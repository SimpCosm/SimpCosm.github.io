<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Houmin" type="application/atom+xml">
  <meta name="google-site-verification" content="zdGhdEF7jHoJW58lsdN6l9JrQFjJFwakCIc7TbbosV0">
  <meta name="msvalidate.01" content="2F527B379ED5537861D0D38C2C754C2B">
  <meta name="baidu-site-verification" content="xAag2PqzKE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="API Server的启动中，我们直到介绍了三种服务Master、CustomResourceDefinitions、Aggrator的创建，但是具体的API的创建部分没有介绍。 本文旨在把这块说清楚，让我们了解整个API Server对外提供了哪些API，这些API是在怎样被注册到服务中去的。我们知道，API Server对外提供的Http&#x2F;Https服务，这都是基于go http服务框架来实现">
<meta name="keywords" content="k8s,apiserver">
<meta property="og:type" content="article">
<meta property="og:title" content="【Kubernetes】Apiserver Api">
<meta property="og:url" content="http://houmin.cc/posts/b4a40ecc/index.html">
<meta property="og:site_name" content="Houmin">
<meta property="og:description" content="API Server的启动中，我们直到介绍了三种服务Master、CustomResourceDefinitions、Aggrator的创建，但是具体的API的创建部分没有介绍。 本文旨在把这块说清楚，让我们了解整个API Server对外提供了哪些API，这些API是在怎样被注册到服务中去的。我们知道，API Server对外提供的Http&#x2F;Https服务，这都是基于go http服务框架来实现">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-11-27T04:00:54.863Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://houmin.cc/posts/b4a40ecc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>【Kubernetes】Apiserver Api | Houmin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="/js/photoswipe.min.js?v="></script>
  <script src="/js/photoswipe-ui-default.min.js?v="></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Houmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Yesterday You Said Tomorrow</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-album">

    <a href="/album" rel="section"><i class="fa fa-fw fa-camera"></i>相册</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://houmin.cc/posts/b4a40ecc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
      <meta itemprop="name" content="Houmin">
      <meta itemprop="description" content="丈夫拥书万卷，何假南面百城">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Houmin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          【Kubernetes】Apiserver Api
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 12:06:11" itemprop="dateCreated datePublished" datetime="2020-08-12T12:06:11+08:00">2020-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/" itemprop="url" rel="index">
                    <span itemprop="name">术业专攻</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/b4a40ecc/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/b4a40ecc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:03</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>API Server的启动中，我们直到介绍了三种服务Master、CustomResourceDefinitions、Aggrator的创建，但是具体的API的创建部分没有介绍。<br> 本文旨在把这块说清楚，让我们了解整个API Server对外提供了哪些API，这些API是在怎样被注册到服务中去的。我们知道，API Server对外提供的Http/Https服务，这都是基于go http服务框架来实现。</p>
<p>API Server支持的HTTP服务采用了go-restful与非go-restful混和的方式，主要是因为go-restful的一些标准无法完全满足需求，而且API Server要兼容旧版本的需要，所以引入了这种混杂模式。</p>
<a id="more"></a>
<p>go-restful是第三方的REST框架，在GitHub上有多个贡献者，采用了“路由”映射的设计思想，并且在API设计中使用了流行的Fluent Style风格，试用起来酣畅淋漓，也难怪Kubernetes选择了它。下面是go-restful的优良特性。</p>
<ul>
<li>Ruby on Rails风格的Rest路由映射，例如/people/{person_id}/groups/{group_id}。</li>
<li>大大简化了Rest API的开发工作。</li>
<li>底层实现采用Golang的HTTP协议栈，几乎没有限制。</li>
<li>拥有完整的单元包代码，很容易开发一个可测试的Rest API。</li>
<li>Google AppEngine ready。</li>
</ul>
<p>go-restful框架中的核心对象如下：</p>
<ul>
<li>restful.Container：代表了一个HTTP Rest服务器，包括一组restful.WebService对象和一个http.ServeMux对象，使用RouteSelector进行请求派发。</li>
<li>restful.WebService：标识一个Rest服务，由多个Rest路由（restful.Route）组成，这一组Rest路由共享同一个RootPath。</li>
<li>restful.Route：标识一个Rest路由，Rest路由主要由Rest Path、HTTP Method、输入输出类型（HTML/JSON）及对应的回调函数restful.RouteFunction组成。</li>
<li>restful.RouteFunction：一个用于处理具体的REST调用的函数接口定义，具体定义为type RouteFunction func(<em>Request, </em>Response)。</li>
</ul>
<h1 id="服务链"><a href="#服务链" class="headerlink" title="服务链"></a>服务链</h1><p>服务链的核心是DelegationTarget接口，它让API Server可以实现链式服务，当有HTTP请求到来时，优先让链首去处理URI，如果能够匹配成功就处理，否则交给下一链，一直到链尾。DelegationTarget的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DelegationTarget <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// UnprotectedHandler returns a handler that is NOT protected by a normal chain</span></span><br><span class="line">    UnprotectedHandler() http.Handler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestContextMapper returns the existing RequestContextMapper.  Because we cannot rewire all existing</span></span><br><span class="line">    <span class="comment">// uses of this function, this will be used in any delegating API server</span></span><br><span class="line">    RequestContextMapper() apirequest.RequestContextMapper</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PostStartHooks returns the post-start hooks that need to be combined</span></span><br><span class="line">    PostStartHooks() <span class="keyword">map</span>[<span class="keyword">string</span>]postStartHookEntry</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PreShutdownHooks returns the pre-stop hooks that need to be combined</span></span><br><span class="line">    PreShutdownHooks() <span class="keyword">map</span>[<span class="keyword">string</span>]preShutdownHookEntry</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HealthzChecks returns the healthz checks that need to be combined</span></span><br><span class="line">    HealthzChecks() []healthz.HealthzChecker</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListedPaths returns the paths for supporting an index</span></span><br><span class="line">    ListedPaths() []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NextDelegate returns the next delegationTarget in the chain of delegations</span></span><br><span class="line">    NextDelegate() DelegationTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>它有一个空的实现emptyDelegate，一般作为链尾，由于是空的实现，所以具体的定义就不列举了。</li>
<li>它的另一个实现是GenericAPIServer，如下所示：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">GenericAPIServer</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">// delegationTarget is the next delegate in the chain or nil</span></span><br><span class="line">    delegationTarget DelegationTarget</span><br><span class="line">    <span class="comment">// HandlerChainWaitGroup allows you to wait for all chain handlers finish after the server shutdown.</span></span><br><span class="line">    HandlerChainWaitGroup *utilwaitgroup.SafeWaitGroup</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>GenericAPIServer定义了一个delegationTarget成员，在API Server整套系统中，总共有三个服务，出了链尾，都是指向GenericAPIServer实例，该成员让GenericAPIServer实现了一套链的功能。</p>
<h1 id="三种服务"><a href="#三种服务" class="headerlink" title="三种服务"></a>三种服务</h1><p>APIServer最终提供链式服务把基本的API Server、CustomResource、Aggregator这三种服务采用链式结构串联起来，对外提供服务。这种链式服务为API Server的可扩展性提供了基础，使增添新的服务功能，不会影响到现有的框架，只需要追加新的服务，放到链中就能够实现。而GenericAPIServer是三种服务的基础，在这三种服务中：<br> Master是API Server的基础服务，它提供的基础资源的API服务；<br> 其他两种CustomResourceDefinitions(简称CRD)、API Server Aggregation(简称AA)，提供了自定义资源的能力。具体见<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="external nofollow noopener noreferrer">自定义资源</a>。</p>
<p>我们看一下对应的三种服务的定义：</p>
<h3 id="基础的API-Server：代码在k8s-io-kubernetes-pkg-master-master-go中"><a href="#基础的API-Server：代码在k8s-io-kubernetes-pkg-master-master-go中" class="headerlink" title="基础的API Server：代码在k8s.io/kubernetes/pkg/master/master.go中"></a>基础的API Server：代码在k8s.io/kubernetes/pkg/master/master.go中</h3><p>Master的结构定义如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Master</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GenericAPIServer *genericapiserver.GenericAPIServer</span><br><span class="line">    ClientCARegistrationHook ClientCARegistrationHook</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Master实例的构建过程中，就完成了API的Install，具体代码见：completedConfig.New，在这里完成了传统API的安装以及新的资源API的安装。在早期的Kubernetes API Server的代码中，只有Master这一种服务，所以一些常见的资源如pods、service等等，都是基于传统的方式安装到REST中，而随着k8s的发展，涌现出了多种资源，而且他们的版本号也不在是v1版本，如：tokenreviews、horizontalpodautoscalers、jobs等等。所以在Master的Install API中，我们可以到InstallAPIS和InstallLegacyAPI。</p>
<ul>
<li>InstallLegacyAPI</li>
</ul>
<p>传统的API都是一些核心资源，他们的GroupName=””，版本都是v1，所以，统一处于一个APIGroupInfo中，相关代码不一一贴出来了，主要的代码逻辑是，创建各种核心资源的REST对象最终组装成<br> map[string]rest.Storage对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">restStorageMap := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;</span><br><span class="line">    <span class="string">"pods"</span>:             podStorage.Pod,</span><br><span class="line">    <span class="string">"pods/attach"</span>:      podStorage.Attach,</span><br><span class="line">    <span class="string">"pods/status"</span>:      podStorage.Status,</span><br><span class="line">    <span class="string">"pods/log"</span>:         podStorage.Log,</span><br><span class="line">    <span class="string">"pods/exec"</span>:        podStorage.Exec,</span><br><span class="line">    <span class="string">"pods/portforward"</span>: podStorage.PortForward,</span><br><span class="line">    <span class="string">"pods/proxy"</span>:       podStorage.Proxy,</span><br><span class="line">    <span class="string">"pods/binding"</span>:     podStorage.Binding,</span><br><span class="line">    <span class="string">"bindings"</span>:         podStorage.Binding,</span><br><span class="line"></span><br><span class="line">    <span class="string">"podTemplates"</span>: podTemplateStorage,</span><br><span class="line"></span><br><span class="line">    <span class="string">"replicationControllers"</span>:        controllerStorage.Controller,</span><br><span class="line">    <span class="string">"replicationControllers/status"</span>: controllerStorage.Status,</span><br><span class="line"></span><br><span class="line">    <span class="string">"services"</span>:        serviceRest.Service,</span><br><span class="line">    <span class="string">"services/proxy"</span>:  serviceRest.Proxy,</span><br><span class="line">    <span class="string">"services/status"</span>: serviceStatusStorage,</span><br><span class="line"></span><br><span class="line">    <span class="string">"endpoints"</span>: endpointsStorage,</span><br><span class="line"></span><br><span class="line">    <span class="string">"nodes"</span>:        nodeStorage.Node,</span><br><span class="line">    <span class="string">"nodes/status"</span>: nodeStorage.Status,</span><br><span class="line">    <span class="string">"nodes/proxy"</span>:  nodeStorage.Proxy,</span><br><span class="line"></span><br><span class="line">    <span class="string">"events"</span>: eventStorage,</span><br><span class="line"></span><br><span class="line">    <span class="string">"limitRanges"</span>:                   limitRangeStorage,</span><br><span class="line">    <span class="string">"resourceQuotas"</span>:                resourceQuotaStorage,</span><br><span class="line">    <span class="string">"resourceQuotas/status"</span>:         resourceQuotaStatusStorage,</span><br><span class="line">    <span class="string">"namespaces"</span>:                    namespaceStorage,</span><br><span class="line">    <span class="string">"namespaces/status"</span>:             namespaceStatusStorage,</span><br><span class="line">    <span class="string">"namespaces/finalize"</span>:           namespaceFinalizeStorage,</span><br><span class="line">    <span class="string">"secrets"</span>:                       secretStorage,</span><br><span class="line">    <span class="string">"serviceAccounts"</span>:               serviceAccountStorage,</span><br><span class="line">    <span class="string">"persistentVolumes"</span>:             persistentVolumeStorage,</span><br><span class="line">    <span class="string">"persistentVolumes/status"</span>:      persistentVolumeStatusStorage,</span><br><span class="line">    <span class="string">"persistentVolumeClaims"</span>:        persistentVolumeClaimStorage,</span><br><span class="line">    <span class="string">"persistentVolumeClaims/status"</span>: persistentVolumeClaimStatusStorage,</span><br><span class="line">    <span class="string">"configMaps"</span>:                    configMapStorage,</span><br><span class="line"></span><br><span class="line">    <span class="string">"componentStatuses"</span>: componentstatus.NewStorage(componentStatusStorage&#123;c.StorageFactory&#125;.serversToValidate),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> legacyscheme.Registry.IsEnabledVersion(schema.GroupVersion&#123;Group: <span class="string">"autoscaling"</span>, Version: <span class="string">"v1"</span>&#125;) &#123;</span><br><span class="line">    restStorageMap[<span class="string">"replicationControllers/scale"</span>] = controllerStorage.Scale</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> legacyscheme.Registry.IsEnabledVersion(schema.GroupVersion&#123;Group: <span class="string">"policy"</span>, Version: <span class="string">"v1beta1"</span>&#125;) &#123;</span><br><span class="line">    restStorageMap[<span class="string">"pods/eviction"</span>] = podStorage.Eviction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个数据结构map[string]rest.Storage是key是REST的path，所以很明显它是API暴漏的关键，我们在后面也会陆续讲到，请参考Installer章节。</p>
<ul>
<li>现代的API<br> 其实后面的CRD与AA都是采用这种模式，但是Master中封装的更好。它对各种新的资源实现了相应的RESTStorageProvider，接口定义如下：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type RESTStorageProvider <span class="keyword">interface</span> &#123;</span><br><span class="line">    GroupName() <span class="keyword">string</span></span><br><span class="line">    NewRESTStorage(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter) (genericapiserver.APIGroupInfo, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RESTStorageProvider实现为REST storage的工厂，这样每个资源实现自己的NewRESTStorage方法，并构建相应的APIGroupInfo。相应的资源为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">restStorageProviders := []<span class="type">RESTStorageProvider</span>&#123;</span><br><span class="line">    authenticationrest.<span class="type">RESTStorageProvider</span>&#123;<span class="type">Authenticator</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">Authenticator</span>&#125;,</span><br><span class="line">    authorizationrest.<span class="type">RESTStorageProvider</span>&#123;<span class="type">Authorizer</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">Authorizer</span>, <span class="type">RuleResolver</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">RuleResolver</span>&#125;,</span><br><span class="line">    autoscalingrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    batchrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    certificatesrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    extensionsrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    networkingrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    policyrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    rbacrest.<span class="type">RESTStorageProvider</span>&#123;<span class="type">Authorizer</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">Authorizer</span>&#125;,</span><br><span class="line">    schedulingrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    settingsrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    storagerest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    <span class="comment">// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.</span></span><br><span class="line">    <span class="comment">// See https://github.com/kubernetes/kubernetes/issues/42392</span></span><br><span class="line">    appsrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    admissionregistrationrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">    eventsrest.<span class="type">RESTStorageProvider</span>&#123;<span class="type">TTL</span>: <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">EventTTL</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义资源服务：代码在k8s-io-apiextensions-apiserver-pkg-apiserver-apiserver-go中"><a href="#自定义资源服务：代码在k8s-io-apiextensions-apiserver-pkg-apiserver-apiserver-go中" class="headerlink" title="自定义资源服务：代码在k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go中"></a>自定义资源服务：代码在k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go中</h3><p>自定义资源服务的结构代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CustomResourceDefinitions</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GenericAPIServer *genericapiserver.GenericAPIServer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provided for easier embedding</span></span><br><span class="line">    Informers internalinformers.SharedInformerFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义资源服务的API的安装也是在completedConfig.New中完成，API较少，相关的代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(apiextensions.GroupName, Registry, Scheme, metav1.ParameterCodec, Codecs)</span><br><span class="line"><span class="keyword">if</span> apiResourceConfig.VersionEnabled(v1beta1.SchemeGroupVersion) &#123;</span><br><span class="line">    apiGroupInfo.GroupMeta.GroupVersion = v1beta1.SchemeGroupVersion</span><br><span class="line">    storage := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;</span><br><span class="line">    <span class="comment">// customresourcedefinitions</span></span><br><span class="line">    customResourceDefintionStorage := customresourcedefinition.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)</span><br><span class="line">    storage[<span class="string">"customresourcedefinitions"</span>] = customResourceDefintionStorage</span><br><span class="line">    storage[<span class="string">"customresourcedefinitions/status"</span>] = customresourcedefinition.NewStatusREST(Scheme, customResourceDefintionStorage)</span><br><span class="line"></span><br><span class="line">    apiGroupInfo.VersionedResourcesStorageMap[<span class="string">"v1beta1"</span>] = storage</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 安装到ApiServerHandler的GoRestfulContainer，基于Go-restful框架的服务</span></span><br><span class="line">    <span class="comment">// 提供了customresourcedefinitions资源的服务能力</span></span><br><span class="line"><span class="keyword">if</span> err := s.GenericAPIServer.InstallAPIGroup(&amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">crdHandler := NewCustomResourceDefinitionHandler(</span><br><span class="line">    versionDiscoveryHandler,</span><br><span class="line">    groupDiscoveryHandler,</span><br><span class="line">    s.GenericAPIServer.RequestContextMapper(),</span><br><span class="line">    s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions(),</span><br><span class="line">    delegateHandler,</span><br><span class="line">    c.ExtraConfig.CRDRESTOptionsGetter,</span><br><span class="line">    c.GenericConfig.AdmissionControl,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 安装到ApiServerHandler的NonGoRestfulMux，基于go-http普通框架的服务</span></span><br><span class="line"><span class="comment">// crdHandler提供自定义资源的API功能，主要包括资源的以下操作：</span></span><br><span class="line"><span class="comment">// get/list/watch/create/udpate/patch/delete/deletecollection</span></span><br><span class="line">s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">"/apis"</span>, crdHandler)</span><br><span class="line">s.GenericAPIServer.Handler.NonGoRestfulMux.HandlePrefix(<span class="string">"/apis/"</span>, crdHandler)</span><br></pre></td></tr></table></figure>
<p>在New方法中，除了上述API的安装外，还有crd、naming、finalizing控制器以及各种Informers，有必要去看待吗，这里不列举。</p>
<h3 id="AggregateServer-：代码在k8s-io-kube-aggregator-pkg-apiserver-apiserver-go中"><a href="#AggregateServer-：代码在k8s-io-kube-aggregator-pkg-apiserver-apiserver-go中" class="headerlink" title="AggregateServer ：代码在k8s.io/kube-aggregator/pkg/apiserver/apiserver.go中"></a>AggregateServer ：代码在k8s.io/kube-aggregator/pkg/apiserver/apiserver.go中</h3><p>主K8S API Server处理built-in资源，如Pods和Services等等，而CRD能够让我们实现了一些通用的自定义资源。<br> AggregateServer实现了API Server Aggregation功能，它让我们可以提供自定义资源的特殊实现，并且部署我们独立API Server，主API Server把请求代理给独立的API Server来处理自定义资源，从而让资源对它的所有的客户端可用。</p>
<p>AggregatorServer的构建代码也是对应的completeConfig.NewWithDelegate方法中完成，该方法带了一个参数，参数的实例基于主API Server对应的GenericAPIServer实例。</p>
<p>AggregatorServer启动了APIServer的共享通知： &amp;apiregistration.APIService{}，基于共享通知的消息，在两个控制器中进行处理：apiserviceRegistrationController和availableController。</p>
<p>在API的处理上也是分为两部分：</p>
<ul>
<li>go-restful部分，也是基于APIGroupInfo来安装API，见k8s.io/kube-aggregator/pkg/registry/apiservice/rest/storage_apiservice.go中的NewRESTStorage方法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRESTStorage</span><span class="params">(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter)</span> <span class="title">genericapiserver</span>.<span class="title">APIGroupInfo</span></span> &#123;</span><br><span class="line">    apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(apiregistration.GroupName, aggregatorscheme.Registry, aggregatorscheme.Scheme, metav1.ParameterCodec, aggregatorscheme.Codecs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> apiResourceConfigSource.VersionEnabled(v1beta1.SchemeGroupVersion) &#123;</span><br><span class="line">        apiGroupInfo.GroupMeta.GroupVersion = v1beta1.SchemeGroupVersion</span><br><span class="line">        storage := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;</span><br><span class="line">        apiServiceREST := apiservicestorage.NewREST(aggregatorscheme.Scheme, restOptionsGetter)</span><br><span class="line">        storage[<span class="string">"apiservices"</span>] = apiServiceREST</span><br><span class="line">        storage[<span class="string">"apiservices/status"</span>] = apiservicestorage.NewStatusREST(aggregatorscheme.Scheme, apiServiceREST)</span><br><span class="line">        apiGroupInfo.VersionedResourcesStorageMap[<span class="string">"v1beta1"</span>] = storage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> apiResourceConfigSource.VersionEnabled(v1.SchemeGroupVersion) &#123;</span><br><span class="line">        apiGroupInfo.GroupMeta.GroupVersion = v1.SchemeGroupVersion</span><br><span class="line">        storage := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;</span><br><span class="line">        apiServiceREST := apiservicestorage.NewREST(aggregatorscheme.Scheme, restOptionsGetter)</span><br><span class="line">        storage[<span class="string">"apiservices"</span>] = apiServiceREST</span><br><span class="line">        storage[<span class="string">"apiservices/status"</span>] = apiservicestorage.NewStatusREST(aggregatorscheme.Scheme, apiServiceREST)</span><br><span class="line">        apiGroupInfo.VersionedResourcesStorageMap[<span class="string">"v1"</span>] = storage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> apiGroupInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，根据是否启用v1beta1和v1版本，实现了apiservice和apiservices/status两种资源类型。</p>
<ul>
<li>non-go-restful部分，见:k8s.io/kubu-aggregator/pkg/apiserver/handler_apis.go中的apisHandler结构<br> apisHanders服务与/apis端，它实现了http.Handler，下面是它的ServeHTTP方法的代码实现：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *apisHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    ctx, ok := r.mapper.Get(req)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        responsewriters.InternalError(w, req, errors.New(<span class="string">"no context found for request"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    discoveryGroupList := &amp;metav1.APIGroupList&#123;</span><br><span class="line">        <span class="comment">// always add OUR api group to the list first.  Since we'll never have a registered APIService for it</span></span><br><span class="line">        <span class="comment">// and since this is the crux of the API, having this first will give our names priority.  It's good to be king.</span></span><br><span class="line">        Groups: []metav1.APIGroup&#123;discoveryGroup&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apiServices, err := r.lister.List(labels.Everything())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    apiServicesByGroup := apiregistrationapi.SortedByGroupAndVersion(apiServices)</span><br><span class="line">    <span class="keyword">for</span> _, apiGroupServers := <span class="keyword">range</span> apiServicesByGroup &#123;</span><br><span class="line">        <span class="comment">// skip the legacy group</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apiGroupServers[<span class="number">0</span>].Spec.Group) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        discoveryGroup := convertToDiscoveryAPIGroup(apiGroupServers)</span><br><span class="line">        <span class="keyword">if</span> discoveryGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">            discoveryGroupList.Groups = <span class="built_in">append</span>(discoveryGroupList.Groups, *discoveryGroup)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responsewriters.WriteObjectNegotiated(ctx, r.codecs, schema.GroupVersion&#123;&#125;, w, req, http.StatusOK, discoveryGroupList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问：看起来apisHandlers的目的是把找到的合适的api server返回？这点我没有搞明白，理论上，AA应该是做代理功能，把请求转发给对应的自定义API Servers去处理才对。</p>
<p>ANSWER：明白了，apisHandlers其实就是ROOT路径/apis的服务器，本来是由GenericAPIServer.DiscoveryGroupManager来实现这个功能的，但是AA需要实时获取注册进来的自定义API Servers信息，并且AA相关信息总是放在/apis相应的头部，如下所示：（没有自定义的API Servers的情况）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yuxianbing@ubuntu<span class="symbol">:~</span>$ curl <span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8080/apis</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"kind"</span>: <span class="string">"APIGroupList"</span>,</span><br><span class="line">  <span class="string">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">  <span class="string">"groups"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"apiregistration.k8s.io"</span>,</span><br><span class="line">      <span class="string">"versions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"groupVersion"</span>: <span class="string">"apiregistration.k8s.io/v1"</span>,</span><br><span class="line">          <span class="string">"version"</span>: <span class="string">"v1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"groupVersion"</span>: <span class="string">"apiregistration.k8s.io/v1beta1"</span>,</span><br><span class="line">          <span class="string">"version"</span>: <span class="string">"v1beta1"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"preferredVersion"</span>: &#123;</span><br><span class="line">        <span class="string">"groupVersion"</span>: <span class="string">"apiregistration.k8s.io/v1"</span>,</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"v1"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"serverAddressByClientCIDRs"</span>: null</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<h1 id="GenericAPIServer"><a href="#GenericAPIServer" class="headerlink" title="GenericAPIServer"></a>GenericAPIServer</h1><p>下面是GenericAPIServer的完整定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericAPIServer contains state for a Kubernetes cluster api server.</span></span><br><span class="line">type GenericAPIServer <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// discoveryAddresses is used to build cluster IPs for discovery.</span></span><br><span class="line">    discoveryAddresses discovery.Addresses</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoopbackClientConfig is a config for a privileged loopback connection to the API server</span></span><br><span class="line">    LoopbackClientConfig *restclient.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minRequestTimeout is how short the request timeout can be.  This is used to build the RESTHandler</span></span><br><span class="line">    minRequestTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ShutdownTimeout is the timeout used for server shutdown. This specifies the timeout before server</span></span><br><span class="line">    <span class="comment">// gracefully shutdown returns.</span></span><br><span class="line">    ShutdownTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// legacyAPIGroupPrefixes is used to set up URL parsing for authorization and for validating requests</span></span><br><span class="line">    <span class="comment">// to InstallLegacyAPIGroup</span></span><br><span class="line">    legacyAPIGroupPrefixes sets.String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admissionControl is used to build the RESTStorage that backs an API Group.</span></span><br><span class="line">    admissionControl admission.Interface</span><br><span class="line"></span><br><span class="line">    <span class="comment">// requestContextMapper provides a way to get the context for a request.  It may be nil.</span></span><br><span class="line">    requestContextMapper apirequest.RequestContextMapper</span><br><span class="line"></span><br><span class="line">    SecureServingInfo *SecureServingInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExternalAddress is the address (hostname or IP and port) that should be used in</span></span><br><span class="line">    <span class="comment">// external (public internet) URLs for this GenericAPIServer.</span></span><br><span class="line">    ExternalAddress <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serializer controls how common API objects not in a group/version prefix are serialized for this server.</span></span><br><span class="line">    <span class="comment">// Individual APIGroups may define their own serializers.</span></span><br><span class="line">    Serializer runtime.NegotiatedSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "Outputs"</span></span><br><span class="line">    <span class="comment">// Handler holds the handlers being used by this API server</span></span><br><span class="line">        <span class="comment">// 实现了API Server对外的API功能，主要包括两个部分：go-restful和non-go-restful。</span></span><br><span class="line">    Handler *APIServerHandler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listedPathProvider is a lister which provides the set of paths to show at /</span></span><br><span class="line">    listedPathProvider routes.ListedPathProvider</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DiscoveryGroupManager serves /apis</span></span><br><span class="line">        <span class="comment">// 一般用于实现/apis的服务，从/apis的输出来看，基本上显示的是各个Group的API与版本的信息。</span></span><br><span class="line">    DiscoveryGroupManager discovery.GroupManager</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable swagger and/or OpenAPI if these configs are non-nil.</span></span><br><span class="line">    swaggerConfig *swagger.Config</span><br><span class="line">    openAPIConfig *openapicommon.Config</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PostStartHooks are each called after the server has started listening, in a separate go func for each</span></span><br><span class="line">    <span class="comment">// with no guarantee of ordering between them.  The map key is a name used for error reporting.</span></span><br><span class="line">    <span class="comment">// It may kill the process with a panic if it wishes to by returning an error.</span></span><br><span class="line">    postStartHookLock      sync.Mutex</span><br><span class="line">    postStartHooks         <span class="built_in">map</span>[<span class="built_in">string</span>]postStartHookEntry</span><br><span class="line">    postStartHooksCalled   <span class="keyword">bool</span></span><br><span class="line">    disabledPostStartHooks sets.String</span><br><span class="line"></span><br><span class="line">    preShutdownHookLock    sync.Mutex</span><br><span class="line">    preShutdownHooks       <span class="built_in">map</span>[<span class="built_in">string</span>]preShutdownHookEntry</span><br><span class="line">    preShutdownHooksCalled <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// healthz checks</span></span><br><span class="line">    healthzLock    sync.Mutex</span><br><span class="line">    healthzChecks  []healthz.HealthzChecker</span><br><span class="line">    healthzCreated <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// auditing. The backend is started after the server starts listening.</span></span><br><span class="line">    AuditBackend audit.Backend</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enableAPIResponseCompression indicates whether API Responses should support compression</span></span><br><span class="line">    <span class="comment">// if the client requests it via Accept-Encoding</span></span><br><span class="line">    enableAPIResponseCompression <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegationTarget is the next delegate in the chain or nil</span></span><br><span class="line">        <span class="comment">// 实现链式结构，一般指向的实例类型也是GenericAPIServer</span></span><br><span class="line">    delegationTarget DelegationTarget</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HandlerChainWaitGroup allows you to wait for all chain handlers finish after the server shutdown.</span></span><br><span class="line">    HandlerChainWaitGroup *utilwaitgroup.SafeWaitGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GenericAPIServer里面包含了几个重要的成员，首先是APIServerHandler类型的Handler成员，它存储了该Server所服务的API，后面要讲到的API的安装功能，主要就是把要服务的资源对应的API存储在Handler中的GoRestfulContainer中。</p>
<blockquote>
<p>APIServerHandler包含了API Server使用的多种http.Handler类型，包括go-restful以及non-go-restful，以及在以上两者之间选择的Director对象，API URI处理的选择过程为：FullHandlerChain-&gt; Director -&gt;{GoRestfulContainer， NonGoRestfulMux}。</p>
</blockquote>
<p>其次是DiscoveryGroupManager，它负责存储支持的API的Group和Version信息，并提供对/apis的调用服务。</p>
<h3 id="APIGroupInfo"><a href="#APIGroupInfo" class="headerlink" title="APIGroupInfo"></a>APIGroupInfo</h3><p>前面在三个API Server的API安装中，提到过go-restful模式的API安装都用到了APIGroupInfo，一般都是先生成一个APIGroupInfo实例，在该实例中，把我们关心的资源类型存好，然后调用GenericAPIServer.InstallAPIGroup完成API的Install操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Info about an API group.</span></span><br><span class="line">type APIGroupInfo <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GroupMeta apimachinery.GroupMeta</span><br><span class="line">    <span class="comment">// Info about the resources in this group. Its a map from version to resource to the storage.</span></span><br><span class="line">    VersionedResourcesStorageMap <span class="built_in">map</span>[<span class="built_in">string</span>]<span class="built_in">map</span>[<span class="built_in">string</span>]rest.Storage</span><br><span class="line">    <span class="comment">// OptionsExternalVersion controls the APIVersion used for common objects in the</span></span><br><span class="line">    <span class="comment">// schema like api.Status, api.DeleteOptions, and metav1.ListOptions. Other implementors may</span></span><br><span class="line">    <span class="comment">// define a version "v1beta1" but want to use the Kubernetes "v1" internal objects.</span></span><br><span class="line">    <span class="comment">// If nil, defaults to groupMeta.GroupVersion.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Remove this when https://github.com/kubernetes/kubernetes/issues/19018 is fixed.</span></span><br><span class="line">    OptionsExternalVersion *schema.GroupVersion</span><br><span class="line">    <span class="comment">// MetaGroupVersion defaults to "meta.k8s.io/v1" and is the scheme group version used to decode</span></span><br><span class="line">    <span class="comment">// common API implementations like ListOptions. Future changes will allow this to vary by group</span></span><br><span class="line">    <span class="comment">// version (for when the inevitable meta/v2 group emerges).</span></span><br><span class="line">    MetaGroupVersion *schema.GroupVersion</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scheme includes all of the types used by this group and how to convert between them (or</span></span><br><span class="line">    <span class="comment">// to convert objects from outside of this group that are accepted in this API).</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace with interfaces</span></span><br><span class="line">    Scheme *runtime.Scheme</span><br><span class="line">    <span class="comment">// NegotiatedSerializer controls how this group encodes and decodes data</span></span><br><span class="line">    NegotiatedSerializer runtime.NegotiatedSerializer</span><br><span class="line">    <span class="comment">// ParameterCodec performs conversions for query parameters passed to API calls</span></span><br><span class="line">    ParameterCodec runtime.ParameterCodec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GenericAPIServer-InstallAPIGroup"><a href="#GenericAPIServer-InstallAPIGroup" class="headerlink" title="GenericAPIServer.InstallAPIGroup"></a>GenericAPIServer.InstallAPIGroup</h3><p>InstallAPIGroup负责把给定的API Group暴漏到API中，主要功能有两块：</p>
<ul>
<li>调用installAPIResources实现资源API的暴漏</li>
<li>API Group的的服务，为了/apis和/apis/<groupname>两种服务，其中/apis通过把信息存放在DiscoveryGroupManager成员中，/apis/<groupname>的通过构建APIGroupHandler，并存放到GoRestfulContainer中。</groupname></groupname></li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">InstallAPIGroup</span><span class="params">(apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do not register empty group or empty version.  Doing so claims /apis/ for the wrong entity to be returned.</span></span><br><span class="line">    <span class="comment">// Catching these here places the error  much closer to its origin</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(apiGroupInfo.GroupMeta.GroupVersion.Group) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot register handler with an empty group for %#v"</span>, *apiGroupInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(apiGroupInfo.GroupMeta.GroupVersion.Version) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot register handler with an empty version for %#v"</span>, *apiGroupInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里实现资源的API暴漏</span></span><br><span class="line">    <span class="keyword">if</span> err := s.installAPIResources(APIGroupPrefix, apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup discovery</span></span><br><span class="line">    <span class="comment">// Install the version handler.</span></span><br><span class="line">    <span class="comment">// Add a handler at /apis/&lt;groupName&gt; to enumerate all versions supported by this group.</span></span><br><span class="line">    apiVersionsForDiscovery := []metav1.GroupVersionForDiscovery&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.GroupMeta.GroupVersions &#123;</span><br><span class="line">        <span class="comment">// Check the config to make sure that we elide versions that don't have any resources</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        apiVersionsForDiscovery = <span class="built_in">append</span>(apiVersionsForDiscovery, metav1.GroupVersionForDiscovery&#123;</span><br><span class="line">            GroupVersion: groupVersion.String(),</span><br><span class="line">            Version:      groupVersion.Version,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    preferredVersionForDiscovery := metav1.GroupVersionForDiscovery&#123;</span><br><span class="line">        GroupVersion: apiGroupInfo.GroupMeta.GroupVersion.String(),</span><br><span class="line">        Version:      apiGroupInfo.GroupMeta.GroupVersion.Version,</span><br><span class="line">    &#125;</span><br><span class="line">    apiGroup := metav1.APIGroup&#123;</span><br><span class="line">        Name:             apiGroupInfo.GroupMeta.GroupVersion.Group,</span><br><span class="line">        Versions:         apiVersionsForDiscovery,</span><br><span class="line">        PreferredVersion: preferredVersionForDiscovery,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把该API Group信息存储到DiscoveryGroupManager中，让后续暴漏的/apis中使用</span></span><br><span class="line">    s.DiscoveryGroupManager.AddGroup(apiGroup)</span><br><span class="line">    <span class="comment">// 生成APIGrouphandler</span></span><br><span class="line">    s.Handler.GoRestfulContainer.Add(discovery.NewAPIGroupHandler(s.Serializer, apiGroup, s.requestContextMapper).WebService())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GenericAPIServer-installAPIResources"><a href="#GenericAPIServer-installAPIResources" class="headerlink" title="GenericAPIServer.installAPIResources"></a>GenericAPIServer.installAPIResources</h3><p>installAPIResources是一个用于安装REST存储的私有方法，用来支撑各种api groupversionresource。该函数的代码逻辑非常简单，它循环扫描APIGroupInfo.GroupMeta.GroupVersions成员，生成相应的APIGroupVersion实例，并通过InstallREST方法把该GroupVersion的资源注册服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">installAPIResources</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.GroupMeta.GroupVersions &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]) == <span class="number">0</span> &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"Skipping API %v because it has no resources."</span>, groupVersion)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 这里生成APIGroupVersion实例，是REST API的关键</span></span><br><span class="line">        apiGroupVersion := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)</span><br><span class="line">        <span class="keyword">if</span> apiGroupInfo.OptionsExternalVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">            apiGroupVersion.OptionsExternalVersion = apiGroupInfo.OptionsExternalVersion</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"Unable to setup API %v: %v"</span>, apiGroupInfo, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getApiGropuVersion的代码如下，它通过组装了所有的资源对应的storage，并生成了APIGroupVersion实例，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">getAPIGroupVersion</span><span class="params">(apiGroupInfo *APIGroupInfo, groupVersion schema.GroupVersion, apiPrefix <span class="keyword">string</span>)</span> *<span class="title">genericapi</span>.<span class="title">APIGroupVersion</span></span> &#123;</span><br><span class="line">    storage := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version] &#123;</span><br><span class="line">        storage[strings.ToLower(k)] = v</span><br><span class="line">    &#125;</span><br><span class="line">    version := s.newAPIGroupVersion(apiGroupInfo, groupVersion)</span><br><span class="line">    version.Root = apiPrefix</span><br><span class="line">    version.Storage = storage</span><br><span class="line">    <span class="keyword">return</span> version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>APIGroupVersion是区分API版本的关键，以下是代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type APIGroupVersion <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Storage <span class="built_in">map</span>[<span class="built_in">string</span>]rest.Storage</span><br><span class="line"></span><br><span class="line">    Root <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GroupVersion is the external group version</span></span><br><span class="line">    GroupVersion schema.GroupVersion</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OptionsExternalVersion controls the Kubernetes APIVersion used for common objects in the apiserver</span></span><br><span class="line">    <span class="comment">// schema like api.Status, api.DeleteOptions, and metav1.ListOptions. Other implementors may</span></span><br><span class="line">    <span class="comment">// define a version "v1beta1" but want to use the Kubernetes "v1" internal objects. If</span></span><br><span class="line">    <span class="comment">// empty, defaults to GroupVersion.</span></span><br><span class="line">    OptionsExternalVersion *schema.GroupVersion</span><br><span class="line">    <span class="comment">// MetaGroupVersion defaults to "meta.k8s.io/v1" and is the scheme group version used to decode</span></span><br><span class="line">    <span class="comment">// common API implementations like ListOptions. Future changes will allow this to vary by group</span></span><br><span class="line">    <span class="comment">// version (for when the inevitable meta/v2 group emerges).</span></span><br><span class="line">    MetaGroupVersion *schema.GroupVersion</span><br><span class="line"></span><br><span class="line">    Mapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Serializer is used to determine how to convert responses from API methods into bytes to send over</span></span><br><span class="line">    <span class="comment">// the wire.</span></span><br><span class="line">    Serializer     runtime.NegotiatedSerializer</span><br><span class="line">    ParameterCodec runtime.ParameterCodec</span><br><span class="line"></span><br><span class="line">    Typer           runtime.ObjectTyper</span><br><span class="line">    Creater         runtime.ObjectCreater</span><br><span class="line">    Convertor       runtime.ObjectConvertor</span><br><span class="line">    Defaulter       runtime.ObjectDefaulter</span><br><span class="line">    Linker          runtime.SelfLinker</span><br><span class="line">    UnsafeConvertor runtime.ObjectConvertor</span><br><span class="line"></span><br><span class="line">    Admit   admission.Interface</span><br><span class="line">    Context request.RequestContextMapper</span><br><span class="line"></span><br><span class="line">    MinRequestTimeout time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EnableAPIResponseCompression indicates whether API Responses should support compression</span></span><br><span class="line">    <span class="comment">// if the client requests it via Accept-Encoding</span></span><br><span class="line">    EnableAPIResponseCompression <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>storage<br> 前面在构建APIGroupVersion 实例的过程中，我们看到第一个成员Storage的身影，这个变量我们要分析清楚，它类型为map[string]rest.Storage。所以storage变量是一个Map，Key为Rest API的path ,Value为rest.Storage接口，此接口是一个通用的符合Restful要求的资源存储服务接口，每个服务接口负责处理一类（Kind）Kubernetes API中的数据对象——-资源你数据，只有一个接口方法：New()，New()方法返回该Storage服务所能识别和管理的某种具体的资源数据逇一个空实例。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Storage <span class="class"><span class="keyword">interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// New returns an empty object that can be used with Create and Update after request data has been put into it.</span></span><br><span class="line">    <span class="comment">// This object must be a pointer type for use with Codec.DecodeInto([]byte, runtime.Object)</span></span><br><span class="line">    New() runtime.<span class="built_in">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行期间，Kubernetes API Runtime运行时框架会把New()方法返回的空对象的指针传入Codec.DecodeInto([]byte, runtime.Object)方法中，从而完成HTTP Rest请求中的Byte数组反序列化逻辑。Kubernetes API Server中所有对外提供服务的Restful资源都实现了此接口，这些资源包括pods、bindings、podTemplates、replicationControllers、services等，三个服务都有自己的列表，其中CRD和AA我们已经在前面的讲解中把代码贴出来了。而Master这块其实有两块资源安装：最新的资源以及传统资源模式，后面单独介绍这块。</p>
<p>APIGroupVersion是与rest.Storage Map绑定的，并且绑定了相应版本的Codec、Convertor用于版本转换，这样就很容易理解Kubernetes是怎么区分多版本API的Rest服务的。</p>
<ul>
<li>InstallREST<br> 在APIGroupVersion的InstallREST(constainer *restful.Container)方法里，用Version变量来构造一个Rest API Path的前缀并赋值给APIInstall的prefix变量，并调用他的Install()方法完成Rest API的转换，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *APIGroupVersion)</span> <span class="title">InstallREST</span><span class="params">(container *restful.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    prefix := path.Join(g.Root, g.GroupVersion.Group, g.GroupVersion.Version)</span><br><span class="line">    installer := &amp;APIInstaller&#123;</span><br><span class="line">        group:                        g,</span><br><span class="line">        prefix:                       prefix,</span><br><span class="line">        minRequestTimeout:            g.MinRequestTimeout,</span><br><span class="line">        enableAPIResponseCompression: g.EnableAPIResponseCompression,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apiResources, ws, registrationErrors := installer.Install()</span><br><span class="line">    versionDiscoveryHandler := discovery.NewAPIVersionHandler(g.Serializer, g.GroupVersion, staticLister&#123;apiResources&#125;, g.Context)</span><br><span class="line">    versionDiscoveryHandler.AddToWebService(ws)</span><br><span class="line">    container.Add(ws)</span><br><span class="line">    <span class="keyword">return</span> utilerrors.NewAggregate(registrationErrors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>APIInstall.Install<br> 接着，在APIInstaller的Install()方法里用prefix(API版本)前缀生成WebService的相对根路径：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span> <span class="title">newWebService</span><span class="params">()</span> *<span class="title">restful</span>.<span class="title">WebService</span></span> &#123;</span><br><span class="line">    ws := <span class="built_in">new</span>(restful.WebService)</span><br><span class="line">    ws.Path(a.prefix)</span><br><span class="line">    <span class="comment">// a.prefix contains "prefix/group/version"</span></span><br><span class="line">    ws.Doc(<span class="string">"API at "</span> + a.prefix)</span><br><span class="line">    <span class="comment">// Backwards compatibility, we accepted objects with empty content-type at V1.</span></span><br><span class="line">    <span class="comment">// If we stop using go-restful, we can default empty content-type to application/json on an</span></span><br><span class="line">    <span class="comment">// endpoint by endpoint basis</span></span><br><span class="line">    ws.Consumes(<span class="string">"*/*"</span>)</span><br><span class="line">    mediaTypes, streamMediaTypes := negotiation.MediaTypesForSerializer(a.group.Serializer)</span><br><span class="line">    ws.Produces(<span class="built_in">append</span>(mediaTypes, streamMediaTypes...)...)</span><br><span class="line">    ws.ApiVersion(a.group.GroupVersion.String())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何实现多版本支持呢？</li>
</ul>
<p>以前面我们列举过的k8s.io/kube-aggregator/pkg/registry/apiservice/rest/storage_apiservice.go中的NewRESTStorage方法中，可以看到，根据是否启用了v1beta1与v1版本的API，我们生成了不同的APIGroupInfo，如果同时启用了v1beta1与v1版本的话，最终调用APIGroupVersion的InstallREST方法，从而完成了最终的多版本API的Rest服务装配流程。</p>
<h3 id="APIInstaller"><a href="#APIInstaller" class="headerlink" title="APIInstaller"></a>APIInstaller</h3><p>前面我们多次讲到map[string]rest.Storage，从Master（传统模式与现代模式）、CRD、AA三个服务InstallGroupInfo中，都最终生成了这样一个Map实例。</p>
<p>这个Map的Key是Rest API的访问路径，Value却不是之前说好的restful.Route。所以必须存在一个“转换适配”的方法来实现上述转换！转化你的方法在pkg/apiserver/api_install.go的下属方法里：<br> func (a <em>APIInstaller) registerResoruceHandlers(path string, storage rest.Storage, ws </em>restful.WebService, proxyHandler http.Handler)</p>
<p>上述方法把一个path对应的rest.Storage转换成一系列的restful.Route并添加到指针restful.WebService中。这个函数的代码之所以很长，是因为有各种情况要考虑，比如pods/portforward这种路径要处理child，还要判断美中Storage资源类型锁支持的操作类型：比如是否支持create、delete、update及是否支持list、watch、pathcer等，对各种情况都考虑以后，这个函数的代码量已经超过500行！于是在外面封装了一个简单函数：func (a *APIInstlal)Install，内部循环调用registerResourceHandlers，返回最终的restful.WebService对象，次方法的主要代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span> <span class="title">Install</span><span class="params">()</span> <span class="params">([]metav1.APIResource, *restful.WebService, []error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> apiResources []metav1.APIResource</span><br><span class="line">    <span class="keyword">var</span> errors []error</span><br><span class="line">    ws := a.newWebService()</span><br><span class="line"></span><br><span class="line">    proxyHandler := (&amp;handlers.ProxyHandler&#123;</span><br><span class="line">        Prefix:     a.prefix + <span class="string">"/proxy/"</span>,</span><br><span class="line">        Storage:    a.group.Storage,</span><br><span class="line">        Serializer: a.group.Serializer,</span><br><span class="line">        Mapper:     a.group.Context,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the paths in a deterministic (sorted) order to get a deterministic swagger spec.</span></span><br><span class="line">    paths := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(a.group.Storage))</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> a.group.Storage &#123;</span><br><span class="line">        paths[i] = path</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(paths)</span><br><span class="line">    <span class="keyword">for</span> _, path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">        apiResource, err := a.registerResourceHandlers(path, a.group.Storage[path], ws, proxyHandler)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errors = <span class="built_in">append</span>(errors, fmt.Errorf(<span class="string">"error in registering resource: %s, %v"</span>, path, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> apiResource != <span class="literal">nil</span> &#123;</span><br><span class="line">            apiResources = <span class="built_in">append</span>(apiResources, *apiResource)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> apiResources, ws, errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Install()方法循环调用了registerResourceHandlers函数，该函数实现了rest.Storage到restful.Route的转换，由于该函数代码比较长，这里只列举相关的片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">creater, isCreater := storage.(rest.Creater)</span><br><span class="line">namedCreater, isNamedCreater := storage.(rest.NamedCreater)</span><br><span class="line">lister, isLister := storage.(rest.Lister)</span><br><span class="line">getter, isGetter := storage.(rest.Getter)</span><br><span class="line">getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)</span><br><span class="line">deleter, isDeleter := storage.(rest.Deleter)</span><br><span class="line">gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)</span><br><span class="line">collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)</span><br><span class="line">updater, isUpdater := storage.(rest.Updater)</span><br><span class="line">patcher, isPatcher := storage.(rest.Patcher)</span><br><span class="line">watcher, isWatcher := storage.(rest.Watcher)</span><br><span class="line">_, isRedirector := storage.(rest.Redirector)</span><br><span class="line">connecter, isConnecter := storage.(rest.Connecter)</span><br><span class="line">storageMeta, isMetadata := storage.(rest.StorageMetadata)</span><br></pre></td></tr></table></figure>
<p>前面我们提到rest.Storage接口只有一个New方法，一般的资源对象存储，出了实现rest.Storage接口之外，还实现多种REST操作接口，如上所示，具体各种资源数据对象的存储对象见<a href="https://www.jianshu.com/writer#/notebooks/29389140/notes/33708604" target="_blank" rel="external nofollow noopener noreferrer">ETCD存储分析</a>。这段代码对storage对象进行判断，以确定并标记它锁满足的API Rest接口类型，而接下来的这段代码在此基础上确定此接口所包含的actions，后者则对应到某种HTTP请求方法（GET/POST/PUT/DELETE）或者HTTP PROXY、WATCH、CONNECT等动作；</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">actions = appendIf(actions, action&#123;<span class="string">"LIST"</span>, resourcePath, resourceParams, namer, <span class="keyword">false</span>&#125;, isLister)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"POST"</span>, resourcePath, resourceParams, namer, <span class="keyword">false</span>&#125;, isCreater)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"DELETECOLLECTION"</span>, resourcePath, resourceParams, namer, <span class="keyword">false</span>&#125;, isCollectionDeleter)</span><br><span class="line"><span class="comment">// DEPRECATED</span></span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"WATCHLIST"</span>, <span class="string">"watch/"</span> + resourcePath, resourceParams, namer, <span class="keyword">false</span>&#125;, allowWatchList)</span><br><span class="line"></span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isGetter)</span><br><span class="line"><span class="keyword">if</span> getSubpath &#123;</span><br><span class="line">    actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="keyword">false</span>&#125;, isGetter)</span><br><span class="line">&#125;</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"PUT"</span>, itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isUpdater)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"PATCH"</span>, itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isPatcher)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"DELETE"</span>, itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isDeleter)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"WATCH"</span>, <span class="string">"watch/"</span> + itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isWatcher)</span><br><span class="line"><span class="comment">// We add "proxy" subresource to remove the need for the generic top level prefix proxy.</span></span><br><span class="line"><span class="comment">// The generic top level prefix proxy is deprecated in v1.2, and will be removed in 1.3, or 1.4 at the latest.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> DEPRECATED in v1.2.</span></span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"PROXY"</span>, <span class="string">"proxy/"</span> + itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="keyword">false</span>&#125;, isRedirector)</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> DEPRECATED in v1.2.</span></span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"PROXY"</span>, <span class="string">"proxy/"</span> + itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isRedirector)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"CONNECT"</span>, itemPath, nameParams, namer, <span class="keyword">false</span>&#125;, isConnecter)</span><br><span class="line">actions = appendIf(actions, action&#123;<span class="string">"CONNECT"</span>, itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="keyword">false</span>&#125;, isConnecter &amp;&amp; connectSubpath)</span><br></pre></td></tr></table></figure>
<p>我们注意到rest.Redirector类型的storage被当作PROXY进行处理，由apiserver.ProxyHandler进行拦截，并调用rest.Redirector的ResourceLocation方法获取资源的处理路径（可能包含一个非空的http.RoundTripper），用于处理执行Redirector返回的URL请求）。Kubernetes API Server中PROXY请求存在的意义在于透明地访问某个其他节点（比如某个Minion）上的API。</p>
<p>最后，我们来分析下registerResourcesHandles中完成从rest.Storage到restful.Route映射的最后一段关键代码。下面是rest.Getter接口的Storage映射代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"GET"</span>: <span class="comment">// Get a resource.</span></span><br><span class="line">        <span class="keyword">var</span> handler restful.RouteFunction</span><br><span class="line">        <span class="keyword">if</span> isGetterWithOptions &#123;</span><br><span class="line">            handler = restfulGetResourceWithOptions(getterWithOptions, reqScope, hasSubresource)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler = restfulGetResource(getter, exporter, reqScope)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> needOverride &#123;</span><br><span class="line">            <span class="comment">// need change the reported verb</span></span><br><span class="line">            handler = metrics.InstrumentRouteFunc(verbOverrider.OverrideMetricsVerb(action.Verb), resource, subresource, requestScope, handler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler = metrics.InstrumentRouteFunc(action.Verb, resource, subresource, requestScope, handler)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> a.enableAPIResponseCompression &#123;</span><br><span class="line">            handler = genericfilters.RestfulWithCompression(handler, a.group.Context)</span><br><span class="line">        &#125;</span><br><span class="line">        doc := <span class="string">"read the specified "</span> + kind</span><br><span class="line">        <span class="keyword">if</span> hasSubresource &#123;</span><br><span class="line">            doc = <span class="string">"read "</span> + subresource + <span class="string">" of the specified "</span> + kind</span><br><span class="line">        &#125;</span><br><span class="line">        route := ws.GET(action.Path).To(handler).</span><br><span class="line">            Doc(doc).</span><br><span class="line">            Param(ws.QueryParameter(<span class="string">"pretty"</span>, <span class="string">"If 'true', then the output is pretty printed."</span>)).</span><br><span class="line">            Operation(<span class="string">"read"</span>+namespaced+kind+strings.Title(subresource)+operationSuffix).</span><br><span class="line">            Produces(<span class="built_in">append</span>(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).</span><br><span class="line">            Returns(http.StatusOK, <span class="string">"OK"</span>, producedObject).</span><br><span class="line">            Writes(producedObject)</span><br><span class="line">        <span class="keyword">if</span> isGetterWithOptions &#123;</span><br><span class="line">            <span class="keyword">if</span> err := addObjectParams(ws, route, versionedGetOptions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> isExporter &#123;</span><br><span class="line">            <span class="keyword">if</span> err := addObjectParams(ws, route, versionedExportOptions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addParams(route, action.Params)</span><br><span class="line">        routes = <span class="built_in">append</span>(routes, route)</span><br></pre></td></tr></table></figure>
<p>上述代码首先通过函数restfulGetResourceWithOptions或者restfulGetResource创建了一个restful.RouteFunction，然后生成一个restful.route对象，最后注册到 restful.WebService中，从而完成了rest.Storage到Rest服务的“最后一公里”通车。restfulGetResource函数的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restfulGetResource</span><span class="params">(r rest.Getter, e rest.Exporter, scope handlers.RequestScope)</span> <span class="title">restful</span>.<span class="title">RouteFunction</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(req *restful.Request, res *restful.Response)</span></span> &#123;</span><br><span class="line">        handlers.GetResource(r, e, scope)(res.ResponseWriter, req.Request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handlers.GetResource的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetResource</span><span class="params">(r rest.Getter, e rest.Exporter, scope RequestScope)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getResourceHandler(scope,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(ctx request.Context, name <span class="keyword">string</span>, req *http.Request, trace *utiltrace.Trace)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">            <span class="comment">// check for export</span></span><br><span class="line">            options := metav1.GetOptions&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> values := req.URL.Query(); <span class="built_in">len</span>(values) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                exports := metav1.ExportOptions&#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> err := metainternalversion.ParameterCodec.DecodeParameters(values, scope.MetaGroupVersion, &amp;exports); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    err = errors.NewBadRequest(err.Error())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> exports.Export &#123;</span><br><span class="line">                    <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">nil</span>, errors.NewBadRequest(fmt.Sprintf(<span class="string">"export of %q is not supported"</span>, scope.Resource.Resource))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> e.Export(ctx, name, exports)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> err := metainternalversion.ParameterCodec.DecodeParameters(values, scope.MetaGroupVersion, &amp;options); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    err = errors.NewBadRequest(err.Error())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> trace != <span class="literal">nil</span> &#123;</span><br><span class="line">                trace.Step(<span class="string">"About to Get from storage"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">//  这里调用了资源对象存储的Get方法，从而返回具体的资源对象</span></span><br><span class="line">            <span class="keyword">return</span> r.Get(ctx, name, &amp;options)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，我们看到了API的服务最终通过调用r.Get(ctx, name, &amp;options)方法，从而得以返回某个资源对象。</p>
<p>在上面的查询操作中，没有权限控制，但是查看一下createHandler方法，就能看到权限控制的身影，如下所示的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">admissionAttributes := admission.NewAttributesRecord(obj, <span class="literal">nil</span>, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Create, userInfo)</span><br><span class="line"><span class="keyword">if</span> mutatingAdmission, ok := admit.(admission.MutationInterface); ok &amp;&amp; mutatingAdmission.Handles(admission.Create) &#123;</span><br><span class="line">    err = mutatingAdmission.Admit(admissionAttributes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        scope.err(err, w, req)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于资源的Create、Update、Delete、Connect、Patch等操作都有类似的权限控制，从Admit的参数admission.Attributes的属性来看，第三方系统可以开发细粒度的权限控制插件，针对任意资源的任意属性进行细粒度的权限控制，因为资源对象本身都传递到参数中了。</p>
<ul>
<li>资源数据对象的序列化与版本化</li>
</ul>
<p>这里也列举了createHandler中的代码片段，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gv := scope.Kind.GroupVersion()</span><br><span class="line">        <span class="comment">// 得到合适的SerializerInfo</span></span><br><span class="line">s, err := negotiation.NegotiateInputSerializer(req, <span class="literal">false</span>, scope.Serializer)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    scope.err(err, w, req)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 找到合适的decoder</span></span><br><span class="line">decoder := scope.Serializer.DecoderToVersion(s.Serializer, schema.GroupVersion&#123;Group: gv.Group, Version: runtime.APIVersionInternal&#125;)</span><br><span class="line"></span><br><span class="line">body, err := readBody(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    scope.err(err, w, req)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">defaultGVK := scope.Kind</span><br><span class="line">original := r.New()</span><br><span class="line">trace.Step(<span class="string">"About to convert to expected version"</span>)</span><br><span class="line">        <span class="comment">//  采用decoder解码</span></span><br><span class="line">obj, gvk, err := decoder.Decode(body, &amp;defaultGVK, original)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    err = transformDecodeError(typer, err, original, gvk, body)</span><br><span class="line">    scope.err(err, w, req)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/3bc1a603/" rel="bookmark">【Kubernetes】ApiServer之初识API</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/1141907b/" rel="bookmark">【Kubernetes】Apiserver Install</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/777d3be4/" rel="bookmark">【Kubernetes】ApiServer Codec</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/783fb758/" rel="bookmark">【Kubernetes】ApiServer与Etcd交互</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/d8b96fe4/" rel="bookmark">【Kubernetes】开篇</a></div>
    </li>
  </ul>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/wechatpay.png" alt="Houmin 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/alipay.jpg" alt="Houmin 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Houmin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://houmin.cc/posts/b4a40ecc/" title="【Kubernetes】Apiserver Api">http://houmin.cc/posts/b4a40ecc/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/k8s/" rel="tag"><i class="fa fa-tag"></i> k8s</a>
              <a href="/tags/apiserver/" rel="tag"><i class="fa fa-tag"></i> apiserver</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/3bc1a603/" rel="next" title="【Kubernetes】ApiServer之初识API">
                  <i class="fa fa-chevron-left"></i> 【Kubernetes】ApiServer之初识API
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/3bc1a603/" rel="prev" title="【Kubernetes】ApiServer 启动分析">
                  【Kubernetes】ApiServer 启动分析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#服务链"><span class="nav-number">1.</span> <span class="nav-text">服务链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三种服务"><span class="nav-number">2.</span> <span class="nav-text">三种服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础的API-Server：代码在k8s-io-kubernetes-pkg-master-master-go中"><span class="nav-number">2.0.1.</span> <span class="nav-text">基础的API Server：代码在k8s.io/kubernetes/pkg/master/master.go中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义资源服务：代码在k8s-io-apiextensions-apiserver-pkg-apiserver-apiserver-go中"><span class="nav-number">2.0.2.</span> <span class="nav-text">自定义资源服务：代码在k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AggregateServer-：代码在k8s-io-kube-aggregator-pkg-apiserver-apiserver-go中"><span class="nav-number">2.0.3.</span> <span class="nav-text">AggregateServer ：代码在k8s.io/kube-aggregator/pkg/apiserver/apiserver.go中</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#GenericAPIServer"><span class="nav-number">3.</span> <span class="nav-text">GenericAPIServer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#APIGroupInfo"><span class="nav-number">3.0.1.</span> <span class="nav-text">APIGroupInfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GenericAPIServer-InstallAPIGroup"><span class="nav-number">3.0.2.</span> <span class="nav-text">GenericAPIServer.InstallAPIGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GenericAPIServer-installAPIResources"><span class="nav-number">3.0.3.</span> <span class="nav-text">GenericAPIServer.installAPIResources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#APIInstaller"><span class="nav-number">3.0.4.</span> <span class="nav-text">APIInstaller</span></a></li></ol></li></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Houmin" src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
  <p class="site-author-name" itemprop="name">Houmin</p>
  <div class="site-description" itemprop="description">丈夫拥书万卷，何假南面百城</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">198</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SimpCosm" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SimpCosm" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weihoumin@gmail.com" title="E-Mail &amp;rarr; mailto:weihoumin@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="hitokoto">
    <!-- hitokoto -->
    <div id="hito-expression">:D 获取中...</div>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
      fetch('https://v1.hitokoto.cn')
        .then(function (res){
          return res.json();
        })
        .then(function (data) {
          var hitokoto = document.getElementById('hito-expression');
          hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
        })
        .catch(function (err) {
          console.error(err);
        })
    </script>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houmin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">43:55</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>



  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '800px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'iEBFuhVyk4tuhVYctQ265uid-gzGzoHsz',
    appKey: 'KGjOktrtgSEWK1v9DYA3T3Az',
    placeholder: "Just go go",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
