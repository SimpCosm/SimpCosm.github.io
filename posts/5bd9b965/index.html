<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Houmin" type="application/atom+xml">
  <meta name="google-site-verification" content="zdGhdEF7jHoJW58lsdN6l9JrQFjJFwakCIc7TbbosV0">
  <meta name="msvalidate.01" content="2F527B379ED5537861D0D38C2C754C2B">
  <meta name="baidu-site-verification" content="xAag2PqzKE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Git是目前世界上最先进的分布式版本控制系统，本文是对 git 的原理与用法的总结笔记。">
<meta name="keywords" content="git,workflow,visualized">
<meta property="og:type" content="article">
<meta property="og:title" content="图解 Git">
<meta property="og:url" content="http://houmin.cc/posts/5bd9b965/index.html">
<meta property="og:site_name" content="Houmin">
<meta property="og:description" content="Git是目前世界上最先进的分布式版本控制系统，本文是对 git 的原理与用法的总结笔记。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/local.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/centralized.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/distributed.png">
<meta property="og:image" content="https://segmentfault.com/img/bVKndm">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/deltas.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/snapshots.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/areas.png">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/conventions.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/diff.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/commit-master.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/commit-maint.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/commit-amend.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/checkout-files.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/checkout-branch.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/checkout-detached.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/commit-detached.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/checkout-after-detached.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/checkout-b-detached.svg">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s---GveiZe---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/je5240aqa5uw9d8j3ibb.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--GqjwnYkF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/hlh0kowt3hov1xhcku38.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--eckmvr2M--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/3kkd2ahn41zixs12xgpf.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--cT4TSe48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/894znjv4oo9agqiz4dql.gif">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/merge.svg">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--7lBksXwA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bcd5ajtoc0g5dxzmpfbq.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--cT4TSe48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/894znjv4oo9agqiz4dql.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--zRZ0x2Vc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/rf1o2b6eduboqwkigg3w.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--9vWP_K4S--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/2dkjx4yeaal10xyvj29v.gif">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/cherry-pick.svg">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--EIY4OOcE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/dwyukhq8yj2xliq4i50e.gif">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/rebase.svg">
<meta property="og:image" content="https://marklodato.github.io/visual-git-guide/rebase-onto.svg">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--VSQt4g1V--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bc1r460xx1i0blu0lnnm.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--P6jr7igd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/msofpv7k6rcmpaaefscm.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--38PuARw2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bulx1voegfji4vwgndh4.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s---X5AXldj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/zifpnl1h6a4tk4qdc9sy.gif">
<meta property="og:image" content="https://res.cloudinary.com/practicaldev/image/fetch/s--A1UMM2AH--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/9z9rhtbw7mrigp0miijz.gif">
<meta property="og:image" content="http://walkerdu.com/2019/11/25/git_basic/git_flow_model.png">
<meta property="og:image" content="http://walkerdu.com/2019/11/25/git_basic/github_flow.png">
<meta property="og:image" content="http://walkerdu.com/2019/11/25/git_basic/gitlab_flow.jpg">
<meta property="og:image" content="https://yanhaijing.com/blog/464.png">
<meta property="og:image" content="https://yanhaijing.com/blog/465.png">
<meta property="og:image" content="https://yanhaijing.com/blog/464.png">
<meta property="og:image" content="https://yanhaijing.com/blog/465.png">
<meta property="og:image" content="https://yanhaijing.com/blog/466.png">
<meta property="og:image" content="https://yanhaijing.com/blog/467.png">
<meta property="og:image" content="https://yanhaijing.com/blog/470.png">
<meta property="og:image" content="https://yanhaijing.com/blog/468.png">
<meta property="og:image" content="https://yanhaijing.com/blog/469.png">
<meta property="og:image" content="https://yanhaijing.com/blog/466.png">
<meta property="og:image" content="https://yanhaijing.com/blog/467.png">
<meta property="og:image" content="https://yanhaijing.com/blog/470.png">
<meta property="og:image" content="https://yanhaijing.com/blog/468.png">
<meta property="og:image" content="https://yanhaijing.com/blog/469.png">
<meta property="og:updated_time" content="2020-08-30T09:37:15.441Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://git-scm.com/book/en/v2/images/local.png">

<link rel="canonical" href="http://houmin.cc/posts/5bd9b965/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>图解 Git | Houmin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="/js/photoswipe.min.js?v="></script>
  <script src="/js/photoswipe-ui-default.min.js?v="></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Houmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Yesterday You Said Tomorrow</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-album">

    <a href="/album" rel="section"><i class="fa fa-fw fa-camera"></i>相册</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://houmin.cc/posts/5bd9b965/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
      <meta itemprop="name" content="Houmin">
      <meta itemprop="description" content="丈夫拥书万卷，何假南面百城">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Houmin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          图解 Git
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-22 15:21:52" itemprop="dateCreated datePublished" datetime="2018-02-22T15:21:52+08:00">2018-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/" itemprop="url" rel="index">
                    <span itemprop="name">术业专攻</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/5bd9b965/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/5bd9b965/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:11</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Git是目前世界上最先进的分布式版本控制系统，本文是对 git 的原理与用法的总结笔记。</p>
<a id="more"></a>
<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。通过版本控制系统，你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态；你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子，但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 <a href="https://www.gnu.org/software/rcs/" target="_blank" rel="external nofollow noopener noreferrer">RCS</a> 的工作原理是在硬盘上保存补丁集；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
<p><img alt="Local version control diagram" data-src="https://git-scm.com/book/en/v2/images/local.png"></p>
<h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、SVN 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p>
<p><img alt="Centralized version control diagram" data-src="https://git-scm.com/book/en/v2/images/centralized.png"></p>
<p>但这种模式有一个致命的缺点，就是中心的单点，如果服务器恰好坏了，那代码全部丢失，所以大公司一般都有很好的容灾机制。</p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>随着开源运动的爆发，中心仓库模式很难适应全球多人写作的模式，于是乎分布式版本控制诞生了</p>
<p>DVCS结合了LVCS和CVCS两者的优点，本地仓库让一切都在本地，同时分布式的设计又让每一个节点都能成为远端</p>
<p>DVCS的缺点也是不容忽视的，本地仓库会导致首次clone变慢，其学习曲线优点陡峭（相对而言）</p>
<p><img alt="Distributed version control diagram" data-src="https://git-scm.com/book/en/v2/images/distributed.png"></p>
<h2 id="Git-工作模型"><a href="#Git-工作模型" class="headerlink" title="Git 工作模型"></a>Git 工作模型</h2><p><img alt="Git 工作模型" data-src="https://segmentfault.com/img/bVKndm"></p>
<h3 id="Snapshots-Not-Differents"><a href="#Snapshots-Not-Differents" class="headerlink" title="Snapshots, Not Differents"></a>Snapshots, Not Differents</h3><p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容：</p>
<blockquote>
<p>Conceptually, most other systems <strong>store information as a list of file-based changes</strong>.</p>
</blockquote>
<p><img alt="Storing data as changes to a base version of each file." data-src="https://git-scm.com/book/en/v2/images/deltas.png"></p>
<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就如下图所示：</p>
<blockquote>
<p>Git thinks about its data more like a <strong>stream of snapshots</strong>.</p>
</blockquote>
<p><img alt="Git stores data as snapshots of the project over time." data-src="https://git-scm.com/book/en/v2/images/snapshots.png"></p>
<blockquote>
<p>This makes Git <strong>more like a mini filesystem</strong> with some incredibly powerful tools built on top of it, rather than simply a VCS.</p>
</blockquote>
<h3 id="The-Three-States"><a href="#The-Three-States" class="headerlink" title="The Three States"></a>The Three States</h3><p><img alt="Working tree, staging area, and Git directory." data-src="https://git-scm.com/book/en/v2/images/areas.png"></p>
<p>对任何一个文件，在Git内都有三种状态：</p>
<ul>
<li>已提交(committed)：表示该文件已经被安全的保存在本地数据库中了</li>
<li>已修改(modified)：表示修改了某个文件，但还没有提交保存</li>
<li>已暂存(staged/index)：表示把已修改的文件放在下次提交时要保存的清单中</li>
</ul>
<h2 id="Git-命令图解"><a href="#Git-命令图解" class="headerlink" title="Git 命令图解"></a>Git 命令图解</h2><p><img alt="Visualize Convention" data-src="https://marklodato.github.io/visual-git-guide/conventions.svg"></p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p><code>git diff</code>显示两次提交之间的变动。</p>
<p><img alt="git diff" data-src="https://marklodato.github.io/visual-git-guide/diff.svg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示暂存区和工作区的代码差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br></pre></td></tr></table></figure>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><h4 id="命令图解"><a href="#命令图解" class="headerlink" title="命令图解"></a>命令图解</h4><p>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。</p>
<p><img alt="git commit" data-src="https://marklodato.github.io/visual-git-guide/commit-master.svg"></p>
<p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。</p>
<p><img alt="git commit" data-src="https://marklodato.github.io/visual-git-guide/commit-maint.svg"></p>
<h4 id="更改最近的commit"><a href="#更改最近的commit" class="headerlink" title="更改最近的commit"></a>更改最近的commit</h4><p>如果想更改一次提交，使用 <code>git commit --amend</code>。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p>
<p><img alt="git commit --amend" data-src="https://marklodato.github.io/visual-git-guide/commit-amend.svg"></p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p>
<p>当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，<code>git checkout HEAD~ foo.c</code>会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的<code>foo.c</code>复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-files.svg"></p>
<p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-branch.svg"></p>
<p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像<em>master~3</em>类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行<code>git checkout v1.6.6.1</code>（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说<code>git checkout master</code>。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#detached" target="_blank" rel="external nofollow noopener noreferrer">下面</a>。</p>
<p><img alt="git checkout master~3" data-src="https://marklodato.github.io/visual-git-guide/checkout-detached.svg"></p>
<h3 id="HEAD标识处于分离状态时的提交操作"><a href="#HEAD标识处于分离状态时的提交操作" class="headerlink" title="HEAD标识处于分离状态时的提交操作"></a>HEAD标识处于分离状态时的提交操作</h3><p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/commit-detached.svg"></p>
<p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-after-detached.svg"></p>
<p>但是，如果你想保存这个状态，可以用命令<code>git checkout -b *name*</code>来创建一个新的分支。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-b-detached.svg"></p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>reset命令把HEAD指针指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<h4 id="Soft-Reset"><a href="#Soft-Reset" class="headerlink" title="Soft Reset"></a>Soft Reset</h4><p><code>soft reset</code> 会移动当前 HEAD 指针到某个特定的commit，与此同时当前工作目录的文件不变。</p>
<p>举个例子，我们在<code>035cc</code> commit 新增了一个 <code>index.js</code> 文件，在 <code>9e78i</code> commit 新增了一个 <code>styles.css</code>文件，这个时候我们像撤销commit，不再要<code>index.js</code>文件，但是想保留 <code>styles.css</code>文件，这个时候我们执行 <code>git reset --soft HEAD~2</code>，HEAD指针前移到<code>ec5be</code>，但是在commit <code>ec5be</code>之后添加的文件仍然保留 commit  <code>9e78i</code> 的状态。</p>
<p><img alt="Soft Reset" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s---GveiZe---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/je5240aqa5uw9d8j3ibb.gif"></p>
<h4 id="Hard-Reset"><a href="#Hard-Reset" class="headerlink" title="Hard Reset"></a>Hard Reset</h4><p><code>hard reset</code> 不仅仅会移动当前 HEAD 指针到某个特定的commit，与此同时在该commit之后提交的所有文件修改都撤销。</p>
<p><img alt="Hard Reset" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--GqjwnYkF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/hlh0kowt3hov1xhcku38.gif"></p>
<h4 id="撤销-add"><a href="#撤销-add" class="headerlink" title="撤销 add"></a>撤销 add</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD <span class="comment"># 撤销add的所有文件</span></span><br><span class="line">$ git reset HEAD &lt;fileA&gt; <span class="comment"># 撤销add的fileA</span></span><br></pre></td></tr></table></figure>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><img alt="git revert" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--eckmvr2M--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/3kkd2ahn41zixs12xgpf.gif"></p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img alt="git merge" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--cT4TSe48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/894znjv4oo9agqiz4dql.gif"></p>
<h4 id="命令图解-1"><a href="#命令图解-1" class="headerlink" title="命令图解"></a>命令图解</h4><p>Merge操作会从目标 commit 和当前 commit （即 HEAD 所指向的 commit）分叉的位置起，把目标 commit 的路径上的所有 commit 的内容一并应用到当前 commit，然后自动生成一个新的 commit。</p>
<p>如下图所示，master 分支当前提交为ed489，other 分支提交为33104，他们的共同祖父节点为b325c，在master 分支执行 <code>git merge other</code>会进行一次<a href="http://en.wikipedia.org/wiki/Three-way_merge" target="_blank" rel="external nofollow noopener noreferrer">三方合并</a>。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。具体来说，执行<code>git merge other</code>的过程中，会对比other分支的两次commit，相对于当前master分支的最新commit，得到改变的内容，合并成一次新的commit提交到master分支。</p>
<p><img alt="git merge other" data-src="https://marklodato.github.io/visual-git-guide/merge.svg"></p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果两个分支修改了相同的内容，merge 的时候就会发生冲突，git 不知道应该以哪个为准，会告诉你 merge 失败的原因，需要你来手动解决掉冲突，并重新 add、commit（改动不同文件或同一文件的不同行都不会产生冲突）；或者使用<code>git merge --abort</code>放弃解决冲突，取消merge。</p>
<p><img alt="git merge conflict" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--7lBksXwA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bcd5ajtoc0g5dxzmpfbq.gif"></p>
<h4 id="Fast-Forward"><a href="#Fast-Forward" class="headerlink" title="Fast Forward"></a>Fast Forward</h4><p><code>Fast Forward</code>是git在合并分支时候为了提高性能的默认方式。当待合并的分支有当前分支的所有commit的时候，不会创建新的commit，而是直接移动HEAD指针。</p>
<p><img alt="git merge fast forward" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--cT4TSe48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/894znjv4oo9agqiz4dql.gif"></p>
<p><code>Fast Forward</code> 会丢失在dev分支上的提交信息，为了保持原有dev分支上提交链的完成性，最佳实践是采用 <code>no-fast-forward</code>模式来执行merge操作。</p>
<p><img alt="git merge no-fast-forward" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--zRZ0x2Vc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/rf1o2b6eduboqwkigg3w.gif"></p>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p><img alt="git cherry-pick" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--9vWP_K4S--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/2dkjx4yeaal10xyvj29v.gif"></p>
<h4 id="命令图解-2"><a href="#命令图解-2" class="headerlink" title="命令图解"></a>命令图解</h4><p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
<p><img alt="git cherry-pick 2c33a" data-src="https://marklodato.github.io/visual-git-guide/cherry-pick.svg"></p>
<p>以上图为例，分别有<code>master</code> 和 <code>topic</code> 两个分支，在 <code>master</code> 分支的 <code>ed489</code> commit 之后执行 <code>git cherry-pick 2c33a</code>，可以直接将<code>topic</code> 分支上<code>2c33a</code>的commit的内容应用到master分支上，同时创建了新的commit <code>f142b</code>。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在target branch 上应用来自 source branch 的对应 commit 的内容</span></span><br><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br><span class="line"><span class="comment"># 一次转移多个commit</span></span><br><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br><span class="line"><span class="comment"># 一次转移commit A到commit B间的所有commit内容</span></span><br><span class="line"><span class="comment"># 要求：commit A 必须早于 commit B</span></span><br><span class="line"><span class="comment"># 注意：下面这个命令中 commit A 不会被包含在 cherry-pick 中</span></span><br><span class="line"><span class="comment"># 如果想要包含commit A，需执行 `git cherry-pick A^..B`</span></span><br><span class="line">$ git cherry-pick A..B</span><br></pre></td></tr></table></figure>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><code>git cherry-pick</code>命令的常用配置项如下。</p>
<p><strong>（1）<code>-e</code>，<code>--edit</code></strong></p>
<p>打开外部编辑器，编辑提交信息。</p>
<p><strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p>
<p>只更新工作区和暂存区，不产生新的提交。</p>
<p><strong>（3）<code>-x</code></strong></p>
<p>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p>
<p><strong>（4）<code>-s</code>，<code>--signoff</code></strong></p>
<p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p>
<p><strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p>
<p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p>
<p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令表示，Cherry pick 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p>
<p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p>
<h4 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p>
<p><strong>（1）<code>--continue</code></strong></p>
<p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）<code>--abort</code></strong></p>
<p>发生代码冲突后，放弃合并，回到操作前的样子。</p>
<p><strong>（3）<code>--quit</code></strong></p>
<p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子</p>
<h4 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h4><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add target git://gitUrl</span><br></pre></td></tr></table></figure>
<p>上面命令添加了一个远程仓库<code>target</code>。</p>
<p>然后，将远程代码抓取到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch target</span><br></pre></td></tr></table></figure>
<p>上面命令将远程代码仓库抓取到本地。</p>
<p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> target/master</span><br></pre></td></tr></table></figure>
<p>最后，使用<code>git cherry-pick</code>命令转移提交。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><img alt="git rebase" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--EIY4OOcE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/dwyukhq8yj2xliq4i50e.gif"></p>
<h4 id="命令图解-3"><a href="#命令图解-3" class="headerlink" title="命令图解"></a>命令图解</h4><p>Rebase 是合并命令的另一种选择。<strong>git merge把两个父分支合并后进行一次提交，提交历史不是线性的</strong>。Rebase在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的cherry-pick。</p>
<p><img alt="git rebase master" data-src="https://marklodato.github.io/visual-git-guide/rebase.svg"></p>
<p><strong>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支</strong>，将topic分支的基准先设置为master的最新commit，然后重演自己的提交，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。具体来说，你从 <code>a47c3</code> 处从master分支创建了你自己的 <code>topic</code>来开发，提交了两次之后到了<code>2c33a</code>。在这个期间，<code>master</code>分支已经合并了来自于多个开发者的提交，进行到了<code>da985</code>这个commit。这个时候，你在自己的<code>topic</code>分支上执行 <code>git rebase master</code>，重新设置了自己的基线。topic分支的基线改为<code>da985</code>，然后重演<code>169a6</code>和<code>2c33a</code>两个提交，形成新的commit。</p>
<p>要限制回滚范围，使用<code>--onto</code>选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p>
<p><img alt="git rebase --onto master 169a6" data-src="https://marklodato.github.io/visual-git-guide/rebase-onto.svg"></p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>rebase过程中，也许会出现冲突（conflict）</p>
<ul>
<li>git会停止rebase，需要解决冲突</li>
<li>解决完，使用<code>git add</code>添加冲突的文件，更新暂存区</li>
<li><code>git rebase --continue</code>继续剩下的rebase</li>
<li><code>git rebase --abort</code>终止rebase行为，并且feature会回到rebase开始之前的状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase develop</span><br><span class="line">CONFLICT (content): Rebase conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic rebase failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git rebase --continue"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>查看readme.md 内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Git tracks changes <span class="keyword">of</span> files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br></pre></td></tr></table></figure>
<p>选择保留<code>HEAD</code>或者<code>feature</code>的版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git tracks changes <span class="keyword">of</span> files.</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick AND simple.</span><br></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.md</span><br><span class="line">$ git rebase --contine</span><br></pre></td></tr></table></figure>
<p>同样有<code>git rebase --interactive</code>让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。交互式的rebase有六个可以执行的操作。</p>
<ul>
<li><code>reword</code>: Change the commit message</li>
<li><code>edit</code>: Amend this commit</li>
<li><code>squash</code>: Meld commit into the previous commit</li>
<li><code>fixup</code>: Meld commit into the previous commit, without keeping the commit’s log message</li>
<li><code>exec</code>: Run a command on each commit we want to rebase</li>
<li><code>drop</code>: Remove the commit</li>
</ul>
<h4 id="压缩commit"><a href="#压缩commit" class="headerlink" title="压缩commit"></a>压缩commit</h4><p><img alt="git interactive rebase squash" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--VSQt4g1V--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bc1r460xx1i0blu0lnnm.gif"></p>
<h4 id="丢弃commit"><a href="#丢弃commit" class="headerlink" title="丢弃commit"></a>丢弃commit</h4><p><img alt="git rebase drop commit" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--P6jr7igd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/msofpv7k6rcmpaaefscm.gif"></p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class="line">origin  git@github.com:jquery/jquery.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:SimpCosm/kubernetes.git</span><br><span class="line">  Push  URL: git@github.com:SimpCosm/kubernetes.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                       tracked</span><br><span class="line">    release-0.10                 tracked</span><br><span class="line">    release-0.12                 tracked</span><br><span class="line">   ...</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span><br><span class="line">    release-1.16 merges with remote release-1.16</span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span><br><span class="line">    release-1.18                 pushes to release-1.18                 (up to date)</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程仓库名</span></span><br><span class="line">$ git remote rm &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给远程主机改名</span></span><br><span class="line">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机的版本库有了更新，需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<p><img alt="git fetch" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--38PuARw2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bulx1voegfji4vwgndh4.gif"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般用法</span></span><br><span class="line">$ git fetch  [&lt;repository&gt; [&lt;refspec&gt;...]</span><br><span class="line"></span><br><span class="line">$ git fetch origin <span class="comment"># 拉回origin仓库的所有分支</span></span><br><span class="line">$ git fetch origin release-1.19 <span class="comment"># 拉回origin仓库的release-1.19分支</span></span><br><span class="line">$ git checkout -b release-1.19 origin/release-1.19 <span class="comment"># 基于远程1.19分支创建本地分支</span></span><br></pre></td></tr></table></figure>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。可以认为git pull是git fetch和git merge两个步骤的结合。</p>
<p><img alt="git pull" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s---X5AXldj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/zifpnl1h6a4tk4qdc9sy.gif"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="comment"># 取回origin主机的next分支，与本地的master分支合并</span></span><br><span class="line">$ git pull origin next:master</span><br><span class="line"><span class="comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span></span><br><span class="line"><span class="comment"># 下面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</span></span><br><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p>
<p>Git也允许手动建立追踪关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream master origin/next</span><br></pre></td></tr></table></figure>
<p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>
<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ git push origin --delete master</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p>
<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --force origin</span><br></pre></td></tr></table></figure>
<p>上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动</span></span><br><span class="line">$ git <span class="built_in">log</span> (tag-name||commit-SHA) HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow file</span><br><span class="line">$ git whatchanged file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br></pre></td></tr></table></figure>
<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p><img alt="git reflog" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--A1UMM2AH--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/9z9rhtbw7mrigp0miijz.gif"></p>
<h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show commit-SHA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only commit-SHA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show commit-SHA:filename</span><br></pre></td></tr></table></figure>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p><code>git stash</code>会把所有未提交的修改（包括暂存和未暂存的）都保存起来，用于日后恢复当前工作目录</p>
<ul>
<li>保存一个不必要但日后又想查看的提交</li>
<li>切换分支前先暂存，处理分支的其他事情</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch develop</span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> file:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line"></span><br><span class="line">modified:   index.html</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: <span class="number">5002</span>d47 ...</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<blockquote>
<p>stage是本地的，不会上传到git server</p>
</blockquote>
<p>实际应用中，推荐给每个stash加一个message，使用<code>git stash save</code> 取代 <code>git stash</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash save <span class="string">"test stash"</span></span><br><span class="line">Saved working directory and index state On autoswitch: test stash</span><br><span class="line">HEAD 现在位于 <span class="number">296e8</span>d4 remove unnecessary postion reset <span class="keyword">in</span> onResume <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"><span class="title">$</span> <span class="title">git</span> <span class="title">stash</span> <span class="title">list</span></span></span><br><span class="line"><span class="function"><span class="title">stash</span>@</span>&#123;<span class="number">0</span>&#125;: On autoswitch: test stash</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用<code>git stash list</code>命令，查看stash列表</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">049</span>d078 stash_0</span><br><span class="line">stash@&#123;<span class="number">1</span>&#125;: WIP on master: c264051 stash_1</span><br><span class="line">stash@&#123;<span class="number">2</span>&#125;: WIP on master: <span class="number">21</span>d80a5 stash_2</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>git stash apply</code>命令可以通过名字指定那个stash，默认指定最近的（stash@{0}）</li>
<li>使用<code>git stash pop</code>将stash中第一个stash删除，并将对应修改应用到当前的工作目录中</li>
<li>使用<code>git stash drop</code>，后面加上stash名，可以移除相应的stash；或者使用<code>git stash clear</code>清空所有stash</li>
</ul>
<p>默认情况下，<code>git stash</code>会缓存：</p>
<ul>
<li>添加到暂存区的修改（staged changes ）</li>
<li>Git跟踪但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>此时，使用<code>-u</code>或者<code>--include-untracked</code>可以stash untracked 文件；使用<code>-a</code>或者<code>--all</code>可以stash当前目录下的所有修改（<strong>慎用</strong>）</p>
<h2 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h2><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p>Git Flow工作流的特点是项目会长期存在两个分支：</p>
<ul>
<li>主分支master：对外发布版本；</li>
<li>开发分支develop：日常开发版本；</li>
</ul>
<p>除了以上两个长期分支外，还会存在三种短期分支，开发完即合入master or develop，然后删除：</p>
<ul>
<li>功能分支（feature branch）</li>
<li>补丁分支（hotfix branch）</li>
<li>预发分支（release branch）</li>
</ul>
<p><img alt="Git Flow" data-src="http://walkerdu.com/2019/11/25/git_basic/git_flow_model.png"></p>
<p>Git flow的优点是清晰可控，缺点是需要同时维护两个长期分支。且该模式<strong>适合于”版本发布”的工作模式，即周期新的产出一个版本</strong>，即有特定的发布窗口。但对于<strong>“持续发布”，每次代码在master提交都需要进行部署发布的项目就没有意义</strong>，因为master和develop分支差别不大，还要维护两个长期版本。</p>
<h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p>顾名思义，这是GitHub推荐的一种工作流模式。<strong>长期只有一个master分支</strong>，根据需求从master拉取新分支，开发完成后向master发起一个Pull Request(PR)，PR是一个通知，大家一起进行代码的评审和讨论，此过程中也可以不断提交修改，最后PR被接受，合入master，然后进行部署，删除分支，整个流程就结束了。如下图：</p>
<p><a href="http://walkerdu.com/2019/11/25/git_basic/github_flow.png" target="_blank" rel="external nofollow noopener noreferrer"><img alt="Github Flow" data-src="http://walkerdu.com/2019/11/25/git_basic/github_flow.png"></a></p>
<p>和Git Flow相比，正好相反，GitHub Flow适合于<strong>“持续发布”，每次代码在master提交都需要进行部署发布的项目</strong>。而对于<strong>“版本发布”的项目并不合适</strong>。</p>
<h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p>顾名思义，这是GitLab推荐的工作流。它其实是一个Git Flow和GitHub Flow的一个结合。它<strong>上游只有一个master分支</strong>，且其作为<strong>上游分支，根据不同的环境建立不同的分支，所有的修改必须由”上游”向”下游”进行</strong>。</p>
<ul>
<li>针对”持续发布”的项目，每个不同的环境建立不同的分支，例如：开发环境：master，预发布：pre_release，真实环境：online等等。</li>
<li>针对”版本发布”的项目，除了master分支外，针对稳定版本拉取一个分支，例如proj_stable_1.1。</li>
</ul>
<p><img alt="img" data-src="http://walkerdu.com/2019/11/25/git_basic/gitlab_flow.jpg"></p>
<p>所有的修改都必须先在上游master进行修复，然后合入对应的分支。这样GitLab Flow就可以很好的支持Git Flow和GitHub Flow。</p>
<h2 id="Git-工具"><a href="#Git-工具" class="headerlink" title="Git 工具"></a>Git 工具</h2><h3 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a><a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="external nofollow noopener noreferrer">Rewriting History</a></h3><h3 id="Signing-Your-Work"><a href="#Signing-Your-Work" class="headerlink" title="Signing Your Work"></a><a href="https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work" target="_blank" rel="external nofollow noopener noreferrer">Signing Your Work</a></h3><h3 id="Submodules"><a href="#Submodules" class="headerlink" title="Submodules"></a><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="external nofollow noopener noreferrer">Submodules</a></h3><p>Git Submodule 实质上是 Git 的包管理器，它允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<h4 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h4><p>我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。</p>
<p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 <code>git submodule add</code> 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">Cloning into <span class="string">'DbConnector'</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
<p>如果这时运行 <code>git status</code>，你会注意到几件事。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   DbConnector</span><br></pre></td></tr></table></figure>
<p>首先应当注意到新的 <code>.gitmodules</code> 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[submodule "DbConnector"]</span></span><br><span class="line">	path = DbConnector</span><br><span class="line">	url = https://github.com/chaconinc/DbConnector</span><br></pre></td></tr></table></figure>
<p>如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p>
<div class="note info">
            <p>由于 <code>.gitmodules</code> 文件中的 URL 是人们首先尝试克隆/拉取的地方，因此请尽可能确保你使用的 URL 大家都能访问。 例如，若你要使用的推送 URL 与他人的拉取 URL 不同，那么请使用他人能访问到的 URL。 你也可以根据自己的需要，通过在本地执行 <code>git config submodule.DbConnector.url &lt;私有URL&gt;</code> 来覆盖这个选项的值。 如果可行的话，一个相对路径会很有帮助。</p>
          </div>
<p>在 <code>git status</code> 输出中列出的另一个是项目文件夹记录。 如果你运行 <code>git diff</code>，会看到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached DbConnector</span><br><span class="line">diff --git a/DbConnector b/DbConnector</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..c3f01dc</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</span><br></pre></td></tr></table></figure>
<p>虽然 <code>DbConnector</code> 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作子模块仓库中的某个具体的提交。</p>
<p>如果你想看到更漂亮的差异输出，可以给 <code>git diff</code> 传递 <code>--submodule</code> 选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached --submodule</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..71fc376</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+[submodule <span class="string">"DbConnector"</span>]</span><br><span class="line">+       path = DbConnector</span><br><span class="line">+       url = https://github.com/chaconinc/DbConnector</span><br><span class="line">Submodule DbConnector 0000000...c3f01dc (new submodule)</span><br></pre></td></tr></table></figure>
<p>当你提交时，会看到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">'added DbConnector module'</span></span><br><span class="line">[master fb9093c] added DbConnector module</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 DbConnector</span><br></pre></td></tr></table></figure>
<p>注意 <code>DbConnector</code> 记录的 <code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p>
<p>最后，推送这些更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h4 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h4><p>接下来我们将会克隆一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into <span class="string">'MainProject'</span>...</span><br><span class="line">remote: Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> MainProject</span><br><span class="line">$ ls -la</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .</span><br><span class="line">drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..</span><br><span class="line">drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git</span><br><span class="line">-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules</span><br><span class="line">drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector</span><br><span class="line">-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile</span><br><span class="line">drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src</span><br><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ ls</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>其中有 <code>DbConnector</code> 目录，不过是空的。 你必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule <span class="string">'DbConnector'</span> (https://github.com/chaconinc/DbConnector) registered <span class="keyword">for</span> path <span class="string">'DbConnector'</span></span><br><span class="line">$ git submodule update</span><br><span class="line">Cloning into <span class="string">'DbConnector'</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'c3f01dc8862123d317dd46284b05b6892c7b29bc'</span></span><br></pre></td></tr></table></figure>
<p>现在 <code>DbConnector</code> 子目录是处在和之前提交时相同的状态了。</p>
<p>不过还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recurse-submodules https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into <span class="string">'MainProject'</span>...</span><br><span class="line">remote: Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Submodule <span class="string">'DbConnector'</span> (https://github.com/chaconinc/DbConnector) registered <span class="keyword">for</span> path <span class="string">'DbConnector'</span></span><br><span class="line">Cloning into <span class="string">'DbConnector'</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'c3f01dc8862123d317dd46284b05b6892c7b29bc'</span></span><br></pre></td></tr></table></figure>
<p>如果你已经克隆了项目但忘记了 <code>--recurse-submodules</code>，那么可以运行 <code>git submodule update --init</code> 将 <code>git submodule init</code> 和 <code>git submodule update</code> 合并成一步。如果还要初始化、抓取并检出任何嵌套的子模块， 请使用简明的 <code>git submodule update --init --recursive</code>。</p>
<h4 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h4><p>现在我们有一份包含子模块的项目副本，我们将会同时在主项目和子模块项目上与队员协作。</p>
<h5 id="从子模块的远端拉取上游修改"><a href="#从子模块的远端拉取上游修改" class="headerlink" title="从子模块的远端拉取上游修改"></a>从子模块的远端拉取上游修改</h5><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。 我们来看一个简单的例子。</p>
<p>如果想要在子模块中查看新工作，可以进入到目录中运行 <code>git fetch</code> 与 <code>git merge</code>，合并上游分支来更新本地代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c3f01dc..d0354fc  master     -&gt; origin/master</span><br><span class="line">$ git merge origin/master</span><br><span class="line">Updating c3f01dc..d0354fc</span><br><span class="line">Fast-forward</span><br><span class="line"> scripts/connect.sh | 1 +</span><br><span class="line"> src/db.c           | 1 +</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<p>如果你现在返回到主项目并运行 <code>git diff --submodule</code>，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。 如果你不想每次运行 <code>git diff</code> 时都输入 <code>--submodle</code>，那么可以将 <code>diff.submodule</code> 设置为 “log” 来将其作为默认行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global diff.submodule <span class="built_in">log</span></span><br><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c3f01dc..d0354fc:</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>
<p>如果在此时提交，那么你会将子模块锁定为其他人更新时的新代码。</p>
<p>如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 <code>git submodule update --remote</code>，Git 将会进入子模块然后抓取并更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote DbConnector</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   3f19983..d0354fc  master     -&gt; origin/master</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'d0354fc054692d3906c85c3af05ddce39a1c0644'</span></span><br></pre></td></tr></table></figure>
<p>此命令默认会假定你想要更新并检出子模块仓库的 <code>master</code> 分支。 不过你也可以设置为想要的其他分支。 例如，你想要 DbConnector 子模块跟踪仓库的 “stable” 分支，那么既可以在 <code>.gitmodules</code> 文件中设置 （这样其他人也可以跟踪它），也可以只在本地的 <code>.git/config</code> 文件中设置。 让我们在 <code>.gitmodules</code> 文件中设置它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git config -f .gitmodules submodule.DbConnector.branch stable</span><br><span class="line"></span><br><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   27cf5d3..c87d55d  stable -&gt; origin/stable</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'</span></span><br></pre></td></tr></table></figure>
<p>如果不用 <code>-f .gitmodules</code> 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。</p>
<p>这时我们运行 <code>git status</code>，Git 会显示子模块中有“新提交”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">  modified:   .gitmodules</span><br><span class="line">  modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>如果你设置了配置选项 <code>status.submodulesummary</code>，Git 也会显示你的子模块的更改摘要：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git config status.submodulesummary 1</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   .gitmodules</span><br><span class="line">	modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">Submodules changed but not updated:</span><br><span class="line"></span><br><span class="line">* DbConnector c3f01dc...c87d55d (4):</span><br><span class="line">  &gt; catch non-null terminated lines</span><br></pre></td></tr></table></figure>
<p>这时如果运行 <code>git diff</code>，可以看到我们修改了 .gitmodules 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule <span class="string">"DbConnector"</span>]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line"> Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>
<p>这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 <code>git log -p</code> 查看这个信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p --submodule</span><br><span class="line">commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Sep 17 16:37:02 2014 +0200</span><br><span class="line"></span><br><span class="line">    updating DbConnector <span class="keyword">for</span> bug fixes</span><br><span class="line"></span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule <span class="string">"DbConnector"</span>]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line">Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>
<p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新 <strong>所有</strong> 子模块， 所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。</p>
<h5 id="从项目远端拉取上游更改"><a href="#从项目远端拉取上游更改" class="headerlink" title="从项目远端拉取上游更改"></a>从项目远端拉取上游更改</h5><p>现在，让我们站在协作者的视角，他有自己的 <code>MainProject</code> 仓库的本地克隆， 只是执行 <code>git pull</code> 获取你新提交的更改还不够：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">From https://github.com/chaconinc/MainProject</span><br><span class="line">   fb9093c..0a24cfc  master     -&gt; origin/master</span><br><span class="line">Fetching submodule DbConnector</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c3f01dc..c87d55d  stable     -&gt; origin/stable</span><br><span class="line">Updating fb9093c..0a24cfc</span><br><span class="line">Fast-forward</span><br><span class="line"> .gitmodules         | 2 +-</span><br><span class="line"> DbConnector         | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"> On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">Submodules changed but not updated:</span><br><span class="line"></span><br><span class="line">* DbConnector c87d55d...c3f01dc (4):</span><br><span class="line">  &lt; catch non-null terminated lines</span><br><span class="line">  &lt; more robust error handling</span><br><span class="line">  &lt; more efficient db routine</span><br><span class="line">  &lt; better connection routine</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>git pull</code> 命令会递归地抓取子模块的更改，如上面第一个命令的输出所示。 然而，它不会 <strong>更新</strong> 子模块。这点可通过 <code>git status</code> 命令看到，它会显示子模块“已修改”，且“有新的提交”。 此外，左边的尖括号（&lt;）指出了新的提交，表示这些提交已在 MainProject 中记录，但尚未在本地的 <code>DbConnector</code> 中检出。 为了完成更新，你需要运行 <code>git submodule update</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br><span class="line">Submodule path <span class="string">'vendor/plugins/demo'</span>: checked out <span class="string">'48679c6302815f6c76f1fe30625d795d9e55fc56'</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"> On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>请注意，为安全起见，如果 MainProject 提交了你刚拉取的新子模块，那么应该在 <code>git submodule update</code> 后面添加 <code>--init</code> 选项，如果子模块有嵌套的子模块，则应使用 <code>--recursive</code> 选项。</p>
<p>如果你想自动化此过程，那么可以为 <code>git pull</code> 命令添加 <code>--recurse-submodules</code> 选项（从 Git 2.14 开始）。 这会让 Git 在拉取后运行 <code>git submodule update</code>，将子模块置为正确的状态。 此外，如果你想让 Git 总是以 <code>--recurse-submodules</code> 拉取，可以将配置选项 <code>submodule.recurse</code> 设置为 <code>true</code> （从 Git 2.15 开始可用于 <code>git pull</code>）。此选项会让 Git 为所有支持 <code>--recurse-submodules</code> 的命令使用该选项（除 <code>clone</code> 以外）。</p>
<p>在为父级项目拉取更新时，还会出现一种特殊的情况：在你拉取的提交中， 可能 <code>.gitmodules</code> 文件中记录的子模块的 URL 发生了改变。 比如，若子模块项目改变了它的托管平台，就会发生这种情况。 此时，若父级项目引用的子模块提交不在仓库中本地配置的子模块远端上，那么执行 <code>git pull --recurse-submodules</code> 或 <code>git submodule update</code> 就会失败。 为了补救，<code>git submodule sync</code> 命令需要：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将新的 URL 复制到本地配置中</span></span><br><span class="line">$ git submodule sync --recursive</span><br><span class="line"><span class="comment"># 从新 URL 更新子模块</span></span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<h5 id="在子模块上工作"><a href="#在子模块上工作" class="headerlink" title="在子模块上工作"></a>在子模块上工作</h5><p>你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。</p>
<p>现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。</p>
<p>到目前为止，当我们运行 <code>git submodule update</code> 从子模块仓库中抓取修改时， Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支（例如 “master” ）跟踪改动。 如果没有工作分支跟踪更改，也就意味着即便你将更改提交到了子模块，这些更改也很可能会在下次运行 <code>git submodule update</code> 时丢失。如果你想要在子模块中跟踪这些修改，还需要一些额外的步骤。</p>
<p>为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 <code>git submodule update --remote</code> 来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。</p>
<p>首先，让我们进入子模块目录然后检出一个分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ git checkout stable</span><br><span class="line">Switched to branch <span class="string">'stable'</span></span><br></pre></td></tr></table></figure>
<p>然后尝试用 “merge” 选项来更新子模块。 为了手动指定它，我们只需给 <code>update</code> 添加 <code>--merge</code> 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ git submodule update --remote --merge</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c87d55d..92c7337  stable     -&gt; origin/stable</span><br><span class="line">Updating c87d55d..92c7337</span><br><span class="line">Fast-forward</span><br><span class="line"> src/main.c | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: merged <span class="keyword">in</span> <span class="string">'92c7337b30ef9e0893e758dac2459d07362ab5ea'</span></span><br></pre></td></tr></table></figure>
<p>如果我们进入 DbConnector 目录，可以发现新的改动已经合并入本地 <code>stable</code> 分支。 现在让我们看看当我们对库做一些本地的改动而同时其他人推送另外一个修改到上游时会发生什么。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ vim src/db.c</span><br><span class="line">$ git commit -am <span class="string">'unicode support'</span></span><br><span class="line">[stable f906e16] unicode support</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ git submodule update --remote --rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: unicode support</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: rebased into <span class="string">'5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</span></span><br></pre></td></tr></table></figure>
<p>如果你忘记 <code>--rebase</code> 或 <code>--merge</code>，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</span></span><br></pre></td></tr></table></figure>
<p>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 <code>origin/stable</code>（或任何一个你想要的远程分支）就行了。</p>
<p>如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 0), reused 4 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   5d60ef9..c75e92a  stable     -&gt; origin/stable</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">	scripts/setup.sh</span><br><span class="line">Please, commit your changes or stash them before you can switch branches.</span><br><span class="line">Aborting</span><br><span class="line">Unable to checkout <span class="string">'c75e92a2b3855c9e5b66f915308390d9db204aca'</span> <span class="keyword">in</span> submodule path <span class="string">'DbConnector'</span></span><br></pre></td></tr></table></figure>
<p>如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --remote --merge</span><br><span class="line">Auto-merging scripts/setup.sh</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> scripts/setup.sh</span><br><span class="line">Recorded preimage <span class="keyword">for</span> <span class="string">'scripts/setup.sh'</span></span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line">Unable to merge <span class="string">'c75e92a2b3855c9e5b66f915308390d9db204aca'</span> <span class="keyword">in</span> submodule path <span class="string">'DbConnector'</span></span><br></pre></td></tr></table></figure>
<p>你可以进入子模块目录中然后就像平时那样修复冲突。</p>
<h5 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h5><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c87d55d..82d2ad3:</span><br><span class="line">  &gt; Merge from origin/stable</span><br><span class="line">  &gt; updated setup script</span><br><span class="line">  &gt; unicode support</span><br><span class="line">  &gt; remove unnecessary method</span><br><span class="line">  &gt; add new option <span class="keyword">for</span> conn pooling</span><br></pre></td></tr></table></figure>
<p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦， 因为他们无法得到依赖的子模块改动。那些改动只存在于我们本地的拷贝中。</p>
<p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 <code>git push</code> 命令接受可以设置为 “check” 或 “on-demand” 的 <code>--recurse-submodules</code> 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 <code>push</code> 操作失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=check</span><br><span class="line">The following submodule paths contain changes that can</span><br><span class="line">not be found on any remote:</span><br><span class="line">  DbConnector</span><br><span class="line"></span><br><span class="line">Please try</span><br><span class="line"></span><br><span class="line">	git push --recurse-submodules=on-demand</span><br><span class="line"></span><br><span class="line">or <span class="built_in">cd</span> to the path and use</span><br><span class="line"></span><br><span class="line">	git push</span><br><span class="line"></span><br><span class="line">to push them to a remote.</span><br></pre></td></tr></table></figure>
<p>如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。 如果你想要对所有推送都执行检查，那么可以通过设置 <code>git config push.recurseSubmodules check</code> 让它成为默认行为。</p>
<p>另一个选项是使用 “on-demand” 值，它会尝试为你这样做。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git push --recurse-submodules=on-demand</span><br><span class="line">Pushing submodule <span class="string">'DbConnector'</span></span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 3), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/DbConnector</span><br><span class="line">   c75e92a..82d2ad3  stable -&gt; stable</span><br><span class="line">Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/MainProject</span><br><span class="line">   3d6d338..9a377d1  master -&gt; master</span><br></pre></td></tr></table></figure>
<p>如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。 如果那个子模块因为某些原因推送失败，主项目也会推送失败。 你也可以通过设置 <code>git config push.recurseSubmodules on-demand</code> 让它成为默认行为。</p>
<h5 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h5><p>如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。</p>
<p>如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。</p>
<p>不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1)</span><br><span class="line">Unpacking objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/MainProject</span><br><span class="line">   9a377d1..eb974f8  master     -&gt; origin/master</span><br><span class="line">Fetching submodule DbConnector</span><br><span class="line">warning: Failed to merge submodule DbConnector (merge following commits not found)</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict <span class="keyword">in</span> DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found” （未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。</p>
<p>为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 <code>git diff</code>，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br></pre></td></tr></table></figure>
<p>所以，在本例中，<code>eb41d76</code> 是我们的子模块中<strong>大家共有</strong>的提交，而 <code>c771610</code> 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 <code>eb41d76</code> 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。</p>
<p>来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。</p>
<p>所以，我们将会进入子模块目录，基于 <code>git diff</code> 的第二个 SHA-1 创建一个分支然后手动合并。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector</span><br><span class="line"></span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"></span><br><span class="line">$ git branch try-merge c771610</span><br><span class="line">(DbConnector) $ git merge try-merge</span><br><span class="line">Auto-merging src/main.c</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> src/main.c</span><br><span class="line">Recorded preimage <span class="keyword">for</span> <span class="string">'src/main.c'</span></span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>我们在这儿得到了一个真正的合并冲突，所以如果想要解决并提交它，那么只需简单地通过结果来更新主项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ vim src/main.c (1)</span><br><span class="line">$ git add src/main.c</span><br><span class="line">$ git commit -am <span class="string">'merged our changes'</span></span><br><span class="line">Recorded resolution <span class="keyword">for</span> <span class="string">'src/main.c'</span>.</span><br><span class="line">[master 9fd905e] merged our changes</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> .. (2)</span><br><span class="line">$ git diff (3)</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@@ -1,1 -1,1 +1,1 @@@</span><br><span class="line">- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"> -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d</span><br><span class="line">++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a</span><br><span class="line">$ git add DbConnector (4)</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"Merge Tom's Changes"</span> (5)</span><br><span class="line">[master 10d2c60] Merge Tom<span class="string">'s Changes</span></span><br></pre></td></tr></table></figure>
<ol>
<li>首先解决冲突</li>
<li>然后返回到主项目目录中</li>
<li>再次检查 SHA-1 值</li>
<li>解决冲突的子模块记录</li>
<li>提交我们的合并</li>
</ol>
<p>这可能会让你有点儿困惑，但它确实不难。</p>
<p>有趣的是，Git 还能处理另一种情况。 如果子模块目录中存在着这样一个合并提交，它的历史中包含了的<strong>两边</strong>的提交，那么 Git 会建议你将它作为一个可行的解决方案。 它看到有人在子模块项目的某一点上合并了包含这两次提交的分支，所以你可能想要那个。</p>
<p>这就是为什么前面的错误信息是 “merge following commits not found”，因为它不能 <strong>这样</strong> 做。 它让人困惑是因为<strong>谁能想到它会尝试这样做？</strong></p>
<p>如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">warning: Failed to merge submodule DbConnector (not fast-forward)</span><br><span class="line">Found a possible merge resolution <span class="keyword">for</span> the submodule:</span><br><span class="line"> 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes</span><br><span class="line">If this is correct simply add it to the index <span class="keyword">for</span> example</span><br><span class="line">by using:</span><br><span class="line"></span><br><span class="line">  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a <span class="string">"DbConnector"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> will accept this suggestion.</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict <span class="keyword">in</span> DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>Git 建议的命令是更新索引，就像你运行了 <code>git add</code> 那样，这样会清除冲突然后提交。 不过你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ git merge 9fd905e</span><br><span class="line">Updating eb41d76..9fd905e</span><br><span class="line">Fast-forward</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ git add DbConnector</span><br><span class="line">$ git commit -am <span class="string">'Fast forwarded to a common submodule child'</span></span><br></pre></td></tr></table></figure>
<p>这些命令完成了同一件事，但是通过这种方式你至少可以验证工作是否有效，以及当你在完成时可以确保子模块目录中有你的代码。</p>
<h4 id="子模的块技巧"><a href="#子模的块技巧" class="headerlink" title="子模的块技巧"></a>子模的块技巧</h4><p>你可以做几件事情来让用子模块工作轻松一点儿。</p>
<h5 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h5><p>有一个 <code>foreach</code> 子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p>
<p>例如，假设我们想要开始开发一项新功能或者修复一些错误，并且需要在几个子模块内工作。 我们可以轻松地保存所有子模块的工作进度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach <span class="string">'git stash'</span></span><br><span class="line">Entering <span class="string">'CryptoLibrary'</span></span><br><span class="line">No <span class="built_in">local</span> changes to save</span><br><span class="line">Entering <span class="string">'DbConnector'</span></span><br><span class="line">Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable</span><br><span class="line">HEAD is now at 82d2ad3 Merge from origin/stable</span><br></pre></td></tr></table></figure>
<p>然后我们可以创建一个新分支，并将所有子模块都切换过去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach <span class="string">'git checkout -b featureA'</span></span><br><span class="line">Entering <span class="string">'CryptoLibrary'</span></span><br><span class="line">Switched to a new branch <span class="string">'featureA'</span></span><br><span class="line">Entering <span class="string">'DbConnector'</span></span><br><span class="line">Switched to a new branch <span class="string">'featureA'</span></span><br></pre></td></tr></table></figure>
<p>你应该明白。 能够生成一个主项目与所有子项目的改动的统一差异是非常有用的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ git diff; git submodule foreach <span class="string">'git diff'</span></span><br><span class="line">Submodule DbConnector contains modified content</span><br><span class="line">diff --git a/src/main.c b/src/main.c</span><br><span class="line">index 210f1ae..1f0acdc 100644</span><br><span class="line">--- a/src/main.c</span><br><span class="line">+++ b/src/main.c</span><br><span class="line">@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)</span><br><span class="line"></span><br><span class="line">      commit_pager_choice();</span><br><span class="line"></span><br><span class="line">+     url = url_decode(url_orig);</span><br><span class="line">+</span><br><span class="line">      /* build alias_argv */</span><br><span class="line">      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));</span><br><span class="line">      alias_argv[0] = alias_string + 1;</span><br><span class="line">Entering <span class="string">'DbConnector'</span></span><br><span class="line">diff --git a/src/db.c b/src/db.c</span><br><span class="line">index 1aaefb6..5297645 100644</span><br><span class="line">--- a/src/db.c</span><br><span class="line">+++ b/src/db.c</span><br><span class="line">@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)</span><br><span class="line">        <span class="built_in">return</span> url_decode_internal(&amp;url, len, NULL, &amp;out, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+char *url_decode(const char *url)</span><br><span class="line">+&#123;</span><br><span class="line">+       <span class="built_in">return</span> url_decode_mem(url, strlen(url));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> char *url_decode_parameter_name(const char **query)</span><br><span class="line"> &#123;</span><br><span class="line">        struct strbuf out = STRBUF_INIT;</span><br></pre></td></tr></table></figure>
<p>在这里，我们看到子模块中定义了一个函数并在主项目中调用了它。 这明显是个简化了的例子，但是希望它能让你明白这种方法的用处。</p>
<h5 id="有用的别名"><a href="#有用的别名" class="headerlink" title="有用的别名"></a>有用的别名</h5><p>你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/_git_aliases" target="_blank" rel="external nofollow noopener noreferrer">Git 别名</a> 介绍了设置 Git 别名， 但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config alias.sdiff <span class="string">'!'</span><span class="string">"git diff &amp;&amp; git submodule foreach 'git diff'"</span></span><br><span class="line">$ git config alias.spush <span class="string">'push --recurse-submodules=on-demand'</span></span><br><span class="line">$ git config alias.supdate <span class="string">'submodule update --remote --merge'</span></span><br></pre></td></tr></table></figure>
<p>这样当你想要更新子模块时可以简单地运行 <code>git supdate</code>，或 <code>git spush</code> 检查子模块依赖后推送。</p>
<h4 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h4><p>然而使用子模块还是有一些小问题。</p>
<h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><p>例如，使用 Git 2.13 以前的版本时，在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.12.2</span><br><span class="line"></span><br><span class="line">$ git checkout -b add-crypto</span><br><span class="line">Switched to a new branch <span class="string">'add-crypto'</span></span><br><span class="line"></span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into <span class="string">'CryptoLibrary'</span>...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">'adding crypto library'</span></span><br><span class="line">[add-crypto 4445836] adding crypto library</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 160000 CryptoLibrary</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	CryptoLibrary/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure>
<p>移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。 如果你移除它然后切换回有那个子模块的分支，需要运行 <code>submodule update --init</code> 来重新建立和填充。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -fdx</span><br><span class="line">Removing CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git checkout add-crypto</span><br><span class="line">Switched to branch <span class="string">'add-crypto'</span></span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git submodule update --init</span><br><span class="line">Submodule path <span class="string">'CryptoLibrary'</span>: checked out <span class="string">'b8dda6aa182ea4464f3f3264b11e0268545172af'</span></span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line">Makefile	includes	scripts		src</span><br></pre></td></tr></table></figure>
<p>再说一遍，这真的不难，只是会让人有点儿困惑。</p>
<p>新版的 Git（&gt;= 2.13）通过为 <code>git checkout</code> 命令添加 <code>--recurse-submodules</code> 选项简化了所有这些步骤， 它能为了我们要切换到的分支让子模块处于的正确状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.13.3</span><br><span class="line"></span><br><span class="line">$ git checkout -b add-crypto</span><br><span class="line">Switched to a new branch <span class="string">'add-crypto'</span></span><br><span class="line"></span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into <span class="string">'CryptoLibrary'</span>...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">'adding crypto library'</span></span><br><span class="line">[add-crypto 4445836] adding crypto library</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 160000 CryptoLibrary</span><br><span class="line"></span><br><span class="line">$ git checkout --recurse-submodules master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>当你在父级项目的几个分支上工作时，对 <code>git checkout</code> 使用 <code>--recurse-submodules</code> 选项也很有用， 它能让你的子模块处于不同的提交上。确实，如果你在记录了子模块的不同提交的分支上切换， 那么在执行 <code>git status</code> 后子模块会显示为“已修改”并指出“新的提交”。 这是因为子模块的状态默认不会在切换分支时保留。</p>
<p>这点非常让人困惑，因此当你的项目中拥有子模块时，可以总是使用 <code>git checkout --recurse-submodules</code>。 （对于没有 <code>--recurse-submodules</code> 选项的旧版 Git，在检出之后可使用 <code>git submodule update --init --recursive</code> 来让子模块处于正确的状态）。</p>
<p>幸运的是，你可以通过 <code>git config submodule.recurse true</code> 设置 <code>submodule.recurse</code> 选项， 告诉 Git（&gt;=2.14）总是使用 <code>--recurse-submodules</code>。 如上所述，这也会让 Git 为每个拥有 <code>--recurse-submodules</code> 选项的命令（除了 <code>git clone</code>） 总是递归地在子模块中执行。</p>
<h5 id="从子目录切换到子模块"><a href="#从子目录切换到子模块" class="headerlink" title="从子目录切换到子模块"></a>从子目录切换到子模块</h5><p>另一个主要的告诫是许多人遇到了将子目录转换为子模块的问题。 如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行 <code>submodule add</code>，Git 会朝你大喊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf CryptoLibrary/</span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line"><span class="string">'CryptoLibrary'</span> already exists <span class="keyword">in</span> the index</span><br></pre></td></tr></table></figure>
<p>你必须要先取消暂存 <code>CryptoLibrary</code> 目录。 然后才可以添加子模块：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm -r CryptoLibrary</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule add https://github.com/chaconinc/CryptoLibrary</span></span><br><span class="line">Cloning into 'CryptoLibrary'...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure>
<p>现在假设你在一个分支下做了这样的工作。 如果尝试切换回的分支中那些文件还在子目录而非子模块中时——你会得到这个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">  CryptoLibrary/Makefile</span><br><span class="line">  CryptoLibrary/includes/crypto.h</span><br><span class="line">  ...</span><br><span class="line">Please move or remove them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>checkout -f</code> 来强制切换，但是要小心，如果其中还有未保存的修改，这个命令会把它们覆盖掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -f master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>当你切换回来之后，因为某些原因你得到了一个空的 <code>CryptoLibrary</code> 目录，并且 <code>git submodule update</code> 也无法修复它。 你需要进入到子模块目录中运行 <code>git checkout .</code> 来找回所有的文件。 你也可以通过 <code>submodule foreach</code> 脚本来为多个子模块运行它。</p>
<p>要特别注意的是，近来子模块会将它们的所有 Git 数据保存在顶级项目的 <code>.git</code> 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失任何提交或分支。</p>
<p>拥有了这些工具，使用子模块会成为可以在几个相关但却分离的项目上同时开发的相当简单有效的方法。</p>
<h3 id="Git-Configuration"><a href="#Git-Configuration" class="headerlink" title="Git Configuration"></a><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration" target="_blank" rel="external nofollow noopener noreferrer">Git Configuration</a></h3><h3 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="external nofollow noopener noreferrer">Git Hooks</a></h3><h2 id="Git-Internal"><a href="#Git-Internal" class="headerlink" title="Git Internal"></a>Git Internal</h2><p>Git常用命令共有30多个，可运行<code>git help</code>查看；但Git总共有130多个命令，可以通过<code>git help -a</code>查看，这些命令可以分为高层命令和底层命令，底层命令被设计成unix风格，不常用</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/464.png"></p>
<p>Git仓库下有一个.git目录，里面存储了git全部的秘密，一般包括下面的内容：</p>
<ul>
<li>config</li>
<li>index</li>
<li>HEAD</li>
<li>hooks/</li>
<li>logs/</li>
<li>refs/</li>
<li>objects/</li>
</ul>
<p>下面会详细介绍没个部分都是什么</p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在配置文件里有表现； fetch操作的行为也是在这里配置的</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="keyword">false</span></span><br><span class="line">    bare = <span class="keyword">false</span></span><br><span class="line">    logallrefupdates = <span class="keyword">true</span></span><br><span class="line">    symlinks = <span class="keyword">false</span></span><br><span class="line">    ignorecase = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git<span class="variable">@github</span>.<span class="symbol">com:</span>yanhaijing/zepto.fullpage.git</span><br><span class="line">    fetch = +refs/heads/*<span class="symbol">:refs/remotes/origin/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[branch <span class="string">"dev"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/dev</span><br></pre></td></tr></table></figure>
<h3 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h3><p>git通过一种算法可以得到任意文件的指纹(40位16进制数字)，然后通过文件指纹存取数据，存取的数据都位于objects目录</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/465.png"></p>
<ul>
<li><p>Git常用命令共有30多个，可运行<code>git help</code>查看；但Git总共有130多个命令，可以通过<code>git help -a</code>查看，这些命令可以分为高层命令和底层命令，底层命令被设计成unix风格，不常用</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/464.png"></p>
<p>Git仓库下有一个.git目录，里面存储了git全部的秘密，一般包括下面的内容：</p>
<ul>
<li>config</li>
<li>index</li>
<li>HEAD</li>
<li>hooks/</li>
<li>logs/</li>
<li>refs/</li>
<li>objects/</li>
</ul>
<p>下面会详细介绍没个部分都是什么</p>
<h2 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h2><p>config是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在配置文件里有表现； fetch操作的行为也是在这里配置的</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="keyword">false</span></span><br><span class="line">    bare = <span class="keyword">false</span></span><br><span class="line">    logallrefupdates = <span class="keyword">true</span></span><br><span class="line">    symlinks = <span class="keyword">false</span></span><br><span class="line">    ignorecase = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git<span class="variable">@github</span>.<span class="symbol">com:</span>yanhaijing/zepto.fullpage.git</span><br><span class="line">    fetch = +refs/heads/*<span class="symbol">:refs/remotes/origin/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[branch <span class="string">"dev"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/dev</span><br></pre></td></tr></table></figure>
<h2 id="objects-1"><a href="#objects-1" class="headerlink" title="objects"></a>objects</h2><p>git通过一种算法可以得到任意文件的指纹(40位16进制数字)，然后通过文件指纹存取数据，存取的数据都位于objects目录</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/465.png"></p>
<p>Git 从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。Git存储的索引内容包含三种对象：</p>
<ul>
<li><strong>commit对象</strong>：<strong>每次提交都会至少产生一个commit对象</strong>，它的内容包括：指向parent commit对象，根tree对象。</li>
<li><strong>tree对象</strong>：类似于目录，tree对象中包含多条记录，每条记录保存了本次快照的所有tree对象和blob对象。</li>
<li><strong>blob对象</strong>：类似于文件，保存具体的文件内容。</li>
</ul>
<p>objects目录下有3种类型的数据：</p>
<ul>
<li>Blob</li>
<li>Tree</li>
<li>Commit</li>
</ul>
<p>文件都被存储为blob类型的文件，可以通过内部命令<code>hash-object</code>写入数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>
<p>然后通过<code>cat-file</code>取出数据</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="keyword">test </span>content</span><br></pre></td></tr></table></figure>
<p>文件夹被存储为tree类型的文件，文件内容如下所示</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p <span class="number">99</span>f<span class="number">1</span>a<span class="number">6</span>d<span class="number">12</span>cb<span class="number">4</span>b<span class="number">6</span>f<span class="number">19</span><span class="keyword">c</span><span class="number">8655</span>fca<span class="number">46</span><span class="keyword">c</span><span class="number">3</span>ecf<span class="number">317074e0</span></span><br><span class="line"><span class="number">100644</span> blob <span class="number">47</span><span class="keyword">c</span><span class="number">6340</span>d<span class="number">6459e05787</span>f<span class="number">644</span><span class="keyword">c</span><span class="number">2447</span>d<span class="number">2595</span>f<span class="number">5</span>d<span class="number">3</span>a<span class="number">54</span>b      simplegit.rb</span><br></pre></td></tr></table></figure>
<p>一般我们系统中的目录，在git中会像下面这样存储</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/466.png"></p>
<p>创建的提交节点被存储为commit类型数据，commit文件的内容如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line">committer Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure>
<p>有三个提交的Git仓库可简化为下图所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/467.png"></p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>refs目录存储都是引用文件，如本地分支，远端分支，标签等</p>
<ul>
<li>refs/heads/xxx 本地分支</li>
<li>refs/remotes/origin/xxx 远端分支</li>
<li>refs/tags/xxx 本地tag</li>
</ul>
<p>引用文件的内容都是40位commit</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/470.png"></p>
<p>上面只有提交的图补上分支后，如下所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/468.png"></p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD文件存储的是当前所在的位置，其内容可以使分支名字，40位commit ID</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat HEAD</span><br><span class="line"><span class="built_in">ref</span>s/heads/master</span><br></pre></td></tr></table></figure>
<p>上面的图补上HEAD后，如下所示：</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/469.png"></p>
</li>
</ul>
<p>文件都被存储为blob类型的文件，可以通过内部命令<code>hash-object</code>写入数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>
<p>然后通过<code>cat-file</code>取出数据</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="keyword">test </span>content</span><br></pre></td></tr></table></figure>
<p>文件夹被存储为tree类型的文件，文件内容如下所示</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p <span class="number">99</span>f<span class="number">1</span>a<span class="number">6</span>d<span class="number">12</span>cb<span class="number">4</span>b<span class="number">6</span>f<span class="number">19</span><span class="keyword">c</span><span class="number">8655</span>fca<span class="number">46</span><span class="keyword">c</span><span class="number">3</span>ecf<span class="number">317074e0</span></span><br><span class="line"><span class="number">100644</span> blob <span class="number">47</span><span class="keyword">c</span><span class="number">6340</span>d<span class="number">6459e05787</span>f<span class="number">644</span><span class="keyword">c</span><span class="number">2447</span>d<span class="number">2595</span>f<span class="number">5</span>d<span class="number">3</span>a<span class="number">54</span>b      simplegit.rb</span><br></pre></td></tr></table></figure>
<p>一般我们系统中的目录，在git中会像下面这样存储</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/466.png"></p>
<p>创建的提交节点被存储为commit类型数据，commit文件的内容如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line">committer Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure>
<p>有三个提交的Git仓库可简化为下图所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/467.png"></p>
<h3 id="refs-1"><a href="#refs-1" class="headerlink" title="refs"></a>refs</h3><p>refs目录存储都是引用文件，如本地分支，远端分支，标签等</p>
<ul>
<li>refs/heads/xxx 本地分支</li>
<li>refs/remotes/origin/xxx 远端分支</li>
<li>refs/tags/xxx 本地tag</li>
</ul>
<p>引用文件的内容都是40位commit</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/470.png"></p>
<p>上面只有提交的图补上分支后，如下所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/468.png"></p>
<h3 id="HEAD-1"><a href="#HEAD-1" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD文件存储的是当前所在的位置，其内容可以使分支名字，40位commit ID</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat HEAD</span><br><span class="line"><span class="built_in">ref</span>s/heads/master</span><br></pre></td></tr></table></figure>
<p>上面的图补上HEAD后，如下所示：</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/469.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/git-school/visualizing-git" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/git-school/visualizing-git</a></li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external nofollow noopener noreferrer">https://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></li>
<li><a href="https://www.cnblogs.com/qcloud1001/p/10006556.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/qcloud1001/p/10006556.html</a></li>
<li><a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1" target="_blank" rel="external nofollow noopener noreferrer">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1</a></li>
<li><a href="https://juejin.im/post/5c714d18f265da2d98090503" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.im/post/5c714d18f265da2d98090503</a></li>
<li><a href="https://yanhaijing.com/git/2017/02/08/deep-git-3/" target="_blank" rel="external nofollow noopener noreferrer">https://yanhaijing.com/git/2017/02/08/deep-git-3/</a></li>
<li><a href="http://walkerdu.com/2019/11/25/git_basic/" target="_blank" rel="external nofollow noopener noreferrer">http://walkerdu.com/2019/11/25/git_basic/</a></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/8fc468f1/" rel="bookmark">Git 服务器</a></div>
    </li>
  </ul>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/wechatpay.png" alt="Houmin 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/alipay.jpg" alt="Houmin 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Houmin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://houmin.cc/posts/5bd9b965/" title="图解 Git">http://houmin.cc/posts/5bd9b965/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/git/" rel="tag"><i class="fa fa-tag"></i> git</a>
              <a href="/tags/workflow/" rel="tag"><i class="fa fa-tag"></i> workflow</a>
              <a href="/tags/visualized/" rel="tag"><i class="fa fa-tag"></i> visualized</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/56733fd3/" rel="next" title="Base64编码及其实现">
                  <i class="fa fa-chevron-left"></i> Base64编码及其实现
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/8fc468f1/" rel="prev" title="Git 服务器">
                  Git 服务器 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#版本控制系统"><span class="nav-number">1.</span> <span class="nav-text">版本控制系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地版本控制系统"><span class="nav-number">1.1.</span> <span class="nav-text">本地版本控制系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集中式版本控制系统"><span class="nav-number">1.2.</span> <span class="nav-text">集中式版本控制系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式版本控制系统"><span class="nav-number">1.3.</span> <span class="nav-text">分布式版本控制系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-工作模型"><span class="nav-number">2.</span> <span class="nav-text">Git 工作模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Snapshots-Not-Differents"><span class="nav-number">2.1.</span> <span class="nav-text">Snapshots, Not Differents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Three-States"><span class="nav-number">2.2.</span> <span class="nav-text">The Three States</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-命令图解"><span class="nav-number">3.</span> <span class="nav-text">Git 命令图解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-diff"><span class="nav-number">3.1.</span> <span class="nav-text">git diff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-commit"><span class="nav-number">3.2.</span> <span class="nav-text">git commit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令图解"><span class="nav-number">3.2.1.</span> <span class="nav-text">命令图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改最近的commit"><span class="nav-number">3.2.2.</span> <span class="nav-text">更改最近的commit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-checkout"><span class="nav-number">3.3.</span> <span class="nav-text">git checkout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEAD标识处于分离状态时的提交操作"><span class="nav-number">3.4.</span> <span class="nav-text">HEAD标识处于分离状态时的提交操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-reset"><span class="nav-number">3.5.</span> <span class="nav-text">git reset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Soft-Reset"><span class="nav-number">3.5.1.</span> <span class="nav-text">Soft Reset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hard-Reset"><span class="nav-number">3.5.2.</span> <span class="nav-text">Hard Reset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#撤销-add"><span class="nav-number">3.5.3.</span> <span class="nav-text">撤销 add</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-revert"><span class="nav-number">3.6.</span> <span class="nav-text">git revert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-merge"><span class="nav-number">3.7.</span> <span class="nav-text">git merge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令图解-1"><span class="nav-number">3.7.1.</span> <span class="nav-text">命令图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决冲突"><span class="nav-number">3.7.2.</span> <span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fast-Forward"><span class="nav-number">3.7.3.</span> <span class="nav-text">Fast Forward</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-cherry-pick"><span class="nav-number">3.8.</span> <span class="nav-text">git cherry-pick</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令图解-2"><span class="nav-number">3.8.1.</span> <span class="nav-text">命令图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">3.8.2.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令参数"><span class="nav-number">3.8.3.</span> <span class="nav-text">命令参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决冲突-1"><span class="nav-number">3.8.4.</span> <span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移到另一个代码库"><span class="nav-number">3.8.5.</span> <span class="nav-text">转移到另一个代码库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-rebase"><span class="nav-number">3.9.</span> <span class="nav-text">git rebase</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令图解-3"><span class="nav-number">3.9.1.</span> <span class="nav-text">命令图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冲突解决"><span class="nav-number">3.9.2.</span> <span class="nav-text">冲突解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩commit"><span class="nav-number">3.9.3.</span> <span class="nav-text">压缩commit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#丢弃commit"><span class="nav-number">3.9.4.</span> <span class="nav-text">丢弃commit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-remote"><span class="nav-number">3.10.</span> <span class="nav-text">git remote</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-fetch"><span class="nav-number">3.11.</span> <span class="nav-text">git fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-pull"><span class="nav-number">3.12.</span> <span class="nav-text">git pull</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-push"><span class="nav-number">3.13.</span> <span class="nav-text">git push</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-log"><span class="nav-number">3.14.</span> <span class="nav-text">git log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-reflog"><span class="nav-number">3.15.</span> <span class="nav-text">git reflog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-show"><span class="nav-number">3.16.</span> <span class="nav-text">git show</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-stash"><span class="nav-number">3.17.</span> <span class="nav-text">git stash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-工作流"><span class="nav-number">4.</span> <span class="nav-text">Git 工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-Flow"><span class="nav-number">4.1.</span> <span class="nav-text">Git Flow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Github-Flow"><span class="nav-number">4.2.</span> <span class="nav-text">Github Flow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gitlab-Flow"><span class="nav-number">4.3.</span> <span class="nav-text">Gitlab Flow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-工具"><span class="nav-number">5.</span> <span class="nav-text">Git 工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rewriting-History"><span class="nav-number">5.1.</span> <span class="nav-text">Rewriting History</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signing-Your-Work"><span class="nav-number">5.2.</span> <span class="nav-text">Signing Your Work</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Submodules"><span class="nav-number">5.3.</span> <span class="nav-text">Submodules</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开始使用子模块"><span class="nav-number">5.3.1.</span> <span class="nav-text">开始使用子模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆含有子模块的项目"><span class="nav-number">5.3.2.</span> <span class="nav-text">克隆含有子模块的项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在包含子模块的项目上工作"><span class="nav-number">5.3.3.</span> <span class="nav-text">在包含子模块的项目上工作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#从子模块的远端拉取上游修改"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">从子模块的远端拉取上游修改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从项目远端拉取上游更改"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">从项目远端拉取上游更改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在子模块上工作"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">在子模块上工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#发布子模块改动"><span class="nav-number">5.3.3.4.</span> <span class="nav-text">发布子模块改动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并子模块改动"><span class="nav-number">5.3.3.5.</span> <span class="nav-text">合并子模块改动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子模的块技巧"><span class="nav-number">5.3.4.</span> <span class="nav-text">子模的块技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#子模块遍历"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">子模块遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有用的别名"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">有用的别名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子模块的问题"><span class="nav-number">5.3.5.</span> <span class="nav-text">子模块的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#切换分支"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">切换分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从子目录切换到子模块"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">从子目录切换到子模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-Configuration"><span class="nav-number">5.4.</span> <span class="nav-text">Git Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-Hooks"><span class="nav-number">5.5.</span> <span class="nav-text">Git Hooks</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-Internal"><span class="nav-number">6.</span> <span class="nav-text">Git Internal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#config"><span class="nav-number">6.1.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objects"><span class="nav-number">6.2.</span> <span class="nav-text">objects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#config-1"><span class="nav-number">7.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objects-1"><span class="nav-number">8.</span> <span class="nav-text">objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#refs"><span class="nav-number">9.</span> <span class="nav-text">refs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HEAD"><span class="nav-number">10.</span> <span class="nav-text">HEAD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#refs-1"><span class="nav-number">10.1.</span> <span class="nav-text">refs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEAD-1"><span class="nav-number">10.2.</span> <span class="nav-text">HEAD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">11.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Houmin" src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
  <p class="site-author-name" itemprop="name">Houmin</p>
  <div class="site-description" itemprop="description">丈夫拥书万卷，何假南面百城</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">212</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SimpCosm" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SimpCosm" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weihoumin@gmail.com" title="E-Mail &amp;rarr; mailto:weihoumin@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="hitokoto">
    <!-- hitokoto -->
    <div id="hito-expression">:D 获取中...</div>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
      fetch('https://v1.hitokoto.cn')
        .then(function (res){
          return res.json();
        })
        .then(function (data) {
          var hitokoto = document.getElementById('hito-expression');
          hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
        })
        .catch(function (err) {
          console.error(err);
        })
    </script>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houmin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">49:11</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>



  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '800px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'iEBFuhVyk4tuhVYctQ265uid-gzGzoHsz',
    appKey: 'KGjOktrtgSEWK1v9DYA3T3Az',
    placeholder: "Just go go",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
