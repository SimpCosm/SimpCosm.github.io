<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/theme/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/theme/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Houmin" type="application/atom+xml">
  <meta name="google-site-verification" content="zdGhdEF7jHoJW58lsdN6l9JrQFjJFwakCIc7TbbosV0">
  <meta name="msvalidate.01" content="2F527B379ED5537861D0D38C2C754C2B">
  <meta name="baidu-site-verification" content="xAag2PqzKE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="ApiServer作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的">
<meta name="keywords" content="源码解读,k8s,go,apiserver">
<meta property="og:type" content="article">
<meta property="og:title" content="【Kubernetes解读】ApiServer之初识API">
<meta property="og:url" content="http://houmin.cc/posts/3bc1a603/index.html">
<meta property="og:site_name" content="Houmin">
<meta property="og:description" content="ApiServer作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://cdn.tianfeiyu.com/API-server-space-1.png">
<meta property="og:image" content="https://www.openshift.com/hs-fs/hubfs/Imported_Blog_Media/API-server-gvr.png?width=400&amp;height=152&amp;name=API-server-gvr.png">
<meta property="og:image" content="http://images.liuliqiang.info/2019/11/24/02/25/56/d14b874da710/">
<meta property="og:image" content="http://cdn.tianfeiyu.com/API-server-flow-2.png">
<meta property="og:image" content="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_start.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_init.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/restfulapi_new.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/list_watch.png">
<meta property="og:updated_time" content="2020-08-07T03:49:53.633Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.tianfeiyu.com/API-server-space-1.png">

<link rel="canonical" href="http://houmin.cc/posts/3bc1a603/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>【Kubernetes解读】ApiServer之初识API | Houmin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="/js/photoswipe.min.js?v="></script>
  <script src="/js/photoswipe-ui-default.min.js?v="></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Houmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Yesterday You Said Tomorrow</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-album">

    <a href="/album" rel="section"><i class="fa fa-fw fa-camera"></i>相册</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://houmin.cc/posts/3bc1a603/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/theme/avatar.png">
      <meta itemprop="name" content="Houmin">
      <meta itemprop="description" content="丈夫拥书万卷，何假南面百城">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Houmin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          【Kubernetes解读】ApiServer之初识API
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-07 20:46:14" itemprop="dateCreated datePublished" datetime="2020-08-07T20:46:14+08:00">2020-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/" itemprop="url" rel="index">
                    <span itemprop="name">术业专攻</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/3bc1a603/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/3bc1a603/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>107k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:15</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>ApiServer</code>作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。</p>
<p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：</p>
<ul>
<li>提供 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用</li>
<li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；</li>
<li>允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd</li>
<li>资源在不同版本之间的转换</li>
</ul>
<a id="more"></a>
<h2 id="API-Overview"><a href="#API-Overview" class="headerlink" title="API Overview"></a>API Overview</h2><p>ApiServer 主要通过对外提供HTTP API 的方式与其他组件进行交互。API首选的序列化方案是JSON，但是也支持Protobuf协议。API主要有下面三种类型：</p>
<ul>
<li>core group：主要在 <code>/api/v1</code> 下；</li>
<li>named groups：其 path 为 <code>/apis/$NAME/$VERSION</code>；</li>
<li>暴露系统状态的一些 API：如<code>/metrics</code> 、<code>/healthz</code> 等；</li>
</ul>
<p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-space-1.png"></p>
<h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><p><img alt="Terminology" data-src="https://www.openshift.com/hs-fs/hubfs/Imported_Blog_Media/API-server-gvr.png?width=400&amp;height=152&amp;name=API-server-gvr.png"></p>
<h4 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h4><p>Kubernetes中的每个对象都有一个字段 <code>Kind</code> 表明其类型，以Pod为例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p><code>Kubernetes</code> 中 Kind 有三种类型：</p>
<ul>
<li>系统中持久的实体对象，比如 <code>Pod</code> , <code>Namespace</code></li>
<li>一系列有某些共同特征的实体列表，比如 <code>PodLists</code>，<code>NodeLists</code></li>
<li>用于某些特定应用的一些非持久的实体，比如 <code>APIGroup</code>，<code>APIResource</code>, <code>Status</code></li>
</ul>
<h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p><code>API Group</code> 是一些有关系的Kinds的集合，比如所有的批处理对象，<code>Job</code> 或者 <code>ScheduledJob</code> 都在 <code>batch</code>这个API Group。</p>
<h4 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h4><p>每个 API Group 下面都能存在有多个 version 版本。为了扩展性，Kubernetes支持多版本的API路径，比如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1/</code>， 不同版本的API意味着不同程度的稳定性和支持度。比如在一个 group 群组中最早有第一个 v1alpha1 版本，后来中间发展到了 v1beta1 版本，最终发展到 v1 的稳定版本。 如果在系统创建了一个 v1beta1 版本的对象，那么它能过被 Group 任一支持的版本（ 比如v1 ）检索到， 这是由于 API server 能够支持不同版本对象之间的无损耗转换。</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>Resource 代表以 JSON 格式通过 HTTP 发送或检索的资源实体。 它既可以使一个单独的resource资源（比如…/namespaces/default，也可以是一组resource 资源（比如…/jobs）。 这里说明一下 Reource 和 Kind 的区别： 其实基本上都是一个概念，只是 Kind 表示一个种类，在实际中它是首字母大写的； Resource 表示资源，在实际中它是全部小写的，并且有单数和复数之分。我们可以把Kind和Resource的关系理解成面向对象编程中类与对象的关系，Kind 其实就是一个类，用于描述对象的；而 Resource 就是具体的 Kind，可以理解成类已经实例化成对象。</p>
<h3 id="GVK-GVR"><a href="#GVK-GVR" class="headerlink" title="GVK/GVR"></a>GVK/GVR</h3><p>在Kubernetes中，要想定位一个对象，我们需要指定GVK或者GVR。比如这里声明了 apiVersion 是 <code>apps/v1</code>，其实就是隐含了 <code>Group</code> 是 apps，<code>Version</code> 是 v1，<code>Kind</code> 就是定义的 DaemonSet，而 kubectl 接收到这个声明之后，就可以根据这个声明去调用 API Server 对应的 URL 去获取信息，例如这个就是 <code>/api/apps/v1/daemonset</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br></pre></td></tr></table></figure>
<p>对应到实际的URI的请求组织形式，如下图所示：</p>
<p><img alt="GVR" data-src="http://images.liuliqiang.info/2019/11/24/02/25/56/d14b874da710/"></p>
<h2 id="API-Request-Flow"><a href="#API-Request-Flow" class="headerlink" title="API Request Flow"></a>API Request Flow</h2><p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</p>
<p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-flow-2.png"></p>
<p>关于 API 的处理代码都在 <code>k8s.io/pkg/api</code> 包中，会处理来自集群内部和集群外部的API请求。</p>
<p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链。该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：</p>
<p><img alt="API-server-storage-flow-2" data-src="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png"></p>
<h2 id="Handler-Chain"><a href="#Handler-Chain" class="headerlink" title="Handler Chain"></a>Handler Chain</h2><p><strong>Decoder</strong></p>
<p>kubernetes 中的多数 resource 都会有一个 <code>internal version</code>，因为在整个开发过程中一个 resource 可能会对应多个 version，比如 deployment 会有 <code>extensions/v1beta1</code>，<code>apps/v1</code>。 为了避免出现问题，kube-apiserver 必须要知道如何在每一对版本之间进行转换（例如，v1⇔v1alpha1，v1⇔v1beta1，v1beta1⇔v1alpha1），因此其使用了一个特殊的<code>internal version</code>，<code>internal version</code> 作为一个通用的 version 会包含所有 version 的字段，它具有所有 version 的功能。 Decoder 会首先把 creater object 转换到 <code>internal version</code>，然后将其转换为 <code>storage version</code>，<code>storage version</code> 是在 etcd 中存储时的另一个 version。</p>
<p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。</p>
<p><strong>Admission</strong></p>
<p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 <code>k8s.io/kubernetes/plugin/pkg/admission</code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 <code>--enable-admission-plugins</code> 参数来开启需要使用的插件，通过 <code>ValidatingAdmissionWebhook</code> 或 <code>MutatingAdmissionWebhook</code> 添加的插件也都会在此处进行工作。</p>
<p><strong>Validation</strong></p>
<p>主要检查 object 中字段的合法性。</p>
<p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |<span class="string">    ⇒       </span>|<span class="string">    ⇒  v1  ⇒ json/yaml ⇒ etcd</span></span><br><span class="line"><span class="string">                     admission    validation</span></span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img alt="apiserver diagram" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png"></p>
<ul>
<li>Scheme：定义了资源序列化和反序列化的方法，以及资源类型和版本的对应关系</li>
<li>Storage：是对资源的完整封装，实现了资源创建、删除、watch等操作</li>
<li>APIGroupInfo：是同一个group下所有资源的集合</li>
</ul>
<p>每个资源对应着两个版本：</p>
<ul>
<li>External Object：这个版本是对外给用户访问创建的接口对象，比如使用yaml或json创建对象时，都要使用External Object</li>
<li>Internal Object：这个版本是核心对象，实现了资源的创建和删除，对应了在ETCD中持久化的版本</li>
</ul>
<p>这两个版本的资源是需要相互转换的，而转换的函数就需要事先初始化到Scheme中， 多个external version版本之间的资源进行相互转换，都是需要通过internal version进行中转。所以在ETCD中存储的资源是带版本的，这也是kubernetes能实现多版本转换的关键。</p>
<h2 id="kube-apiserver-中的组件"><a href="#kube-apiserver-中的组件" class="headerlink" title="kube-apiserver 中的组件"></a>kube-apiserver 中的组件</h2><p>kube-apiserver 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：</p>
<ul>
<li><strong>Aggregator</strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；</li>
<li><strong>KubeAPIServer</strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；</li>
<li><strong>APIExtensionServer</strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。</li>
</ul>
<p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。</p>
<h3 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h3><p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 <code>GenericAPIServer</code> 和维护自身状态的 Controller。其中 <code>GenericAPIServer</code> 主要处理 <code>apiregistration.k8s.io</code> 组下的 APIService 资源请求。</p>
<p><strong>Aggregator 除了处理资源请求外还包含几个 controller：</strong></p>
<ul>
<li>1、<code>apiserviceRegistrationController</code>：负责 APIServices 中资源的注册与删除；</li>
<li>2、<code>availableConditionController</code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；</li>
<li>3、<code>autoRegistrationController</code>：用于保持 API 中存在的一组特定的 APIServices；</li>
<li>4、<code>crdRegistrationController</code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；</li>
<li>5、<code>openAPIAggregationController</code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；</li>
</ul>
<p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="external nofollow noopener noreferrer">apiserver-builder</a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。</p>
<h5 id="启用-API-Aggregation"><a href="#启用-API-Aggregation" class="headerlink" title="启用 API Aggregation"></a>启用 API Aggregation</h5><p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--proxy-client-cert-file</span>=/etc/kubernetes/certs/proxy.crt</span><br><span class="line"><span class="attr">--proxy-client-key-file</span>=/etc/kubernetes/certs/proxy.key</span><br><span class="line"><span class="attr">--requestheader-client-ca-file</span>=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line"><span class="attr">--requestheader-allowed-names</span>=aggregator</span><br><span class="line"><span class="attr">--requestheader-extra-headers-prefix</span>=X-Remote-Extra-</span><br><span class="line"><span class="attr">--requestheader-group-headers</span>=X-Remote-Group</span><br><span class="line"><span class="attr">--requestheader-username-headers</span>=X-Remote-User</span><br></pre></td></tr></table></figure>
<h3 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h3><p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。</p>
<h3 id="APIExtensionServer"><a href="#APIExtensionServer" class="headerlink" title="APIExtensionServer"></a>APIExtensionServer</h3><p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。</p>
<p>其中包含的 controller 以及功能如下所示：</p>
<ul>
<li>1、<code>openapiController</code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 <code>/openapi/v2</code> 进行查看；</li>
<li>2、<code>crdController</code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 <code>$ kubectl api-versions</code> 和 <code>$ kubectl api-resources</code> 查看；</li>
<li>3、<code>namingController</code>：检查 crd obj 中是否有命名冲突，可在 crd <code>.status.conditions</code> 中查看；</li>
<li>4、<code>establishingController</code>：检查 crd 是否处于正常状态，可在 crd <code>.status.conditions</code> 中查看；</li>
<li>5、<code>nonStructuralSchemaController</code>：检查 crd obj 结构是否正常，可在 crd <code>.status.conditions</code> 中查看；</li>
<li>6、<code>apiApprovalController</code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd <code>.status.conditions</code> 中查看；</li>
<li>7、<code>finalizingController</code>：类似于 finalizes 的功能，与 CRs 的删除有关；</li>
</ul>
<h3 id="kube-apiserver-启动流程分析"><a href="#kube-apiserver-启动流程分析" class="headerlink" title="kube-apiserver 启动流程分析"></a>kube-apiserver 启动流程分析</h3><blockquote>
<p>kubernetes 版本：v1.16</p>
</blockquote>
<p>首先分析 kube-apiserver 的启动方式，kube-apiserver 也是通过其 <code>Run</code> 方法启动主逻辑的，在<code>Run</code> 方法调用之前会进行解析命令行参数、设置默认值等。</p>
<h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><p><code>Run</code> 方法的主要逻辑为：</p>
<ul>
<li>1、调用 <code>CreateServerChain</code> 构建服务调用链并判断是否启动非安全的 http server，http server 链中包含 apiserver 要启动的三个 server，以及为每个 server 注册对应资源的路由；</li>
<li>2、调用 <code>server.PrepareRun</code> 进行服务运行前的准备，该方法主要完成了健康检查、存活检查和<code>OpenAPI</code>路由的注册工作；</li>
<li>3、调用 <code>prepared.Run</code> 启动 https server；</li>
</ul>
<p>server 的初始化使用委托模式，通过 DelegationTarget 接口，把基本的 API Server、CustomResource、Aggregator 这三种服务采用链式结构串联起来，对外提供服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span>:<span class="number">147</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(completeOptions completedServerRunOptions, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server, err := CreateServerChain(completeOptions, stopCh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepared, err := server.PrepareRun()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prepared.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CreateServerChain"><a href="#CreateServerChain" class="headerlink" title="CreateServerChain"></a>CreateServerChain</h4><p><code>CreateServerChain</code> 是完成 server 初始化的方法，里面包含 <code>APIExtensionsServer</code>、<code>KubeAPIServer</code>、<code>AggregatorServer</code> 初始化的所有流程，最终返回 <code>aggregatorapiserver.APIAggregator</code> 实例，初始化流程主要有：http filter chain 的配置、API Group 的注册、http path 与 handler 的关联以及 handler 后端存储 etcd 的配置。其主要逻辑为：</p>
<ul>
<li>1、调用 <code>CreateKubeAPIServerConfig</code> 创建 KubeAPIServer 所需要的配置，主要是创建 <code>master.Config</code>，其中会调用 <code>buildGenericConfig</code> 生成 genericConfig，genericConfig 中包含 apiserver 的核心配置；</li>
<li>2、判断是否启用了扩展的 API server 并调用 <code>createAPIExtensionsConfig</code> 为其创建配置，apiExtensions server 是一个代理服务，用于代理 kubeapiserver 中的其他 server，比如 metric-server；</li>
<li>3、调用 <code>createAPIExtensionsServer</code> 创建 apiExtensionsServer 实例；</li>
<li>4、调用 <code>CreateKubeAPIServer</code>初始化 kubeAPIServer；</li>
<li>5、调用 <code>createAggregatorConfig</code> 为 aggregatorServer 创建配置并调用 <code>createAggregatorServer</code> 初始化 aggregatorServer；</li>
<li>6、配置并判断是否启动非安全的 http server；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span>:<span class="number">165</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateServerChain</span><span class="params">(completedOptions completedServerRunOptions, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*aggregatorapiserver.APIAggregator, error)</span></span> &#123;</span><br><span class="line">    nodeTunneler, proxyTransport, err := CreateNodeDialer(completedOptions)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、为 kubeAPIServer 创建配置</span></span><br><span class="line">    kubeAPIServerConfig, insecureServingInfo, serviceResolver, pluginInitializer, admissionPostStartHook, err :=                                         CreateKubeAPIServerConfig(completedOptions, nodeTunneler, proxyTransport)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否配置了 APIExtensionsServer，创建 apiExtensionsConfig </span></span><br><span class="line">    apiExtensionsConfig, err := createAPIExtensionsConfig(*kubeAPIServerConfig.GenericConfig, kubeAPIServerConfig.ExtraConfig.VersionedInformers,        pluginInitializer, completedOptions.ServerRunOptions, completedOptions.MasterCount,</span><br><span class="line">        serviceResolver, webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, kubeAPIServerConfig.GenericConfig.LoopbackClientConfig))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、初始化 APIExtensionsServer</span></span><br><span class="line">    apiExtensionsServer, err := createAPIExtensionsServer(apiExtensionsConfig, genericapiserver.NewEmptyDelegate())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、初始化 KubeAPIServer</span></span><br><span class="line">    kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer, admissionPostStartHook)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5、创建 AggregatorConfig</span></span><br><span class="line">    aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, completedOptions.ServerRunOptions, kubeAPIServerConfig.          ExtraConfig.VersionedInformers, serviceResolver, proxyTransport, pluginInitializer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6、初始化 AggregatorServer</span></span><br><span class="line">    aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、判断是否启动非安全端口的 http server</span></span><br><span class="line">    <span class="keyword">if</span> insecureServingInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">        insecureHandlerChain := kubeserver.BuildInsecureHandlerChain(aggregatorServer.GenericAPIServer.UnprotectedHandler(), kubeAPIServerConfig.GenericConfig)</span><br><span class="line">        <span class="keyword">if</span> err := insecureServingInfo.Serve(insecureHandlerChain, kubeAPIServerConfig.GenericConfig.RequestTimeout, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CreateKubeAPIServerConfig"><a href="#CreateKubeAPIServerConfig" class="headerlink" title="CreateKubeAPIServerConfig"></a>CreateKubeAPIServerConfig</h5><p>在 <code>CreateKubeAPIServerConfig</code> 中主要是调用 <code>buildGenericConfig</code> 创建 genericConfig 以及构建 master.Config 对象。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server<span class="selector-class">.go</span>:<span class="number">271</span></span><br><span class="line">func CreateKubeAPIServerConfig(</span><br><span class="line">    s completedServerRunOptions,</span><br><span class="line">    nodeTunneler tunneler<span class="selector-class">.Tunneler</span>,</span><br><span class="line">    proxyTransport *http<span class="selector-class">.Transport</span>,</span><br><span class="line">) (......) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、构建 genericConfig</span></span><br><span class="line">    genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory,    lastErr = buildGenericConfig(s<span class="selector-class">.ServerRunOptions</span>, proxyTransport)</span><br><span class="line">    <span class="keyword">if</span> lastErr != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化所支持的 capabilities</span></span><br><span class="line">    capabilities.Initialize(capabilities.Capabilities&#123;</span><br><span class="line">        AllowPrivileged: s<span class="selector-class">.AllowPrivileged</span>,</span><br><span class="line">        PrivilegedSources: capabilities.PrivilegedSources&#123;</span><br><span class="line">            HostNetworkSources: []string&#123;&#125;,</span><br><span class="line">            HostPIDSources:     []string&#123;&#125;,</span><br><span class="line">            HostIPCSources:     []string&#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        PerConnectionBandwidthLimitBytesPerSec: s<span class="selector-class">.MaxConnectionBytesPerSec</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、获取 service ip range 以及 api server service IP</span></span><br><span class="line">    serviceIPRange, apiServerServiceIP, lastErr := master.DefaultServiceIPRange(s.PrimaryServiceClusterIPRange)</span><br><span class="line">    <span class="keyword">if</span> lastErr != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、构建 master.Config 对象</span></span><br><span class="line">    config = &amp;master.Config&#123;......&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> nodeTunneler != nil &#123;</span><br><span class="line">        config<span class="selector-class">.ExtraConfig</span><span class="selector-class">.KubeletClientConfig</span><span class="selector-class">.Dial</span> = nodeTunneler.Dial</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> config<span class="selector-class">.GenericConfig</span><span class="selector-class">.EgressSelector</span> != nil &#123;</span><br><span class="line">        config<span class="selector-class">.ExtraConfig</span><span class="selector-class">.KubeletClientConfig</span><span class="selector-class">.Lookup</span> = config<span class="selector-class">.GenericConfig</span><span class="selector-class">.EgressSelector</span>.Lookup</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="buildGenericConfig"><a href="#buildGenericConfig" class="headerlink" title="buildGenericConfig"></a>buildGenericConfig</h5><p>主要逻辑为：</p>
<ul>
<li>1、调用 <code>genericapiserver.NewConfig</code> 生成默认的 genericConfig，genericConfig 中主要配置了 <code>DefaultBuildHandlerChain</code>，<code>DefaultBuildHandlerChain</code> 中包含了认证、鉴权等一系列 http filter chain；</li>
<li>2、调用 <code>master.DefaultAPIResourceConfigSource</code> 加载需要启用的 API Resource，集群中所有的 API Resource 可以在代码的 <code>k8s.io/api</code> 目录中看到，随着版本的迭代也会不断变化；</li>
<li>3、为 genericConfig 中的部分字段设置默认值；</li>
<li>4、调用 <code>completedStorageFactoryConfig.New</code> 创建 storageFactory，后面会使用 storageFactory 为每种API Resource 创建对应的 RESTStorage；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span>:<span class="number">386</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGenericConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    s *options.ServerRunOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    proxyTransport *http.Transport,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(......)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1、为 genericConfig 设置默认值</span></span><br><span class="line">    genericConfig = genericapiserver.NewConfig(legacyscheme.Codecs)</span><br><span class="line">    genericConfig.MergedResourceConfig = master.DefaultAPIResourceConfigSource()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lastErr = s.GenericServerRunOptions.ApplyTo(genericConfig); lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig(......)</span><br><span class="line">    genericConfig.OpenAPIConfig.Info.Title = <span class="string">"Kubernetes"</span></span><br><span class="line">    genericConfig.LongRunningFunc = filters.BasicLongRunningRequestCheck(</span><br><span class="line">        sets.NewString(<span class="string">"watch"</span>, <span class="string">"proxy"</span>),</span><br><span class="line">        sets.NewString(<span class="string">"attach"</span>, <span class="string">"exec"</span>, <span class="string">"proxy"</span>, <span class="string">"log"</span>, <span class="string">"portforward"</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    kubeVersion := version.Get()</span><br><span class="line">    genericConfig.Version = &amp;kubeVersion</span><br><span class="line"></span><br><span class="line">    storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class="line">    storageFactoryConfig.ApiResourceConfig = genericConfig.MergedResourceConfig</span><br><span class="line">    completedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = err</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 storageFactory</span></span><br><span class="line">    storageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class="line">    <span class="keyword">if</span> lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> genericConfig.EgressSelector != <span class="literal">nil</span> &#123;</span><br><span class="line">        storageFactory.StorageConfig.Transport.EgressLookup = genericConfig.EgressSelector.Lookup</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、初始化 RESTOptionsGetter，后期根据其获取操作 Etcd 的句柄，同时添加 etcd 的健康检查方法</span></span><br><span class="line">    <span class="keyword">if</span> lastErr = s.Etcd.ApplyWithStorageFactoryTo(storageFactory, genericConfig); lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、设置使用 protobufs 用来内部交互，并且禁用压缩功能</span></span><br><span class="line">    genericConfig.LoopbackClientConfig.ContentConfig.ContentType = <span class="string">"application/vnd.kubernetes.protobuf"</span></span><br><span class="line">    </span><br><span class="line">    genericConfig.LoopbackClientConfig.DisableCompression = <span class="literal">true</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 4、创建 clientset</span></span><br><span class="line">    kubeClientConfig := genericConfig.LoopbackClientConfig</span><br><span class="line">    clientgoExternalClient, err := clientgoclientset.NewForConfig(kubeClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"failed to create real external clientset: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    versionedInformers = clientgoinformers.NewSharedInformerFactory(clientgoExternalClient, <span class="number">10</span>*time.Minute)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、创建认证实例，支持多种认证方式：请求 Header 认证、Auth 文件认证、CA 证书认证、Bearer token 认证、</span></span><br><span class="line">    <span class="comment">// ServiceAccount 认证、BootstrapToken 认证、WebhookToken 认证等</span></span><br><span class="line">    genericConfig.Authentication.Authenticator, genericConfig.OpenAPIConfig.SecurityDefinitions, err = BuildAuthenticator(s,                 clientgoExternalClient, versionedInformers)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"invalid authentication config: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、创建鉴权实例，包含：Node、RBAC、Webhook、ABAC、AlwaysAllow、AlwaysDeny</span></span><br><span class="line">    genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer(s, versionedInformers)</span><br><span class="line">    ......</span><br><span class="line">		</span><br><span class="line">    serviceResolver = buildServiceResolver(s.EnableAggregatorRouting, genericConfig.LoopbackClientConfig.Host, versionedInformers)</span><br><span class="line"></span><br><span class="line">    authInfoResolverWrapper := webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, genericConfig.LoopbackClientConfig)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、审计插件的初始化</span></span><br><span class="line">    lastErr = s.Audit.ApplyTo(......)</span><br><span class="line">    <span class="keyword">if</span> lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8、准入插件的初始化</span></span><br><span class="line">    pluginInitializers, admissionPostStartHook, err = admissionConfig.New(proxyTransport, serviceResolver)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"failed to create admission plugin initializer: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = s.Admission.ApplyTo(......)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"failed to initialize admission: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上主要分析 KubeAPIServerConfig 的初始化，其他两个 server config 的初始化暂且不详细分析，下面接着继续分析 server 的初始化。</p>
<h5 id="createAPIExtensionsServer"><a href="#createAPIExtensionsServer" class="headerlink" title="createAPIExtensionsServer"></a>createAPIExtensionsServer</h5><p>APIExtensionsServer 是最先被初始化的，在 <code>createAPIExtensionsServer</code> 中调用 <code>apiextensionsConfig.Complete().New</code> 来完成 server 的初始化，其主要逻辑为：</p>
<ul>
<li>1、首先调用 <code>c.GenericConfig.New</code> 按照<code>go-restful</code>的模式初始化 Container，在 <code>c.GenericConfig.New</code> 中会调用 <code>NewAPIServerHandler</code> 初始化 handler，APIServerHandler 包含了 API Server 使用的多种http.Handler 类型，包括 <code>go-restful</code> 以及 <code>non-go-restful</code>，以及在以上两者之间选择的 Director 对象，<code>go-restful</code> 用于处理已经注册的 handler，<code>non-go-restful</code> 用来处理不存在的 handler，API URI 处理的选择过程为：<code>FullHandlerChain-&gt; Director -&gt;{GoRestfulContainer， NonGoRestfulMux}</code>。在 <code>c.GenericConfig.New</code> 中还会调用 <code>installAPI</code>来添加包括 <code>/</code>、<code>/debug/*</code>、<code>/metrics</code>、<code>/version</code> 等路由信息。三种 server 在初始化时首先都会调用 <code>c.GenericConfig.New</code> 来初始化一个 genericServer，然后进行 API 的注册；</li>
<li>2、调用 <code>s.GenericAPIServer.InstallAPIGroup</code> 在路由中注册 API Resources，此方法的调用链非常深，主要是为了将需要暴露的 API Resource 注册到 server 中，以便能通过 http 接口进行 resource 的 REST 操作，其他几种 server 在初始化时也都会执行对应的 <code>InstallAPI</code>；</li>
<li>3、初始化 server 中需要使用的 controller，主要有 <code>openapiController</code>、<code>crdController</code>、<code>namingController</code>、<code>establishingController</code>、<code>nonStructuralSchemaController</code>、<code>apiApprovalController</code>、<code>finalizingControlle</code>r；</li>
<li>4、将需要启动的 controller 以及 informer 添加到 PostStartHook 中；</li>
</ul>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/apiextensions.go:94</span><br><span class="line">func createAPIExtensionsServer(apiextensionsConfig *apiextensionsapiserver.Config, delegateAPIServer genericapiserver.DelegationTarget) (*  apiextensionsapiserver.CustomResourceDefinitions, error) &#123;</span><br><span class="line">    <span class="attribute">return apiextensionsConfig.Complete().New(delegateAPIServer)</span></span><br><span class="line"><span class="attribute">&#125;</span></span><br><span class="line"><span class="attribute">k8s.io/kubernetes/staging/src/k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go</span>:132</span><br><span class="line">func (c completedConfig) New(delegationTarget genericapiserver<span class="variable">.DelegationTarget</span>) (*CustomResourceDefinitions, error) &#123;</span><br><span class="line">    // 1、初始化 genericServer</span><br><span class="line">    genericServer, err := c<span class="variable">.GenericConfig</span><span class="variable">.New</span>("apiextensions-apiserver", delegationTarget)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := &amp;CustomResourceDefinitions&#123;</span><br><span class="line">        GenericAPIServer: genericServer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、初始化 APIGroup Info，APIGroup 指该 server 需要暴露的 API</span><br><span class="line">    apiResourceConfig := c<span class="variable">.GenericConfig</span><span class="variable">.MergedResourceConfig</span></span><br><span class="line">    apiGroupInfo := genericapiserver<span class="variable">.NewDefaultAPIGroupInfo</span>(apiextensions<span class="variable">.GroupName</span>, Scheme, metav1<span class="variable">.ParameterCodec</span>, Codecs)</span><br><span class="line">    if apiResourceConfig<span class="variable">.VersionEnabled</span>(v1beta1<span class="variable">.SchemeGroupVersion</span>) &#123;</span><br><span class="line">        storage := map[string]rest<span class="variable">.Storage</span>&#123;&#125;</span><br><span class="line">        customResourceDefintionStorage := customresourcedefinition<span class="variable">.NewREST</span>(Scheme, c<span class="variable">.GenericConfig</span><span class="variable">.RESTOptionsGetter</span>)</span><br><span class="line">        storage["customresourcedefinitions"] = customResourceDefintionStorage</span><br><span class="line">        storage["customresourcedefinitions/status"] = customresourcedefinition<span class="variable">.NewStatusREST</span>(Scheme, customResourceDefintionStorage)</span><br><span class="line"></span><br><span class="line">        apiGroupInfo<span class="variable">.VersionedResourcesStorageMap</span>[v1beta1<span class="variable">.SchemeGroupVersion</span><span class="variable">.Version</span>] = storage</span><br><span class="line">    &#125;</span><br><span class="line">    if apiResourceConfig<span class="variable">.VersionEnabled</span>(v1<span class="variable">.SchemeGroupVersion</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、注册 APIGroup</span><br><span class="line">    if err := s<span class="variable">.GenericAPIServer</span><span class="variable">.InstallAPIGroup</span>(&amp;apiGroupInfo); <span class="attribute">err != nil &#123;</span></span><br><span class="line"><span class="attribute">        return nil, err</span></span><br><span class="line"><span class="attribute">    &#125;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">    // 4、初始化需要使用的 controller</span></span><br><span class="line"><span class="attribute">    crdClient, err</span> := internalclientset<span class="variable">.NewForConfig</span>(s<span class="variable">.GenericAPIServer</span><span class="variable">.LoopbackClientConfig</span>)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, fmt<span class="variable">.Errorf</span>("failed to create clientset: %v", err)</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="variable">.Informers</span> = internalinformers<span class="variable">.NewSharedInformerFactory</span>(crdClient, 5*time<span class="variable">.Minute</span>)</span><br><span class="line">		</span><br><span class="line">    ......</span><br><span class="line">    establishingController := establish<span class="variable">.NewEstablishingController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>().                    CustomResourceDefinitions(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    crdHandler, err := NewCustomResourceDefinitionHandler(......)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.Handler</span><span class="variable">.NonGoRestfulMux</span><span class="variable">.Handle</span>("/apis", crdHandler)</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.Handler</span><span class="variable">.NonGoRestfulMux</span><span class="variable">.HandlePrefix</span>("/apis/", crdHandler)</span><br><span class="line"></span><br><span class="line">    crdController := NewDiscoveryController(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>(),                 versionDiscoveryHandler, groupDiscoveryHandler)</span><br><span class="line">    namingController := status<span class="variable">.NewNamingConditionController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    nonStructuralSchemaController := nonstructuralschema<span class="variable">.NewConditionController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>().         CustomResourceDefinitions(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    apiApprovalController := apiapproval<span class="variable">.NewKubernetesAPIApprovalPolicyConformantConditionController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>().      InternalVersion()<span class="variable">.CustomResourceDefinitions</span>(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    finalizingController := finalizer<span class="variable">.NewCRDFinalizer</span>(</span><br><span class="line">        s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>(),</span><br><span class="line">        crdClient<span class="variable">.Apiextensions</span>(),</span><br><span class="line">        crdHandler,</span><br><span class="line">    )</span><br><span class="line">    var openapiController *openapicontroller<span class="variable">.Controller</span></span><br><span class="line">    if utilfeature<span class="variable">.DefaultFeatureGate</span><span class="variable">.Enabled</span>(apiextensionsfeatures<span class="variable">.CustomResourcePublishOpenAPI</span>) &#123;</span><br><span class="line">        openapiController = openapicontroller<span class="variable">.NewController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5、将 informer 以及 controller 添加到 PostStartHook 中</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.AddPostStartHookOrDie</span>("start-apiextensions-informers", func(context genericapiserver<span class="variable">.PostStartHookContext</span>) error &#123;</span><br><span class="line">        s<span class="variable">.Informers</span><span class="variable">.Start</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;)</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.AddPostStartHookOrDie</span>("start-apiextensions-controllers", func(context genericapiserver<span class="variable">.PostStartHookContext</span>) error &#123;</span><br><span class="line">        ......</span><br><span class="line">        go crdController<span class="variable">.Run</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        go namingController<span class="variable">.Run</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        go establishingController<span class="variable">.Run</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        go nonStructuralSchemaController<span class="variable">.Run</span>(5, context<span class="variable">.StopCh</span>)</span><br><span class="line">        go apiApprovalController<span class="variable">.Run</span>(5, context<span class="variable">.StopCh</span>)</span><br><span class="line">        go finalizingController<span class="variable">.Run</span>(5, context<span class="variable">.StopCh</span>)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.AddPostStartHookOrDie</span>("crd-informer-synced", func(context genericapiserver<span class="variable">.PostStartHookContext</span>) error &#123;</span><br><span class="line">        return wait<span class="variable">.PollImmediateUntil</span>(100*time<span class="variable">.Millisecond</span>, func() (bool, error) &#123;</span><br><span class="line">            return s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>()<span class="variable">.Informer</span>()<span class="variable">.HasSynced</span>(), nil</span><br><span class="line">        &#125;, context<span class="variable">.StopCh</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return s, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是 APIExtensionsServer 的初始化流程，其中最核心方法是 <code>s.GenericAPIServer.InstallAPIGroup</code>，也就是 API 的注册过程，三种 server 中 API 的注册过程都是其核心。</p>
<h5 id="CreateKubeAPIServer"><a href="#CreateKubeAPIServer" class="headerlink" title="CreateKubeAPIServer"></a>CreateKubeAPIServer</h5><p>本节继续分析 KubeAPIServer 的初始化，在<code>CreateKubeAPIServer</code> 中调用了 <code>kubeAPIServerConfig.Complete().New</code> 来完成相关的初始化操作。</p>
<h5 id="kubeAPIServerConfig-Complete-New"><a href="#kubeAPIServerConfig-Complete-New" class="headerlink" title="kubeAPIServerConfig.Complete().New"></a>kubeAPIServerConfig.Complete().New</h5><p>主要逻辑为：</p>
<ul>
<li>1、调用 <code>c.GenericConfig.New</code> 初始化 GenericAPIServer，其主要实现在上文已经分析过；</li>
<li>2、判断是否支持 logs 相关的路由，如果支持，则添加 <code>/logs</code> 路由；</li>
<li>3、调用 <code>m.InstallLegacyAPI</code> 将核心 API Resource 添加到路由中，对应到 apiserver 就是以 <code>/api</code> 开头的 resource；</li>
<li>4、调用 <code>m.InstallAPIs</code> 将扩展的 API Resource 添加到路由中，在 apiserver 中即是以 <code>/apis</code> 开头的 resource；</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:<span class="number">214</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeAPIServer</span><span class="params">(......)</span></span> (*master.<span class="type">Master</span>, error) &#123;</span><br><span class="line">    kubeAPIServer, err := kubeAPIServerConfig.<span class="type">Complete</span>().<span class="type">New</span>(delegateAPIServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kubeAPIServer.<span class="type">GenericAPIServer</span>.<span class="type">AddPostStartHookOrDie</span>(<span class="string">"start-kube-apiserver-admission-initializer"</span>, admissionPostStartHook)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kubeAPIServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">k8s.io/kubernetes/pkg/master/master.go:<span class="number">325</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> completedConfig)</span></span> <span class="type">New</span>(delegationTarget genericapiserver.<span class="type">DelegationTarget</span>) (*<span class="type">Master</span>, error) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1、初始化 GenericAPIServer</span></span><br><span class="line">    s, err := <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">New</span>(<span class="string">"kube-apiserver"</span>, delegationTarget)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、注册 logs 相关的路由</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">EnableLogsSupport</span> &#123;</span><br><span class="line">        routes.<span class="type">Logs</span>&#123;&#125;.<span class="type">Install</span>(s.<span class="type">Handler</span>.<span class="type">GoRestfulContainer</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := &amp;<span class="type">Master</span>&#123;</span><br><span class="line">        <span class="type">GenericAPIServer</span>: s,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、安装 LegacyAPI</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">APIResourceConfigSource</span>.<span class="type">VersionEnabled</span>(apiv1.<span class="type">SchemeGroupVersion</span>) &#123;</span><br><span class="line">        legacyRESTStorageProvider := corerest.<span class="type">LegacyRESTStorageProvider</span>&#123;</span><br><span class="line">            <span class="type">StorageFactory</span>:              <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">StorageFactory</span>,</span><br><span class="line">            <span class="type">ProxyTransport</span>:              <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">ProxyTransport</span>,</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := m.<span class="type">InstallLegacyAPI</span>(&amp;<span class="built_in">c</span>, <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">RESTOptionsGetter</span>, legacyRESTStorageProvider); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    restStorageProviders := []<span class="type">RESTStorageProvider</span>&#123;</span><br><span class="line">        auditregistrationrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">        authenticationrest.<span class="type">RESTStorageProvider</span>&#123;<span class="type">Authenticator</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">Authentication</span>.<span class="type">Authenticator</span>, <span class="type">APIAudiences</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.  <span class="type">Authentication</span>.<span class="type">APIAudiences</span>&#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、安装 APIs</span></span><br><span class="line">    <span class="keyword">if</span> err := m.<span class="type">InstallAPIs</span>(<span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">APIResourceConfigSource</span>, <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">RESTOptionsGetter</span>, restStorageProviders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">Tunneler</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.installTunneler(<span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">Tunneler</span>, corev1client.<span class="type">NewForConfigOrDie</span>(<span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">LoopbackClientConfig</span>).<span class="type">Nodes</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.<span class="type">GenericAPIServer</span>.<span class="type">AddPostStartHookOrDie</span>(<span class="string">"ca-registration"</span>, <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">ClientCARegistrationHook</span>.<span class="type">PostStartHook</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="m-InstallLegacyAPI"><a href="#m-InstallLegacyAPI" class="headerlink" title="m.InstallLegacyAPI"></a>m.InstallLegacyAPI</h5><p>此方法的主要功能是将 core API 注册到路由中，是 apiserver 初始化流程中最核心的方法之一，不过其调用链非常深，下面会进行深入分析。将 API 注册到路由其最终的目的就是对外提供 RESTful API 来操作对应 resource，注册 API 主要分为两步，第一步是为 API 中的每个 resource 初始化 RESTStorage 以此操作后端存储中数据的变更，第二步是为每个 resource 根据其 verbs 构建对应的路由。<code>m.InstallLegacyAPI</code> 的主要逻辑为：</p>
<ul>
<li>1、调用 <code>legacyRESTStorageProvider.NewLegacyRESTStorage</code> 为 LegacyAPI 中各个资源创建 RESTStorage，RESTStorage 的目的是将每种资源的访问路径及其后端存储的操作对应起来；</li>
<li>2、初始化 <code>bootstrap-controller</code>，并将其加入到 PostStartHook 中，<code>bootstrap-controller</code> 是 apiserver 中的一个 controller，主要功能是创建系统所需要的一些 namespace 以及创建 kubernetes service 并定期触发对应的 sync 操作，apiserver 在启动后会通过调用 PostStartHook 来启动 <code>bootstrap-controller</code>；</li>
<li>3、在为资源创建完 RESTStorage 后，调用 <code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 为 APIGroup 注册路由信息，<code>InstallLegacyAPIGroup</code>方法的调用链非常深，主要为<code>InstallLegacyAPIGroup--&gt; installAPIResources --&gt; InstallREST --&gt; Install --&gt; registerResourceHandlers</code>，最终核心的路由构造在<code>registerResourceHandlers</code>方法内，该方法比较复杂，其主要功能是通过上一步骤构造的 REST Storage 判断该资源可以执行哪些操作（如 create、update等），将其对应的操作存入到 action 中，每一个 action 对应一个标准的 REST 操作，如 create 对应的 action 操作为 POST、update 对应的 action 操作为PUT。最终根据 actions 数组依次遍历，对每一个操作添加一个 handler 方法，注册到 route 中去，再将 route 注册到 webservice 中去，webservice 最终会注册到 container 中，遵循 go-restful 的设计模式；</li>
</ul>
<p>关于 <code>legacyRESTStorageProvider.NewLegacyRESTStorage</code> 以及 <code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 方法的详细说明在后文中会继续进行讲解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/master/master.<span class="keyword">go</span>:<span class="number">406</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(......)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error building core storage: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controllerName := <span class="string">"bootstrap-controller"</span></span><br><span class="line">    coreClient := corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    bootstrapController := c.NewBootstrapController(legacyRESTStorage, coreClient, coreClient, coreClient, coreClient.RESTClient())</span><br><span class="line">    m.GenericAPIServer.AddPostStartHookOrDie(controllerName, bootstrapController.PostStartHook)</span><br><span class="line">    m.GenericAPIServer.AddPreShutdownHookOrDie(controllerName, bootstrapController.PreShutdownHook)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InstallAPIs</code> 与 <code>InstallLegacyAPI</code> 的主要流程是类似的，限于篇幅此处不再深入分析。</p>
<h4 id="createAggregatorServer"><a href="#createAggregatorServer" class="headerlink" title="createAggregatorServer"></a>createAggregatorServer</h4><p><code>AggregatorServer</code> 主要用于自定义的聚合控制器的，使 CRD 能够自动注册到集群中。</p>
<p>主要逻辑为：</p>
<ul>
<li>1、调用 <code>aggregatorConfig.Complete().NewWithDelegate</code> 创建 aggregatorServer；</li>
<li>2、初始化 <code>crdRegistrationController</code> 和 <code>autoRegistrationController</code>，<code>crdRegistrationController</code> 负责注册 CRD，<code>autoRegistrationController</code> 负责将 CRD 对应的 APIServices 自动注册到 apiserver 中，CRD 创建后可通过 <code>$ kubectl get apiservices</code> 查看是否注册到 apiservices 中；</li>
<li>3、将 <code>autoRegistrationController</code> 和 <code>crdRegistrationController</code> 加入到 PostStartHook 中；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/aggregator.<span class="keyword">go</span>:<span class="number">124</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAggregatorServer</span><span class="params">(......)</span> <span class="params">(*aggregatorapiserver.APIAggregator, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1、初始化 aggregatorServer</span></span><br><span class="line">    aggregatorServer, err := aggregatorConfig.Complete().NewWithDelegate(delegateAPIServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化 auto-registration controller</span></span><br><span class="line">    apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    autoRegistrationController := autoregister.NewAutoRegisterController(......)</span><br><span class="line">    apiServices := apiServicesToRegister(delegateAPIServer, autoRegistrationController)</span><br><span class="line">    crdRegistrationController := crdregistration.NewCRDRegistrationController(......)</span><br><span class="line">    err = aggregatorServer.GenericAPIServer.AddPostStartHook(<span class="string">"kube-apiserver-autoregistration"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> crdRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> aggregatorConfig.GenericConfig.MergedResourceConfig.AnyVersionForGroupEnabled(<span class="string">"apiextensions.k8s.io"</span>) &#123;</span><br><span class="line">                crdRegistrationController.WaitForInitialSync()</span><br><span class="line">            &#125;</span><br><span class="line">            autoRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = aggregatorServer.GenericAPIServer.AddBootSequenceHealthChecks(</span><br><span class="line">        makeAPIServiceAvailableHealthCheck(</span><br><span class="line">            <span class="string">"autoregister-completion"</span>,</span><br><span class="line">            apiServices,</span><br><span class="line">            aggregatorServer.APIRegistrationInformers.Apiregistration().V1().APIServices(),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="aggregatorConfig-Complete-NewWithDelegate"><a href="#aggregatorConfig-Complete-NewWithDelegate" class="headerlink" title="aggregatorConfig.Complete().NewWithDelegate"></a>aggregatorConfig.Complete().NewWithDelegate</h5><p><code>aggregatorConfig.Complete().NewWithDelegate</code> 是初始化 aggregatorServer 的方法，主要逻辑为：</p>
<ul>
<li>1、调用 <code>c.GenericConfig.New</code> 初始化 GenericAPIServer，其内部的主要功能在上文已经分析过；</li>
<li>2、调用 <code>apiservicerest.NewRESTStorage</code> 为 APIServices 资源创建 RESTStorage，RESTStorage 的目的是将每种资源的访问路径及其后端存储的操作对应起来；</li>
<li>3、调用 <code>s.GenericAPIServer.InstallAPIGroup</code> 为 APIGroup 注册路由信息；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span>:<span class="number">158</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">NewWithDelegate</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*APIAggregator, error)</span></span> &#123;</span><br><span class="line">    openAPIConfig := c.GenericConfig.OpenAPIConfig</span><br><span class="line">    c.GenericConfig.OpenAPIConfig = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 1、初始化 genericServer</span></span><br><span class="line">    genericServer, err := c.GenericConfig.New(<span class="string">"kube-aggregator"</span>, delegationTarget)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apiregistrationClient, err := clientset.NewForConfig(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    informerFactory := informers.NewSharedInformerFactory(</span><br><span class="line">        apiregistrationClient,</span><br><span class="line">        <span class="number">5</span>*time.Minute, </span><br><span class="line">    )</span><br><span class="line">    s := &amp;APIAggregator&#123;</span><br><span class="line">        GenericAPIServer: genericServer,</span><br><span class="line">        delegateHandler: delegationTarget.UnprotectedHandler(),</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、为 API 注册路由</span></span><br><span class="line">    apiGroupInfo := apiservicerest.NewRESTStorage(c.GenericConfig.MergedResourceConfig, c.GenericConfig.RESTOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err := s.GenericAPIServer.InstallAPIGroup(&amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 3、初始化 apiserviceRegistrationController、availableController</span></span><br><span class="line">    apisHandler := &amp;apisHandler&#123;</span><br><span class="line">        codecs: aggregatorscheme.Codecs,</span><br><span class="line">        lister: s.lister,</span><br><span class="line">    &#125;</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">"/apis"</span>, apisHandler)</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle(<span class="string">"/apis/"</span>, apisHandler)</span><br><span class="line">    apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().V1().APIServices(), s)</span><br><span class="line">    availableController, err := statuscontrollers.NewAvailableConditionController(</span><br><span class="line">       ......</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、添加 PostStartHook</span></span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">"start-kube-aggregator-informers"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        informerFactory.Start(context.StopCh)</span><br><span class="line">        c.GenericConfig.SharedInformerFactory.Start(context.StopCh)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">"apiservice-registration-controller"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span>      <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> apiserviceRegistrationController.Run(context.StopCh)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">"apiservice-status-available-controller"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> availableController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是对 AggregatorServer 初始化流程的分析，可以看出，在创建 APIExtensionsServer、KubeAPIServer 以及 AggregatorServer 时，其模式都是类似的，首先调用 <code>c.GenericConfig.New</code> 按照<code>go-restful</code>的模式初始化 Container，然后为 server 中需要注册的资源创建 RESTStorage，最后将 resource 的 APIGroup 信息注册到路由中。</p>
<p>至此，CreateServerChain 中流程已经分析完，其中的调用链如下所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                    |<span class="string">--&gt; CreateNodeDialer</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">--&gt; CreateKubeAPIServerConfig</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">CreateServerChain --|<span class="string">--&gt; createAPIExtensionsConfig</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">                                                                       </span>|<span class="string">--&gt; c.GenericConfig.New</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">--&gt; createAPIExtensionsServer --&gt; apiextensionsConfig.Complete().New --</span>|</span><br><span class="line">                    |<span class="string">                                                                       </span>|<span class="string">--&gt; s.GenericAPIServer.InstallAPIGroup</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">                                                                 </span>|<span class="string">--&gt; c.GenericConfig.New --&gt; legacyRESTStorageProvider.NewLegacyRESTStorage</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">                                                                 </span>|</span><br><span class="line">                    |<span class="string">--&gt; CreateKubeAPIServer --&gt; kubeAPIServerConfig.Complete().New --</span>|<span class="string">--&gt; m.InstallLegacyAPI</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">                                                                 </span>|</span><br><span class="line">                    |<span class="string">                                                                 </span>|<span class="string">--&gt; m.InstallAPIs</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |</span><br><span class="line"><span class="string">                    </span>|<span class="string">--&gt; createAggregatorConfig</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">                                                                             </span>|<span class="string">--&gt; c.GenericConfig.New</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">                                                                             </span>|</span><br><span class="line">                    |<span class="string">--&gt; createAggregatorServer --&gt; aggregatorConfig.Complete().NewWithDelegate --</span>|<span class="string">--&gt; apiservicerest.NewRESTStorage</span></span><br><span class="line"><span class="string">                                                                                                  </span>|</span><br><span class="line">                                                                                                  |<span class="string">--&gt; s.GenericAPIServer.InstallAPIGroup</span></span><br></pre></td></tr></table></figure>
<h4 id="prepared-Run"><a href="#prepared-Run" class="headerlink" title="prepared.Run"></a>prepared.Run</h4><p>在 <code>Run</code> 方法中首先调用 <code>CreateServerChain</code> 完成各 server 的初始化，然后调用 <code>server.PrepareRun</code> 完成服务启动前的准备工作，最后调用 <code>prepared.Run</code> 方法来启动安全的 http server。<code>server.PrepareRun</code> 主要完成了健康检查、存活检查和<code>OpenAPI</code>路由的注册工作，下面继续分析 <code>prepared.Run</code> 的流程，在 <code>prepared.Run</code> 中主要调用 <code>s.NonBlockingRun</code> 来完成启动工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span>:<span class="number">269</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedAPIAggregator)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.runnable.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.<span class="keyword">go</span>:<span class="number">316</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    delayedStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(delayedStopCh)</span><br><span class="line">        &lt;-stopCh</span><br><span class="line"></span><br><span class="line">        time.Sleep(s.ShutdownDelayDuration)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 s.NonBlockingRun 完成启动流程</span></span><br><span class="line">    err := s.NonBlockingRun(delayedStopCh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当收到退出信号后完成一些收尾工作</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    err = s.RunPreShutdownHooks()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;-delayedStopCh</span><br><span class="line">    s.HandlerChainWaitGroup.Wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="s-NonBlockingRun"><a href="#s-NonBlockingRun" class="headerlink" title="s.NonBlockingRun"></a>s.NonBlockingRun</h5><p><code>s.NonBlockingRun</code> 的主要逻辑为：</p>
<ul>
<li>1、判断是否要启动审计日志服务；</li>
<li>2、调用 <code>s.SecureServingInfo.Serve</code> 配置并启动 https server；</li>
<li>3、执行 postStartHooks；</li>
<li>4、向 systemd 发送 ready 信号；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.<span class="keyword">go</span>:<span class="number">351</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">NonBlockingRun</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    auditStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、判断是否要启动审计日志</span></span><br><span class="line">    <span class="keyword">if</span> s.AuditBackend != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := s.AuditBackend.Run(auditStopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to run the audit backend: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、启动 https server</span></span><br><span class="line">    internalStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> stoppedCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> s.SecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.Handler != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        stoppedCh, err = s.SecureServingInfo.Serve(s.Handler, s.ShutdownTimeout, internalStopCh)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">close</span>(internalStopCh)</span><br><span class="line">            <span class="built_in">close</span>(auditStopCh)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        <span class="built_in">close</span>(s.readinessStopCh)</span><br><span class="line">        <span class="built_in">close</span>(internalStopCh)</span><br><span class="line">        <span class="keyword">if</span> stoppedCh != <span class="literal">nil</span> &#123;</span><br><span class="line">            &lt;-stoppedCh</span><br><span class="line">        &#125;</span><br><span class="line">        s.HandlerChainWaitGroup.Wait()</span><br><span class="line">        <span class="built_in">close</span>(auditStopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、执行 postStartHooks</span></span><br><span class="line">    s.RunPostStartHooks(stopCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、向 systemd 发送 ready 信号</span></span><br><span class="line">    <span class="keyword">if</span> _, err := systemd.SdNotify(<span class="literal">true</span>, <span class="string">"READY=1\n"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Unable to send systemd daemon successful start message: %v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 server 的初始化以及启动流程过程的分析，上文已经提到各 server 初始化过程中最重要的就是 API Resource RESTStorage 的初始化以及路由的注册，由于该过程比较复杂，下文会单独进行讲述。</p>
<h3 id="storageFactory-的构建"><a href="#storageFactory-的构建" class="headerlink" title="storageFactory 的构建"></a>storageFactory 的构建</h3><p>上文已经提到过，apiserver 最终实现的 handler 对应的后端数据是以 <strong>Store</strong> 的结构保存的，这里以 <code>/api</code> 开头的路由举例，通过<code>NewLegacyRESTStorage</code>方法创建各个资源的<strong>RESTStorage</strong>。RESTStorage 是一个结构体，具体的定义在<code>k8s.io/apiserver/pkg/registry/generic/registry/store.go</code>下，结构体内主要包含<code>NewFunc</code>返回特定资源信息、<code>NewListFunc</code>返回特定资源列表、<code>CreateStrategy</code>特定资源创建时的策略、<code>UpdateStrategy</code>更新时的策略以及<code>DeleteStrategy</code>删除时的策略等重要方法。在<code>NewLegacyRESTStorage</code>内部，可以看到创建了多种资源的 RESTStorage。</p>
<p><code>NewLegacyRESTStorage</code> 的调用链为 <code>CreateKubeAPIServer --&gt; kubeAPIServerConfig.Complete().New --&gt; m.InstallLegacyAPI --&gt; legacyRESTStorageProvider.NewLegacyRESTStorage</code>。</p>
<h4 id="NewLegacyRESTStorage"><a href="#NewLegacyRESTStorage" class="headerlink" title="NewLegacyRESTStorage"></a>NewLegacyRESTStorage</h4><p>一个 API Group 下的资源都有其 REST 实现，<code>k8s.io/kubernetes/pkg/registry</code>下所有的 Group 都有一个rest目录，存储的就是对应资源的 RESTStorage。在<code>NewLegacyRESTStorage</code>方法中，通过<code>NewREST</code>或者<code>NewStorage</code>会生成各种资源对应的 Storage，此处以 pod 为例进行说明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/registry/core/rest/storage_core.<span class="keyword">go</span>:<span class="number">102</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c LegacyRESTStorageProvider)</span> <span class="title">NewLegacyRESTStorage</span><span class="params">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class="params">(LegacyRESTStorage, genericapiserver.  APIGroupInfo, error)</span></span> &#123;</span><br><span class="line">    apiGroupInfo := genericapiserver.APIGroupInfo&#123;</span><br><span class="line">        PrioritizedVersions:          legacyscheme.Scheme.PrioritizedVersionsForGroup(<span class="string">""</span>),</span><br><span class="line">        VersionedResourcesStorageMap: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;,</span><br><span class="line">        Scheme:                       legacyscheme.Scheme,</span><br><span class="line">        ParameterCodec:               legacyscheme.ParameterCodec,</span><br><span class="line">        NegotiatedSerializer:         legacyscheme.Codecs,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> podDisruptionClient policyclient.PodDisruptionBudgetsGetter</span><br><span class="line">    <span class="keyword">if</span> policyGroupVersion := (schema.GroupVersion&#123;Group: <span class="string">"policy"</span>, Version: <span class="string">"v1beta1"</span>&#125;); legacyscheme.Scheme.                               IsVersionRegistered(policyGroupVersion) &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        podDisruptionClient, err = policyclient.NewForConfig(c.LoopbackClientConfig)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、LegacyAPI 下的 resource RESTStorage 的初始化</span></span><br><span class="line">    restStorage := LegacyRESTStorage&#123;&#125;</span><br><span class="line"></span><br><span class="line">    podTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    eventStorage, err := eventstore.NewREST(restOptionsGetter, <span class="keyword">uint64</span>(c.EventTTL.Seconds()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    limitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    endpointsStorage, err := endpointsstore.NewREST(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodeStorage, err := nodestore.NewStorage(restOptionsGetter, c.KubeletClientConfig, c.ProxyTransport)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、pod RESTStorage 的初始化</span></span><br><span class="line">    podStorage, err := podstore.NewStorage(......)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">		</span><br><span class="line">    serviceClusterIPAllocator, err := ipallocator.NewAllocatorCIDRRange(&amp;serviceClusterIPRange, <span class="function"><span class="keyword">func</span><span class="params">(max <span class="keyword">int</span>, rangeSpec <span class="keyword">string</span>)</span> <span class="params">(allocator. Interface, error)</span></span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, fmt.Errorf(<span class="string">"cannot create cluster IP allocator: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    restStorage.ServiceClusterIPAllocator = serviceClusterIPRegistry</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> secondaryServiceClusterIPAllocator ipallocator.Interface</span><br><span class="line">    <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.IPv6DualStack) &amp;&amp; c.SecondaryServiceIPRange.IP != <span class="literal">nil</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceNodePortRegistry rangeallocation.RangeRegistry</span><br><span class="line">    serviceNodePortAllocator, err := portallocator.NewPortAllocatorCustom(c.ServiceNodePortRange, <span class="function"><span class="keyword">func</span><span class="params">(max <span class="keyword">int</span>, rangeSpec <span class="keyword">string</span>)</span>      <span class="params">(allocator.Interface, error)</span></span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, fmt.Errorf(<span class="string">"cannot create cluster port allocator: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    restStorage.ServiceNodePortAllocator = serviceNodePortRegistry</span><br><span class="line"></span><br><span class="line">    controllerStorage, err := controllerstore.NewStorage(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serviceRest, serviceRestProxy := servicestore.NewREST(......)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、restStorageMap 保存 resource http path 与 RESTStorage 对应关系</span></span><br><span class="line">    restStorageMap := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;</span><br><span class="line">        <span class="string">"pods"</span>:             podStorage.Pod,</span><br><span class="line">        <span class="string">"pods/attach"</span>:      podStorage.Attach,</span><br><span class="line">        <span class="string">"pods/status"</span>:      podStorage.Status,</span><br><span class="line">        <span class="string">"pods/log"</span>:         podStorage.Log,</span><br><span class="line">        <span class="string">"pods/exec"</span>:        podStorage.Exec,</span><br><span class="line">        <span class="string">"pods/portforward"</span>: podStorage.PortForward,</span><br><span class="line">        <span class="string">"pods/proxy"</span>:       podStorage.Proxy,</span><br><span class="line">        ......</span><br><span class="line">        <span class="string">"componentStatuses"</span>: componentstatus.NewStorage(componentStatusStorage&#123;c.StorageFactory&#125;.serversToValidate),</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="podstore-NewStorage"><a href="#podstore-NewStorage" class="headerlink" title="podstore.NewStorage"></a>podstore.NewStorage</h5><p><code>podstore.NewStorage</code> 是为 pod 生成 storage 的方法，该方法主要功能是为 pod 创建后端存储最终返回一个 RESTStorage 对象，其中调用 <code>store.CompleteWithOptions</code> 来创建后端存储的。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">k8s.io<span class="meta-keyword">/kubernetes/</span>pkg<span class="meta-keyword">/registry/</span>core<span class="meta-keyword">/pod/</span>storage/storage.go:<span class="number">71</span></span><br><span class="line">func NewStorage(......) (PodStorage, error) &#123;</span><br><span class="line">    store := <span class="variable">&amp;genericregistry</span>.Store&#123;</span><br><span class="line"><span class="symbol">        NewFunc:</span>                  func() runtime.<span class="class">Object </span>&#123; return <span class="variable">&amp;api</span>.Pod&#123;&#125; &#125;,</span><br><span class="line"><span class="symbol">        NewListFunc:</span>              func() runtime.<span class="class">Object </span>&#123; return <span class="variable">&amp;api</span>.PodList&#123;&#125; &#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    options := <span class="variable">&amp;generic</span>.StoreOptions&#123;</span><br><span class="line"><span class="symbol">        RESTOptions:</span> optsGetter,</span><br><span class="line"><span class="symbol">        AttrFunc:</span>    pod.GetAttrs,</span><br><span class="line"><span class="symbol">        TriggerFunc:</span> map[string]storage.IndexerFunc&#123;<span class="string">"spec.nodeName"</span>: pod.NodeNameTriggerFunc&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 store.CompleteWithOptions</span></span><br><span class="line">    if err := store.CompleteWithOptions(options); err != <span class="class">nil </span>&#123;</span><br><span class="line">        return PodStorage&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    statusStore := *store</span><br><span class="line">    statusStore.UpdateStrategy = pod.StatusStrategy</span><br><span class="line">    ephemeralContainersStore := *store</span><br><span class="line">    ephemeralContainersStore.UpdateStrategy = pod.EphemeralContainersStrategy</span><br><span class="line"></span><br><span class="line">    bindingREST := <span class="variable">&amp;</span>BindingREST&#123;store: store&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PodStorage 对象</span></span><br><span class="line">    return PodStorage&#123;</span><br><span class="line"><span class="symbol">        Pod:</span>                 <span class="variable">&amp;</span>REST&#123;store, proxyTransport&#125;,</span><br><span class="line"><span class="symbol">        Binding:</span>             <span class="variable">&amp;</span>BindingREST&#123;store: store&#125;,</span><br><span class="line"><span class="symbol">        LegacyBinding:</span>       <span class="variable">&amp;</span>LegacyBindingREST&#123;bindingREST&#125;,</span><br><span class="line"><span class="symbol">        Eviction:</span>            newEvictionStorage(store, podDisruptionBudgetClient),</span><br><span class="line"><span class="symbol">        Status:</span>              <span class="variable">&amp;</span>StatusREST&#123;store: <span class="variable">&amp;</span>statusStore&#125;,</span><br><span class="line"><span class="symbol">        EphemeralContainers:</span> <span class="variable">&amp;</span>EphemeralContainersREST&#123;store: <span class="variable">&amp;</span>ephemeralContainersStore&#125;,</span><br><span class="line"><span class="symbol">        Log:</span>                 <span class="variable">&amp;podrest</span>.LogREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line"><span class="symbol">        Proxy:</span>               <span class="variable">&amp;podrest</span>.ProxyREST&#123;Store: store, ProxyTransport: proxyTransport&#125;,</span><br><span class="line"><span class="symbol">        Exec:</span>                <span class="variable">&amp;podrest</span>.ExecREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line"><span class="symbol">        Attach:</span>              <span class="variable">&amp;podrest</span>.AttachREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line"><span class="symbol">        PortForward:</span>         <span class="variable">&amp;podrest</span>.PortForwardREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line">    &#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终返回的对象里对 pod 的不同操作都是一个 REST 对象，REST 中自动集成了 <code>genericregistry.Store</code> 对象，而 <code>store.CompleteWithOptions</code> 方法就是对 <code>genericregistry.Store</code> 对象中存储实例就行初始化的。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type REST struct &#123;</span><br><span class="line">    *genericregistry.Store</span><br><span class="line">    proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BindingREST struct &#123;</span><br><span class="line">    store *genericregistry.Store</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<h5 id="store-CompleteWithOptions"><a href="#store-CompleteWithOptions" class="headerlink" title="store.CompleteWithOptions"></a>store.CompleteWithOptions</h5><p><code>store.CompleteWithOptions</code> 主要功能是为 store 中的配置设置一些默认的值以及根据提供的 options 更新 store，其中最主要的就是初始化 store 的后端存储实例。</p>
<p>在<code>CompleteWithOptions</code>方法内，调用了<code>options.RESTOptions.GetRESTOptions</code> 方法，其最终返回<code>generic.RESTOptions</code> 对象，<code>generic.RESTOptions</code> 对象中包含对 etcd 初始化的一些配置、数据序列化方法以及对 etcd 操作的 storage.Interface 对象。其会依次调用<code>StorageWithCacher--&gt;NewRawStorage--&gt;Create</code>方法创建最终依赖的后端存储。</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go:1192</span><br><span class="line">func (e *Store) CompleteWithOptions(options *generic.StoreOptions) error &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="attribute">var isNamespaced bool</span></span><br><span class="line"><span class="attribute">    switch &#123;</span></span><br><span class="line"><span class="attribute">    case e.CreateStrategy != nil</span>:</span><br><span class="line">        isNamespaced = e<span class="variable">.CreateStrategy</span><span class="variable">.NamespaceScoped</span>()</span><br><span class="line">    case e<span class="variable">.UpdateStrategy</span> != nil:</span><br><span class="line">        isNamespaced = e<span class="variable">.UpdateStrategy</span><span class="variable">.NamespaceScoped</span>()</span><br><span class="line">    default:</span><br><span class="line">        return fmt<span class="variable">.Errorf</span>("store for %s must have CreateStrategy or UpdateStrategy set", e<span class="variable">.DefaultQualifiedResource</span><span class="variable">.String</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 1、调用 options<span class="variable">.RESTOptions</span><span class="variable">.GetRESTOptions</span> </span><br><span class="line">    opts, err := options<span class="variable">.RESTOptions</span><span class="variable">.GetRESTOptions</span>(e<span class="variable">.DefaultQualifiedResource</span>)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、设置 ResourcePrefix </span><br><span class="line">    prefix := opts<span class="variable">.ResourcePrefix</span></span><br><span class="line">    if !strings<span class="variable">.HasPrefix</span>(prefix, "/") &#123;</span><br><span class="line">        prefix = "/" + prefix</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if prefix == "/" &#123;</span><br><span class="line">        return fmt<span class="variable">.Errorf</span>("store for %s has an invalid prefix %q", e<span class="variable">.DefaultQualifiedResource</span><span class="variable">.String</span>(), opts<span class="variable">.ResourcePrefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if e<span class="variable">.KeyRootFunc</span> == nil &amp;&amp; e<span class="variable">.KeyFunc</span> == nil &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyFunc := func(obj runtime<span class="variable">.Object</span>) (string, error) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、以下操作主要是将 opts 对象中的值赋值到 store 对象中</span><br><span class="line">    if e<span class="variable">.DeleteCollectionWorkers</span> == 0 &#123;</span><br><span class="line">        e<span class="variable">.DeleteCollectionWorkers</span> = opts<span class="variable">.DeleteCollectionWorkers</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e<span class="variable">.EnableGarbageCollection</span> = opts<span class="variable">.EnableGarbageCollection</span></span><br><span class="line">    if e<span class="variable">.ObjectNameFunc</span> == nil &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if e<span class="variable">.Storage</span><span class="variable">.Storage</span> == nil &#123;</span><br><span class="line">        e<span class="variable">.Storage</span><span class="variable">.Codec</span> = opts<span class="variable">.StorageConfig</span><span class="variable">.Codec</span></span><br><span class="line">        var err error</span><br><span class="line">        e<span class="variable">.Storage</span><span class="variable">.Storage</span>, e<span class="variable">.DestroyFunc</span>, err = opts<span class="variable">.Decorator</span>(</span><br><span class="line">            opts<span class="variable">.StorageConfig</span>,</span><br><span class="line">            prefix,</span><br><span class="line">            keyFunc,</span><br><span class="line">            e<span class="variable">.NewFunc</span>,</span><br><span class="line">            e<span class="variable">.NewListFunc</span>,</span><br><span class="line">            attrFunc,</span><br><span class="line">            options<span class="variable">.TriggerFunc</span>,</span><br><span class="line">        )</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        e<span class="variable">.StorageVersioner</span> = opts<span class="variable">.StorageConfig</span><span class="variable">.EncodeVersioner</span></span><br><span class="line"></span><br><span class="line">        if opts<span class="variable">.CountMetricPollPeriod</span> &gt; 0 &#123;</span><br><span class="line">            stopFunc := e<span class="variable">.startObservingCount</span>(opts<span class="variable">.CountMetricPollPeriod</span>)</span><br><span class="line">            previousDestroy := e<span class="variable">.DestroyFunc</span></span><br><span class="line">            e<span class="variable">.DestroyFunc</span> = func() &#123;</span><br><span class="line">                stopFunc()</span><br><span class="line">                if previousDestroy != nil &#123;</span><br><span class="line">                    previousDestroy()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>options.RESTOptions</code> 是一个 interface，想要找到其 <code>GetRESTOptions</code> 方法的实现必须知道 <code>options.RESTOptions</code> 初始化时对应的实例，其初始化是在 <code>CreateKubeAPIServerConfig --&gt; buildGenericConfig --&gt; s.Etcd.ApplyWithStorageFactoryTo</code> 方法中进行初始化的，<code>RESTOptions</code> 对应的实例为 <code>StorageFactoryRestOptionsFactory</code>，所以 PodStorage 初始时构建的 store 对象中<code>genericserver.Config.RESTOptionsGetter</code> 实际的对象类型为 <code>StorageFactoryRestOptionsFactory</code>，其 <code>GetRESTOptions</code> 方法如下所示：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go:253</span><br><span class="line">func (f *StorageFactoryRestOptionsFactory) GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, error) &#123;</span><br><span class="line">    <span class="attribute">storageConfig, err</span> := f<span class="variable">.StorageFactory</span><span class="variable">.NewConfig</span>(resource)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return generic<span class="variable">.RESTOptions</span>&#123;&#125;, fmt<span class="variable">.Errorf</span>("unable to find storage destination for %v, due to %v", resource, err<span class="variable">.Error</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret := generic<span class="variable">.RESTOptions</span>&#123;</span><br><span class="line">        StorageConfig:           storageConfig,</span><br><span class="line">        Decorator:               generic<span class="variable">.UndecoratedStorage</span>,</span><br><span class="line">        DeleteCollectionWorkers: f<span class="variable">.Options</span><span class="variable">.DeleteCollectionWorkers</span>,</span><br><span class="line">        EnableGarbageCollection: f<span class="variable">.Options</span><span class="variable">.EnableGarbageCollection</span>,</span><br><span class="line">        ResourcePrefix:          f<span class="variable">.StorageFactory</span><span class="variable">.ResourcePrefix</span>(resource),</span><br><span class="line">        CountMetricPollPeriod:   f<span class="variable">.Options</span><span class="variable">.StorageConfig</span><span class="variable">.CountMetricPollPeriod</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    if f<span class="variable">.Options</span><span class="variable">.EnableWatchCache</span> &#123;</span><br><span class="line">        sizes, err := ParseWatchCacheSizes(f<span class="variable">.Options</span><span class="variable">.WatchCacheSizes</span>)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return generic<span class="variable">.RESTOptions</span>&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line">        cacheSize, ok := sizes[resource]</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            cacheSize = f<span class="variable">.Options</span><span class="variable">.DefaultWatchCacheSize</span></span><br><span class="line">        &#125;</span><br><span class="line">        // 调用 generic<span class="variable">.StorageDecorator</span></span><br><span class="line">        ret<span class="variable">.Decorator</span> = genericregistry<span class="variable">.StorageWithCacher</span>(cacheSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>genericregistry.StorageWithCacher</code> 中又调用了不同的方法最终会调用 <code>factory.Create</code> 来初始化存储实例，其调用链为：<code>genericregistry.StorageWithCacher --&gt; generic.NewRawStorage --&gt; factory.Create</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/factory.go:<span class="number">30</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(<span class="built_in">c</span> storagebackend.Config)</span></span> (storage.<span class="type">Interface</span>, <span class="type">DestroyFunc</span>, error) &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">c</span>.<span class="type">Type</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"etcd2"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.<span class="type">Errorf</span>(<span class="string">"%v is no longer a supported storage backend"</span>, <span class="built_in">c</span>.<span class="type">Type</span>)</span><br><span class="line">    <span class="comment">// 目前 k8s 只支持使用 etcd v3</span></span><br><span class="line">    <span class="keyword">case</span> storagebackend.<span class="type">StorageTypeUnset</span>, storagebackend.<span class="type">StorageTypeETCD3</span>:</span><br><span class="line">        <span class="keyword">return</span> newETCD3Storage(<span class="built_in">c</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.<span class="type">Errorf</span>(<span class="string">"unknown storage type: %s"</span>, <span class="built_in">c</span>.<span class="type">Type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="newETCD3Storage"><a href="#newETCD3Storage" class="headerlink" title="newETCD3Storage"></a>newETCD3Storage</h6><p>在 <code>newETCD3Storage</code> 中，首先通过调用 <code>newETCD3Client</code> 创建 etcd 的 client，client 的创建最终是通过 etcd 官方提供的客户端工具 <a href="https://github.com/etcd-io/etcd/tree/master/clientv3" target="_blank" rel="external nofollow noopener noreferrer">clientv3</a> 进行创建的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go:<span class="number">209</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newETCD3Storage</span><span class="params">(<span class="built_in">c</span> storagebackend.Config)</span></span> (storage.<span class="type">Interface</span>, <span class="type">DestroyFunc</span>, error) &#123;</span><br><span class="line">    stopCompactor, err := startCompactorOnce(<span class="built_in">c</span>.<span class="type">Transport</span>, <span class="built_in">c</span>.<span class="type">CompactionInterval</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client, err := newETCD3Client(<span class="built_in">c</span>.<span class="type">Transport</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stopCompactor()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> once sync.<span class="type">Once</span></span><br><span class="line">    destroyFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.<span class="type">Do</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            stopCompactor()</span><br><span class="line">            client.<span class="type">Close</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    transformer := <span class="built_in">c</span>.<span class="type">Transformer</span></span><br><span class="line">    <span class="keyword">if</span> transformer == <span class="literal">nil</span> &#123;</span><br><span class="line">        transformer = value.<span class="type">IdentityTransformer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> etcd3.<span class="type">New</span>(client, <span class="built_in">c</span>.<span class="type">Codec</span>, <span class="built_in">c</span>.<span class="type">Prefix</span>, transformer, <span class="built_in">c</span>.<span class="type">Paging</span>), destroyFunc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此对于 pod resource 中 store 的构建基本分析完成，不同 resource 对应一个 REST 对象，其中又引用了 <code>genericregistry.Store</code> 对象，最终是对 <code>genericregistry.Store</code> 的初始化。在分析完 store 的初始化后还有一个重要的步骤就是路由的注册，路由注册主要的流程是为 resource 根据不同 verbs 构建 http path 以及将 path 与对应 handler 进行绑定。</p>
<h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>上文 RESTStorage 的构建对应的是 <code>InstallLegacyAPI</code> 中的 <code>legacyRESTStorageProvider.NewLegacyRESTStorage</code> 方法，下面继续分析 <code>InstallLegacyAPI</code> 中的 <code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 方法的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/master/master.<span class="keyword">go</span>:<span class="number">406</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(......)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error building core storage: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 的调用链非常深，最终是为 Group 下每一个 API resources 注册 handler 及路由信息，其调用链为：<code>m.GenericAPIServer.InstallLegacyAPIGroup --&gt; s.installAPIResources --&gt; apiGroupVersion.InstallREST --&gt; installer.Install --&gt; a.registerResourceHandlers</code>。其中几个方法的作用如下所示：</p>
<ul>
<li><code>s.installAPIResources</code>：为每一个 API resource 调用 <code>apiGroupVersion.InstallREST</code> 添加路由；</li>
<li><code>apiGroupVersion.InstallREST</code>：将 <code>restful.WebServic</code> 对象添加到 container 中；</li>
<li><code>installer.Install</code>：返回最终的 <code>restful.WebService</code> 对象</li>
</ul>
<h5 id="a-registerResourceHandlers"><a href="#a-registerResourceHandlers" class="headerlink" title="a.registerResourceHandlers"></a>a.registerResourceHandlers</h5><p>该方法实现了 <code>rest.Storage</code> 到 <code>restful.Route</code> 的转换，其首先会判断 API Resource 所支持的 REST 接口，然后为 REST 接口添加对应的 handler，最后将其注册到路由中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/installer.<span class="keyword">go</span>:<span class="number">181</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span> <span class="title">registerResourceHandlers</span><span class="params">(path <span class="keyword">string</span>, storage rest.Storage, ws *restful.WebService)</span> <span class="params">(*metav1.APIResource, error)</span></span> &#123;       </span><br><span class="line">    admit := a.group.Admit</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 1、判断该 resource 实现了哪些 REST 操作接口，以此来判断其支持的 verbs 以便为其添加路由</span></span><br><span class="line">    creater, isCreater := storage.(rest.Creater)</span><br><span class="line">    namedCreater, isNamedCreater := storage.(rest.NamedCreater)</span><br><span class="line">    lister, isLister := storage.(rest.Lister)</span><br><span class="line">    getter, isGetter := storage.(rest.Getter)</span><br><span class="line">    getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)</span><br><span class="line">    gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)</span><br><span class="line">    collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)</span><br><span class="line">    updater, isUpdater := storage.(rest.Updater)</span><br><span class="line">    patcher, isPatcher := storage.(rest.Patcher)</span><br><span class="line">    watcher, isWatcher := storage.(rest.Watcher)</span><br><span class="line">    connecter, isConnecter := storage.(rest.Connecter)</span><br><span class="line">    storageMeta, isMetadata := storage.(rest.StorageMetadata)</span><br><span class="line">    storageVersionProvider, isStorageVersionProvider := storage.(rest.StorageVersionProvider)</span><br><span class="line">    <span class="keyword">if</span> !isMetadata &#123;</span><br><span class="line">        storageMeta = defaultStorageMetadata&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exporter, isExporter := storage.(rest.Exporter)</span><br><span class="line">    <span class="keyword">if</span> !isExporter &#123;</span><br><span class="line">        exporter = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、为 resource 添加对应的 actions 并根据是否支持 namespace </span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> !namespaceScoped:</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"LIST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isLister)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"POST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCreater)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"DELETECOLLECTION"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCollectionDeleter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"WATCHLIST"</span>, <span class="string">"watch/"</span> + resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, allowWatchList)</span><br><span class="line"></span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isGetter)</span><br><span class="line">        <span class="keyword">if</span> getSubpath &#123;</span><br><span class="line">            actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="literal">false</span>&#125;, isGetter)</span><br><span class="line">        &#125;</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"PUT"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isUpdater)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"PATCH"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isPatcher)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"DELETE"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isGracefulDeleter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"WATCH"</span>, <span class="string">"watch/"</span> + itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isWatcher)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"CONNECT"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isConnecter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"CONNECT"</span>, itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="literal">false</span>&#125;, isConnecter &amp;&amp; connectSubpath)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ......</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"LIST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isLister)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"POST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCreater)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"DELETECOLLECTION"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCollectionDeleter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"WATCHLIST"</span>, <span class="string">"watch/"</span> + resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, allowWatchList)</span><br><span class="line"></span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isGetter)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、根据 action 创建对应的 route</span></span><br><span class="line">    kubeVerbs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    reqScope := handlers.RequestScope&#123;</span><br><span class="line">        Serializer:      a.group.Serializer,</span><br><span class="line">        ParameterCodec:  a.group.ParameterCodec,</span><br><span class="line">        Creater:         a.group.Creater,</span><br><span class="line">        Convertor:       a.group.Convertor,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 4、从 rest.Storage 到 restful.Route 映射</span></span><br><span class="line">    <span class="comment">// 为每个操作添加对应的 handler</span></span><br><span class="line">    <span class="keyword">for</span> _, action := <span class="keyword">range</span> actions &#123;</span><br><span class="line">        ......</span><br><span class="line">        verbOverrider, needOverride := storage.(StorageMetricsOverride)</span><br><span class="line">        <span class="keyword">switch</span> action.Verb &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"GET"</span>: ......</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"LIST"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"PUT"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"PATCH"</span>:</span><br><span class="line">        <span class="comment">// 此处以 POST 操作进行说明</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"POST"</span>: </span><br><span class="line">            <span class="keyword">var</span> handler restful.RouteFunction</span><br><span class="line">            <span class="comment">// 5、初始化 handler</span></span><br><span class="line">            <span class="keyword">if</span> isNamedCreater &#123;</span><br><span class="line">                handler = restfulCreateNamedResource(namedCreater, reqScope, admit)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler = restfulCreateResource(creater, reqScope, admit)</span><br><span class="line">            &#125;</span><br><span class="line">            handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)</span><br><span class="line">            article := GetArticleForNoun(kind, <span class="string">" "</span>)</span><br><span class="line">            doc := <span class="string">"create"</span> + article + kind</span><br><span class="line">            <span class="keyword">if</span> isSubresource &#123;</span><br><span class="line">                doc = <span class="string">"create "</span> + subresource + <span class="string">" of"</span> + article + kind</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6、route 与 handler 进行绑定</span></span><br><span class="line">            route := ws.POST(action.Path).To(handler).</span><br><span class="line">                Doc(doc).</span><br><span class="line">                Param(ws.QueryParameter(<span class="string">"pretty"</span>, <span class="string">"If 'true', then the output is pretty printed."</span>)).</span><br><span class="line">                Operation(<span class="string">"create"</span>+namespaced+kind+strings.Title(subresource)+operationSuffix).</span><br><span class="line">                Produces(<span class="built_in">append</span>(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).</span><br><span class="line">                Returns(http.StatusOK, <span class="string">"OK"</span>, producedObject).</span><br><span class="line">                Returns(http.StatusCreated, <span class="string">"Created"</span>, producedObject).</span><br><span class="line">                Returns(http.StatusAccepted, <span class="string">"Accepted"</span>, producedObject).</span><br><span class="line">                Reads(defaultVersionedObject).</span><br><span class="line">                Writes(producedObject)</span><br><span class="line">            <span class="keyword">if</span> err := AddObjectParams(ws, route, versionedCreateOptions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            addParams(route, action.Params)</span><br><span class="line">            <span class="comment">// 7、添加到路由中</span></span><br><span class="line">            routes = <span class="built_in">append</span>(routes, route)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"DELETE"</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"DELETECOLLECTION"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"WATCH"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"WATCHLIST"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"CONNECT"</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> &amp;apiResource, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="restfulCreateNamedResource"><a href="#restfulCreateNamedResource" class="headerlink" title="restfulCreateNamedResource"></a>restfulCreateNamedResource</h5><p><code>restfulCreateNamedResource</code> 是 POST 操作对应的 handler，最终会调用 <code>createHandler</code> 方法完成。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go:<span class="number">1087</span></span><br><span class="line">func restful<span class="constructor">CreateNamedResource(<span class="params">r</span> <span class="params">rest</span>.NamedCreater, <span class="params">scope</span> <span class="params">handlers</span>.RequestScope, <span class="params">admit</span> <span class="params">admission</span>.Interface)</span> restful.RouteFunction &#123;</span><br><span class="line">    return func(req *restful.Request, res *restful.Response) &#123;</span><br><span class="line">        handlers.<span class="constructor">CreateNamedResource(<span class="params">r</span>, &amp;<span class="params">scope</span>, <span class="params">admit</span>)</span>(res.ResponseWriter, req.Request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="constructor">CreateNamedResource(<span class="params">r</span> <span class="params">rest</span>.NamedCreater, <span class="params">scope</span> <span class="operator">*</span>RequestScope, <span class="params">admission</span> <span class="params">admission</span>.Interface)</span> http.HandlerFunc &#123;</span><br><span class="line">    return create<span class="constructor">Handler(<span class="params">r</span>, <span class="params">scope</span>, <span class="params">admission</span>, <span class="params">true</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="createHandler"><a href="#createHandler" class="headerlink" title="createHandler"></a>createHandler</h5><p><code>createHandler</code> 是将数据写入到后端存储的方法，对于资源的操作都有相关的权限控制，在 <code>createHandler</code> 中首先会执行 <code>decoder</code> 和 <code>admission</code> 操作，然后调用 <code>create</code> 方法完成 resource 的创建，在 <code>create</code> 方法中会进行 <code>validate</code> 以及最终将数据保存到后端存储中。<code>admit</code> 操作即执行 kube-apiserver 中的 admission-plugins，admission-plugins 在 <code>CreateKubeAPIServerConfig</code> 中被初始化为了 admissionChain，其初始化的调用链为 <code>CreateKubeAPIServerConfig --&gt; buildGenericConfig --&gt; s.Admission.ApplyTo --&gt; a.GenericAdmission.ApplyTo --&gt; a.Plugins.NewFromPlugins</code>，最终在 <code>a.Plugins.NewFromPlugins</code> 中将所有已启用的 plugins 封装为 admissionChain，此处要执行的 admit 操作即执行 admission-plugins 中的 admit 操作。</p>
<p><code>createHandler</code> 中调用的 create 方法是<code>genericregistry.Store</code> 对象的方法，在每个 resource 初始化 RESTStorage 都会引入 <code>genericregistry.Store</code> 对象。</p>
<p><code>createHandler</code> 中所有的操作就是本文开头提到的请求流程，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |    ⇒       |    ⇒  v1  ⇒ json/yaml ⇒ etcd</span><br><span class="line">                     admission    validation</span><br><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.<span class="keyword">go</span>:<span class="number">46</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createHandler</span><span class="params">(r rest.NamedCreater, scope *RequestScope, admit admission.Interface, includeName <span class="keyword">bool</span>)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        trace := utiltrace.New(<span class="string">"Create"</span>, utiltrace.Field&#123;<span class="string">"url"</span>, req.URL.Path&#125;)</span><br><span class="line">        <span class="keyword">defer</span> trace.LogIfLong(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        gv := scope.Kind.GroupVersion()</span><br><span class="line">        <span class="comment">// 1、得到合适的SerializerInfo</span></span><br><span class="line">        s, err := negotiation.NegotiateInputSerializer(req, <span class="literal">false</span>, scope.Serializer)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            scope.err(err, w, req)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、找到合适的 decoder</span></span><br><span class="line">        decoder := scope.Serializer.DecoderToVersion(s.Serializer, scope.HubGroupVersion)</span><br><span class="line"></span><br><span class="line">        body, err := limitedReadBody(req, scope.MaxRequestBodyBytes)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            scope.err(err, w, req)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        defaultGVK := scope.Kind</span><br><span class="line">        original := r.New()</span><br><span class="line">        trace.Step(<span class="string">"About to convert to expected version"</span>)</span><br><span class="line">        <span class="comment">// 3、decoder 解码</span></span><br><span class="line">        obj, gvk, err := decoder.Decode(body, &amp;defaultGVK, original)</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        ae := request.AuditEventFrom(ctx)</span><br><span class="line">        admit = admission.WithAudit(admit, ae)</span><br><span class="line">        audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)</span><br><span class="line"></span><br><span class="line">        userInfo, _ := request.UserFrom(ctx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">            _, name, _ = scope.Namer.ObjectName(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、执行 admit 操作，即执行 kube-apiserver 启动时加载的 admission-plugins，</span></span><br><span class="line">        admissionAttributes := admission.NewAttributesRecord(......)</span><br><span class="line">        <span class="keyword">if</span> mutatingAdmission, ok := admit.(admission.MutationInterface); ok &amp;&amp; mutatingAdmission.Handles(admission.Create) &#123;</span><br><span class="line">            err = mutatingAdmission.Admit(ctx, admissionAttributes, scope)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                scope.err(err, w, req)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 5、执行 create 操作</span></span><br><span class="line">        result, err := finishRequest(timeout, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r.Create(</span><br><span class="line">                ctx,</span><br><span class="line">                name,</span><br><span class="line">                obj,</span><br><span class="line">                rest.AdmissionToValidateObjectFunc(admit, admissionAttributes, scope),</span><br><span class="line">                options,</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析 kube-apiserver 的启动流程，kube-apiserver 中包含三个 server，分别为 KubeAPIServer、APIExtensionsServer 以及 AggregatorServer，三个 server 是通过委托模式连接在一起的，初始化过程都是类似的，首先为每个 server 创建对应的 config，然后初始化 http server，http server 的初始化过程为首先初始化 <code>GoRestfulContainer</code>，然后安装 server 所包含的 API，安装 API 时首先为每个 API Resource 创建对应的后端存储 RESTStorage，再为每个 API Resource 支持的 verbs 添加对应的 handler，并将 handler 注册到 route 中，最后将 route 注册到 webservice 中，启动流程中 RESTFul API 的实现流程是其核心，至于 kube-apiserver 中认证鉴权等 filter 的实现、多版本资源转换、kubernetes service 的实现等一些细节会在后面的文章中继续进行分析。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>在<code>cmd/kube-apiserver/apiserver.go</code>的main包中启动apiserver，使用<code>options</code>包中的<code>NewServerRunOptions()</code>函数初始化默认配置，并使用<code>pflag</code>包和<code>AddFlags()</code>方法通过命令行启动参数填充配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">	s := options.NewServerRunOptions()</span><br><span class="line">	s.AddFlags(pflag.CommandLine)</span><br><span class="line"></span><br><span class="line">	flag.InitFlags()</span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">	verflag.PrintAndExitIfRequested()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := app.Run(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化完成后调用<code>app</code>包中的<code>Run()</code>函数启动实例，将创建的<code>ServerRunOptions</code>对象传入<code>app.Run()</code>中，并创建一个http server和一个https server。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run()让apiserver跑起来，永远不会退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(s *options.ServerRunOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	genericvalidation.VerifyEtcdServersList(s.GenericServerRunOptions)</span><br><span class="line">	genericapiserver.DefaultAndValidateRunOptions(s.GenericServerRunOptions)</span><br><span class="line">	genericConfig := genericapiserver.NewConfig(). <span class="comment">// create the new config</span></span><br><span class="line">							ApplyOptions(s.GenericServerRunOptions). <span class="comment">// apply the options selected</span></span><br><span class="line">							Complete()                               <span class="comment">// set default values based on the known values</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">  </span><br><span class="line">	m, err := config.Complete().New()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sharedInformers.Start(wait.NeverStop)</span><br><span class="line">	m.GenericAPIServer.PrepareRun().Run(wait.NeverStop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要用于生成master实例对象，<code>m, err := config.Complete().New()</code> 用来创建master，<code>Complete()</code>完善Config的初始化，<code>New()</code>进行resources的初始化和RESTful-api的注册，各种api的请求最后都是通过master对象来处理的，在最后APIServer会通过启动<code>Run(wait.NeverStop)</code>的方法来启动HTTP/HTTPS服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.SecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.Handler != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.serveSecurely(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.InsecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.InsecureHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.serveInsecurely(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.RunPostStartHooks()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// err == systemd.SdNotifyNoSocket when not running on a systemd system</span></span><br><span class="line">	<span class="keyword">if</span> err := systemd.SdNotify(<span class="string">"READY=1\n"</span>); err != <span class="literal">nil</span> &amp;&amp; err != systemd.SdNotifyNoSocket &#123;</span><br><span class="line">		glog.Errorf(<span class="string">"Unable to send systemd daemon successful start message: %v\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个Run()中实际由<code>s.serveSecurely(stopCh)</code>和<code>s.serveInsecurely(stopCh)</code>分别运行了https和http server。</p>
<p>而实际上，<code>s.serveSecurely(stopCh)</code>和<code>s.serveInsecurely(stopCh)</code>中都会调用<code>runServer()</code>函数来运行http和https server，<code>runServer()</code>会监听传入的端口号，调用goroutine持续服务直到<code>stopCH</code>这个只读通道关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runServer</span><span class="params">(server *http.Server, network <span class="keyword">string</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(server.Addr) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"address cannot be empty"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(network) == <span class="number">0</span> &#123;</span><br><span class="line">		network = <span class="string">"tcp"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first listen is synchronous (fail early!)</span></span><br><span class="line">	ln, err := net.Listen(network, server.Addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"failed to listen on %v: %v"</span>, server.Addr, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get port</span></span><br><span class="line">	tcpAddr, ok := ln.Addr().(*net.TCPAddr)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		ln.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"invalid listen address: %q"</span>, ln.Addr().String())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock := sync.Mutex&#123;&#125; <span class="comment">// to avoid we close an old listener during a listen retry</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		ln.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> listener net.Listener</span><br><span class="line">			listener = tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;</span><br><span class="line">			<span class="keyword">if</span> server.TLSConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">				listener = tls.NewListener(listener, server.TLSConfig)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			err := server.Serve(listener)</span><br><span class="line">			glog.Errorf(<span class="string">"Error serving %v (%v); will try again."</span>, server.Addr, err)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// listen again</span></span><br><span class="line">			<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				lock.Lock()</span><br><span class="line">				<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">				<span class="keyword">for</span> &#123;</span><br><span class="line">					time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line"></span><br><span class="line">					ln, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line">					<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					glog.Errorf(<span class="string">"Error listening on %v (%v); will try again."</span>, server.Addr, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tcpAddr.Port, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以整个apiserver的启动主体过程就是下图： <img alt="apiserver start" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_start.png"></p>
<h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><h3 id="type-APIRegistrationManager-struct"><a href="#type-APIRegistrationManager-struct" class="headerlink" title="type APIRegistrationManager struct"></a>type APIRegistrationManager struct</h3><p><code>APIRegistrationManager</code>负责对外提供已经注册并enable了的<code>GroupVersions</code>，将所有已经注册的，已经enable的，第三方的的<code>GroupVersions</code>进行了汇总，还包括了各个<code>GroupVersion</code>的<code>GroupMeta</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIRegistrationManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// registeredGroupVersions stores all API group versions for which RegisterGroup is called.</span></span><br><span class="line">    <span class="comment">//所有已经registered的GroupVersions都是通过调用RegisterVersions()方法来进行注册的</span></span><br><span class="line"></span><br><span class="line">	registeredVersions <span class="keyword">map</span>[unversioned.GroupVersion]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// thirdPartyGroupVersions are API versions which are dynamically</span></span><br><span class="line">	<span class="comment">// registered (and unregistered) via API calls to the apiserver</span></span><br><span class="line">	<span class="comment">//第三方注册的GroupVersions,这些都向apiServer动态注册的使用AddThirdPartyAPIGroupVersions()进行注册</span></span><br><span class="line">	</span><br><span class="line">	thirdPartyGroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">	<span class="comment">// enabledVersions represents all enabled API versions. It should be a</span></span><br><span class="line">	<span class="comment">// subset of registeredVersions. Please call EnableVersions() to add</span></span><br><span class="line">	<span class="comment">// enabled versions.</span></span><br><span class="line">	<span class="comment">//所有已经enable的GroupVersions，可以通过EnableVersions()将要enable的GroupVersion加入进来。只有enable了，才能使用对应的GroupVersion</span></span><br><span class="line"></span><br><span class="line">	enabledVersions <span class="keyword">map</span>[unversioned.GroupVersion]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map of group meta for all groups.</span></span><br><span class="line">	<span class="comment">// 所有groups的GroupMeta</span></span><br><span class="line"></span><br><span class="line">	groupMetaMap <span class="keyword">map</span>[<span class="keyword">string</span>]*apimachinery.GroupMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// envRequestedVersions represents the versions requested via the</span></span><br><span class="line">	<span class="comment">// KUBE_API_VERSIONS environment variable. The install package of each group</span></span><br><span class="line">	<span class="comment">// checks this list before add their versions to the latest package and</span></span><br><span class="line">	<span class="comment">// Scheme.  This list is small and order matters, so represent as a slice</span></span><br><span class="line">	<span class="comment">//存储KUBE_API_VERSIONS环境变量包含的版本，如果未指定，则KUBE_API_VERSIONS为空</span></span><br><span class="line">	</span><br><span class="line">	envRequestedVersions []unversioned.GroupVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-GroupVersion-struct"><a href="#type-GroupVersion-struct" class="headerlink" title="type GroupVersion struct"></a>type GroupVersion struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GroupVersion</code>中就是两个string类型，<code>Group</code>和<code>Version</code>，分别对应了api所处的分组和版本，这也是kubernetes实现多版本的基础。</p>
<h3 id="type-GroupMeta-struct"><a href="#type-GroupMeta-struct" class="headerlink" title="type GroupMeta struct"></a>type GroupMeta struct</h3><p><code>GroupMeta</code>主要包括Group的元信息，里面的成员RESTMapper，与APIGroupVersion一样，其实APIGroupVersion的RESTMapper直接取值于GroupMeta的RESTMapper。一个Group可能包含多个版本，存储在 GroupVersions 中，而 GroupVersion 是默认存储在etcd中的版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// GroupVersion represents the preferred version of the group.</span></span><br><span class="line">	<span class="comment">// 该group的默认版本</span></span><br><span class="line">	GroupVersion unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GroupVersions is Group + all versions in that group.</span></span><br><span class="line">	<span class="comment">// 该Group中可能会有多个版本，该字段就包含了所有的versions</span></span><br><span class="line">	GroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Codec is the default codec for serializing output that should use</span></span><br><span class="line">	<span class="comment">// the preferred version.  Use this Codec when writing to</span></span><br><span class="line">	<span class="comment">// disk, a data store that is not dynamically versioned, or in tests.</span></span><br><span class="line">	<span class="comment">// This codec can decode any object that the schema is aware of.</span></span><br><span class="line">	<span class="comment">// 用于编解码</span></span><br><span class="line">	Codec runtime.Codec</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SelfLinker can set or get the SelfLink field of all API types.</span></span><br><span class="line">	<span class="comment">// to go through the InterfacesFor method below.</span></span><br><span class="line">	SelfLinker runtime.SelfLinker</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known</span></span><br><span class="line">	<span class="comment">// versions.</span></span><br><span class="line">	<span class="comment">// RESTMapper提供 REST路径 与 那些在api.Scheme和所有已知版本中声明的对象之间的默认映射。用于类型，对象之间的转换</span></span><br><span class="line"></span><br><span class="line">	RESTMapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line">	<span class="comment">// InterfacesFor returns the default Codec and ResourceVersioner for a given version</span></span><br><span class="line">	<span class="comment">// string, or an error if the version is not known.</span></span><br><span class="line">	<span class="comment">// function provided below once every place that populates this field has been changed.</span></span><br><span class="line">	InterfacesFor <span class="function"><span class="keyword">func</span><span class="params">(version unversioned.GroupVersion)</span> <span class="params">(*meta.VersionInterfaces, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InterfacesByVersion stores the per-version interfaces.</span></span><br><span class="line">	InterfacesByVersion <span class="keyword">map</span>[unversioned.GroupVersion]*meta.VersionInterfaces</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-RESTMapper-interface"><a href="#type-RESTMapper-interface" class="headerlink" title="type RESTMapper interface"></a>type RESTMapper interface</h3><p><code>RESTMapper</code>是一个接口，<code>RESTMapper</code>可以从GVR获取GVK，并生成一个<code>RESTMapping</code>来处理该GVR</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RESTMapper allows clients to map resources to kind, and map kind and version</span></span><br><span class="line"><span class="comment">// to interfaces for manipulating those objects. It is primarily intended for</span></span><br><span class="line"><span class="comment">// consumers of Kubernetes compatible REST APIs as defined in docs/devel/api-conventions.md.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Kubernetes API provides versioned resources and object kinds which are scoped</span></span><br><span class="line"><span class="comment">// to API groups. In other words, kinds and resources should not be assumed to be</span></span><br><span class="line"><span class="comment">// unique across groups.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RESTMapper <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// KindFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches</span></span><br><span class="line">	KindFor(resource unversioned.GroupVersionResource) (unversioned.GroupVersionKind, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// KindsFor takes a partial resource and returns the list of potential kinds in priority order</span></span><br><span class="line">	KindsFor(resource unversioned.GroupVersionResource) ([]unversioned.GroupVersionKind, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ResourceFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches</span></span><br><span class="line">	ResourceFor(input unversioned.GroupVersionResource) (unversioned.GroupVersionResource, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ResourcesFor takes a partial resource and returns the list of potential resource in priority order</span></span><br><span class="line">	ResourcesFor(input unversioned.GroupVersionResource) ([]unversioned.GroupVersionResource, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RESTMapping identifies a preferred resource mapping for the provided group kind.</span></span><br><span class="line">	<span class="comment">// RESTMapping为指定的group kind 生成一个resource mapping。</span></span><br><span class="line">	RESTMapping(gk unversioned.GroupKind, versions ...<span class="keyword">string</span>) (*RESTMapping, error)</span><br><span class="line">	<span class="comment">// RESTMappings returns all resource mappings for the provided group kind.</span></span><br><span class="line">	RESTMappings(gk unversioned.GroupKind) ([]*RESTMapping, error)</span><br><span class="line"></span><br><span class="line">	AliasesForResource(resource <span class="keyword">string</span>) ([]<span class="keyword">string</span>, <span class="keyword">bool</span>)</span><br><span class="line">	ResourceSingularizer(resource <span class="keyword">string</span>) (singular <span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GroupVersionKind-GroupVersionResource-GroupKind"><a href="#GroupVersionKind-GroupVersionResource-GroupKind" class="headerlink" title="GroupVersionKind GroupVersionResource GroupKind"></a>GroupVersionKind GroupVersionResource GroupKind</h3><p>通过结构体字段可以发现，它们其实就是Group、Version、Kind、Resource的不同组合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">	Kind    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Version  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">	Resource <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Kind  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Resource-1"><a href="#Resource-1" class="headerlink" title="Resource"></a>Resource</h4><p>Resource就是指定了一个名字和kind的资源对象，不管它有没有namespace。 resource是通过<code>plural, singular := KindToResource(kind)</code>取值，singular是将Kind转换为小写字母，而plural是变为复数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// name is the name of the resource.</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line">	<span class="comment">// namespaced indicates if a resource is namespaced or not.</span></span><br><span class="line">	Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line">	<span class="comment">// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')</span></span><br><span class="line">	Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reousrce := unversioned.APIResource&#123;</span><br><span class="line">		Name:       <span class="string">"nodes"</span>, </span><br><span class="line">		Namespaced: <span class="literal">false</span>,</span><br><span class="line">		Kind:       <span class="string">"Node"</span>, </span><br><span class="line">	&#125;</span><br><span class="line">reousrce = unversioned.APIResource&#123;</span><br><span class="line">		Name:       <span class="string">"pods"</span>,</span><br><span class="line">		Namespaced: <span class="literal">true</span>,</span><br><span class="line">		Kind:       <span class="string">"Pod"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kind-1"><a href="#Kind-1" class="headerlink" title="Kind"></a>Kind</h4><p>Kind就是一个资源对象对应的种类 kind是通过<code>Kind=reflector.TypeOf(&amp;Pod{}).Elem().Name()</code>进行取值，取得的就是Pod这个结构体的名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> PodList <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> NodeList <span class="keyword">struct</span></span><br></pre></td></tr></table></figure>
<h4 id="Group-Version"><a href="#Group-Version" class="headerlink" title="Group Version"></a>Group Version</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Group=<span class="string">"core"</span></span><br><span class="line">Version=v1</span><br><span class="line"></span><br><span class="line">Group=<span class="string">"apps"</span></span><br><span class="line">Version=v1beta1</span><br></pre></td></tr></table></figure>
<p>各个Group是相互独立的，发展速度也不同，所有每个Group都会有不同的Version，而kubernetes是通过插件的方式来使用各个Group的，可以根据需求决定使用哪个Group。</p>
<h3 id="type-RESTMapping-struct"><a href="#type-RESTMapping-struct" class="headerlink" title="type RESTMapping struct"></a>type RESTMapping struct</h3><p>RESTMapping包含一个Resource名称，及其对应的GVK，一个Scope(标明资源是否为root或者namespaced)，一个Convertor用来转换该GVK对应的Object和一个MetadataAccessor用来提取Object的meta信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RESTMapping <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Resource is a string representing the name of this resource as a REST client would see it</span></span><br><span class="line">	Resource <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	GroupVersionKind unversioned.GroupVersionKind</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scope contains the information needed to deal with REST Resources that are in a resource hierarchy</span></span><br><span class="line">	Scope RESTScope</span><br><span class="line"></span><br><span class="line">	runtime.ObjectConvertor</span><br><span class="line">	MetadataAccessor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-RESTScope-interface"><a href="#type-RESTScope-interface" class="headerlink" title="type RESTScope interface"></a>type RESTScope interface</h3><p>RESTScope用于标识某个资源是处于Namespace下，还是全局资源</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"></span><br><span class="line">	RESTScopeNameNamespace RESTScopeName = <span class="string">"namespace"</span></span><br><span class="line">	RESTScopeNameRoot      RESTScopeName = <span class="string">"root"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTScope contains the information needed to deal with REST resources that are in a resource hierarchy</span></span><br><span class="line"><span class="comment">// RESTScope包含处理资源层次结构中的REST资源所需的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RESTScope <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Name of the scope</span></span><br><span class="line">	Name() RESTScopeName</span><br><span class="line">	<span class="comment">// ParamName is the optional name of the parameter that should be inserted in the resource url</span></span><br><span class="line">	<span class="comment">// If empty, no param will be inserted</span></span><br><span class="line">	ParamName() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// ArgumentName is the optional name that should be used for the variable holding the value.</span></span><br><span class="line">	ArgumentName() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// ParamDescription is the optional description to use to document the parameter in api documentation</span></span><br><span class="line">	ParamDescription() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-ObjectConvertor-interface"><a href="#type-ObjectConvertor-interface" class="headerlink" title="type ObjectConvertor interface"></a>type ObjectConvertor interface</h3><p>Convertor用来转换该GVK对应的Object</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectConvertor converts an object to a different version.</span></span><br><span class="line"><span class="comment">// ObjectConvertor将一个object转换为不同的版本。</span></span><br><span class="line"><span class="keyword">type</span> ObjectConvertor <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Convert attempts to convert one object into another, or returns an error. This method does</span></span><br><span class="line">	<span class="comment">// not guarantee the in object is not mutated. The context argument will be passed to</span></span><br><span class="line">	<span class="comment">// all nested conversions.</span></span><br><span class="line">	Convert(in, out, context <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// ConvertToVersion takes the provided object and converts it the provided version. This</span></span><br><span class="line">	<span class="comment">// method does not guarantee that the in object is not mutated. This method is similar to</span></span><br><span class="line">	<span class="comment">// Convert() but handles specific details of choosing the correct output version.</span></span><br><span class="line">	ConvertToVersion(in Object, gv GroupVersioner) (out Object, err error)</span><br><span class="line">	ConvertFieldLabel(version, kind, label, value <span class="keyword">string</span>) (<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-MetadataAccessor-interface"><a href="#type-MetadataAccessor-interface" class="headerlink" title="type MetadataAccessor interface"></a>type MetadataAccessor interface</h3><p><code>type MetadataAccessor interface</code>可以让你在任何external version或者internal version中操作object和list这些metadata</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MetadataAccessor <span class="keyword">interface</span> &#123;</span><br><span class="line">	APIVersion(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">	SetAPIVersion(obj runtime.Object, version <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	Kind(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">	SetKind(obj runtime.Object, kind <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	Namespace(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">	SetNamespace(obj runtime.Object, namespace <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	Name(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">	SetName(obj runtime.Object, name <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	GenerateName(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">	SetGenerateName(obj runtime.Object, name <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	UID(obj runtime.Object) (types.UID, error)</span><br><span class="line">	SetUID(obj runtime.Object, uid types.UID) error</span><br><span class="line"></span><br><span class="line">	SelfLink(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">	SetSelfLink(obj runtime.Object, selfLink <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	Labels(obj runtime.Object) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span><br><span class="line">	SetLabels(obj runtime.Object, labels <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	Annotations(obj runtime.Object) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span><br><span class="line">	SetAnnotations(obj runtime.Object, annotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">	runtime.ResourceVersioner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//runtime.Object 定义在/pkg/runtime/interfaces.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All API types registered with Scheme must support the Object interface. Since objects in a scheme are</span></span><br><span class="line"><span class="comment">// expected to be serialized to the wire, the interface an Object must provide to the Scheme allows</span></span><br><span class="line"><span class="comment">// serializers to set the kind, version, and group the object is represented as. An Object may choose</span></span><br><span class="line"><span class="comment">// to return a no-op ObjectKindAccessor in cases where it is not expected to be serialized.</span></span><br><span class="line"><span class="comment">// 在Scheme中注册的所有API类型都必须支持Object接口。这是因为在scheme中的objects是会被序列化成线的，所以一个Object必须提供接口给scheme来序列化地设置其kind、version、group。在不需要序列化的情况下，Object可以选择返回一个无操作的ObjectKindAccessor。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetObjectKind() unversioned.ObjectKind</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourceVersioner provides methods for setting and retrieving</span></span><br><span class="line"><span class="comment">// the resource version from an API object.</span></span><br><span class="line"><span class="comment">// 设置和接收一个API object的resource version</span></span><br><span class="line"><span class="keyword">type</span> ResourceVersioner <span class="keyword">interface</span> &#123;</span><br><span class="line">	SetResourceVersion(obj Object, version <span class="keyword">string</span>) error</span><br><span class="line">	ResourceVersion(obj Object) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多版本资源注册"><a href="#多版本资源注册" class="headerlink" title="多版本资源注册"></a>多版本资源注册</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>在<code>pkg/master/import_known_versions.go</code>中会初始化所有group的install包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> master</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	k8s现阶段，API一共分为13个Group：</span></span><br><span class="line"><span class="comment">		Core、</span></span><br><span class="line"><span class="comment">		apps、authentication、authorization、</span></span><br><span class="line"><span class="comment">		autoscaling、batch、certificates、componentconfig、</span></span><br><span class="line"><span class="comment">		extensions、imagepolicy、policy、rbac、storage。</span></span><br><span class="line"><span class="comment">	其中Core的Group Name为空，它包含的API是最核心的API,如Pod、Service等，它的代码位于pkg/api下面。</span></span><br><span class="line"><span class="comment">	其它12个Group代码位于pkg/apis。</span></span><br><span class="line"><span class="comment">	每个目录下都有一个install目录，里面有一个install.go文件，接着通过init()负责初始化。</span></span><br><span class="line"><span class="comment">	所有的install都是通过下面的import进行导入的！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These imports are the API groups the API server will support.</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/api/install"</span></span><br><span class="line">	<span class="string">"k8s.io/kubernetes/pkg/apimachinery/registered"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/apps/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/authentication/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/authorization/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/autoscaling/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/batch/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/certificates/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/componentconfig/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/extensions/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/imagepolicy/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/policy/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/rbac/install"</span></span><br><span class="line">	_ <span class="string">"k8s.io/kubernetes/pkg/apis/storage/install"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> missingVersions := registered.ValidateEnvRequestedVersions(); <span class="built_in">len</span>(missingVersions) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"KUBE_API_VERSIONS contains versions that are not installed: %q."</span>, missingVersions))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有的<code>/install/install.go</code>文件中，都会生成<code>groupMeta</code>，并向<code>registered.DefaultAPIRegistrationManager</code>注册。这个<code>groupMeta</code>中包含一个<code>DefaultRESTMapper</code> 以<code>pkg/api/install/install.go</code>中core group的install包为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过registered.RegisterVersions将core group所有的versions注册到DefaultAPIRegistrationManager中</span></span><br><span class="line">	registered.RegisterVersions(availableVersions)</span><br><span class="line">	externalVersions := []unversioned.GroupVersion&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> availableVersions &#123;</span><br><span class="line">        <span class="comment">// 判断下环境变量KUBE_API_VERSIONS的设置是否允许该gv，并append成一个切片，默认情况下，是不会设置环境变量KUBE_API_VERSIONS，就Core Group而言，此时externalVersions的值应该是 v1</span></span><br><span class="line">		<span class="keyword">if</span> registered.IsAllowedVersion(v) &#123;</span><br><span class="line">			externalVersions = <span class="built_in">append</span>(externalVersions, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(externalVersions) == <span class="number">0</span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"No version is registered for group %v"</span>, api.GroupName)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再进行gv的enable，其实就是存入APIRegistrationManager.enabledVersions</span></span><br><span class="line">	<span class="keyword">if</span> err := registered.EnableVersions(externalVersions...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"%v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := enableVersions(externalVersions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.V(<span class="number">4</span>).Infof(<span class="string">"%v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步的<code>err := enableVersions(externalVersions)</code>非常重要，完成了填充Scheme，初始化groupMeta的步骤：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enableVersions</span><span class="params">(externalVersions []unversioned.GroupVersion)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将所有的GroupVersions添加到Scheme</span></span><br><span class="line">    </span><br><span class="line">    addVersionsToScheme(externalVersions...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将第一个GroupVersion作为默认的值 ""/v1</span></span><br><span class="line">    </span><br><span class="line">	preferredExternalVersion := externalVersions[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里开始进行GroupMeta的初始化。主要是用external versions去填充GroupMeta以及其成员RESTMapper。GroupMeta主要用于初始化APIGroupVersion</span></span><br><span class="line">    </span><br><span class="line">	groupMeta := apimachinery.GroupMeta&#123;</span><br><span class="line">		GroupVersion:  preferredExternalVersion,</span><br><span class="line">		GroupVersions: externalVersions,</span><br><span class="line">		RESTMapper:    newRESTMapper(externalVersions),</span><br><span class="line">		SelfLinker:    runtime.SelfLinker(accessor),</span><br><span class="line">		InterfacesFor: interfacesFor,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// registered.RegisterGroup(groupMeta)其实就是以第一个GroupVersion的groupName为key，groupMeta为value，向APIRegistrationManager注册了v1版本的groupMeta。所有group的/install/install.go文件中，都会生成groupMeta，并向registered.DefaultAPIRegistrationManager注册</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> err := registered.RegisterGroup(groupMeta); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>addVersionsToScheme：将所有的Versions添加到Scheme</li>
<li>生成一个groupMeta，即groupMeta的初始化</li>
<li>registered.RegisterGroup(groupMeta)，真正注册一个group</li>
</ul>
<p>其中<code>newRESTMapper(externalVersions)</code>其实包含的是一种转换关系，resource到kind，kind到resource，kind到scope的转换。 <code>RESTMapper</code>映射是指GVR(<code>GroupVersionResource</code>)和GVK(<code>GroupVersionKind</code>)的关系，可以通过GVR找到合适的GVK</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRESTMapper</span><span class="params">(externalVersions []unversioned.GroupVersion)</span> <span class="title">meta</span>.<span class="title">RESTMapper</span></span> &#123;</span><br><span class="line">	<span class="comment">// the list of kinds that are scoped at the root of the api hierarchy</span></span><br><span class="line">	<span class="comment">// if a kind is not enumerated here, it is assumed to have a namespace scope</span></span><br><span class="line">	<span class="comment">//rootScoped枚举列出的是API最顶层的对象，可以理解为没有namespace的对象。</span></span><br><span class="line">	rootScoped := sets.NewString(</span><br><span class="line">		<span class="string">"Node"</span>,</span><br><span class="line">		<span class="string">"Namespace"</span>,</span><br><span class="line">		<span class="string">"PersistentVolume"</span>,</span><br><span class="line">		<span class="string">"ComponentStatus"</span>,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// these kinds should be excluded from the list of resources</span></span><br><span class="line">	<span class="comment">//ignoredKinds是下面接口需要用到的参数，表示遍历Scheme时忽略这些kinds。</span></span><br><span class="line">	ignoredKinds := sets.NewString(</span><br><span class="line">		<span class="string">"ListOptions"</span>,</span><br><span class="line">		<span class="string">"DeleteOptions"</span>,</span><br><span class="line">		<span class="string">"Status"</span>,</span><br><span class="line">		<span class="string">"PodLogOptions"</span>,</span><br><span class="line">		<span class="string">"PodExecOptions"</span>,</span><br><span class="line">		<span class="string">"PodAttachOptions"</span>,</span><br><span class="line">		<span class="string">"PodProxyOptions"</span>,</span><br><span class="line">		<span class="string">"NodeProxyOptions"</span>,</span><br><span class="line">		<span class="string">"ServiceProxyOptions"</span>,</span><br><span class="line">		<span class="string">"ThirdPartyResource"</span>,</span><br><span class="line">		<span class="string">"ThirdPartyResourceData"</span>,</span><br><span class="line">		<span class="string">"ThirdPartyResourceList"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		调用api.NewDefaultRESTMapper()，</span></span><br><span class="line"><span class="comment">		==&gt;定义在pkg/api/mapper.go</span></span><br><span class="line"><span class="comment">			==&gt;func NewDefaultRESTMapper</span></span><br><span class="line"><span class="comment">		importPrefix 的值为："k8s.io/kubernetes/pkg/api"，</span></span><br><span class="line"><span class="comment">		externalVersions: [v1]</span></span><br><span class="line"><span class="comment">		interfacesFor是一个函数func interfacesFor(version unversioned.GroupVersion)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	mapper := api.NewDefaultRESTMapper(externalVersions, interfacesFor, importPrefix, ignoredKinds, rootScoped)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>NewDefaultRESTMapper</code>定义在<code>pkg/api/mapper.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据在api.Scheme中注册的types来实例化一个DefaultRESTMapper</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultRESTMapper</span><span class="params">(defaultGroupVersions []unversioned.GroupVersion, interfacesFunc meta.VersionInterfacesFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">	importPathPrefix <span class="keyword">string</span>, ignoredKinds, rootScoped sets.String)</span> *<span class="title">meta</span>.<span class="title">DefaultRESTMapper</span></span> &#123;</span><br><span class="line">	<span class="comment">// 指定一个Scheme,并继续调用下面的接口</span></span><br><span class="line">	<span class="keyword">return</span> NewDefaultRESTMapperFromScheme(defaultGroupVersions, interfacesFunc, importPathPrefix, ignoredKinds, rootScoped, Scheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再调用<code>NewDefaultRESTMapperFromScheme</code>函数，它主要流程是：</p>
<ol>
<li>先创建了一个空的<code>DefaultRESTMapper</code>,</li>
<li>然后根据”<code>/api/v1</code>“的<code>groupVersion</code>（只举了其中的一个<code>groupversion</code>，所以可以依据<code>defaultGroupVersions</code>来区别<code>DefaultRESTMapper</code>）,</li>
<li>遍历Scheme中所有的kinds，</li>
<li>接着再调用<code>mapper.Add(gvk, scope)</code>去填充这个mapper，</li>
<li>最后返回该mapper。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	基于指定的 Scheme 中注册的“types”实例化一个DefaultRESTMapper</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	scope=RESTScopeNamespace或RESTScopeRoot</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NewDefaultRESTMapperFromScheme()函数依据传入的defaultGroupVersions和interfacesFunc参数生成mapper，</span></span><br><span class="line"><span class="comment">然后把在Scheme中defaultGroupVersions下的资源注册到mapper中。</span></span><br><span class="line"><span class="comment">这里的Scheme即api.Scheme，全部的类型都会注册到api.Scheme中。</span></span><br><span class="line"><span class="comment">所以可以依据defaultGroupVersions来区别DefaultRESTMapper。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultRESTMapperFromScheme</span><span class="params">(defaultGroupVersions []unversioned.GroupVersion, interfacesFunc meta.VersionInterfacesFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">	importPathPrefix <span class="keyword">string</span>, ignoredKinds, rootScoped sets.String, scheme *runtime.Scheme)</span> *<span class="title">meta</span>.<span class="title">DefaultRESTMapper</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		初始化了一个DefaultRESTMapper对象</span></span><br><span class="line"><span class="comment">		meta.NewDefaultRESTMapper定义在/pkg/api/meta/restmapper.go</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	mapper := meta.NewDefaultRESTMapper(defaultGroupVersions, interfacesFunc)</span><br><span class="line">	fmt.Println(<span class="string">"defaultGroupVersions is: "</span>, reflect.ValueOf(defaultGroupVersions))</span><br><span class="line">	fmt.Println(<span class="string">"initial time, mapper is: "</span>, reflect.ValueOf(mapper))</span><br><span class="line">	<span class="comment">// enumerate all supported versions, get the kinds, and register with the mapper how to address</span></span><br><span class="line">	<span class="comment">// our resources.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		遍历所有支持的versions，获取kinds，在mapper中注册如何去address our resource</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		根据输入的defaultGroupVersions,比如"/api/v1"，</span></span><br><span class="line"><span class="comment">		从Scheme中遍历所有的kinds，</span></span><br><span class="line"><span class="comment">		然后进行Add</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> _, gv := <span class="keyword">range</span> defaultGroupVersions &#123;</span><br><span class="line">		<span class="comment">//从scheme获取一个指定GV的所有Type</span></span><br><span class="line">		<span class="keyword">for</span> kind, oType := <span class="keyword">range</span> scheme.KnownTypes(gv) &#123;</span><br><span class="line">			fmt.Println(<span class="string">"gv, kind is:"</span>, gv, kind)</span><br><span class="line">			gvk := gv.WithKind(kind)</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> Remove import path check.</span></span><br><span class="line">			<span class="comment">// We check the import path because we currently stuff both "api" and "extensions" objects</span></span><br><span class="line">			<span class="comment">// into the same group within Scheme since Scheme has no notion of groups yet.</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> !strings.Contains(oType.PkgPath(), importPathPrefix) || ignoredKinds.Has(kind) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 判断该kind是否有namespace属性</span></span><br><span class="line">			scope := meta.RESTScopeNamespace</span><br><span class="line">			<span class="keyword">if</span> rootScoped.Has(kind) &#123;</span><br><span class="line">				scope = meta.RESTScopeRoot</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				然后将该gvk加入到对应的组中</span></span><br><span class="line"><span class="comment">				Add定义在/pkg/api/meta/restmapper.go</span></span><br><span class="line"><span class="comment">				==&gt;func (m *DefaultRESTMapper) Add(kind unversioned.GroupVersionKind, scope RESTScope)</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			mapper.Add(gvk, scope)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>mapper.Add(gvk, scope)</code>方法是把GVK（kind）和GVK对应的scope加入到<code>DefaultRESTMapper</code>对应的map属性中</p>
<p><code>type DefaultRESTMapper struct</code>中字段的含义：</p>
<ul>
<li>defaultGroupVersions: 默认的GroupVersion，如v1，apps/v1beta1等，一般一个DefaultRESTMapper只设一个默认的GroupVersion</li>
<li>resourceToKind：GVR(单数,复数)到GVK的map；</li>
<li>kindToPluralResource：GVK到GVR(复数)的map；</li>
<li>kindToScope：GVK到Scope的map；</li>
<li>singularToPlural：GVR(单数)到GVR(复数)的map；</li>
<li>interfacesFunc：用来产生Convertor和MetadataAccessor，具体实现为/pkg/api/install/install.go中的interfacesFor()函数。</li>
<li>aliasToResource：用于将别名映射到资源</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DefaultRESTMapper <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	defaultGroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">	resourceToKind       <span class="keyword">map</span>[unversioned.GroupVersionResource]unversioned.GroupVersionKind</span><br><span class="line">	kindToPluralResource <span class="keyword">map</span>[unversioned.GroupVersionKind]unversioned.GroupVersionResource</span><br><span class="line">	kindToScope          <span class="keyword">map</span>[unversioned.GroupVersionKind]RESTScope</span><br><span class="line">	singularToPlural     <span class="keyword">map</span>[unversioned.GroupVersionResource]unversioned.GroupVersionResource</span><br><span class="line">	pluralToSingular     <span class="keyword">map</span>[unversioned.GroupVersionResource]unversioned.GroupVersionResource</span><br><span class="line"></span><br><span class="line">	interfacesFunc VersionInterfacesFunc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// aliasToResource is used for mapping aliases to resources</span></span><br><span class="line">	aliasToResource <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addVersionsToScheme</code>：将所有的Versions添加到Scheme，Apiserver全局范围内，只有一个Scheme，即api.Scheme。 所有的GroupVersion受这个api.Scheme管理。所有的GroupVersion的Type都是往这个全局唯一的api.Scheme里面注册。</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scheme`定义在`pkg/api/register.go`，`NewScheme()`定义在`/pkg/runtime/scheme.go</span><br><span class="line">var Scheme = runtime.NewScheme()</span><br></pre></td></tr></table></figure>
<p>在Scheme的定义里面</p>
<ul>
<li>一个Type，就是一个特定的Go Struct</li>
<li>一个Version，是该Type的特定表示的时间点标识符（通常向后兼容）</li>
<li>一个Kind，是一个Type在该Version中的唯一name</li>
<li>一个Group，标识了一组Versions, Kinds, and Types</li>
<li>一个Unversioned Type，是一种还没正式绑定到一个Type的Type，会被往后兼容</li>
</ul>
<p><code>RESTMapper</code>管理的是GVR和GVK的关系，<code>Scheme</code>管理的是GVK和Type的关系</p>
<p>在<code>pkg/runtime/scheme.go</code>中，定义了<code>type Scheme struct</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// versionMap allows one to figure out the go type of an object with</span></span><br><span class="line">	<span class="comment">// the given version and name.</span></span><br><span class="line">	<span class="comment">// 用gvk找出对应的Type，一个gvk只能对应一个Type</span></span><br><span class="line">	gvkToType <span class="keyword">map</span>[unversioned.GroupVersionKind]reflect.Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// typeToGroupVersion allows one to find metadata for a given go object.</span></span><br><span class="line">	<span class="comment">// The reflect.Type we index by should *not* be a pointer.</span></span><br><span class="line">	<span class="comment">// 存储Type和gvk的关系，一个type可能对应多个GVK</span></span><br><span class="line">	typeToGVK <span class="keyword">map</span>[reflect.Type][]unversioned.GroupVersionKind</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unversionedTypes are transformed without conversion in ConvertToVersion.</span></span><br><span class="line">	<span class="comment">// 记录没有版本控制的Type（即unversionedTypes）和GVK的关系，unversionedTypes无需版本转换</span></span><br><span class="line">	unversionedTypes <span class="keyword">map</span>[reflect.Type]unversioned.GroupVersionKind</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unversionedKinds are the names of kinds that can be created in the context of any group</span></span><br><span class="line">	<span class="comment">// or version</span></span><br><span class="line">    <span class="comment">// 记录unversioned的GVK和Type的关系</span></span><br><span class="line">	unversionedKinds <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Map from version and resource to the corresponding func to convert</span></span><br><span class="line">	<span class="comment">// resource field labels in that version to internal version.</span></span><br><span class="line">	fieldLabelConversionFuncs <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]FieldLabelConversionFunc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// defaulterFuncs is an array of interfaces to be called with an object to provide defaulting</span></span><br><span class="line">	<span class="comment">// the provided object must be a pointer.</span></span><br><span class="line">	defaulterFuncs <span class="keyword">map</span>[reflect.Type]<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// converter stores all registered conversion functions. It also has</span></span><br><span class="line">	<span class="comment">// default coverting behavior.</span></span><br><span class="line">	<span class="comment">// converter存储所有注册转换函数。 它还具有默认转换功能。用来转换不同版本的结构体值</span></span><br><span class="line">	converter *conversion.Converter</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cloner stores all registered copy functions. It also has default</span></span><br><span class="line">	<span class="comment">// deep copy behavior.</span></span><br><span class="line">	<span class="comment">// 用来获取结构体值的拷贝</span></span><br><span class="line">	cloner *conversion.Cloner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kubernetes内部组件的流通的结构体值使用的是内部版本，所有的外部版本都要向内部版本进行转换； 内部版本必须转换成外部版本才能进行输出。 外部版本之间不能直接转换。 etcd中存储的是带有版本的数据</p>
<p>在<code>addVersionsToScheme()</code>函数中，主要就是向Scheme注册internal version和external version</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addVersionsToScheme</span><span class="params">(externalVersions ...unversioned.GroupVersion)</span></span> &#123;</span><br><span class="line">	<span class="comment">// add the internal version to Scheme</span></span><br><span class="line">    <span class="comment">/* 将internal version加入到api.Scheme。</span></span><br><span class="line"><span class="comment">		Scheme就是在pkg/api/register.go中初始化的</span></span><br><span class="line"><span class="comment">		var Scheme = runtime.NewScheme()</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> err := api.AddToScheme(api.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Programmer error, detect immediately</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// add the enabled external versions to Scheme</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> externalVersions &#123;</span><br><span class="line">		<span class="keyword">if</span> !registered.IsEnabledVersion(v) &#123;</span><br><span class="line">			glog.Errorf(<span class="string">"Version %s is not enabled, so it will not be added to the Scheme."</span>, v)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> v &#123;</span><br><span class="line">		<span class="keyword">case</span> v1.SchemeGroupVersion:</span><br><span class="line">			<span class="keyword">if</span> err := v1.AddToScheme(api.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Programmer error, detect immediately</span></span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func (c completedConfig) New()</code>基于给定的配置生成一个新的Master实例，在这个方法中生成各版本资源对应的RESTful API。</p>
<p><code>func (c completedConfig) New()</code>方法的流程如下：</p>
<ol>
<li>调用<code>func (c completedConfig) New() (*GenericAPIServer, error)</code>，创建一<code>type GenericAPIServer struct</code>实例</li>
<li>判断是否enable了用于Watch的Cache，和etcd建立连接</li>
<li>调用<code>InstallLegacyAPI</code>进行”<code>/api</code>“的API安装</li>
<li>调用<code>InstallAPIs</code>进行”<code>/apis</code>“的API安装，如果其处于enabled状态</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*Master, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(c.KubeletClientConfig, kubeletclient.KubeletClientConfig&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Master.New() called with empty config.KubeletClientConfig"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值s中包涵了s.HandlerContainer，也就是说s.HandlerContainer在这里完成了初始化</span></span><br><span class="line"><span class="comment">	里面还完成WebService的创建，该WebService是用于list 一个group下的所有versions，因为只注册了简单的路由规则。同时把WebService注入到了s.HandlerContainer中,真正核心的注册都会在pkg/apiserver/apiserver.go中的func (g *APIGroupVersion) InstallREST 中进行</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	s, err := c.Config.GenericConfig.SkipComplete().New() <span class="comment">// completion is done in Complete, no need for a second time</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.EnableUISupport &#123;</span><br><span class="line">		routes.UIRedirect&#123;&#125;.Install(s.HandlerContainer)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.EnableLogsSupport &#123;</span><br><span class="line">		routes.Logs&#123;&#125;.Install(s.HandlerContainer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m := &amp;Master&#123;</span><br><span class="line">		GenericAPIServer: s,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	restOptionsFactory := restOptionsFactory&#123;</span><br><span class="line">		deleteCollectionWorkers: c.DeleteCollectionWorkers,</span><br><span class="line">		enableGarbageCollection: c.GenericConfig.EnableGarbageCollection,</span><br><span class="line">		storageFactory:          c.StorageFactory,</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    判断是否enable了用于Watch的Cache。有无cache，赋值的是不同的接口实现。</span></span><br><span class="line"><span class="comment">    有无cache的接口差异就在于：</span></span><br><span class="line"><span class="comment">			有cache的话，就提供操作cache的接口；</span></span><br><span class="line"><span class="comment">			无cache的话，就提供直接操作etcd的接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> c.EnableWatchCache &#123;</span><br><span class="line">		restOptionsFactory.storageDecorator = registry.StorageWithCacher</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		restOptionsFactory.storageDecorator = generic.UndecoratedStorage</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// install legacy rest storage</span></span><br><span class="line">    <span class="comment">// 判断/api/v1的group是否已经注册并enable，是的话再进行install</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> c.GenericConfig.APIResourceConfigSource.AnyResourcesForVersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">		legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;</span><br><span class="line">			StorageFactory:       c.StorageFactory,</span><br><span class="line">			ProxyTransport:       c.ProxyTransport,</span><br><span class="line">			KubeletClientConfig:  c.KubeletClientConfig,</span><br><span class="line">			EventTTL:             c.EventTTL,</span><br><span class="line">			ServiceIPRange:       c.ServiceIPRange,</span><br><span class="line">			ServiceNodePortRange: c.ServiceNodePortRange,</span><br><span class="line">			LoopbackClientConfig: c.GenericConfig.LoopbackClientConfig,</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行"/api"的API安装</span></span><br><span class="line">        </span><br><span class="line">		m.InstallLegacyAPI(c.Config, restOptionsFactory.NewFor, legacyRESTStorageProvider)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	restStorageProviders := []genericapiserver.RESTStorageProvider&#123;</span><br><span class="line">		appsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		authenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authenticator&#125;,</span><br><span class="line">		authorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorizer&#125;,</span><br><span class="line">		autoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		batchrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		certificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		extensionsrest.RESTStorageProvider&#123;ResourceInterface: thirdparty.NewThirdPartyResourceServer(s, c.StorageFactory)&#125;,</span><br><span class="line">		policyrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">		rbacrest.RESTStorageProvider&#123;AuthorizerRBACSuperUser: c.GenericConfig.AuthorizerRBACSuperUser&#125;,</span><br><span class="line">		storagerest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行"/apis"的API安装</span></span><br><span class="line">    </span><br><span class="line">	m.InstallAPIs(c.Config.GenericConfig.APIResourceConfigSource, restOptionsFactory.NewFor, restStorageProviders...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.Tunneler != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.installTunneler(c.Tunneler, coreclient.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig).Nodes())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>InstallLegacyAPI()</code>进行了/api的安装</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(c *Config, restOptionsGetter genericapiserver.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	glog.Infof(<span class="string">"生成apiGroupInfo, apiGroupInfo携带着restStorageMap"</span>)</span><br><span class="line">	legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Fatalf(<span class="string">"Error building core storage: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.EnableCoreControllers &#123;</span><br><span class="line">		serviceClient := coreclient.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line"></span><br><span class="line">		bootstrapController := c.NewBootstrapController(legacyRESTStorage, serviceClient)</span><br><span class="line">		<span class="keyword">if</span> err := m.GenericAPIServer.AddPostStartHook(<span class="string">"bootstrap-controller"</span>, bootstrapController.PostStartHook); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.Fatalf(<span class="string">"Error registering PostStartHook %q: %v"</span>, <span class="string">"bootstrap-controller"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// install core Group's API</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		调用InstallLegacyAPIGroup，定义在</span></span><br><span class="line"><span class="comment">		==&gt;/pkg/genericapiserver/genericapiserver.go</span></span><br><span class="line"><span class="comment">			==&gt;func (s *GenericAPIServer) InstallLegacyAPIGroup(apiPrefix string, apiGroupInfo *APIGroupInfo)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Fatalf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在<code>NewLegacyRESTStorage</code>方法中，会进行storage的创建，其流程如下：</p>
<ol>
<li>生成一个type APIGroupInfo struct实例，这个和前面说的资源注册的<code>APIRegistrationManager、Scheme、GroupMeta...</code>有关系。</li>
<li>初始化一个LegacyRESTStorage对象，即restStorage</li>
<li>创建各类Storage，如podStorage、nodeStorage..</li>
<li>把步骤3中创建的各种Storage保存到restStorageMap中，然后装在到APIGroupInfo中，APIGroupInfo.VersionedResourcesStorageMap[“v1”]。这是API映射map，这很重要，在后面的利用APIGroupInfo来生成APIGroupVersion的时候，就是依靠这个map映射关系来获取对应version的资源的rest strorage实现。</li>
<li>return restStorage, APIGroupInfo</li>
</ol>
<p><code>InstallLegacyAPIGroup()</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">InstallLegacyAPIGroup</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断前缀参数是否正确</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		s.legacyAPIGroupPrefixes is: map[/api:&#123;&#125;]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> !s.legacyAPIGroupPrefixes.Has(apiPrefix) &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%q is not in the allowed legacy API prefixes: %v"</span>, apiPrefix, s.legacyAPIGroupPrefixes.List())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		关键接口，真正install API（转化为resuful api）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> err := s.installAPIResources(apiPrefix, apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// setup discovery</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		获取了该Group下所有的version信息</span></span><br><span class="line"><span class="comment">		添加一个WebService，其route路径是/api</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	apiVersions := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.GroupMeta.GroupVersions &#123;</span><br><span class="line">		apiVersions = <span class="built_in">append</span>(apiVersions, groupVersion.Version)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Install the version handler.</span></span><br><span class="line">	<span class="comment">// Add a handler at /&lt;apiPrefix&gt; to enumerate the supported api versions.</span></span><br><span class="line">	apiserver.AddApiWebService(s.Serializer, s.HandlerContainer.Container, apiPrefix, <span class="function"><span class="keyword">func</span><span class="params">(req *restful.Request)</span> *<span class="title">unversioned</span>.<span class="title">APIVersions</span></span> &#123;</span><br><span class="line">		clientIP := utilnet.GetClientIP(req.Request)</span><br><span class="line"></span><br><span class="line">		apiVersionsForDiscovery := unversioned.APIVersions&#123;</span><br><span class="line">			ServerAddressByClientCIDRs: s.discoveryAddresses.ServerAddressByClientCIDRs(clientIP),</span><br><span class="line">			Versions:                   apiVersions,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;apiVersionsForDiscovery</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>installAPIResources()</code>方法用于安装每个api groupversionresource的REST存储，基本流程如下：</p>
<ol>
<li>遍历该Group的所有versions（一个Group调用一次本函数，亦即所有Group最后都是调用本函数来安装Restful API）</li>
<li>基于<code>apiGroupInfo</code>, <code>groupVersion</code>, <code>apiPrefix</code>创建一个<code>type APIGroupVersion struct</code>对象</li>
<li>根据创建的<code>APIGroupVersion</code>,然后安装restful API，<code>apiGroupVersion.InstallREST</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">installAPIResources</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 遍历该Group下的所有GroupVersons</span></span><br><span class="line">	<span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.GroupMeta.GroupVersions &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			创建APIGroupVersion</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			调用func (s *GenericAPIServer) getAPIGroupVersion</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		apiGroupVersion, err := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> apiGroupInfo.OptionsExternalVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">			apiGroupVersion.OptionsExternalVersion = apiGroupInfo.OptionsExternalVersion</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			根据之前创建的APIGroupVersion,然后安装restful API</span></span><br><span class="line"><span class="comment">			该s.HandlerContainer.Container就是go-restful的Container</span></span><br><span class="line"><span class="comment">			InstallREST 定义在：pkg/apiserver/apiserver.go</span></span><br><span class="line"><span class="comment">					==&gt;func (g *APIGroupVersion) InstallREST(container *restful.Container)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> err := apiGroupVersion.InstallREST(s.HandlerContainer.Container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"Unable to setup API %v: %v"</span>, apiGroupInfo, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用<code>InstallREST()</code>安装restful API，<code>InstallREST()</code>将REST handlers（storage, watch, proxy and redirect）注册到go-restful框架的Container中，流程如下：</p>
<ol>
<li>创建了一个type APIInstaller struct对象</li>
<li>构造一个webservice</li>
<li>往webservice里面添加Route</li>
<li>往container中添加webservice</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *APIGroupVersion)</span> <span class="title">InstallREST</span><span class="params">(container *restful.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		newInstaller()  拼装path: "Prefix/Group/Version"</span></span><br><span class="line"><span class="comment">		然后填充并返回一个APIInstaller对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	installer := g.newInstaller()</span><br><span class="line">	<span class="comment">// 创建一个WebService，设置了ws的path属性</span></span><br><span class="line">	ws := installer.NewWebService()</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*********************************************</span></span><br><span class="line"><span class="comment">		*********************************************</span></span><br><span class="line"><span class="comment">		调用Install函数</span></span><br><span class="line"><span class="comment">		这个是关键，会对各种URL进行注册！</span></span><br><span class="line"><span class="comment">		在这个注册的过程中，InstallREST最终调用了registerResourceHandlers()接口，</span></span><br><span class="line"><span class="comment">		registerResourceHandlers()接口最终会把一个rest.Storage对象转换成实际的getter、lister等处理函数，</span></span><br><span class="line"><span class="comment">		并和实际的URL关联起来。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	apiResources, registrationErrors := installer.Install(ws)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		一个list功能的API</span></span><br><span class="line"><span class="comment">		添加了一个Route，对应路径是"/"</span></span><br><span class="line"><span class="comment">		访问形如"Prefix/Group/Version"这样的根路径时候，返回该GroupVersion所支持的resources</span></span><br><span class="line"><span class="comment">	    curl http://192.168.56.101:8080/api/v1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	lister := g.ResourceLister</span><br><span class="line">	<span class="keyword">if</span> lister == <span class="literal">nil</span> &#123;</span><br><span class="line">		lister = staticLister&#123;apiResources&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	AddSupportedResourcesWebService(g.Serializer, ws, g.GroupVersion, lister)</span><br><span class="line">	<span class="comment">// 将该WebService加入到Container</span></span><br><span class="line">	container.Add(ws)</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(registrationErrors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InstallAPIs()</code>进行/apis的安装</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallAPIs</span><span class="params">(apiResourceConfigSource genericapiserver.APIResourceConfigSource, restOptionsGetter genericapiserver.RESTOptionsGetter, restStorageProviders ...genericapiserver.RESTStorageProvider)</span></span> &#123;</span><br><span class="line">	apiGroupsInfo := []genericapiserver.APIGroupInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, restStorageBuilder := <span class="keyword">range</span> restStorageProviders &#123;</span><br><span class="line">		groupName := restStorageBuilder.GroupName()</span><br><span class="line">		<span class="keyword">if</span> !apiResourceConfigSource.AnyResourcesForGroupEnabled(groupName) &#123;</span><br><span class="line">			glog.V(<span class="number">1</span>).Infof(<span class="string">"Skipping disabled API group %q."</span>, groupName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		apiGroupInfo, enabled := restStorageBuilder.NewRESTStorage(apiResourceConfigSource, restOptionsGetter)</span><br><span class="line">		<span class="keyword">if</span> !enabled &#123;</span><br><span class="line">			glog.Warningf(<span class="string">"Problem initializing API group %q, skipping."</span>, groupName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		glog.V(<span class="number">1</span>).Infof(<span class="string">"Enabling API group %q."</span>, groupName)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> postHookProvider, ok := restStorageBuilder.(genericapiserver.PostStartHookProvider); ok &#123;</span><br><span class="line">			name, hook, err := postHookProvider.PostStartHook()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				glog.Fatalf(<span class="string">"Error building PostStartHook: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := m.GenericAPIServer.AddPostStartHook(name, hook); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				glog.Fatalf(<span class="string">"Error registering PostStartHook %q: %v"</span>, name, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		apiGroupsInfo = <span class="built_in">append</span>(apiGroupsInfo, apiGroupInfo)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> apiGroupsInfo &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			调用func (s *GenericAPIServer) InstallAPIGroup(apiGroupInfo *APIGroupInfo)</span></span><br><span class="line"><span class="comment">			==&gt;定义在/pkg/genericapiserver/genericapiserver.go</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> err := m.GenericAPIServer.InstallAPIGroup(&amp;apiGroupsInfo[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			glog.Fatalf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s, err := c.Config.GenericConfig.SkipComplete().New()</code>会根据config创建了一个<code>GenericAPIServer</code>实例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.Serializer == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Genericapiserver.New() called with config.Serializer == nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := &amp;GenericAPIServer&#123;</span><br><span class="line">		discoveryAddresses:     c.DiscoveryAddresses,</span><br><span class="line">		LoopbackClientConfig:   c.LoopbackClientConfig,</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			c.LegacyAPIGroupPrefixes值是/api，取值于</span></span><br><span class="line"><span class="comment">				==&gt;/pkg/genericapiserver/config.go</span></span><br><span class="line"><span class="comment">					==&gt;DefaultLegacyAPIPrefix = "/api"</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		legacyAPIGroupPrefixes: c.LegacyAPIGroupPrefixes,</span><br><span class="line">		admissionControl:       c.AdmissionControl,</span><br><span class="line">		requestContextMapper:   c.RequestContextMapper,</span><br><span class="line">		Serializer:             c.Serializer,</span><br><span class="line"></span><br><span class="line">		minRequestTimeout:    time.Duration(c.MinRequestTimeout) * time.Second,</span><br><span class="line">		enableSwaggerSupport: c.EnableSwaggerSupport,</span><br><span class="line"></span><br><span class="line">		SecureServingInfo:   c.SecureServingInfo,</span><br><span class="line">		InsecureServingInfo: c.InsecureServingInfo,</span><br><span class="line">		ExternalAddress:     c.ExternalAddress,</span><br><span class="line"></span><br><span class="line">		apiGroupsForDiscovery: <span class="keyword">map</span>[<span class="keyword">string</span>]unversioned.APIGroup&#123;&#125;,</span><br><span class="line"></span><br><span class="line">		enableOpenAPISupport: c.EnableOpenAPISupport,</span><br><span class="line">		openAPIConfig:        c.OpenAPIConfig,</span><br><span class="line"></span><br><span class="line">		postStartHooks: <span class="keyword">map</span>[<span class="keyword">string</span>]postStartHookEntry&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		这里进行了HandlerContainer的初始化</span></span><br><span class="line"><span class="comment">		NewAPIContainer定义在/pkg/genericapiserver/mux/container.go</span></span><br><span class="line"><span class="comment">			==&gt;func NewAPIContainer(mux *http.ServeMux, s runtime.NegotiatedSerializer) *APIContainer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		传进去的两个参数：</span></span><br><span class="line"><span class="comment">				http.NewServeMux()新建了一个http的ServeMux;</span></span><br><span class="line"><span class="comment">				c.Serializer则是实现了编解码序列化反序列化的对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s.HandlerContainer = mux.NewAPIContainer(http.NewServeMux(), c.Serializer)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		上面Container已创建并且也进行了初始化。该轮到WebService了，添加了WebService</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s.installAPI(c.Config)</span><br><span class="line"></span><br><span class="line">	s.Handler, s.InsecureHandler = c.BuildHandlerChainsFunc(s.HandlerContainer.ServeMux, c.Config)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个初始化流程：</p>
<ol>
<li><code>initial.go</code>中的初始化主要用<code>internal version</code>和<code>external versions</code>填充了<code>Scheme</code>，完成了 <code>APIRegistrationManager</code>中<code>GroupMeta</code>的初始化。<code>GroupMeta</code>的主要用于后面的初始化<code>APIGroupVersion</code></li>
<li>初始化<code>groupMeta</code>的时候会根据<code>Scheme</code>和<code>externalVersions</code>新建一个<code>RESTMapper</code></li>
<li><code>/pkg/registry/core/rest/storage_core.go</code>中的<code>NewLegacyRESTStorage</code>基于上面的<code>Scheme</code>和<code>GroupMeta</code>生成了一个<code>APIGroupInfo</code></li>
<li>然后基于<code>APIGroupInfo</code>生成一个<code>APIGroupVersion</code></li>
<li>基于<code>APIGroupVersion</code>来生成<code>Restful API</code></li>
</ol>
<p>多版本资源的初始化调用图</p>
<p><img alt="init" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_init.png"></p>
<p>资源注册成RESTful API调用图</p>
<p><img alt="restful api" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/restfulapi_new.png"></p>
<h2 id="kube-apiserver端List-Watch机制"><a href="#kube-apiserver端List-Watch机制" class="headerlink" title="kube-apiserver端List-Watch机制"></a>kube-apiserver端List-Watch机制</h2><p>apiserver针对集群中的每一类资源都会与etcd建立一个连接，获取该资源的opt，watch功能是其中一个opt。kubelet、kube-controller-manager、kube-scheduler需要监控各种资源的变化， 当这些对象发生变化时(add、delete、update)，kube-apiserver能够主动通知这些组件。而apiserver端的Watch机制是建立在etcd的Watch基础上的。 etcd的watch是没有过滤功能的，而kube-apiserver增加了过滤功能，能将订阅方感兴趣的部分资源发给订阅方。</p>
<p>Event数据流向如下：</p>
<ol>
<li>从etcd—&gt;Cacher，是一个watchCache，存储apiserver从etcd那里watch到的对象。</li>
<li>结合etcd和Cacher的resourceVersion进行对比，形成一个WatchEvent，分发到各个观察者watcher中</li>
</ol>
<p>在<code>/pkg/storage/cacher.go</code>中的<code>func NewCacherFromConfig()</code>，用来创建一个新的cacher，负责服务内部的watch-list缓存请求，并在后台更新缓存，流程如下：</p>
<ol>
<li>新建一个watchCache，用来存储apiserver从etcd那里watch到的对象</li>
<li>新建一个listerWatcher</li>
<li>实例化一个type Cacher struct对象，其核心是reflector机制</li>
<li>启动dispatchEvents协程，分发event到各个订阅方</li>
<li>cacher.startCaching(stopCh)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacherFromConfig</span><span class="params">(config CacherConfig)</span> *<span class="title">Cacher</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		新建一个watchCache，用来存储apiserver从etcd那里watch到的对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	watchCache := newWatchCache(config.CacheCapacity, config.KeyFunc)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		对config.Storage进行list和watch</span></span><br><span class="line"><span class="comment">		config.Storage是数据源（可以简单理解为etcd、带cache的etcd），一个资源的etcd handler</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	listerWatcher := newCacherListerWatcher(config.Storage, config.ResourcePrefix, config.NewListFunc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Give this error when it is constructed rather than when you get the</span></span><br><span class="line">	<span class="comment">// first watch item, because it's much easier to track down that way.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		译：在构造时给出错误，而不是在第一次去watch该item时。因为这种方式更容易跟踪。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		编码器进行类型检查</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> obj, ok := config.Type.(runtime.Object); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> err := runtime.CheckCodec(config.Codec, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"storage codec doesn't seem to match given type: "</span> + err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Cacher接口必然也实现了storage.Interface接口所需要的方法。</span></span><br><span class="line"><span class="comment">		因为该Cacher只用于WATCH和LIST的request，</span></span><br><span class="line"><span class="comment">		所以可以看下cacher提供的API,除了WATCH和LIST相关的之外的接口都是调用了之前创建的storage的API。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		四个重要的成员：storage、watchCache、reflector、watchers</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cacher := &amp;Cacher&#123;</span><br><span class="line">		ready: newReady(),</span><br><span class="line">		<span class="comment">//config.Storage就是和etcd建立连接后返回该资源的handler</span></span><br><span class="line">		storage:    config.Storage,</span><br><span class="line">		objectType: reflect.TypeOf(config.Type),</span><br><span class="line">		<span class="comment">//watchCache用来存储apiserver从etcd那里watch到的对象</span></span><br><span class="line">		watchCache: watchCache,</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			reflector这个对象，包含两个重要的数据成员listerWatcher和watchCache,</span></span><br><span class="line"><span class="comment">			而listerWatcher包装了config.Storage，会对storage进行list和watch。</span></span><br><span class="line"><span class="comment">			reflector工作主要是将watch到的config.Type类型的对象存放到watcherCache中。</span></span><br><span class="line"><span class="comment">			==&gt;定义在/pkg/client/cache/reflector.go</span></span><br><span class="line"><span class="comment">				==&gt;func NewReflector</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		reflector: cache.NewReflector(listerWatcher, config.Type, watchCache, <span class="number">0</span>),</span><br><span class="line">		<span class="comment">//Versioner控制resource的版本</span></span><br><span class="line">		versioner:   config.Versioner,</span><br><span class="line">		triggerFunc: config.TriggerPublisherFunc,</span><br><span class="line">		watcherIdx:  <span class="number">0</span>,</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			allWatchers、valueWatchers 都是一个map，map的值类型为cacheWatcher，</span></span><br><span class="line"><span class="comment">			当kubelet、kube-scheduler需要watch某类资源时，</span></span><br><span class="line"><span class="comment">			他们会向kube-apiserver发起watch请求，kube-apiserver就会生成一个cacheWatcher，</span></span><br><span class="line"><span class="comment">			他们负责将watch的资源通过http从apiserver传递到kubelet、kube-scheduler</span></span><br><span class="line"><span class="comment">				==&gt;event分发功能是在下面的 go cacher.dispatchEvents()中完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			watcher是kube-apiserver watch的发布方和订阅方的枢纽</span></span><br><span class="line"><span class="comment">			watchers是在哪里注册添加成员的？？?</span></span><br><span class="line"><span class="comment">				==&gt;func newCacheWatcher(resourceVersion uint64, chanSize int, initEvents []watchCacheEvent, filter filterObjectFunc, forget func(bool)) *cacheWatcher &#123;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		watchers: indexedWatchers&#123;</span><br><span class="line">			allWatchers:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*cacheWatcher),</span><br><span class="line">			valueWatchers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]watchersMap),</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Figure out the correct value for the buffer size.</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			incoming会被分发到 watchers中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			这个要和/pkg/storage/etcd/etcd_watcher.go中的channel etcdIncoming进行区分，两者不是一个通道</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		incoming: <span class="built_in">make</span>(<span class="keyword">chan</span> watchCacheEvent, <span class="number">100</span>),</span><br><span class="line">		<span class="comment">// We need to (potentially) stop both:</span></span><br><span class="line">		<span class="comment">// - wait.Until go-routine</span></span><br><span class="line">		<span class="comment">// - reflector.ListAndWatch</span></span><br><span class="line">		<span class="comment">// and there are no guarantees on the order that they will stop.</span></span><br><span class="line">		<span class="comment">// So we will be simply closing the channel, and synchronizing on the WaitGroup.</span></span><br><span class="line">		stopCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		设置watchCache的onEvent这个handler。</span></span><br><span class="line"><span class="comment">		cacher.processEvent是incoming chan watchCacheEvent的生产者</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	watchCache.SetOnEvent(cacher.processEvent)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		完成event分发功能，把event分发到对应的watchers中。</span></span><br><span class="line"><span class="comment">		是incoming chan watchCacheEvent的消费者</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">go</span> cacher.dispatchEvents()</span><br><span class="line"></span><br><span class="line">	stopCh := cacher.stopCh</span><br><span class="line">	cacher.stopWg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> cacher.stopWg.Done()</span><br><span class="line">		wait.Until(</span><br><span class="line">			<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !cacher.isStopped() &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">						apiserver端，list-watch机制 V1.0</span></span><br><span class="line"><span class="comment">					*/</span></span><br><span class="line">					cacher.startCaching(stopCh)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, time.Second, stopCh,</span><br><span class="line">		)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> cacher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startCaching()</code>方法流程如下：</p>
<ol>
<li>首先会通过terminateAllWatchers注销所有的cachewatcher,因为这个时候apiserver还处于初始化阶段，因此不可能接受其他组件的watch，也就不可能有watcher。</li>
<li>然后调用c.reflector.ListAndWatch函数，完成前面说过的功能：reflector主要将apiserver组件从etcd中watch到的资源存储到watchCache中。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">startCaching</span><span class="params">(stopChannel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// The 'usable' lock is always 'RLock'able when it is safe to use the cache.</span></span><br><span class="line">	<span class="comment">// It is safe to use the cache after a successful list until a disconnection.</span></span><br><span class="line">	<span class="comment">// We start with usable (write) locked. The below OnReplace function will</span></span><br><span class="line">	<span class="comment">// unlock it after a successful list. The below defer will then re-lock</span></span><br><span class="line">	<span class="comment">// it when this function exits (always due to disconnection), only if</span></span><br><span class="line">	<span class="comment">// we actually got a successful list. This cycle will repeat as needed.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		在连接中断之前，在一个成功的lis操作之后使用cache是读写安全的</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	successfulList := <span class="literal">false</span></span><br><span class="line">	c.watchCache.SetOnReplace(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		successfulList = <span class="literal">true</span></span><br><span class="line">		c.ready.set(<span class="literal">true</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> successfulList &#123;</span><br><span class="line">			c.ready.set(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//终止所有的watcher</span></span><br><span class="line">	c.terminateAllWatchers()</span><br><span class="line">	<span class="comment">// Note that since onReplace may be not called due to errors, we explicitly</span></span><br><span class="line">	<span class="comment">// need to retry it on errors under lock.</span></span><br><span class="line">	<span class="comment">// Also note that startCaching is called in a loop, so there's no need</span></span><br><span class="line">	<span class="comment">// to have another loop here.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		apiserver端，list-watch机制</span></span><br><span class="line"><span class="comment">		func (c *Cacher) startCaching已经是在一个循环中被调用，所以这里不再有循环</span></span><br><span class="line"><span class="comment">		ListAndWatch(stopChannel)定义在/pkg/client/cache/reflector.go</span></span><br><span class="line"><span class="comment">			==&gt;func (r *Reflector) ListAndWatch(stopCh &lt;-chan struct&#123;&#125;) error</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> err := c.reflector.ListAndWatch(stopChannel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		glog.Errorf(<span class="string">"unexpected ListAndWatch error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Reflector的<code>ListAndWatch()</code></p>
<p>分析其流程，如下：</p>
<ol>
<li>执行list操作</li>
<li>执行watch操作</li>
<li>调用<code>func (r *Reflector) watchHandler</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	译：func (r *Reflector) ListAndWatch 首先会list所有的items，得到resource version；</span></span><br><span class="line"><span class="comment">		然后使用该resource version去watch。</span></span><br><span class="line"><span class="comment">		如果ListAndWatch没有尝试去初始化watch，返回error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	注意func (r *Reflector) ListAndWatch函数会被apiserver和kubelet等多个组件复用。</span></span><br><span class="line"><span class="comment">	区别： apiserver去watch etcd，而kubelet去watch apiserver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line">	<span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line">	resyncCh, cleanup := r.resyncChan()</span><br><span class="line">	<span class="keyword">defer</span> cleanup()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line">	<span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line">	<span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		译：明确把resource version设置为"0"---这样子是适用于对cache进行 List()操作的，虽然可能会造成内容相对于</span></span><br><span class="line"><span class="comment">			etcd中的数据有所延迟。</span></span><br><span class="line"><span class="comment">		   Reflector框架是通过Watch()操作来追赶上来。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	options := api.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		apiserver端，list-watch机制 V3.0 ，List操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		用resource version＝"0"来进行list操作，</span></span><br><span class="line"><span class="comment">		r.listerWatcher.List定义在/pkg/storage/cacher.go</span></span><br><span class="line"><span class="comment">			==&gt;func (lw *cacherListerWatcher) List(options api.ListOptions)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	list, err := r.listerWatcher.List(options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		获取该类型的List接口，定义在</span></span><br><span class="line"><span class="comment">		==&gt;/pkg/api/meta/meta.go</span></span><br><span class="line"><span class="comment">			==&gt;func ListAccessor(obj interface&#123;&#125;) (List, error)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">	&#125;</span><br><span class="line">	resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">	items, err := meta.ExtractList(list)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line"></span><br><span class="line">	resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">	cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">			<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line">			<span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				resyncerrc &lt;- err</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			cleanup()</span><br><span class="line">			resyncCh, cleanup = r.resyncChan()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">		options = api.ListOptions&#123;</span><br><span class="line">			ResourceVersion: resourceVersion,</span><br><span class="line">			<span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">			<span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">			TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			apiserver端，list-watch机制 V3.0 ，Watch操作</span></span><br><span class="line"><span class="comment">			定义在/pkg/storage/cacher.go</span></span><br><span class="line"><span class="comment">			==&gt;func (lw *cacherListerWatcher) Watch(options api.ListOptions) (watch.Interface, error)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			生成一个watcher，该watcher实现了watch.Interface（用接口来让kubelet、apiserver复用该接口）</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		w, err := r.listerWatcher.Watch(options)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> err &#123;</span><br><span class="line">			<span class="keyword">case</span> io.EOF:</span><br><span class="line">				<span class="comment">// watch closed normally</span></span><br><span class="line">			<span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">				glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line">			<span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line">			<span class="comment">// watch where we ended.</span></span><br><span class="line">			<span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line">			<span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line">				<span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line">					<span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">						time.Sleep(time.Second)</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			apiserver端，list-watch机制 V4.0</span></span><br><span class="line"><span class="comment">			把上面生成的watcher w传进去</span></span><br><span class="line"><span class="comment">			调用func (r *Reflector) watchHandler</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">				glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>list, err := r.listerWatcher.List(options)</code>和<code>w, err := r.listerWatcher.Watch(options)</code>，真正调用的是etcdHelper的list watch方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *cacherListerWatcher)</span> <span class="title">List</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	list := lw.newListFunc()</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		调用storage的List方法，定义在</span></span><br><span class="line"><span class="comment">		==&gt;/pkg/storage/etcd/etcd_helper.go</span></span><br><span class="line"><span class="comment">			==&gt;func (h *etcdHelper) List(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate, listObj runtime.Object) error</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> err := lw.storage.List(context.TODO(), lw.resourcePrefix, <span class="string">""</span>, Everything, list); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implements cache.ListerWatcher interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *cacherListerWatcher)</span> <span class="title">Watch</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		调用storage的WatchList方法，定义在</span></span><br><span class="line"><span class="comment">		==&gt;/pkg/storage/etcd/etcd_helper.go</span></span><br><span class="line"><span class="comment">			==&gt;func (h *etcdHelper) WatchList(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> lw.storage.WatchList(context.TODO(), lw.resourcePrefix, options.ResourceVersion, Everything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>err := r.watchHandler</code>是将event对象从channel outgoing中读取出来，而方法中调用的<code>r.store.Add(event.Object)</code>则是将event添加到cache中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	object, resourceVersion, err := objectToVersionedRuntimeObject(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		把入口参数object重新包装成event</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	event := watch.Event&#123;Type: watch.Added, Object: object&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		定义函数面值f， w.store.Add(elem)定义在是pkg/client/cache/store.go</span></span><br><span class="line"><span class="comment">			==&gt;func (c *cache) Add(obj interface&#123;&#125;) error</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(elem *storeElement)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> w.store.Add(elem) &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		调用func (w *watchCache) processEvent</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> w.processEvent(event, resourceVersion, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的<code>processEvent()</code>方法最终完成了Event从etcd流向Cache。</p>
<p>以上是完成了event的生产过程，最终event都要流向消费它的订阅方，在上面的代码中<code>dispatchEvents()</code>就是那个分发event的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvents</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			type Cacher struct的channel incoming的消费者</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-c.incoming:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.dispatchEvent(&amp;event)</span><br><span class="line">		<span class="keyword">case</span> &lt;-c.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用<code>dispatchEvent()</code>方法，将event分发给所有的watcher</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		获取event中的value、前一个event的value</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	triggerValues, supported := c.triggerValues(event)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> For now we assume we have a given &lt;timeout&gt; budget for dispatching</span></span><br><span class="line">	<span class="comment">// a single event. We should consider changing to the approach with:</span></span><br><span class="line">	<span class="comment">// - budget has upper bound at &lt;max_timeout&gt;</span></span><br><span class="line">	<span class="comment">// - we add &lt;portion&gt; to current timeout every second</span></span><br><span class="line">	timeout := time.Duration(<span class="number">250</span>) * time.Millisecond</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   RWMutex提供了四个方法：</span></span><br><span class="line"><span class="comment">	   func (*RWMutex) Lock  写锁定</span></span><br><span class="line"><span class="comment">	   func (*RWMutex) Unlock  写解锁</span></span><br><span class="line"><span class="comment">	   func (*RWMutex) RLock  读锁定</span></span><br><span class="line"><span class="comment">	   func (*RWMutex) RUnlock  读解锁</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">	<span class="comment">// Iterate over "allWatchers" no matter what the trigger function is.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		对Cacher中的watchers.allWatchers进行遍历，</span></span><br><span class="line"><span class="comment">		把event 发送到所有的watcher中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.allWatchers &#123;</span><br><span class="line">		watcher.add(event, &amp;timeout)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> supported &#123;</span><br><span class="line">		<span class="comment">// Iterate over watchers interested in the given values of the trigger.</span></span><br><span class="line">		<span class="keyword">for</span> _, triggerValue := <span class="keyword">range</span> triggerValues &#123;</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.valueWatchers[triggerValue] &#123;</span><br><span class="line">				watcher.add(event, &amp;timeout)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// supported equal to false generally means that trigger function</span></span><br><span class="line">		<span class="comment">// is not defined (or not aware of any indexes). In this case,</span></span><br><span class="line">		<span class="comment">// watchers filters should generally also don't generate any</span></span><br><span class="line">		<span class="comment">// trigger values, but can cause problems in case of some</span></span><br><span class="line">		<span class="comment">// misconfiguration. Thus we paranoidly leave this branch.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Iterate over watchers interested in exact values for all values.</span></span><br><span class="line">		<span class="keyword">for</span> _, watchers := <span class="keyword">range</span> c.watchers.valueWatchers &#123;</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> watchers &#123;</span><br><span class="line">				watcher.add(event, &amp;timeout)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>watcher.add(event, &amp;timeout)</code>方法，把event分发到一个<code>type cacheWatcher struct</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">add</span><span class="params">(event *watchCacheEvent, timeout *time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Try to send the event immediately, without blocking.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		channel取不到值时，走default通道，就是select语句结束，继续执行后续部分</span></span><br><span class="line"><span class="comment">		如果取到值，直接return</span></span><br><span class="line"><span class="comment">		这里完成event的分发，channel input的生产者，</span></span><br><span class="line"><span class="comment">		其对应的消费者在type cacheWatcher struct</span></span><br><span class="line"><span class="comment">		==&gt;/pkg/storage/cacher.go</span></span><br><span class="line"><span class="comment">			==&gt;func newCacheWatcher</span></span><br><span class="line"><span class="comment">				==&gt;func (c *cacheWatcher) process(initEvents []watchCacheEvent, resourceVersion uint64)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c.input &lt;- *event:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// OK, block sending, but only for up to &lt;timeout&gt;.</span></span><br><span class="line">	<span class="comment">// cacheWatcher.add is called very often, so arrange</span></span><br><span class="line">	<span class="comment">// to reuse timers instead of constantly allocating.</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		func (c *cacheWatcher) add会很频繁地被调用，设置了一个定时器</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	startTime := time.Now()</span><br><span class="line"></span><br><span class="line">	t, ok := timerPool.Get().(*time.Timer)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		t.Reset(*timeout)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t = time.NewTimer(*timeout)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> timerPool.Put(t)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c.input &lt;- *event:</span><br><span class="line">		stopped := t.Stop()</span><br><span class="line">		<span class="keyword">if</span> !stopped &#123;</span><br><span class="line">			<span class="comment">// Consume triggered (but not yet received) timer event</span></span><br><span class="line">			<span class="comment">// so that future reuse does not get a spurious timeout.</span></span><br><span class="line">			&lt;-t.C</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">		<span class="comment">// This means that we couldn't send event to that watcher.</span></span><br><span class="line">		<span class="comment">// Since we don't want to block on it infinitely,</span></span><br><span class="line">		<span class="comment">// we simply terminate it.</span></span><br><span class="line">		c.forget(<span class="literal">false</span>)</span><br><span class="line">		c.stop()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> *timeout = *timeout - time.Since(startTime); *timeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">		*timeout = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里Event已经分发到了各个订阅者的watcher中了，后续各个Watcher组件会从channel input中获取到event</p>
<p>kube-apiserver初始化时，建立对etcd的连接，并对etcd进行watch，将watch的结果存入watchCache。 当其他组件需要watch资源时，其他组件向apiserver发送一个watch请求，这个请求是可以带filter函数的。 apiserver针对这个请求会创建一个watcher，并基于watcher创建WatchServer。 watchCache watch的对象，首先会通过filter函数的过滤，假如过滤通过的话，则会通过WatcherServer发送给订阅组件。</p>
<p>整个list-watch过程的调用链</p>
<p><img alt="list-watch" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/list_watch.png"></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/d3e0e7a2/" rel="bookmark">【Kubernetes解读】Scheduler</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/d8b96fe4/" rel="bookmark">【Kubernetes解读】开篇</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/83a17de0/" rel="bookmark">【Kubernetes解读】Scheduling Framework</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/4744ce1d/" rel="bookmark">【Go语言设计与实现】Context</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/b130e91a/" rel="bookmark">【Kubernetes解读】调度策略</a></div>
    </li>
  </ul>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/theme/wechatpay.png" alt="Houmin 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/theme/alipay.jpg" alt="Houmin 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Houmin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://houmin.cc/posts/3bc1a603/" title="【Kubernetes解读】ApiServer之初识API">http://houmin.cc/posts/3bc1a603/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" rel="tag"><i class="fa fa-tag"></i> 源码解读</a>
              <a href="/tags/k8s/" rel="tag"><i class="fa fa-tag"></i> k8s</a>
              <a href="/tags/go/" rel="tag"><i class="fa fa-tag"></i> go</a>
              <a href="/tags/apiserver/" rel="tag"><i class="fa fa-tag"></i> apiserver</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/b130e91a/" rel="next" title="【Kubernetes解读】调度策略">
                  <i class="fa fa-chevron-left"></i> 【Kubernetes解读】调度策略
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/47d0d3b/" rel="prev" title="所谓生活">
                  所谓生活 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#API-Overview"><span class="nav-number">1.</span> <span class="nav-text">API Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Terminology"><span class="nav-number">1.1.</span> <span class="nav-text">Terminology</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kind"><span class="nav-number">1.1.1.</span> <span class="nav-text">Kind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Group"><span class="nav-number">1.1.2.</span> <span class="nav-text">Group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Version"><span class="nav-number">1.1.3.</span> <span class="nav-text">Version</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Resource"><span class="nav-number">1.1.4.</span> <span class="nav-text">Resource</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GVK-GVR"><span class="nav-number">1.2.</span> <span class="nav-text">GVK/GVR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API-Request-Flow"><span class="nav-number">2.</span> <span class="nav-text">API Request Flow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-Chain"><span class="nav-number">3.</span> <span class="nav-text">Handler Chain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构图"><span class="nav-number">5.</span> <span class="nav-text">架构图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kube-apiserver-中的组件"><span class="nav-number">6.</span> <span class="nav-text">kube-apiserver 中的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Aggregator"><span class="nav-number">6.1.</span> <span class="nav-text">Aggregator</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#启用-API-Aggregation"><span class="nav-number">6.1.0.1.</span> <span class="nav-text">启用 API Aggregation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KubeAPIServer"><span class="nav-number">6.2.</span> <span class="nav-text">KubeAPIServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#APIExtensionServer"><span class="nav-number">6.3.</span> <span class="nav-text">APIExtensionServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kube-apiserver-启动流程分析"><span class="nav-number">6.4.</span> <span class="nav-text">kube-apiserver 启动流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Run"><span class="nav-number">6.4.1.</span> <span class="nav-text">Run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CreateServerChain"><span class="nav-number">6.4.2.</span> <span class="nav-text">CreateServerChain</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CreateKubeAPIServerConfig"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">CreateKubeAPIServerConfig</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#buildGenericConfig"><span class="nav-number">6.4.2.2.</span> <span class="nav-text">buildGenericConfig</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#createAPIExtensionsServer"><span class="nav-number">6.4.2.3.</span> <span class="nav-text">createAPIExtensionsServer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CreateKubeAPIServer"><span class="nav-number">6.4.2.4.</span> <span class="nav-text">CreateKubeAPIServer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kubeAPIServerConfig-Complete-New"><span class="nav-number">6.4.2.5.</span> <span class="nav-text">kubeAPIServerConfig.Complete().New</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#m-InstallLegacyAPI"><span class="nav-number">6.4.2.6.</span> <span class="nav-text">m.InstallLegacyAPI</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createAggregatorServer"><span class="nav-number">6.4.3.</span> <span class="nav-text">createAggregatorServer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#aggregatorConfig-Complete-NewWithDelegate"><span class="nav-number">6.4.3.1.</span> <span class="nav-text">aggregatorConfig.Complete().NewWithDelegate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prepared-Run"><span class="nav-number">6.4.4.</span> <span class="nav-text">prepared.Run</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#s-NonBlockingRun"><span class="nav-number">6.4.4.1.</span> <span class="nav-text">s.NonBlockingRun</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#storageFactory-的构建"><span class="nav-number">6.5.</span> <span class="nav-text">storageFactory 的构建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NewLegacyRESTStorage"><span class="nav-number">6.5.1.</span> <span class="nav-text">NewLegacyRESTStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#podstore-NewStorage"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">podstore.NewStorage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#store-CompleteWithOptions"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">store.CompleteWithOptions</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#newETCD3Storage"><span class="nav-number">6.5.1.2.1.</span> <span class="nav-text">newETCD3Storage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由注册"><span class="nav-number">6.5.2.</span> <span class="nav-text">路由注册</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-registerResourceHandlers"><span class="nav-number">6.5.2.1.</span> <span class="nav-text">a.registerResourceHandlers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#restfulCreateNamedResource"><span class="nav-number">6.5.2.2.</span> <span class="nav-text">restfulCreateNamedResource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#createHandler"><span class="nav-number">6.5.2.3.</span> <span class="nav-text">createHandler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.6.</span> <span class="nav-text">总结</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#启动流程"><span class="nav-number">7.</span> <span class="nav-text">启动流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键数据结构"><span class="nav-number">8.</span> <span class="nav-text">关键数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-APIRegistrationManager-struct"><span class="nav-number">8.1.</span> <span class="nav-text">type APIRegistrationManager struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-GroupVersion-struct"><span class="nav-number">8.2.</span> <span class="nav-text">type GroupVersion struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-GroupMeta-struct"><span class="nav-number">8.3.</span> <span class="nav-text">type GroupMeta struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-RESTMapper-interface"><span class="nav-number">8.4.</span> <span class="nav-text">type RESTMapper interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GroupVersionKind-GroupVersionResource-GroupKind"><span class="nav-number">8.5.</span> <span class="nav-text">GroupVersionKind GroupVersionResource GroupKind</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Resource-1"><span class="nav-number">8.5.1.</span> <span class="nav-text">Resource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kind-1"><span class="nav-number">8.5.2.</span> <span class="nav-text">Kind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Group-Version"><span class="nav-number">8.5.3.</span> <span class="nav-text">Group Version</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-RESTMapping-struct"><span class="nav-number">8.6.</span> <span class="nav-text">type RESTMapping struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-RESTScope-interface"><span class="nav-number">8.7.</span> <span class="nav-text">type RESTScope interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-ObjectConvertor-interface"><span class="nav-number">8.8.</span> <span class="nav-text">type ObjectConvertor interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-MetadataAccessor-interface"><span class="nav-number">8.9.</span> <span class="nav-text">type MetadataAccessor interface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多版本资源注册"><span class="nav-number">9.</span> <span class="nav-text">多版本资源注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化流程"><span class="nav-number">9.1.</span> <span class="nav-text">初始化流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kube-apiserver端List-Watch机制"><span class="nav-number">10.</span> <span class="nav-text">kube-apiserver端List-Watch机制</span></a></li></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Houmin" src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/theme/avatar.png">
  <p class="site-author-name" itemprop="name">Houmin</p>
  <div class="site-description" itemprop="description">丈夫拥书万卷，何假南面百城</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SimpCosm" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SimpCosm" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weihoumin@gmail.com" title="E-Mail &amp;rarr; mailto:weihoumin@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="hitokoto">
    <!-- hitokoto -->
    <div id="hito-expression">:D 获取中...</div>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
      fetch('https://v1.hitokoto.cn')
        .then(function (res){
          return res.json();
        })
        .then(function (data) {
          var hitokoto = document.getElementById('hito-expression');
          hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
        })
        .catch(function (err) {
          console.error(err);
        })
    </script>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houmin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">649k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">19:39</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>



  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '800px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'iEBFuhVyk4tuhVYctQ265uid-gzGzoHsz',
    appKey: 'KGjOktrtgSEWK1v9DYA3T3Az',
    placeholder: "Just go go",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
