<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Houmin" type="application/atom+xml">
  <meta name="google-site-verification" content="zdGhdEF7jHoJW58lsdN6l9JrQFjJFwakCIc7TbbosV0">
  <meta name="msvalidate.01" content="2F527B379ED5537861D0D38C2C754C2B">
  <meta name="baidu-site-verification" content="xAag2PqzKE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 range 和 select 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以本节就不会再次介绍了。作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高">
<meta name="keywords" content="Go,源码阅读,并发,channel">
<meta property="og:type" content="article">
<meta property="og:title" content="【Go语言设计与实现】Channel">
<meta property="og:url" content="http://houmin.cc/posts/93e1c454/index.html">
<meta property="og:site_name" content="Houmin">
<meta property="og:description" content="本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 range 和 select 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以本节就不会再次介绍了。作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487042-shared-memory.png">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487080-channel-and-goroutines.png">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487089-concurrency-control.png">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-02-07_go-channel-direct-send.png">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487104-channel-buffer-send.png">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487111-channel-receive-node.png">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487118-channel-receive-from-sendq.png">
<meta property="og:image" content="https://img.draveness.me/2020-01-28-15802171487125-channel-buffer-receive.png">
<meta property="og:updated_time" content="2021-02-07T11:32:17.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.draveness.me/2020-01-28-15802171487042-shared-memory.png">

<link rel="canonical" href="http://houmin.cc/posts/93e1c454/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>【Go语言设计与实现】Channel | Houmin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="/js/photoswipe.min.js?v="></script>
  <script src="/js/photoswipe-ui-default.min.js?v="></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Houmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Yesterday You Said Tomorrow</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-album">

    <a href="/album" rel="section"><i class="fa fa-fw fa-camera"></i>相册</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://houmin.cc/posts/93e1c454/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
      <meta itemprop="name" content="Houmin">
      <meta itemprop="description" content="丈夫拥书万卷，何假南面百城">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Houmin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          【Go语言设计与实现】Channel
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-06 12:19:21" itemprop="dateCreated datePublished" datetime="2020-05-06T12:19:21+08:00">2020-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/" itemprop="url" rel="index">
                    <span itemprop="name">术业专攻</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/93e1c454/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/93e1c454/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本节会介绍管道 Channel 的设计原理、数据结构和常见操作，例如 Channel 的创建、发送、接收和关闭。虽然 Channel 与关键字 <code>range</code> 和 <code>select</code> 的关系紧密，但是因为在前面的两节中已经分析了 Channel 在不同的控制结构中组合使用时的现象，所以本节就不会再次介绍了。作为 Go 核心的数据结构和 Goroutine 之间的通信方式，Channel 是支撑 Go 语言高性能并发编程模型的重要结构，我们首先需要了解 Channel 背后的设计原理以及它的底层数据结构。</p>
<a id="more"></a>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>Go 语言中最常见的、也是经常被人提及的设计模式就是 — 不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程冲突的问题，我们需要限制同一时间能够读写这些变量的线程数量，这与 Go 语言鼓励的方式并不相同。</p>
<p><img alt="shared-memory" data-src="https://img.draveness.me/2020-01-28-15802171487042-shared-memory.png"></p>
<p>虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，也就是通信顺序进程（Communicating sequential processes，CSP）<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。</p>
<p><img alt="channel-and-goroutines" data-src="https://img.draveness.me/2020-01-28-15802171487080-channel-and-goroutines.png"></p>
<p>上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。</p>
<h3 id="先入先出"><a href="#先入先出" class="headerlink" title="先入先出"></a>先入先出</h3><p>目前的 Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：</p>
<ul>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据；</li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；</li>
</ul>
<p>这种 FIFO 的设计是相对好理解的，但是 Go 语言稍早版本的实现却不是严格遵循这一语义的，<a href="https://github.com/golang/go/issues/11506" target="_blank" rel="external nofollow noopener noreferrer">runtime: make sure blocked channels run operations in FIFO order</a> 中提出了有缓冲区的 Channel 在执行收发操作时没有遵循 FIFO 的规则<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>。</p>
<ul>
<li>发送方会向缓冲区中写入数据，然后唤醒接收方，多个接收方会尝试从缓冲区中读取数据，如果没有读取到就会重新陷入休眠；</li>
<li>接收方会从缓冲区中读取数据，然后唤醒发送方，发送方会尝试向缓冲区写入数据，如果缓冲区已满就会重新陷入休眠；</li>
</ul>
<p>这种基于重试的机制会导致 Channel 的处理不会遵循 FIFO 的原则。经过 <a href="https://github.com/golang/go/commit/8e496f1d6923172291658f0a785bdb47cc152325" target="_blank" rel="external nofollow noopener noreferrer">runtime: simplify buffered channels</a> 和 <a href="https://github.com/golang/go/commit/e410a527b208e0a9acd0cded3775b302d8f2b00a" target="_blank" rel="external nofollow noopener noreferrer">runtime: simplify chan ops, take 2</a> 两个提交的修改，带缓冲区和不带缓冲区的 Channel 都会遵循先入先出对数据进行接收和发送<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a> <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a>。</p>
<h3 id="无锁管道"><a href="#无锁管道" class="headerlink" title="无锁管道"></a>无锁管道</h3><p>锁是一种常见的并发控制技术，我们一般会将锁分成乐观锁和悲观锁，即乐观并发控制和悲观并发控制，无锁（lock-free）队列更准确的描述是使用乐观并发控制的队列。乐观并发控制也叫乐观锁，但是它并不是真正的锁，很多人都会误以为乐观锁是一种真正的锁，然而它只是一种并发控制的思想<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:5" target="_blank" rel="external nofollow noopener noreferrer">5</a>。</p>
<p><img alt="concurrency-control" data-src="https://img.draveness.me/2020-01-28-15802171487089-concurrency-control.png"></p>
<p>乐观并发控制本质上是基于验证的协议，我们使用原子指令 CAS（compare-and-swap 或者 compare-and-set）在多线程中同步数据，无锁队列的实现也依赖这一原子指令。</p>
<p>Channel 在运行时的内部表示是 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a>，该结构体中包含了一个用于保护成员变量的互斥锁，从某种程度上说，Channel 是一个用于同步和通信的有锁队列。使用互斥锁解决程序中可能存在的线程竞争问题是很常见的，我们能很容易地实现有锁队列。</p>
<p>然而锁导致的休眠和唤醒会带来额外的上下文切换，如果临界区<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:6" target="_blank" rel="external nofollow noopener noreferrer">6</a>过小，加锁解锁导致的额外开销就会成为性能瓶颈。1994 年的论文 <a href="http://people.cs.pitt.edu/~jacklange/teaching/cs2510-f12/papers/implementing_lock_free.pdf" target="_blank" rel="external nofollow noopener noreferrer">Implementing lock-free queues</a> 就研究了如何使用无锁的数据结构实现先进先出队列<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:7" target="_blank" rel="external nofollow noopener noreferrer">7</a>，而 Go 语言社区也在 2014 年提出了无锁 Channel 的实现方案，该方案将 Channel 分成了以下三种类型<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:8" target="_blank" rel="external nofollow noopener noreferrer">8</a>：</p>
<ul>
<li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方；</li>
<li>异步 Channel — 基于环形缓存的传统生产者消费者模型；</li>
<li><code>chan struct{}</code> 类型的异步 Channel — <code>struct{}</code> 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义；</li>
</ul>
<p>这个提案的目的也不是实现完全无锁的队列，只是在一些关键路径上通过无锁提升 Channel 的性能。社区中已经有无锁 Channel 的实现<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:9" target="_blank" rel="external nofollow noopener noreferrer">9</a>，但是在实际的基准测试中，无锁队列在多核测试中的表现还需要进一步的改进<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:10" target="_blank" rel="external nofollow noopener noreferrer">10</a>。</p>
<p>因为目前通过 CAS 实现<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:11" target="_blank" rel="external nofollow noopener noreferrer">11</a>的无锁 Channel 没有提供 FIFO 的特性，所以该提案暂时也被搁浅了<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:12" target="_blank" rel="external nofollow noopener noreferrer">12</a>。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Go 语言的 Channel 在运行时使用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 结构体表示。我们在 Go 语言中创建新的 Channel 时，实际上创建的都是如下所示的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">	sendx    <span class="keyword">uint</span>  </span><br><span class="line">	recvx    <span class="keyword">uint</span></span><br><span class="line">	recvq    waitq</span><br><span class="line">	sendq    waitq</span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 结构体中的五个字段 <code>qcount</code>、<code>dataqsiz</code>、<code>buf</code>、<code>sendx</code>、<code>recv</code> 构建底层的循环队列：</p>
<ul>
<li><code>qcount</code> — Channel 中的元素个数；</li>
<li><code>dataqsiz</code> — Channel 中的循环队列的长度；</li>
<li><code>buf</code> — Channel 的缓冲区数据指针；</li>
<li><code>sendx</code> — Channel 的发送操作处理到的位置；</li>
<li><code>recvx</code> — Channel 的接收操作处理到的位置；</li>
</ul>
<p>除此之外，<code>elemsize</code> 和 <code>elemtype</code> 分别表示当前 Channel 能够收发的元素类型和大小；<code>sendq</code> 和 <code>recvq</code> 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L53" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.waitq</code></a> 表示，链表中所有的元素都是 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 表示一个在等待列表中的 Goroutine，该结构体中存储了阻塞的相关信息以及两个分别指向前后 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 的指针。</p>
<h2 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h2><p>Go 语言中所有 Channel 的创建都会使用 <code>make</code> 关键字。编译器会将 <code>make(chan int, 10)</code> 表达式被转换成 <code>OMAKE</code> 类型的节点，并在类型检查阶段将 <code>OMAKE</code> 类型的节点转换成 <code>OMAKECHAN</code> 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OMAKE:</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">		<span class="keyword">case</span> TCHAN:</span><br><span class="line">			l = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123; <span class="comment">// 带缓冲区的异步 Channel</span></span><br><span class="line">				...</span><br><span class="line">				n.Left = l</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不带缓冲区的同步 Channel</span></span><br><span class="line">				n.Left = nodintconst(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			n.Op = OMAKECHAN</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一阶段会对传入 <code>make</code> 关键字的缓冲区大小进行检查，如果我们不向 <code>make</code> 传递表示缓冲区大小的参数，那么就会设置一个默认值 0，也就是当前的 Channel 不存在缓冲区。</p>
<p><code>OMAKECHAN</code> 类型的节点最终都会在 SSA 中间代码生成阶段之前被转换成调用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L71" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makechan</code></a> 或者 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L63" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makechan64</code></a> 的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OMAKECHAN:</span><br><span class="line">		size := n.Left</span><br><span class="line">		fnname := <span class="string">"makechan64"</span></span><br><span class="line">		argtype := types.Types[TINT64]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> size.Type.IsKind(TIDEAL) || maxintval[size.Type.Etype].Cmp(maxintval[TUINT]) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			fnname = <span class="string">"makechan"</span></span><br><span class="line">			argtype = types.Types[TINT]</span><br><span class="line">		&#125;</span><br><span class="line">		n = mkcall1(chanfn(fnname, <span class="number">1</span>, n.Type), n.Type, init, typename(n.Type), conv(size, argtype))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L71" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makechan</code></a> 和 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L63" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makechan64</code></a> 会根据传入的参数类型和缓冲区大小创建一个新的 Channel 结构，其中后者用于处理缓冲区大小大于 2 的 32 次方的情况，我们重点关注 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L71" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makechan</code></a> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line">	mem, _ := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = c.raceaddr()</span><br><span class="line">	<span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码根据 Channel 中收发元素的类型和缓冲区的大小初始化 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 结构体和缓冲区：</p>
<ul>
<li>如果当前 Channel 中不存在缓冲区，那么就只会为 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 分配一段内存空间；</li>
<li>如果当前 Channel 中存储的类型不是指针类型，就会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li>
<li>在默认情况下会单独为 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 和缓冲区分配内存；</li>
</ul>
<p>在函数的最后会统一更新 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L32" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 的 <code>elemsize</code>、<code>elemtype</code> 和 <code>dataqsiz</code> 几个字段。</p>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>当我们想要向 Channel 发送数据时，就需要使用 <code>ch &lt;- i</code> 语句，编译器会将它解析成 <code>OSEND</code> 节点并在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中转换成 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L126" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend1</code></a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OSEND:</span><br><span class="line">		n1 := n.Right</span><br><span class="line">		n1 = assignconv(n1, n.Left.Type.Elem(), <span class="string">"chan send"</span>)</span><br><span class="line">		n1 = walkexpr(n1, init)</span><br><span class="line">		n1 = nod(OADDR, n1, <span class="literal">nil</span>)</span><br><span class="line">		n = mkcall1(chanfn(<span class="string">"chansend1"</span>, <span class="number">2</span>, n.Left.Type), <span class="literal">nil</span>, init, n.Left, n1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L126" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend1</code></a> 只是调用了 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 并传入 Channel 和需要发送的数据。<a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 是向 Channel 中发送数据时最终会调用的函数，这个函数负责了发送数据的全部逻辑，如果我们在调用时将 <code>block</code> 参数设置成 <code>true</code>，那么就表示当前发送操作是一个阻塞操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止发生竞争条件。如果 Channel 已经关闭，那么向该 Channel 发送数据时就会报<code>&quot;send on closed channel&quot;</code> 错误并中止程序。</p>
<p>因为 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 函数的实现比较复杂，所以我们这里将该函数的执行过程分成以下的三个部分：</p>
<ul>
<li>当存在等待的接收者时，通过 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L270" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.send</code></a> 直接将数据发送给阻塞的接收者；</li>
<li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li>
<li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li>
</ul>
<h3 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L142" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 函数会从接收队列 <code>recvq</code> 中取出最先陷入等待的 Goroutine 并直接向它发送数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">	send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图展示了 Channel 中存在等待数据的 Goroutine 时，向 Channel 发送数据的过程：</p>
<p><img alt="直接发送数据的过程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-02-07_go-channel-direct-send.png"></p>
<p>发送数据时会调用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L270" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.send</code></a>，该函数的执行可以分成两个部分：</p>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L313" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sendDirect</code></a> 函数将发送的数据直接拷贝到 <code>x = &lt;-c</code> 表达式中变量 <code>x</code> 所在的内存地址上；</li>
<li>调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L313" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goready</code></a> 将等待接收数据的 Goroutine 标记成可运行状态 <code>Grunnable</code> 并把该 Goroutine 放到发送方所在的处理器的 <code>runnext</code> 上等待执行，该处理器在下一次调度时就会立刻唤醒数据的接收方；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，发送数据的过程只是将接收方的 Goroutine 放到了处理器的 <code>runnext</code> 中，程序没有立刻执行该 Goroutine。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>如果创建的 Channel 包含缓冲区并且 Channel 中的数据没有装满，就会执行下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们首先会使用 <code>chanbuf</code> 计算出下一个可以存储数据的位置，然后通过 <a href="https://github.com/golang/go/blob/db16de920370892b0241d3fa0617dddff2417a4d/src/runtime/mbarrier.go#L156" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.typedmemmove</code></a> 将发送的数据拷贝到缓冲区中并增加 <code>sendx</code> 索引和 <code>qcount</code> 计数器。</p>
<p><img alt="channel-buffer-send" data-src="https://img.draveness.me/2020-01-28-15802171487104-channel-buffer-send.png"></p>
<p><strong>图 6-21 向缓冲区写入数据</strong></p>
<p>如果当前 Channel 的缓冲区未满，向 Channel 发送的数据会存储在 Channel 中 <code>sendx</code> 索引所在的位置并将 <code>sendx</code> 索引加一，由于这里的 <code>buf</code> 是一个循环数组，所以当 <code>sendx</code> 等于 <code>dataqsiz</code> 时就会重新回到数组开始的位置。</p>
<h3 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h3><p>当 Channel 没有接收者能够处理数据时，向 Channel 发送数据就会被下游阻塞，当然使用 <code>select</code> 关键字可以向 Channel 非阻塞地发送消息。向 Channel 阻塞地发送数据会执行下面的代码，我们可以简单梳理一下这段代码的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/stubs.go#L18" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.getg</code></a> 获取发送数据使用的 Goroutine；</li>
<li>执行 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L320" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.acquireSudog</code></a> 函数获取 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体并设置这一次阻塞发送的相关信息，例如发送的 Channel、是否在 Select 控制结构中和待发送数据的内存地址等；</li>
<li>将刚刚创建并初始化的 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 加入发送等待队列，并设置到当前 Goroutine 的 <code>waiting</code> 上，表示 Goroutine 正在等待该 <code>sudog</code> 准备就绪；</li>
<li>调用 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goparkunlock</code></a> 函数将当前的 Goroutine 陷入沉睡等待唤醒；</li>
<li>被调度器唤醒后会执行一些收尾工作，将一些属性置零并且释放 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体；</li>
</ol>
<p>在最后，函数会返回 <code>true</code> 表示这向 Channel 发送数据的结束。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p>
<ol>
<li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 <code>sendx</code> 所在的位置上；</li>
<li>如果不满足上面的两种情况，就会创建一个 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li>
</ol>
<p>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</p>
<ol>
<li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</li>
<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时就会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goparkunlock</code></a> 触发 Goroutine 的调度让出处理器的使用权；</li>
</ol>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>我们接下来继续介绍 Channel 操作的另一方 — 数据的接收。Go 语言中可以使用两种不同的方式去接收 Channel 中的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i &lt;- ch</span><br><span class="line">i, ok &lt;- ch</span><br></pre></td></tr></table></figure>
<p>这两种不同的方法经过编译器的处理都会变成 <code>ORECV</code> 类型的节点，后者会在类型检查阶段被转换成 <code>OAS2RECV</code> 类型。数据的接收操作遵循以下的路线图：</p>
<p><img alt="channel-receive-node" data-src="https://img.draveness.me/2020-01-28-15802171487111-channel-receive-node.png"></p>
<p><strong>图 6-22 Channel 接收操作的路线图</strong></p>
<p>虽然不同的接收方式会被转换成 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L406" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv1</code></a> 和 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv2</code></a> 两种不同函数的调用，但是这两个函数最终还是会调用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L422" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a>。</p>
<p>当我们从一个空 Channel 接收数据时会直接调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L287" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 直接让出处理器的使用权。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前 Channel 已经被关闭并且缓冲区中不存在任何的数据，那么就会清除 <code>ep</code> 指针中的数据并立刻返回。</p>
<p>除了上述两种特殊情况，使用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L422" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 从 Channel 接收数据时还包含以下三种不同情况：</p>
<ul>
<li>当存在等待的发送者时，通过 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L556" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recv</code></a> 直接从阻塞的发送者或者缓冲区中获取数据；</li>
<li>当缓冲区存在数据时，从 Channel 的缓冲区中接收数据；</li>
<li>当缓冲区中不存在数据时，等待其他 Goroutine 向 Channel 发送数据；</li>
</ul>
<h3 id="直接接收"><a href="#直接接收" class="headerlink" title="直接接收"></a>直接接收</h3><p>当 Channel 的 <code>sendq</code> 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几，只是发送数据时调用的是 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L270" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.send</code></a> 函数，而接收数据时使用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L556" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recv</code></a> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">	recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L556" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recv</code></a> 函数的实现比较复杂：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		c.recvx++</span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := sg.g</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会根据缓冲区的大小分别处理不同的情况：</p>
<ul>
<li>如果 Channel 不存在缓冲区；<ol>
<li>调用 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L326" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recvDirect</code></a> 函数会将 Channel 发送队列中 Goroutine 存储的 <code>elem</code> 数据拷贝到目标内存地址中；</li>
</ol>
</li>
<li>如果 Channel 存在缓冲区；<ol>
<li>将队列中的数据拷贝到接收方的内存地址；</li>
<li>将发送队列头的数据拷贝到缓冲区中，释放一个阻塞的发送方；</li>
</ol>
</li>
</ul>
<p>无论发生哪种情况，运行时都会调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L313" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goready</code></a> 函数将当前处理器的 <code>runnext</code> 设置成发送数据的 Goroutine，在调度器下一次调度时将阻塞的发送方唤醒。</p>
<p><img alt="channel-receive-from-sendq" data-src="https://img.draveness.me/2020-01-28-15802171487118-channel-receive-from-sendq.png"></p>
<p><strong>图 6-23 从发送队列中获取数据</strong></p>
<p>上图展示了 Channel 在缓冲区已经没有空间并且发送队列中存在等待的 Goroutine 时，运行 <code>&lt;-ch</code> 的执行过程 — 发送队列头的 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构中的元素会替换接收索引 <code>recvx</code> 所在位置的元素，原有的元素会被拷贝到接收数据的变量的内存空间上。</p>
<h3 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>当Channel 的缓冲区中已经包含数据时，从 Channel 中接收数据会直接从缓冲区中 <code>recvx</code> 的索引位置中取出数据进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果接收数据的内存地址不为空，那么就会直接使用 <a href="https://github.com/golang/go/blob/db16de920370892b0241d3fa0617dddff2417a4d/src/runtime/mbarrier.go#L156" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.typedmemmove</code></a> 将缓冲区中的数据拷贝到内存中、清除队列中的数据并完成收尾工作。</p>
<p><img alt="channel-buffer-receive" data-src="https://img.draveness.me/2020-01-28-15802171487125-channel-buffer-receive.png"></p>
<p><strong>图 6-24 从缓冲区中接接收数据</strong></p>
<p>收尾工作包括递增 <code>recvx</code>，一旦发现索引超过了 Channel 的容量时，就会将它归零（循环队列）；除此之外，这个函数还会减少 <code>qcount</code> 计数器并释放持有 Channel 的锁。</p>
<h3 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h3><p>当 Channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞操作，然而不是所有的接收操作都是阻塞的，与 <code>select</code> 语句结合使用时就可能会使用到非阻塞的接收操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.c = c</span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在正常的接收场景中，我们会使用 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体将当前 Goroutine 包装成一个处于等待状态的 Goroutine 并将其加入到接收队列中。</p>
<p>完成入队之后，上述代码还会调用 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goparkunlock</code></a> 函数立刻触发 Goroutine 的调度，让出处理器的使用权并等待调度器的调度。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我们梳理一下从 Channel 中接收数据时可能会发生的五种情况：</p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L287" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，<a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L422" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 函数会直接返回；</li>
<li>如果 Channel 的 <code>sendq</code> 队列中存在挂起的 Goroutine，就会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code>sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 <code>recvx</code> 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 <a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/runtime2.go#L342" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构加入 <code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>我们总结一下从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：</p>
<ol>
<li>当 Channel 为空时；</li>
<li>当缓冲区中不存在数据并且也不存在数据的发送者时；</li>
</ol>
<h2 id="关闭管道"><a href="#关闭管道" class="headerlink" title="关闭管道"></a>关闭管道</h2><p>编译器会将用于关闭管道的 <code>close</code> 关键字转换成 <code>OCLOSE</code> 节点以及 <a href="https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L335" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.closechan</code></a> 的函数调用。</p>
<p>当 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接 <code>panic</code> 并抛出异常：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>处理完了这些异常的情况之后就可以开始执行关闭 Channel 的逻辑了，下面这段代码的主要工作就是将 <code>recvq</code> 和 <code>sendq</code> 两个队列中的数据加入到 Goroutine 列表 <code>gList</code> 中，与此同时该函数会清除所有 <code>sudog</code> 上未被处理的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist gList</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">		gp := glist.pop()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数在最后会为所有被阻塞的 Goroutine 调用 <a href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L313" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goready</code></a> 触发调度。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>Channel 是 Go 语言能够提供强大并发能力的原因之一，我们在这一节中分析了 Channel 的设计原理、数据结构以及发送数据、接收数据和关闭 Channel 这些基本操作，相信能够帮助大家更好地理解 Channel 的工作原理。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://github.com/golang/go/issues/8899" target="_blank" rel="external nofollow noopener noreferrer">Dmitry Vyukov. Oct, 2014.“runtime: lock-free channels”</a></li>
<li><a href="https://doi.org/10.1145/248052.248106" target="_blank" rel="external nofollow noopener noreferrer">Simple, fast, and practical non-blocking and blocking concurrent queue algorithms</a></li>
<li><a href="https://golang.org/ref/spec#Channel_types" target="_blank" rel="external nofollow noopener noreferrer">Channel types · The Go Programming Language Specification</a></li>
<li><a href="http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/" target="_blank" rel="external nofollow noopener noreferrer">Concurrency in Golang</a></li>
<li><a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="external nofollow noopener noreferrer">Communicating sequential processes</a></li>
<li><a href="https://golang.org/doc/faq#csp" target="_blank" rel="external nofollow noopener noreferrer">Why build concurrency on the ideas of CSP?</a></li>
<li><a href="https://dave.cheney.net/2015/08/08/performance-without-the-event-loop" target="_blank" rel="external nofollow noopener noreferrer">Performance without the event loop</a></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/77ffac6b/" rel="bookmark">【Go语言设计与实现】同步原语</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/8e2bf8a2/" rel="bookmark">【Go语言设计与实现】Go Scheduler</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/e87a4e07/" rel="bookmark">【Go语言设计与实现】String</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/44c65087/" rel="bookmark">【Go语言设计与实现】循环</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/540e2781/" rel="bookmark">【Go语言设计与实现】Defer</a></div>
    </li>
  </ul>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/wechatpay.png" alt="Houmin 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/alipay.jpg" alt="Houmin 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Houmin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://houmin.cc/posts/93e1c454/" title="【Go语言设计与实现】Channel">http://houmin.cc/posts/93e1c454/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag"><i class="fa fa-tag"></i> 源码阅读</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
              <a href="/tags/channel/" rel="tag"><i class="fa fa-tag"></i> channel</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/77ffac6b/" rel="next" title="【Go语言设计与实现】同步原语">
                  <i class="fa fa-chevron-left"></i> 【Go语言设计与实现】同步原语
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/8e2bf8a2/" rel="prev" title="【Go语言设计与实现】Go Scheduler">
                  【Go语言设计与实现】Go Scheduler <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计原理"><span class="nav-number">1.</span> <span class="nav-text">设计原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先入先出"><span class="nav-number">1.1.</span> <span class="nav-text">先入先出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无锁管道"><span class="nav-number">1.2.</span> <span class="nav-text">无锁管道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建管道"><span class="nav-number">3.</span> <span class="nav-text">创建管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送数据"><span class="nav-number">4.</span> <span class="nav-text">发送数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直接发送"><span class="nav-number">4.1.</span> <span class="nav-text">直接发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区"><span class="nav-number">4.2.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞发送"><span class="nav-number">4.3.</span> <span class="nav-text">阻塞发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">4.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接收数据"><span class="nav-number">5.</span> <span class="nav-text">接收数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直接接收"><span class="nav-number">5.1.</span> <span class="nav-text">直接接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区-1"><span class="nav-number">5.2.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞接收"><span class="nav-number">5.3.</span> <span class="nav-text">阻塞接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">5.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭管道"><span class="nav-number">6.</span> <span class="nav-text">关闭管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-2"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展阅读"><span class="nav-number">8.</span> <span class="nav-text">扩展阅读</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Houmin" src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
  <p class="site-author-name" itemprop="name">Houmin</p>
  <div class="site-description" itemprop="description">丈夫拥书万卷，何假南面百城</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">170</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">230</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SimpCosm" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SimpCosm" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weihoumin@gmail.com" title="E-Mail &amp;rarr; mailto:weihoumin@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="hitokoto">
    <!-- hitokoto -->
    <div id="hito-expression">:D 获取中...</div>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
      fetch('https://v1.hitokoto.cn')
        .then(function (res){
          return res.json();
        })
        .then(function (data) {
          var hitokoto = document.getElementById('hito-expression');
          hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
        })
        .catch(function (err) {
          console.error(err);
        })
    </script>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houmin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">2.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">65:25</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>



  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '800px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'iEBFuhVyk4tuhVYctQ265uid-gzGzoHsz',
    appKey: 'KGjOktrtgSEWK1v9DYA3T3Az',
    placeholder: "Just go go",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
