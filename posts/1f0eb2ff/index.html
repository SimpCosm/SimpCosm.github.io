<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Houmin" type="application/atom+xml">
  <meta name="google-site-verification" content="zdGhdEF7jHoJW58lsdN6l9JrQFjJFwakCIc7TbbosV0">
  <meta name="msvalidate.01" content="2F527B379ED5537861D0D38C2C754C2B">
  <meta name="baidu-site-verification" content="xAag2PqzKE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List&#x2F;Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。">
<meta name="keywords" content="k8s,informer,watch,消息机制,异步">
<meta property="og:type" content="article">
<meta property="og:title" content="【Kubernetes】List&#x2F;Watch机制和Informer模块详解">
<meta property="og:url" content="http://houmin.cc/posts/1f0eb2ff/index.html">
<meta property="og:site_name" content="Houmin">
<meta property="og:description" content="Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List&#x2F;Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-20_client-go-controller-interaction.jpeg">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737350162-8e7c6121-2b0a-49fa-8ad8-a7b714de3445.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737386982-feae09ae-ac6d-4090-8ca2-d2f3f5120d61.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737435884-518fce5a-0118-4935-be61-0716e2c3ba0c.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737496494-8a3052e1-7837-46d9-9513-8d3a64ffe8ba.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737549651-a3636652-fc91-49e1-a91e-9f5e18b05672.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737669393-995cf89c-87f6-4749-9086-b9febee3a692.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737745807-e10d9521-5633-4cf7-9a0f-90ce2a3dee46.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737835151-715cdc2b-b53a-4208-85d8-2383fdef8b8f.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738078512-ade28ada-2824-46d3-af63-45873a8a37a4.png">
<meta property="og:image" content="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738429252-bd646701-8543-47cd-a638-552ac419f5c9.png">
<meta property="og:image" content="https://static001.geekbang.org/wechat/images/a1/a1a5745f0c0309c9d05c484905887fb8.jpeg">
<meta property="og:updated_time" content="2020-11-30T11:12:08.458Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png">

<link rel="canonical" href="http://houmin.cc/posts/1f0eb2ff/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>【Kubernetes】List/Watch机制和Informer模块详解 | Houmin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="/js/photoswipe.min.js?v="></script>
  <script src="/js/photoswipe-ui-default.min.js?v="></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Houmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Yesterday You Said Tomorrow</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-album">

    <a href="/album" rel="section"><i class="fa fa-fw fa-camera"></i>相册</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://houmin.cc/posts/1f0eb2ff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
      <meta itemprop="name" content="Houmin">
      <meta itemprop="description" content="丈夫拥书万卷，何假南面百城">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Houmin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          【Kubernetes】List/Watch机制和Informer模块详解
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-21 15:46:29" itemprop="dateCreated datePublished" datetime="2020-09-21T15:46:29+08:00">2020-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/" itemprop="url" rel="index">
                    <span itemprop="name">术业专攻</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/1f0eb2ff/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/1f0eb2ff/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:26</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。</p>
<a id="more"></a>
<h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>Kubernetes中的组件，如果要访问Kubernetes中的Object，绝大部分情况下会使用Informer中的Lister()方法，而非直接请求Kubernetes API。</p>
<h1 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h1><p><img alt="img" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png"></p>
<p><img alt="Client-go Controller Interaction" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p>
<h2 id="client-go组件"><a href="#client-go组件" class="headerlink" title="client-go组件"></a>client-go组件</h2><ul>
<li><code>Reflector</code>：reflector用来watch特定的k8s API资源。具体的实现是通过<code>ListAndWatch</code>的方法，watch可以是k8s内建的资源或者是自定义的资源。当reflector通过watch API接收到有关新资源实例存在的通知时，它使用相应的列表API获取新创建的对象，并将其放入watchHandler函数内的Delta Fifo队列中。</li>
<li><code>Informer</code>：informer从Delta Fifo队列中弹出对象。执行此操作的功能是processLoop。base controller的作用是保存对象以供以后检索，并调用我们的控制器将对象传递给它。</li>
<li><code>Indexer</code>：索引器提供对象的索引功能。典型的索引用例是基于对象标签创建索引。 Indexer可以根据多个索引函数维护索引。Indexer使用线程安全的数据存储来存储对象及其键。 在Store中定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数生成对象的键作为该对象的<code>&lt;namespace&gt; / &lt;name&gt;</code>组合。</li>
</ul>
<h2 id="自定义controller组件"><a href="#自定义controller组件" class="headerlink" title="自定义controller组件"></a>自定义controller组件</h2><ul>
<li><code>Informer reference</code>：指的是Informer实例的引用，定义如何使用自定义资源对象。 自定义控制器代码需要创建对应的Informer。</li>
<li><code>Indexer reference</code>: 自定义控制器对Indexer实例的引用。自定义控制器需要创建对应的Indexser。</li>
</ul>
<blockquote>
<p>client-go中提供<code>NewIndexerInformer</code>函数可以创建Informer 和 Indexer。</p>
</blockquote>
<ul>
<li><code>Resource Event Handlers</code>：资源事件回调函数，当它想要将对象传递给控制器时，它将被调用。 编写这些函数的典型模式是获取调度对象的key，并将该key排入工作队列以进行进一步处理。</li>
<li><code>Workqueue</code>：任务队列。 编写资源事件处理程序函数以提取传递的对象的key并将其添加到任务队列。</li>
<li><code>Process Item</code>：处理任务队列中对象的函数， 这些函数通常使用Indexer引用或Listing包装器来重试与该key对应的对象。</li>
</ul>
<h1 id="关键设计"><a href="#关键设计" class="headerlink" title="关键设计"></a>关键设计</h1><p>Informer依赖Kubernetes的List/Watch API。 通过Lister()对象来List/Get对象时，Informer不会去请求Kubernetes API，而是直接查询本地缓存，减少对Kubernetes API的直接调用。</p>
<p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p>
<p>Informer组件：</p>
<ul>
<li>Controller</li>
<li>Reflector：通过Kubernetes Watch API监听resource下的所有事件</li>
<li>Lister：用来被调用List/Get方法</li>
<li>Processor：记录并触发回调函数</li>
<li>DeltaFIFO</li>
<li>LocalStore</li>
</ul>
<p>DeltaFIFO和LocalStore是Informer的两级缓存。 DeltaFIFO：用来存储Watch API返回的各种事件。 LocalStore：Lister的List/Get方法访问。</p>
<p>我们以 Pod 为例，详细说明一下 Informer 的关键逻辑：</p>
<ol>
<li>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</li>
<li>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</li>
<li>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</li>
<li>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</li>
<li>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</li>
<li>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</li>
<li>DeltaFIFO 再 Pop 这个事件到 Controller 中</li>
<li>Controller 收到这个事件，会触发 Processor 的回调函数</li>
</ol>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737350162-8e7c6121-2b0a-49fa-8ad8-a7b714de3445.png"></p>
<p>之前说到kubernetes里面的apiserver的只负责数据的CRUD接口实现，并不负责业务逻辑的处理，所以k8s中就通过外挂controller通过对应资源的控制器来负责事件的处理，controller如何感知事件呢？答案就是informer</p>
<h2 id="基于chunk的消息通知"><a href="#基于chunk的消息通知" class="headerlink" title="基于chunk的消息通知"></a>基于chunk的消息通知</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737386982-feae09ae-ac6d-4090-8ca2-d2f3f5120d61.png"></p>
<p>watcher的设计在之前的文章中已经介绍，服务端是如何将watcher感知到的事件发送给informer呢？我们提到过apiserver本质上就是一个http的rest接口实现，watch机制则也是基于http协议，不过不同于一般的get其通过chunk机制，来实现消息的通知</p>
<h2 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737435884-518fce5a-0118-4935-be61-0716e2c3ba0c.png"></p>
<p>服务端通过chunk进行数据的发送，在客户端同样的需要根据对应的chunk来进行数据的解包，同时还要维护这个长链接</p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737496494-8a3052e1-7837-46d9-9513-8d3a64ffe8ba.png"></p>
<p>通过listwatch接口主要分为两部分，list接口我们可以获取到对应资源当前版本的全量资源，watch接口可以获取到后续变更的资源，通过全量加增量的数据，就构成了在client端一份完整的数据(基于当前版本的)，那后续如果要获取对应的数据，就直接可以通过本地的缓存来进行获取，为此informer抽象了cache这个组件，并且实现了store接口，如果后续要获取资源，则就可以通过本地的缓存来进行获取</p>
<h2 id="本地索引"><a href="#本地索引" class="headerlink" title="本地索引"></a>本地索引</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737549651-a3636652-fc91-49e1-a91e-9f5e18b05672.png"></p>
<p>上面将资源缓存在本地的内存中，那如果我们要进行数据查询，快速检索数据，这个时候就需要用到informer里面的indexer, 我们可以注册不同的索引函数，在添加对象的时候，会通过indexer为其建立对应的索引，这样后续我们就可以通过key来检索获取元数据</p>
<h2 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737669393-995cf89c-87f6-4749-9086-b9febee3a692.png"></p>
<p>为了协调数据生产与消费的不一致状态，在cleint-go中通过实现了一个无界队列来进行数据的缓冲，当reflector获取到数据之后，只需要将数据写入到无界队列中，则就可以继续watch后续事件，从而减少阻塞时间， 下面的事件去重也是在该队列中实现的</p>
<h2 id="事件去重"><a href="#事件去重" class="headerlink" title="事件去重"></a>事件去重</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737745807-e10d9521-5633-4cf7-9a0f-90ce2a3dee46.png"></p>
<p>事件去重是指的，在上面的无界队列中，如果针对某个资源的事件重复被触发，则就只会保留相同事件最后一个事件作为后续处理</p>
<p>到此对于事件接收和数据缓存相关优化就结束了，接下就是处理层的优化</p>
<h2 id="复用连接"><a href="#复用连接" class="headerlink" title="复用连接"></a>复用连接</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737835151-715cdc2b-b53a-4208-85d8-2383fdef8b8f.png"></p>
<p>在k8s中一些控制器可能会关注多种资源，比如Deployment可能会关注Pod和replicaset，replicaSet可能还会关注Pod，为了避免每个控制器都独立的去与apiserver建立链接，k8s中抽象了sharedInformer的概念，即共享的informer, 针对同一资源只建立一个链接</p>
<h2 id="基于观察者模式的注册"><a href="#基于观察者模式的注册" class="headerlink" title="基于观察者模式的注册"></a>基于观察者模式的注册</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738078512-ade28ada-2824-46d3-af63-45873a8a37a4.png"></p>
<p>因为彼此共用informer,但是每个组件的处理逻辑可能各部相同，在informer中通过观察者模式，各个组件可以注册一个EventHandler来实现业务逻辑的注入</p>
<h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738429252-bd646701-8543-47cd-a638-552ac419f5c9.png"></p>
<h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>该部分的代码主要位于<code>client-go</code>这个第三方包中。</p>
<p>此部分的逻辑主要位于<code>/vendor/k8s.io/client-go/tools/cache</code>包中，代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cache</span><br><span class="line">├── controller.go  <span class="comment"># 包含：Config、Run、processLoop、NewInformer、NewIndexerInformer</span></span><br><span class="line">├── delta_fifo.go  <span class="comment"># 包含：NewDeltaFIFO、DeltaFIFO、AddIfNotPresent</span></span><br><span class="line">├── expiration_cache.go</span><br><span class="line">├── expiration_cache_fakes.go</span><br><span class="line">├── fake_custom_store.go</span><br><span class="line">├── fifo.go   <span class="comment"># 包含：Queue、FIFO、NewFIFO</span></span><br><span class="line">├── heap.go</span><br><span class="line">├── index.go    <span class="comment"># 包含：Indexer、MetaNamespaceIndexFunc</span></span><br><span class="line">├── listers.go</span><br><span class="line">├── listwatch.go   <span class="comment"># 包含：ListerWatcher、ListWatch、List、Watch</span></span><br><span class="line">├── mutation_cache.go</span><br><span class="line">├── mutation_detector.go</span><br><span class="line">├── reflector.go   <span class="comment"># 包含：Reflector、NewReflector、Run、ListAndWatch</span></span><br><span class="line">├── reflector_metrics.go</span><br><span class="line">├── shared_informer.go  <span class="comment"># 包含：NewSharedInformer、WaitForCacheSync、Run、HasSynced</span></span><br><span class="line">├── store.go  <span class="comment"># 包含：Store、MetaNamespaceKeyFunc、SplitMetaNamespaceKey</span></span><br><span class="line">├── testing</span><br><span class="line">│   ├── fake_controller_source.go</span><br><span class="line">├── thread_safe_store.go  <span class="comment"># 包含：ThreadSafeStore、threadSafeMap</span></span><br><span class="line">├── undelta_store.go</span><br></pre></td></tr></table></figure>
<h2 id="sharedInformerFactory-Start"><a href="#sharedInformerFactory-Start" class="headerlink" title="sharedInformerFactory.Start"></a>sharedInformerFactory.Start</h2><p>在controller-manager的Run函数部分调用了InformerFactory.Start的方法。</p>
<blockquote>
<p>此部分代码位于/cmd/kube-controller-manager/app/controllermanager.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">        <span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InformerFactory是一个<code>SharedInformerFactory</code>的接口，接口定义如下：</p>
<blockquote>
<p>此部分代码位于vendor/k8s.io/client-go/informers/internalinterfaces/factory_interfaces.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SharedInformerFactory a small interface to allow for adding an informer without an import cycle</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    InformerFor(obj runtime.Object, newFunc NewInformerFunc) cache.SharedIndexInformer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。其中，通过<code>startdInformers</code>这个map用来追踪有哪些Informer已经启动，从而可以让Start方法被多次调用。</p>
<blockquote>
<p>此部分代码位于vendor/k8s.io/client-go/informers/factory.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">        <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">            <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">            f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sharedIndexInformer-Run"><a href="#sharedIndexInformer-Run" class="headerlink" title="sharedIndexInformer.Run"></a>sharedIndexInformer.Run</h2><blockquote>
<p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/shared_informer.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ListerWatcher:    s.listerWatcher,</span><br><span class="line">        ObjectType:       s.objectType,</span><br><span class="line">        FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">        RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">        Process: s.HandleDeltas,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">        s.controller = New(cfg)</span><br><span class="line">        s.controller.(*controller).clock = s.clock</span><br><span class="line">        s.started = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">    processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">        s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">    &#125;()</span><br><span class="line">    s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewDeltaFIFO"><a href="#NewDeltaFIFO" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><p>DeltaFIFO是一个对象变化的存储队列，依据先进先出的原则，process的函数接收该队列的Pop方法的输出对象来处理相关功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br></pre></td></tr></table></figure>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>构造controller的配置文件，构造process，即HandleDeltas，该函数为后面使用到的process函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>调用New(cfg)，构建sharedIndexInformer的controller。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">    s.controller = New(cfg)</span><br><span class="line">    s.controller.(*controller).clock = s.clock</span><br><span class="line">    s.started = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="cacheMutationDetector-Run"><a href="#cacheMutationDetector-Run" class="headerlink" title="cacheMutationDetector.Run"></a>cacheMutationDetector.Run</h3><p>调用s.cacheMutationDetector.Run，检查缓存对象是否变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br></pre></td></tr></table></figure>
<p><strong>defaultCacheMutationDetector.Run</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we DON'T want protection from panics.  If we're running this code, we want to die</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d.CompareObjects()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(d.period):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CompareObjects</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">CompareObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> d.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    altered := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, obj := <span class="keyword">range</span> d.cachedObjs &#123;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(obj.cached, obj.copied) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"CACHE %s[%d] ALTERED!\n%v\n"</span>, d.name, i, diff.ObjectDiff(obj.cached, obj.copied))</span><br><span class="line">            altered = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> altered &#123;</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"cache %s modified"</span>, d.name)</span><br><span class="line">        <span class="keyword">if</span> d.failureFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">            d.failureFunc(msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processor-run"><a href="#processor-run" class="headerlink" title="processor.run"></a>processor.run</h3><p>调用s.processor.run，将调用sharedProcessor.run，会调用Listener.run和Listener.pop,执行处理queue的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.processor.run)</span><br></pre></td></tr></table></figure>
<p><strong>sharedProcessor.Run</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.listenersLock.RLock()</span><br><span class="line">        <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            p.wg.Start(listener.run)</span><br><span class="line">            p.wg.Start(listener.pop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">        <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该部分逻辑待后面分析。</p>
<h3 id="controller-Run"><a href="#controller-Run" class="headerlink" title="controller.Run"></a>controller.Run</h3><p>调用s.controller.Run，构建Reflector，进行对etcd的缓存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">    s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">&#125;()</span><br><span class="line">s.controller.Run(stopCh)</span><br></pre></td></tr></table></figure>
<p>controller.Run</p>
<blockquote>
<p>此部分代码位于/vendor/k8s.io/client-go/tools/cache/controller.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins processing items, and will continue until a value is sent down stopCh.</span></span><br><span class="line"><span class="comment">// It's an error to call Run more than once.</span></span><br><span class="line"><span class="comment">// Run blocks; call via go.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        c.config.Queue.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    r.ShouldResync = c.config.ShouldResync</span><br><span class="line">    r.clock = c.clock</span><br><span class="line"></span><br><span class="line">    c.reflectorMutex.Lock()</span><br><span class="line">    c.reflector = r</span><br><span class="line">    c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line"></span><br><span class="line">    wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建Reflector</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">    c.config.ListerWatcher,</span><br><span class="line">    c.config.ObjectType,</span><br><span class="line">    c.config.Queue,</span><br><span class="line">    c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 运行Reflector</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"><span class="comment">// 执行processLoop</span></span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br></pre></td></tr></table></figure>
<h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><h3 id="Reflector-1"><a href="#Reflector-1" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p>
<p>常用属性说明：</p>
<ul>
<li>expectedType：期望放入缓存store的资源类型。</li>
<li>store：watch的资源对应的本地缓存。</li>
<li>listerWatcher：list和watch的接口。</li>
<li>period：watch的周期，默认为1秒。</li>
<li>resyncPeriod：resync的周期，当非零的时候，会按该周期执行list。</li>
<li>lastSyncResourceVersion：最新一次看到的资源的版本号，主要在watch时候使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflector watches a specified resource and causes all changes to be reflected in the given store.</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">    metrics *reflectorMetrics</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The type of object we expect to place in the store.</span></span><br><span class="line">    expectedType reflect.Type</span><br><span class="line">    <span class="comment">// The destination to sync up with the watch source</span></span><br><span class="line">    store Store</span><br><span class="line">    <span class="comment">// listerWatcher is used to perform lists and watches.</span></span><br><span class="line">    listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// period controls timing between one watch ending and</span></span><br><span class="line">    <span class="comment">// the beginning of the next one.</span></span><br><span class="line">    period       time.Duration</span><br><span class="line">    resyncPeriod time.Duration</span><br><span class="line">    ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// lastSyncResourceVersion is the resource version token last</span></span><br><span class="line">    <span class="comment">// observed when doing a sync with the underlying store</span></span><br><span class="line">    <span class="comment">// it is thread safe, but not synchronized with the underlying store</span></span><br><span class="line">    lastSyncResourceVersion <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">    lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewReflector"><a href="#NewReflector" class="headerlink" title="NewReflector"></a>NewReflector</h3><p>NewReflector主要用来构建Reflector的结构体。</p>
<blockquote>
<p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/reflector.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReflector creates a new Reflector object which will keep the given store up to</span></span><br><span class="line"><span class="comment">// date with the server's contents for the given resource. Reflector promises to</span></span><br><span class="line"><span class="comment">// only put things in the store that have the type of expectedType, unless expectedType</span></span><br><span class="line"><span class="comment">// is nil. If resyncPeriod is non-zero, then lists will be executed after every</span></span><br><span class="line"><span class="comment">// resyncPeriod, so that you can use reflectors to periodically process everything as</span></span><br><span class="line"><span class="comment">// well as incrementally processing the things that change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflectorDisambiguator is used to disambiguate started reflectors.</span></span><br><span class="line"><span class="comment">// initialized to an unstable value to ensure meaning isn't attributed to the suffix.</span></span><br><span class="line"><span class="keyword">var</span> reflectorDisambiguator = <span class="keyword">int64</span>(time.Now().UnixNano() % <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reflector-Run"><a href="#Reflector-Run" class="headerlink" title="Reflector.Run"></a>Reflector.Run</h3><p>Reflector.Run主要执行了<code>ListAndWatch</code>的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span></span><br><span class="line"><span class="comment">// Run will exit when stopCh is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</span><br><span class="line">    wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            utilruntime.HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListAndWatch first lists all items and get the resource version at the moment of call,</span></span><br><span class="line"><span class="comment">// and then use the resource version to watch.</span></span><br><span class="line"><span class="comment">// It returns error if ListAndWatch didn't even try to initialize watch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line">    <span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line">    <span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line">    <span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line">    options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">    r.metrics.numberOfLists.Inc()</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    list, err := r.listerWatcher.List(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.listDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">    items, err := meta.ExtractList(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.numberOfItemsInList.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(items)))</span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将资源的版本号设置为0，然后调用<code>listerWatcher.List(options)</code>，列出所有list的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号设置为0</span></span><br><span class="line">options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line"><span class="comment">// list接口</span></span><br><span class="line">list, err := r.listerWatcher.List(options)</span><br></pre></td></tr></table></figure>
<p>获取资源版本号，并将list的内容提取成对象列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line">resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line"><span class="comment">// 将list的内容提取成对象列表</span></span><br><span class="line">items, err := meta.ExtractList(list)</span><br></pre></td></tr></table></figure>
<p>将list中对象列表的内容和版本号存储到本地的缓存store中，并全量替换已有的store的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.syncWith(items, resourceVersion)</span><br></pre></td></tr></table></figure>
<p>syncWith调用了store的Replace的方法来替换原来store中的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncWith replaces the store's items with the given list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        found = <span class="built_in">append</span>(found, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Store.Replace方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后设置最新的资源版本号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.setLastSyncResourceVersion(resourceVersion)</span><br></pre></td></tr></table></figure>
<p>setLastSyncResourceVersion:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">setLastSyncResourceVersion</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    r.lastSyncResourceVersionMutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.lastSyncResourceVersionMutex.Unlock()</span><br><span class="line">    r.lastSyncResourceVersion = v</span><br><span class="line"></span><br><span class="line">    rv, err := strconv.Atoi(v)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.metrics.lastResourceVersion.Set(<span class="keyword">float64</span>(rv))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="store-Resync"><a href="#store-Resync" class="headerlink" title="store.Resync"></a>store.Resync</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resyncCh, cleanup := r.resyncChan()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cleanup() <span class="comment">// Call the last one written into cleanup</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.ShouldResync == <span class="literal">nil</span> || r.ShouldResync() &#123;</span><br><span class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line">            <span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                resyncerrc &lt;- err</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanup()</span><br><span class="line">        resyncCh, cleanup = r.resyncChan()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.store.Resync()</span><br></pre></td></tr></table></figure>
<p>store的具体对象为<code>DeltaFIFO</code>，即调用DeltaFIFO.Resync</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resync will send a sync event for each item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keys := f.knownObjects.ListKeys()</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">    options = metav1.ListOptions&#123;</span><br><span class="line">        ResourceVersion: resourceVersion,</span><br><span class="line">        <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">        <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">        TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.metrics.numberOfWatches.Inc()</span><br><span class="line">    w, err := r.listerWatcher.Watch(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">        <span class="keyword">case</span> io.EOF:</span><br><span class="line">            <span class="comment">// watch closed normally</span></span><br><span class="line">        <span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">            glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line">        <span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line">        <span class="comment">// watch where we ended.</span></span><br><span class="line">        <span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line">        <span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置watch的超时时间，默认为5分钟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">options = metav1.ListOptions&#123;</span><br><span class="line">    ResourceVersion: resourceVersion,</span><br><span class="line">    <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">    <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">    TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行listerWatcher.Watch(options)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w, err := r.listerWatcher.Watch(options)</span><br></pre></td></tr></table></figure>
<p>执行watchHandler。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh)</span><br></pre></td></tr></table></figure>
<h4 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h4><p>watchHandler主要是通过watch的方式保证当前的资源版本是最新的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    eventCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stopping the watcher should be idempotent and if we return from this function there's no way</span></span><br><span class="line">    <span class="comment">// we're coming back in with the same watch interface.</span></span><br><span class="line">    <span class="keyword">defer</span> w.Stop()</span><br><span class="line">    <span class="comment">// update metrics</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r.metrics.numberOfItemsInWatch.Observe(<span class="keyword">float64</span>(eventCount))</span><br><span class="line">        r.metrics.watchDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span> errorStopRequested</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> event.Type == watch.Error &#123;</span><br><span class="line">                <span class="keyword">return</span> apierrs.FromObject(event.Object)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            meta, err := meta.Accessor(event.Object)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">            <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">            <span class="keyword">case</span> watch.Added:</span><br><span class="line">                err := r.store.Add(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Modified:</span><br><span class="line">                err := r.store.Update(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Deleted:</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">                <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">                <span class="comment">// to change this.</span></span><br><span class="line">                err := r.store.Delete(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">            &#125;</span><br><span class="line">            *resourceVersion = newResourceVersion</span><br><span class="line">            r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">            eventCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchDuration := r.clock.Now().Sub(start)</span><br><span class="line">    <span class="keyword">if</span> watchDuration &lt; <span class="number">1</span>*time.Second &amp;&amp; eventCount == <span class="number">0</span> &#123;</span><br><span class="line">        r.metrics.numberOfShortWatches.Inc()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received"</span>, r.name)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: Watch close - %v total %v items received"</span>, r.name, r.expectedType, eventCount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取watch接口中的事件的channel，来获取事件的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当获得添加、更新、删除的事件时，将对应的对象更新到本地缓存store中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line"><span class="keyword">case</span> watch.Added:</span><br><span class="line">    err := r.store.Add(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Modified:</span><br><span class="line">    err := r.store.Update(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Deleted:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">    <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">    <span class="comment">// to change this.</span></span><br><span class="line">    err := r.store.Delete(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新当前的最新版本号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">*resourceVersion = newResourceVersion</span><br><span class="line">r.setLastSyncResourceVersion(newResourceVersion)</span><br></pre></td></tr></table></figure>
<p>通过对Reflector模块的分析，可以看到多次使用到本地缓存store模块，而store的数据由DeltaFIFO赋值而来，以下针对DeltaFIFO和store做分析。</p>
<h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO由NewDeltaFIFO初始化，并赋值给config.Queue。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewDeltaFIFO-1"><a href="#NewDeltaFIFO-1" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeltaFIFO returns a Store which can be used process changes to items.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// keyFunc is used to figure out what key an object should have. (It's</span></span><br><span class="line"><span class="comment">// exposed in the returned DeltaFIFO's KeyOf() method, with bonus features.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'compressor' may compress as many or as few items as it wants</span></span><br><span class="line"><span class="comment">// (including returning an empty slice), but it should do what it</span></span><br><span class="line"><span class="comment">// does quickly since it is called while the queue is locked.</span></span><br><span class="line"><span class="comment">// 'compressor' may be nil if you don't want any delta compression.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'keyLister' is expected to return a list of keys that the consumer of</span></span><br><span class="line"><span class="comment">// this queue "knows about". It is used to decide which items are missing</span></span><br><span class="line"><span class="comment">// when Replace() is called; 'Deleted' deltas are produced for these items.</span></span><br><span class="line"><span class="comment">// It may be nil if you don't need to detect all deletions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider merging keyLister with this object, tracking a list of</span></span><br><span class="line"><span class="comment">//       "known" keys when Pop() is called. Have to think about how that</span></span><br><span class="line"><span class="comment">//       affects error retrying.</span></span><br><span class="line"><span class="comment">// TODO(lavalamp): I believe there is a possible race only when using an</span></span><br><span class="line"><span class="comment">//                 external known object source that the above TODO would</span></span><br><span class="line"><span class="comment">//                 fix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Also see the comment on DeltaFIFO. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeltaFIFO</span><span class="params">(keyFunc KeyFunc, compressor DeltaCompressor, knownObjects KeyListerGetter)</span> *<span class="title">DeltaFIFO</span></span> &#123;</span><br><span class="line">    f := &amp;DeltaFIFO&#123;</span><br><span class="line">        items:           <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas&#123;&#125;,</span><br><span class="line">        queue:           []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">        keyFunc:         keyFunc,</span><br><span class="line">        deltaCompressor: compressor,</span><br><span class="line">        knownObjects:    knownObjects,</span><br><span class="line">    &#125;</span><br><span class="line">    f.cond.L = &amp;f.lock</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller.Run的部分调用了NewReflector。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewReflector构造函数，将c.config.Queue赋值给Reflector.store的属性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DeltaFIFO-1"><a href="#DeltaFIFO-1" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p>
<p>DeltaFIFO主要用在以下场景：</p>
<ul>
<li>希望对象变更最多处理一次</li>
<li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li>
<li>要处理对象的删除</li>
<li>希望定期重新处理对象</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaFIFO is like FIFO, but allows you to process deletes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO is a producer-consumer queue, where a Reflector is</span></span><br><span class="line"><span class="comment">// intended to be the producer, and the consumer is whatever calls</span></span><br><span class="line"><span class="comment">// the Pop() method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO solves this use case:</span></span><br><span class="line"><span class="comment">//  * You want to process every object change (delta) at most once.</span></span><br><span class="line"><span class="comment">//  * When you process an object, you want to see everything</span></span><br><span class="line"><span class="comment">//    that's happened to it since you last processed it.</span></span><br><span class="line"><span class="comment">//  * You want to process the deletion of objects.</span></span><br><span class="line"><span class="comment">//  * You might want to periodically reprocess objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO's Pop(), Get(), and GetByKey() methods return</span></span><br><span class="line"><span class="comment">// interface&#123;&#125; to satisfy the Store/Queue interfaces, but it</span></span><br><span class="line"><span class="comment">// will always return an object of type Deltas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on threading: If you call Pop() in parallel from multiple</span></span><br><span class="line"><span class="comment">// threads, you could end up with multiple threads processing slightly</span></span><br><span class="line"><span class="comment">// different versions of the same object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on the KeyLister used by the DeltaFIFO: It's main purpose is</span></span><br><span class="line"><span class="comment">// to list keys that are "known", for the purpose of figuring out which</span></span><br><span class="line"><span class="comment">// items have been deleted when Replace() or Delete() are called. The deleted</span></span><br><span class="line"><span class="comment">// object will be included in the DeleteFinalStateUnknown markers. These objects</span></span><br><span class="line"><span class="comment">// could be stale.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may provide a function to compress deltas (e.g., represent a</span></span><br><span class="line"><span class="comment">// series of Updates as a single Update).</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// lock/cond protects access to 'items' and 'queue'.</span></span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    cond sync.Cond</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We depend on the property that items in the set are in</span></span><br><span class="line">    <span class="comment">// the queue and vice versa, and that all Deltas in this</span></span><br><span class="line">    <span class="comment">// map have at least one Delta.</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></span><br><span class="line">    populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">    initialPopulationCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keyFunc is used to make the key used for queued item</span></span><br><span class="line">    <span class="comment">// insertion and retrieval, and should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deltaCompressor tells us how to combine two or more</span></span><br><span class="line">    <span class="comment">// deltas. It may be nil.</span></span><br><span class="line">    deltaCompressor DeltaCompressor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// knownObjects list keys that are "known", for the</span></span><br><span class="line">    <span class="comment">// purpose of figuring out which items have been deleted</span></span><br><span class="line">    <span class="comment">// when Replace() or Delete() is called.</span></span><br><span class="line">    knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indication the queue is closed.</span></span><br><span class="line">    <span class="comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span></span><br><span class="line">    <span class="comment">// Currently, not used to gate any of CRED operations.</span></span><br><span class="line">    closed     <span class="keyword">bool</span></span><br><span class="line">    closedLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queue-amp-Store"><a href="#Queue-amp-Store" class="headerlink" title="Queue &amp; Store"></a>Queue &amp; Store</h3><p>DeltaFIFO的类型是Queue接口，Reflector.store是Store接口，Queue接口是一个存储队列，Process的方法执行Queue.Pop出来的数据对象，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue is exactly like a Store, but has a Pop() method too.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">    Store</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pop blocks until it has something to process.</span></span><br><span class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></span><br><span class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></span><br><span class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></span><br><span class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></span><br><span class="line">    <span class="comment">// returned by Pop back into the queue as long</span></span><br><span class="line">    <span class="comment">// as nothing else (presumably more recent)</span></span><br><span class="line">    <span class="comment">// has since been added.</span></span><br><span class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></span><br><span class="line">    HasSynced() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close queue</span></span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p>
<p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store is a generic object storage interface. Reflector knows how to watch a server</span></span><br><span class="line"><span class="comment">// and update a store. A generic store is provided, which allows Reflector to be used</span></span><br><span class="line"><span class="comment">// as a local caching system, and an LRU store, which allows Reflector to work like a</span></span><br><span class="line"><span class="comment">// queue of items yet to be processed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Store makes no assumptions about stored object identity; it is the responsibility</span></span><br><span class="line"><span class="comment">// of a Store implementation to provide a mechanism to correctly key objects and to</span></span><br><span class="line"><span class="comment">// define the contract for obtaining objects by some arbitrary key type.</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">    GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Replace</code>方法会删除原来store中的内容，并将新增的list的内容存入store中，即完全替换数据。</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache实现了store的接口，而cache的具体实现又是调用<code>ThreadSafeStore</code>接口来实现功能的。</p>
<p>cache的功能主要有以下两点：</p>
<ul>
<li>通过keyFunc计算对象的key</li>
<li>调用ThreadSafeStorage接口的方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache responsibilities are limited to:</span></span><br><span class="line"><span class="comment">//  1. Computing keys for objects via keyFunc</span></span><br><span class="line"><span class="comment">//  2. Invoking methods of a ThreadSafeStorage interface</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">    <span class="comment">// should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ListAndWatch主要用到以下的方法：</p>
<p><strong>cache.Replace</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace will delete the contents of 'c', using instead the given list.</span></span><br><span class="line"><span class="comment">// 'c' takes ownership of the list, you should not reference the list again</span></span><br><span class="line"><span class="comment">// after calling this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Replace</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">        key, err := c.keyFunc(item)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[key] = item</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Replace(items, resourceVersion)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cache.Add</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add inserts an item into the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Add(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cache.Update</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update sets an item in the cache to its updated state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Update</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Update(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cache.Delete</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete removes an item from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Delete</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Delete(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p>cache的具体是调用<code>ThreadSafeStore</code>来实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadSafeStore is an interface that allows concurrent access to a storage backend.</span></span><br><span class="line"><span class="comment">// TL;DR caveats: you must not modify anything returned by Get or List as it will break</span></span><br><span class="line"><span class="comment">// the indexing feature in addition to not being thread safe.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The guarantees of thread safety provided by List/Get are only valid if the caller</span></span><br><span class="line"><span class="comment">// treats returned items as read-only. For example, a pointer inserted in the store</span></span><br><span class="line"><span class="comment">// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`</span></span><br><span class="line"><span class="comment">// on the same key and modify the pointer in a non-thread-safe way. Also note that</span></span><br><span class="line"><span class="comment">// modifying objects stored by the indexers (if any) will *not* automatically lead</span></span><br><span class="line"><span class="comment">// to a re-index. So it's not a good idea to directly modify the objects returned by</span></span><br><span class="line"><span class="comment">// Get/List, in general.</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Update(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">    Get(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Replace(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>)</span><br><span class="line">    Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">    ListIndexFuncValues(name <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>threadSafeMap</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  sync.RWMutex</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">    indexers Indexers</span><br><span class="line">    <span class="comment">// indices maps a name to an Index</span></span><br><span class="line">    indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop"></a>processLoop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在controller.Run方法中会调用processLoop，以下分析<code>processLoop</code>的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processLoop drains the work queue.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span></span><br><span class="line"><span class="comment">// to make sure that we don't end up processing the same object multiple times</span></span><br><span class="line"><span class="comment">// concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span></span><br><span class="line"><span class="comment">// actually exit when the controller is stopped. Or just give up on this stuff</span></span><br><span class="line"><span class="comment">// ever being stoppable. Converting this whole package to use Context would</span></span><br><span class="line"><span class="comment">// also be helpful.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">                <span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">                c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processLoop主要处理任务队列中的任务，其中处理逻辑是调用具体的<code>ProcessFunc</code>函数来实现，核心代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br></pre></td></tr></table></figure>
<h3 id="DeltaFIFO-Pop"><a href="#DeltaFIFO-Pop" class="headerlink" title="DeltaFIFO.Pop"></a>DeltaFIFO.Pop</h3><p>Pop会阻塞住直到队列里面添加了新的对象，如果有多个对象，按照先进先出的原则处理，如果某个对象没有处理成功会重新被加入该队列中。</p>
<p>Pop中会调用具体的process函数来处理对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop blocks until an item is added to the queue, and then returns it.  If</span></span><br><span class="line"><span class="comment">// multiple items are ready, they are returned in the order in which they were</span></span><br><span class="line"><span class="comment">// added/updated. The item is removed from the queue (and the store) before it</span></span><br><span class="line"><span class="comment">// is returned, so if you don't successfully process it, you need to add it back</span></span><br><span class="line"><span class="comment">// with AddIfNotPresent().</span></span><br><span class="line"><span class="comment">// process function is called under lock, so it is safe update data structures</span></span><br><span class="line"><span class="comment">// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc</span></span><br><span class="line"><span class="comment">// may return an instance of ErrRequeue with a nested error to indicate the current</span></span><br><span class="line"><span class="comment">// item should be requeued (equivalent to calling AddIfNotPresent under the lock).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Pop returns a 'Deltas', which has a complete list of all the things</span></span><br><span class="line"><span class="comment">// that happened to the object (deltas) while it was sitting in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">            <span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">            <span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">            <span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        id := f.queue[<span class="number">0</span>]</span><br><span class="line">        f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">        item, ok := f.items[id]</span><br><span class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            f.initialPopulationCount--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        err := process(item)</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">            f.addIfNotPresent(id, item)</span><br><span class="line">            err = e.Err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">        <span class="comment">// ownership to the caller.</span></span><br><span class="line">        <span class="keyword">return</span> item, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    item, ok := f.items[id]</span><br><span class="line">    ...</span><br><span class="line">    err := process(item)</span><br><span class="line">    <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">        f.addIfNotPresent(id, item)</span><br><span class="line">        err = e.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">    <span class="comment">// ownership to the caller.</span></span><br><span class="line">    <span class="keyword">return</span> item, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas"></a>HandleDeltas</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中process函数就是在sharedIndexInformer.Run方法中，给config.Process赋值的<code>HandleDeltas</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.blockDeltas.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from oldest to newest</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">        <span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">            isSync := d.Type == Sync</span><br><span class="line">            s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">            <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Deleted:</span><br><span class="line">            <span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> d.Type &#123;</span><br><span class="line"><span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">    ...</span><br><span class="line">    s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的类型，调用<code>processor.distribute</code>方法，该方法将对象加入<code>processorListener</code>的channel中。</p>
<h3 id="sharedProcessor-distribute"><a href="#sharedProcessor-distribute" class="headerlink" title="sharedProcessor.distribute"></a>sharedProcessor.distribute</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sync &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processorListener.add:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综合以上的分析，可以看出processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。以下分析processorListener.Run的部分。</p>
<h2 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h2><p>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p>
<p>流程：</p>
<ol>
<li>listenser的add函数负责将notify装进pendingNotifications。</li>
<li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li>
<li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sharedProcessor-Run"><a href="#sharedProcessor-Run" class="headerlink" title="sharedProcessor.Run"></a>sharedProcessor.Run</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      p.listenersLock.RLock()</span><br><span class="line">      <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">      <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">         p.wg.Start(listener.run)</span><br><span class="line">         p.wg.Start(listener.pop)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   &lt;-stopCh</span><br><span class="line">   p.listenersLock.RLock()</span><br><span class="line">   <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">   <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">      <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="listener-pop"><a href="#listener-pop" class="headerlink" title="listener.pop"></a>listener.pop</h4><p>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextCh <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">            <span class="comment">// Notification dispatched</span></span><br><span class="line">            <span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">            notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">                nextCh = <span class="literal">nil</span> <span class="comment">// Disable this select case</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> notificationToAdd, ok := &lt;-p.addCh:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> notification == <span class="literal">nil</span> &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">                <span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">                notification = notificationToAdd</span><br><span class="line">                nextCh = p.nextCh</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">                p.pendingNotifications.WriteOne(notificationToAdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="listener-run"><a href="#listener-run" class="headerlink" title="listener.run"></a>listener.run</h4><p>listener.run部分根据不同的更新类型调用不同的处理函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">        <span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> updateNotification:</span><br><span class="line">            p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> addNotification:</span><br><span class="line">            p.handler.OnAdd(notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> deleteNotification:</span><br><span class="line">            p.handler.OnDelete(notification.oldObj)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中具体的实现函数handler是在NewDeploymentController（其他不同类型的controller类似）中赋值的，而该handler是一个接口，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceEventHandler can handle notifications for events that happen to a</span></span><br><span class="line"><span class="comment">// resource. The events are informational only, so you can't return an</span></span><br><span class="line"><span class="comment">// error.</span></span><br><span class="line"><span class="comment">//  * OnAdd is called when an object is added.</span></span><br><span class="line"><span class="comment">//  * OnUpdate is called when an object is modified. Note that oldObj is the</span></span><br><span class="line"><span class="comment">//      last known state of the object-- it is possible that several changes</span></span><br><span class="line"><span class="comment">//      were combined together, so you can't use this to see every single</span></span><br><span class="line"><span class="comment">//      change. OnUpdate is also called when a re-list happens, and it will</span></span><br><span class="line"><span class="comment">//      get called even if nothing changed. This is useful for periodically</span></span><br><span class="line"><span class="comment">//      evaluating or syncing something.</span></span><br><span class="line"><span class="comment">//  * OnDelete will get the final state of the item if it is known, otherwise</span></span><br><span class="line"><span class="comment">//      it will get an object of type DeletedFinalStateUnknown. This can</span></span><br><span class="line"><span class="comment">//      happen if the watch is closed and misses the delete event and we don't</span></span><br><span class="line"><span class="comment">//      notice the deletion until the subsequent re-list.</span></span><br><span class="line"><span class="keyword">type</span> ResourceEventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnAdd(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnUpdate(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnDelete(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResourceEventHandler"><a href="#ResourceEventHandler" class="headerlink" title="ResourceEventHandler"></a>ResourceEventHandler</h3><p>以下以DeploymentController的处理逻辑为例。</p>
<p>在<code>NewDeploymentController</code>部分会注册deployment的事件函数，以下注册了三种类型的事件函数，其中包括：dInformer、rsInformer和podInformer。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeploymentController creates a new DeploymentController.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer extensionsinformers.DeploymentInformer, rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addDeployment,</span><br><span class="line">        UpdateFunc: dc.updateDeployment,</span><br><span class="line">        <span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">        DeleteFunc: dc.deleteDeployment,</span><br><span class="line">    &#125;)</span><br><span class="line">    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addReplicaSet,</span><br><span class="line">        UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">        DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">    &#125;)</span><br><span class="line">    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        DeleteFunc: dc.deletePod,</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addDeployment"><a href="#addDeployment" class="headerlink" title="addDeployment"></a>addDeployment</h4><p>以下以<code>addDeployment</code>为例，addDeployment主要是将对象加入到enqueueDeployment的队列中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">addDeployment</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    d := obj.(*extensions.Deployment)</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"Adding deployment %s"</span>, d.Name)</span><br><span class="line">    dc.enqueueDeployment(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueueDeployment的定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enqueueDeployment <span class="function"><span class="keyword">func</span><span class="params">(deployment *extensions.Deployment)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将dc.enqueue赋值给dc.enqueueDeployment</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.enqueueDeployment = dc.enqueue</span><br></pre></td></tr></table></figure>
<p>dc.enqueue调用了dc.queue.Add(key)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">enqueue</span><span class="params">(deployment *extensions.Deployment)</span></span> &#123;</span><br><span class="line">    key, err := controller.KeyFunc(deployment)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %#v: %v"</span>, deployment, err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dc.queue主要记录了需要被同步的deployment的对象，供syncDeployment使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dc := &amp;DeploymentController&#123;</span><br><span class="line">    ...</span><br><span class="line">    queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewNamedRateLimitingQueue</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedRateLimitingQueue</span><span class="params">(rateLimiter RateLimiter, name <span class="keyword">string</span>)</span> <span class="title">RateLimitingInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;rateLimitingType&#123;</span><br><span class="line">        DelayingInterface: NewNamedDelayingQueue(name),</span><br><span class="line">        rateLimiter:       rateLimiter,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上分析，可以看出processor记录了不同类似的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析的部分主要是k8s的<code>informer</code>机制，即<code>List-Watch</code>机制。</p>
<h3 id="Reflector-2"><a href="#Reflector-2" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p>
<h3 id="ListAndWatch-1"><a href="#ListAndWatch-1" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p><code>ListAndWatch</code>第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p>
<h3 id="DeltaFIFO-2"><a href="#DeltaFIFO-2" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p><code>DeltaFIFO</code>是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p>
<p>DeltaFIFO主要用在以下场景：</p>
<ul>
<li>希望对象变更最多处理一次</li>
<li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li>
<li>要处理对象的删除</li>
<li>希望定期重新处理对象</li>
</ul>
<h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p>
<p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p>
<h3 id="processor-1"><a href="#processor-1" class="headerlink" title="processor"></a>processor</h3><p><code>processor</code>的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p>
<p>流程：</p>
<ol>
<li>listenser的add函数负责将notify装进pendingNotifications。</li>
<li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li>
<li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li>
</ol>
<p><code>processor</code>记录了不同类似的事件函数，其中事件函数在<code>NewXxxController</code>构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似<code>syncDeployment</code>的同步函数来维持期望状态的同步逻辑。</p>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol>
<li>在controller-manager的Run函数部分调用了InformerFactory.Start的方法，Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。</li>
<li>informer.Run的部分先生成一个DeltaFIFO的队列来存储对象变化的数据。然后调用processor.Run和controller.Run函数。</li>
<li>controller.Run函数会生成一个Reflector，<code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</li>
<li>Reflector接着执行ListAndWatch函数，ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</li>
<li>controller.Run函数还会调用processLoop函数，processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。</li>
<li>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。processor记录了不同类型的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="Informer-二级缓存中的同步问题"><a href="#Informer-二级缓存中的同步问题" class="headerlink" title="Informer 二级缓存中的同步问题"></a>Informer 二级缓存中的同步问题</h2><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存 DeltaIFIFO 和 LocalStore 之间会存在 resync 机制，k8s 中 kube-controller-manager 的 StatefulSetController 中使用了两级缓存的 resync 机制（如下图所示），我们在生产环境中发现 sts 创建后过了很久 pod 才会创建，主要是由于 StatefulSetController 的两级缓存之间 30s 会同步一次，由于 StatefulSetController watch 到变化后就会把对应的 sts 放入 DeltaIFIFO 中，且每隔 30s 会把 LocalStore 中全部的 sts 重新入一遍 DeltaIFIFO，入队时会做一些处理，过滤掉一些不需要重复入队列的 sts，若间隔的 30s 内没有处理完队列中所有的 sts，则待处理队列中始终存在未处理完的 sts，并且在同步过程中产生的 sts 会加的队列的尾部，新加入队尾的 sts 只能等到前面的 sts 处理完成（也就是 resync 完成）才会被处理，所以导致的现象就是 sts 创建后过了很久 pod 才会创建。</p>
<p>优化的方法就是去掉二级缓存的同步策略（将 setInformer.Informer().AddEventHandlerWithResyncPeriod() 改为 informer.AddEventHandler()）或者调大同步周期，但是在研究 kube-controller-manager 其他 controller 时发现并不是所有的 controller 都有同步策略，社区也有相关的 issue 反馈了这一问题，Remove resync period for sset controller，社区也会在以后的版本中去掉两级缓存之间的 resync 策略。</p>
<p>k8s.io/kubernetes/pkg/controller/statefulset/stateful_set.go</p>
<p><img alt="Kubernetes 中 informer 的使用" data-src="https://static001.geekbang.org/wechat/images/a1/a1a5745f0c0309c9d05c484905887fb8.jpeg">kube-controller-manager sts controller</p>
<h2 id="使用-Informer-如何监听所有资源对象？"><a href="#使用-Informer-如何监听所有资源对象？" class="headerlink" title="使用 Informer 如何监听所有资源对象？"></a>使用 Informer 如何监听所有资源对象？</h2><p>一个 Informer 实例只能监听一种 resource，每个 resource 需要创建对应的 Informer 实例。</p>
<h2 id="为什么不是使用-workqueue？"><a href="#为什么不是使用-workqueue？" class="headerlink" title="为什么不是使用 workqueue？"></a>为什么不是使用 workqueue？</h2><p>建议使用 RateLimitingQueue，它相比普通的 workqueue 多了以下的功能:</p>
<ul>
<li><strong>限流：</strong>可以限制一个 item 被 reenqueued 的次数。</li>
<li><strong>防止 hot loop：</strong>它保证了一个 item 被 reenqueued 后，不会马上被处理。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://github.com/kubernetes/client-go/tree/master/tools/cache" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/tree/master/tools/cache</a></li>
<li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></li>
<li><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/3bc1a603/" rel="bookmark">【Kubernetes】ApiServer 启动分析</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/d8b96fe4/" rel="bookmark">【Kubernetes】开篇</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/b0614056/" rel="bookmark">【Kubernetes】API Install</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/1141907b/" rel="bookmark">【Kubernetes】Apiserver Install</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/777d3be4/" rel="bookmark">【Kubernetes】ApiServer Codec</a></div>
    </li>
  </ul>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/wechatpay.png" alt="Houmin 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/alipay.jpg" alt="Houmin 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Houmin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://houmin.cc/posts/1f0eb2ff/" title="【Kubernetes】List&#x2F;Watch机制和Informer模块详解">http://houmin.cc/posts/1f0eb2ff/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/k8s/" rel="tag"><i class="fa fa-tag"></i> k8s</a>
              <a href="/tags/informer/" rel="tag"><i class="fa fa-tag"></i> informer</a>
              <a href="/tags/watch/" rel="tag"><i class="fa fa-tag"></i> watch</a>
              <a href="/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="tag"><i class="fa fa-tag"></i> 消息机制</a>
              <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"><i class="fa fa-tag"></i> 异步</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/b7728477/" rel="next" title="【Kubernetes】Client Go">
                  <i class="fa fa-chevron-left"></i> 【Kubernetes】Client Go
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/3adb7157/" rel="prev" title="【Kubernetes解读】Workqueue">
                  【Kubernetes解读】Workqueue <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#使用入门"><span class="nav-number">1.</span> <span class="nav-text">使用入门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原理示意"><span class="nav-number">2.</span> <span class="nav-text">原理示意</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#client-go组件"><span class="nav-number">2.1.</span> <span class="nav-text">client-go组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义controller组件"><span class="nav-number">2.2.</span> <span class="nav-text">自定义controller组件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关键设计"><span class="nav-number">3.</span> <span class="nav-text">关键设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计目标"><span class="nav-number">3.1.</span> <span class="nav-text">设计目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于chunk的消息通知"><span class="nav-number">3.2.</span> <span class="nav-text">基于chunk的消息通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reflector"><span class="nav-number">3.3.</span> <span class="nav-text">reflector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地缓存"><span class="nav-number">3.4.</span> <span class="nav-text">本地缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地索引"><span class="nav-number">3.5.</span> <span class="nav-text">本地索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无界队列"><span class="nav-number">3.6.</span> <span class="nav-text">无界队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件去重"><span class="nav-number">3.7.</span> <span class="nav-text">事件去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复用连接"><span class="nav-number">3.8.</span> <span class="nav-text">复用连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于观察者模式的注册"><span class="nav-number">3.9.</span> <span class="nav-text">基于观察者模式的注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计总结"><span class="nav-number">3.10.</span> <span class="nav-text">设计总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码走读"><span class="nav-number">4.</span> <span class="nav-text">源码走读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sharedInformerFactory-Start"><span class="nav-number">4.1.</span> <span class="nav-text">sharedInformerFactory.Start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sharedIndexInformer-Run"><span class="nav-number">4.2.</span> <span class="nav-text">sharedIndexInformer.Run</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NewDeltaFIFO"><span class="nav-number">4.2.1.</span> <span class="nav-text">NewDeltaFIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Config"><span class="nav-number">4.2.2.</span> <span class="nav-text">Config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#controller"><span class="nav-number">4.2.3.</span> <span class="nav-text">controller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cacheMutationDetector-Run"><span class="nav-number">4.2.4.</span> <span class="nav-text">cacheMutationDetector.Run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#processor-run"><span class="nav-number">4.2.5.</span> <span class="nav-text">processor.run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#controller-Run"><span class="nav-number">4.2.6.</span> <span class="nav-text">controller.Run</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflector"><span class="nav-number">4.3.</span> <span class="nav-text">Reflector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflector-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">Reflector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewReflector"><span class="nav-number">4.3.2.</span> <span class="nav-text">NewReflector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflector-Run"><span class="nav-number">4.3.3.</span> <span class="nav-text">Reflector.Run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ListAndWatch"><span class="nav-number">4.3.4.</span> <span class="nav-text">ListAndWatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#store-Resync"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">store.Resync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watch"><span class="nav-number">4.3.4.3.</span> <span class="nav-text">Watch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watchHandler"><span class="nav-number">4.3.4.4.</span> <span class="nav-text">watchHandler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DeltaFIFO"><span class="nav-number">4.4.</span> <span class="nav-text">DeltaFIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NewDeltaFIFO-1"><span class="nav-number">4.4.1.</span> <span class="nav-text">NewDeltaFIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeltaFIFO-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">DeltaFIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-amp-Store"><span class="nav-number">4.4.3.</span> <span class="nav-text">Queue &amp; Store</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#store"><span class="nav-number">4.5.</span> <span class="nav-text">store</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cache"><span class="nav-number">4.5.1.</span> <span class="nav-text">cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadSafeStore"><span class="nav-number">4.5.2.</span> <span class="nav-text">ThreadSafeStore</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#processLoop"><span class="nav-number">4.6.</span> <span class="nav-text">processLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DeltaFIFO-Pop"><span class="nav-number">4.6.1.</span> <span class="nav-text">DeltaFIFO.Pop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandleDeltas"><span class="nav-number">4.6.2.</span> <span class="nav-text">HandleDeltas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sharedProcessor-distribute"><span class="nav-number">4.6.3.</span> <span class="nav-text">sharedProcessor.distribute</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#processor"><span class="nav-number">4.7.</span> <span class="nav-text">processor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sharedProcessor-Run"><span class="nav-number">4.7.1.</span> <span class="nav-text">sharedProcessor.Run</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#listener-pop"><span class="nav-number">4.7.1.1.</span> <span class="nav-text">listener.pop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listener-run"><span class="nav-number">4.7.1.2.</span> <span class="nav-text">listener.run</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceEventHandler"><span class="nav-number">4.7.2.</span> <span class="nav-text">ResourceEventHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#addDeployment"><span class="nav-number">4.7.2.1.</span> <span class="nav-text">addDeployment</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.8.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflector-2"><span class="nav-number">4.8.1.</span> <span class="nav-text">Reflector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ListAndWatch-1"><span class="nav-number">4.8.2.</span> <span class="nav-text">ListAndWatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeltaFIFO-2"><span class="nav-number">4.8.3.</span> <span class="nav-text">DeltaFIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-1"><span class="nav-number">4.8.4.</span> <span class="nav-text">store</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#processor-1"><span class="nav-number">4.8.5.</span> <span class="nav-text">processor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要步骤"><span class="nav-number">4.8.6.</span> <span class="nav-text">主要步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见问题"><span class="nav-number">5.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Informer-二级缓存中的同步问题"><span class="nav-number">5.1.</span> <span class="nav-text">Informer 二级缓存中的同步问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Informer-如何监听所有资源对象？"><span class="nav-number">5.2.</span> <span class="nav-text">使用 Informer 如何监听所有资源对象？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么不是使用-workqueue？"><span class="nav-number">5.3.</span> <span class="nav-text">为什么不是使用 workqueue？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文章"><span class="nav-number">6.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Houmin" src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
  <p class="site-author-name" itemprop="name">Houmin</p>
  <div class="site-description" itemprop="description">丈夫拥书万卷，何假南面百城</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">206</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SimpCosm" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SimpCosm" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weihoumin@gmail.com" title="E-Mail &amp;rarr; mailto:weihoumin@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="hitokoto">
    <!-- hitokoto -->
    <div id="hito-expression">:D 获取中...</div>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
      fetch('https://v1.hitokoto.cn')
        .then(function (res){
          return res.json();
        })
        .then(function (data) {
          var hitokoto = document.getElementById('hito-expression');
          hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
        })
        .catch(function (err) {
          console.error(err);
        })
    </script>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houmin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">45:57</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>



  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '800px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'iEBFuhVyk4tuhVYctQ265uid-gzGzoHsz',
    appKey: 'KGjOktrtgSEWK1v9DYA3T3Az',
    placeholder: "Just go go",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
