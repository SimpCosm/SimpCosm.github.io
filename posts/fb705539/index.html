<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="Houmin" type="application/atom+xml">
  <meta name="google-site-verification" content="zdGhdEF7jHoJW58lsdN6l9JrQFjJFwakCIc7TbbosV0">
  <meta name="msvalidate.01" content="2F527B379ED5537861D0D38C2C754C2B">
  <meta name="baidu-site-verification" content="xAag2PqzKE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Kubelet 作为 k8s 集群中 Node 上的关键组件，在每个 Node 上以 Agent 进程的形式运行，负责管理 Pod 和其中容器的生命周期。Kubelet 主要功能是定时从某个地方获取节点上 pod&#x2F;container 的期望状态，并调用容器平台接口达到这个状态。本文将作为 Kubelet 分析的开篇，介绍 Kubelet 的主要功能和实现原理。">
<meta name="keywords" content="k8s,kubelet">
<meta property="og:type" content="article">
<meta property="og:title" content="【Kubernetes】Kubelet">
<meta property="og:url" content="http://houmin.cc/posts/fb705539/index.html">
<meta property="og:site_name" content="Houmin">
<meta property="og:description" content="Kubelet 作为 k8s 集群中 Node 上的关键组件，在每个 Node 上以 Agent 进程的形式运行，负责管理 Pod 和其中容器的生命周期。Kubelet 主要功能是定时从某个地方获取节点上 pod&#x2F;container 的期望状态，并调用容器平台接口达到这个状态。本文将作为 Kubelet 分析的开篇，介绍 Kubelet 的主要功能和实现原理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_kubelet.png">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_kubelet-source.jpg">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-25_k8s-kubelet.png">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_k8s-pod-start.png">
<meta property="og:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-25_k8s-kubelet-process.png">
<meta property="og:updated_time" content="2021-01-27T09:44:35.266Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_kubelet.png">

<link rel="canonical" href="http://houmin.cc/posts/fb705539/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>【Kubernetes】Kubelet | Houmin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


  <script src="/js/photoswipe.min.js?v="></script>
  <script src="/js/photoswipe-ui-default.min.js?v="></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Houmin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">Yesterday You Said Tomorrow</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-album">

    <a href="/album" rel="section"><i class="fa fa-fw fa-camera"></i>相册</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://houmin.cc/posts/fb705539/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
      <meta itemprop="name" content="Houmin">
      <meta itemprop="description" content="丈夫拥书万卷，何假南面百城">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Houmin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          【Kubernetes】Kubelet
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 20:47:13" itemprop="dateCreated datePublished" datetime="2020-09-06T20:47:13+08:00">2020-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/" itemprop="url" rel="index">
                    <span itemprop="name">术业专攻</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/fb705539/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/fb705539/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>Kubelet</code> 作为 k8s 集群中 Node 上的关键组件，在每个 Node 上以 Agent 进程的形式运行，负责管理 Pod 和其中容器的生命周期。Kubelet 主要功能是定时从某个地方获取节点上 pod/container 的期望状态，并调用容器平台接口达到这个状态。本文将作为 Kubelet 分析的开篇，介绍 Kubelet 的主要功能和实现原理。</p>
<a id="more"></a>
<h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>下图展示了 kubelet 内部组件结构，Kubelet 由许多内部组件构成</p>
<ul>
<li>Kubelet API，包括 10250 端口的认证 API、4194 端口的 cAdvisor API、10255 端口的只读 API 以及 10248 端口的健康检查 API</li>
<li>syncLoop：从 API 或者 manifest 目录接收 Pod 更新，发送到 podWorkers 处理，大量使用 channel 处理来处理异步请求</li>
<li>辅助的 manager，如 cAdvisor、PLEG、Volume Manager 等，处理 syncLoop 以外的其他工作</li>
<li>CRI：容器执行引擎接口，负责与 container runtime shim 通信，关于 CRI 的更多内容可以参考 <a href="https://houmin.cc/posts/89dc9bfd">CRI</a></li>
<li>容器执行引擎，如 dockershim、rkt 等</li>
<li>网络插件，目前支持 CNI 和 kubenet</li>
</ul>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_kubelet.png"></p>
<h3 id="pod-管理"><a href="#pod-管理" class="headerlink" title="pod 管理"></a>pod 管理</h3><p>Kubelet 基于 PodSpec 来工作，它需要确保这些 PodSpec 中描述的容器处于运行状态且运行状况良好，因此 Kubelet 不管理那些不是由 k8s 创建的容器。PodSpec 的来源有以下四种：</p>
<ul>
<li><code>API Server</code>：通过 API Server 监听 etcd 目录获取数据，这也是最主要的来源</li>
<li><code>File</code>：利用命令行参数传递路径，kubelet 周期性地监视此路径下的文件是否有更新，监视周期默认为 20s</li>
<li><code>HTTP Endpoint</code>：利用命令行参数指定 HTTP 端点。 此端点的监视周期默认为 20 秒</li>
<li><code>HTTP Server</code>：kubelet 还可以侦听 HTTP 并响应简单的 API （目前没有完整规范）来提交新的清单</li>
</ul>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_kubelet-source.jpg"></p>
<h4 id="监听-API-Server"><a href="#监听-API-Server" class="headerlink" title="监听 API Server"></a>监听 API Server</h4><p>Kubelet 通过 API Server Client 使用 <code>List/Watch</code> 的方式监听 <code>/registry/nodes/&lt;NodeName&gt;</code> 和 <code>/registry/pods</code> 路径，将获取的信息同步到本地缓存中。Kubelet 监听 etcd，所有针对 Pod 的操作都将会被 Kubelet 监听到：</p>
<ul>
<li>如果发现有新的绑定到本节点的 Pod，则按照 PodSpec 的要求创建该 Pod。</li>
<li>如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改，比如删除 Pod 中某个容器时，则通过 Docker Client 删除该容器。</li>
<li>如果发现删除本节点的 Pod，则删除相应的 Pod，并通过 Docker Client 删除 Pod 中的容器。</li>
</ul>
<p>Kubelet 读取监听到的信息，如果是创建和修改 Pod 任务，则执行如下处理：</p>
<ul>
<li>为该 Pod 创建一个数据目录</li>
<li>从 API Server 读取该 PodSpec</li>
<li>为该 Pod 挂载外部卷</li>
<li>下载 Pod 用到的 Secret</li>
<li>检查已经在节点上运行的 Pod，如果该 Pod 没有容器或 Pause 容器没有启动，则先停止 Pod 里所有容器的进程。如果在 Pod 中有需要删除的容器，则删除这些容器</li>
<li>用 <code>kubernetes/pause</code> 镜像为每个 Pod 创建一个容器。Pause 容器用于接管 Pod 中所有其他容器的网络。每创建一个新的 Pod，Kubelet 都会先创建一个 Pause 容器，然后创建其他容器。</li>
<li>为 Pod 中的每个容器做如下处理：<ol>
<li>为容器计算一个 hash 值，然后用容器的名字去 Docker 查询对应容器的 hash 值。若查找到容器，且两者 hash 值不同，则停止 Docker 中容器的进程，并停止与之关联的 Pause 容器的进程；若两者相同，则不做任何处理；</li>
<li>如果容器被终止了，且容器没有指定的 restartPolicy，则不做任何处理；</li>
<li>调用 Docker Client 下载容器镜像，调用 Docker Client 运行容器。</li>
</ol>
</li>
</ul>
<h4 id="Static-Pod"><a href="#Static-Pod" class="headerlink" title="Static Pod"></a>Static Pod</h4><p>所有以非 API Server 方式创建的 Pod 都叫 Static Pod。Kubelet 将 Static Pod 的状态汇报给 API Server，API Server 为该 Static Pod 创建一个 Mirror Pod 和其相匹配。Mirror Pod 的状态将真实反映 Static Pod 的状态。当 Static Pod 被删除时，与之相对应的 Mirror Pod 也会被删除。</p>
<h3 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h3><p>容器健康检查通过 <code>LivenessProbe</code> 与 <code>ReadinessProbe</code> 两类探针来判断容器是否健康。</p>
<ul>
<li><strong>LivenessProbe</strong> ：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 <strong>Success</strong>；</li>
<li><strong>ReadinessProbe</strong>：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。</li>
</ul>
<p>Kubelet 定期调用容器中的 LivenessProbe 探针来诊断容器的健康状况。LivenessProbe 包含如下三种实现方式：</p>
<ul>
<li><strong>ExecAction</strong>：在容器内部执行一个命令，如果该命令的退出状态码为 0，则表明容器健康；</li>
<li><strong>TCPSocketAction</strong>：通过容器的 IP 地址和端口号执行 TCP 检查，如果端口能被访问，则表明容器健康；</li>
<li><strong>HTTPGetAction</strong>：通过容器的 IP 地址和端口号及路径调用 HTTP GET 方法，如果响应的状态码大于等于 200 且小于 400，则认为容器状态健康。</li>
</ul>
<h3 id="cAdvisor-容器监控"><a href="#cAdvisor-容器监控" class="headerlink" title="cAdvisor 容器监控"></a>cAdvisor 容器监控</h3><p>Kubernetes 集群中，应用程序的执行情况可以在不同的级别上监测到，这些级别包括：容器、Pod、Service 和整个集群。Kubelet 通过 cAdvisor 获取其所在节点及容器的数据。</p>
<p>cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，集成到 Kubelet中，当Kubelet启动时会同时启动cAdvisor，且一个cAdvisor只监控一个Node节点的信息。cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</p>
<p>关于 cAdvisor 更多的内容，可以参考 <a href="https://houmin.cc/posts/703a5727/">cAdvisor</a> 。</p>
<h3 id="Kubelet-Eviction"><a href="#Kubelet-Eviction" class="headerlink" title="Kubelet Eviction"></a>Kubelet Eviction</h3><p>Kubelet 会监控资源的使用情况，并使用驱逐机制防止计算和存储资源耗尽。在驱逐时，Kubelet 将 Pod 的所有容器停止，并将 PodPhase 设置为 Failed。Kubelet 定期（<code>housekeeping-interval</code>）检查系统的资源是否达到了预先配置的驱逐阈值，包括</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Eviction Signal</th>
<th>Condition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memory.available</code></td>
<td>MemoryPressue</td>
<td><code>memory.available</code> := <code>node.status.capacity[memory]</code> - <code>node.stats.memory.workingSet</code> （计算方法参考<a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/memory-available.sh" target="_blank" rel="external nofollow noopener noreferrer">这里</a>）</td>
</tr>
<tr>
<td><code>nodefs.available</code></td>
<td>DiskPressure</td>
<td><code>nodefs.available</code> := <code>node.stats.fs.available</code>（Kubelet Volume以及日志等）</td>
</tr>
<tr>
<td><code>nodefs.inodesFree</code></td>
<td>DiskPressure</td>
<td><code>nodefs.inodesFree</code> := <code>node.stats.fs.inodesFree</code></td>
</tr>
<tr>
<td><code>imagefs.available</code></td>
<td>DiskPressure</td>
<td><code>imagefs.available</code> := <code>node.stats.runtime.imagefs.available</code>（镜像以及容器可写层等）</td>
</tr>
<tr>
<td><code>imagefs.inodesFree</code></td>
<td>DiskPressure</td>
<td><code>imagefs.inodesFree</code> := <code>node.stats.runtime.imagefs.inodesFree</code></td>
</tr>
</tbody>
</table>
</div>
<p>这些驱逐阈值可以使用百分比，也可以使用绝对值，如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--eviction-hard=memory.available&lt;500Mi,nodefs.available&lt;1Gi,imagefs.available&lt;100Gi</span><br><span class="line">--eviction-minimum-reclaim=<span class="string">"memory.available=0Mi,nodefs.available=500Mi,imagefs.available=2Gi"</span>`</span><br><span class="line">--system-reserved=memory=1.5Gi</span><br></pre></td></tr></table></figure>
<p>这些驱逐信号可以分为软驱逐和硬驱逐</p>
<ul>
<li>软驱逐（Soft Eviction）：配合驱逐宽限期（eviction-soft-grace-period和eviction-max-pod-grace-period）一起使用。系统资源达到软驱逐阈值并在超过宽限期之后才会执行驱逐动作。</li>
<li>硬驱逐（Hard Eviction ）：系统资源达到硬驱逐阈值时立即执行驱逐动作。</li>
</ul>
<p>驱逐动作包括回收节点资源和驱逐用户 Pod 两种：</p>
<ul>
<li>回收节点资源<ul>
<li>配置了 imagefs 阈值时<ul>
<li>达到 nodefs 阈值：删除已停止的 Pod</li>
<li>达到 imagefs 阈值：删除未使用的镜像</li>
</ul>
</li>
<li>未配置 imagefs 阈值时<ul>
<li>达到 nodefs阈值时，按照删除已停止的 Pod 和删除未使用镜像的顺序清理资源</li>
</ul>
</li>
</ul>
</li>
<li>驱逐用户 Pod<ul>
<li>驱逐顺序为：BestEffort、Burstable、Guaranteed</li>
<li>配置了 imagefs 阈值时<ul>
<li>达到 nodefs 阈值，基于 nodefs 用量驱逐（local volume + logs）</li>
<li>达到 imagefs 阈值，基于 imagefs 用量驱逐（容器可写层）</li>
</ul>
</li>
<li>未配置 imagefs 阈值时<ul>
<li>达到 nodefs阈值时，按照总磁盘使用驱逐（local volume + logs + 容器可写层）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Kubelet 的工作核心是 <code>SyncLoop</code> 这个控制循环，驱动整个控制循环的事件包括：</p>
<ul>
<li><code>kubetypes.PodUpdate</code>：pod更新事件</li>
<li><code>pleg.PodLifeEvent</code>：pod生命周期变化</li>
<li><code>periodic sync events</code>：kubelet本身设置的执行周期</li>
<li><code>housekeeping events</code>：定时清理事件</li>
</ul>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-25_k8s-kubelet.png"></p>
<h3 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a>SyncLoop</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-26_k8s-pod-start.png"></p>
<p>在SyncLoop循环上还有很多 <code>Manager</code>：</p>
<ul>
<li><strong><code>statusManager</code></strong>： 负责维护状态信息，并把 pod 状态更新到 apiserver，但是它并不负责监控 pod 状态的变化，而是提供对应的接口供其他组件调用，比如 probeManager</li>
<li><strong>PLEG(Pod Lifecycle Event Generator）</strong> PLEG 是 kubelet 的核心模块，PLEG 会一直调用 container runtime 获取本节点 containers/sandboxes 的信息，并与自身维护的 pods cache 信息进行对比，生成对应的 PodLifecycleEvent，然后输出到 eventChannel 中，通过 eventChannel 发送到 kubelet syncLoop 进行消费，然后由 kubelet syncPod 来触发 pod 同步处理过程，最终达到用户的期望状态</li>
<li><strong>imageManager</strong>： 调用 <code>kubecontainer</code> 提供的PullImage/GetImageRef/ListImages/RemoveImage/ImageStates 方法来保证pod 运行所需要的镜像。</li>
<li><strong>volumeManager</strong>： 负责 node 节点上 pod 所使用 volume 的管理，volume 与 pod 的生命周期关联，负责 pod 创建删除过程中 volume 的 mount/umount/attach/detach 流程，kubernetes 采用 volume Plugins 的方式，实现存储卷的挂载等操作，内置几十种存储插件。</li>
<li><strong>containerManager</strong>： 负责 node 节点上运行的容器的 cgroup 配置信息，kubelet 启动参数如果指定 <code>--cgroups-per-qos</code> 的时候，kubelet 会启动 goroutine 来周期性的更新 pod 的 cgroup 信息，维护其正确性，该参数默认为 <code>true</code>，实现了 pod 的Guaranteed/BestEffort/Burstable 三种级别的 Qos。</li>
<li><strong>runtimeManager</strong>： containerRuntime 负责 kubelet 与不同的 runtime 实现进行对接，实现对于底层 container 的操作，初始化之后得到的 runtime 实例将会被之前描述的组件所使用</li>
<li><strong>podManager</strong>：提供了接口来存储和访问 pod 的信息，维持 static pod 和 mirror pods 的关系，podManager 会被statusManager/volumeManager/runtimeManager 所调用，podManager 的接口处理流程里面会调用 secretManager 以及 configMapManager</li>
<li><strong>probeManager</strong> ：依赖于 <code>statusManager</code>，<code>livenessManager</code>，<code>containerRefManager</code>，会定时去监控 pod 中容器的健康状况</li>
<li><strong>evictionManager</strong>： 当节点的内存、磁盘或 inode 等资源不足时，达到了配置的 evict 策略， node 会变为 pressure 状态，此时 kubelet 会按照 qosClass 顺序来驱赶 pod，以此来保证节点的稳定性。</li>
<li><strong>imageGC</strong>： 负责 node 节点的镜像回收，当本地的存放镜像的本地磁盘空间达到某阈值的时候，会触发镜像的回收，删除掉不被 pod 所使用的镜像</li>
<li><strong>containerGC</strong>：负责清理 node 节点上已消亡的 container，具体的 GC 操作由runtime 来实现</li>
<li><strong>cAdvisor</strong> 是 google 开发的容器监控工具，集成在 kubelet 中，起到收集本节点和容器的监控信息，cAvisor 模块对外提供了 interface 接口，该接口也被 imageManager，OOMWatcher，containerManager 等所使用。</li>
<li><strong>OOMWatcher</strong> 系统 OOM 的监听器，会与 cadvisor 模块之间建立 SystemOOM，通过 Watch方式从 cadvisor 那里收到的 OOM 信号，并产生相关事件。</li>
<li><strong>containerRefManager</strong> 容器引用的管理，相对简单的Manager，用来报告容器的创建，失败等事件，通过定义 map 来实现了 containerID 与 v1.ObjectReferece 容器引用的映射</li>
<li>…</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2021-01-25_k8s-kubelet-process.png"></p>
<figure class="highlight go"><figcaption><span>kubernetes\pkg\kubelet\kubelet.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) Run(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate) &#123;</span><br><span class="line">	<span class="comment">//注册 logServer</span></span><br><span class="line">	<span class="keyword">if</span> kl.logServer == <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.logServer = http.StripPrefix(<span class="string">"/logs/"</span>, http.FileServer(http.Dir(<span class="string">"/var/log/"</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kl.kubeClient == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Warning(<span class="string">"No api server defined - no node status update will be sent."</span>)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> kl.cloudResourceSyncManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> kl.cloudResourceSyncManager.Run(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用 kl.initializeModules 首先启动不依赖 container runtime 的一些模块</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.initializeModules(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//启动 volume manager</span></span><br><span class="line">	<span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kl.kubeClient != <span class="literal">nil</span> &#123; </span><br><span class="line">		<span class="comment">//执行 kl.syncNodeStatus 定时同步 Node 状态</span></span><br><span class="line">		<span class="keyword">go</span> wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)</span><br><span class="line">		<span class="comment">//调用 kl.fastStatusUpdateOnce 更新容器运行时启动时间以及执行首次状态同步</span></span><br><span class="line">		<span class="keyword">go</span> kl.fastStatusUpdateOnce()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// start syncing lease</span></span><br><span class="line">		<span class="comment">//NodeLease 机制</span></span><br><span class="line">		<span class="keyword">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行 kl.updateRuntimeUp 定时更新 Runtime 状态</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(kl.updateRuntimeUp, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up iptables util rules</span></span><br><span class="line">	<span class="comment">//执行 kl.syncNetworkUtil 定时同步 iptables 规则</span></span><br><span class="line">	<span class="keyword">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class="line">		kl.initNetworkUtil()</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//获取 pk.podKillingCh异常pod， 并定时清理异常 pod</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(kl.podKiller.PerformPodKillingWork, <span class="number">1</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start component sync loops.</span></span><br><span class="line">	<span class="comment">//启动 statusManager、probeManager、runtimeClassManager</span></span><br><span class="line">	kl.statusManager.Start()</span><br><span class="line">	kl.probeManager.Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start syncing RuntimeClasses if enabled.</span></span><br><span class="line">	<span class="keyword">if</span> kl.runtimeClassManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">	<span class="comment">//启动 pleg 该模块主要用于周期性地向 container runtime 刷新当前所有容器的状态</span></span><br><span class="line">	<span class="comment">//https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md</span></span><br><span class="line">	kl.pleg.Start()</span><br><span class="line">	kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会做以下事情：</p>
<ol>
<li>注册logServer；</li>
<li>如果设置了Cloud Provider，那么会启动云资源管理器，具体的可以查看文章：<a href="https://kubernetes.feisky.xyz/extension/cloud-provider" target="_blank" rel="external nofollow noopener noreferrer">cloud-provider</a>；</li>
<li>调用kl.initializeModules启动不依赖 container runtime 的一些模块，这个方法我们下面再分析；</li>
<li>启动 volume manager；</li>
<li>执行 kl.syncNodeStatus 定时同步 Node 状态；</li>
<li>调用kl.fastStatusUpdateOnce启动一个循环更新pod CIDR、runtime状态以及node状态；</li>
<li>调用 <code>kl.nodeLeaseController.Run</code> 启动NodeLease机制，NodeLease机制是一种上报心跳的方式，可以通过更加轻量化节约资源的方式，并提升性能上报node的心跳信息，具体看： <a href="https://kubernetes.io/docs/concepts/architecture/nodes/#heartbeats" target="_blank" rel="external nofollow noopener noreferrer">Lease object</a>；</li>
<li>执行 <code>kl.updateRuntimeUp</code> 定时更新 Runtime 状态；</li>
<li>执行<code>kl.syncNetworkUtil</code> 定时同步 iptables 规则；</li>
<li>获取 <code>pk.podKillingCh</code> 异常pod， 并定时清理异常 pod；</li>
<li>然后启动 statusManager、probeManager、runtimeClassManager；</li>
<li>启动 pleg模块，该模块主要用于周期性地向 container runtime 上报当前所有容器的状态，具体可以看：<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md" target="_blank" rel="external nofollow noopener noreferrer">Pod Lifecycle Event Generator (PLEG)</a>；</li>
<li>调用 <code>kl.syncLoop</code> 启动kublet事件循环；</li>
</ol>
<h3 id="initializeModules"><a href="#initializeModules" class="headerlink" title="initializeModules"></a>initializeModules</h3><p>下面我们看看initializeModules方法做了些什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) initializeModules() error &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建文件目录</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.setupDataDirs(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//创建 ContainerLogsDir</span></span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(ContainerLogsDir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := kl.os.MkdirAll(ContainerLogsDir, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create directory %q: %v"</span>, ContainerLogsDir, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//启动 imageManager</span></span><br><span class="line">	kl.imageManager.Start()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//启动 certificate manager ，证书相关</span></span><br><span class="line">	<span class="keyword">if</span> kl.serverCertificateManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.serverCertificateManager.Start()</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//启动 oomWatcher.</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.oomWatcher.Start(kl.nodeRef); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to start OOM watcher %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//启动 resource analyzer,刷新volume stats到缓存中</span></span><br><span class="line">	kl.resourceAnalyzer.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initializeModules方法主要做了以下几件事：</p>
<ol>
<li>创建创建文件目录、Container的log目录；</li>
<li>启动 imageManager，这个管理器实际上是realImageGCManager，我们待会看；</li>
<li>启动 certificate manager ，证书相关；</li>
<li>启动 oomWatcher监视器；</li>
<li>启动 resource analyzer,定时刷新volume stats到缓存中；</li>
</ol>
<p><strong>realImageGCManager#Start</strong></p>
<p>文件路径：pkg/kubelet/images/image_gc_manager.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(im *realImageGCManager) Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">		<span class="keyword">var</span> ts time.Time</span><br><span class="line">		<span class="keyword">if</span> im.initialized &#123;</span><br><span class="line">			ts = time.Now()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找出所有的image，并删除不再使用的image</span></span><br><span class="line">		_, err := im.detectImages(ts)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"[imageGCManager] Failed to monitor images: %v"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			im.initialized = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">5</span>*time.Minute, wait.NeverStop)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//更新image的缓存</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//调用容器接口，获取最新的image</span></span><br><span class="line">		images, err := im.runtime.ListImages()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"[imageGCManager] Failed to update image list: %v"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			im.imageCache.set(images)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">30</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realImageGCManager</code> 的 <code>start</code> 方法会启动两个协程，然后分别定时调用 <code>detectImages</code> 方法与 <code>imageCache</code> 的 <code>set</code> 方法。<code>detectImages</code> 方法里面主要就是调用 <code>ImageService</code> 和 <code>RuntimeService</code> 的方法找出所有正在使用的image，然后删除不再使用的image。</p>
<p>这里 <code>ListImages</code> 和 <code>detectImages</code> 里面用到的GetPods方法都是调用了CRI的方法，</p>
<h3 id="fastStatusUpdateOnce"><a href="#fastStatusUpdateOnce" class="headerlink" title="fastStatusUpdateOnce"></a>fastStatusUpdateOnce</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) fastStatusUpdateOnce() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		node, err := kl.GetNode()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(node.Spec.PodCIDRs) != <span class="number">0</span> &#123;</span><br><span class="line">			podCIDRs := strings.Join(node.Spec.PodCIDRs, <span class="string">","</span>)</span><br><span class="line">			<span class="keyword">if</span> _, err := kl.updatePodCIDR(podCIDRs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Pod CIDR update to %v failed %v"</span>, podCIDRs, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//更新 Runtime 状态</span></span><br><span class="line">			kl.updateRuntimeUp()</span><br><span class="line">            <span class="comment">//更新 节点 状态</span></span><br><span class="line">			kl.syncNodeStatus()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FastStatusUpdateOnce 函数启动一个循环，尝试立即更新POD CIDR。更新pod CIDR后，它会触发运行时更新和节点状态更新。函数在一次成功的节点状态更新后直接返回。该功能仅在 kubelet 启动期间执行，通过尽快更新 pod cidr、运行时状态和节点状态来提高准备就绪节点的延迟。</p>
<p><strong>updateRuntimeUp</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首次执行的时候会初始化runtime依赖模块，然后更新runtimeState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">updateRuntimeUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kl.updateRuntimeMux.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kl.updateRuntimeMux.Unlock()</span><br><span class="line">	<span class="comment">//获取 containerRuntime Status</span></span><br><span class="line">	s, err := kl.containerRuntime.Status()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Container runtime sanity check failed: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Container runtime status is nil"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; </span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Container runtime status: %v"</span>, s)</span><br><span class="line">	<span class="comment">//检查 network 和 runtime 是否处于 ready 状态</span></span><br><span class="line">	networkReady := s.GetRuntimeCondition(kubecontainer.NetworkReady)</span><br><span class="line">	<span class="keyword">if</span> networkReady == <span class="literal">nil</span> || !networkReady.Status &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Container runtime network not ready: %v"</span>, networkReady)</span><br><span class="line">		kl.runtimeState.setNetworkState(fmt.Errorf(<span class="string">"runtime network not ready: %v"</span>, networkReady))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Set nil if the container runtime network is ready.</span></span><br><span class="line">		kl.runtimeState.setNetworkState(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// information in RuntimeReady condition will be propagated to NodeReady condition.</span></span><br><span class="line">	<span class="comment">//获取运行时状态</span></span><br><span class="line">	runtimeReady := s.GetRuntimeCondition(kubecontainer.RuntimeReady)</span><br><span class="line">	<span class="comment">// If RuntimeReady is not set or is false, report an error.</span></span><br><span class="line">	<span class="keyword">if</span> runtimeReady == <span class="literal">nil</span> || !runtimeReady.Status &#123;</span><br><span class="line">		err := fmt.Errorf(<span class="string">"Container runtime not ready: %v"</span>, runtimeReady)</span><br><span class="line">		klog.Error(err)</span><br><span class="line">		kl.runtimeState.setRuntimeState(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	kl.runtimeState.setRuntimeState(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">//调用 kl.initializeRuntimeDependentModules 启动依赖模块</span></span><br><span class="line">	kl.oneTimeInitializer.Do(kl.initializeRuntimeDependentModules)</span><br><span class="line">	kl.runtimeState.setRuntimeSync(kl.clock.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateRuntimeUp会获取container运行状态信息，然后根据返回RuntimeStatus检查网络、runtime是不是已经处于ready状态；接着调用kl.initializeRuntimeDependentModules初始化依赖模块，这里会启动cadvisor、containerManager、evictionManager、containerLogManager、pluginManager；最后设置Runtime同步时间。</p>
<p>最后看看syncLoop方法</p>
<h3 id="syncLoop"><a href="#syncLoop" class="headerlink" title="syncLoop"></a>syncLoop</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) syncLoop(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler) &#123;</span><br><span class="line">	...</span><br><span class="line">  syncTicker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">	housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">	<span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">	plegCh := kl.pleg.Watch()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">		<span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>syncLoop方法在一个循环中不断的调用 <code>syncLoopIteration</code> 方法执行主要逻辑。</p>
<h3 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a><strong>syncLoopIteration</strong></h3><p>syncLoopIteration方法比较长，拆开来看。</p>
<h3 id="syncCh"><a href="#syncCh" class="headerlink" title="syncCh"></a>syncCh</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	<span class="comment">//方法会监听多个 channel，当发现任何一个 channel 有数据就交给 handler 去处理，在 handler 中通过调用 dispatchWork 分发任务</span></span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="keyword">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">//该模块将同时 watch 3 个不同来源的 pod 信息的变化（file，http，apiserver），</span></span><br><span class="line">		<span class="comment">//一旦某个来源的 pod 信息发生了更新（创建/更新/删除），这个 channel 中就会出现被更新的 pod 信息和更新的具体操作；</span></span><br><span class="line">	<span class="keyword">case</span> u, open := &lt;-configCh: </span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"Update channel is closed. Exiting the sync loop."</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (ADD, %q): %q"</span>, u.Source, format.Pods(u.Pods)) </span><br><span class="line">			handler.HandlePodAdditions(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (UPDATE, %q): %q"</span>, u.Source, format.PodsWithDeletionTimestamps(u.Pods))</span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (REMOVE, %q): %q"</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">			handler.HandlePodRemoves(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (RECONCILE, %q): %q"</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">			handler.HandlePodReconcile(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (DELETE, %q): %q"</span>, u.Source, format.Pods(u.Pods)) </span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.SET: </span><br><span class="line">			klog.Errorf(<span class="string">"Kubelet does not support snapshot update"</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			klog.Errorf(<span class="string">"Invalid event type received: %d."</span>, u.Op)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>configCh</code> 读取配置事件的管道，该模块将同时 watch 3 个不同来源的 pod 信息的变化（file，http，apiserver），一旦某个来源的 pod 信息发生了更新（创建/更新/删除），这个 <code>channel</code> 中就会出现被更新的 pod 信息和更新的具体操作。这里对于pod的操作我们下一篇再讲。</p>
<h3 id="plegCh"><a href="#plegCh" class="headerlink" title="plegCh"></a>plegCh</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	<span class="comment">//方法会监听多个 channel，当发现任何一个 channel 有数据就交给 handler 去处理，在 handler 中通过调用 dispatchWork 分发任务</span></span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="keyword">bool</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">		<span class="keyword">if</span> e.Type == pleg.ContainerStarted &#123;</span><br><span class="line">			kl.lastContainerStartedTime.Add(e.ID, time.Now())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> isSyncPodWorthy(e) &#123; </span><br><span class="line">			<span class="keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">				klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (PLEG): %q, event: %#v"</span>, format.Pod(pod), e)</span><br><span class="line">				handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">				klog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (PLEG): ignore irrelevant event: %#v"</span>, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line">			<span class="keyword">if</span> containerID, ok := e.Data.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">				kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PLEG.Start 的时候会每秒钟启动调用一次relist，根据最新的 PodStatus 生成PodLiftCycleEvent，然后存入到 <code>PLEG Channel</code> 中。</p>
<p><code>syncLoop</code> 会调用 <code>pleg.Watch</code> 方法获取 <code>PLEG Channel</code> 管道，然后传给syncLoopIteration方法，在syncLoopIteration方法中也就是plegCh这个管道，syncLoopIteration会消费plegCh中的数据，在 handler 中通过调用 dispatchWork 分发任务。</p>
<h3 id="syncCh-1"><a href="#syncCh-1" class="headerlink" title="syncCh"></a>syncCh</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="keyword">bool</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//	每秒钟会执行到一次</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line">		<span class="comment">// Sync pods waiting for sync</span></span><br><span class="line">		podsToSync := kl.getPodsToSync()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (SYNC): %d pods; %s"</span>, <span class="built_in">len</span>(podsToSync), format.Pods(podsToSync))</span><br><span class="line">		<span class="comment">//同步最新保存的 pod 状态</span></span><br><span class="line">		handler.HandlePodSyncs(podsToSync)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>syncCh是由syncLoop方法里面创建的一个定时任务，每秒钟会向syncCh添加一个数据，然后就会执行到这里。这个方法会同步所有等待同步的pod。</p>
<h3 id="livenessManager-Updates"><a href="#livenessManager-Updates" class="headerlink" title="livenessManager.Updates"></a>livenessManager.Updates</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="keyword">bool</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line">		<span class="comment">//如果探针检测失败，需要更新pod的状态</span></span><br><span class="line">		<span class="keyword">if</span> update.Result == proberesults.Failure &#123; </span><br><span class="line">			pod, ok := kl.podManager.GetPodByUID(update.PodUID)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123; </span><br><span class="line">				klog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (container unhealthy): ignore irrelevant update: %#v"</span>, update)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			klog.V(<span class="number">1</span>).Infof(<span class="string">"SyncLoop (container unhealthy): %q"</span>, format.Pod(pod))</span><br><span class="line">			handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对失败的pod或者liveness检查失败的pod进行sync操作。</p>
<h3 id="housekeepingCh"><a href="#housekeepingCh" class="headerlink" title="housekeepingCh"></a>housekeepingCh</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(kl *Kubelet) syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="keyword">bool</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//	每两秒钟执行一次</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">		<span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123; </span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (housekeeping, skipped): sources aren't ready yet."</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"SyncLoop (housekeeping)"</span>)</span><br><span class="line">			<span class="comment">//执行一些清理工作，包括终止pod workers、删除不想要的pod，移除volumes、pod目录</span></span><br><span class="line">			<span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Failed cleaning pods: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>housekeepingCh</code> 这个管道也是由 <code>syncLoop</code> 创建，每两秒钟会触发清理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>kubelet.Run</code> 部分主要执行kubelet包含的各种manager的运行，大部分会以一部线程的方式定时运行。接下来看了syncLoop主函数，这个函数主要对pod的生命周期进行管理，包括对pod进行add 、update、remove、delete等操作，这些具体的代码执行过程留到下一篇，pod的初始化时再讲，syncLoop还需要更新根据不同的channel触发不同的操作，如更新runtime缓存、同步pod、触发清理pod、liveness检查失败的pod进行sync操作等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000021603262" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000021603262</a></li>
<li><a href="https://qiankunli.github.io/2018/12/31/kubernetes_source_kubelet.html" target="_blank" rel="external nofollow noopener noreferrer">https://qiankunli.github.io/2018/12/31/kubernetes_source_kubelet.html</a></li>
<li><a href="https://www.bookstack.cn/read/source-code-reading-notes/kubernetes-kubelet-modules.md" target="_blank" rel="external nofollow noopener noreferrer">https://www.bookstack.cn/read/source-code-reading-notes/kubernetes-kubelet-modules.md</a></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/3bc1a603/" rel="bookmark">【Kubernetes】ApiServer 启动分析</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/4cc9f1a2/" rel="bookmark">【Kubernetes】Liveness/Readiness Probe</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/d8b96fe4/" rel="bookmark">【Kubernetes】开篇</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/b0614056/" rel="bookmark">【Kubernetes】API Install</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/1141907b/" rel="bookmark">【Kubernetes】Apiserver Install</a></div>
    </li>
  </ul>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/wechatpay.png" alt="Houmin 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/alipay.jpg" alt="Houmin 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Houmin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://houmin.cc/posts/fb705539/" title="【Kubernetes】Kubelet">http://houmin.cc/posts/fb705539/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/k8s/" rel="tag"><i class="fa fa-tag"></i> k8s</a>
              <a href="/tags/kubelet/" rel="tag"><i class="fa fa-tag"></i> kubelet</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/posts/89dc9bfd/" rel="next" title="【Kubernetes】Container Runtime Interface">
                  <i class="fa fa-chevron-left"></i> 【Kubernetes】Container Runtime Interface
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/posts/b88b921f/" rel="prev" title="【Kubernetes】Pod">
                  【Kubernetes】Pod <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#功能分析"><span class="nav-number">1.</span> <span class="nav-text">功能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pod-管理"><span class="nav-number">1.1.</span> <span class="nav-text">pod 管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#监听-API-Server"><span class="nav-number">1.1.1.</span> <span class="nav-text">监听 API Server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Static-Pod"><span class="nav-number">1.1.2.</span> <span class="nav-text">Static Pod</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器健康检查"><span class="nav-number">1.2.</span> <span class="nav-text">容器健康检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cAdvisor-容器监控"><span class="nav-number">1.3.</span> <span class="nav-text">cAdvisor 容器监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubelet-Eviction"><span class="nav-number">1.4.</span> <span class="nav-text">Kubelet Eviction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作原理"><span class="nav-number">2.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SyncLoop"><span class="nav-number">2.1.</span> <span class="nav-text">SyncLoop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initializeModules"><span class="nav-number">3.1.</span> <span class="nav-text">initializeModules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fastStatusUpdateOnce"><span class="nav-number">3.2.</span> <span class="nav-text">fastStatusUpdateOnce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syncLoop"><span class="nav-number">3.3.</span> <span class="nav-text">syncLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syncLoopIteration"><span class="nav-number">3.4.</span> <span class="nav-text">syncLoopIteration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syncCh"><span class="nav-number">3.5.</span> <span class="nav-text">syncCh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#plegCh"><span class="nav-number">3.6.</span> <span class="nav-text">plegCh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syncCh-1"><span class="nav-number">3.7.</span> <span class="nav-text">syncCh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#livenessManager-Updates"><span class="nav-number">3.8.</span> <span class="nav-text">livenessManager.Updates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#housekeepingCh"><span class="nav-number">3.9.</span> <span class="nav-text">housekeepingCh</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Houmin" src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/theme/avatar.png">
  <p class="site-author-name" itemprop="name">Houmin</p>
  <div class="site-description" itemprop="description">丈夫拥书万卷，何假南面百城</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">223</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SimpCosm" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SimpCosm" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:weihoumin@gmail.com" title="E-Mail &amp;rarr; mailto:weihoumin@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="hitokoto">
    <!-- hitokoto -->
    <div id="hito-expression">:D 获取中...</div>

    <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
    <script>
      fetch('https://v1.hitokoto.cn')
        .then(function (res){
          return res.json();
        })
        .then(function (data) {
          var hitokoto = document.getElementById('hito-expression');
          hitokoto.innerText = data.hitokoto + '——【' + data.from + '】';
        })
        .catch(function (err) {
          console.error(err);
        })
    </script>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houmin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">59:37</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>



  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '800px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'iEBFuhVyk4tuhVYctQ265uid-gzGzoHsz',
    appKey: 'KGjOktrtgSEWK1v9DYA3T3Az',
    placeholder: "Just go go",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
