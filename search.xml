<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>明天</title>
    <url>/posts/5767840f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>也许明天…</p>
<p>明天会怎样？明天的我，明天的你，明天的故事……未知<br>昨天的故事才刚刚过去，仍不时带给我回忆</p>
<p>但今日的忙碌，却似乎容不得我慢慢的回忆，生活如一股洪流推动着我继续向前。<br>今日我用这些拙劣的文字来记忆此时我的心情，仅留给明日的我一个成长的印记。</p>
<a id="more"></a>
<p>就在一年前，我，一个高中生，普普通通、认认真真，我眼中的我</p>
<p>那时的我，执着于分数、排名，刷题、改错，这似乎是我高中生涯的最深刻的回忆，这样的高中生活，该怎样评判，是是非非，此时的我尚无法判明这段生活对于我真正的意义。</p>
<p>让我再来细细捋一捋那时的生活：</p>
<p>每一天早上是6点还是6点10分就要跑步来着？具体时间点忘了。但是一直以来，我对于早上起床这件事就没多大兴趣，能尽量晚就尽量晚，一般是离跑步开始还有10分钟的时候才一跃而起，匆匆洗刷完毕后就奔向寝室阶梯下集合，虽然在这一二十分钟前我已醒来，但就是要赖在床上（鄙视） ,虽然经常集合迟到，被C残忍的记上名字。</p>
<p>在经历了精力充沛的早读后，在下课铃的鞭策下迅速奔向食堂，不过到高三后期这个习惯似乎有点懈怠了，吃完饭后游到寝室，削个苹果，一路啃将下来，到达四楼的教室正好吃完（精确，哈哈），那个时候到达教室的几条路线现在清晰如故</p>
<p>很喜欢在教学楼间转来转去的感觉</p>
<p>到教室后，要么改错，要么做英语阅读，或者其他，印象不太深了</p>
<p>接下来上课，高三所有的课中，感觉除了语文和数学之外，其他的都不太喜欢，老想自己在下面干自己的事，哦对了，体育也不错</p>
<p>确实挺喜欢ZH和XH二位的，赞之 </p>
<p>那个时候刷理综的冲动挺大的，所以上课、午休、自习 都想刷，好像每天都想刷一套理综。对了，刷 这个字好像是高考后才学会的，之前是不会的那个时候的中午基本上都是不睡的，好像小时候就不喜欢睡午觉，那时好像也没觉着有什么，倒是现在越来越渴望睡午觉了（叫你每天睡那么晚-&gt;_-&gt; ) </p>
<p>接下来，下午上课、下午自习、晚上跑步、晚自习，到后期基本上是做卷子了</p>
<p>再后来，211</p>
<p>211时好像也没什么，倒反而觉得轻松许多，毕竟有好多自己的时间了（嗯，可以更好的刷理综了，哈哈）</p>
<p>当时的我是没有任何电子设备的，没有QQ,微信，人人，邮箱，不知道智能手机这一概念，不知道jobs的伟大，甚至还很奇怪为什么英语阅读里老是jobs，不知道office，什么PPT，Word概念是没有的。</p>
<p>今天来看，那段日子自有它的纯真</p>
<p>不知道明天将会如何看待那时与今日</p>
<p>对于初中，现在印象也渐渐淡了，那时的作业是什么时候完成的都已不记得。那时候是骑车上学的，初三后每天晚上9点多下课后就迅速骑车回家。在家里等待我的是妈妈准备好的一大碗面，吃地我撑撑的。其实妈妈本来也很困，但是还是坚持等到我回家。</p>
<p>毕竟那时升Y中压力很小，以致于现在对于那是上课的记忆都远了，只留下模糊的影子，倒是课间玩耍的景象清晰得多<br>初中有一个很喜欢的女孩，喜欢她的眼睛，清澈。祝现在的她安好</p>
<p>对了，初中有一幕是清晰的：第一次上晚自习时看窗外的天空从火黄到靛蓝。 这与高中第一次睡集体宿舍时清晰记忆是十分相像的。说到集体宿舍，那个暑假是509吧，还记得某位考完数学后十分亢奋激昂，虐待一下了可怜的木板床。过了暑假后就搬到我们的特享寝室了~ </p>
<p>那个暑假还是相当郁闷的，正如那个暑假的阴雨，各种不顺，最后还是扛过来了。伴随那段记忆，每天早上的tell me why 和 星月神话至今还是我很喜欢的歌，虽然那段tell me why的歌词在那时根本没听懂过<br>说的是明天，却又习惯性的提起了昨日，且当是整顿行囊，再度出发吧</p>
<p>至于明天的故事，有明天的你在</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>高中</tag>
      </tags>
  </entry>
  <entry>
    <title>新学期，新气象</title>
    <url>/posts/ad8bd1fd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>正是一年好春光，蓝天与暖阳共舞，春风催新芽。想起初中这个时候开学，学校必然会贴上“新学期，新气象”这类的标语。虽然是新学期，新气象却不一定能保证了。但是作为一个美好的愿望，也是极好的。毕竟旧这个字似乎总是和不好的东西联系在一起，过个新年，大家都要穿上新衣服，新鞋样，买些新笔记本，换上一份新心情。且将那一切旧的东西扫将出去，再不相见。</p>
<a id="more"></a>
<p>刚刚过完春节的我们，也许是在家都吃得好好的，再加上正是发育时期，回来后个个都像雨后春笋一节一节的向上长。紧接着，伴随着开学大扫除，新学期的生活照旧就开始了。毕竟初中好过，每天也就照例跟着老师上上课，做做作业，一切似乎都渐归于常态。这时候放学后也比较清闲，放学归途，磨磨蹭蹭，没心没肺，过的也还不赖。清人高鼎诗云：</p>
<blockquote class="blockquote-center"><p>​          草长莺飞二月天，拂堤杨柳醉春烟。<br>​          儿童散学归来早，忙趁东风放纸鸢。</p>
</blockquote>
<p>说的大概就是这种场景。至于说放风筝，还是小学时候的事，后来就很少了。</p>
<p>傻乎乎的再过些日子，就到了清明。清明时节最是羡人的便是那漫山遍野的油菜花了。也许漫山遍野这个词说的不太对，毕竟家周围也没有什么山，倒是长江近在眼前。放学后，骑个自行车在河堤上走，江内江外皆是那金黄与翠绿掩映的油菜花，煞是好看。清明这个日子在中国人眼里似乎总是带着淡淡的忧伤，从杜牧的“清明时节雨纷纷，路上行人欲断魂” 到陆游的“ 素衣莫起风尘叹，犹及清明可到家” ，都是要到先人面前，缅怀深思的。每年的扫墓是必不可少的，直到现在离家在外。记得每次去的时候，墓边长得正是脆嫩的各种绿色植物，夹带着前几天留下来的雨滴，我们在墓顶贴上打好的纸钱，然后在妈妈的指挥下进行一场烧纸、叩拜的庄严仪式，现在想起来也很是怀念。</p>
<p>接下来就是五一、端午，就这样一学期就被这几个节日给完美分割，自己也就有了更多的期待。然而其实年复一年都是像这样的，在上学中想着放假，放假过后又怀恋着过的如此之快的假期，也就无所谓什么新学期，新气象了。倒是随着年岁虚长，自己也逐渐麻木了。只是毕竟是新年，毕竟是新学期，不在这个时候表表宣言，说说志向感觉是不太好意思的，不然岁月匆匆，自己走过却了无痕迹，岂不痛哉？</p>
<p>想想上学期拟定的计划，大多已落空，心中不免难堪和沮丧。单是早起这一项千年之困疾，仍没解决。不过毕竟没有在睡得那么晚了，12点前已基本上床，甚好。再有跑步锻炼这一项，又因天气冷、要上课等等原因给拖延，实在是惭愧，唉，再不锻炼说不定就赘肉累累了。至于其他之如看书、记单词，也当再做筹划。毕竟，很多事说得却不一定做得，做得却不需要说得。</p>
<p>新学期，新气象  ==<strong><em>__</em></strong>==  </p>
<p>刚刚开年，便热闹的很。先是红包，duang，衣服，再是雾霾。喜欢柴静的态度，不管别人怎么说，自己还是做自己的事。不管怎么说 ， just  do something ……</p>
<p>又是废话连篇，不知所云……</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>春天</tag>
      </tags>
  </entry>
  <entry>
    <title>人在旅途</title>
    <url>/posts/7b125ab3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>越来越不喜欢到处走动了，简直成了一个装在一个固定套子里面的人。不止是对去各处旅行丝毫提不起兴趣，就连去附近超市都懒得动弹。对了，就连明天的同学会，也不想去。</p>
<a id="more"></a>
<p>如果说契诃夫笔下装在套子里面的人是对于传统道德的卫道士的话，我只能算是一个旧的价值体系被击碎得七零八落，而新的价值体系尚未建立起来的徘徊不前者。</p>
<p>为什么现在不想出去走动？</p>
<p>与其回答这个问题，我更喜欢回答为什么当初喜欢四处走动的原因。从高中升入大学，面对着崭新的世界（姑且这么称之），自然有一种探索的欲望，更何况是第一次拥有了行动自由权。从最开始的北京各处野长城之行、到大一业毕的北京-北戴河骑行之旅，从冰天雪地的东北、到清风椰影的东南，从苏杭的江南别院、到登封的天地之中。哦对了，还有那次APEC假期与期中考试矛盾中的山东作死之旅。这一切的一切，都是在体验祖国大好风光这个幌子下面进行的爱国主义事业。或者说，是源自于那个“世界这么大，我想去看看”的原始冲动。<br>然而，随着走的地方越来越多，对于旅行的目的的质疑也越来越大。更直白的说，随着年纪越来越大，一把老身子骨开始抱怨:为什么要这么舟车劳顿去看那些我在图片和宣传片上就可以欣赏的美景，甚至于实际的景色都远远不及我所期待的；为什么我要吃不好、喝不好、睡不好地去坐K字列车，去到一个人挤人的地方；为什么我要浪费这么多金钱去追求我本可以在阅读和观看记录片中获得的东西，而且收效甚微？<br>这个时候的我，简直就是于斯曼小说《逆流》中的德埃桑迪斯。19世纪末的英国社会正如今日中国，随着工业社会的进一步发展，人们也纷纷走出自己常年寓居的方圆百里。然而，摩肩接踵的人群、同质化的风景，却让我倍感失望。</p>
<hr>
<blockquote>
<p>“回忆和期待一样，是一种简化和剪辑现实的工具。”</p>
</blockquote>
<p>除了回忆和期待，语言、文字、图片、视频更是简化和剪辑现实最为直接的成果。我们所看到的图片和宣传片都是经过精心选择的，你很难说它们是假的，它们确实可能曾经实实在在地存在于那里。但是正如艺术作品在构型的时候具有极强的选择性和简单化，在现代生活中，我们还必须忍受那些被艺术所忽略的环节。为了看到这美丽的一瞬，你不得不忍受路途上的艰苦、饮食上的不顺、脱离日常常规活动的彻夜狂欢。当亲身处于我们所魂牵梦萦的地方的时候，我们面对的一个挑战在于如何快速聚焦于那些美的瞬间，如何忽略那些生活中的无聊时刻。</p>
<hr>
<p>脑袋中的小人A跳出来，“所以到底有什么吸引你去突破这些冗杂的旅行事物？”<br>小人B说，“异国情调——我想去看希腊海岸，我想去看英伦风光，我想去看日本樱花，我想去乘着邮轮畅游深海……”<br>小人C说，“壮阔——如果这个世界不公平，或让人无法理解，那么壮阔的景致会提示我们，世间本来就是如此，没有什么好大惊小怪的。”<br>……</p>
<hr>
<p>这篇文章从2月13号开始写，一直拖到现在继续写，这是一种怎样的拖延症……<br>告别了近一个月的寒假，今天再次回到北京。</p>
<blockquote>
<p>“回到北京？”<br>“回家？”</p>
</blockquote>
<p>潜意识里两个地方都用了回字，但是仿佛两个地方都不是我的故乡。在故乡，对于所谓的家的温暖，感受始终是复杂的。一方面，家作为亲人团聚的地方，爸爸妈妈亲切的照顾，确实会让人忘记在北京的那种冷漠的感觉；另一方面，由于所受教育的不同，父母和自己在价值观上存在明显的分歧，有很多东西是不会跟他们说的。这就是一种他们虽然爱我，但是却不能找到思想的共鸣。故乡是回不去了，然而北京，却也始终还没有找到一个心灵的归属。一到北京，顿时感觉心理压力加了一层。各人自顾自的地铁，就连视线都不知道停留在何方，只好沉浸在自己的电子世界。茨威格说，“在这个世界上，再也没有比置身于人群之中，却又得孤独生活更可怕的事情了”，无论在哪里，都不再具有归属感。心灵不再拥有故乡，永远在漂泊，永远在旅行。</p>
<hr>
<blockquote>
<p>“因为我有幸孤身独处，虽然我从来并不孤独，我只是独自一个人而已，独自生活在稠密的思想之中，因为我有点儿狂妄，是无限和永恒中的狂妄分子，而无限和永恒也许就喜欢我这样的人。”</p>
</blockquote>
<p>我没有赫拉巴尔那般博学多才，我只是一个普普通通的工科生，但是像生命、人生这种哲学命题是一个人终身都必须面对的问题。有时候脑袋卡在这个问题上，便失去了继续思考的勇气，整个人就像完全泄了气的皮球，什么事情都提不起兴趣，大脑开始神游，要不然就是刷各种手机软件，或者是刷电影，让自己的大脑停止思考。<br>简单的说，这就是无聊……或者说，这就是孤独与寂寞。<br>有时候会想，如果有个妹子该多好。但是很明显，这种连一个人都过不好的生活，我该怎么迎接生命中的那个她进入我的生活。</p>
<hr>
<p>我只是想要一个“自洽”的自我。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>G94 和 G524</title>
    <url>/posts/7c931de4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>伴着细细的秋雨，一行人拖着行李，告别了暑假，告别了嵩阳书院，再次回到燕园。正是下午一两点，沿路的人并不多，随着新学期的到来，学校也不再是北京工地大学的模样，博实路边新修的宿舍楼里已经有学生入住，尽管未名上还有着关于宿舍楼甲醛的质疑，宿舍楼间的银杏走道已经恢复，让人期待着秋页烂漫，只有那些坑坑洼洼的道路尚能触动暑假中学校连夜破土动工的记忆。</p>
<a id="more"></a>
<p>一路走来，今年的开学季相对与以往似乎并没有什么区别，三大手机运营商依旧早早地在学校搭好了各自的阵地，大声地招徕着过往的同学。一进入校门就有个学长吐嘲说，“一进学校就成大四狗了”；另一个同学则说，“不不不，还有三天呢，14号才正式开课呢”，这样讲好像也有道理。那么，静静享受这三天时光，准备做一只大三狗吧，哈哈。</p>
<p>本来这个暑假是并不打算回家的。</p>
<p>在一个看似还不错的学期匆匆结尾后，就马上跟随着学院的暑期实践团赶去了厦门，得以一见在我心中久久期待的东南风光，一周的体验过去后，虽然没干多少正事，还真有点怀念呢。从福建回来，接着上了一个月的暑期学校，因为多选了两门课，从周一到周四，上午到下午似乎都在上课。学完太极拳，用VHDL写完贪吃蛇，到八月初，刚刚上完暑期课还没两天，三个室友就纷纷回家了。打开寝室门，面对空荡荡的寝室，我顿时产生了一种想要回家的冲动。</p>
<p>我向来认为自己是一个感情冷漠的人，也许事实也确实如此。</p>
<p>尽管离家千里，并没有产生很深的思家情绪，倒总是家里人给我打电话。这个暑假鉴于还有一些作业没有做完，本来就做好了不回家，八月底直接去嵩山的打算。暑期课结束前，家里打来电话，告知了大舅去世的消息，希望我能够回家一趟，我当即就以暑期课没借口为由拒绝了。</p>
<p>从小因为家庭间的种种原因，妈妈和大舅家的关系并不是很和睦，然而每一次节气，原来老一辈的一大家子人又总要聚在一起，说一些家常里小，说一些言不及衷的闲话，每一次我都有一种想要逃离的感觉。然而毕竟身体里流着相同的血脉，可以感受得到，大舅对于我们这些晚辈有一种发自内心的喜爱，一方面这个大家里我们这一辈孩子的成绩都还不错，满足了他和同伴吹牛的虚荣心，另一方面他一直对我们小辈以他的方式表现出极大的热情，尽管他的那种热情我一直不太愿意接受。</p>
<p>早在上次寒假归家，大家对于大舅的病情已了然于心，对于在这时去世，大家心里也早就做好了准备。也许，对于大舅他自己，也是如此。我可以想及回家后的场面，一大家子人因为这件事再次聚集到一起，努力为大舅办好最后一件事。也许会有按时出现的哭喊，虽然可能听起来是那么的撕裂人心；也许会有和乐融融的麻将桌，虽然大家白天忙累了很多；也许会有……</p>
<p>我不懂得这种仪式的意义，我不喜欢这种仪式的氛围。如果一种礼仪丧失了它本来的意义，那么它还有什么存在的价值呢？也许这只是我的借口，但，我不想置身这种环境。就这样，我接着又在学校呆了两个星期，紧赶慢赶，终于在二十号之前写完了作业，赶上了高铁，踏上了回家的行程。</p>
<p>家究竟是什么？从小便在各种矫情的作文里写过什么“心灵的港湾”、“灵魂的驿站”、“生活的加油站”，但是我并没能真正的懂得这些句子。家究竟是什么，也许仍然会有不愉快存在，但家始终是那个你最能舒心的位置，最无所顾忌的位置。这个暑假在家短短一周，除了在外面，真正和爸妈在一起也没有多少时间。几年后的日子应该也都会是这个样子了，且说珍重。</p>
<p> 八月二十七日，G94从武汉至郑州，感谢杨君的一路相送。 </p>
<p>这次来嵩山，本来也是抱着放松一下的心态去玩的。但是嵩阳书院的人显然不是这么想的( ▼-▼ )。每一天都不到六点就得爬起来，各种行程安排的严丝合缝。但从另一方面想倒也不错，这个暑假除了在家的那个星期都做到了八点前起来，私以为对我来说也算是个不错的成就咯。两个星期，从未如此深入了解一个陌生的城市。</p>
<p>四战之地，天地之中，千百年历史在这里汇聚在一起。浅薄如我并不能真正懂得各种建筑、雕刻的艺术之美，幸好周围有懂得那么多的师兄师姐们，幸好周围有对真正的美有极大热情的他们。一直自称为历史爱好者，然而对于历史的把握也只是在很浅的层次，真正折服于导读师兄师姐的知识储备；一直说对传统儒家有兴趣，然而这是第一次真正开始读《大学》、《诗经》、《论语》、《孟子》，真正折服于导读师兄师姐的信手拈来。</p>
<p>从小接受无神论教导的我，这一次近距离的接触了道家和佛家，先后听了两位禅师的讲佛和一位道长的讲道，和之前所接触的佛道不到，这一次总算从他们那里听到了一些颇有些哲理的东西，虽然他们没有真正说服我，但是这次能够近距离接触他们，也算是一次不错的体验吧。最后，每天早上大家一起拿着竹扫帚在古色古香的书院里洒扫应对，真的挺有感觉的呢。</p>
<p>九月十日，G524归京，是以记。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>Regular Expression</title>
    <url>/posts/cf8e9225/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>  正则表达式，就是处理字符串的方法，它是以行为单位进行字符串的处理行为，正则表达式通过一些特殊符号的辅助，可以让使用者轻易的达到<code>搜索/取代/删除</code>某个特定字符串的处理程序。正则表达式基本上是一种表示法，只要工具程序支持这种表示法，那么该工具程序就可以用来作为正则表达式的字符串处理之用。例如vi、grep、awk、sed等工具，因为它们支持正则表达式，所以这些工具可以使用正则表达式的特殊字符来进行字符串的处理。但是例如cp、ls等指令并未支持正则表达式，所以只能使用bash自己本身的通配符而已。</p>
<a id="more"></a>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><h2 id="前向引用"><a href="#前向引用" class="headerlink" title="前向引用"></a>前向引用</h2><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>  当正则表达式中包含能接受重复的限定符时，通常的行为是(在使整个表达式能得到匹配的前提下)匹配 <strong>尽可能多</strong> 的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 <em>aabab</em> 的话，它会匹配整个字符串 <em>aabab</em> 。这被称为 <strong>贪婪匹配</strong>。<br>  有时，我们更需要 <strong>懒惰匹配</strong>，也就是匹配 <strong>尽可能少</strong> 的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样 .*? 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：<code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><h2 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:left">将下一个字符标记为特殊字符，或者是一个原义字符，或一个向后引用，或一个八进制转义字符。如，”n”匹配”n”，”\n”匹配一个换行符，”\“匹配”\”,”(“匹配”(“</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">匹配字符串的开始位置</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:left">匹配字符串的结束位置</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em> 等价于{0,}</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:left">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:left">n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:left">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(. &#124; \n)”的模式</td>
</tr>
<tr>
<td style="text-align:center">x &#124; y</td>
<td style="text-align:left">匹配x或y。例如，“z &#124; food”能匹配“z”或“food”。“(z &#124; f)ood”则匹配“zood”或“food”</td>
</tr>
<tr>
<td style="text-align:center">[xyz]</td>
<td style="text-align:left">字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”，[afl] 代表 a 或 f 或 l的意思。\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符</td>
</tr>
<tr>
<td style="text-align:center"><sup><a href="#fn_xyz" id="reffn_xyz">xyz</a></sup></td>
<td style="text-align:left">排除型（negate）字符集合。匹配未列出的任意字符。搜寻的字符串可以是 (oog) (ood) 但不能是 (oot) ,那个 ^ 在 [] 内时,代表的意义是『反向选择』的意思。 例如,我不要大写字符,则为 <sup><a href="#fn_A-Z" id="reffn_A-Z">A-Z</a></sup>。</td>
</tr>
<tr>
<td style="text-align:center">[a-z]</td>
<td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符</td>
</tr>
<tr>
<td style="text-align:center"><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup></td>
<td style="text-align:left">排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“<sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>”可以匹配任何不在“a”到“z”范围内的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:left">匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:left">匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
</tr>
<tr>
<td style="text-align:center">\cx</td>
<td style="text-align:left">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:left">匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:left">匹配一个非数字字符。等价于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>。</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:left">匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:left">匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:left">匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:left">匹配任何非空白字符。等价于<sup><a href="#fn_\f\n\r\t\v" id="reffn_\f\n\r\t\v">\f\n\r\t\v</a></sup>。</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:left">匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:left">匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:left">匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:left">匹配任何非单词字符。等价于“<sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup>”</td>
</tr>
<tr>
<td style="text-align:center">\x<strong><em>n</em></strong></td>
<td style="text-align:left">匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码</td>
</tr>
<tr>
<td style="text-align:center">\u<strong><em>n</em></strong></td>
<td style="text-align:left">匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>“\r” 是return，回到行首，”\n”是newline，新起一行<br>  在windows中，换行必须为”\r\n”，<br>  在Linux中，换行为”\n”,”\r”会被识别为控制字符”^M”<br>  在Mac中，换行为”\r”</p>
</blockquote>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><p>  <strong> Reference: </strong> <a href="http://deerchao.net/tutorials/regex/common.htm" target="_blank" rel="external nofollow noopener noreferrer">常用正则表达式</a></p>
<p>  说明：正则表达式通常用于两种任务：1.验证，2.搜索/替换。用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和$。此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">说明</th>
<th style="text-align:left">正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网址(URL)</td>
<td style="text-align:left">[a-zA-z]+://<sup><a href="#fn_\s" id="reffn_\s">\s</a></sup>*</td>
</tr>
<tr>
<td style="text-align:center">IP地址(IP Address)</td>
<td style="text-align:left">((2[0-4]\d&#124;25[0-5]&#124;[01]?\d\d?).){3}(2[0-4]\d&#124;25[0-5]&#124;[01]?\d\d?)</td>
</tr>
<tr>
<td style="text-align:center">电子邮件(Email)</td>
<td style="text-align:left">\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*</td>
</tr>
<tr>
<td style="text-align:center">日期(年-月-日)</td>
<td style="text-align:left">(\d{4}&#124;\d{2})-((1[0-2])&#124;(0?[1-9]))-(([12][0-9])&#124;(3[01])&#124;(0?[1-9]))</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm#howtouse" target="_blank" rel="external nofollow noopener noreferrer">正则表达式30分钟入门教程</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB笔记</title>
    <url>/posts/f2195e8a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：<br>GDB主要帮忙你完成下面四个方面的功能：</p>
<ul>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ul>
<a id="more"></a>
<h2 id="编译生成调试信息"><a href="#编译生成调试信息" class="headerlink" title="编译生成调试信息"></a>编译生成调试信息</h2><p>一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -g hello.c -o hello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ -g hello.cpp -o hello</span></span><br></pre></td></tr></table></figure><br>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p>
<h2 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h2><p>使用<code>gdb &lt;program&gt;</code>就可以启动gdb用于调试程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">houmin@cosmos:~$ gdb hello</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</span><br><span class="line">and "show warranty" for details.</span><br><span class="line">This GDB was configured as "x86_64-linux-gnu".</span><br><span class="line">Type "show configuration" for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type "help".</span><br><span class="line">Type "apropos word" to search for commands related to "word"...</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行程序run，可以简写为r</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/houmin/hello</span><br><span class="line">hello world</span><br><span class="line">[Inferior 1 (process 3646) exited normally]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出gdb</span></span><br><span class="line">(gdb) quit</span><br><span class="line">houmin@cosmos:~$</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置程序参数</span></span><br><span class="line">(gdb) set args 10 20</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is "10 20".</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定运行参数，比如 run arg1 arg2</span></span><br></pre></td></tr></table></figure>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="栈信息"><a href="#栈信息" class="headerlink" title="栈信息"></a>栈信息</h3><p>不管是操作转储文件还是用GDB设置断点进行调试，都可以输入(GDB)bt打印栈内容进行查看。一般的当机BUG，看下当机的位置，然后看下源代码基本就可以解决了。但是很多情况下简单的(GDB)bt还查不到问题，这时候就要涉及到比较复杂的操作。下面罗列了一些对栈的操作：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) bt：显示所有栈帧。</span><br><span class="line">(GDB) bt 10：显示前面10个栈帧。</span><br><span class="line">(GDB) bt -10：显示后面10个栈帧。</span><br><span class="line">(GDB) bt full：显示栈帧以及局部变量。</span><br><span class="line">(GDB) bt full 10：显示前面10个栈帧以及局部变量。</span><br><span class="line">(GDB) bt full -10：显示后面10个栈帧以及局部变量。</span><br><span class="line">(GDB) frame &lt;栈帧编号&gt;：进入指定的栈帧中，然后可以查看当前栈帧中的局部变量，以及栈帧内容等信息。</span><br><span class="line">(GDB) info frame &lt;栈帧编号&gt;：可以查看指定栈帧的详细信息。</span><br><span class="line">(GDB) up：进入上层栈帧。</span><br><span class="line">(GDB) down：进入下层栈帧。</span><br></pre></td></tr></table></figure></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>调试BUG过程中查看变量信息是很有帮助的操作，查看方式如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) p &lt;变量名&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>对于调试来说寄存器中的值也很重要，可以查看到当前正在执行的指令的地址等。具体操作罗列如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) info reg：显示所有寄存器。可以简写为：i r。如果要查看具体的寄存器可以这样：i $ebx</span><br><span class="line">(GDB) p $eax：显示eax寄存器内容。</span><br><span class="line">(GDB) p/c $eax：用字符显示eax寄存器内容，反斜杠后面的是显示格式</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可使用的格式见下表：该表在显示内存内容的x命令中也是通用的。</span></span><br><span class="line">格式	说明</span><br><span class="line">x	显示为十六进制数</span><br><span class="line">d	显示为十进制数</span><br><span class="line">u	显示为无符号十进制数</span><br><span class="line">o	显示为八进制数</span><br><span class="line">t	显示为二进制数</span><br><span class="line">a	显示为地址</span><br><span class="line">c	显示为字符（ASCII）</span><br><span class="line">f	显示为浮点小数</span><br><span class="line">s	显示为字符串</span><br><span class="line">i	显示为机器语言（仅在显示内存的x命令中可用）</span><br></pre></td></tr></table></figure></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>可以查看具体内存地址中的内容，比如：目前执行的汇编指令，以及栈中内容等。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">(GDB) x <span class="variable">$pc</span>：显示程序指针指向位置的内容。</span><br><span class="line">(GDB) x/<span class="selector-tag">i</span> <span class="variable">$pc</span>：显示程序当前位置的汇编指令。</span><br><span class="line">(GDB) x/<span class="number">10</span>i <span class="variable">$pc</span>：显示程序当前位置开始往后的<span class="number">10</span>条汇编指令。</span><br><span class="line">(GDB) disassem <span class="variable">$pc</span>：反汇编当前函数。简写为：disas <span class="variable">$pc</span>。</span><br></pre></td></tr></table></figure></p>
<p>常见命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x/s 0xbffff890      # Examine a string stored at 0xbffff890</span><br><span class="line">x/20b sum           # Examine first 20 opcode bytes of function sum</span><br><span class="line">x/10i sum           # Examine first 10 instructions of function sum</span><br></pre></td></tr></table></figure></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) break &lt;函数名&gt;：对当前正在执行的文件中的指定函数设置断点。可简写为：(GDB) b &lt;函数名&gt;</span><br><span class="line">(GDB) break &lt;行号&gt;：对当前正在执行的文件中的特定行设置断点。可简写为：(GDB) b &lt;行号&gt;</span><br><span class="line">(GDB) break &lt;文件名：行号&gt;：对指定文件的指定行设置断点。最常用的设置断点方式。可简写为：(GDB) b &lt;文件名：行号&gt;</span><br><span class="line">(GDB) break &lt;文件名：函数名&gt;：对指定文件的指定函数设置断点。C++类中的方法似乎不好使。可简写为：(GDB) b &lt;文件名：函数名&gt;</span><br><span class="line">(GDB) break &lt;+/-偏移量&gt;：当前指令行+/-偏移量出设置断点。可简写为：b &lt;+/-偏移量&gt;</span><br><span class="line">(GDB) break &lt;*地址&gt;：指定地址处设置断点。可简写为：b &lt;*地址&gt;</span><br></pre></td></tr></table></figure>
<h4 id="查看和删除断点"><a href="#查看和删除断点" class="headerlink" title="查看和删除断点"></a>查看和删除断点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) info break ：显示所有断点以及监视点。可简写为：(GDB) i b</span><br><span class="line">(GDB) delete &lt;编号&gt;：删除编号指向的断点或者监视点。可简写为：(GDB) d &lt;编号&gt;</span><br><span class="line">(GDB) clear &lt;行号&gt;：删除该行的断点。</span><br><span class="line">(GDB) clear &lt;文件名：行号&gt;：删除该行的断点。</span><br></pre></td></tr></table></figure>
<h4 id="设置无效和有效断点"><a href="#设置无效和有效断点" class="headerlink" title="设置无效和有效断点"></a>设置无效和有效断点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) disable &lt;断点编号&gt; ： 当前断点设置为无效。</span><br><span class="line">(GDB) enable &lt;断点编号&gt;：当前断点设置为有效。</span><br></pre></td></tr></table></figure>
<h3 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h3><p>可以监视某个变量，在变量被访问或者被修改时程序会在当前点进入断点。删除，查看监视点的方式与断点相同。设置监视点方式如下        </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) watch &lt;表达式&gt;：表达式发生变化时暂停。</span><br><span class="line">(GDB) awatch &lt;表达式&gt;：表达式访问或者改变时暂停。</span><br><span class="line">(GDB) rwatch &lt;表达式&gt;：表达式被访问时暂停。</span><br></pre></td></tr></table></figure>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>在调试程序过程中，有时候我们只想在某个条件下停止程序，然后进行单步调试，而条件断点就是为此而设计。下面是条件断点的操作方式：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) b &lt;断点&gt; if &lt;条件表达式&gt; : 例如：b main.cpp:8 if x=10 &amp;&amp; y=10</span><br><span class="line">(GDB) condition &lt;断点编号&gt;：删除该断点的条件。</span><br><span class="line">(GDB) condition &lt;断点编号&gt; &lt;条件表达式&gt;：修改断点条件。例如：condition 1 x=10 &amp;&amp; y=10</span><br></pre></td></tr></table></figure></p>
<h3 id="断点命令"><a href="#断点命令" class="headerlink" title="断点命令"></a>断点命令</h3><p>每次断点发生时候，想要查看的变量很多时，如果每个变量都手动print则需要浪费很多时间。断点命令可以在断点发生时批量执行GDB命令。下面是断点命令的设置方式：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) commands &lt;断点编号&gt;</span><br><span class="line">(GDB) &gt;print x</span><br><span class="line">(GDB) &gt;print y</span><br><span class="line">(GDB) &gt;end</span><br></pre></td></tr></table></figure><br>首先输入GDB命令commands &lt;断点编号&gt;然后回车，这时候会出现&gt;提示符。出现&gt;提示符后可以输入断点发生时需要执行的GDB命令，每行一条，全部输入完成后输入end结束断点命令。</p>
<h3 id="反复执行"><a href="#反复执行" class="headerlink" title="反复执行"></a>反复执行</h3><p>单步执行时如果进入了你不关心的函数，你想立即跳出函数；或者进入了大循环中，你想立即循环。下面的命令可以帮到你：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) ignore &lt;断点编号&gt; &lt;次数&gt;：忽略N次断点。</span><br><span class="line">(GDB) c N： 执行N次指令，会忽略断点。</span><br><span class="line">(GDB) s/stepi/n/nexti N：往后执行N行，不会忽略断点。</span><br><span class="line">(GDB) finish：执行完当前函数后停止，不会忽略断点。</span><br><span class="line">(GDB) until：执行完当前循环后停止，不会忽略断点。</span><br><span class="line">(GDB) until &lt;地址&gt;：执行到指定地址停止。</span><br></pre></td></tr></table></figure></p>
<h3 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h3><p>对变量的值进行控制，可以更快的调试自己的程序。下面就是设置变量值的方法：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) set variable &lt;变量&gt; = &lt;表达式&gt;：将变量的值设定为指定表达式的值。例如 set variable x=10</span><br></pre></td></tr></table></figure></p>
<h3 id="手动生成转储文件："><a href="#手动生成转储文件：" class="headerlink" title="手动生成转储文件："></a>手动生成转储文件：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(GDB) generate-core-file 简写为：(GDB) gcore</span><br></pre></td></tr></table></figure>
<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.gnu.org/software/gdb/documentation/" target="_blank" rel="external nofollow noopener noreferrer">GDB官方文档</a></li>
<li><a href="http://beej.us/guide/bggdb/" target="_blank" rel="external nofollow noopener noreferrer">Beej’s Quick Guide to GDB</a></li>
<li><a href="http://blog.csdn.net/xinguimeng/article/details/50583488" target="_blank" rel="external nofollow noopener noreferrer">一篇优秀的gdb的总结</a></li>
<li><a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf" target="_blank" rel="external nofollow noopener noreferrer">gdbnotes-x86-64</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记</title>
    <url>/posts/fedfc052/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>LaTeX是基于TeX的文档排版系统。TeX是当初Knuth教授为了写作TAOCP而开发的个人排版软件，而LaTeX是Lamport博士为了编写自己的书籍而设计的。LaTeX实际上就是用TeX语言编写的一套宏代码，拥有比原来TeX格式(plain TeX)更为规范的命令和一整套预定义的格式，隐藏了不少排版上的细节。</p>
<a id="more"></a>
<h2 id="搭建LaTeX环境"><a href="#搭建LaTeX环境" class="headerlink" title="搭建LaTeX环境"></a>搭建LaTeX环境</h2><p>TeX/LaTex并不是单独的程序，而是复杂的软件包，里面包含了排版的专业引擎、编译脚本、格式转换工具、管理界面、支持工具、字体及数以千计的宏包和文档。一个TeX发行版就是把所有这些部件集合起来打包发布的软件。现在最为流行的发行版为CTeX套装和TeX Live。前者是Windows下面的软件，后者适用于各种操作系统。这里以TeX Live为例。</p>
<p>TeX Live是由TUG(TeX User Group)发布的一个发行版。</p>
<p>参考资料</p>
<ul>
<li><a href="http://www.linuxidc.com/Linux/2016-08/133913.htm" target="_blank" rel="external nofollow noopener noreferrer">Linux系统下原版TeX Live 2016的安装与配置</a></li>
<li><a href="http://www.ezlippi.com/blog/2015/03/install-texlive-in-ubuntu.html" target="_blank" rel="external nofollow noopener noreferrer">在Ubuntu下安装和编译LaTeX</a></li>
</ul>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><h4 id="下载TeX-Live镜像"><a href="#下载TeX-Live镜像" class="headerlink" title="下载TeX Live镜像"></a>下载TeX Live镜像</h4><p>本机环境为64位Ubuntu 16.04，下载发型版为Tex Live 2016。</p>
<h4 id="删除旧版"><a href="#删除旧版" class="headerlink" title="删除旧版"></a>删除旧版</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get purge tex-common</span></span><br></pre></td></tr></table></figure>
<h4 id="安装Perk-TK模块"><a href="#安装Perk-TK模块" class="headerlink" title="安装Perk-TK模块"></a>安装Perk-TK模块</h4><p>install-tl是一个perl脚本，要在专家GUI模式安装，需要加入XFT支持的Perl-TK模块<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install perl-tk</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安装主程序"><a href="#安装主程序" class="headerlink" title="安装主程序"></a>安装主程序</h3><h4 id="挂载ios镜像文件"><a href="#挂载ios镜像文件" class="headerlink" title="挂载ios镜像文件"></a>挂载ios镜像文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -o loop path_to.iso /mnt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /mnt</span></span><br></pre></td></tr></table></figure>
<h4 id="启动安装程序"><a href="#启动安装程序" class="headerlink" title="启动安装程序"></a>启动安装程序</h4><p>在加入了XFT支持的Perl-TK模块后，可以用以下方法启动GUI专家模式进行安装：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./install-tl -gui</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>选择安装方案。初级用户推荐直接选择 scheme-full 全部安装。如果磁盘空间有限也可以选择small或者median模式。高级用户可以选择scheme-custom进一步定制。这里我选择了scheme-custom，并且在“进一步定制”里去掉了自己不会用到的一些语言包和ConTeXt相关组件。</li>
<li>由于这里是安装到系统里，因此portable setup选择了否，安装路径为默认。</li>
<li>选项里面选择默认为A4纸张大小，其它一些选项基本都选了是。其中要注意的是创建符号链接会在 /usr/local/bin里面创建指向可执行程序的软链接，从而可以直接使用latex,pdflatex等命令，此外还可以使用man latex等命令查看帮助。</li>
<li>建议在最后的get package updates一项选否，等安装好了之后手动安装更新。</li>
</ul>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>配置<code>.bashrc</code>文件，在文件最后加上<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TEX_HOME=/usr/local/texlive/2016</span><br><span class="line">export PATH=$PATH:$TEX_HOME/bin/x86_64-linux</span><br><span class="line">export INFOPATH=$INFOPATH:$TEX_HOME/texmf-dist/doc/info</span><br><span class="line">export MANPATH=$MANPATH:$TEX_HOME/texmf-dist/doc/man</span><br></pre></td></tr></table></figure></p>
<p>进入home目录下输入命令使得修改的环境变量生效<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">houmin@cosmos:~$ source .bashrc</span><br></pre></td></tr></table></figure></p>
<h3 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">houmin@cosmos:~$ tex --version</span><br><span class="line">TeX 3.14159265 (TeX Live 2016)</span><br><span class="line">kpathsea version 6.2.2</span><br><span class="line">Copyright 2016 D.E. Knuth.</span><br><span class="line">There is NO warranty.  Redistribution of this software is</span><br><span class="line">covered by the terms of both the TeX copyright and</span><br><span class="line">the Lesser GNU General Public License.</span><br><span class="line">For more information about these matters, see the file</span><br><span class="line">named COPYING and the TeX source.</span><br><span class="line">Primary author of TeX: D.E. Knuth.</span><br></pre></td></tr></table></figure>
<p>安装完成<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo umount /mnt</span></span><br></pre></td></tr></table></figure></p>
<h3 id="配置字体"><a href="#配置字体" class="headerlink" title="配置字体"></a>配置字体</h3><p>XeTeX 和 LuaTeX 可以直接使用系统字体。然而 texlive 自带的字体并不在系统的字体目录里面。为了让系统可以使用texlive所带的字体，需要进行如下配置。</p>
<ul>
<li>将texlive的字体配置文件复制到系统内<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/local/texlive/2016/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/09-texlive.conf</span><br></pre></td></tr></table></figure></li>
<li>刷新系统字体缓存<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo fc-cache -fsv</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="更新源配置"><a href="#更新源配置" class="headerlink" title="更新源配置"></a>更新源配置</h3><p>配置合适的CTAN源可以加快宏包更新的网速，以中科大的源为例：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tlmgr option repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet</span><br></pre></td></tr></table></figure><br>之后可以利用tlmgr进行网络更新。CTAN 上的包更新很频繁，所以即便是最新版的texlive2016，其中也有大量的宏包需要更新（可能包括tlmgr程序本身）。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tlmgr update --self --all</span><br></pre></td></tr></table></figure></p>
<h3 id="dummy-package-安装"><a href="#dummy-package-安装" class="headerlink" title="dummy package 安装"></a>dummy package 安装</h3><p>texlive2016安装之后需要“告诉”系统texlive相关软件包都安装好了。这样在系统安装依赖于tex的软件（比如R）时就不必重新下载软件仓库中的旧版 texlive 相关软件。也不会造成不同版本 tex 命令的冲突。dummy package 就是解决这样的软件依赖问题的“虚包”。</p>
<h3 id="测试LaTeX"><a href="#测试LaTeX" class="headerlink" title="测试LaTeX"></a>测试LaTeX</h3><p>这个时候，在testTeX文件夹下编写hello.tex<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% hello.tex</span><br><span class="line">\documentclass&#123;beamer&#125;%声明文档类型</span><br><span class="line">\usetheme&#123;default&#125;%使用默认主题</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;frame&#125;&#123;A sample slide&#125;</span><br><span class="line"></span><br><span class="line">A displayed formula:</span><br><span class="line"></span><br><span class="line">\[</span><br><span class="line">\int_&#123;-\infty&#125;^\infty e^&#123;-x^2&#125; \, dx &#x3D; \sqrt&#123;\pi&#125;</span><br><span class="line">\]</span><br><span class="line"></span><br><span class="line">An itemized list:</span><br><span class="line"></span><br><span class="line">\begin&#123;itemize&#125;</span><br><span class="line">\item itemized item 1</span><br><span class="line">\item itemized item 2</span><br><span class="line">\item itemized item 3</span><br><span class="line">\end&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;theorem&#125;</span><br><span class="line">In a right triangle, the square of hypotenuse equals</span><br><span class="line">the sum of squares of two other sides.</span><br><span class="line">\end&#123;theorem&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译即可生成beamer格式的slide<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">houmin@cosmos:~/testTeX$ xelatex hello.tex</span><br></pre></td></tr></table></figure></p>
<p><img alt="LaTeX-Sample-Slide" data-src="/images/2017-03-05-latex-sample-slide.png"></p>
<p>这个时候测试中文是否可行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">我爱中国！</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译可以看到输出</p>
<p><img alt="LaTeX-Chinese" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-chinese.png"></p>
<p>不过编译的时候会出现warning<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*************************************************</span><br><span class="line">* fontspec warning: "script-not-exist"</span><br><span class="line">*</span><br><span class="line">* Font 'FandolSong-Regular' does not contain script 'CJK'.</span><br><span class="line">*************************************************</span><br><span class="line">)) (/usr/local/texlive/2016/texmf-dist/tex/latex/ctex/config/ctex.cfg)</span><br><span class="line">No file hello.aux.</span><br><span class="line">(/usr/local/texlive/2016/texmf-dist/tex/latex/tipa/t3cmr.fd)</span><br><span class="line">ABD: EverySelectfont initializing macros [1] (./hello.aux) )</span><br><span class="line">Output written on hello.pdf (1 page).</span><br><span class="line">Transcript written on hello.log.</span><br></pre></td></tr></table></figure></p>
<p>其实貌似这个时候的中文字体已经好了？<br>编写test.tex<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;CJKutf8&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125;</span><br><span class="line">这是一个楷体中文测试，处理简体字。</span><br><span class="line">\end&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span><br><span class="line">这是一个宋体中文测试，处理简体字。</span><br><span class="line">\end&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;bkai&#125;</span><br><span class="line">這是一個big5編碼的楷體中文測試，處理繁體文字。</span><br><span class="line">\end&#123;CJK&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;bsmi&#125;</span><br><span class="line">這是一個个big5編碼的明體中文測試，處理繁體文字。</span><br><span class="line">\end&#123;CJK&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><br>使用命令pdflatex，不知道为什么用xelatex不行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pdflatex test.tex</span></span><br></pre></td></tr></table></figure><br>生成pdf文件<br><img alt="LaTeX-Chinese-Sample" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-chinese-sample.png"></p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><h4 id="Atom编辑器"><a href="#Atom编辑器" class="headerlink" title="Atom编辑器"></a>Atom编辑器</h4><p>参考</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/24548752" target="_blank" rel="external nofollow noopener noreferrer">Atom编译器关于LaTex的简单编译配置</a></li>
</ul>
<h2 id="组织文本"><a href="#组织文本" class="headerlink" title="组织文本"></a>组织文本</h2><p>参考</p>
<ul>
<li><a href="http://www.liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="external nofollow noopener noreferrer">一份其实很短的LaTeX总结</a></li>
<li><a href="http://www.hustlei.tk/2014/08/latex-math-equation.html" target="_blank" rel="external nofollow noopener noreferrer">LaTeX数学公式</a></li>
<li>LaTeX入门，刘海洋</li>
</ul>
<h3 id="作者、标题、日期"><a href="#作者、标题、日期" class="headerlink" title="作者、标题、日期"></a>作者、标题、日期</h3><p>保存并用XeLaTeX编译以下文档<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\title&#123;你好，world!&#125;</span><br><span class="line">\author&#123;Houmin&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">你好，world!</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><br>在<code>导言区</code>添加了有关作者、标题、日期，而在<code>document</code>环境中，多了一个控制命令<code>maketitle</code>。这个命令能够将导言区中定义的标题、作者和日期按照预定的格式显示出来。</p>
<h3 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h3><p>保存并用XeLaTeX编译以下文档</p>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li><code>\textrm{}</code>，可以在公式中插入正常文本（也可以直接在公式输入文本，但是会出现忽略空格分行等问题）</li>
<li><code>\mathrm{}</code>，正常字体</li>
<li><code>\mathit{}</code>，斜体</li>
<li><code>\mathbf{}</code>，粗体符号boldfont</li>
<li><code>\mathbb{}</code>，空心粗体blackboard</li>
<li><code>\mathnormal{}</code>，正常字体</li>
</ul>
<h3 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h3><ul>
<li>在段落内插入公式：置于<script type="math/tex">`和`</script>之间</li>
<li>在独立数学公式：置于<code>\[</code>和<code>\]</code>之间</li>
<li>需要对行间公式进行编号，则<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">...</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常用数学公式命令"><a href="#常用数学公式命令" class="headerlink" title="常用数学公式命令"></a>常用数学公式命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">表示方法</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">示例效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上标</td>
<td style="text-align:center">^</td>
<td style="text-align:center">x^2</td>
<td style="text-align:center">$x^2$</td>
</tr>
<tr>
<td style="text-align:center">下标</td>
<td style="text-align:center">_</td>
<td style="text-align:center">x_2</td>
<td style="text-align:center">$x_2$</td>
</tr>
<tr>
<td style="text-align:center">上划线</td>
<td style="text-align:center">\overline</td>
<td style="text-align:center">\overline{m+n}</td>
<td style="text-align:center">$\overline{m+n}$</td>
</tr>
<tr>
<td style="text-align:center">下划线</td>
<td style="text-align:center">\underline</td>
<td style="text-align:center">\underline(m-n)</td>
<td style="text-align:center">$\underline{m-n}$</td>
</tr>
<tr>
<td style="text-align:center">向量</td>
<td style="text-align:center">\vec</td>
<td style="text-align:center">\vec{AB}</td>
<td style="text-align:center">$\vec{AB}$</td>
</tr>
<tr>
<td style="text-align:center">导数</td>
<td style="text-align:center">‘</td>
<td style="text-align:center">y’y’’</td>
<td style="text-align:center">$y’y’’$</td>
</tr>
<tr>
<td style="text-align:center">平方根</td>
<td style="text-align:center">\sqrt</td>
<td style="text-align:center">\sqrt{x}</td>
<td style="text-align:center">$\sqrt{x}$</td>
</tr>
<tr>
<td style="text-align:center">分数</td>
<td style="text-align:center">\frac{}{}</td>
<td style="text-align:center">\frac{4}{a+b}</td>
<td style="text-align:center">$\frac{4}{a+b}$</td>
</tr>
<tr>
<td style="text-align:center">求和</td>
<td style="text-align:center">\sum</td>
<td style="text-align:center">\sum_{i=1}{n}a_i</td>
<td style="text-align:center">$\sum_{i=1}^{n}a_i$</td>
</tr>
<tr>
<td style="text-align:center">乘积</td>
<td style="text-align:center">\prod</td>
<td style="text-align:center">\prod_{i=1}(n)a_i</td>
<td style="text-align:center">$\prod_{i=1}^{n}a_i$</td>
</tr>
<tr>
<td style="text-align:center">积分</td>
<td style="text-align:center">\int \iint</td>
<td style="text-align:center">\iint_a^b f(x)dx</td>
<td style="text-align:center">$\iint_a^b f(x)dx$</td>
</tr>
<tr>
<td style="text-align:center">极限</td>
<td style="text-align:center">\lim</td>
<td style="text-align:center">\lim_{n\to\infty}\frac{1}{n} = 0</td>
<td style="text-align:center">$\lim_{n\to\infty}\frac{1}{n} = 0$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><p><img alt="Greek-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-greek-symbols.jpg"></p>
<p><img alt="Relation-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-relation-symbols.jpg"></p>
<p><img alt="Binary-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-binary-operators.jpg"></p>
<p><img alt="Variable-Sized-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-variable-sized-symbols.jpg"></p>
<p><img alt="Arrow-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-arrow-symbols.jpg"></p>
<p><img alt="Delimiters" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-delimiters.jpg"></p>
<p><img alt="Miscellaneous-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-miscellaneous-symbols.jpg"></p>
<p><img alt="Non-Text-Symbols" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-non-text-symbols.jpg"></p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><img alt="Functions" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-03-05-latex-functions.jpg"></p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="不同分隔符"><a href="#不同分隔符" class="headerlink" title="不同分隔符"></a>不同分隔符</h4><p><code>amsmath</code>的<code>pmatrix</code>,<code>bmatrix</code>,<code>Bmatrix</code>,<code>vmatrix</code>, <code>Vmatrix</code>可以在矩阵两边加上各种分隔符。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad</span><br><span class="line">\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad</span><br><span class="line">\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad</span><br><span class="line">\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad</span><br><span class="line">\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \]</span><br></pre></td></tr></table></figure><br>显示效果如下：</p>
<script type="math/tex; mode=display">\begin{pmatrix} a&b\\c&d \end{pmatrix} \quad
\begin{bmatrix} a&b\\c&d \end{bmatrix} \quad
\begin{Bmatrix} a&b\\c&d \end{Bmatrix} \quad
\begin{vmatrix} a&b\\c&d \end{vmatrix} \quad
\begin{Vmatrix} a&b\\c&d \end{Vmatrix}</script><h4 id="行内公式矩阵"><a href="#行内公式矩阵" class="headerlink" title="行内公式矩阵"></a>行内公式矩阵</h4><p>使用<code>smallmatrix</code>环境，可以生成行内公式的小矩阵<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Marry has a little matrix $ ( \begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; ) $.</span><br></pre></td></tr></table></figure><br>效果</p>
<blockquote>
<p>Marry has a little matrix $ ( \begin{smallmatrix} a&amp;b\\c&amp;d \end{smallmatrix} ) $.</p>
</blockquote>
<h4 id="带点矩阵"><a href="#带点矩阵" class="headerlink" title="带点矩阵"></a>带点矩阵</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[  A &#x3D; \begin&#123;bmatrix&#125;</span><br><span class="line">  a_&#123;11&#125; &amp; \dots &amp; a_&#123;1n&#125; \\</span><br><span class="line">   &amp; \ddots &amp; \vdots \\</span><br><span class="line">  0 &amp; &amp; a_&#123;nn&#125;</span><br><span class="line">\end&#123;bmatrix&#125;_&#123;n\times n&#125;  \]</span><br></pre></td></tr></table></figure>
<p>效果</p>
<script type="math/tex; mode=display">A = \begin{bmatrix}
  a_{11} & \dots & a_{1n} \\
   & \ddots & \vdots \\
  0 & & a_{nn}
\end{bmatrix}_{n\times n}</script><h4 id="无括号矩阵"><a href="#无括号矩阵" class="headerlink" title="无括号矩阵"></a>无括号矩阵</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[</span><br><span class="line">\sum_&#123;\substack&#123;0&lt;i&lt;n \\ 0&lt;j&lt;i&#125;&#125; A_&#123;ij&#125;</span><br><span class="line">\]</span><br></pre></td></tr></table></figure>
<p>效果</p>
<script type="math/tex; mode=display">
\sum_{\substack{0<i<n \\ 0<j<i}} A_{ij}</script><h3 id="配对括号"><a href="#配对括号" class="headerlink" title="配对括号"></a>配对括号</h3><p>在数学公式中，如果直接使用括号，得到的公式会比较简陋，例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[</span><br><span class="line">\lim_x(1+\frac&#123;1&#125;&#123;x&#125;)^x &#x3D; \mathrm&#123;e&#125;</span><br><span class="line">\]</span><br></pre></td></tr></table></figure><br>效果</p>
<script type="math/tex; mode=display">\lim_x(1+\frac{1}{x})^x = \mathrm{e}</script><p>我们可以用<code>\left</code>和<code>\right</code>命令来自动调整大小的括号，例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[</span><br><span class="line">\lim_x \left (1+\frac&#123;1&#125;&#123;x&#125; \right)^x &#x3D; \mathrm&#123;e&#125;</span><br><span class="line">\]</span><br></pre></td></tr></table></figure><br>效果</p>
<script type="math/tex; mode=display">\lim_x \left (1+\frac{1}{x} \right)^x = \mathrm{e}</script><h3 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h3><p>有的公式特别长，我们需要手动为他们换行；有几个公式是一组，我们需要将他们放在一起；还有些类似分段函数，我们需要给它加上一个左边的花括号。</p>
<h4 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h4><h5 id="不对齐"><a href="#不对齐" class="headerlink" title="不对齐"></a>不对齐</h5><p>无须对齐的长公式可以使用 <code>multline</code> 环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;multline&#125;</span><br><span class="line">x &#x3D; a+b+c+&#123;&#125; \\</span><br><span class="line">d+e+f+g</span><br><span class="line">\end&#123;multline&#125;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<script type="math/tex; mode=display">
\begin{multline}
x = a+b+c+{} \\
d+e+f+g
\end{multline}</script><p>如果不需要编号，可以使用 <code>multline*</code> 环境代替</p>
<h5 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h5><p>需要对齐的公式，可以使用 <code>aligned</code> 次环境来实现，它必须包含在数学环境之内。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[\begin&#123;aligned&#125;</span><br><span class="line">x &#x3D;&#123;&#125;&amp; a+b+c+&#123;&#125; \\</span><br><span class="line">&amp;d+e+f+g</span><br><span class="line">\end&#123;aligned&#125;\]</span><br></pre></td></tr></table></figure><br>效果</p>
<script type="math/tex; mode=display">
\begin{aligned}
x ={}& a+b+c+{} \\
&d+e+f+g
\end{aligned}</script><h4 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h4><p>无需对齐的公式组可以使用 <code>gather</code> 环境，需要对齐的公式组可以使用 <code>align</code> 环境。他们都带有编号，如果不需要编号可以使用带星花的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;gather&#125;</span><br><span class="line">a &#x3D; b+c+d \\</span><br><span class="line">x &#x3D; y+z</span><br><span class="line">\end&#123;gather&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp;&#x3D; b+c+d \\</span><br><span class="line">x &amp;&#x3D; y+z</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<script type="math/tex; mode=display">
\begin{gather}
a = b+c+d \\
x = y+z
\end{gather}</script><script type="math/tex; mode=display">
\begin{align}
a &= b+c+d \\
x &= y+z
\end{align}</script><h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><p>分段函数可以用<code>cases</code>次环境来实现，它必须包含在数学环境之内。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[</span><br><span class="line">y&#x3D;\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0 \\</span><br><span class="line">x,\quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">\]</span><br></pre></td></tr></table></figure><br>效果</p>
<script type="math/tex; mode=display">
y=\begin{cases}
-x,\quad x\leq 0 \\
x,\quad x>0
\end{cases}</script><h2 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h2><h2 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h2><h2 id="演示文稿"><a href="#演示文稿" class="headerlink" title="演示文稿"></a>演示文稿</h2>]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64编码及其实现</title>
    <url>/posts/56733fd3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>Base64是一种基于64个可打印字符来表示二进制数据的方法。</p>
</blockquote>
<p>当我们用文本编辑器打开<code>jpg</code>、<code>pdf</code>、<code>exe</code>这些文件格式的时候，会看到一大堆的乱码，这是因为二进制文件包含很多无法显示和打印的字符。所以，如果想要让记事本这样的文本编辑器处理二进制数据，就需要一个从二进制到字符串的转换方法。<strong>Base64就是一种最常见的二进制编码方法</strong>。 </p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h3><p>使用计算机时，我们会遇到各种各样的文件格式，有像<code>txt</code>、<code>cpp</code>、<code>java</code>、<code>md</code>这样的可以用文本编辑器直接打开的文件格式，我们称之为 <strong><em>文本文件</em></strong>，也有一些文件用编辑器打开时是一堆乱码，比如像上面提到的<code>jpg</code>、<code>wav</code>、<code>pdf</code>，这些文件格式称之为 <strong><em>二进制文件</em></strong>。</p>
<p><strong>我们知道，所有文件在计算机的存储都是一堆0和1的序列，也就是说不论是文本文件还是二进制文件，在物理上，计算机的存储是都是二进制的。</strong>  所谓的文本文件和二进制文件的区别并不是物理上的，而是逻辑上的。广义上来说，文本文件也是二进制文件。二者的区别是因为你看待数据的方式不同而产生的差别，具体的说二者的区别就在于打开这个文件的程序对其内容的解释上。</p>
<p>以文件的读写过程为例，这实际包含了如下的两个转换过程</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">磁盘</span> --<span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">文件缓冲区</span> --<span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">应用程序内存空间</span></span><br></pre></td></tr></table></figure>
<p>第一个过程中，文件被应用程序从磁盘读取到文件缓冲区，二者都是一堆的0和1的序列，这个时候文本文件和二进制文件并没有什么区别。</p>
<p>接下来，不同的应用程序，根据面对的不同文件格式，对一堆的0和1序列进行解释。对于文本文件，应用程序直接将其中的数据(也就是这一堆0和1序列按照ASCII或者Unicode编码的方式解释出来)，显示成文本的形式。对于其他类型的文件，一般包括了控制信息和内容信息，应用程序按照文件格式，从这些数据中解析出对应的数据内容，比如常见的wav文件解析过程，而这些就是所谓的二进制文件。</p>
<h3 id="Base64的转换"><a href="#Base64的转换" class="headerlink" title="Base64的转换"></a>Base64的转换</h3><p>Base64编码选择的64个可打印字符为字母A-Z，a-z、数字0-9，这样共有62个字符，此外还有两个字符在不同的系统中而不同。比如对于MIME格式，其采用的为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> table[] = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;</span><br></pre></td></tr></table></figure>
<p>然后，而二进制数据进行处理，每3个字节一组，一共是 $ 3 × 8 = 24 $ bit，划分为4组，每组正好6个bit。</p>
<p><img alt="base64" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-12-12-base64.png"></p>
<p>这样，我们得到4个数字作为索引，然后查表，获得相应的4个字符，就得到编码后的字符串。所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<p>如果要编码的二进制数据不是3的倍数，Base64就会在后面补0，每补1个0就在编码出来的字符串后加上1个<code>=</code>，解码的时候会自动将<code>=</code>去掉。</p>
<p>Python中内置的<code>base64</code>可以直接进行base64的编解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">b'hello, world!'</span>)</span><br><span class="line"><span class="string">b'aGVsbG8sIHdvcmxkIQ=='</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(<span class="string">b'aGVsbG8sIHdvcmxkIQ=='</span>)</span><br><span class="line"><span class="string">b'hello, world!'</span></span><br></pre></td></tr></table></figure>
<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><p>此处源码可在  <a href="https://github.com/SimpCosm/code/tree/master/base64" target="_blank" rel="external nofollow noopener noreferrer">base64的C++实现</a></p>
<h3 id="encode方法"><a href="#encode方法" class="headerlink" title="encode方法"></a>encode方法</h3><ul>
<li>首先计算生成base64字符串的长度</li>
<li>原来的二进制流中，每3个字节为整体，合为一个32位的bit串</li>
<li>将这个32位bit串的低24bit的每6个比特作为索引，得到映射表中对应的字符</li>
<li>如果原来的字节串不是3的倍数，则补零，并且每补一个0加一个<code>=</code> </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span></span><br><span class="line">encode_base64(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; unencoded)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> encoded;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">size</span> = unencoded.<span class="built_in">size</span>();</span><br><span class="line">    encoded.reserve(((<span class="built_in">size</span> / <span class="number">3</span>) + (<span class="built_in">size</span> % <span class="number">3</span> &gt; <span class="number">0</span>)) * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> value;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">cursor</span> = unencoded.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> <span class="built_in">position</span> = <span class="number">0</span>; <span class="built_in">position</span> &lt; <span class="built_in">size</span> / <span class="number">3</span>; <span class="built_in">position</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        value = (*<span class="built_in">cursor</span>++) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        value += (*<span class="built_in">cursor</span>++) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        value += (*<span class="built_in">cursor</span>++);</span><br><span class="line">        encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x00FC0000</span>) &gt;&gt; <span class="number">18</span>]);</span><br><span class="line">        encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x0003F000</span>) &gt;&gt; <span class="number">12</span>]);</span><br><span class="line">        encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x00000FC0</span>) &gt;&gt; <span class="number">6</span>]);</span><br><span class="line">        encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x0000003F</span>) &gt;&gt; <span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">size</span> % <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            value = (*<span class="built_in">cursor</span>++) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x00FC0000</span>) &gt;&gt; <span class="number">18</span>]);</span><br><span class="line">            encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x0003F000</span>) &gt;&gt; <span class="number">12</span>]);</span><br><span class="line">            encoded.append(<span class="number">2</span>, pad);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            value = (*<span class="built_in">cursor</span>++) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            value += (*<span class="built_in">cursor</span>++) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x00FC0000</span>) &gt;&gt; <span class="number">18</span>]);</span><br><span class="line">            encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x0003F000</span>) &gt;&gt; <span class="number">12</span>]);</span><br><span class="line">            encoded.append(<span class="number">1</span>, table[(value &amp; <span class="number">0x00000FC0</span>) &gt;&gt; <span class="number">6</span>]);</span><br><span class="line">            encoded.append(<span class="number">1</span>, pad);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="decode方法"><a href="#decode方法" class="headerlink" title="decode方法"></a>decode方法</h3><ul>
<li>首先判断base64字符串的长度是不是4的倍数</li>
<li>去除 <code>=</code> 这样的pad，<code>=</code>只可能是1个或2个</li>
<li>遍历整个base64字符串，每4个为一个单位(对应也就是3个字节的二进制数，以value表示)，对于每个字符得到其在映射表中的索引，从而得到value的值，进而解析出每个字节的值</li>
</ul>
<p>对应代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">decode</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt;&amp; out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">uint32_t</span> mask = <span class="number">0x000000FF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> length = in.length();</span><br><span class="line">    <span class="keyword">if</span> ((length % <span class="number">4</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> padding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[length - <span class="number">1</span>] == pad)</span><br><span class="line">            padding++;</span><br><span class="line">        <span class="keyword">if</span> (in[length - <span class="number">2</span>] == pad)</span><br><span class="line">            padding++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; decoded;</span><br><span class="line">    decoded.reserve((length / <span class="number">4</span>) * <span class="number">3</span> - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">cursor</span> = in.<span class="built_in">begin</span>(); <span class="built_in">cursor</span> &lt; in.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> <span class="built_in">position</span> = <span class="number">0</span>; <span class="built_in">position</span> &lt; <span class="number">4</span>; <span class="built_in">position</span>++)</span><br><span class="line">        &#123;</span><br><span class="line">            value &lt;&lt;= <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">if</span> (*<span class="built_in">cursor</span> &gt;= <span class="number">0x41</span> &amp;&amp; *<span class="built_in">cursor</span> &lt;= <span class="number">0x5A</span>)     <span class="comment">// A-Z</span></span><br><span class="line">                value |= *<span class="built_in">cursor</span> - <span class="number">0x41</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">cursor</span> &gt;= <span class="number">0x61</span> &amp;&amp; *<span class="built_in">cursor</span> &lt;= <span class="number">0x7A</span>)    <span class="comment">// a-z</span></span><br><span class="line">                value |= *<span class="built_in">cursor</span>- <span class="number">0x47</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">cursor</span> &gt;= <span class="number">0x30</span> &amp;&amp; *<span class="built_in">cursor</span> &lt;= <span class="number">0x39</span>)    <span class="comment">// 0-9</span></span><br><span class="line">                value |= *<span class="built_in">cursor</span> + <span class="number">0x04</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">cursor</span> == <span class="number">0x2B</span>)       <span class="comment">// +</span></span><br><span class="line">                value |= <span class="number">0x3E</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">cursor</span> == <span class="number">0x2F</span>)       <span class="comment">// /</span></span><br><span class="line">                value |= <span class="number">0x3F</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">cursor</span> == pad)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Handle 1 or 2 pad characters.</span></span><br><span class="line">                <span class="keyword">switch</span> (in.<span class="built_in">end</span>() - <span class="built_in">cursor</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        decoded.push_back((value &gt;&gt; <span class="number">16</span>) &amp; mask);</span><br><span class="line">                        decoded.push_back((value &gt;&gt; <span class="number">8</span>) &amp; mask);</span><br><span class="line">                        out = decoded;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        decoded.push_back((value &gt;&gt; <span class="number">10</span>) &amp; mask);    <span class="comment">// (&lt;&lt; 6)(&gt;&gt; 16)</span></span><br><span class="line">                        out = decoded;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cursor</span>++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        decoded.push_back((value &gt;&gt; <span class="number">16</span>) &amp; mask);</span><br><span class="line">        decoded.push_back((value &gt;&gt; <span class="number">8</span>) &amp; mask);</span><br><span class="line">        decoded.push_back((value &gt;&gt; <span class="number">0</span>) &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out = decoded;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>写一个简单的demo验证</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base64.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encoded_str</span><span class="params">(<span class="string">"aGVsbG8sIHdvcmxkIQ=="</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Encoded base64 string: "</span> &lt;&lt; encoded_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; orignal_vector;</span><br><span class="line">    <span class="keyword">if</span> ((decode_base64(orignal_vector, encoded_str)) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"decode error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">orignal_str</span><span class="params">(orignal_vector.<span class="built_in">begin</span>(), orignal_vector.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Original string is "</span> &lt;&lt; orignal_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> encoded = encode_base64(orignal_vector);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Encoded again: "</span> &lt;&lt; encoded &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后得到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -o demo demo.cpp base.cpp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo </span></span><br><span class="line">Encoded base64 string: aGVsbG8sIHdvcmxkIQ==</span><br><span class="line">Original string is hello, world!</span><br><span class="line">Encoded again: aGVsbG8sIHdvcmxkIQ==</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>上面说了base64的编码方法，那么为什么要使用base64编码呢，有哪些情景需求？</p>
<p>我们知道在计算机中任何数据都是按ascii码存储的，而ascii码的128～255之间的值是不可见字符。而在网络上交换数据时，比如说从A地传到B地，往往要经过多个路由设备，由于不同的设备对字符的处理方式有一些不同，这样那些不可见字符就有可能被处理错误，这是不利于传输的。所以就先把数据先做一个Base64编码，统统变成可见字符，这样出错的可能性就大降低了。</p>
<h3 id="HTML内嵌base64编码图片"><a href="#HTML内嵌base64编码图片" class="headerlink" title="HTML内嵌base64编码图片"></a>HTML内嵌base64编码图片</h3><h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3><h3 id="X-509-公钥证书"><a href="#X-509-公钥证书" class="headerlink" title="X.509 公钥证书"></a>X.509 公钥证书</h3>]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 服务器</title>
    <url>/posts/8fc468f1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一个公用的 git 远程仓库可以让开发者之间高效协作，每个人都有权利访问远程仓库，并且可以从那里推送和拉取资料。一个远程仓库通常只是一个裸仓库（bare repository）——即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 <code>.git</code> 子目录内容，不包含其他资料。Git 支持四种不同的传输协议：本地协议（Local）、HTTP(S) 协议、SSH（Secure Shell）协议以及 Git 协议，这四种协议在不同的场合有不同的用途，并且各有利弊，可以根据实际情况来选择。</p>
<a id="more"></a>
<h2 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h2><p>本地协议是 Git 最基本的协议，当我们想在本地做一些 Git 实验时，这将非常有用。我们首先建立两个目录：<code>/git/repo</code> 和 <code>~/working</code>，前者作为远程版本库，后者作为本地工作目录。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">aneasystone<span class="meta">@little</span>-<span class="string">stone:</span>~$ sudo mkdir -p <span class="regexp">/git/</span>repo``aneasystone<span class="meta">@little</span>-<span class="string">stone:</span>~$ sudo git init --bare <span class="regexp">/git/</span>repo<span class="regexp">/test.git``已初始化空的 Git 仓库于 /</span>git<span class="regexp">/repo/</span>test.git/</span><br></pre></td></tr></table></figure>
<p>我们在 <code>/git/repo</code> 目录通过 <code>git init --bare</code> 命令创建一个裸仓库（bare repository，即一个不包含当前工作目录的仓库），只要这一步，我们就可以开始使用了。接着我们在工作目录 <code>clone</code> 这个版本库：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">aneasystone@little-<span class="symbol">stone:</span>~$ cd ~<span class="regexp">/working/</span><span class="string">``</span>aneasystone@little-<span class="symbol">stone:</span>~<span class="regexp">/working$ git clone /git</span><span class="regexp">/repo/test</span>.git<span class="string">``</span>正克隆到 <span class="string">'test'</span>...<span class="string">``</span><span class="symbol">warning:</span> 您似乎克隆了一个空仓库。<span class="string">``</span>完成。</span><br></pre></td></tr></table></figure>
<p>然后我们可以使用 <code>pull</code>、<code>push</code> 就像操作其他的版本库一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aneasystone@little-stone:~/working$ cd test/``aneasystone@little-stone:~/working/test$ touch 1``aneasystone@little-stone:~/working/test$ touch 2``aneasystone@little-stone:~/working/test$ git add .``aneasystone@little-stone:~/working/test$ git <span class="keyword">commit</span> -m <span class="string">'first commit'</span><span class="string">``</span>[<span class="keyword">master</span> （根提交） <span class="number">4983</span>f84] <span class="keyword">first</span> <span class="keyword">commit</span><span class="string">``</span> <span class="string">``</span><span class="number">2</span> files <span class="keyword">changed</span>, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)<span class="string">``</span> <span class="string">``</span><span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> <span class="number">1</span><span class="string">``</span> <span class="string">``</span><span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> <span class="number">2</span><span class="string">``</span>aneasystone@<span class="keyword">little</span>-stone:~/working/<span class="keyword">test</span>$ sudo git push<span class="string">``</span>[sudo] aneasystone 的密码： <span class="string">``</span>对象计数中: <span class="number">3</span>, 完成.<span class="string">``</span>Delta compression <span class="keyword">using</span> up <span class="keyword">to</span> <span class="number">8</span> threads.<span class="string">``</span>压缩对象中: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), 完成.<span class="string">``</span>写入对象中: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">205</span> <span class="keyword">bytes</span> | <span class="number">205.00</span> KiB/s, 完成.<span class="string">``</span>Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)<span class="string">``</span><span class="keyword">To</span> /git/repo/test.git<span class="string">``</span> <span class="string">``</span>* [<span class="keyword">new</span> branch]   <span class="keyword">master</span> -&gt; <span class="keyword">master</span></span><br></pre></td></tr></table></figure>
<p>本地协议不仅在做 Git 实验时很有用，如果你的团队有一个共享文件系统，可以在这个共享文件系统上创建一个远程版本库，团队成员把这个共享文件系统挂在本地，就可以直接使用本地协议进行协作开发，完全不需要搭建一台专门的 Git 服务器。</p>
<h2 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h2><p>本地协议虽然简单，但是一般来说并不适用，因为你无法控制用户对共享文件系统的操作，用户拥有 push 权限也就意味着用户对远程目录拥有完整的 Shell 权限，他们有可能会无意甚至有意的修改或删除 Git 内部文件，损坏 Git 仓库。</p>
<p>更安全的做法是使用专门的 Git 服务器，如果你有一台可以使用 SSH 连接的服务器，搭建 Git 服务将会非常简单。首先我们要确保服务器上运行着 SSH 服务（<code>sshd</code>），大多数 Linux 服务器版本都默认包含了该服务，如果没有，可以先安装 <code>openssh-server</code>。然后在服务器上创建 Git 远程版本库：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">root<span class="keyword">@myserver</span>:~# mkdir -p /git/repo<span class="string">``</span>root<span class="keyword">@myserver</span>:~# git init --bare /git/repo/test.git<span class="string">``</span>已初始化空的 Git 仓库于 /git/repo/test.git/</span><br></pre></td></tr></table></figure>
<p>然后在本地 <code>clone</code> 这个版本库：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">aneasystone@little-<span class="symbol">stone:</span>~<span class="regexp">/working$ git clone ssh:/</span><span class="regexp">/root@myserver/git</span><span class="regexp">/repo/test</span>.git<span class="string">``</span>正克隆到 <span class="string">'test'</span>...<span class="string">``</span>root@myserver<span class="string">'s password: ``warning: 您似乎克隆了一个空仓库。</span></span><br></pre></td></tr></table></figure>
<p>可以看到和使用本地协议几乎一样，不同的地方在于，在 clone 的时候需要在 URL 前面加上 <code>ssh://root@myserver</code>，你也可以使用 scp 式的写法：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone root<span class="variable">@myserver</span><span class="symbol">:/git/repo/test</span>.git</span><br></pre></td></tr></table></figure>
<p>另外一点不同的地方是，每次 <code>pull</code>、<code>push</code> 的时候都需要输入远程服务器的 root 密码。很显然，让每个 Git 用户都使用 root 来访问服务器是一种很不安全的做法，有几种方法可以解决这个问题：</p>
<ul>
<li>最显而易见的方法是为每个 Git 用户创建一个独立的账号，并分别为他们分配对仓库的读写权限，这种方法行的通，但是对账号的管理非常麻烦，在团队人员不是很多的时候可以尝试，但是并不推荐；</li>
<li>另一种方法是配置 SSH 服务器使用某个已有的认证系统来管理用户，比如 <a href="https://zh.wikipedia.org/wiki/轻型目录访问协议" target="_blank" rel="external nofollow noopener noreferrer">LDAP</a>，这在很多企业中是很常见的，这样可以省去用 <code>adduser</code> 手工管理服务器账号的麻烦；</li>
<li>还有一种方法是只创建一个账号，比如叫做 git，他对仓库具有读写权限，大家都使用这个账号来访问仓库。这种方法的好处是用户管理起来比较简单，而且可以使用后面介绍的 <code>authorized_keys</code> 文件对用户的公钥进行管理；</li>
</ul>
<p>下面我们尝试下第三种方法。首先在服务器上创建一个名叫 git 的账号：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">root@myserver:~# adduser git``Adding<span class="built_in"> user </span>`git<span class="string">' ...``Adding new group `git'</span> (1000) <span class="built_in">..</span>.``Adding new<span class="built_in"> user </span>`git<span class="string">' (1000) with group `git'</span> <span class="built_in">..</span>.``Creating home directory `/home/git<span class="string">' ...``Copying files from `/etc/skel'</span> <span class="built_in">..</span>.``Enter new UNIX password: ``Retype new UNIX password: ``passwd: password updated successfully``Changing the<span class="built_in"> user </span>information <span class="keyword">for</span> git``Enter the new value, <span class="keyword">or</span> press ENTER <span class="keyword">for</span> the default``  ``Full Name []: git``  ``Room Number []:  ``  ``Work Phone []: ``  ``Home Phone []: ``  ``Other []: ``Is the information correct? [Y/n] Y</span><br></pre></td></tr></table></figure>
<p>再设置一下 git 仓库的权限（默认情况下，git 仓库的权限为 <code>rwxr-xr-x</code>，只有创建者 root 有写的权限，也就意味着使用 git 账号只能 <code>clone</code> <code>pull</code>，不能 <code>push</code>）：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod a+w -R /git/repo/test.git</span></span><br></pre></td></tr></table></figure>
<p>我们这里非常粗暴的使用 <code>chmod a+w</code> 将 git 仓库设置为对所有人可写，这里可以想一想，如果我们希望设置某些用户对仓库具有只读的权限，该怎么做呢？</p>
<p>然后就可以在本地愉快的进行 git 操作了：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone git<span class="variable">@myserver</span><span class="symbol">:/git/repo/test</span>.git</span><br></pre></td></tr></table></figure>
<p>到这里似乎一切都很正常，但是几次实操之后你就会发现，每次 git 操作都要输入一次密码，这也太麻烦了，能不能“免密提交代码”呢？首先我们要知道，只要能通过 SSH 登陆到服务器，我们就能操作 git，所以如果 SSH 能支持免密登陆，我们就可以“免密提交代码”。还好，SSH 支持公钥认证，这种认证方式无需密码登陆。在 Linux 操作系统中，每个用户都可以拥有自己的一个或多个密钥对（公钥和私钥成对出现），这些密钥一般情况会保存在 <code>~/.ssh</code> 目录下，在开始之前，我们先确认下自己是否已经生成过公钥了，可以看下这个目录下是否有 <code>id_dsa.pub</code> 或 <code>id_rsa.pub</code> 这样的文件，如果没有，我们通过 <code>ssh-keygen</code> 来生成：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">aneasystone<span class="meta">@little</span>-stone:~/.ssh$ ssh-keygen<span class="string">``</span>Generating public/private rsa key pair.<span class="string">``</span>Enter file <span class="keyword">in</span> which to save the key (/home/aneasystone/.ssh/id_rsa): <span class="string">``</span>Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="string">``</span>Enter same passphrase again: <span class="string">``</span>Your identification has been saved <span class="keyword">in</span> /home/aneasystone/.ssh/id_rsa.<span class="string">``</span>Your public key has been saved <span class="keyword">in</span> /home/aneasystone/.ssh/id_rsa.pub.<span class="string">``</span>The key fingerprint is:<span class="string">``</span>SHA256:<span class="number">4</span>Ulpufuhs/AgDMb0VXnqMUTw6bD/HrAOI2z9c1cod9I aneasystone<span class="meta">@little</span>-stone<span class="string">``</span>The key's randomart image is:<span class="string">``</span>+---[RSA <span class="number">2048</span>]----+<span class="string">``</span>|   .oo.    |<span class="string">``</span>|    oo+.   |<span class="string">``</span>| .  o.Oo    |<span class="string">``</span>| o . . B++    |<span class="string">``</span>| + . ..So  o  |<span class="string">``</span>| . + . ..+. + E |<span class="string">``</span>|  * * + oo +  |<span class="string">``</span>|  . o Oo+.o.  |<span class="string">``</span>|    **+.   |<span class="string">``</span>+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>这样我们在 <code>~/.ssh</code> 目录生成了两个文件，<code>id_rsa</code> 是你的私钥，<code>id_rsa.pub</code> 是你的公钥。关于私钥和公钥的原理以及 RSA 加密算法等内容可以参考我之前写过的一篇介绍 <a href="https://www.aneasystone.com/archives/2016/04/java-and-https.html" target="_blank" rel="external nofollow noopener noreferrer">HTTPS 和证书</a> 的文章。</p>
<p>我们假设你的 Git 服务器是由专门的服务器管理员负责维护和管理，当你生成你的公钥之后，就可以给服务器管理员发送一封申请 Git 服务的邮件，并附上你的公钥。服务器管理员在收到你的申请之后，如果同意了，就可以进行下面的操作：</p>
<p>首先将公钥文件拷贝到服务器上：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scp id_rsa.pub root<span class="doctag">@myserver</span>:/home/git</span></span><br></pre></td></tr></table></figure>
<p>将公钥文件的内容追加到 git 账户的 authorized_keys 文件中（要注意的是，如果是第一次操作，/home/git 目录下是没有 .ssh 目录的，需要手工创建 .ssh 目录和 authorized_keys 文件）：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@myserver</span><span class="symbol">:/home/git</span><span class="comment"># cat id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
<p>后续如果有其他的用户申请 Git 服务，都可以按照这个步骤操作。一旦完成这个操作，服务器管理员将会回复你的邮件，通知你 Git 服务已经开通，这个时候你再进行 git 操作就可以不用输入密码了。关于 SSH 的使用，更详细的步骤可以参考 Github 上的这篇指南：<a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="external nofollow noopener noreferrer">Connecting to GitHub with SSH</a>。</p>
<p>作为服务器管理员，关于 SSH 还有一点需要考虑，那就是 SSH 的安全问题。在上面介绍本地协议时，我们说这种方式无法控制用户对 Git 仓库的操作，无法防止用户有意或无意的损坏 Git 仓库，使用 SSH 协议一样存在这样的问题，用户能通过 SSH 拉取和提交代码，也就意味着用户可以通过 SSH 连接到服务器，对 Git 仓库进行任何操作，这是一件很让人担心的事情。</p>
<p>因此，我们还需要对 git 账号做一些限制。默认情况下，我们新建账号的登陆 shell 是 <code>/bin/bash</code>，这个配置在 <code>/etc/passwd</code> 文件中：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git:</span><span class="symbol">x:</span><span class="number">1000:1000</span><span class="symbol">:git</span>,,,<span class="symbol">:/home/git</span><span class="symbol">:/bin/bash</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>chsh</code> 命令修改用户的登陆 shell，让他不能通过 SSH 访问服务器，怎么修改呢？我们可以看一下 <code>/etc/shells</code> 文件，这里定义了所有可以使用的登陆 shell，你可以将 <code>/bin/bash</code> 改成这里的任何一个：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">root<span class="keyword">@myserver</span>:~# cat /etc/shells <span class="string">``</span># /etc/shells: valid login shells<span class="string">``</span>/bin/sh<span class="string">``</span>/bin/dash<span class="string">``</span>/bin/bash<span class="string">``</span>/bin/rbash</span><br></pre></td></tr></table></figure>
<p>很显然，这些 shell 并不是我们想要的，有没有一个 shell 只允许用户进行 git 操作，而不允许其他操作呢？还好，Git 的软件包提供了一个名叫 <a href="https://git-scm.com/docs/git-shell" target="_blank" rel="external nofollow noopener noreferrer"><code>git-shell</code> 的登陆 shell</a>，我们可以把他加进去，一般情况下位于 <code>/usr/bin/git-shell</code>。我们使用 <code>chsh</code> 修改 git 的登陆 shell：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">root<span class="meta">@myserver</span>:~# chsh git<span class="string">``</span>Changing the login shell <span class="keyword">for</span> git<span class="string">``</span>Enter the <span class="keyword">new</span> value, or press ENTER <span class="keyword">for</span> the <span class="keyword">default</span><span class="string">``</span>  <span class="string">``</span>Login Shell [<span class="regexp">/bin/</span>bash]: <span class="regexp">/usr/</span>bin/git-shell</span><br></pre></td></tr></table></figure>
<p>这样当用户 git 通过 SSH 连接服务器时，就会直接被拒绝了。</p>
<h2 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h2><p>SSH 协议解决了用户直接操作 Git 仓库的权限问题，但是如果我们希望对除仓库维护者之外的所有人都开放 Git 仓库的只读权限，这在开源项目中和企业内部往往是很常见的，任何人都可以去查看仓库的代码，这时管理员需要给每一个用户配置 SSH 密钥是非常麻烦的。虽然也可以使用变通的方法来达到这个效果，但是很繁琐，下面是具体的步骤：</p>
<ul>
<li>使用 <code>g+w</code> 设置 Git 仓库的权限，让仓库创建者所在的用户组具有写权限，而不是所有人都有写权限（这一步通常也可以在 <code>git init</code> 的时候加上 <code>--shared</code> 参数）；</li>
<li>然后将 git 账号加到仓库创建者的用户组；</li>
<li>再创建一个 git_ro 账户，这个账户对仓库只有只读权限；</li>
<li>最后为 git_ro 账户创建一个密钥对，把 git_ro 的私钥公开出来供所有人使用。</li>
</ul>
<p>可以看到使用 SSH 协议最终都逃不过授权这一步，而且公开私钥的做法也不是很优雅。实际上，Git 提供了另一种方式来让这个操作更简单，那就是 Git 协议。使用 Git 协议必须要在服务器上运行 Git 守护进程，git 命令自带了一个 <code>daemon</code> 参数：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@myserver</span><span class="symbol">:~</span><span class="comment"># git daemon --reuseaddr --base-path=/git/repo/ /git/repo/</span></span><br></pre></td></tr></table></figure>
<p>上面的各个参数可以 <a href="https://git-scm.com/docs/git-daemon" target="_blank" rel="external nofollow noopener noreferrer">参考 git-daemon 的文档</a>。git-daemon 会监听 9418 端口，如果你的服务器有防火墙，需要将该端口添加到白名单，如果你使用的是阿里云服务器，需要像下面这样添加一个安全组规则：</p>
<p><img alt="security-group.jpg" data-src="https://www.aneasystone.com/usr/uploads/2018/11/1985996525.jpg"></p>
<p>为了让所有的用户都可以访问我们的仓库，还需要在仓库目录下创建一个名为 <code>git-daemon-export-ok</code> 的文件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">root<span class="meta">@myserver</span>:~# cd /git/repo/test.git/<span class="string">``</span>root<span class="meta">@myserver</span>:<span class="regexp">/git/</span>repo/test.git/# touch git-daemon-<span class="keyword">export</span>-ok</span><br></pre></td></tr></table></figure>
<p>至此，所有人都可以通过 Git 协议来克隆或拉取项目源码了（注意上面指定了 <code>base-path</code> 参数为 <code>/git/repo/</code>，所以 URL 可以直接写 <code>git://myserver/test.git</code>）：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">aneasystone<span class="meta">@little</span>-<span class="string">stone:</span><span class="regexp">~/working$ git clone git:/</span><span class="regexp">/myserver/</span>test.git</span><br></pre></td></tr></table></figure>
<p>一般情况下，服务器管理员还会做一些其他的配置，譬如在服务器重启时让 Git 守护进程自动启动，这有很多种方式可以实现，可以参考《Pro Git》 <a href="https://git-scm.com/book/zh/v2/服务器上的-Git-Git-守护进程" target="_blank" rel="external nofollow noopener noreferrer">Git 守护进程</a> 这一节的内容。</p>
<h2 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP(S) 协议"></a>HTTP(S) 协议</h2><p>我们一般通过 Git 协议进行无授权访问，通过 SSH 协议进行授权访问，如果你的项目是内部项目，只针对部分授权用户，那使用 SSH 协议就足够了，但是如果既需要授权访问也需要无授权访问，可能需要 SSH 协议和 Git 协议搭配使用，这在维护上成本很高。这时就到了我们的压轴戏 —— HTTP 协议出场的时候了，它同时支持上面两种访问方式。</p>
<p>通过 HTTP 协议访问 Git 服务是目前使用最广泛的方式，它支持两种模式：旧版本的 <code>Dumb HTTP</code> 和 新版本的 <code>Smart HTTP</code>，Dumb HTTP 一般很少使用，下面除非特殊说明，所说的 HTTP 协议都是 Smart HTTP。使用 HTTP 协议的好处是可以使用各种 HTTP 认证机制，比如用户名/密码，这比配置 SSH 密钥要简单的多，对普通用户来说也更能接受。如果担心数据传输安全，也可以配置 HTTPS 协议，这和普通的 Web 服务是一样的。</p>
<p>下面我们就来尝试搭建一个基于 HTTP 协议的 Git 服务器。《Pro Git》上提供了一个<a href="https://git-scm.com/book/zh/v2/服务器上的-Git-Smart-HTTP" target="_blank" rel="external nofollow noopener noreferrer">基于 Apache 的配置示例</a>，如果你是使用 Apache 作为 Web 服务器，可以参考之，我们这里使用 Nginx 来作为 Web 服务器，其原理本质上是一样的，都是通过 Web 服务器接受 HTTP 请求，并将请求转发到 Git 自带的一个名为 <a href="https://git-scm.com/docs/git-http-backend/" target="_blank" rel="external nofollow noopener noreferrer"><code>git-http-backend</code> 的 CGI 脚本</a>。</p>
<p>首先我们安装所需的软件：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># apt-get install -y git-core nginx fcgiwrap apache2-utils</span></span><br></pre></td></tr></table></figure>
<p>其中，Nginx 作为 Web 服务器，本身是不能执行外部 CGI 脚本的，需要通过 <a href="https://github.com/gnosek/fcgiwrap" target="_blank" rel="external nofollow noopener noreferrer">fcgiwrap</a> 来中转，就像使用 php-fpm 来执行 PHP 脚本一样。apache2-utils 是 Apache 提供的一个 Web 服务器的工具集，包含了一些有用的小工具，譬如下面我们会用到的 htpasswd 可以生成 Basic 认证文件。</p>
<p>启动 nginx 和 fcgiwrap，并访问 <code>http://myserver</code> 测试 Web 服务器是否能正常访问：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># service nginx start``# service fcgiwrap start</span><br></pre></td></tr></table></figure>
<p>然后我们打开并编辑 Nginx 的配置文件（<code>/etc/nginx/sites-available/default</code>）:</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">location / &#123;<span class="string">``</span>    <span class="string">``</span>include fastcgi_params;<span class="string">``</span>    <span class="string">``</span>fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend;<span class="string">``</span>    <span class="string">``</span>fastcgi_param GIT_HTTP_EXPORT_ALL <span class="string">""</span>;<span class="string">``</span>    <span class="string">``</span>fastcgi_param GIT_PROJECT_ROOT /git/repo;<span class="string">``</span>    <span class="string">``</span>fastcgi_param PATH_INFO <span class="symbol">$uri</span>;<span class="string">``</span>    <span class="string">``</span>fastcgi_param REMOTE_USER <span class="symbol">$remote</span>_user;<span class="string">``</span>    <span class="string">``</span>fastcgi_pass unix:<span class="regexp">/var/</span>run/fcgiwrap.socket;<span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>fastcgi_param</code> 设置了一堆的 FastCGI 参数，如下：</p>
<ul>
<li>SCRIPT_FILENAME：指定 CGI 脚本 <code>git-http-backend</code> 的位置，表示每次 HTTP 请求会被转发到该 CGI 脚本；</li>
<li>GIT_HTTP_EXPORT_ALL：<code>git-http-backend</code> 默认只能访问目录下有 <code>git-daemon-export-ok</code> 文件的 Git 仓库，和上面介绍的 Git 协议是一样的，如果指定了 GIT_HTTP_EXPORT_ALL，表示允许访问所有仓库；</li>
<li>GIT_PROJECT_ROOT：Git 仓库的根目录；</li>
<li>REMOTE_USER：如果有认证，将认证的用户信息传到 CGI 脚本；</li>
</ul>
<p>改完之后我们重启 Nginx，并通过 HTTP 协议 <code>clone</code> 仓库：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">aneasystone<span class="meta">@little</span>-<span class="string">stone:</span><span class="regexp">~/working$ git clone http:/</span><span class="regexp">/myserver/</span>test.git</span><br></pre></td></tr></table></figure>
<h3 id="开启身份认证"><a href="#开启身份认证" class="headerlink" title="开启身份认证"></a>开启身份认证</h3><p>到这里一切 OK，但是当我们 <code>push</code> 代码的时候，却会报下面的 403 错误：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">aneasystone<span class="meta">@little</span>-<span class="string">stone:</span><span class="regexp">~/working/</span>test$ git push origin master``<span class="string">fatal:</span> unable to access <span class="string">'http://myserver/test.git/'</span>: The requested URL returned <span class="string">error:</span> <span class="number">403</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个错误，我们可以在 <a href="https://git-scm.com/docs/git-http-backend/" target="_blank" rel="external nofollow noopener noreferrer">git-http-backend 的官网文档</a> 上找到这样的一段描述：</p>
<blockquote>
<p>By default, only the <code>upload-pack</code> service is enabled, which serves <em>git fetch-pack</em> and <em>git ls-remote</em> clients, which are invoked from <em>git fetch</em>, <em>git pull</em>, and <em>git clone</em>. If the client is authenticated, the <code>receive-pack</code> service is enabled, which serves <em>git send-pack</em> clients, which is invoked from <em>git push</em>.</p>
</blockquote>
<p>第一次读这段话可能会有些不知所云，这是因为我们对这里提到的 <code>upload-pack</code>、<code>fetch-pack</code>、<code>receive-pack</code>、<code>send-pack</code> 这几个概念还没有什么认识。但是我们大抵可以猜出来，默认情况下，只有认证的用户才可以 push 代码，如果某个 Git 仓库希望所有用户都有权限 push 代码，可以为相应的仓库设置 <code>http.receivepack</code>：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">root@myserver:/# cd /git/repo/test.git/``root@myserver:/git/repo/test.git# git<span class="built_in"> config </span>http.receivepack <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>当然最好的做法还是对 push 操作开启认证，官网文档上有一个 <a href="https://git-scm.com/docs/git-http-backend/#git-http-backend-Lighttpd" target="_blank" rel="external nofollow noopener noreferrer">lighttpd 的配置</a> 我们可以借鉴：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$HTTP[<span class="string">"querystring"</span>] =~ <span class="string">"service=git-receive-pack"</span> &#123;<span class="string">``</span>  <span class="string">``</span><span class="keyword">include</span> <span class="string">"git-auth.conf"</span><span class="string">``</span>&#125;<span class="string">``</span>$HTTP[<span class="string">"url"</span>] =~ <span class="string">"^/git/.*/git-receive-pack$"</span> &#123;<span class="string">``</span>  <span class="string">``</span><span class="keyword">include</span> <span class="string">"git-auth.conf"</span><span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置看上去非常简单，但是想要理解为什么这样配置，就必须去了解下 Git 的内部原理。正如上面 git-http-backend 文档上的那段描述，当 Git 客户端执行 <em>git fetch</em>, <em>git pull</em>, and <em>git clone</em> 时，会调用 <code>upload-pack</code> 服务，当执行 <em>git push</em> 时，会调用 <code>receive-pack</code> 服务，为了更清楚的说明这一点，我们来看看 Nginx 的访问日志。</p>
<p>执行 <code>git clone</code>：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[27/Nov/2018:22:18:00]</span> <span class="string">"<span class="keyword">GET</span> /test.git/info/refs?service=git-upload-pack HTTP/1.1"</span> <span class="number">200</span> <span class="number">363</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span>``<span class="string">[27/Nov/2018:22:18:00]</span> <span class="string">"<span class="keyword">POST</span> /test.git/git-upload-pack HTTP/1.1"</span> <span class="number">200</span> <span class="number">306</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>git pull</code>：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[27/Nov/2018:22:20:25]</span> <span class="string">"<span class="keyword">GET</span> /test.git/info/refs?service=git-upload-pack HTTP/1.1"</span> <span class="number">200</span> <span class="number">363</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span>``<span class="string">[27/Nov/2018:22:20:25]</span> <span class="string">"<span class="keyword">POST</span> /test.git/git-upload-pack HTTP/1.1"</span> <span class="number">200</span> <span class="number">551</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>git push</code>：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[27/Nov/2018:22:19:33]</span> <span class="string">"<span class="keyword">GET</span> /test.git/info/refs?service=git-receive-pack HTTP/1.1"</span> <span class="number">401</span> <span class="number">204</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span>``admin <span class="string">[27/Nov/2018:22:19:33]</span> <span class="string">"<span class="keyword">GET</span> /test.git/info/refs?service=git-receive-pack HTTP/1.1"</span> <span class="number">200</span> <span class="number">193</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span>``admin <span class="string">[27/Nov/2018:22:19:33]</span> <span class="string">"<span class="keyword">POST</span> /test.git/git-receive-pack HTTP/1.1"</span> <span class="number">200</span> <span class="number">63</span> <span class="string">"-"</span> <span class="string">"git/1.9.1"</span></span><br></pre></td></tr></table></figure>
<p>可以看到执行 clone 和 pull 请求的接口是一样的，先请求 <code>/info/refs?service=git-upload-pack</code>，然后再请求 <code>/git-upload-pack</code>；而 push 是先请求 <code>/info/refs?service=git-receive-pack</code>，然后再请求 <code>/git-receive-pack</code>，所以在上面的 lighttpd 的配置中我们看到了两条记录，如果要对 push 做访问控制，那么对这两个请求都要限制。关于 Git 传输的原理可以参考 《Pro Git》的 <a href="https://git-scm.com/book/zh/v2/Git-内部原理-传输协议" target="_blank" rel="external nofollow noopener noreferrer">Git 内部原理 - 传输协议</a> 这一节。</p>
<p>我们依葫芦画瓢，Nginx 配置文件如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">location @auth &#123;<span class="string">``</span>    <span class="string">``</span>auth_basic <span class="string">"Git Server"</span>;<span class="string">``</span>    <span class="string">``</span>auth_basic_user_file /etc/nginx/passwd;<span class="string">` `</span>    <span class="string">``</span><span class="keyword">include</span> fastcgi_params;<span class="string">``</span>    <span class="string">``</span>fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend;<span class="string">``</span>    <span class="string">``</span>fastcgi_param GIT_HTTP_EXPORT_ALL <span class="string">""</span>;<span class="string">``</span>    <span class="string">``</span>fastcgi_param GIT_PROJECT_ROOT /git/repo;<span class="string">``</span>    <span class="string">``</span>fastcgi_param PATH_INFO $uri;<span class="string">``</span>    <span class="string">``</span>fastcgi_param REMOTE_USER $remote_user;<span class="string">``</span>    <span class="string">``</span>fastcgi_pass <span class="symbol">unix:</span>/var/run/fcgiwrap.socket;<span class="string">``</span>&#125;<span class="string">` `</span>location / &#123;<span class="string">``</span>    <span class="string">``</span>error_page <span class="number">418</span> = @auth;<span class="string">``</span>    <span class="string">``</span><span class="keyword">if</span> ( $query_string = <span class="string">"service=git-receive-pack"</span> ) &#123; <span class="keyword">return</span> <span class="number">418</span>; &#125;<span class="string">``</span>    <span class="string">``</span><span class="keyword">if</span> ( $uri ~ <span class="string">"git-receive-pack$"</span> ) &#123; <span class="keyword">return</span> <span class="number">418</span>; &#125;<span class="string">` `</span>    <span class="string">``</span><span class="keyword">include</span> fastcgi_params;<span class="string">``</span>    <span class="string">``</span>fastcgi_param SCRIPT_FILENAME /usr/lib/git-core/git-http-backend;<span class="string">``</span>    <span class="string">``</span>fastcgi_param GIT_HTTP_EXPORT_ALL <span class="string">""</span>;<span class="string">``</span>    <span class="string">``</span>fastcgi_param GIT_PROJECT_ROOT /git/repo;<span class="string">``</span>    <span class="string">``</span>fastcgi_param PATH_INFO $uri;<span class="string">``</span>    <span class="string">``</span>fastcgi_param REMOTE_USER $remote_user;<span class="string">``</span>    <span class="string">``</span>fastcgi_pass <span class="symbol">unix:</span>/var/run/fcgiwrap.socket;<span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中相同的配置我们也可以用 <code>include</code> 指令放在一个共用的配置文件里，这样我们就实现了在 push 的时候需要填写用户名和密码了。我们通过 Nginx 的 <code>auth_basic_user_file</code> 指令来做身份认证，用户名和密码保存在 <code>/etc/nginx/passwd</code> 文件中，这个文件可以使用上面提到的 apache2-utils 包里的 htpasswd 来生成：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@myserver</span><span class="symbol">:/</span><span class="comment"># htpasswd -cb /etc/nginx/passwd admin 123456</span></span><br></pre></td></tr></table></figure>
<p>另外，在 push 的时候，有时候可能会遇到 <code>unpack failed: unable to create temporary object directory</code> 这样的提示错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aneasystone@little-stone:~/working/test$ git push origin master``Counting objects: 3, done.``Writing objects: 100% (3/3), 193 bytes | 0 bytes/s, done.``Total 3 (delta 0), reused 0 (delta 0)``error: unpack failed: unable to <span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">object</span> <span class="keyword">directory</span><span class="string">``</span><span class="keyword">To</span> <span class="keyword">http</span>://myserver/test.git<span class="string">``</span> <span class="string">``</span>! [remote rejected] <span class="keyword">master</span> -&gt; <span class="keyword">master</span> (unpacker <span class="keyword">error</span>)<span class="string">``</span><span class="keyword">error</span>: <span class="keyword">failed</span> <span class="keyword">to</span> push <span class="keyword">some</span> refs <span class="keyword">to</span> <span class="string">'http://myserver/test.git'</span></span><br></pre></td></tr></table></figure>
<p>这一般情况下都是由于 Git 仓库目录的权限问题导致的，在这里 Git 仓库的根目录 <code>/git/repo</code> 是 root 创建的，而运行 nginx 和 fcgiwrap 的用户都是 www-data，我们可以把 Git 仓库目录设置成对所有人可读可写，也可以像下面这样将它的拥有者设置成 www-data 用户：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@myserver</span><span class="symbol">:/</span><span class="comment"># chown -R www-data:www-data /git/repo</span></span><br></pre></td></tr></table></figure>
<h3 id="凭证管理"><a href="#凭证管理" class="headerlink" title="凭证管理"></a>凭证管理</h3><p>上面我们站在管理员的角度解决了用户身份认证的问题，但是站在用户的角度，每次提交代码都要输入用户名和密码是一件很痛苦的事情。在上面介绍 SSH 协议时，我们可以使用 SSH 协议自带的公钥认证机制来省去输入密码的麻烦，那么在 HTTP 协议中是否存在类似的方法呢？答案是肯定的，那就是 Git 的凭证存储工具：<code>credential.helper</code>。</p>
<p>譬如像下面这样，将用户名和密码信息保存在缓存中：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global credential.helper cache</span><br></pre></td></tr></table></figure>
<p>这种方式默认只保留 15 分钟，如果要改变保留的时间，可以通过 <code>--timeout</code> 参数设置，或者像下面这样，将密码保存在文件中：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global credential.helper store</span><br></pre></td></tr></table></figure>
<p>这种方式虽然可以保证密码不过期，但是要记住的是，这种方式密码是以明文的方式保存在你的 home 目录下的。可以借鉴操作系统自带的凭证管理工具来解决这个问题， 比如 OSX Keychain 或者 <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" target="_blank" rel="external nofollow noopener noreferrer">Git Credential Manager for Windows</a>。更多的内容可以参考<a href="https://git-scm.com/book/zh/v2/Git-工具-凭证存储" target="_blank" rel="external nofollow noopener noreferrer">《Pro Git》凭证存储</a> 这一节。</p>
<p>除此之外，还有一种更简单粗暴的方式：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">aneasystone<span class="meta">@little</span>-<span class="string">stone:</span><span class="regexp">~/working$ git clone http:/</span><span class="regexp">/admin:123456@myserver/</span>test.git</span><br></pre></td></tr></table></figure>
<h2 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h2><p>这一节对 Git 的四大协议做一个综合对比。</p>
<ul>
<li>本地协议<ul>
<li>优点：架设简单，不依赖外部服务，直接使用现有文件和网络权限，常用于共享文件系统</li>
<li>缺点：共享文件系统的配置和使用不方便，且无法保护仓库被意外损坏，传输性能较低</li>
</ul>
</li>
<li>SSH 协议<ul>
<li>优点：架设简单，所有数据经过授权加密，数据传输很安全，传输性能很高</li>
<li>缺点：不支持匿名访问，配置 SSH 的密钥对小白用户有一定的门槛</li>
</ul>
</li>
<li>Git 协议<ul>
<li>优点：对开放的项目很适用，无需授权，传输性能最高</li>
<li>缺点：缺乏授权机制，架设较麻烦，企业一般不会默认开放 9418 端口需要另行添加</li>
</ul>
</li>
<li>HTTP/S 协议<ul>
<li>优点：同时支持授权访问和无授权访问，传输性能较高，配合 HTTPS 也可以实现数据安全</li>
<li>缺点：架设 HTTP 服务较麻烦，认证凭证不好管理</li>
</ul>
</li>
</ul>
<h2 id="更高级的工具"><a href="#更高级的工具" class="headerlink" title="更高级的工具"></a>更高级的工具</h2><p>上面介绍的是搭建 Git 服务器最基本的方法，如果你只是希望能找一个版本控制系统来替代现有的 SVN，这也许就足够了。但如果你希望你的版本控制系统能拥有一个更友好的 UI 界面，能更好的管理你的用户和权限，能支持更现代的 Pull Request 功能以及能和 CI/CD 系统更紧密的联系起来，你就需要一个更高级的工具，你可以试试 <a href="https://git-scm.com/book/zh/v2/服务器上的-Git-GitWeb" target="_blank" rel="external nofollow noopener noreferrer">GitWeb</a>、<a href="http://gitolite.com/gitolite/" target="_blank" rel="external nofollow noopener noreferrer">Gitolite</a>、<a href="https://about.gitlab.com/" target="_blank" rel="external nofollow noopener noreferrer">Gitlab</a>、<a href="https://gogs.io/" target="_blank" rel="external nofollow noopener noreferrer">Gogs</a>、<a href="https://gitea.io/zh-cn/" target="_blank" rel="external nofollow noopener noreferrer">Gitea</a>，当然，如果你愿意，你也可以把代码放在那些流行的代码托管平台上，比如 <a href="https://github.com/" target="_blank" rel="external nofollow noopener noreferrer">Github</a>、<a href="https://bitbucket.org/" target="_blank" rel="external nofollow noopener noreferrer">Bitbucket</a> 等等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.aneasystone.com/archives/2018/12/build-your-own-git-server.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.aneasystone.com/archives/2018/12/build-your-own-git-server.html</a></li>
<li><a href="https://git-scm.com/book/zh/v2/服务器上的-Git-协议" target="_blank" rel="external nofollow noopener noreferrer">https://git-scm.com/book/zh/v2/服务器上的-Git-协议</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Test</title>
    <url>/posts/4dea1165/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><a id="more"></a><h2 id="Test-测试"><a href="#Test-测试" class="headerlink" title="Test 测试"></a>Test 测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试一般是用来测试我们的代码逻辑有没有问题，有没有按照我们期望的运行，以保证代码质量。</p><p>大多数的单元测试，都是对某一个函数方法进行测试，以尽可能的保证没有问题或者问题可被我们预知。为了达到这个目的，我们可以使用各种手段、逻辑，模拟不同的场景进行测试。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sum := Add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> sum == <span class="number">3</span> &#123;</span><br><span class="line">		t.Log(<span class="string">"the result is ok"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">"the result is wrong"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在终端的项目目录下运行<code>go test -v</code>就可以看到测试结果了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">        add_test.go:26: the result is ok</span><br><span class="line">PASS</span><br><span class="line">ok             0.007s</span><br></pre></td></tr></table></figure>
<p>Go语言为我们提供了测试框架，以便帮助我们更容易的进行单元测试，但是要使用这个框架，需要遵循如下几点规则：</p>
<ol>
<li>含有单元测试代码的go文件必须以<code>_test.go</code>结尾，Go语言测试工具只认符合这个规则的文件</li>
<li>单元测试文件名<code>_test.go</code>前面的部分最好是被测试的方法所在go文件的文件名，比如例子中是<code>add_test.go</code>，因为测试的<code>Add</code>函数，在<code>add.go</code>文件里</li>
<li>单元测试的函数名必须以<code>Test</code>开头，是可导出公开的函数</li>
<li>测试函数的签名必须接收一个指向<code>testing.T</code>类型的指针，并且不能返回任何值</li>
<li>函数名最好是Test+要测试的方法函数名，比如例子中是<code>TestAdd</code>，表示测试的是<code>Add</code>这个这个函数</li>
</ol>
<h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>我们尽可能的模拟更多的场景来测试我们代码的不同情况，但是有时候的确也有忘记测试的代码，这时候我们就需要测试覆盖率作为参考了。</p>
<p>由单元测试的代码，触发运行到的被测试代码的代码行数占所有代码行数的比例，被称为<strong>测试覆盖率</strong>，代码覆盖率不一定完全精准，但是可以作为参考，可以帮我们测量和我们预计的覆盖率之间的差距，<code>go test</code>工具，就为我们提供了这么一个度量测试覆盖率的能力。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tag.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tag</span><span class="params">(tag <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> tag &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Android"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Go"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Java"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Python"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tag_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTag</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	Tag(<span class="number">1</span>)</span><br><span class="line">	Tag(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们使用<code>go test</code>工具运行单元测试，和前几次不一样的是，我们要显示测试覆盖率，所以要多加一个参数<code>-coverprofile</code>,所以完整的命令为：<code>go test -v -coverprofile=c.out</code>，<code>-coverprofile</code>是指定生成的覆盖率文件，例子中是<code>c.out</code>，这个文件一会我们会用到。现在我们看终端输出，已经有了一个覆盖率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v -coverprofile=c.out</span><br><span class="line">=== RUN   TestTag</span><br><span class="line">Android</span><br><span class="line">Go</span><br><span class="line">--- PASS: TestTag (0.00s)</span><br><span class="line">PASS</span><br><span class="line">coverage: 50.0% of statements</span><br><span class="line">ok  	<span class="built_in">test</span>	0.001s</span><br></pre></td></tr></table></figure>
<p><code>coverage: 50.0% of statements</code>，50%的测试覆盖率，还没有到100%，那么我们看看还有那些代码没有被测试到。这就需要我们刚刚生成的测试覆盖率文件<code>c.out</code>生成测试覆盖率报告了。生成报告有go为我们提供的工具，使用<code>go tool cover -html=c.out -o=tag.html</code>，即可生成一个名字为<code>tag.html</code>的HTML格式的测试覆盖率报告，这里有详细的信息告诉我们哪一行代码测试到了，哪一行代码没有测试到。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2018-09-16-golang-test-cover.png"></p>
<p>从上图中可以看到，标记为绿色的代码行已经被测试了；标记为红色的还没有测试到，有2行的，现在我们根据没有测试到的代码逻辑，完善我的单元测试代码即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTag</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	Tag(<span class="number">1</span>)</span><br><span class="line">	Tag(<span class="number">2</span>)</span><br><span class="line">	Tag(<span class="number">3</span>)</span><br><span class="line">    Tag(<span class="number">4</span>)</span><br><span class="line">	Tag(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Benchmark测试"><a href="#Benchmark测试" class="headerlink" title="Benchmark测试"></a>Benchmark测试</h2><p>基准测试，是一种测试代码性能的方法，比如你有多种不同的方案，都可以解决问题，那么到底是那种方案性能更好呢？这时候基准测试就派上用场了。</p>
<p>基准测试主要是通过测试CPU和内存的效率问题，来评估被测试代码的性能，进而找到更好的解决方案。比如链接池的数量不是越多越好，那么哪个值才是最优值呢，这就需要配合基准测试不断调优了。</p>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>基准测试代码的编写和单元测试非常相似，它也有一定的规则，我们先看一个示例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// itoa_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSprintf</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	num:=<span class="number">10</span></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		fmt.Sprintf(<span class="string">"%d"</span>,num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个基准测试的例子，从中我们可以看出以下规则：</p>
<ol>
<li>基准测试的代码文件必须以_test.go结尾</li>
<li>基准测试的函数必须以Benchmark开头，必须是可导出的</li>
<li>基准测试函数必须接受一个指向Benchmark类型的指针作为唯一参数</li>
<li>基准测试函数不能有返回值</li>
<li><code>b.ResetTimer</code>是重置计时器，这样可以避免for循环之前的初始化代码的干扰</li>
<li>最后的for循环很重要，被测试的代码要放到循环里</li>
<li>b.N是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能</li>
</ol>
<p>下面我们运行下基准测试，看看效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=. -run=none</span><br><span class="line">BenchmarkSprintf-8      20000000               117 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      flysnow.org/hello       2.474s</span><br></pre></td></tr></table></figure>
<p>运行基准测试也要使用<code>go test</code>命令，不过我们要加上<code>-bench=</code>标记，它接受一个表达式作为参数，匹配基准测试的函数，<code>.</code>表示运行所有基准测试。</p>
<p>因为默认情况下 <code>go test</code> 会运行单元测试，为了防止单元测试的输出影响我们查看基准测试的结果，可以使用<code>-run=</code>匹配一个从来没有的单元测试方法，过滤掉单元测试的输出，我们这里使用<code>none</code>，因为我们基本上不会创建这个名字的单元测试方法。</p>
<p>下面着重解释下说出的结果，看到函数后面的<code>-8</code>了吗？这个表示运行时对应的GOMAXPROCS的值。接着的<code>20000000</code>表示运行for循环的次数，也就是调用被测试代码的次数，最后的<code>117 ns/op</code>表示每次需要话费117纳秒。</p>
<p>以上是测试时间默认是1秒，也就是1秒的时间，调用两千万次，每次调用花费117纳秒。如果想让测试运行的时间更长，可以通过<code>-benchtime</code>指定，比如3秒。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=. -benchtime=3s -run=none</span><br><span class="line">BenchmarkSprintf-8      50000000               109 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      flysnow.org/hello       5.628s</span><br></pre></td></tr></table></figure>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>上面那个基准测试的例子，其实是一个int类型转为string类型的例子，标准库里还有几种方法，我们看下哪种性能更加。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSprintf</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	num:=<span class="number">10</span></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		fmt.Sprintf(<span class="string">"%d"</span>,num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFormat</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	num:=<span class="keyword">int64</span>(<span class="number">10</span>)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		strconv.FormatInt(num,<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkItoa</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	num:=<span class="number">10</span></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		strconv.Itoa(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行基准测试，看看结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=. -run=none              </span><br><span class="line">BenchmarkSprintf-8   	20000000	        82.8 ns/op</span><br><span class="line">BenchmarkFormat-8    	500000000	         3.06 ns/op</span><br><span class="line">BenchmarkItoa-8      	300000000	         4.78 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  	<span class="built_in">test</span>	5.508s</span><br></pre></td></tr></table></figure>
<p>从结果上看<code>strconv.FormatInt</code>函数是最快的，其次是<code>strconv.Itoa</code>，然后是<code>fmt.Sprintf</code>最慢，前两个函数性能达到了最后一个的3倍多。那么最后一个为什么这么慢的，我们再通过<code>-benchmem</code>找到根本原因。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=. -run=none              </span><br><span class="line">BenchmarkSprintf-8   	20000000	        83.5 ns/op	      16 B/op	       2 allocs/op</span><br><span class="line">BenchmarkFormat-8    	500000000	         3.08 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkItoa-8      	300000000	         4.73 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok  	<span class="built_in">test</span>	5.518s</span><br></pre></td></tr></table></figure>
<p><code>-benchmem</code>可以提供每次操作分配内存的次数，以及每次操作分配的字节数。从结果我们可以看到，性能高的两个函数，每次操作都是进行0次内存分配，而最慢的那个要分配2次；性能高的每次操作分配2个字节内存，而慢的那个函数每次需要分配0字节的内存。从这个数据我们就知道它为什么这么慢了，内存分配都占用都太高。</p>
<h2 id="Example测试"><a href="#Example测试" class="headerlink" title="Example测试"></a>Example测试</h2><h2 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h2><h2 id="Main测试"><a href="#Main测试" class="headerlink" title="Main测试"></a>Main测试</h2><h2 id="HTTP测试"><a href="#HTTP测试" class="headerlink" title="HTTP测试"></a>HTTP测试</h2>]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>端午</title>
    <url>/posts/6a1bd212/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今年的端午与往年相比好像来的更晚一些。印象中的端午总是和高考，和父亲节联系在一起，今年也不例外。只是，今年的六月对我来说，高考已经远去，父亲节也如往年一般，更多的是因为N，才有了别样的记忆。</p>
<a id="more"></a>
<p>两个月的时间，说短不短，说长也不长，但是这两个月在我看来，却好像发生了很多很多的故事，比以往任何的两个月都要漫长，都要精彩。这是一段从春天走向夏天的故事，希望也是一段从稚嫩走向成熟的故事。</p>
<p>回看自己的Period相册，发现这两个月上传的图片比以往所有累计的图片都多。也许是若有所思，也许是喜欢上了上班走路的这段路，每天就这样看看天，看看云，看看西山的夕阳，看看路边的树影，也会突然产生生活很美这样很矫情的感受。</p>
<p><img alt="实习下班的路上，雨后的天好好看，西山的夕阳，路边的树影，一切都有了诗意" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2018-06-13_sunset.jpg"></p>
<p>公司旁边有一个基督教堂，没实习之前也有路过这里，但是从来没有意识到原来它离我们这么近。</p>
<p>曾经也和一个台湾妹子一起逛过北京的各种基督教堂，我们都不是基督徒，当时更多的只是从一个外来者的角度看窥探这些信徒他们的世界，更多的是一种好奇，一种历史的俯察，一种建筑的审美，一种中西文化融合的感慨。</p>
<p>而在这两个多月，这个曾经以为文化上的外来者彻底的生活化了，你开始习惯它在你身边的存在。习惯于每周日早上教堂传来的钟声，习惯于时不时在这里举办的婚礼，习惯于参加祷告的人们在这里聚集。这就是生活啊，匆忙却永远包裹不住活力的生活。</p>
<p><img alt="下班必定会路过的教堂，皎洁的月光，映衬十字架的光芒，照耀着四周匆忙而充满活力的世俗世界" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2018-05-28_church.jpg"></p>
<p><img alt="周日参加祷告的信徒们，下着淅淅沥沥的小雨，你甚至觉得他们就是在参加生活的一场聚会" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2018-06-03_worship.jpg"></p>
<p>写到这里，真的觉得自己很矫情了，矫情就矫情呗，就当是简单停下来，回顾一下过往的生活。关于Period相册，还是在保研结束那会，就要搬离呆了一年多的创新实验室的时候创建。一时觉得很多时候有些人有些事情一下子进入你的生活，可是你却根本就没有意识，直到最后彻底告别的时候，才懂得它对你存在的意义。后来一直断断续续的上传一些生活的痕迹，直到最近才开始密集的上传。</p>
<p>上一个阶段上传的最后一张图片还是在去年高考的时候。</p>
<p><img alt="2017年夏天的高考，当时的我刚刚本科毕业，每天骑着自行车来回于西二旗和颐和园之间" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-06-06_college-admission.jpg"></p>
<p>那会正是本科刚刚毕业，每天早上骑车路过101中学，一路向北，趁着太阳还没有高高升起，赶往西二旗。一直觉得西二旗，尤其是百度科技园是一个很奇怪的存在，这种感觉可能只有你去过才会感受到。从颐和园到西二旗的路上十分荒凉，中间经过肖家河、农业大学那一带，你会觉得那是一种和北京不太匹配的无序和混乱，有一种城乡结合部的感觉。</p>
<p><img alt="农大南路附近，交错的十字路口准备过红绿灯的人们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-08-23_road.jpg"></p>
<p><img alt="肖家河桥上，不绝的车流，远处永远是热火朝天的建设图景" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-08-23-bridge.jpg"></p>
<p>可是突然一转，当你看到了百度科技园，你又会看到超出普通北京所拥有的现代感和科技感。又或者，这才是北京，永远是那么的丰富，展现给你的不单单只有一面。</p>
<p><img alt="五栋建筑贯通在一起的百度科技园，第一次来的时候你会惊讶于它独特的科技感" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-08-25_baidu.jpg"></p>
<p><img alt="隔壁的新浪，还有一直在建设中的腾讯大厦" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2017-08-25_sina.jpg"></p>
<p>去年的那个夏天很忙，除了白天在百度实习，晚上还自己参加了GSoC，和加拿大的开源组织一起协作。不知道这种状态到底是好还是不好，总是显得自己很忙，好像也有所收获，但是也总是感觉少了一点什么。大三那年的夏天好像也是这个样子，在呆呆老师指导下参加了全国电子设计竞赛，有收获也有遗憾，和Y还有S一起去上海，最后比赛的合影都没留下来几张，只在英特尔的官微上找到了唯一的一张。</p>
<p><img alt="16年夏天去上海参加电子设计竞赛的我们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2016-07-23-time.jpg"></p>
<p>好像又扯了很远，端午节啊，更何况还有父亲节，本来应该回家和爸妈一起的，却最终还是呆在了北京。上次回家还是4月底，正是春花灿烂的时候。那会感觉心情也很好，就像这些花一样，是多么的明艳可爱。</p>
<p><img alt="回家的那天早上，学校外边的花正明艳灿烂" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2018-06-18_flower.jpg"></p>
<p>夏天就要到了，夏天已经到了，不知道这个夏天又会发生怎样的故事呢？</p>
<hr>
<p>矫情矫情真矫情，端午节咯，开开心心的，加班还能工资翻倍，开心！</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell笔记</title>
    <url>/posts/f8586b35/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文记录了常用的shell笔记</p>
<a id="more"></a>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul>
<li><code>?</code>字符代表单个字符，<code>?</code>不能匹配空字符。</li>
<li><code>*</code>代表任意数量的字符，可以匹配空字符。</li>
<li><code>[...]</code>匹配方括号之中的任意一个字符，比如<code>[aeiou]</code>可以匹配五个元音字母。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设当前目录下存在，文件 a.txt、b.txt、c.txt、ab.txt、report1.txt、report2.txt 和 report3.txt</span></span><br><span class="line">$ ls ?.txt</span><br><span class="line">a.txt b.txt c.txt</span><br><span class="line"></span><br><span class="line">$ ls ??.txt</span><br><span class="line">ab.txt</span><br><span class="line"></span><br><span class="line">$ ls [ab].txt</span><br><span class="line">a.txt b.txt</span><br><span class="line"></span><br><span class="line">$ ls *[ab].txt</span><br><span class="line">ab.txt a.txt b.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[start-end]</code>表示一个连续的范围。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls [a-c].txt</span><br><span class="line">a.txt b.txt c.txt</span><br><span class="line"></span><br><span class="line">$ ls report[0-9].txt</span><br><span class="line">report1.txt report2.txt report3.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[^...]</code>和<code>[!...]</code>表示匹配不在方括号里面的字符（不包括空字符）。这两种写法是等价的。这种模式下也可以使用连续范围的写法<code>[!start-end]</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls [^a].txt</span><br><span class="line">b.txt c.txt</span><br><span class="line"></span><br><span class="line">$ ls report[!2-3].txt</span><br><span class="line">report1.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>{...}</code> 表示匹配大括号里面的所有模式，模式之间使用逗号分隔。它可以用于多字符的模式。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> d&#123;a,e,i,u,o&#125;g</span><br><span class="line">dag deg dig dug dog</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;cat,dog&#125;</span><br><span class="line">cat dog</span><br></pre></td></tr></table></figure>
<ul>
<li><code>{...}</code>与<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不存在 a.txt 和 b.txt</span></span><br><span class="line">$ ls [ab].txt</span><br><span class="line">ls: [ab].txt: No such file or directory</span><br><span class="line"></span><br><span class="line">$ ls &#123;a,b&#125;.txt</span><br><span class="line">ls: a.txt: No such file or directory</span><br><span class="line">ls: b.txt: No such file or directory</span><br></pre></td></tr></table></figure>
<ul>
<li>大括号可以嵌套。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;j&#123;p,pe&#125;g,png&#125;</span><br><span class="line">jpg jpeg png</span><br></pre></td></tr></table></figure>
<ul>
<li>大括号也可以与其他模式联用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;cat,d*&#125;</span><br><span class="line">cat dawg dg dig dog doug dug</span><br></pre></td></tr></table></figure>
<ul>
<li><code>{start..end}</code>会匹配连续范围的字符。如果遇到无法解释的扩展，模式会原样输出。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> d&#123;a..d&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;11..15&#125;</span><br><span class="line">11 12 13 14 15</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;a1..3c&#125;</span><br><span class="line">&#123;a1..3c&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h4><p>ld命令是二进制工具集GNU Binutils的一员，是GNU链接器，用于将目标文件与库链接为可执行程序或库文件。</p>
<h4 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h4><h4 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h4><h3 id="查找搜索"><a href="#查找搜索" class="headerlink" title="查找搜索"></a>查找搜索</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find [path] -name []</span></span><br><span class="line">$ find / -name hello[a-z].<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据文件时间戳搜索</span></span><br><span class="line">$ find / -<span class="built_in">type</span> f -atime -7 <span class="comment"># 搜索近七天内被访问过的所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据文件大小搜索</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -size +10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配文件</span></span><br><span class="line">$ find . <span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索但跳过指定目录</span></span><br><span class="line">$ find . -path <span class="string">"./sk"</span> -prune -o -name <span class="string">"*.txt"</span> <span class="comment"># -o means logical OR</span></span><br></pre></td></tr></table></figure>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><h4 id="ack"><a href="#ack" class="headerlink" title="ack"></a>ack</h4><h4 id="ag"><a href="#ag" class="headerlink" title="ag"></a>ag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="磁盘和文件系统"><a href="#磁盘和文件系统" class="headerlink" title="磁盘和文件系统"></a>磁盘和文件系统</h3><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</span></span><br><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 931.5G  0 disk</span><br><span class="line">└─sda1   8:1    0 931.5G  0 part /data</span><br><span class="line">sdb      8:16   0 119.2G  0 disk</span><br><span class="line">├─sdb1   8:17   0   512M  0 part /boot/efi</span><br><span class="line">└─sdb2   8:18   0 118.8G  0 part /</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件系统的磁盘空间占用情况</span></span><br><span class="line">$ df -Tlh</span><br><span class="line">Filesystem     Type      Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs          tmpfs     1.6G  1.9M  1.6G   1% /run</span><br><span class="line">/dev/sdb2      ext4      117G  110G  613M 100% /</span><br><span class="line">/dev/sdb1      vfat      511M  6.1M  505M   2% /boot/efi</span><br><span class="line">/dev/sda1      ext4      916G  611G  260G  71% /data</span><br><span class="line"></span><br><span class="line"><span class="comment"># fdisk磁盘分区，分区有大小限制为2T</span></span><br><span class="line">$ fdisk -l <span class="comment"># 查看系统上的硬盘</span></span><br><span class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: gpt</span><br><span class="line">Disk identifier: 67A1E9ED-BCBF-44B4-93FD-8FA305437B2E</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors   Size Type</span><br><span class="line">/dev/sda1   2048 1953525134 1953523087 931.5G Linux filesystem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 119.2 GiB, 128035676160 bytes, 250069680 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: gpt</span><br><span class="line">Disk identifier: 0AA99923-E2A0-4D46-9A95-71036FC86EEF</span><br><span class="line"></span><br><span class="line">Device       Start       End   Sectors   Size Type</span><br><span class="line">/dev/sdb1     2048   1050623   1048576   512M EFI System</span><br><span class="line">/dev/sdb2  1050624 250068991 249018368 118.8G Linux filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># parted磁盘分区，相对fdisk可以对更大的磁盘进行划分</span></span><br></pre></td></tr></table></figure>
<h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs [options] [-t &lt;vfs-type&gt;] &lt;device&gt;</span></span><br><span class="line">mkfs -t ext4 /dev/sdc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># mount</span></span><br><span class="line"><span class="comment"># mount [options] [device] [mount-point]</span></span><br><span class="line"><span class="comment"># -t vfstype 指定文件系统的类型</span></span><br><span class="line"><span class="comment"># -o options 主要用来描述设备或档案的挂接方式</span></span><br><span class="line"><span class="comment"># 		loop：用来把一个文件当成硬盘分区挂接上系统</span></span><br><span class="line"><span class="comment">#			ro：采用只读方式挂接设备</span></span><br><span class="line"><span class="comment">#			rw：采用读写方式挂接设备</span></span><br><span class="line"><span class="comment">#			iocharset：指定访问文件系统所用字符集</span></span><br><span class="line">mount -t ext4 /dev/sdc1 /mnt/lfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># umount</span></span><br><span class="line">umount /mnt/lfs</span><br></pre></td></tr></table></figure>
<h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地的/dev/hdb整盘备份到/dev/hdd</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/hdb of=/dev/hdd</span><br><span class="line"><span class="comment"># 将/dev/hdb全盘数据备份到指定路径的image文件</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/hdb of=/root/image</span><br><span class="line"><span class="comment"># 将备份文件恢复到指定盘</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/root/image of=/dev/hdb</span><br><span class="line"><span class="comment"># 备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/hdb | gzip &gt; /root/image.gz</span><br><span class="line"><span class="comment"># 压缩的备份文件恢复到指定盘</span></span><br><span class="line">$ gzip -dc /root/image.gz | dd of=/dev/hdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份与恢复MBR</span></span><br><span class="line"><span class="comment">## 备份磁盘开始的512个字节大小的MBR信息到指定文件：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/hda of=/root/image count=1 bs=512 <span class="comment"># count=1指仅拷贝一个块；bs=512指块大小为512个字节</span></span><br><span class="line"><span class="comment">## 恢复：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/root/image of=/dev/had <span class="comment"># 将备份的MBR信息写到磁盘开始部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝内存内容到硬盘</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/mem of=/root/mem.bin bs=1024 (指定块大小为1k)</span><br><span class="line"><span class="comment"># 拷贝光盘内容到指定文件夹，并保存为cd.iso文件</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom(hdc) of=/root/cd.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加swap分区文件大小</span></span><br><span class="line"><span class="comment">## 第一步：创建一个大小为256M的文件：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1024 count=262144</span><br><span class="line"><span class="comment">## 第二步：把这个文件变成swap文件：</span></span><br><span class="line">$ mkswap /swapfile</span><br><span class="line"><span class="comment">## 第三步：启用这个swap文件：</span></span><br><span class="line">$ swapon /swapfile</span><br><span class="line"><span class="comment">## 第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件：</span></span><br><span class="line">$ swapfile    swap    swap    default   0 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 销毁磁盘数据</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/urandom of=/dev/hda1</span><br><span class="line"><span class="comment"># 注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试硬盘的读写速度</span></span><br><span class="line"><span class="variable">$dd</span> <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line">$ dd <span class="keyword">if</span>=/root/1Gb.file bs=64k | dd of=/dev/null</span><br><span class="line"><span class="comment"># 通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定硬盘的最佳块大小：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero bs=2048 count=500000 of=/root/1Gb.file</span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero bs=4096 count=250000 of=/root/1Gb.file</span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</span><br><span class="line"><span class="comment"># 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复硬盘：</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/sda of=/dev/sda</span><br><span class="line"><span class="comment"># 当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生。并且这个过程是安全、高效的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用netcat远程备份</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/hda bs=16065b | netcat &lt; targethost-IP &gt; 1234</span><br><span class="line"><span class="comment"># 在源主机上执行此命令备份/dev/hda</span></span><br><span class="line">$ netcat -l -p 1234 | dd of=/dev/hdc bs=16065b</span><br><span class="line"><span class="comment"># 在目的主机上执行此命令来接收数据并写入/dev/hdc</span></span><br><span class="line">$ netcat -l -p 1234 | bzip2 &gt; partition.img</span><br><span class="line">$ netcat -l -p 1234 | gzip &gt; partition.img</span><br><span class="line"><span class="comment"># 以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值）</span></span><br><span class="line">$ <span class="built_in">echo</span> A | dd of=bigfile seek=<span class="variable">$i</span> bs=1 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mknod 创建块设备或者字符设备文件</span></span><br><span class="line"><span class="comment"># mknod [OPTION]... NAME TYPE [MAJOR MINOR]</span></span><br><span class="line">$ mknod /dev/sdb4 b 1 1 <span class="comment"># 创建一个块设备</span></span><br><span class="line">$ mknod /dev/console5 c 5 1 <span class="comment"># 创建一个字符设备</span></span><br></pre></td></tr></table></figure>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加用户</span></span><br><span class="line">$ adduser houmin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把用户加到组</span></span><br><span class="line">$ usermod -aG sudo houmin</span><br></pre></td></tr></table></figure>
<h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><ul>
<li>硬链接：通过索引 <code>inode</code>来映射到文件数据。<code>linux</code>允许多个文件名指向同一 <code>inode</code>。删除硬链接并不会导致数据实体被删除，只有最后一个链接被删除，同时磁盘有新数据要存放时，才能导致数据实体删除。</li>
<li>软链接：也称符号链接，类似于windows系统中的快捷方式，与硬链接不同，软链接就是一个普通文件，只是数据块内容有点特殊，文件用户数据块中存放的内容是另一文件的路径名的指向，通过这个方式可以快速定位到软连接所指向的源文件实体。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建硬链接</span></span><br><span class="line">ln [target] [link_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建软链接</span></span><br><span class="line">ln -s [target] [link_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改软链接</span></span><br><span class="line">ln -snf [new_target] [link_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除软链接</span></span><br><span class="line">rm -rf [link_name]</span><br></pre></td></tr></table></figure>
<h3 id="远程同步文件"><a href="#远程同步文件" class="headerlink" title="远程同步文件"></a>远程同步文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scp: secure copy，用于远程的文件的复制</span></span><br><span class="line"><span class="comment"># -r 递归复制整个目录</span></span><br><span class="line">scp [option] [<span class="built_in">source</span>] [dest]</span><br><span class="line"></span><br><span class="line"><span class="comment"># rsync: remote sync, 用于数据镜像备份，可用于增量更新</span></span><br><span class="line"><span class="comment"># -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span></span><br><span class="line"><span class="comment"># -v, --verbose 详细模式输出</span></span><br><span class="line"><span class="comment"># -z, --compress 对备份的文件在传输时进行压缩处理</span></span><br><span class="line"><span class="comment"># -u 加上该选项后，如果DEST中的文件比SRC新，则不同步</span></span><br><span class="line"><span class="comment"># -P, --partial --progress 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span></span><br><span class="line"><span class="comment"># --delete 删除DEST中SRC没有的文件</span></span><br><span class="line"><span class="comment"># --exclude 过滤指定文件，如--exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rsync [option] [source] [dest]</span></span><br><span class="line">$ rsync -avP houmin@host1:~/data alice@host2:/data/</span><br></pre></td></tr></table></figure>
<h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><h4 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt 命令就是 apt-get、apt-cache 和 apt-config 中最常用命令选项的集合</span></span><br><span class="line">$ sudo apt update     <span class="comment"># 更新包索引文</span></span><br><span class="line">$ sudo apt install nginx    <span class="comment"># 安装包</span></span><br><span class="line">$ sudo apt install vim=2:8.0.1453-1ubuntu1  <span class="comment"># 安装指定版本的包</span></span><br><span class="line">$ sudo apt install name.deb    <span class="comment"># 安装本地的 deb 包文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统中有更新的包</span></span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除包</span></span><br><span class="line"><span class="comment"># 其中 remove 命令会保留配置文件，而 purge 命令会把配置文件一起删除</span></span><br><span class="line">$ sudo apt remove nmap</span><br><span class="line">$ sudo apt purge nmap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包的信息</span></span><br><span class="line">$ apt show vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出指定条件的包列表</span></span><br><span class="line">$ apt list vim*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包</span></span><br><span class="line">$ apt search docker</span><br></pre></td></tr></table></figure>
<h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">$ tar -xf file.tar        <span class="comment"># 解压 tar包</span></span><br><span class="line">$ tar -xzf file.tar.gz    <span class="comment"># 解压tar.gz</span></span><br><span class="line">$ tar -xjf file.tar.bz2   <span class="comment"># 解压 tar.bz2</span></span><br><span class="line">$ tar -xJf file.tar.xz    <span class="comment"># 解压 tar.xz</span></span><br><span class="line">$ tar -xZf file.tar.Z     <span class="comment"># 解压tar.Z</span></span><br><span class="line">$ unrar e file.rar        <span class="comment"># 解压rar</span></span><br><span class="line">$ unzip file.zip          <span class="comment"># 解压zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩</span></span><br><span class="line">$ tar -cvf jpg.tar *.jpg</span><br><span class="line">$ tar -czf jpg.tar.gz *.jpg</span><br><span class="line">$ tar -cjf jpg.tar.bz2 *.jpg</span><br><span class="line">$ tar -cZf jpg.tar.Z *.jpg</span><br><span class="line">$ rar a jpg.rar *.jpg</span><br><span class="line">$ zip jpg.zip *.jpg</span><br></pre></td></tr></table></figure>
<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><p>cpio是一个非常古老的归档工具，已逐渐被tar替代，但是有些功能是tar不存在的，所以还是分享下它的用法。</p>
<p>cpio用于创建、解压归档文件，也可以对归档文件执行拷入拷出的动作，即向归档文件中追加文件，或从归档文件中提取文件。它也支持tar格式的归档文件，但是对压缩后的tar(如.tar.gz格式)就没法支持了，cpio毕竟不会调用对应的(解)压缩工具。</p>
<p>cpio一般从标准输入获取数据，写入到标准输出，所以一般会结合管道、输入重定向、输出重定向使用。命令格式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cpio –o [abcv]</span><br><span class="line">$ cpio –i [bcdmrtuv] [patterns]</span><br><span class="line">$ cpio –p [adlmuv] [directory]</span><br></pre></td></tr></table></figure>
<p>对应上述三种命令，cpio有三种运行模式：</p>
<ul>
<li><p><strong>Copy-out模式</strong></p>
<p>此模式下，cpio将向归档文件中拷入文件，即进行归档操作，所以称为<strong>归档模式</strong>。它会从标准输入中读取待归档的文件，将它们归档到目标目标中，若未指定归档的目标，将归档到标准输出中。</p>
</li>
<li><p><strong>Copy-in模式</strong></p>
<p>此模式下，cpio将从归档文件中提取文件，或者列出归档文件中的文件列表。它将从标准输入中读取归档文件。</p>
</li>
<li><p><strong>Copy-pass模式</strong></p>
<p>此模式下，从一个目录向另一个目录或从一个文件系统向另一个文件系统复制文件，合并copy-out和copy-in命令的功能。</p>
</li>
</ul>
<p>上面命令的选项如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-o 将文件拷贝打包成文件或者将文件输出到设备上。</span></span><br><span class="line"><span class="deletion">-i 将打包文件解压或者将设备上的备份还原到系统。</span></span><br><span class="line"><span class="deletion">-t 查看cpio打包的文件内容或者输出到设备上的文件内容。</span></span><br><span class="line"><span class="deletion">-v 显示打包过程中的文件名称。</span></span><br><span class="line"><span class="deletion">-d 在cpio还原文件的过程中，自动的建立相应的目录。</span></span><br><span class="line"><span class="deletion">-c Use the old POSIX portable character format</span></span><br><span class="line"><span class="deletion">-B 让默认的Blocks可以增大到5120 bytes，默认Blocks为512 bytes，这样做的好处是可以加快存取速度。</span></span><br><span class="line"><span class="deletion">-H Produce the output archive in the specified format.</span></span><br></pre></td></tr></table></figure>
<p>下面是 cpio 的常见使用案例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将etc目录备份</span></span><br><span class="line">$ find ./etc -<span class="built_in">print</span> | cpio -ov &gt; etc.cpio</span><br><span class="line"><span class="comment"># 恢复文件</span></span><br><span class="line">$ cpio -idv &lt; /root/etc.cpio</span><br><span class="line"><span class="comment"># 只是查看etc.cpio文件</span></span><br><span class="line">$ cpio -tv &lt; etc.cpio</span><br></pre></td></tr></table></figure>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crontab</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># crontab 文件含义</span></span><br><span class="line"><span class="comment"># minute hour day month week command</span></span><br><span class="line"><span class="comment"># 30 21 * * * /etc/init.d/smb restart # 每晚的21:30重启smb</span></span><br><span class="line"><span class="comment"># * */1 * * * /etc/init.d/smb restart # 每一小时重启smb </span></span><br><span class="line"><span class="comment"># 0,15,30,45 18-06 * * * /bin/echo `date` &gt; dev/tty1 # 每天的18点到6点的每隔15分钟执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 crontab 文件</span></span><br><span class="line">$ crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 crontab 文件</span></span><br><span class="line">$ crontab -l</span><br><span class="line">0,15,30,45 18-06 * * * /bin/<span class="built_in">echo</span> `date` &gt; dev/tty1</span><br></pre></td></tr></table></figure>
<h3 id="bash-profile-和-bashrc"><a href="#bash-profile-和-bashrc" class="headerlink" title="bash_profile 和 bashrc"></a>bash_profile 和 bashrc</h3><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p><code>xargs</code>命令的作用，是将标准输入转为命令行参数。大多数命令（比如<code>rm</code>, <code>mkdir</code>,<code>ls</code>) 与管道一起使用时，都需要 <code>xargs</code> 将标准输入专为命令行参数。关于 <code>xargs</code>与管道的区别，可以参考<a href="https://www.cnblogs.com/wangqiguo/p/6464234.html" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其命令格式如下</span></span><br><span class="line">$ xargs [-options] [<span class="built_in">command</span>]</span><br><span class="line">$ find . -name <span class="string">"*.txt"</span> | xargs grep <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -d 参数可定制分隔符</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\tb\tc"</span> | xargs -d <span class="string">"\t"</span> <span class="built_in">echo</span></span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line"><span class="comment"># -I指定每一项命令行参数的替代字符串</span></span><br><span class="line">$ cat foo.txt</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"></span><br><span class="line">$ cat foo.txt | xargs -I file sh -c <span class="string">'echo file; mkdir file'</span></span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">one two three</span><br><span class="line"></span><br><span class="line"><span class="comment"># xargs默认只用一个进程执行命令，--max-procs 参数指定同时用多少个进程并行执行命令，0 表示不限制</span></span><br><span class="line">$ docker ps -q | xargs -n 1 --max-procs 0 docker <span class="built_in">kill</span></span><br></pre></td></tr></table></figure>
<h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h3><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 /，即以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 / 位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chroot [options] NEWROOT [COMMANDS]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>增加了系统的安全性，限制了用户的权力：</strong></li>
</ul>
<p>在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (<a href="http://man.linuxde.net/login" target="_blank" rel="external nofollow noopener noreferrer">login</a>) 前使用 chroot，以此达到用户不能访问一些特定的文件。</p>
<ul>
<li><strong>建立一个与原系统隔离的系统目录结构，方便用户的开发：</strong></li>
</ul>
<p>使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</p>
<ul>
<li><strong>切换系统的根目录位置，引导 Linux 系统启动以及急救系统等：</strong></li>
</ul>
<p>chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 <a href="http://man.linuxde.net/init" target="_blank" rel="external nofollow noopener noreferrer">init</a>。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。</p>
<h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><h3 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a>set -x</h3><h3 id="source-的区别"><a href="#source-的区别" class="headerlink" title="source 的区别"></a>source 的区别</h3><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p: 同时显示每个进程的 PID</span></span><br><span class="line"><span class="comment"># -u: 同时列出每个进程所属账号名称</span></span><br><span class="line">$ pstree -up</span><br><span class="line"></span><br><span class="line">$ ps -aux</span><br></pre></td></tr></table></figure>
<h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pgrep [进程名] <span class="comment"># 等同于 ps aux | grep [进程名]</span></span><br><span class="line">$ pkill [进程名] <span class="comment"># 等同于 pgrep [进程名] | xargs kill -9</span></span><br></pre></td></tr></table></figure>
<h3 id="查看网络端口"><a href="#查看网络端口" class="headerlink" title="查看网络端口"></a>查看网络端口</h3><p><code>netstat</code> 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字，参考<a href="https://linux.cn/article-2434-1.html" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># netstat 参数</span></span><br><span class="line"><span class="comment"># -t 列出TCP协议的连接，-u 列出UDP协议的连接</span></span><br><span class="line"><span class="comment"># -n 禁用域名解析，只列出IP地址，可提升查找速度</span></span><br><span class="line"><span class="comment"># -l 列出正在监听的套接字</span></span><br><span class="line"><span class="comment"># -p 查看进程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出正在监听中的连接</span></span><br><span class="line">$ sudo netstat -lntp</span><br><span class="line">$ netstat -lntp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 active 状态的连接</span></span><br><span class="line">$ netstat -atnp | grep ESTA</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 192.168.1.2:49156       173.255.230.5:80        ESTABLISHED 1691/chrome     </span><br><span class="line">tcp        0      0 192.168.1.2:33324       173.194.36.117:443      ESTABLISHED 1691/chrome</span><br></pre></td></tr></table></figure>
<h3 id="查看打开文件"><a href="#查看打开文件" class="headerlink" title="查看打开文件"></a>查看打开文件</h3><p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsof -i <span class="comment"># 列出所有的网络的连接</span></span><br><span class="line">$ lsof -i tcp <span class="comment"># 列出所有TCP连接</span></span><br><span class="line">$ lsof -i :3306 <span class="comment"># 列出谁在使用某个端口</span></span><br><span class="line">$ lsof -i udp:80 <span class="comment"># 列出谁在使用某个特定的UDP端口</span></span><br><span class="line">$ lsof -p 234 <span class="comment"># 列出进程234打开的所有文件</span></span><br><span class="line">$ lsof -u houmin <span class="comment">#列出用户houmin打开的所有文件</span></span><br><span class="line">$ lsof -c mysql <span class="comment"># 列出所有以mysql这个进程开头的程序的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="查看磁盘占用"><a href="#查看磁盘占用" class="headerlink" title="查看磁盘占用"></a>查看磁盘占用</h3><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 16:27:05 up 157 days, 18:43,  6 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 121 total,   2 running, 119 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2048028 total,   340732 free,   198124 used,  1509172 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  1631636 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">10109 root      10 -10  132768  17288  14768 S  0.3  0.8   8:55.79 AliYunDun</span><br><span class="line">12503 houmin    20   0   42720  16312   2764 S  0.3  0.8   0:41.47 tmux</span><br><span class="line">    1 root      20   0  119584   5224   3468 S  0.0  0.3   1:02.52 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.02 kthreadd</span><br><span class="line">    3 root      20   0       0      0      0 S  0.0  0.0   0:30.96 ksoftirqd/0</span><br><span class="line">    5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">    7 root      20   0       0      0      0 R  0.0  0.0  14:00.55 rcu_sched</span><br><span class="line">    8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh</span><br><span class="line">    9 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0</span><br><span class="line">   10 root      rt   0       0      0      0 S  0.0  0.0   0:41.19 watchdog/0</span><br><span class="line">   11 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kdevtmpfs</span><br></pre></td></tr></table></figure>
<p>关于 top 的显示的具体意义，可以参考 <a href="http://houmin.cc">To be done</a></p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><h3 id="ptrack"><a href="#ptrack" class="headerlink" title="ptrack"></a>ptrack</h3><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vmstat [-options] [delay] [count]</span></span><br><span class="line"><span class="comment"># 如果不写count，则会一直输出</span></span><br><span class="line">vmstat 5 6</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 0  0      0 2455496 234152 4772420    0    0     2    16    4   85  1  0 99  0  0</span><br><span class="line"> 0  0      0 2454372 234152 4772420    0    0     0    66 1005 1825  0  1 99  0  0</span><br><span class="line"> 0  0      0 2454628 234156 4772424    0    0     0    15  967 1747  0  1 99  0  0</span><br><span class="line"> 0  0      0 2454040 234164 4772428    0    0     0    26 1030 1893  1  0 99  0  0</span><br><span class="line"> 0  0      0 2454224 234168 4772436    0    0     0    10  996 1794  1  0 99  0  0</span><br><span class="line"> 0  0      0 2454404 234168 4772436    0    0     0    10  958 1768  1  0 99  0  0</span><br></pre></td></tr></table></figure>
<p>各个参数意义如下：</p>
<ul>
<li><strong>r</strong> 运行队列中进程的数量</li>
<li><strong>b</strong> 等待IO的进程数量</li>
<li><strong>swpd</strong> 使用虚拟内存大小</li>
<li><strong>free</strong>  空闲的物理内存的大小</li>
<li><strong>buff</strong>  用作缓冲的内存大小，指的是块设备IO时候在内存中的缓冲，一般来说不太重要</li>
<li><strong>cache</strong> 用作缓存的内存大小，指的是文件读写时候的page cache，比较重要</li>
<li><strong>si</strong> 每秒从交换区写到内存的大小</li>
<li><strong>so</strong> 每秒写入交换区的内存大小</li>
<li><strong>bi</strong> 每秒从块设备读取的块数量，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒</li>
<li><strong>bo</strong> 每秒写入到块设备的块数量</li>
<li><strong>in</strong> 每秒CPU的中断次数，包括时间中断</li>
<li><strong>cs</strong> 每秒上下文切换次数</li>
<li><strong>us</strong> 用户CPU时间，包括nice时间</li>
<li><strong>sy</strong> 系统CPU时间</li>
<li><strong>id</strong> 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。</li>
<li><strong>wa</strong> 等待IO CPU时间</li>
<li><strong>st</strong> 虚拟机中运行的时间stolen</li>
</ul>
<h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p><code>iostat</code>是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。iostat属于sysstat软件包。可以用<code>yum install sysstat</code>直接安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iostat [-options] [interval] [count]</span></span><br><span class="line"><span class="comment"># iostat -x 表示输出详细信息</span></span><br><span class="line">$ iostat -x 5</span><br><span class="line">Linux 4.14.105-19-0012 (VM-1-28-centos) 	07/21/2020 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.59    0.00    0.40    0.04    0.00   98.96</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">loop0             0.00     0.00    0.00    0.00     0.00     0.00    19.77     0.00    0.11    0.11    0.00   0.00   0.00</span><br><span class="line">scd0              0.00     0.00    0.01    0.00     0.48     0.00    66.54     0.00    0.33    0.33    0.00   0.26   0.00</span><br><span class="line">vda               0.00     2.27    0.90    2.36     9.37    61.83    43.65     0.03   13.44    1.72   17.92   0.16   0.05</span><br></pre></td></tr></table></figure>
<p>各个参数意义如下</p>
<ul>
<li><code>%user</code>：CPU处在用户模式下的时间百分比</li>
<li><code>%nice</code>：CPU处在带NICE值的用户模式下的时间百分比</li>
<li><code>%system</code>：CPU处在系统模式下的时间百分比</li>
<li>%iowait<code>：CPU等待输入输出完成时间的百分比</code></li>
<li>%steal<code>：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</code></li>
<li>%idle<code>：CPU空闲时间百分比</code></li>
</ul>
<p>当然了，<code>iostat</code>命令的重点不是用来看CPU的，重点是用来监测磁盘性能的。</p>
<ul>
<li><code>Device</code>：设备名称</li>
<li><code>rrqm/s</code>：每秒合并到设备的读取请求数</li>
<li><code>wrqm/s</code>：每秒合并到设备的写请求数</li>
<li><code>r/s</code>：每秒向磁盘发起的读操作数</li>
<li><code>w/s</code>：每秒向磁盘发起的写操作数</li>
<li><code>rkB/s</code>：每秒读K字节数</li>
<li><code>wkB/s</code>:每秒写K字节数</li>
<li><code>avgrq-sz</code>：平均每次设备I/O操作的数据大小</li>
<li><code>avgqu-sz</code>：平均I/O队列长度</li>
<li><code>await</code>：平均每次设备I/O操作的等待时间 (毫秒)，一般地，系统I/O响应时间应该低于5ms，如果大于 10ms就比较大了</li>
<li><code>r_await</code>：每个读操作平均所需的时间；不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间</li>
<li><code>w_await</code>：每个写操作平均所需的时间；不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间</li>
<li><code>svctm</code>：平均每次设备I/O操作的服务时间 (毫秒)（这个数据不可信！）</li>
<li><code>%util</code>：一秒中有百分之多少的时间用于I/O操作，即被IO消耗的CPU百分比，一般地，如果该参数是100%表示设备已经接近满负荷运行了</li>
</ul>
<p>关于数据总结：</p>
<ul>
<li>如果 <code>%util</code> 接近100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈</li>
</ul>
<h3 id="找出系统瓶颈-sar"><a href="#找出系统瓶颈-sar" class="headerlink" title="找出系统瓶颈 sar"></a>找出系统瓶颈 sar</h3><h3 id="查看程序依赖库-ldd"><a href="#查看程序依赖库-ldd" class="headerlink" title="查看程序依赖库 ldd"></a>查看程序依赖库 ldd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ldd: list dynamic dependencies, 用于查看动态库的依赖关系</span></span><br><span class="line"><span class="comment"># ldd 常用来解决程式因缺少某个库文件而不能运行的一些问题。</span></span><br><span class="line">$ ldd /bin/ls</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe25deb000)</span><br><span class="line">	libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f8e79815000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8e7944b000)</span><br><span class="line">	libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f8e791db000)</span><br><span class="line">	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f8e78fd7000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f8e79a37000)</span><br><span class="line">	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f8e78dba000)</span><br><span class="line"><span class="comment"># 第一列：程序需要依赖什么库</span></span><br><span class="line"><span class="comment"># 第二列: 系统提供的与程序需要的库所对应的库</span></span><br><span class="line"><span class="comment"># 第三列：库加载的开始地址</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>原理： ldd不是个可执行程式，而只是个shell脚本； ldd显示可执行模块的dependency的工作原理，其实质是通过 <code>ld-linux.so</code>（elf动态库的装载器）来实现的。ld-linux.so模块会先于executable模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。</p><p>关于 <code>ld-linux.so</code>，可以参见我的<a href="../">另一篇文章</a></p>
          </div>
<h3 id="文件格式分析"><a href="#文件格式分析" class="headerlink" title="文件格式分析"></a>文件格式分析</h3><h4 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h4><p>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）</p>
<p>关于 <code>ELF</code>可以参考 <a href="../">这篇文章</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -all a.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">'s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Intel 80386</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x8048330</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          4412 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         30</span></span><br><span class="line"><span class="string">  Section header string table index: 27</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Section Headers:</span></span><br><span class="line"><span class="string">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span><br><span class="line"><span class="string">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span></span><br><span class="line"><span class="string">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span></span><br><span class="line"><span class="string">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span></span><br><span class="line"><span class="string">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span></span><br><span class="line"><span class="string">  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4</span></span><br><span class="line"><span class="string">  [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4</span></span><br><span class="line"><span class="string">  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16</span></span><br><span class="line"><span class="string">  [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16</span></span><br><span class="line"><span class="string">  [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4</span></span><br><span class="line"><span class="string">  [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4</span></span><br><span class="line"><span class="string">  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4</span></span><br><span class="line"><span class="string">  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4</span></span><br><span class="line"><span class="string">  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1</span></span><br><span class="line"><span class="string">  [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1</span></span><br><span class="line"><span class="string">  [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4</span></span><br><span class="line"><span class="string">  [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1</span></span><br><span class="line"><span class="string">Key to Flags:</span></span><br><span class="line"><span class="string">  W (write), A (alloc), X (execute), M (merge), S (strings)</span></span><br><span class="line"><span class="string">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span></span><br><span class="line"><span class="string">  O (extra OS processing required) o (OS specific), p (processor specific)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are no section groups in this file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Program Headers:</span></span><br><span class="line"><span class="string">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span></span><br><span class="line"><span class="string">  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4</span></span><br><span class="line"><span class="string">  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1</span></span><br><span class="line"><span class="string">      [Requesting program interpreter: /lib/ld-linux.so.2]</span></span><br><span class="line"><span class="string">  LOAD           0x000000 0x08048000 0x08048000 0x005e4 0x005e4 R E 0x1000</span></span><br><span class="line"><span class="string">  LOAD           0x000f14 0x08049f14 0x08049f14 0x00100 0x00108 RW  0x1000</span></span><br><span class="line"><span class="string">  DYNAMIC        0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW  0x4</span></span><br><span class="line"><span class="string">  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4</span></span><br><span class="line"><span class="string">  GNU_EH_FRAME   0x0004ec 0x080484ec 0x080484ec 0x00034 0x00034 R   0x4</span></span><br><span class="line"><span class="string">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4</span></span><br><span class="line"><span class="string">  GNU_RELRO      0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R   0x1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Section to Segment mapping:</span></span><br><span class="line"><span class="string">  Segment Sections...</span></span><br><span class="line"><span class="string">   00</span></span><br><span class="line"><span class="string">   01     .interp</span></span><br><span class="line"><span class="string">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame</span></span><br><span class="line"><span class="string">   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss</span></span><br><span class="line"><span class="string">   04     .dynamic</span></span><br><span class="line"><span class="string">   05     .note.ABI-tag .note.gnu.build-id</span></span><br><span class="line"><span class="string">   06     .eh_frame_hdr</span></span><br><span class="line"><span class="string">   07</span></span><br><span class="line"><span class="string">   08     .ctors .dtors .jcr .dynamic .got</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dynamic section at offset 0xf28 contains 20 entries:</span></span><br><span class="line"><span class="string">  Tag        Type                         Name/Value</span></span><br><span class="line"><span class="string"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span></span><br><span class="line"><span class="string"> 0x0000000c (INIT)                       0x80482b4</span></span><br><span class="line"><span class="string"> 0x0000000d (FINI)                       0x80484bc</span></span><br><span class="line"><span class="string"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span></span><br><span class="line"><span class="string"> 0x00000005 (STRTAB)                     0x804821c</span></span><br><span class="line"><span class="string"> 0x00000006 (SYMTAB)                     0x80481cc</span></span><br><span class="line"><span class="string"> 0x0000000a (STRSZ)                      76 (bytes)</span></span><br><span class="line"><span class="string"> 0x0000000b (SYMENT)                     16 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000015 (DEBUG)                      0x0</span></span><br><span class="line"><span class="string"> 0x00000003 (PLTGOT)                     0x8049ff4</span></span><br><span class="line"><span class="string"> 0x00000002 (PLTRELSZ)                   24 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000014 (PLTREL)                     REL</span></span><br><span class="line"><span class="string"> 0x00000017 (JMPREL)                     0x804829c</span></span><br><span class="line"><span class="string"> 0x00000011 (REL)                        0x8048294</span></span><br><span class="line"><span class="string"> 0x00000012 (RELSZ)                      8 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000013 (RELENT)                     8 (bytes)</span></span><br><span class="line"><span class="string"> 0x6ffffffe (VERNEED)                    0x8048274</span></span><br><span class="line"><span class="string"> 0x6fffffff (VERNEEDNUM)                 1</span></span><br><span class="line"><span class="string"> 0x6ffffff0 (VERSYM)                     0x8048268</span></span><br><span class="line"><span class="string"> 0x00000000 (NULL)                       0x0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section '</span>.rel.dyn<span class="string">' at offset 0x294 contains 1 entries:</span></span><br><span class="line"><span class="string"> Offset     Info    Type            Sym.Value  Sym. Name</span></span><br><span class="line"><span class="string">08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section '</span>.rel.plt<span class="string">' at offset 0x29c contains 3 entries:</span></span><br><span class="line"><span class="string"> Offset     Info    Type            Sym.Value  Sym. Name</span></span><br><span class="line"><span class="string">0804a000  00000107 R_386_JUMP_SLOT   00000000   printf</span></span><br><span class="line"><span class="string">0804a004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span></span><br><span class="line"><span class="string">0804a008  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are no unwind sections in this file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table '</span>.dynsym<span class="string">' contains 5 entries:</span></span><br><span class="line"><span class="string">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)</span></span><br><span class="line"><span class="string">     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span></span><br><span class="line"><span class="string">     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span></span><br><span class="line"><span class="string">     4: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table '</span>.symtab<span class="string">' contains 65 entries:</span></span><br><span class="line"><span class="string">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 08048154     0 SECTION LOCAL  DEFAULT    1</span></span><br><span class="line"><span class="string">     2: 08048168     0 SECTION LOCAL  DEFAULT    2</span></span><br><span class="line"><span class="string">     3: 08048188     0 SECTION LOCAL  DEFAULT    3</span></span><br><span class="line"><span class="string">     4: 080481ac     0 SECTION LOCAL  DEFAULT    4</span></span><br><span class="line"><span class="string">     5: 080481cc     0 SECTION LOCAL  DEFAULT    5</span></span><br><span class="line"><span class="string">     6: 0804821c     0 SECTION LOCAL  DEFAULT    6</span></span><br><span class="line"><span class="string">     7: 08048268     0 SECTION LOCAL  DEFAULT    7</span></span><br><span class="line"><span class="string">     8: 08048274     0 SECTION LOCAL  DEFAULT    8</span></span><br><span class="line"><span class="string">     9: 08048294     0 SECTION LOCAL  DEFAULT    9</span></span><br><span class="line"><span class="string">    10: 0804829c     0 SECTION LOCAL  DEFAULT   10</span></span><br><span class="line"><span class="string">    11: 080482b4     0 SECTION LOCAL  DEFAULT   11</span></span><br><span class="line"><span class="string">    12: 080482f0     0 SECTION LOCAL  DEFAULT   12</span></span><br><span class="line"><span class="string">    13: 08048330     0 SECTION LOCAL  DEFAULT   13</span></span><br><span class="line"><span class="string">    14: 080484bc     0 SECTION LOCAL  DEFAULT   14</span></span><br><span class="line"><span class="string">    15: 080484d8     0 SECTION LOCAL  DEFAULT   15</span></span><br><span class="line"><span class="string">    16: 080484ec     0 SECTION LOCAL  DEFAULT   16</span></span><br><span class="line"><span class="string">    17: 08048520     0 SECTION LOCAL  DEFAULT   17</span></span><br><span class="line"><span class="string">    18: 08049f14     0 SECTION LOCAL  DEFAULT   18</span></span><br><span class="line"><span class="string">    19: 08049f1c     0 SECTION LOCAL  DEFAULT   19</span></span><br><span class="line"><span class="string">    20: 08049f24     0 SECTION LOCAL  DEFAULT   20</span></span><br><span class="line"><span class="string">    21: 08049f28     0 SECTION LOCAL  DEFAULT   21</span></span><br><span class="line"><span class="string">    22: 08049ff0     0 SECTION LOCAL  DEFAULT   22</span></span><br><span class="line"><span class="string">    23: 08049ff4     0 SECTION LOCAL  DEFAULT   23</span></span><br><span class="line"><span class="string">    24: 0804a00c     0 SECTION LOCAL  DEFAULT   24</span></span><br><span class="line"><span class="string">    25: 0804a014     0 SECTION LOCAL  DEFAULT   25</span></span><br><span class="line"><span class="string">    26: 00000000     0 SECTION LOCAL  DEFAULT   26</span></span><br><span class="line"><span class="string">    27: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span></span><br><span class="line"><span class="string">    28: 08049f14     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_LIST__</span></span><br><span class="line"><span class="string">    29: 08049f1c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_LIST__</span></span><br><span class="line"><span class="string">    30: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_LIST__</span></span><br><span class="line"><span class="string">    31: 08048360     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux</span></span><br><span class="line"><span class="string">    32: 0804a014     1 OBJECT  LOCAL  DEFAULT   25 completed.6086</span></span><br><span class="line"><span class="string">    33: 0804a018     4 OBJECT  LOCAL  DEFAULT   25 dtor_idx.6088</span></span><br><span class="line"><span class="string">    34: 080483c0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy</span></span><br><span class="line"><span class="string">    35: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span></span><br><span class="line"><span class="string">    36: 08049f18     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_END__</span></span><br><span class="line"><span class="string">    37: 080485e0     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__</span></span><br><span class="line"><span class="string">    38: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_END__</span></span><br><span class="line"><span class="string">    39: 08048490     0 FUNC    LOCAL  DEFAULT   13 __do_global_ctors_aux</span></span><br><span class="line"><span class="string">    40: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span></span><br><span class="line"><span class="string">    41: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end</span></span><br><span class="line"><span class="string">    42: 08049f28     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC</span></span><br><span class="line"><span class="string">    43: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start</span></span><br><span class="line"><span class="string">    44: 08049ff4     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_</span></span><br><span class="line"><span class="string">    45: 08048480     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini</span></span><br><span class="line"><span class="string">    46: 08048482     0 FUNC    GLOBAL HIDDEN    13 __i686.get_pc_thunk.bx</span></span><br><span class="line"><span class="string">    47: 0804a00c     0 NOTYPE  WEAK   DEFAULT   24 data_start</span></span><br><span class="line"><span class="string">    48: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0</span></span><br><span class="line"><span class="string">    49: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS _edata</span></span><br><span class="line"><span class="string">    50: 080484bc     0 FUNC    GLOBAL DEFAULT   14 _fini</span></span><br><span class="line"><span class="string">    51: 08049f20     0 OBJECT  GLOBAL HIDDEN    19 __DTOR_END__</span></span><br><span class="line"><span class="string">    52: 0804a00c     0 NOTYPE  GLOBAL DEFAULT   24 __data_start</span></span><br><span class="line"><span class="string">    53: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span></span><br><span class="line"><span class="string">    54: 0804a010     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle</span></span><br><span class="line"><span class="string">    55: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span></span><br><span class="line"><span class="string">    56: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_</span></span><br><span class="line"><span class="string">    57: 08048410    97 FUNC    GLOBAL DEFAULT   13 __libc_csu_init</span></span><br><span class="line"><span class="string">    58: 0804a01c     0 NOTYPE  GLOBAL DEFAULT  ABS _end</span></span><br><span class="line"><span class="string">    59: 08048330     0 FUNC    GLOBAL DEFAULT   13 _start</span></span><br><span class="line"><span class="string">    60: 080484d8     4 OBJECT  GLOBAL DEFAULT   15 _fp_hw</span></span><br><span class="line"><span class="string">    61: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start</span></span><br><span class="line"><span class="string">    62: 080483e4    40 FUNC    GLOBAL DEFAULT   13 main</span></span><br><span class="line"><span class="string">    63: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses</span></span><br><span class="line"><span class="string">    64: 080482b4     0 FUNC    GLOBAL DEFAULT   11 _init</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Histogram for `.gnu.hash'</span> bucket list length (total of 2 buckets):</span><br><span class="line"> Length  Number     % of total  Coverage</span><br><span class="line">      0  1          ( 50.0%)</span><br><span class="line">      1  1          ( 50.0%)    100.0%</span><br><span class="line"></span><br><span class="line">Version symbols section <span class="string">'.gnu.version'</span> contains 5 entries:</span><br><span class="line"> Addr: 0000000008048268  Offset: 0x000268  Link: 5 (.dynsym)</span><br><span class="line">  000:   0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.0)     0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.0)</span><br><span class="line">  004:   1 (*global*)</span><br><span class="line"></span><br><span class="line">Version needs section <span class="string">'.gnu.version_r'</span> contains 1 entries:</span><br><span class="line"> Addr: 0x0000000008048274  Offset: 0x000274  Link: 6 (.dynstr)</span><br><span class="line">  000000: Version: 1  File: libc.so.6  Cnt: 1</span><br><span class="line">  0x0010:   Name: GLIBC_2.0  Flags: none  Version: 2</span><br><span class="line"></span><br><span class="line">Notes at offset 0x00000168 with length 0x00000020:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)</span><br><span class="line">    OS: Linux, ABI: 2.6.15</span><br><span class="line"></span><br><span class="line">Notes at offset 0x00000188 with length 0x00000024:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)</span><br><span class="line">    Build ID: 17fb9651029b6a8543bfafec9eea23bd16454e65</span><br></pre></td></tr></table></figure>
<h4 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h4><p>objdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">$ objdump -d main.o</span><br></pre></td></tr></table></figure>
<h4 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h4><p>nm指令是names的简称，通过该指令可以列举文件中的符号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat &gt; hello.c &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ gcc hello.c -o hello</span><br><span class="line">$ name hello</span><br><span class="line">0000000000601038 B __bss_start</span><br><span class="line">0000000000601038 b completed.7594</span><br><span class="line">0000000000601028 D __data_start</span><br><span class="line">0000000000601028 W data_start</span><br><span class="line">0000000000400460 t deregister_tm_clones</span><br><span class="line">00000000004004e0 t __do_global_dtors_aux</span><br><span class="line">0000000000600e18 t __do_global_dtors_aux_fini_array_entry</span><br><span class="line">0000000000601030 D __dso_handle</span><br><span class="line">0000000000600e28 d _DYNAMIC</span><br><span class="line">0000000000601038 D _edata</span><br><span class="line">0000000000601040 B _end</span><br><span class="line">00000000004005b4 T _fini</span><br><span class="line">0000000000400500 t frame_dummy</span><br><span class="line">0000000000600e10 t __frame_dummy_init_array_entry</span><br><span class="line">00000000004006f8 r __FRAME_END__</span><br><span class="line">0000000000601000 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">00000000004005d0 r __GNU_EH_FRAME_HDR</span><br><span class="line">00000000004003c8 T _init</span><br><span class="line">0000000000600e18 t __init_array_end</span><br><span class="line">0000000000600e10 t __init_array_start</span><br><span class="line">00000000004005c0 R _IO_stdin_used</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">0000000000600e20 d __JCR_END__</span><br><span class="line">0000000000600e20 d __JCR_LIST__</span><br><span class="line">                 w _Jv_RegisterClasses</span><br><span class="line">00000000004005b0 T __libc_csu_fini</span><br><span class="line">0000000000400540 T __libc_csu_init</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">0000000000400526 T main</span><br><span class="line">                 U puts@@GLIBC_2.2.5</span><br><span class="line">00000000004004a0 t register_tm_clones</span><br><span class="line">0000000000400430 T _start</span><br><span class="line">0000000000601038 D __TMC_END__</span><br></pre></td></tr></table></figure>
<h2 id="内核参数设置"><a href="#内核参数设置" class="headerlink" title="内核参数设置"></a>内核参数设置</h2><p>Sysctl 是一个在运行时检查和改变内核参数的工具，它是在 <a href="https://en.wikipedia.org/wiki/procfs" target="_blank" rel="external nofollow noopener noreferrer">procfs</a> 中实现的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sysctl -a														# 显示所有的系统参数</span></span><br><span class="line"><span class="comment"># sysctl -w kernel.domainname="example.com"		# 临时改变某个指定参数的值</span></span><br><span class="line"><span class="comment"># sysctl -p /etc/sysctl.conf		# 载入sysctl配置文件</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md</a></li>
<li><a href="https://www.zhihu.com/question/25910725" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/25910725</a></li>
<li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html" target="_blank" rel="external nofollow noopener noreferrer">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 深度定制</title>
    <url>/posts/a63a603e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hexo是一个基于NodeJS简洁高效的博客框架, 本文详细介绍了自己基于Hexo和NexT主题搭建自己个人网站，并且部署到AWS和阿里云ECS服务上的过程。并且深度定制了自己的个人网站，仅作为自己的一个备忘和对他人的一份有些许价值的参考。</p>
<a id="more"></a>
<h2 id="阿里云服务器端"><a href="#阿里云服务器端" class="headerlink" title="阿里云服务器端"></a>阿里云服务器端</h2><h3 id="购买ECS服务"><a href="#购买ECS服务" class="headerlink" title="购买ECS服务"></a>购买ECS服务</h3><p>之前是利用GitHub Pages + Hexo 部署的博客，因为强迫症想要更加全面的掌控自己的博客，决定在自己的服务器上部署Hexo博客。</p>
<p>现在各大厂商都有自己的ECS服务，同时针对学生也有固定的学生优惠。我选择的是阿里云云翼计划的云服务器ECS服务。</p>
<p>配置如下</p>
<ul>
<li>1核CPU Intel Xeon E5-2682 v4</li>
<li>2G DDR4 内存</li>
<li>1M带宽 VPC专有网络, I/O 优化</li>
<li>40G系统盘</li>
</ul>
<p>这一套下来官网价格得要1452RMB，用学生优惠下来只需要114RMB，显然实惠很多。</p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>既然都已经有了自己的服务器了，自然就想，为何不整一套自己的域名呢？</p>
<p>域名可以在国外知名域名注册厂家Godaddy和NameCheap等购买，也可以使用国内的阿里云万网和腾讯云的域名注册服务购买。但是看着国外域名随随便便一年十几刀的费用，我还是老老实实用万网的服务买的域名。</p>
<p><code>houmin.cc</code>用160RMB买了10年的域名服务，从2017年到2027年。</p>
<p>因为某些不可知的因素，cc域名从2018年起不能在国内备案了，导致我现在这个域名也一直不能备案，不过还是可以解析的。购买域名服务后，修改域名解析服务，将域名指向我们自己的阿里云服务器。</p>
<h3 id="服务器环境搭建"><a href="#服务器环境搭建" class="headerlink" title="服务器环境搭建"></a>服务器环境搭建</h3><h4 id="配置安全组规则"><a href="#配置安全组规则" class="headerlink" title="配置安全组规则"></a>配置安全组规则</h4><p>由于阿里云是默认不授权80端口的访问的，所以我们要手动配置。</p>
<p>打开阿里云服务器管理控制台-&gt;点击左侧安全组-&gt;点击右侧的配置规则-&gt;点击添加安全组规则</p>
<h4 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h4><p>服务器采用的是Ubuntu 16.04，作为一个网站，必定要有一个web server，这里采用的是Nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<p>这个时候打开浏览器，输入服务器的公网IP地址，就可以看到Nginx的默认网页了。</p>
<p>关于Nginx当前采用的是默认配置，我们的目标是让这个网站的默认地址指向我们的博客，是不是默认的这个欢迎界面。这就需要我们去修改Nginx的默认配置。Nginx的配置文件在Ubuntu下放在了<code>/etc/nginx</code>的目录下，我们可以看到该目录下有<code>sites-available</code>和<code>sites-enabled</code>，其中<code>sites-enabled</code>里面的default就是<code>sites-available</code>下面default的一个软链接。打开default我们可以看到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Default server configuration</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">server &#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">	listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> SSL configuration</span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> listen 443 ssl default_server;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> listen [::]:443 ssl default_server;</span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> Note: You should <span class="built_in">disable</span> gzip <span class="keyword">for</span> SSL traffic.</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> See: https://bugs.debian.org/773332</span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> Read up on ssl_ciphers to ensure a secure configuration.</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> See: https://bugs.debian.org/765782</span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> Self signed certs generated by the ssl-cert package</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> Don<span class="string">'t use them in a production server!</span></span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> include snippets/snakeoil.conf;</span></span><br><span class="line"></span><br><span class="line">	root /var/www/html;</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> Add index.php to the list <span class="keyword">if</span> you are using PHP</span></span><br><span class="line">	index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">	server_name _;</span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash"> First attempt to serve request as file, <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">		#</span><span class="bash"> as directory, <span class="keyword">then</span> fall back to displaying a 404.</span></span><br><span class="line">		try_files $uri $uri/ =404;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">location ~ \.php$ &#123;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">	include snippets/fastcgi-php.conf;</span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">	<span class="comment"># With php7.0-cgi alone:</span></span></span><br><span class="line"><span class="meta">	#</span><span class="bash">	fastcgi_pass 127.0.0.1:9000;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">	<span class="comment"># With php7.0-fpm:</span></span></span><br><span class="line"><span class="meta">	#</span><span class="bash">	fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"> deny access to .htaccess files, <span class="keyword">if</span> Apache<span class="string">'s document root</span></span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> concurs with nginx<span class="string">'s one</span></span></span><br><span class="line"><span class="meta">	#</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">location ~ /\.ht &#123;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">	deny all;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前Nginx监听在80端口，默认没有打开HTTPS，同时网站的源代码放在了<code>/var/www/html</code>目录下。进入这个目录，我们也确实可以看到一个<code>index.nginx-debian.html</code>文件。这就是我们看到的默认Nginx的欢迎页面。</p>
<p>为了创建我们自己的网站，我们需要类似的有同样的配置</p>
<ul>
<li>创建存放网站源文件的目录，这里我们创建的是<code>/var/www/houmin.cc</code></li>
<li>创建我们自己网站的配置文件，在<code>/etc/nginx/sites-available</code>中，这里我们叫<code>houmin.cc</code></li>
<li>在<code>/etc/nginx/sites-enabled</code>中删去default，并且创建一个对<code>houmin.cc</code>配置文件的软链接。</li>
<li>删除<code>/etc/nginx/sites-enabled</code>中的default</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /var/www/houmin.cc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /etc/nginx/sites-enabled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /etc/nginx/sites-available/houmin.cc houmin.cc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /etc/nginx/sites-enabled/default</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart nginx.service</span></span><br></pre></td></tr></table></figure>
<p>其中新的配置文件中只是修改了网站root的目录，其他地方没有做修改。这时候在<code>/var/www/houmin.cc</code>目录下放置一个新的html文件，输入公网IP应该可以新的网页了。</p>
<h4 id="配置Git服务"><a href="#配置Git服务" class="headerlink" title="配置Git服务"></a>配置Git服务</h4><p>网站的源文件通过git进行版本管理，每一次更新源文件之后，可以通过git的hook操作自动更新到Nginx的目录下。因此，我们需要在服务器上面搭建一个自己的git服务器，具体的操作如下：</p>
<ul>
<li>创建git用户，并且授予其sudo权限<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo adduser git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG sudo git</span></span><br></pre></td></tr></table></figure>
这时候在服务器上以git用户登陆，可以在<code>/home/git</code>目录下创建repositories目录，专门用作git服务器放置repo的地方。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@cosmos:~/repositories$ git init --bare blog.git</span><br><span class="line">Initialized empty Git repository in /home/git/repositories/blog.git/</span><br></pre></td></tr></table></figure>
<p>这时候在客户端应该是可以clone这个repo的<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@houmin.cc:/home/git/repositories/blog.git</span></span><br><span class="line">Cloning into 'blog'...</span><br><span class="line">git@houmin.cc's password:</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line"><span class="meta">$</span><span class="bash"> touch hello.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello, Git"</span> &gt;&gt; hello.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add hello.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Add hello.md"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin</span></span><br><span class="line">git@houmin.cc's password:</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3/3), 219 bytes | 219.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To houmin.cc:/home/git/repositories/blog.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch 'master' set up to track remote branch 'master' from 'origin'.</span><br></pre></td></tr></table></figure><br>为了避免输入密码，可以在本地机器执行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-copy-id git@houmin.cc</span></span><br></pre></td></tr></table></figure></p>
<p>为了实现自动部署，我们需要利用git的hook功能。</p>
<p>我们进入到blog.git目录，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@cosmos:~/repositories/blog.git/hooks$ cat post-receive</span><br><span class="line">git --work-tree=/var/www/houmin.cc --git-dir=/home/git/repositories/blog.git checkout -f</span><br><span class="line">git@cosmos:~/repositories/blog.git/hooks$ chmod +x post-receive</span><br><span class="line">git@cosmos:~$ sudo chown -R git:git /var/www/houmin.cc</span><br></pre></td></tr></table></figure><br>这里通过创建<code>post-receive</code>这个hook，在每次<code>git push</code>将项目最新的文件复制到work tree下</p>
<p>通过这种方式，是可以看到<code>/var/www/houmin.cc</code>目录下的文件实时的发生更新。为了能够使用git用户更新houmin.cc目录下的文件，需要将该目录的所有者更改为git。</p>
<p>这时候通过ip访问，是可以看到Nginx的默认网页的。</p>
<h4 id="阿里云劫持未备案的请求"><a href="#阿里云劫持未备案的请求" class="headerlink" title="阿里云劫持未备案的请求"></a>阿里云劫持未备案的请求</h4><p>这个时候，如果通过域名访问的话，会告诉你houmin.cc没有备案。也就是说，通过访问 <code>http://houmin.cc</code>阿里云会自动识别这个域名所属的服务器没有备案过，会自动劫持请求。</p>
<p>啊是的，你现在也不让我备案了啊(工信部在2018年停掉了<code>cc</code>域名的备案)，怎么办呢？查阅资料发现，<a href="https://juejin.im/post/5c62bf5f51882562c5505fa4" target="_blank" rel="external nofollow noopener noreferrer">有人说</a>可以通过开启HTTPS解决这个问题，再仔细一看这个是在2019年上半年的解决方案，阿里云在2019年年中的时候就将没有备案的云服务器通过https的请求也给劫持了。</p>
<p>然后在整https的时候也试了好几种方案，</p>
<ul>
<li>let’s encrypt</li>
<li>acme.sh自动</li>
<li>cloudflare免费十年证书</li>
</ul>
<p>采用这三种方案的时候，都因为访问阿里云服务器被劫持了导致没能成功。为了解决这个问题，可以有两个方案</p>
<ul>
<li>重新申请可以备案的域名，老老实实备案，这个需要20天的时间</li>
<li>使用国外的云服务，比如AWS，可以先<a href="https://www.luofan.net/post/105.html" target="_blank" rel="external nofollow noopener noreferrer">免费白嫖一年</a> </li>
</ul>
<p>这两个方案我同时都在进行，一边买了<code>houmin.site</code>十年的域名，一边又申请了AWS的免费一年的EC2服务。</p>
<p>现在的状态：</p>
<ul>
<li>备案时间较长，仍在进行中</li>
<li>EC2服务申请成功后，将<code>houmin.cc</code>解析到EC2上，这时候是可以成功通过域名访问网站的。</li>
</ul>
<p>关于HTTPS的部分，可以参考 <a href="#开启HTTPS">开启HTTPS</a></p>
<h2 id="客户端环境搭建"><a href="#客户端环境搭建" class="headerlink" title="客户端环境搭建"></a>客户端环境搭建</h2><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 18.04 LTS</span><br><span class="line">NodeJS: 8.10.0</span><br><span class="line">Hexo: 4.0.0</span><br><span class="line">NexT: 7.5.0</span><br></pre></td></tr></table></figure>
<h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><ul>
<li>从官网下载系统对应的源码</li>
<li>依次执行以下命令解压编译安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -xzvf node-v8.10.0-linux-x64.tar.xz</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹的目录如下</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>接下来安装 Hexo 关于启动服务器的插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>
<p>这个时候可以启动服务器, 本地查看打开 <a href="http://localhost:4000" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:4000</a> 查看效果效果, 如果不指定端口，默认为4000<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<h3 id="主题和配置"><a href="#主题和配置" class="headerlink" title="主题和配置"></a>主题和配置</h3><p>这里选择的主题为NexT，下面介绍配置主题的主要步骤</p>
<ul>
<li>前往 <a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="external nofollow noopener noreferrer">NexT主题发布界面</a>下载主题压缩包</li>
<li>解压并将目录更名为next</li>
<li>将 next 移动至 blog/themes/ 目录下</li>
<li>将 blog 目录下的 _config.yml 文件中的 theme 属性值改为 next</li>
<li>此时主题更换成功，可启动 server 验证效果</li>
</ul>
<h3 id="将博客部署到阿里云"><a href="#将博客部署到阿里云" class="headerlink" title="将博客部署到阿里云"></a>将博客部署到阿里云</h3><ul>
<li>在阿里云的git服务器上新建blog的仓库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@cosmos:~/repositories$ git init --bare blog.git</span><br><span class="line"><span class="comment"># add post-receive hook</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装 hexo 关于 git 的组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>_config.yml</code> 中为 git 添加配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@houmin.cc:/home/git/repositories/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>执行(每次修改都要执行这些命令才能在github pages看到效果)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate <span class="comment"># generate static files</span></span><br><span class="line">$ hexo deploy <span class="comment">#Deploy to remote sites</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Next主题基本功能配置"><a href="#Next主题基本功能配置" class="headerlink" title="Next主题基本功能配置"></a>Next主题基本功能配置</h2><h3 id="Hexo依赖安装"><a href="#Hexo依赖安装" class="headerlink" title="Hexo依赖安装"></a>Hexo依赖安装</h3><p>下面是当前配置下需要安装的dependency</p>
<figure class="highlight shell"><figcaption><span>hexo安装依赖package.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name": "hexo-site",</span><br><span class="line">  "version": "0.0.0",</span><br><span class="line">  "private": true,</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "hexo generate",</span><br><span class="line">    "clean": "hexo clean",</span><br><span class="line">    "deploy": "hexo deploy",</span><br><span class="line">    "server": "hexo server"</span><br><span class="line">  &#125;,</span><br><span class="line">  "hexo": &#123;</span><br><span class="line">    "version": "4.0.0"</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123;</span><br><span class="line">    "canvas-nest.js": "^2.0.4",</span><br><span class="line">    "hexo": "^4.0.0",</span><br><span class="line">    "hexo-abbrlink": "^2.0.5",</span><br><span class="line">    "hexo-admin": "^2.3.0",</span><br><span class="line">    "hexo-deployer-git": "^2.0.0",</span><br><span class="line">    "hexo-douban": "^1.1.3",</span><br><span class="line">    "hexo-generator-archive": "^1.0.0",</span><br><span class="line">    "hexo-generator-category": "^1.0.0",</span><br><span class="line">    "hexo-generator-feed": "^2.0.0",</span><br><span class="line">    "hexo-generator-index": "^1.0.0",</span><br><span class="line">    "hexo-generator-searchdb": "^1.1.0",</span><br><span class="line">    "hexo-generator-sitemap": "^1.2.0",</span><br><span class="line">    "hexo-generator-tag": "^1.0.0",</span><br><span class="line">    "hexo-related-popular-posts": "^3.0.6",</span><br><span class="line">    "hexo-renderer-ejs": "^1.0.0",</span><br><span class="line">    "hexo-renderer-marked": "^2.0.0",</span><br><span class="line">    "hexo-renderer-stylus": "^1.1.0",</span><br><span class="line">    "hexo-server": "^1.0.0",</span><br><span class="line">    "hexo-symbols-count-time": "^0.6.3",</span><br><span class="line">    "hexo-tag-aplayer": "^3.0.4",</span><br><span class="line">    "hexo-tag-dplayer": "^0.3.3"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在博客目录下执行下面命令即可安装上所有的依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install --production</span></span><br></pre></td></tr></table></figure>
<h3 id="定制favicon"><a href="#定制favicon" class="headerlink" title="定制favicon"></a>定制favicon</h3><figure class="highlight yaml"><figcaption><span>文件位置: blog/themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  <span class="comment"># 网站小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span>   <span class="comment"># 中等图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span>  <span class="comment"># app_touch上显示图标   </span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span>   <span class="comment"># 在Safari浏览器中显示图标</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json  # 安卓默认显示同普通情况下</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<p>网站 favicon 图标可以放到你的 next 主题目录下面的<code>source/images</code>中，然后按照上述相对路径方式引用，这里 favicon 图标不需要非得是 ico 格式的，也可以是 png 或其它图片格式。</p>
<p>如果是有第三方图床放图片链接的，也可以直接改成图片链接。</p>
<h3 id="社交信息"><a href="#社交信息" class="headerlink" title="社交信息"></a>社交信息</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/SimpCosm</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:weihoumin@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="attr">Douban:</span> <span class="string">http://douban.com/people/SimpCosm</span> <span class="string">||</span> <span class="string">douban</span></span><br></pre></td></tr></table></figure>
<p>这里有一个问题就是豆瓣没有对应的<code>font awesome</code>图标</p>
<h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><h3 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h3><p>如果不开启阅读更多按钮的话，默认是展示文章中所有内容的，这显然体验不好。</p>
<p>一般都会在文章中插入<code>&lt;!--more--&gt;</code>这种注释形式表示首页展示到注释处为止。或者会使用如下官方配置文件中自带的方式。一般都推荐使用注释的方式，因为下面这种<code>auto_excerpt</code>方式不会保留前面的行文样式，但是注释方式会保留样式。</p>
<p>搜索 auto_excerpt，找到如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span> <span class="comment">#到多少字数后不显示</span></span><br></pre></td></tr></table></figure>
<h3 id="侧边栏头像设置"><a href="#侧边栏头像设置" class="headerlink" title="侧边栏头像设置"></a>侧边栏头像设置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 如果放在本地(source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># 如果第三方图床，直接写地址</span></span><br><span class="line">  <span class="attr">url:</span>  <span class="comment"># 此处是头像的地址</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span>   <span class="comment"># 设置头像是否为圆形</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span>    <span class="comment"># 设置不透明度，1为完全不透明，0为完全透明</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span>   <span class="comment"># 设置鼠标放到头像上是否旋转</span></span><br></pre></td></tr></table></figure>
<h3 id="代码设置"><a href="#代码设置" class="headerlink" title="代码设置"></a>代码设置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">heightling_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="attr">copy_button:</span>  <span class="comment"># 设置是否开启代码块复制按钮</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span>  <span class="comment"># 是否显示复制成功信息</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>
<p>这里指的是代码块，不是行内代码块，起始写法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">​```<span class="selector-attr">[language]</span> <span class="selector-attr">[title]</span> <span class="selector-attr">[url]</span> <span class="selector-attr">[link-text]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</li>
<li>[title] 是顶部左边的说明，非必须；</li>
<li>[url] 是顶部右边的超链接地址，非必须；</li>
<li>[link text] 如它的字面意思，超链接的名称，非必须。</li>
</ul>
<p>亲测这 4 项应该是根据空格来分隔，而不是<code>[]</code>，故请不要加<code>[]</code>。除非如果你想写后面两个，但不想写前面两个，那么就必须加<code>[]</code>了，要这样写：<code>[] [] [url] [link text]</code>。</p>
<figure class="highlight cpp"><figcaption><span>你看，这是C++代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在站点配置文件_config.yml中设置自动高亮</p>
<figure class="highlight diff"><figcaption><span>文件位置：hexo/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line"># 代码自动高亮</span><br><span class="line"><span class="deletion">-  auto_detect: false</span></span><br><span class="line"><span class="addition">+  auto_detect: true</span></span><br></pre></td></tr></table></figure>
<h3 id="文章元数据设置"><a href="#文章元数据设置" class="headerlink" title="文章元数据设置"></a>文章元数据设置</h3><p>元数据就是显示在 home 页的文章创建于、更新于、阅读次数之类的数据，搜索 post_meta，找到如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">false</span>  <span class="comment"># 是否显示对应的文字</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>  <span class="comment"># 是否显示 创建于</span></span><br><span class="line">  <span class="attr">updated_at:</span>       <span class="comment"># 是否显示 更新于</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 更新日期显示规则，只有更新日期与创建日期不同时，才会显示</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># 是否显示分类信息</span></span><br></pre></td></tr></table></figure>
<h3 id="文章字数统计设置"><a href="#文章字数统计设置" class="headerlink" title="文章字数统计设置"></a>文章字数统计设置</h3><p>由于上面的元数据中没有带文章字数统计功能，需要利用<code>hexo-symbols-count-time</code>插件来完成。在 hexo 站点根目录下使用<code>npm install hexo-symbols-count-time --save</code>命令安装模块后开启上述功能使用。</p>
<p>配置站点配置文件激活插件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>配置主题配置文件</p>
<figure class="highlight yaml"><figcaption><span>NexT Config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<h3 id="博客本地搜索"><a href="#博客本地搜索" class="headerlink" title="博客本地搜索"></a>博客本地搜索</h3><p>Hexo的NexT主题通过<code>hexo-generator-searchdb</code>这个插件实现搜索本地搜索。它预先生成了一个文本库<code>search.xml</code>，然后传到了网站里面，在本地搜索时候，NexT直接用JS调用这个文件，从而实现了静态网站的本地搜索。</p>
<p>安装完插件后，站点配置文件新增</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="RSS订阅"><a href="#RSS订阅" class="headerlink" title="RSS订阅"></a>RSS订阅</h3><p>安装插件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>刷新主页就可以看到 rss。</p>
<h3 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h3><p>主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"> <span class="attr">reward_settings:</span></span><br><span class="line">   <span class="comment"># If true, reward would be displayed in every article by default.</span></span><br><span class="line">   <span class="comment"># You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter.</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">   <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">   <span class="comment">#comment: Donate comment here.</span></span><br><span class="line"> </span><br><span class="line"> <span class="attr">reward:</span></span><br><span class="line">   <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.jpg</span></span><br><span class="line">   <span class="comment">#alipay: /images/alipay.png</span></span><br><span class="line">   <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>
<h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><p>开启文章推荐功能后可以自动推荐相关内容的文章，在主题配置文件中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 是否开启</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">相关文章推荐</span>    <span class="comment"># 标题</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span> <span class="comment"># 是否在首页显示，建议为false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span>   <span class="comment"># 相关文章的最大数量</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="attr">isExcerpt:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>开启相关文章推荐需要安装<code>hexo-related-popular-posts</code>模块，即在 hexo 站点根目录下使用<code>npm install hexo-related-popular-posts --save</code>安装模块，然后开启上面的相关文章功能就可以了。</p>
<h3 id="文章版权声明"><a href="#文章版权声明" class="headerlink" title="文章版权声明"></a>文章版权声明</h3><p>在主题配置文件中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>  <span class="comment"># 将false改为true即可显示版权信息</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>在当前免费开源的评论系统中，基于leancloud的valine不仅简洁，还可以支持匿名留言。leancloud是一个面向个人用户免费的存储系统，valine后台的评论保存就是基于leancloud的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>   <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">wavatar</span> <span class="comment"># gravatar style https://valine.js.org/avatar/</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail</span> <span class="comment"># custom comment header default: nick,mail,link</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">  <span class="attr">visitors:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>为了评论能够及时通过邮箱通知，可以使用 <a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="external nofollow noopener noreferrer">Valine-Admin</a> 来配置。</p>
<h3 id="不蒜子统计网站访问信息"><a href="#不蒜子统计网站访问信息" class="headerlink" title="不蒜子统计网站访问信息"></a>不蒜子统计网站访问信息</h3><p>可以通过不蒜子服务来统计网站的访问信息，包括整个网站的UV(Unique Visitor)和PV(Page View)，还有每一个post的访问数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> </span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>
<p>注意这里的post_views和配置文件中leanCloud_visitors冲突，这里只开启了不蒜子的服务。</p>
<h2 id="Next主题进阶优化配置"><a href="#Next主题进阶优化配置" class="headerlink" title="Next主题进阶优化配置"></a>Next主题进阶优化配置</h2><h3 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h3><p>插入音乐可以直接通过网易云音乐生成外链，也可以使用 <a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="external nofollow noopener noreferrer">hexo-tag-aplayer</a> 插件中 MetingJS的支持。</p>
<p>安装了<code>hexo-tag-aplayer</code>插件之后，在Hexo配置文件中加入‘</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>接着就可以在文章中使用MetingJS播放器了</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 歌曲模板</span><br><span class="line">&#123;% meting "3986040" "netease" "song" "theme:#555" "mutex:true" "listmaxheight:340px" "preload:auto" %&#125;</span><br><span class="line"></span><br><span class="line"># 歌单模板</span><br><span class="line">&#123;% meting "627070825" "netease" "playlist" "theme:#555" "mutex:true" "listmaxheight:340px" "preload:auto" %&#125;</span><br></pre></td></tr></table></figure>

    <div id="aplayer-pcxjKGCI" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28152391" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>

    <div id="aplayer-ytPSRfzz" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2353471182" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<p>对于网易云音乐因为版权保护无法生成外链从而获取ID的问题，可以参考<a href="https://javahikers.github.io/2019/06/15/hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5aplayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/#%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%80%89%E9%A1%B9%E5%88%97%E8%A1%A8" target="_blank" rel="external nofollow noopener noreferrer">hexo在文章插入aplayer音乐播放器</a></p>
<h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><p>插入视频可以直接通过B站生成外链，也可以通过插件 <a href="https://github.com/MoePlayer/hexo-tag-dplayer" target="_blank" rel="external nofollow noopener noreferrer">hexo-tag-dplayer</a></p>
<ul>
<li>直接用生成外链</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=74371709&amp;cid=127218978&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><iframe src="//player.bilibili.com/player.html?aid=74371709&cid=127218978&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></p>
<ul>
<li><p>hexo-tag-dplayer</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer "url=https://什么什么什么.mp4" "https://封面图.jpg" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %&#125;</span><br></pre></td></tr></table></figure>
<p>要使用弹幕，必须有<code>api</code>和<code>id</code>两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与<a href="https://api.prprpr.me/dplayer/list" target="_blank" rel="external nofollow noopener noreferrer">这个列表</a>的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="external nofollow noopener noreferrer">这个工具</a>将一段与众不同的文字😂生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
</li>
<li><p>插入<code>Youtube</code>或者<code>Viemo</code>视频</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% vimeo video_id %&#125;</span><br><span class="line">&#123;% youtube video_id %&#125;</span><br></pre></td></tr></table></figure>
<div class="video-container"><iframe src="//www.youtube.com/embed/VoPnzAnclUs" frameborder="0" allowfullscreen></iframe></div>
<p>这里的<code>video_id</code>就是视频分享时生成短链接后面的字符。</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>NexT主题里面已经集成了MathJax和KaTex，配置起来也很方便。这里我们使用MathJax来渲染数学公式。</p>
<p>在主题配置文件中，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span> <span class="comment"># 默认为true，表示每篇文章需要额外地单独启用MathJax</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"> <span class="attr">vendors:</span></span><br><span class="line">   <span class="attr">mathjax:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>Hexo默认的渲染引擎<code>hexo-renderer-marked</code>对MathJax的支持很不好，会出现各种莫名其妙的问题。NexT主题的<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>也推荐换用其他渲染引擎。推荐换用<code>hexo-renderer-kramed</code>。</p>
<p>这里是一个典型的LaTeX公式示例，在markdown中的源代码和现实效果如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;<span class="number">1</span>&#125;&#123;m&#125;\lg C=\frac&#123;<span class="number">1</span>&#125;&#123;n&#125;\left(\sum<span class="number">_</span>&#123;i=<span class="number">1</span>&#125;^n&#123;Y_i+\frac&#123;<span class="number">1</span>&#125;&#123;m&#125;\sum<span class="number">_</span>&#123;i=<span class="number">1</span>&#125;^n&#123;X_i&#125;&#125;\right)$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\frac{1}{m}\lg C=\frac{1}{n}\left(\sum_{i=1}^n{Y_i+\frac{1}{m}\sum_{i=1}^n{X_i}}\right)</script><p>关于更多和LaTeX相关的内容，可以参考 <a href="../fedfc052/">LaTeX笔记</a></p>
<h3 id="添加豆瓣读书-电影"><a href="#添加豆瓣读书-电影" class="headerlink" title="添加豆瓣读书/电影"></a>添加豆瓣读书/电影</h3><p><a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="external nofollow noopener noreferrer">hexo-douban</a>是一个支持引入豆瓣读书和电影的hexo插件，它通过爬取豆瓣用户的对应信息，从而生成对应的html文本。</p>
<p>你可以参考官方README或者 <a href="https://bestzuo.cn/posts/hexo-douban.html" target="_blank" rel="external nofollow noopener noreferrer">在Hexo博客中加入豆瓣读书页面</a>参考部署。</p>
<p>当然作者所做的界面是没有样式的，我们可以在作者的基础上继续魔改增加自己喜欢的样式，在安装好所需插件后，我们打开目录为<code>hexo/node_modules/hexo-douban/lib/templates/index.css</code>文件，里面是整个阅读界面的 css 样式代码文件，我们可以在其中添加背景图片等样式，比如可以添加如下：</p>
<figure class="highlight css"><figcaption><span>文件位置：hexo/node_modules/hexo-douban/lib/templates/index.css</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">"xxx.jpg"</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改上面的 url 中地址图片链接就可以新增背景图片了~</p>
<h3 id="文章摘要图片"><a href="#文章摘要图片" class="headerlink" title="文章摘要图片"></a>文章摘要图片</h3><p>文章摘要（excerpt）是指每篇文章（post）在页面（page）上显示的那部分内容，也就是 [Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片，页面看起来就很美观。但是有时候可能会出现一个问题：你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？</p>
<p>前提是在<strong>主题</strong>配置文件中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>首先加代码:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;% if is_index %&#125;</span><br><span class="line">  &#123;% if post.description and theme.excerpt_description %&#125;</span><br><span class="line">    &#123;&#123; post.description &#125;&#125;</span><br><span class="line">    &lt;!--noindex--&gt;</span><br><span class="line">    &lt;div class="post-button text-center"&gt;</span><br><span class="line">      &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt;</span><br><span class="line">        &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!--/noindex--&gt;</span><br><span class="line">  &#123;% elif post.excerpt  %&#125;</span><br><span class="line">    &#123;&#123; post.excerpt &#125;&#125;</span><br><span class="line"><span class="addition">+   </span></span><br><span class="line"><span class="addition">+   &#123;% if post.image %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;div class="out-img-topic"&gt;</span></span><br><span class="line"><span class="addition">+     &lt;img src=&#123;&#123; post.image &#125;&#125; class="img-topic" /&gt;</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+   &#123;% endif %&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure>
<p>为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在<code>hexo/source/_data/styles.styl</code>中加入：</p>
<p>注意，目前自定义的样式文件在hexo/source目录下，这里需要自己创建<code>_data/styles.styl</code>文件，同时在主题配置文件中修<code>custom_file_path</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-class">.img-topic</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后编辑有这需求的相关文章时，在<code>Front-matter</code>（文件最上方以<code>---</code>分隔的区域）加上一行：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">url</span></span><br></pre></td></tr></table></figure>
<p><code>url</code>即图片的链接地址～</p>
<h3 id="永久性链接"><a href="#永久性链接" class="headerlink" title="永久性链接"></a>永久性链接</h3><p>Hexo 默认生成的文章地址路径是 <code>:year/:month/:day/:title/</code>。这种链接对搜索爬虫很不友好，因为它的 url 结构超过了三层，太深了；而且，如果修改了文章的文件名，就相应会修改其路径，无法保证链接的永久性，所以需要进行修改。</p>
<p>这里使用插件 <code>hexo-abbrlink</code> 来生成博客文章的永久链接，可以查看该插件的 <a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="external nofollow noopener noreferrer">GitHub 项目页面</a>。首先需要进行安装：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-abbrlink</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>
<p>然后在站点配置文件中修改 <code>permalink</code>：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="addition">+permalink: posts/:abbrlink/</span></span><br><span class="line"><span class="addition">+abbrlink:</span></span><br><span class="line"><span class="addition">+  alg: crc32  #support crc16(default) and crc32</span></span><br><span class="line"><span class="addition">+  rep: hex    #support dec(default) and hex</span></span><br></pre></td></tr></table></figure>
<h3 id="定制回到顶部"><a href="#定制回到顶部" class="headerlink" title="定制回到顶部"></a>定制回到顶部</h3><p>从 <a href="http://yearito.cn/" target="_blank" rel="external nofollow noopener noreferrer">Yearito’s Blog</a> 看到的，效果如下：</p>
<p><a href="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/back-to-top.gif" target="_blank" rel="external nofollow noopener noreferrer"><img alt="回到顶部" data-src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/back-to-top.gif"></a></p>
<p><a href="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/back-to-top.gif" target="_blank" rel="external nofollow noopener noreferrer">回到顶部</a></p>
<p>原理很简单，将 back-to-top 按钮添加图片背景，并添加 CSS3 动效即可。</p>
<p>首先，找到自己喜欢的图片素材放到 <code>source/images</code> 目录下。</p>
<p>你可以点击下方按钮下载本站所使用的小猫上吊素材（ 小猫咪这么可爱，当然要多放点孜然啦…）</p>
<p>然后在自定义样式文件<code>hexo/source/styles.styl</code>中添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//自定义回到顶部样式</span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  width: 70px;  //图片素材宽度</span><br><span class="line">  height: 900px;  //图片素材高度</span><br><span class="line">  <span class="selector-tag">top</span>: <span class="selector-tag">-900px</span>;</span><br><span class="line">  <span class="selector-tag">bottom</span>: <span class="selector-tag">unset</span>;</span><br><span class="line">  <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.5s</span> <span class="selector-tag">ease-in-out</span>;</span><br><span class="line">  background: url("/images/scroll.png");</span><br><span class="line"></span><br><span class="line">  //隐藏箭头图标</span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? <span class="built_in">calc</span>( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新浏览器即可预览效果。</p>
<h3 id="定制-sidebar"><a href="#定制-sidebar" class="headerlink" title="定制 sidebar"></a>定制 sidebar</h3><p>在<code>hexo/source/_data/styles.styl</code>中添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.sidebar</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">block;</span></span><br><span class="line">  <span class="attr">width:</span> <span class="string">320px;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">url(/images/bk.jpg);</span></span><br><span class="line">  <span class="attr">background-size:</span> <span class="string">320px,</span> <span class="string">659px;</span></span><br><span class="line">  <span class="attr">background-position:</span> <span class="string">center;</span></span><br><span class="line">  <span class="attr">background-repeat:</span> <span class="literal">no</span><span class="string">-repeat;</span></span><br><span class="line">  <span class="attr">background-color:</span> <span class="comment">#f5f5f5 !important;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">p,</span> <span class="string">span,</span> <span class="string">a</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="comment">#080808;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在images目录下添加背景图片作为sidebar的背景图片。</p>
<h3 id="定制-header"><a href="#定制-header" class="headerlink" title="定制 header"></a>定制 header</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.header</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">url("/images/header-bk.jpg");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="定制-footer"><a href="#定制-footer" class="headerlink" title="定制 footer"></a>定制 footer</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.header</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">url("/images/header-bk.jpg");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="定制网站背景"><a href="#定制网站背景" class="headerlink" title="定制网站背景"></a>定制网站背景</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">body</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">url("/images/field.jpg");</span></span><br><span class="line">  <span class="attr">background-size:</span> <span class="string">cover;</span></span><br><span class="line">  <span class="attr">background-repeat:</span> <span class="literal">no</span><span class="string">-repeat;</span></span><br><span class="line">  <span class="attr">background-attachment:</span> <span class="string">fixed;</span></span><br><span class="line">  <span class="attr">background-position:</span> <span class="string">center;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.main-inner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">75</span><span class="string">%;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">.content</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">border-radius:</span> <span class="string">10px;</span></span><br><span class="line">  <span class="attr">margin-top:</span> <span class="string">60px;</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="string">25px;</span></span><br><span class="line">  <span class="string">background:rgba(255,</span> <span class="number">255</span><span class="string">,</span> <span class="number">255</span><span class="string">,</span> <span class="number">0.8</span><span class="string">)</span> <span class="string">none</span> <span class="string">repeat</span> <span class="string">scroll</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="定制字体"><a href="#定制字体" class="headerlink" title="定制字体"></a>定制字体</h3><h3 id="开启分享"><a href="#开启分享" class="headerlink" title="开启分享"></a>开启分享</h3><h3 id="已运行时间"><a href="#已运行时间" class="headerlink" title="已运行时间"></a>已运行时间</h3><h3 id="热门文章页面"><a href="#热门文章页面" class="headerlink" title="热门文章页面"></a>热门文章页面</h3><h2 id="Next主题扩展功能"><a href="#Next主题扩展功能" class="headerlink" title="Next主题扩展功能"></a>Next主题扩展功能</h2><h3 id="使用hexo-admin在线发布文章"><a href="#使用hexo-admin在线发布文章" class="headerlink" title="使用hexo-admin在线发布文章"></a>使用hexo-admin在线发布文章</h3><h4 id="在本地部署hexo-admin"><a href="#在本地部署hexo-admin" class="headerlink" title="在本地部署hexo-admin"></a>在本地部署hexo-admin</h4><p>一直想给自己的博客添加一个后台在线编辑的功能，搜了一下发现社区已经有 <a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="external nofollow noopener noreferrer">hexo-admin</a> 这个插件。 <code>hexo-admin</code> 可以将常规的hexo命令(new, deploy等)可视化，并且提供了一个在线的markdown编辑器，使得编写hexo blog脱离了本地开发环境和IDE，从而更加灵活。</p>
<p>要使用这个工具，首先需要安装插件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install --save hexo-admin</span><br></pre></td></tr></table></figure>
<p>在客户端机器安装好插件之后，在博客根目录下面使用<code>hexo s -d</code>命令，然后打开<code>http://localhost:4000/admin/</code>进行登录就可以管理后台了。</p>
<p><img alt="hexo admin后台" data-src="https://blogimage-1258928558.cos.ap-guangzhou.myqcloud.com/blog-establish/hexo-admin.png"></p>
<p>安装好后，还需要设置登录的账号密码，不然谁都可以使用你的后台管理。第一次登录后，进入<code>setting</code>菜单，点击<code>Setup authentification here</code>进入用户名密码设置项，按照提示设置后，把生成的代码添加到<code>blog/_config.xml</code>中，如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-admin authentification</span></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">username</span></span><br><span class="line">  <span class="attr">password_hash:</span> <span class="string">$2a$10$L.XAIqIWgTc5S1zpvV3MEu7/rH34p4Is/nq824smv8EZ3lIPCp1su</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">my</span> <span class="string">super</span> <span class="string">secret</span> <span class="string">phrase</span></span><br><span class="line">  <span class="attr">deployCommand:</span> <span class="string">./admin_script/hexo_deploy.sh</span></span><br></pre></td></tr></table></figure>
<p>在blog目录下创建对应的 <code>hexo_deploy.sh</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir admin_script;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch admin_script/hexo_deploy.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x admin_script/hexo_deploy.sh</span></span><br></pre></td></tr></table></figure>
<p>文件内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>注意，这里的 <code>password_hash</code> 是你自己的明文密码经过加密后的字符串，但是如果用类似下面的网址： <a href="https://bcrypt-generator.com/" target="_blank" rel="external nofollow noopener noreferrer">https://bcrypt-generator.com/</a> 会生成<code>:$2y$10$pJjIxxxxxfMn9U/xxxxxNuuA20kh1eoB7vZxxxxx/7WpeV7IOxxxx</code>类似的加密串，但是运行会报<code>invalid salt revision</code>错误，其原因是：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">$ cat node_modules/hexo-admin/www/bundle.js | head <span class="number">-4851</span> | tail <span class="number">-10</span></span><br><span class="line">    <span class="keyword">if</span> (salt.charAt(<span class="number">0</span>) != <span class="string">'$'</span> || salt.charAt(<span class="number">1</span>) != <span class="string">'2'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Invalid salt version"</span>;</span><br><span class="line">    <span class="keyword">if</span> (salt.charAt(<span class="number">2</span>) == <span class="string">'$'</span>)</span><br><span class="line">        <span class="literal">off</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        minor = salt.charAt(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (minor != <span class="string">'a'</span> || salt.charAt(<span class="number">3</span>) != <span class="string">'$'</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">"Invalid salt revision"</span>;</span><br><span class="line">        <span class="literal">off</span> = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要版本号是2a的加密方式，因此只能用python自己写了：<br><a href="https://pypi.org/project/bcrypt/3.1.0/" target="_blank" rel="external nofollow noopener noreferrer">https://pypi.org/project/bcrypt/3.1.0/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; hashed = bcrypt.hashpw(password, bcrypt.gensalt(prefix=b<span class="string">"2a"</span>))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(hashed)</span></span><br><span class="line">b'$2a$12$PAoJr3USOBxxxxxxxxxxxxxxV/.h.QNbh/6q.xxxxxxxxxxxxxxxxcDcJ.'</span><br></pre></td></tr></table></figure>
<p>经过这些设置之后，进入后台，就可以在线创作博客了。admin的后台有一个deploy的按钮，点击这个按钮就会执行<code>hexo_deploy.sh</code> 的脚本。该脚本会将markdown文件生成静态网页，如果用nginx配置去访问静态网页，速度就会快很多。</p>
<h4 id="在服务器端部署hexo-admin"><a href="#在服务器端部署hexo-admin" class="headerlink" title="在服务器端部署hexo-admin"></a>在服务器端部署hexo-admin</h4><p>上面的部署有一个问题，就是我是想让我的在线博客具有后台编辑的功能，而不是必须在我本地启动hexo。那么要解决这个问题，必须要在服务器端运行<code>hexo server</code>的进程。</p>
<p>在之前的部署中</p>
<ul>
<li>我们都是在服务器端只是部署了nginx，在客户端机器安装了hexo的环境，所有hexo的配置都是在客户端机器上的。</li>
<li>每次在客户端更新了hexo源文件后，在客户端环境执行<code>hexo generate &amp;&amp; hexo deploy</code>将生成的public目录下的网站源文件通过git传到服务端的git服务器目录。</li>
<li>服务器端的git服务器通过<code>git hooks</code>将对应的文件复制到nginx对应的root目录</li>
</ul>
<p>要在服务端运行<code>hexo server</code>的命令，我们需要在服务端有<code>hexo server</code>运行的环境。这个环境其实也就是安装了所有插件之后的blog根目录。好在我们已经将blog目录通过git做了版本控制，这里的版本控制不仅仅监控发布post的版本，还监控网站主题各种配置的版本。</p>
<p>之前我每次更新后会将这个push到github自己的一个私人目录下。现在可以push到自己的git服务器，然后通过 <code>git hooks</code> 自动更新到某个固定的目录。通过 <code>hexo-admin</code> 后台编辑发布新文章会更新这个blog的目录，本地的blog可以通过<code>git fetch</code> 拉取远端的最新情况。</p>
<p>说干就干，具体操作如下</p>
<h5 id="服务器端创建新的blog的repo"><a href="#服务器端创建新的blog的repo" class="headerlink" title="服务器端创建新的blog的repo"></a>服务器端创建新的blog的repo</h5><p>在前面的操作中我们<a href="#配置Git服务">配置Git服务</a>，这个repo是存放的是generate出来的网站源文件，现在我们还是在git用户的repositories目录下新创建一个repo，不过这个repo里面存放的是blog的源文件，通过这个blog源文件，执行<code>hexo generate</code>的命令可以生成网站的源文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/git/repositories</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init --bare hexo.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys <span class="comment"># 添加ssh权限</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hexo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install --production</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate</span></span><br></pre></td></tr></table></figure>
<p>修改Nginx的配置文件，是的其root地址指向hexo产生的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">	listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">	server_name houmin.cc;</span><br><span class="line"></span><br><span class="line">	root &#x2F;home&#x2F;git&#x2F;hexo&#x2F;public;</span><br><span class="line">	index index.html index.htm;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		error_page 404 &#x2F;404&#x2F;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	location &#x2F;admin &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;houmin.cc:50003&#x2F;admin;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启nginx服务，应该就能够看到网站能够再次运行了</p>
<h5 id="使用pm2保持hexo-server一直在服务器后台运行"><a href="#使用pm2保持hexo-server一直在服务器后台运行" class="headerlink" title="使用pm2保持hexo server一直在服务器后台运行"></a>使用pm2保持hexo server一直在服务器后台运行</h5><p><a href="https://pm2.keymetrics.io/" target="_blank" rel="external nofollow noopener noreferrer">pm2</a>是一个专门为NodeJS开发的进程管理工具，支持管理node进程，查看node进程的状态，也支持性能监控和进程守护。因为使用 <code>hexo server -d &amp;</code> 在一段时间后会停止hexo，此时无法打开后台，所以我们采用pm2接管hexo进程。</p>
<p>在服务器端，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install -g pm2</span><br></pre></td></tr></table></figure>
<p>在服务器端博客的根目录下创建一个<code>hexo_run.js</code>的文件，内容如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec  &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line">exec(<span class="string">'hexo server -p 50003 -d'</span>,(error, stdout, stderr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'exec error: $&#123;error&#125;'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout: $&#123;stdout&#125;'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stderr: $&#123;stderr&#125;'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行开启命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm2 start hexo_run.js</span><br></pre></td></tr></table></figure>
<p>附上一个hexo重启脚本，<code>restart_hexo.sh</code>, 需要重启刷新的时候执行 <code>source restart_hexo.sh</code>即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PROCESS=`ps -ef|grep hexo|grep -v grep|grep -v PPID|awk '&#123; print $2 &#125;'`</span><br><span class="line">PROC_NAME="pm2"</span><br><span class="line">for i in $PROCESS</span><br><span class="line">do</span><br><span class="line">    echo "Kill the $1 process [ $i  ]"</span><br><span class="line">    kill -9 $i</span><br><span class="line">done</span><br><span class="line">hexo clean #清除数据</span><br><span class="line">hexo generate #生成静态文件public文件夹</span><br><span class="line">ProcNumber=`ps -ef |grep -w $PROC_NAME|grep -v grep|wc -l`</span><br><span class="line">if [ $ProcNumber -le 0  ];then</span><br><span class="line">    pm2 start hexo_run.js</span><br><span class="line">else</span><br><span class="line">    pm2 restart hexo_run.js</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<p>注意，我们可以看到<code>hexo_run.js</code>里面通过让<code>hexo server</code>监听在50003的端口，然后用pm2管理这个进程。在nginx的配置里面，用户通过<code>http://houmin.cc/admin</code>的请求，会被nginx重定向到hexo server那里。所以，你需要在云服务厂商那里配置安全组策略，开放这里的50003端口，使得用户可以访问对应的后台。</p>
<h5 id="在客户端编辑博客"><a href="#在客户端编辑博客" class="headerlink" title="在客户端编辑博客"></a>在客户端编辑博客</h5><p>可以看到我们现在可以在线编辑博客，那么如果我们想在客户端机器上本地编辑博客怎么办呢？</p>
<p>这里需要修改一下站点的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@13.250.11.186:/home/git/repositories/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>这里每次更新之后还是可以执行<code>hexo generate &amp;&amp; hexo deploy</code>去更新博客，只是在blog的<code>git hooks</code>需要修改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/home/git/hexo/public --git-dir=/home/git/repositories/blog.git checkout -f</span><br></pre></td></tr></table></figure>
<p>注意这里的work-tree改成了新的目录</p>
<h3 id="相册管理"><a href="#相册管理" class="headerlink" title="相册管理"></a>相册管理</h3><p>对于相册，在自己博客上期待实现的效果与豆瓣相册类似，具体如下</p>
<ul>
<li>主界面<ul>
<li>分类相册</li>
<li>自定义相册名</li>
<li>自定义封面</li>
<li>自动裁剪封面为等尺寸</li>
</ul>
</li>
<li>分类相册界面<ul>
<li>三等分列</li>
<li>按图片原长宽比平铺</li>
<li>点击看大图</li>
<li>本地图片源/图床外链均可</li>
<li>与文章插图格式保持统一</li>
</ul>
</li>
<li>其他<ul>
<li>每张图片都可以有对应的文字描述</li>
<li>游客可以为图片添加评论</li>
<li>相册里面也可以插入视频</li>
</ul>
</li>
</ul>
<div class="note success">
            <p>2019.12.05更新：终于填坑把相册这一块给补上了，参考 <a href="../d487dd02">Hexo NexT主题添加多级相册功能</a></p>
          </div>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><h3 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h3><h3 id="开启HTTPS"><a href="#开启HTTPS" class="headerlink" title="开启HTTPS"></a>开启HTTPS</h3><p>现在个人博客开启HTTPS可以看到 <code>cloudflare</code> 和 <code>letsencrypt</code> 两种方案，这里的是 <code>letsencrypt</code> 的方案，参考博客 <a href="https://segmentfault.com/a/1190000015758393" target="_blank" rel="external nofollow noopener noreferrer">教你快速撸一个免费HTTPS证书</a></p>
<h4 id="安装-certbot"><a href="#安装-certbot" class="headerlink" title="安装 certbot"></a>安装 certbot</h4><p><a href="https://certbot.eff.org/" target="_blank" rel="external nofollow noopener noreferrer">Certbot</a>可以用于管理(申请、更新、配置、撤销和删除等)Let’s Encrypt证书。这里安装的是带nginx插件的certbot：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:certbot/certbot</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y python-certbot-nginx</span><br></pre></td></tr></table></figure>
<h4 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h4><p>使用certbot命令为<a href="https://houmin.cc/">houmin.cc</a>申请HTTPS证书。<strong>—nginx</strong>选项表示Web服务器为nginx，<strong>-d</strong>选项指定域名，<strong>-n</strong>选项表示非交互式运行命令。若去除<strong>-n</strong>选项，则终端会提醒你选择是否将http请求重定向为https请求。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">certbot <span class="comment">--nginx -d houmin.cc</span></span><br></pre></td></tr></table></figure>
<p>证书申请成功之后，会看到以下信息。Let’s Encrypt证书的有效期只有3个月，但是<a href="https://community.letsencrypt.org/t/cerbot-cron-job/23895/5?u=fundebug" target="_blank" rel="external nofollow noopener noreferrer">Certbot会通过Cron和systemd timer自动更新证书</a>，证书的时效性不用担心。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class="line">   /etc/letsencrypt/live/houmin.cc/fullchain.pem</span><br><span class="line">   Your key file has been saved at:</span><br><span class="line">   /etc/letsencrypt/live/houmin.cc/privkey.pem</span><br><span class="line">   Your cert will expire on 2020-03-15. To obtain a new or tweaked</span><br><span class="line">   version of this certificate in the future, simply run certbot again</span><br><span class="line">   with the "certonly" option. To non-interactively renew *all* of</span><br><span class="line">   your certificates, run "certbot renew"</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate</span><br><span class="line">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure>
<p>当前的nginx配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    server_name houmin.cc;</span><br><span class="line"></span><br><span class="line">    root &#x2F;home&#x2F;git&#x2F;hexo&#x2F;public;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        error_page 404 &#x2F;404&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;admin &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;houmin.cc:50003&#x2F;admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers 4 16k;</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    gzip_comp_level 2;</span><br><span class="line">    gzip_types text&#x2F;plain text&#x2F;css text&#x2F;xml application&#x2F;javescript application&#x2F;json image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    listen [::]:443 ssl ipv6only&#x3D;on; # managed by Certbot</span><br><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;houmin.cc&#x2F;fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;houmin.cc&#x2F;privkey.pem; # managed by Certbot</span><br><span class="line">    include &#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam &#x2F;etc&#x2F;letsencrypt&#x2F;ssl-dhparams.pem; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="博客写作进阶"><a href="#博客写作进阶" class="headerlink" title="博客写作进阶"></a>博客写作进阶</h2><h3 id="Note标签使用"><a href="#Note标签使用" class="headerlink" title="Note标签使用"></a>Note标签使用</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note default </span>%&#125;</span><br><span class="line">默认形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>默认形式的类别</p>
          </div>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span>primary %&#125;</span><br><span class="line">首要类型形式</span><br><span class="line">&#123;% endnote %&#125;`</span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p>首要类型形式</p>
          </div>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span><span class="builtin-name">info</span> %&#125;</span><br><span class="line">info形式</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>info形式</p>
          </div>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span>success %&#125;</span><br><span class="line">首要类型形式</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>success形式</p>
          </div>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span><span class="builtin-name">warning</span> %&#125;</span><br><span class="line">warning形式</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>warning形式</p>
          </div>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span>danger %&#125;</span><br><span class="line">danger形式</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note danger">
            <p>danger形式</p>
          </div>
<h3 id="文本居中引用"><a href="#文本居中引用" class="headerlink" title="文本居中引用"></a>文本居中引用</h3><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">cq</span> %&#125;</span></span><br><span class="line"><span class="xml">人生乃是一面镜子，</span></span><br><span class="line"><span class="xml">从镜子里认识自己，</span></span><br><span class="line"><span class="xml">我要称之为头等大事，</span></span><br><span class="line"><span class="xml">也只是我们追求的目的！</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endcq</span> %&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p>
</blockquote>
<h3 id="Tabs标签"><a href="#Tabs标签" class="headerlink" title="Tabs标签"></a>Tabs标签</h3><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">tabs</span> 选项卡, 2 %&#125;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 1**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 2**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 3**</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span></span><br></pre></td></tr></table></figure>
<div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong></p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong></p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong></p></div></div></div>
<h3 id="插入-PDF"><a href="#插入-PDF" class="headerlink" title="插入 PDF"></a>插入 PDF</h3><figure class="highlight yaml"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">500px</span></span><br></pre></td></tr></table></figure>
<p>使用方法</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% pdf url [height] %&#125;</span></span><br><span class="line"></span><br><span class="line">[url]    : <span class="symbol">Relative</span> path to <span class="symbol">PDF</span> file.</span><br><span class="line">[height] : <span class="symbol">Optional</span>. <span class="symbol">Height</span> of the <span class="symbol">PDF</span> display element, e.g. <span class="number">800</span>px.</span><br></pre></td></tr></table></figure>
<div class="pdf" target="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/pdf/2018-03-16_distr.pdf" height="800px"></div>
<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;% label [class]@Text %&#125;</span><br><span class="line"></span><br><span class="line">[class] :<span class="built_in"> default </span>| primary | success | <span class="builtin-name">info</span> | <span class="builtin-name">warning</span> | danger.</span><br><span class="line">          <span class="string">'@Text'</span> can be specified with <span class="keyword">or</span> without space</span><br><span class="line">          E.g. <span class="string">'success @text'</span> similar <span class="keyword">to</span> <span class="string">'success@text'</span>.</span><br><span class="line">          <span class="keyword">If</span> <span class="keyword">not</span> specified,<span class="built_in"> default </span>class will be selected.</span><br></pre></td></tr></table></figure>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">Lorem </span><span class="template-tag">&#123;% <span class="name">label</span> @ipsum %&#125;</span><span class="xml"> </span><span class="template-tag">&#123;% <span class="name">label</span> primary@dolor sit %&#125;</span><span class="xml"> amet, consectetur </span><span class="template-tag">&#123;% <span class="name">label</span> success@adipiscing elit, %&#125;</span><span class="xml"> sed </span><span class="template-tag">&#123;% <span class="name">label</span> info@do eiusmod %&#125;</span><span class="xml"> tempor incididunt ut labore et dolore magna aliqua.</span></span><br><span class="line"></span><br><span class="line"><span class="xml">Ut enim *</span><span class="template-tag">&#123;% <span class="name">label</span> warning @ad %&#125;</span><span class="xml">* minim veniam, quis **</span><span class="template-tag">&#123;% <span class="name">label</span> danger@nostrud %&#125;</span><span class="xml">** exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</span></span><br><span class="line"></span><br><span class="line"><span class="xml">Duis aute irure dolor in reprehenderit in voluptate ~~</span><span class="template-tag">&#123;% <span class="name">label</span> default @velit %&#125;</span><span class="xml">~~ <span class="tag">&lt;<span class="name">mark</span>&gt;</span>esse<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span></span><br></pre></td></tr></table></figure>
<p>Lorem <span class="label default">ipsum</span> <span class="label primary">dolor sit</span> amet, consectetur <span class="label success">adipiscing elit,</span> sed <span class="label info">do eiusmod</span> tempor incididunt ut labore et dolore magna aliqua.</p>
<p>Ut enim <em><span class="label warning">ad</span></em> minim veniam, quis <strong><span class="label danger">nostrud</span></strong> exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
<p>Duis aute irure dolor in reprehenderit in voluptate <del><span class="label default">velit</span></del> <mark>esse</mark> cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<h2 id="博客推广及优化"><a href="#博客推广及优化" class="headerlink" title="博客推广及优化"></a>博客推广及优化</h2><h3 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h3><p>robots.txt是搜索引擎蜘蛛协议，告诉引擎哪些要收录，哪些禁止收录。<br>source文件夹下新建 robots.txt，内容如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">User-<span class="string">agent:</span> *</span><br><span class="line"><span class="string">Allow:</span> /</span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/archives/</span></span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/categories/</span></span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/tags/</span></span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/about/</span></span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/posts/</span></span><br><span class="line"></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/assets/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/js/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/css/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/lib/</span></span><br><span class="line"></span><br><span class="line"><span class="string">Sitemap:</span> <span class="string">http:</span><span class="comment">//www.houmin.cc/sitemap.xml</span></span><br><span class="line"><span class="string">Sitemap:</span> <span class="string">http:</span><span class="comment">//www.houmin.cc/baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
<h3 id="URL持久化"><a href="#URL持久化" class="headerlink" title="URL持久化"></a>URL持久化</h3><p>大家知道 hexo 默认的链接是 <code>http://xxx.yy.com/2018/07/14/hello-world</code> 这种类型的，这源于站点目录下的配置 <code>_config.yml</code> 里的配置 <code>:permalink: :year/:month/:day/:title/</code>，这种默认配置的缺点就是一般文件名是中文，导致 <code>url</code> 链接里有中文出现，同时多层目录也不利于SEO。</p>
<p><code>hexo-abbrlink</code>这个插件，猜测是根据时间点算出的最终链接，这样就确保了博文链接的唯一化，只要不修改 md 文件的abbrlink的值， url 就永久不会改变。如此 md 文件名和文件内容也可以随便改了。后面的层级更短，这样也有利于 SEO 优化。</p>
<p>安装：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-abbrlink <span class="comment">--save</span></span><br></pre></td></tr></table></figure><br>配置：<br>站点配置文件里:<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">permalink:</span> post/:abbrlink/</span><br><span class="line"><span class="symbol">abbrlink:</span></span><br><span class="line"><span class="symbol"> alg:</span> crc32  <span class="meta"># 算法：crc16(default) and crc32</span></span><br><span class="line"><span class="symbol"> rep:</span> hex    <span class="meta"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><br><div class="note info">
            <p>百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</p><p>搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。</p>
          </div></p>
<h3 id="添加nofollow标签"><a href="#添加nofollow标签" class="headerlink" title="添加nofollow标签"></a>添加nofollow标签</h3><p><code>nofollow</code> 标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 <code>nofollow</code> 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。<br>这里推荐 <code>hexo-autonofollow</code> 插件来解决。</p>
<p>安装：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-autonofollow  --save</span><br></pre></td></tr></table></figure><br>配置：<br>在站点配置文件中添加以下代码：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="comment"># 例外的链接，可将友情链接放置此处</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">你自己的站点地址</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">友链地址</span></span><br></pre></td></tr></table></figure></p>
<h3 id="搜索引擎收录"><a href="#搜索引擎收录" class="headerlink" title="搜索引擎收录"></a>搜索引擎收录</h3><p>参考博客 <a href="https://blog.csdn.net/qq_43414988/article/details/92374636" target="_blank" rel="external nofollow noopener noreferrer">百度录入</a></p>
<h2 id="网站加速"><a href="#网站加速" class="headerlink" title="网站加速"></a>网站加速</h2><h3 id="Nginx-gzip压缩"><a href="#Nginx-gzip压缩" class="headerlink" title="Nginx gzip压缩"></a>Nginx gzip压缩</h3><p>参考 <a href="https://www.cnblogs.com/kevingrace/p/10018914.html" target="_blank" rel="external nofollow noopener noreferrer">Nginx gzip压缩</a></p>
<h3 id="利用gulp压缩代码"><a href="#利用gulp压缩代码" class="headerlink" title="利用gulp压缩代码"></a>利用gulp压缩代码</h3><p>参考 <a href="https://zhuanlan.zhihu.com/p/28447279" target="_blank" rel="external nofollow noopener noreferrer">gulp压缩</a></p>
<h3 id="修改默认Google字体库"><a href="#修改默认Google字体库" class="headerlink" title="修改默认Google字体库"></a>修改默认Google字体库</h3><h3 id="对象存储存放图片资源"><a href="#对象存储存放图片资源" class="headerlink" title="对象存储存放图片资源"></a>对象存储存放图片资源</h3><p>图床替换之后，可以通过<code>sed</code>命令全局替换图片链接</p>
<h2 id="多主机同步源码"><a href="#多主机同步源码" class="headerlink" title="多主机同步源码"></a>多主机同步源码</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://juejin.im/post/5c62bf5f51882562c5505fa4" target="_blank" rel="external nofollow noopener noreferrer">绕开阿里云域名备案: http服务升级到https</a></li>
<li><a href="https://www.luofan.net/post/105.html" target="_blank" rel="external nofollow noopener noreferrer">薅羊毛，Amazon AWS免费使用一年，详细教程说明</a></li>
<li><a href="https://theme-next.org/" target="_blank" rel="external nofollow noopener noreferrer">https://theme-next.org/</a></li>
<li><a href="http://tding.top/archives/aad98408.html" target="_blank" rel="external nofollow noopener noreferrer">Hexo搭建个人博客文章汇总</a></li>
<li><a href="http://tding.top/archives/aad98408.html" target="_blank" rel="external nofollow noopener noreferrer">Hexo博客+Next主题深度优化与定制</a></li>
<li><a href="https://javahikers.github.io/2019/06/15/hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5aplayer%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/#%E5%85%B3%E4%BA%8E%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%80%89%E9%A1%B9%E5%88%97%E8%A1%A8" target="_blank" rel="external nofollow noopener noreferrer">hexo在文章插入aplayer音乐播放器</a></li>
<li><a href="http://goingmerry.cn/2019/10/22/Hexo-admin%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" target="_blank" rel="external nofollow noopener noreferrer">Hexo-admin服务器部署</a></li>
<li><a href="https://www.cnblogs.com/zjutlitao/p/10416094.html" target="_blank" rel="external nofollow noopener noreferrer">搭建hexo博客</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>25：我在未来等你</title>
    <url>/posts/fa1a82ad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>所以，这就二十五岁了呀。一下子就步入20年代的后半段，时光就这样不在乎你自己的节奏，自顾自的往前走。</p>

    <div id="aplayer-LixDKfhZ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="526470685" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<p>其实爸妈早就在我阴历生日给我发了生日祝福和红包，但是自己还是想以这个阳历生日作为节点，正式宣告我25岁的到来。真的是很有仪式感的一个生日了吧。毕竟，从春天就开始的秋招到现在正式结束了，在微软五个月的实习生涯也暂时告一段落。今年是来北京的第七年，也是学生时代的最后一年。总觉得这是人生的一个重要节点，呐你看，读了二十年的书，找完了工作，马上就要成为一个社会人了呀。正好也是二十五岁的生日，距离三十而立也只有五年的时光。心里想着，接下来的路要怎么走呢？在这之后，你需要承担更多的东西了呀。</p>
<p>六年前的秋天，第一次来到北京，真的是被北京的秋天惊艳到了，从此爱上了故都的秋。蓝天白云，红墙绿瓦，清风凉爽，黄叶飘飘，加上燕园古典雅素的老建筑，真的是很很舒适了。然后时钟的发条飞速旋转，到现在再一看，居然已经在北京呆的是第七年了。给依老师当助教的时候，看着大一大二的小同学，突然意识到，啊我已经这么老了啊。不过毕竟我还是很乐观的，看着一起工作的FTE们，哈哈哈，二十五岁嘛，还是很年轻的，正是当打之年，作为祖国精心培养的青年人，还是有大把的时光为祖国发展贡献力量：）</p>
<p>中间是想过毕业之后是不是要换一个城市呢。你说说，北京这个城市，房价这么高，压力这么大，是不是换一个城市会更好一点呢。毕竟，也呆了六七年了嘛，换个城市感受一下是不是会更好一点呢？比如上海，比如杭州，或者深圳？毕竟，一个单身狗，去哪个城市好像都很自由。但是，到了真正秋招的时候，除了最开始的一段时间纠结了一下，之后迅速的决定想留在北京。毕竟，对于互联网这个方向，我发现我可以投的很多岗位都在北京，至于房价至于压力，好像北京和上海深圳也差不了太多？反正现在都还买不起。加上北京的气候我也很喜欢，还有北京的暖气，除了北京的早餐样式太单一之外，感觉都还好。</p>
<p>所以，就这么粗暴的决定了留在北京。说不定，以后真的就定居在这边了呢，谁知道呢。</p>
<p>来北京的这几年，看到很多很多优秀的人，你可以从他们身上看到自己想成为的样子。我觉得我是一个很乐观的人，也是一个愿意去努力去改变的人。现在身上还有这样或者那样的不足，但是人是一个可进步的动物，你永远可以变得更好。在学校里我钦佩像呆呆老师、依老师这样的老师，除了自身专业的素养以外，你可以看到他们身上散发的热情，待人接物的柔和舒适。在MSRA这边实习，也会看到CP，ZX，Ran，Lei这样优秀的前辈。今天和CP聊天，感觉自己对于Work Life<br>Balance有了进一步的认识。这也是我一直认可的，工作就在那里，只要你能按时按点优秀的完成，而不在意你选择何种方式在什么时刻去做这么一件事情，我们关注的是结果。今天CP让我印象特别深刻的一句话是，<code>工作可以有DDL，但是生活没有，生活就是这样一直往前走</code>。（所以我这个节点论在他那里应该是不成立的？hhh)</p>
<p>所以呀，今天是你二十五岁的生日，你未来还有很长的一段路要走，你期待你的未来是怎么样的呢？</p>
<p>未来的路，或许会有很多的坎坷，你肯定也会经历这样或者那样的挫折。但是我希望，在这个旅途中，你能够一直保有希望，一直能有一颗积极乐观的心，在完成工作的同时，尽量的去发挥你作为人最大的主观能动性。人这一辈子，总要做一些有价值的事情吧，不然这一生岂不是白过。希望在我老了的时候，能够自豪的对着我的小孙子说，你看看你爷爷我当年怎么怎么的（期待他不要烦）（啊喂，你先找个女朋友再说吧←_←</p>
<p>一直认为自己是一个不善于表达情感的人，期待自己以后能够变好一点。很感谢FourSum第一个指针送的蛋糕，大家吃的都很开心。从秋招开始，大家也一直辛苦到了现在，中间各种曲折坎坷，好在大家现在都有了一些不错的消息，甚至可能接下来还会有一些更好的消息。能有这么几个人，或者阳春白雪或者下里巴人，随心所致，畅怀大笑的人，真的挺难得的，很开心能够这样恣意潇洒。</p>
<p><img alt="Four Sum" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18-four-sum.jpg"></p>
<p>自己现在还是一个人，也许下一个生日就不是的呢，总要往好的方向想对吧。总是会对甜甜的恋爱有所期待，就像今天晚上的冰激淋一样。</p>
<p>二十五岁啦，要加油呀，你永远可以做一个更好的自己: )</p>
]]></content>
      <categories>
        <category>生日快乐</category>
      </categories>
      <tags>
        <tag>birthday</tag>
      </tags>
  </entry>
  <entry>
    <title>醉酒</title>
    <url>/posts/132128c1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>几许痴人聚一堂，掷股赌酒齐酣畅。诸君频频共举杯，醉眼怎堪弄影茫。</p>
</blockquote>
<a id="more"></a>

    <div id="aplayer-kNSqtvQH" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="614027" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<p>第一次，我喝醉了，断片的那种。</p>
<p>并没有什么伤肠寸断的事情，只是几个人，聊的开心，一时间也没有收住。然后，一杯接着一杯，最终以一个醉酒的状态迎来了2010年代的最后一个月。</p>
<p>你喜欢喝酒吗？哦不，我不喜欢。</p>
<p>酒这种东西，既没有雪碧的甜口，也没有茶的清香。除了那些梅子酒和甜葡萄酒之外，其他的白酒、清酒、烧酒、啤酒我都不喜欢。他们说的酒的醇香爽口，直到今天我还是不能get到。我不理解，为什么那么多人喜欢喝酒。曾经问过一个同学，他说他们喜欢的不是酒的味道，而是喜欢喝酒之后的那种微醺的感觉。这在我看来是可解的，喝完酒之后人的话就会不由自主的多起来，也会说出平常自己不愿意说的话。</p>
<p><img alt="居酒屋的我们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-12-01-drunk.jpg"></p>
<p>但是呢，可以理解不代表喜欢。真的，醉酒的成本太高了，昨天晚上喝到十二点最后转战马路边边的时候吐了，早上起来的时候再一次吐了，一直到现在还是很难受。太伤身体了，以后尽量不能够这个样子了。</p>
<p>早上起来的时候，突然意识到已经十二月份了啊。一年的最后一个月，当它结束之时，我们也就迎来了2020年代。</p>
<p>2010年代的开始，是从初三奔入高中。<br>2020年代的开始，是从学校进入职场。</p>
<p>2010年代，我一直在读书，高中三年，本科四年，研究生三年。这十年呢，我从当初那个怯生生的小男生，成长到现在这个还算成熟的青年人。这十年是一个按部就班的十年，非常的按部就班以至于好像没啥亮点。</p>
<p>未来的十年，期待自己能够更加的主动，更加的积极。毕竟，25岁了，你的人生完全由你来掌控，你需要更加外向的去拥抱这个世界，去认识更多有意思的人，去过一个酣畅淋漓的人生。这十年，将是你人生中最重要的十年，也是最灿烂的十年。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
  </entry>
  <entry>
    <title>【Go语言设计与实现】代码即文档</title>
    <url>/posts/cb5a5d4d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>软件工程中有一句话叫做 <strong>代码即文档</strong>，就是说理想条件下我们通过阅读代码就能够比较好的理解软件的设计思路以及功能。为了更好的维护软件和文档，通常采用的方式是将文档和软件结合在一起，这样文档方便书写，同时也利于维护。</p>
<p>类似于Python中的<code>docstring</code> 和Java里面的<code>Javadoc</code>，Go也提供了文档化工具<code>godoc</code>。</p>
<a id="more"></a>
<p>它通过解析源代码，包括注释，可以产生不同格式的文档(HTLM，或者txt文件)。与此同时，如果代码开源在github等开放平台中，还可以通过<code>godoc.org</code>自动生成对应的文档，并且可以仅仅通过点击链接，从一个函数的文档到该函数的源码实现。</p>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><ol>
<li><p>注释符<code>//</code>后面要加空格, 例如: <code>// xxx</code></p>
</li>
<li><p>在<code>package, const, type, func</code>等<code>关键字</code>上面并且紧邻关键字的注释才会被展示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此行注释被省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此行注释被展示 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 此行注释被展示2 </span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type, const, func</code>以名称为注释的开头, <code>package</code>以<code>Package name</code>为注释的开头</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package banana ...</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xyz ...</span></span><br><span class="line"><span class="keyword">const</span> Xyz = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Abc ...</span></span><br><span class="line"><span class="keyword">type</span> Abc <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bcd ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bcd</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有效的关键字注释不应该超过<code>3</code>行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package banana ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 最好不要超过三行</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Package</code>的注释如果超过<code>3</code>行, 应该放在当前包目录下一个单独的文件中, 如:<a href="https://golang.org/pkg/encoding/gob/" target="_blank" rel="external nofollow noopener noreferrer">doc.go</a></p>
</li>
<li><p><strong>如果当前包目录下包含多个Package注释的go文件(包括doc.go), 那么按照文件名的字母数序优先显示</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----- doc.go -----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...第一个显示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----- e.go -----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package banana ...第二个显示</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----- f.go -----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package banana ...第三个显示</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Package</code>的注释会出现在godoc的<a href="https://golang.org/pkg/" target="_blank" rel="external nofollow noopener noreferrer">包列表</a>中, 但只能展示大约523字节的长度</p>
</li>
<li><p>在无效注释中以<code>BUG(who)</code>开头的注释, 将被识别为已知bug, 显示在<code>bugs</code>区域, <a href="https://link.jianshu.com?t=http://golang.org/pkg/bytes/#bugs" target="_blank" rel="external nofollow noopener noreferrer">示例</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BUG(who): 我是bug说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package banana ...</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>bug注释</code>和<code>关键字注释</code>中间无换行, 那么<code>混合的注释</code>将被显示在<code>bugs</code>和<code>godoc列表</code>两个区域内</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BUG(who): 我是bug注释</span></span><br><span class="line"><span class="comment">// Package banana ...也是pkg注释</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
</li>
<li><p>段落:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abc ... bcd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Basic(字体加粗变蓝需首字母大写, 中文加粗变蓝需要加上一个大写字母)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">... 属于Basic的段落</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">bcd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> banana</span><br></pre></td></tr></table></figure>
</li>
<li><p>预格式化:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abc ... bcd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Abc(不会加粗变蓝, 预格式化和段落不能同时存在)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    abc ... 预格式化需要缩进 ... bcd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>URL将被转化为HTML链接</p>
</li>
</ol>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul>
<li>文件必须放在当前包下</li>
<li>文件名以<code>example</code>开头, <code>_</code>连接, <code>test</code>结尾, 如:<code>example_xxx_test.go</code> </li>
<li>包名是<code>当前包名</code> + <code>_test</code>, 如: <code>strings_test</code> </li>
<li>函数名称的格式<code>func Example[FuncName][_tag]()</code> </li>
<li>函数注释会展示在页面上</li>
<li>函数结尾加上<code>// Output:</code>注释, 说明函数返回的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件必须放在 banana包目录下, 名字必须为example_xxx_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package banana_test 为banana包的示例</span></span><br><span class="line"><span class="keyword">package</span> banana_test</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此注释将会被展示在页面上</span></span><br><span class="line"><span class="comment">// 此函数将被展示在OverView区域</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello OverView"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// Hello OverView</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数将被展示在OverView区域, 并展示noOutput标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_noOutput</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello OverView"</span>)</span><br><span class="line">    <span class="comment">// (Output: )非必须, 存在时将会展示输出结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数将被展示在Function区域</span></span><br><span class="line"><span class="comment">// Peel必须是banana包实现的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePeel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello Banana"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// Hello Banana</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数将被展示在Function区域</span></span><br><span class="line"><span class="comment">// Peel必须是banana包实现的方法, 并展示big标签</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePeel_big</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello Banana"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// Hello Banana</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>如果你的golang项目上传了github，可以通过特殊的url，看到自己的库的文档，如下:</p>
<p><a href="https://godoc.org/github.com/SimpCosm/algorithms/strings/kmp" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/github.com/SimpCosm/algorithms/strings/kmp</a> // 这是生成的文档地址</p>
<p><a href="https://github.com/SimpCosm/algorithms/strings/kmp" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/SimpCosm/algorithms/strings/kmp</a> // 这是对应的github库地址</p>
<h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">godoc -http=":6060"</span><br></pre></td></tr></table></figure>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ol>
<li>如何现实成main函数的，并且能够跑Goplayground</li>
</ol>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>godoc</tag>
      </tags>
  </entry>
  <entry>
    <title>ゆきのはな</title>
    <url>/posts/d72ef121/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>下第一场雪的时候表白的话，据说可以永久在一起。</p>

    <div id="aplayer-thlsTzxs" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="625096" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<blockquote class="blockquote-center"><p>のびた人陰を舗道にならべ<br>夕闇のなかを君と歩いてる<br>手をつないでいつまでもずっと<br>そばにいれたなら<br>泣けちゃうくらい</p>
<p>風が冷たくなって<br>冬の匂いがした<br>そろそろこの街に<br>君と近付ける季節がくる<br>今年、最初の雪の華を<br>ふたり寄り添って<br>眺めているこの瞬間に<br>幸せがあふれだす</p>
<p>甘えとか弱さじゃない<br>ただ、君を愛してる<br>心からそう思った<br>君がいるとどんなことでも<br>乗りきれるような気持ちになってる<br>こんな日々がいつまでもきっと<br>続いてくことを祈っているよ</p>
<p>風が窓を揺らした<br>夜は揺り起こして<br>どんな悲しいことも<br>僕が笑顔へと変えてあげる<br>舞い落ちてきた雪の華が<br>窓の外ずっと<br>降りやむことを知らずに<br>僕らの街を染める<br>誰かのために何かを<br>したいと思えるのが<br>愛ということを知った<br>もし、君を失ったとしたなら<br>星になって君を照らすだろう<br>笑顔も涙に濡れてる夜も<br>いつもいつでもそばにいるよ</p>
<p>今年、最初の雪の華を<br>ふたり寄り添って<br>眺めているこの瞬間に<br>幸せがあふれだす<br>甘えとか弱さじゃない<br>ただ、君とずっと<br>このまま一緒にいたい<br>素直にそう思える<br>この街に降り積もってく<br>真っ白な雪の華<br>ふたりの胸にそっと想い出を描くよ<br>これからも君とずっと</p>
</blockquote>
<p>下雪了呀，难得准时的北京初雪。初雪，多么浪漫的词。</p>
<p>据说，一起看到初雪的情侣，会永远幸福的在一起。<br>据说，在下第一场雪的时候表白的话，成功率超过90%。<br>据说，在初雪的那天，你会碰上你喜欢的人。</p>
<p>今天的初雪呢，我还是自己一个人在一起：）<br>现在没有自己喜欢的人。<br>但是呢，我悄悄给自己立了一个FLAG。期待从今天起，在自己这个独立的空间里，静静地记录自己的生活，每一天。嗯，这是一个FLAG，但是我期待它能够实现。</p>
<p>我期待，在这里可以有我每天喜欢的音乐；<br>我期待，在这里可以有我每天记录的光影；<br>我期待，在这里可以有我每天思考的文字。</p>
<p>人的一生，由有限个数字的日子。假设我还能再或75年，那么也就只有27375天组成，算起来也就只有不到三万天。更实际一点的话，可能也就只有两万多一点。</p>
<p>所以呢，我期待自己的每一天，能够过的有意义，能够有它自己的思考。从今天起，记录岁月的时光。</p>
<p>那么，今天的问题是什么呢？</p>
<p><strong> 什么样的女孩子会让你动心呢 </strong></p>
<p>虽然，我一直开玩笑说，只要是女的和活的就行。但是，玩笑归玩笑，谁还没有一点小心思呢。对于未来的那个她，我仍然是有一些期待。</p>
<p>首先呢，就是要「有眼缘」。眼缘真的是一个奇怪的东西。它说的是长得漂亮就完了吗？不是的，对于我来说，所谓的颜值只是一个门槛。有时候一个女孩子，可能在其他人看来并没有那么好看，但是她在某一个时刻可能就会让我动心。有时候呢，也许在其他人眼里看起来很好看的女孩子，我并不喜欢她身上的某些特质，这样之后，好看可能也是没有眼缘的。</p>
<p>然后呢，你喜欢什么样的女孩子呢？在下面，我可以罗列出很多很多的标准，但是它可能只是我心中的意淫。也许碰到那个女孩子之后，这些标准都完全没有意义了，谁知道呢？</p>
<ul>
<li>我喜欢爱笑的女孩子。爱笑的女孩子真的是世界上最美的生物</li>
<li>那个女孩子有自己的想法，我可以和她一起探讨生活中各种各样有意思的问题</li>
<li>她可能是活泼的，可能是古灵精怪的，也可能是温柔知性的，我不知道</li>
<li>她一定要喜欢小孩子，因为我特别喜欢小孩子</li>
<li>她也许喜欢厨艺，或者我们可以一起探索美食世界</li>
</ul>
<p>呀，怎么在这里罗列条件呢？我不知道你是什么样子的，期待你能够亲自给我描绘你的美丽。</p>
<hr>
<p>今日光影</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/video/2019-11-29-yuki.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo NexT 添加多级相册功能</title>
    <url>/posts/d487dd02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在 <a href="../a63a603e/">上一篇关于Hexo的文章</a> 之后，其中关于相册的功能一直没太能完全实现，暂时采用的是 <a href="https://cherryzzangg.site/2019/02/10/%20HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">HEXO博客搭建相册</a> 的解决方案，但是没有子相册的功能。时隔将近一个月之后，自己在 <strong>Hexo NexT</strong> 主题下自己实现了自己想要的功能，大体能够满足我的需求，也许以后还会再改。这篇文章仅仅当做自己的记录，期待能够给其他人带来一些参考。</p>
<a id="more"></a>
<h2 id="相册期待实现效果"><a href="#相册期待实现效果" class="headerlink" title="相册期待实现效果"></a>相册期待实现效果</h2><p>对于相册，在自己 <strong>基于Hexo NexT搭建</strong> 的博客上期待实现与豆瓣相册类似的效果，具体如下</p>
<ul>
<li>主界面<ul>
<li>分类相册</li>
<li>自定义相册名</li>
<li>自定义封面</li>
</ul>
</li>
<li>分类相册界面<ul>
<li>三等分列</li>
<li>点击看大图</li>
<li>本地图片源/图床外链均可</li>
<li>与文章插图格式保持统一</li>
</ul>
</li>
<li>其他<ul>
<li>每张图片都可以有对应的文字描述</li>
<li>游客可以为图片添加评论</li>
<li>相册里面也可以插入视频</li>
</ul>
</li>
</ul>
<h2 id="目前可查到的方案"><a href="#目前可查到的方案" class="headerlink" title="目前可查到的方案"></a>目前可查到的方案</h2><ul>
<li><a href="https://asdfv1929.github.io/2018/05/26/next-add-photos" target="_blank" rel="external nofollow noopener noreferrer">Hexo NexT主题内添加相册功能</a> 没有子相册功能，流程不够自动化</li>
<li><a href="https://co5.me/2018/181112-gallerry2.html" target="_blank" rel="external nofollow noopener noreferrer">css+markdown 实现 hexo 相册</a> 纯css的实现，没有photoswipe的效果，不够动态</li>
<li><a href="https://cherryzzangg.site/2019/02/10/%20HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">HEXO博客搭建相册</a> 没有子相册功能</li>
<li><a href="https://liyangzone.com/2019/07/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BA%A7%E5%88%86%E7%B1%BB%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">hexo博客添加一级分类相册功能</a> 使用的不是Next主题</li>
</ul>
<p>自己也到Hexo NexT的github社区问过<a href="https://github.com/theme-next/hexo-theme-next/issues/1253" target="_blank" rel="external nofollow noopener noreferrer">大家的意见</a>。确实作为相册这个功能，每个人都有自己独特的需求，如果能够开发成专门的插件似乎是一个更好的选择。（也许以后可以再填一填坑？现在确实还没太有时间来搞这个）</p>
<h2 id="我的实现方案"><a href="#我的实现方案" class="headerlink" title="我的实现方案"></a>我的实现方案</h2><p>我的方案基本上是 <a href="https://liyangzone.com/2019/07/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BA%A7%E5%88%86%E7%B1%BB%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">hexo博客添加一级分类相册功能</a> 和 <a href="https://cherryzzangg.site/2019/02/10/%20HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">HEXO博客搭建相册</a> 两篇文章方法的综合体。具体如下</p>
<h3 id="一级分类相册-Album"><a href="#一级分类相册-Album" class="headerlink" title="一级分类相册 Album"></a>一级分类相册 Album</h3><p>一级分类相册需要有自己专门的页面，我们可以自己定制Album的页面，然后Hexo就会基于模板渲染出对应的html页面。这里只是根据配置，在Album页面加入了各个gallery的封面，相册名和相册描述。根据需要，你也可以添加更新时间，相册的图片数量等信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends '_layout.swig' %&#125;</span><br><span class="line">&#123;% import '_macro/sidebar.swig' as sidebar_template with context %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-block"</span> <span class="attr">lang</span>=<span class="string">"&#123;&#123; page.lang or page.language or config.language &#125;&#125;"</span>&gt;</span></span><br><span class="line">            &#123;% include '_partials/page/page-header.swig' %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body&#123;%- if page.direction and page.direction.toLowerCase() === 'rtl' %&#125; rtl&#123;%- endif %&#125;"</span>&gt;</span></span><br><span class="line">                &#123;% if config.album %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"album-wrapper row"</span>&gt;</span></span><br><span class="line">                    &#123;% for gallery in config.album %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"gallery-box"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"./&#123;&#123; gallery.name &#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"gallery-item"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"gallery-cover-box"</span> <span class="attr">style</span>=<span class="string">"background-image: url(&#123;&#123; gallery.imageBed &#125;&#125;/&#123;&#123; gallery.name &#125;&#125;/artwork/&#123;&#123; gallery.cover &#125;&#125;);"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"gallery-name"</span>&gt;</span></span><br><span class="line">                                &#123;&#123; gallery.name &#125;&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"gallery-description"</span>&gt;</span></span><br><span class="line">                            &#123;&#123; gallery.description &#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    &#123;% endfor %&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% include '_partials/page/breadcrumb.swig' %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(true) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>在渲染的时候，我们需要用到站点配置文件中的一些参数。比如到底有多少相册，每个相册的名字是什么，封面的图片是什么，相册的描述怎样。这里需要在站点配置文件中添加如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">album:</span></span><br><span class="line">  <span class="attr">imageBed:</span> <span class="string">https://xxx.s3-ap-southeast-1.amazonaws.com/album</span></span><br><span class="line">  <span class="attr">gallery:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'Period'</span></span><br><span class="line">      <span class="attr">cover:</span> <span class="string">'2019-09-12-flash.jpg'</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">'时间'</span></span><br><span class="line">      <span class="attr">created:</span> <span class="string">'2018-07-23'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'Cosmos'</span></span><br><span class="line">      <span class="attr">cover:</span> <span class="string">'2019-11-29-yuki.jpg'</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">'秩序'</span></span><br><span class="line">      <span class="attr">created:</span> <span class="string">'2018-07-23'</span></span><br></pre></td></tr></table></figure>
<p>对于Album页面，这里只是生成了html页面，你可以根据css来定制对应的样式。这里我的css数据放在了<code>blog/souce/_data/styles.styl</code>中，这里放置了我所有的自定义的样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.gallery-wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery-wrapper</span> <span class="selector-class">.gallery-box</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.gallery-wrapper</span> <span class="selector-class">.gallery-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.22</span>);</span><br><span class="line">  <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.22</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.22</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.gallery-cover-box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background</span>: center center no-repeat;</span><br><span class="line">  <span class="attribute">-webkit-background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.gallery-cover-box</span> <span class="selector-class">.gallery-cover-img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery-item</span> <span class="selector-class">.gallery-name</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这些模板之后，只需要在<code>blog/souce</code>目录下创建album目录，在目录下创建对应的index.md即可</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 相册</span><br><span class="line">layout: "album"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="二级相册-Gallery"><a href="#二级相册-Gallery" class="headerlink" title="二级相册 Gallery"></a>二级相册 Gallery</h3><p>可以看到，在Album页面，每一个二级相册Gallery都可以通过点击封面作为一个链接访问。访问请求是<code>/album/&lt;gallery-name&gt;</code>。</p>
<h4 id="Gallery页面描述文件"><a href="#Gallery页面描述文件" class="headerlink" title="Gallery页面描述文件"></a>Gallery页面描述文件</h4><p>因此，我们在Album目录下，为每一个Gallery创建子目录，比如这里的<code>Period</code> 和 <code>Cosmos</code> 。类似的我们为gallery创建了一个渲染模板，在Period目录下，我们只需要有对应的 <code>index.md</code> 和 描述gallery的JSON文件即可。</p>
<figure class="highlight markdown"><figcaption><span>index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: gallery</span><br><span class="line">title: Period</span><br><span class="line">galleryName: Period</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>下面是描述相册的JSON文件，你可以通过Python脚本自动生成和更新。</p>
<figure class="highlight json"><figcaption><span>data</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Period"</span>,</span><br><span class="line">    <span class="attr">"cover"</span>: <span class="string">"2019-09-12_flash.jpg"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"时光"</span>,</span><br><span class="line">    <span class="attr">"created"</span>: <span class="string">"2019-07-23"</span>,</span><br><span class="line">    <span class="attr">"imageBed"</span>: <span class="string">"https://xxx.s3-ap-southeast-1.amazonaws.com/album"</span>,</span><br><span class="line">    <span class="attr">"items"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"date"</span>: <span class="string">"2019-11"</span>,</span><br><span class="line">            <span class="attr">"year"</span>: <span class="number">2019</span>,</span><br><span class="line">            <span class="attr">"month"</span>: <span class="number">11</span>,</span><br><span class="line">            <span class="attr">"images"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"2019-11-10_博雅塔.jpg"</span>,</span><br><span class="line">                    <span class="attr">"caption"</span>: <span class="string">"晚秋的博雅塔"</span>,</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"image"</span>,</span><br><span class="line">                    <span class="attr">"date"</span>: <span class="string">"2019-11-10"</span>,</span><br><span class="line">                    <span class="attr">"width"</span>: <span class="number">6400</span>,</span><br><span class="line">                    <span class="attr">"height"</span>: <span class="number">4000</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"2019-11-10_狗狗.jpg"</span>,</span><br><span class="line">                    <span class="attr">"caption"</span>: <span class="string">"二体旁边晒太阳的狗狗"</span>,</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"image"</span>,</span><br><span class="line">                    <span class="attr">"date"</span>: <span class="string">"2019-11-10"</span>,</span><br><span class="line">                    <span class="attr">"width"</span>: <span class="number">6400</span>,</span><br><span class="line">                    <span class="attr">"height"</span>: <span class="number">4000</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"date"</span>: <span class="string">"2019-09"</span>,</span><br><span class="line">            <span class="attr">"year"</span>: <span class="number">2019</span>,</span><br><span class="line">            <span class="attr">"month"</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="attr">"images"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"2019-09-12_车流.jpg"</span>,</span><br><span class="line">                    <span class="attr">"caption"</span>: <span class="string">"第一次拍车流"</span>,</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"image"</span>,</span><br><span class="line">                    <span class="attr">"date"</span>: <span class="string">"2019-09-12"</span>,</span><br><span class="line">                    <span class="attr">"width"</span>: <span class="number">6400</span>,</span><br><span class="line">                    <span class="attr">"height"</span>: <span class="number">4000</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gallery页面样式"><a href="#Gallery页面样式" class="headerlink" title="Gallery页面样式"></a>Gallery页面样式</h4><p>接下来是layout下面的<code>gallery.swig</code>文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends '_layout.swig' %&#125;</span><br><span class="line">&#123;% import '_macro/sidebar.swig' as sidebar_template with context %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;&#123; page.title &#125;&#125; | &#123;&#123; title &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-block"</span> <span class="attr">lang</span>=<span class="string">"&#123;&#123; page.lang or page.language or config.language &#125;&#125;"</span>&gt;</span></span><br><span class="line">            &#123;% include '_partials/page/page-header.swig' %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body&#123;%- if page.direction and page.direction.toLowerCase() === 'rtl' %&#125; rtl&#123;%- endif %&#125;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/lib/album/gallery.css"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/lib/album/photoswipe.css"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/lib/album/default-skin/default-skin.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"gallery-description"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"gallery-description"</span>&gt;</span>这里是相册描述<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"instagram itemscope"</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://houmin.cc"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">class</span>=<span class="string">"open-ins"</span>&gt;</span>图片正在加载中…<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">                  (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> loadScript = <span class="function"><span class="keyword">function</span><span class="params">(path)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                      <span class="keyword">var</span> $script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span></span><br><span class="line"><span class="javascript">                      <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild($script)</span></span><br><span class="line"><span class="actionscript">                      $script.setAttribute(<span class="string">'src'</span>, path)</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="actionscript">                    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                        loadScript(<span class="string">'/lib/album/gallery.js'</span>)</span></span><br><span class="line">                    &#125;, 0)</span><br><span class="line">                  &#125;)()</span><br><span class="line">                <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% include '_partials/page/breadcrumb.swig' %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(true) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>其实到这一步已经和 <a href="https://cherryzzangg.site/2019/02/10/%20HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">HEXO博客搭建相册</a> 里面说的很像了。只是我把这些给模板化了，同时修改了JSON文件的数据格式。</p>
<h4 id="Gallery页面JS脚本"><a href="#Gallery页面JS脚本" class="headerlink" title="Gallery页面JS脚本"></a>Gallery页面JS脚本</h4><p>然后接下来就是修改<code>gallery.js</code>了，不知道写前端的人代码风格怎么样，原来的<code>gallery.js</code>（也就是之前教程里面的<code>ins.js</code>）代码让我看起来感觉不是很清晰。原来相关代码比较长，也不是原生手写的代码，而是通过<code>webpack</code>自动打包生成的代码。因此学习了一下前端技术中的<code>webpack</code>，下面具体梳理一下相关脚本的逻辑思路。</p>
<h5 id="webpack打包环境"><a href="#webpack打包环境" class="headerlink" title="webpack打包环境"></a>webpack打包环境</h5><p>关于webpack，可以参考教程</p>
<ul>
<li><a href="http://echizen.github.io/tech/2019/03-17-webpack-bundle-code" target="_blank" rel="external nofollow noopener noreferrer">webpack-打包后代码分析</a></li>
<li><a href="https://segmentfault.com/a/1190000006178770" target="_blank" rel="external nofollow noopener noreferrer">入门 Webpack，看这篇就够了</a></li>
<li><a href="https://segmentfault.com/a/1190000013052777" target="_blank" rel="external nofollow noopener noreferrer">一步一步教你webpack打包</a></li>
</ul>
<p>主机系统上安装的webpack版本是4.41.2，关于文件组织结构如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">╭─ houmin@cosmos   ~/blog/album_script     master</span><br><span class="line">╰─ tree</span><br><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   └── gallery.js</span><br><span class="line">├── src</span><br><span class="line">│   ├── gallery.js</span><br><span class="line">│   └── photoswipe.js</span><br><span class="line">└── webpack.config.js</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>其中，<code>webpack.config.js</code>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// mode: "development",</span></span><br><span class="line">    mode: <span class="string">"production"</span>,</span><br><span class="line">    entry: <span class="string">"./src/gallery.js"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"gallery.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimize: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，webpack的大包入口文件是<code>gallery.js</code></p>
<h5 id="gallery文件"><a href="#gallery文件" class="headerlink" title="gallery文件"></a>gallery文件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'lazyloadjs'</span>);</span><br><span class="line"><span class="keyword">var</span> photoswipe = <span class="built_in">require</span>(<span class="string">"./photoswipe.js"</span>);</span><br><span class="line"><span class="keyword">var</span> view = _interopRequireDefault(photoswipe.viewer);</span><br><span class="line"><span class="keyword">var</span> galleryPath = <span class="built_in">window</span>.location.pathname;</span><br><span class="line"><span class="keyword">var</span> galleryName = galleryPath.split(<span class="string">"/"</span>)[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> dataUrl = <span class="string">'/album/'</span> + galleryName + <span class="string">'/data'</span>;</span><br><span class="line"><span class="keyword">var</span> dataJSON;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123;</span><br><span class="line">        <span class="keyword">default</span>: obj</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> meta = response[<span class="string">"meta"</span>];</span><br><span class="line">    <span class="keyword">var</span> data = response[<span class="string">"data"</span>];</span><br><span class="line">    <span class="keyword">var</span> imageBed = meta[<span class="string">"imageBed"</span>];</span><br><span class="line">    <span class="keyword">var</span> description = meta[<span class="string">"description"</span>];</span><br><span class="line">    <span class="keyword">var</span> ulTmpl = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">var</span> liTmpl = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> item = data[i];</span><br><span class="line">        <span class="keyword">var</span> date = item[<span class="string">"date"</span>];</span><br><span class="line">        <span class="keyword">var</span> year = date.substring(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">var</span> month = date.substring(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j <span class="keyword">in</span> item[<span class="string">"images"</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> image = item[<span class="string">"images"</span>][j];</span><br><span class="line">            <span class="keyword">var</span> thumbnail = imageBed + <span class="string">'/'</span> + galleryName + <span class="string">"/thumbnail/"</span> + image.name;</span><br><span class="line">            <span class="keyword">var</span> artwork = imageBed + <span class="string">'/'</span> + galleryName + <span class="string">"/artwork/"</span> + image.name;</span><br><span class="line">            <span class="keyword">var</span> caption = image.caption;</span><br><span class="line">            <span class="keyword">var</span> width = image.width;</span><br><span class="line">            <span class="keyword">var</span> height = image.height;</span><br><span class="line"></span><br><span class="line">            liTmpl += <span class="string">`&lt;figure class="thumb" itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject"&gt;</span></span><br><span class="line"><span class="string">                        &lt;a href="<span class="subst">$&#123;artwork&#125;</span>" itemprop="contentUrl" data-size="<span class="subst">$&#123;width&#125;</span>x<span class="subst">$&#123;height&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">                            &lt;img class="reward-img" data-src="<span class="subst">$&#123;thumbnail&#125;</span>" src="/lib/album/assets/empty.png" itemprop="thumbnail" onload="lzld(this)"&gt;</span></span><br><span class="line"><span class="string">                        &lt;/a&gt;</span></span><br><span class="line"><span class="string">                        &lt;figcaption style="display:none" itemprop="caption description"&gt;<span class="subst">$&#123;caption&#125;</span>&lt;/figcaption&gt;</span></span><br><span class="line"><span class="string">                      &lt;/figure&gt;`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ulTmpl += <span class="string">`&lt;section class="archives album"&gt;&lt;h1 class="timeline"&gt;<span class="subst">$&#123;year&#125;</span>年<span class="subst">$&#123;month&#125;</span>月&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                    &lt;ul class="img-box-ul"&gt;<span class="subst">$&#123;liTmpl&#125;</span>&lt;/ul&gt;</span></span><br><span class="line"><span class="string">                  &lt;/section&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'.instagram'</span>).innerHTML = <span class="string">`&lt;div class=<span class="subst">$&#123;photoswipe.galleryClass&#125;</span> itemscope="" itemtype="http://schema.org/ImageGallery"&gt;<span class="subst">$&#123;ulTmpl&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#gallery-description'</span>).innerHTML = description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// createVideoIcon();</span></span><br><span class="line">    view.default.init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params">render</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dataJSON) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, dataUrl + <span class="string">'?t='</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="literal">true</span>);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                dataJSON = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response);</span><br><span class="line">                render(dataJSON);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      render(dataJSON);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Gallery = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        loadData(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            render(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Gallery.init();</span><br></pre></td></tr></table></figure>
<p>可以看到，这里的<code>gallery.js</code>依赖了 <code>lazyloadjs</code> 和 <code>photoswipe.js</code>, 整个文件的思路非常直接</p>
<ul>
<li>初始化<code>Gallery</code>对象，它会在初始化的时候通过XHR请求打开对应Gallery的JSON描述文件</li>
<li>获取JSON文件的响应后，通过render函数来解析JSON数据，从而拼接处对应的HTML文本</li>
<li>这里具体的相册名是通过解析访问的链接名得到的 <code>window.location.pathname</code></li>
<li>为了能够使用 <code>photoswipe</code> 插件，我们需要在render函数中讲 <code>view</code> 对象初始化</li>
</ul>
<p>关于 <code>lazyloadjs</code> 插件的使用，可以参考 <a href="https://github.com/vvo/lazyload" target="_blank" rel="external nofollow noopener noreferrer">其GitHub说明文档</a></p>
<h5 id="photoswipe文件"><a href="#photoswipe文件" class="headerlink" title="photoswipe文件"></a>photoswipe文件</h5><p>这里的 <code>photoswipe.js</code> 主要参考了photoswipe官方文档的 <a href="https://photoswipe.com/documentation/getting-started.html" target="_blank" rel="external nofollow noopener noreferrer">How to build an array of slides from a list of links</a> 部分。</p>
<p>主要的思想就是，根据上面 <code>gallery.js</code> 中生成的链接的list，利用photoswipe生成对应的photoswipe对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initPhotoSwipeFromDOM = <span class="function"><span class="keyword">function</span>(<span class="params">gallerySelector</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse slide data (url, title, size ...) from DOM elements</span></span><br><span class="line">    <span class="comment">// (children of gallerySelector)</span></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">    <span class="comment">// [</span></span><br><span class="line">    <span class="comment">//  &#123;</span></span><br><span class="line">    <span class="comment">//      src: "http://imageBed/artwork/src.jpg",</span></span><br><span class="line">    <span class="comment">//      msrc: "http://imageBed/thumbnail/src.jpg",</span></span><br><span class="line">    <span class="comment">//      w: 600,</span></span><br><span class="line">    <span class="comment">//      h: 400,</span></span><br><span class="line">    <span class="comment">//      title: "这是caption",</span></span><br><span class="line">    <span class="comment">//  &#125;,</span></span><br><span class="line">    <span class="comment">// ]</span></span><br><span class="line">    <span class="keyword">var</span> parseThumbnailElements = <span class="function"><span class="keyword">function</span> <span class="title">parseThumbnailElements</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        el = el.parentNode.parentNode;</span><br><span class="line">        <span class="keyword">var</span> thumbElements = el.getElementsByClassName(<span class="string">'thumb'</span>),</span><br><span class="line">            numNodes = thumbElements.length,</span><br><span class="line">            items = [],</span><br><span class="line">            figureEl,</span><br><span class="line">            linkEl,</span><br><span class="line">            size,</span><br><span class="line">            item;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            figureEl = thumbElements[i]; <span class="comment">// &lt;figure&gt; element</span></span><br><span class="line">            <span class="comment">// include only element nodes</span></span><br><span class="line">            <span class="keyword">if</span> (figureEl.nodeType !== <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            linkEl = figureEl.children[<span class="number">0</span>]; <span class="comment">// &lt;a&gt; element</span></span><br><span class="line">            size = linkEl.getAttribute(<span class="string">'data-size'</span>).split(<span class="string">'x'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create slide object</span></span><br><span class="line">            item = &#123;</span><br><span class="line">                src: linkEl.getAttribute(<span class="string">'href'</span>),</span><br><span class="line">                w: <span class="built_in">parseInt</span>(size[<span class="number">0</span>], <span class="number">10</span>),</span><br><span class="line">                h: <span class="built_in">parseInt</span>(size[<span class="number">1</span>], <span class="number">10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (figureEl.children.length &gt; <span class="number">1</span>) &#123; <span class="comment">// &lt;figcaption&gt; content</span></span><br><span class="line">                item.title = figureEl.children[<span class="number">1</span>].innerHTML;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (linkEl.children.length &gt; <span class="number">0</span>) &#123; <span class="comment">// &lt;img&gt; thumbnail element, retrieving thumbnail url</span></span><br><span class="line">                item.msrc = linkEl.children[<span class="number">0</span>].getAttribute(<span class="string">'src'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            item.el = figureEl; <span class="comment">// save link to element for getThumbBoundsFn</span></span><br><span class="line">            items.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find nearest parent element</span></span><br><span class="line">    <span class="keyword">var</span> closest = <span class="function"><span class="keyword">function</span> <span class="title">closest</span>(<span class="params">el, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> el &amp;&amp; (fn(el) ? el : closest(el.parentNode, fn));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triggers when user clicks on thumbnail</span></span><br><span class="line">    <span class="keyword">var</span> onThumbnailsClick = <span class="function"><span class="keyword">function</span> <span class="title">onThumbnailsClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e = e || <span class="built_in">window</span>.event;</span><br><span class="line">        e.preventDefault ? e.preventDefault() : e.returnValue = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> eTarget = e.target || e.srcElement;</span><br><span class="line">        <span class="comment">// find root element of slide</span></span><br><span class="line">        <span class="keyword">var</span> clickedListItem = closest(eTarget, <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> el.tagName &amp;&amp; el.tagName.toUpperCase() === <span class="string">'FIGURE'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!clickedListItem) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find index of clicked item by looping through all child nodes</span></span><br><span class="line">        <span class="comment">// alternatively, you may define index via data- attribute</span></span><br><span class="line">        <span class="keyword">var</span> clickedGallery = clickedListItem.parentNode,</span><br><span class="line">            childNodes = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'thumb'</span>),</span><br><span class="line">            numChildNodes = childNodes.length,</span><br><span class="line">            nodeIndex = <span class="number">0</span>,</span><br><span class="line">            index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numChildNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childNodes[i].nodeType !== <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (childNodes[i] === clickedListItem) &#123;</span><br><span class="line">                index = nodeIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// open PhotoSwipe if valid index found</span></span><br><span class="line">            openPhotoSwipe(index, clickedGallery);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse picture index and gallery index from URL (#&amp;pid=1&amp;gid=2)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">photoswipeParseHash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash.substring(<span class="number">1</span>),</span><br><span class="line">        params = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (hash.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> params;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> vars = hash.split(<span class="string">'&amp;'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vars[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> pair = vars[i].split(<span class="string">'='</span>);</span><br><span class="line">            <span class="keyword">if</span> (pair.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            params[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (params.gid) &#123;</span><br><span class="line">            params.gid = <span class="built_in">parseInt</span>(params.gid, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">openPhotoSwipe</span>(<span class="params">index, galleryElement, disableAnimation, fromURL</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pswpElement = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.pswp'</span>)[<span class="number">0</span>],</span><br><span class="line">            gallery,</span><br><span class="line">            options,</span><br><span class="line">            items;</span><br><span class="line"></span><br><span class="line">        items = parseThumbnailElements(galleryElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define options (if needed)</span></span><br><span class="line">        options = &#123;</span><br><span class="line">            <span class="comment">// define gallery index (for URL)</span></span><br><span class="line">            galleryUID: galleryElement.getAttribute(<span class="string">'data-pswp-uid'</span>),</span><br><span class="line">            getThumbBoundsFn: <span class="function"><span class="keyword">function</span> <span class="title">getThumbBoundsFn</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// See Options -&gt; getThumbBoundsFn section of documentation for more info</span></span><br><span class="line">                <span class="keyword">var</span> thumbnail = items[index].el.getElementsByTagName(<span class="string">'img'</span>)[<span class="number">0</span>],</span><br><span class="line">                <span class="comment">// find thumbnail</span></span><br><span class="line">                pageYScroll = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop,</span><br><span class="line">                rect = thumbnail.getBoundingClientRect();</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    x: rect.left,</span><br><span class="line">                    y: rect.top + pageYScroll,</span><br><span class="line">                    w: rect.width</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PhotoSwipe opened from URL</span></span><br><span class="line">        <span class="keyword">if</span> (fromURL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.galleryPIDs) &#123;</span><br><span class="line">                <span class="comment">// parse real index when custom PIDs are used</span></span><br><span class="line">                <span class="comment">// http://photoswipe.com/documentation/faq.html#custom-pid-in-url</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; items.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (items[j].pid == index) &#123;</span><br><span class="line">                        options.index = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// in URL indexes start from 1</span></span><br><span class="line">                options.index = <span class="built_in">parseInt</span>(index, <span class="number">10</span>) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            options.index = <span class="built_in">parseInt</span>(index, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit if index not found</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(options.index)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disableAnimation) &#123;</span><br><span class="line">            options.showAnimationDuration = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Pass data to PhotoSwipe and initialize it</span></span><br><span class="line">        <span class="keyword">var</span> gallery = <span class="keyword">new</span> PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);</span><br><span class="line">        gallery.init();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through all gallery elements and bind events</span></span><br><span class="line">    <span class="keyword">var</span> galleryElements = <span class="built_in">document</span>.querySelectorAll(gallerySelector);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = galleryElements.length; i &lt; l; i++) &#123;</span><br><span class="line">        galleryElements[i].setAttribute(<span class="string">'data-pswp-uid'</span>, i + <span class="number">1</span>);</span><br><span class="line">        galleryElements[i].onclick = onThumbnailsClick;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Parse URL and open gallery if it contains #&amp;pid=3&amp;gid=1</span></span><br><span class="line">    <span class="keyword">var</span> hashData = photoswipeParseHash();</span><br><span class="line">    <span class="keyword">if</span> (hashData.pid &amp;&amp; hashData.gid) &#123;</span><br><span class="line">        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - <span class="number">1</span>], <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> galleryClass = <span class="string">"photos"</span>;</span><br><span class="line"><span class="keyword">var</span> selector = <span class="string">'.'</span> + galleryClass;</span><br><span class="line"><span class="keyword">var</span> viewer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        initPhotoSwipeFromDOM(selector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: init</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    galleryClass,</span><br><span class="line">    viewer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="自动化更新JSON脚本"><a href="#自动化更新JSON脚本" class="headerlink" title="自动化更新JSON脚本"></a>自动化更新JSON脚本</h3><p>这里补上了自动化上传图片的脚本。脚本的功能如下</p>
<ul>
<li>创建相册</li>
<li>插入图片<ul>
<li>裁剪图片</li>
<li>压缩图片</li>
<li>更新JSON脚本</li>
<li>上传图片到AWS的S3服务</li>
</ul>
</li>
</ul>
<p>实现的原理很简单，由<code>AlbumTool.py</code>和<code>S3.py</code>组成。这两个文件放在<code>hexo/album_tool</code>目录下，在同级路径还有一个<code>album</code>的文件夹，针对不同的相册，都有<code>artwork</code>、<code>square</code>和<code>thumbnail</code>三个文件夹。用户需要上传图片时，只需要将对应的图片放到<code>artwork</code>路径下，然后运行<code>python AlbumTool.py -a insert</code>就可以了，之后可以按照命令行的提示执行即可。</p>
<figure class="highlight python"><figcaption><span>AlbumTool.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> S3 <span class="keyword">import</span> S3Tool</span><br><span class="line"></span><br><span class="line">bucket = <span class="string">"xxx"</span></span><br><span class="line">imageBed = <span class="string">"https://xxx.s3-ap-southeast-1.amazonaws.com/album"</span></span><br><span class="line">indexTmpl = <span class="string">"""</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">layout: gallery</span></span><br><span class="line"><span class="string">title: &#123;0&#125;</span></span><br><span class="line"><span class="string">galleryName: &#123;0&#125;</span></span><br><span class="line"><span class="string">comments: false</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlbumTool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, bucket, gallery)</span>:</span></span><br><span class="line">        self.s3 = S3Tool(bucket)</span><br><span class="line">        self.scale = <span class="number">4</span></span><br><span class="line">        self.gallery = gallery</span><br><span class="line">        self.galleryPath = <span class="string">"album/"</span> + gallery</span><br><span class="line">        self.artwork = self.galleryPath + <span class="string">"/artwork/"</span></span><br><span class="line">        self.square = self.galleryPath + <span class="string">"/square/"</span></span><br><span class="line">        self.thumbnail = self.galleryPath + <span class="string">"/thumbnail/"</span></span><br><span class="line">        self.data_json = self.galleryPath + <span class="string">"/data.json"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut_by_ratio</span><span class="params">(self, infile, outfile)</span>:</span></span><br><span class="line">            <span class="string">"""按照图片长宽进行分割</span></span><br><span class="line"><span class="string">            取中间的部分，裁剪成正方形</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            im = Image.open(infile)</span><br><span class="line">            (w, h) = im.size</span><br><span class="line">            region = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> w &lt; h:</span><br><span class="line">                w, h = h, w</span><br><span class="line">            region = (int(w-h)/<span class="number">2</span>, <span class="number">0</span>, int(w+h)/<span class="number">2</span>, h)</span><br><span class="line">            crop_img = im.crop(region)</span><br><span class="line">            crop_img.save(outfile)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cut</span><span class="params">(self, image)</span>:</span></span><br><span class="line">        <span class="string">"""裁剪图片，将图片裁成正方形"""</span></span><br><span class="line">        print(<span class="string">"Cutting the artwork image to square..."</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.square):</span><br><span class="line">            os.makedirs(self.square)</span><br><span class="line">        self.cut_by_ratio(self.artwork+image, self.square+image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(self, image)</span>:</span></span><br><span class="line">        <span class="string">"""调用压缩图片的函数"""</span></span><br><span class="line">        print(<span class="string">"Compressing the square image to thumbnail..."</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.thumbnail):</span><br><span class="line">            os.makedirs(self.thumbnail)</span><br><span class="line">        img = Image.open(self.square + image)</span><br><span class="line">        w, h = img.size</span><br><span class="line">        w, h = int(w/self.scale), int(h/self.scale)</span><br><span class="line">        img.thumbnail((w, h))</span><br><span class="line">        img.save(self.thumbnail + image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe</span><span class="params">(self, image, caption)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        根据当前传入的相册名，图片，描述更新相册的描述JSON文件</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 根据image和caption信息，生成关于image的新dict</span></span><br><span class="line">        print(<span class="string">"Updating the data json file..."</span>)</span><br><span class="line">        img_info = Image.open(self.artwork + image)</span><br><span class="line">        width, height = img_info.size</span><br><span class="line">        image_dict = &#123;</span><br><span class="line">            <span class="string">"name"</span>: image,</span><br><span class="line">            <span class="string">"caption"</span>: caption,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"image"</span>,</span><br><span class="line">            <span class="string">"date"</span>: image[:<span class="number">10</span>],</span><br><span class="line">            <span class="string">"width"</span>: width,</span><br><span class="line">            <span class="string">"height"</span>: height</span><br><span class="line">        &#125;</span><br><span class="line">        item_dict = &#123;</span><br><span class="line">            <span class="string">"date"</span>: image[:<span class="number">7</span>],</span><br><span class="line">            <span class="string">"images"</span>: [</span><br><span class="line">                image_dict</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 根据相册名确定原来JSON文件的路径，读取原来的JSON文件并解析</span></span><br><span class="line">        items = []</span><br><span class="line">        images = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        current = time.strftime(<span class="string">'%Y-%m-%d %H:%M-%S'</span>, time.localtime(time.time()))</span><br><span class="line">        <span class="keyword">with</span> open(self.data_json) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line">            items =  data[<span class="string">"items"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据当前的文件名，命名为yyyy-mm-dd_name.jpg[png][gif]</span></span><br><span class="line">        <span class="comment"># 解析出应该插入的月份，并且更新相应的list，同时加入caption</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> items:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">                <span class="keyword">if</span> item[<span class="string">"date"</span>] != image[:<span class="number">7</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                images = item[<span class="string">"images"</span>]</span><br><span class="line">                index = items.index(item)</span><br><span class="line">            <span class="keyword">if</span> images:</span><br><span class="line">                <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">                    <span class="keyword">if</span> img[<span class="string">"name"</span>] == image:</span><br><span class="line">                        print(<span class="string">"The file "</span> + image + <span class="string">" already exists"</span>)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                images.insert(<span class="number">0</span>, image_dict)</span><br><span class="line">                images.sort(key=<span class="keyword">lambda</span> image:image[<span class="string">"date"</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">                items[index][<span class="string">"images"</span>] = images</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                items.insert(<span class="number">0</span>, item_dict)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items.insert(<span class="number">0</span>, item_dict)</span><br><span class="line"></span><br><span class="line">        items.sort(key=<span class="keyword">lambda</span> item:item[<span class="string">"date"</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        data[<span class="string">"items"</span>] = items</span><br><span class="line">        data[<span class="string">"updated"</span>] = current</span><br><span class="line">        data[<span class="string">"number"</span>] = data[<span class="string">"number"</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 序列化数据结构到JSON文本</span></span><br><span class="line">        <span class="keyword">with</span> open(self.data_json, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            json.dump(data, json_file, ensure_ascii=<span class="literal">False</span>, sort_keys=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(self, image)</span>:</span></span><br><span class="line">        print(<span class="string">"Uploading the image to AWS S3 service..."</span>)</span><br><span class="line">        self.s3.upload_file(self.artwork + image)</span><br><span class="line">        self.s3.upload_file(self.thumbnail + image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(self)</span>:</span></span><br><span class="line">        os.system(<span class="string">"cp "</span> + self.data_json + <span class="string">" ../source/album/"</span> + self.gallery + <span class="string">"/data"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(self.galleryPath):</span><br><span class="line">            print(<span class="string">"Error: gallery "</span> + self.gallery + <span class="string">" already exists"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            os.makedirs(self.galleryPath)</span><br><span class="line">            os.makedirs(self.artwork)</span><br><span class="line">            os.makedirs(self.square)</span><br><span class="line">            os.makedirs(self.thumbnail)</span><br><span class="line"></span><br><span class="line">            cover = input(<span class="string">"Please input the cover image for gallery "</span> + self.gallery + <span class="string">": "</span>)</span><br><span class="line">            description = input(<span class="string">"Please input the description for the gallery "</span> + self.gallery + <span class="string">": "</span>)</span><br><span class="line">            current = time.strftime(<span class="string">'%Y-%m-%d %H:%M-%S'</span>, time.localtime(time.time()))</span><br><span class="line">            data_dict = &#123;</span><br><span class="line">                <span class="string">"name"</span>: self.gallery,</span><br><span class="line">                <span class="string">"cover"</span>: cover,</span><br><span class="line">                <span class="string">"description"</span>: description,</span><br><span class="line">                <span class="string">"created"</span>: current,</span><br><span class="line">                <span class="string">"updated"</span>: current,</span><br><span class="line">                <span class="string">"imageBed"</span>: imageBed,</span><br><span class="line">                <span class="string">"number"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">"items"</span>: []</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">with</span> open(self.data_json, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">                json.dump(data_dict, json_file, ensure_ascii=<span class="literal">False</span>, sort_keys=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            os.makedirs(<span class="string">"../source/album/"</span> + self.gallery)</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"../source/album/"</span> + self.gallery + <span class="string">"/index.md"</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(indexTmpl.format(self.gallery, self.gallery))</span><br><span class="line">                self.sync()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self)</span>:</span></span><br><span class="line">        image = input(<span class="string">"Please input the image file name: "</span>)</span><br><span class="line">        caption = input(<span class="string">"Please input the caption for the image: "</span>)</span><br><span class="line">        self.cut(image)</span><br><span class="line">        self.compress(image)</span><br><span class="line">        self.describe(image, caption)</span><br><span class="line">        self.upload(image)</span><br><span class="line">        self.sync()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">"Album Tool For Hexo NexT"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-a'</span>, <span class="string">'--action'</span>, type=str, help=<span class="string">'action to be executed'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    gallery = input(<span class="string">"Please input the gallery name: "</span>)</span><br><span class="line"></span><br><span class="line">    album = AlbumTool(bucket, gallery)</span><br><span class="line">    <span class="keyword">if</span> args.action == <span class="string">"create"</span>:</span><br><span class="line">        album.create()</span><br><span class="line">    <span class="keyword">elif</span> args.action == <span class="string">"insert"</span>:</span><br><span class="line">        album.insert()</span><br></pre></td></tr></table></figure>
<p><code>S3.py</code>主要是对<code>boto3</code>进行了封装，配置好AWS的密钥信息之后，可以直接执行这个脚本。如果以后改用阿里云或者其他云服务商的对象存储服务，随之更新即可。</p>
<figure class="highlight python"><figcaption><span>S3.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">from</span> botocore.exceptions <span class="keyword">import</span> ClientError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S3Tool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, bucket)</span>:</span></span><br><span class="line">        self.s3_client = boto3.client(<span class="string">'s3'</span>)</span><br><span class="line">        self.bucket = bucket</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">(self, file_name, object_name=None)</span>:</span></span><br><span class="line">        <span class="string">"""Upload a file to an S3 bucket</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param file_name: File to upload</span></span><br><span class="line"><span class="string">        :param object_name: S3 object name. If not specified then file_name is used</span></span><br><span class="line"><span class="string">        :return: True if file was uploaded, else False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If S3 object_name was not specified, use file_name</span></span><br><span class="line">        <span class="keyword">if</span> object_name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            object_name = file_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Upload the file</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = self.s3_client.upload_file(file_name, self.bucket, object_name)</span><br><span class="line">        <span class="keyword">except</span> ClientError <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_file</span><span class="params">(self, file_name, object_name=None)</span>:</span></span><br><span class="line">        <span class="string">"""Download a file from an S3 bucket</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param file_name: File to be downloaded as</span></span><br><span class="line"><span class="string">        :param object_name: S3 object name. If not specified then file_name is used</span></span><br><span class="line"><span class="string">        :return: True if file was uploaded, else False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If S3 object_name was not specified, use file_name</span></span><br><span class="line">        <span class="keyword">if</span> object_name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            object_name = file_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Upload the file</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = self.s3_client.download_file(self.bucket, object_name, file_name)</span><br><span class="line">        <span class="keyword">except</span> ClientError <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="实际实现效果"><a href="#实际实现效果" class="headerlink" title="实际实现效果"></a>实际实现效果</h2><p>大家可以到 <a href="../../album/">我的相册 </a>页面看看的实际的效果。基本上实现了上述的要求，欢迎评论。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://cherryzzangg.site/2019/02/10/%20HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">HEXO博客搭建相册</a></li>
<li><a href="https://liyangzone.com/2019/07/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BA%A7%E5%88%86%E7%B1%BB%E7%9B%B8%E5%86%8C/" target="_blank" rel="external nofollow noopener noreferrer">hexo博客添加一级分类相册功能</a></li>
<li><a href="https://co5.me/2018/181112-gallerry2.html" target="_blank" rel="external nofollow noopener noreferrer">css+markdown 实现 hexo 相册</a></li>
<li><a href="https://asdfv1929.github.io/2018/05/26/next-add-photos/" target="_blank" rel="external nofollow noopener noreferrer">Hexo NexT主题内添加相册功能</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>相册</tag>
      </tags>
  </entry>
  <entry>
    <title>阴天快乐</title>
    <url>/posts/b4bc5563/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>Self Protection System:</p>
<ul>
<li>Nothing to expect</li>
<li>Nothing to lose</li>
</ul>
</blockquote>
<a id="more"></a>

    <div id="aplayer-tSsWsfkY" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28563317" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<p><strong>为什么人会不开心呢？</strong></p>
<p>当你有了期待，你便会失落。</p>
<p>你期待你被人欣赏；<br>你期待你有一个爱你的并且你也爱的人；<br>你期待你做出优秀的成绩…</p>
<p>你期待着，但是这些期待并不能总能得到满足。在生活中，你经常会有那么一个时刻，让你不是很开心，你会心情低落，对很多很多的事情都提不起兴趣。这个时候，怎么办呢？</p>
<p>首先，你需要明白一个残酷的现实，那就是这世上的绝大多数人都过的不是那么的开心。嘿，你去地铁看看，那么多漠然的脸，他们好像很疲惫，似乎眼神中也都没有多少光彩。</p>
<p>为什么会不开心？因为你的期待没有得到满足。更可怕的就是，人类是一个欲望永无止境的生物。你会始终有自己的期待，然而这绝大数的期待，是很有可能实现不了的。知乎不是有那句话吗？<code>「人的一切痛苦，本质上都是对自己无能的愤怒」</code>。人是一个弱小的东西，总会有一些事情是你所实现不了。</p>
<p>有一个<code>幸福跑步机</code>现象，说的就是你可能会无休止地（非常累地）去追求一些东西。而且很有可能，你这一辈子都无法追求到你想要的。在这个路途中，你可能会得到一些东西，你也必然会失去一些重要的东西（比如健康、比如时间、比如青春）。</p>
<p>那么，就这样放弃去追求了吗？</p>
<p>不，当然不能。为了减少痛苦，为了更多的开心，你需要知道你不开心的原因，你需要知道你开心的事情，你需要明晰自己对于幸福的美好愿景。其实，在曾经的一篇日记中，我对自己期待成为的样子有过感性的描述。对，感性的描述，很抽象，没有任何数据的支撑。</p>
<p>数据是一个非常客观的东西，它对于所有人都一视同仁，它会让你看到在那些岁月你的碌碌无为，也会让你看到你曾经的努力和坚持。没有数据支撑下的期待，往往会让你和你期待的轨道偏离，丧失努力的动力。数据，往往又是由一系列的指标组成，那么，对于你而言，什么才是最重要的指标呢？</p>
<p>哈佛幸福公开课老师 本－沙哈尔 坚定地认为：<strong>幸福感是衡量人生的唯一标准，是所有目标的最终目标。</strong></p>
<blockquote>
<p>人们衡量商业成就时，标准是钱。用钱去评估资产和债务、利润和亏损，所有与钱无关的都不会被考虑进去，金钱是最高的财富。但是我认为，人生与商业一样，也有盈利和亏损。具体地说，在看待自己的生命时，可以把负面情绪当作支出，把正面情绪当作收入。当正面情绪多于负面情绪时，我们在幸福这一<strong>至高财富</strong>上就盈利了。长期的抑郁，可以被看成是一种<strong>情感破产</strong>。整个社会，也有可能面临这种问题，如果个体的问题不断增长，焦虑和压力的问题越来越多，社会就正在走向幸福的<strong>大萧条</strong>。</p>
</blockquote>
<p>在他看来，人的幸福感主要取决3个因素：<code>遗传基因</code>、<code>与幸福有关的环境因素</code>以及<code>能够帮助我们获得幸福的行动</code>。<strong>幸福，是可以通过学习和练习获得的。</strong></p>
<p>好像我们讨论的话题，一下子由开心变成了幸福。虽然两者并不是完全一致的东西，但是可以拿幸福作为参考。</p>
<p>他的论点里面，<strong>幸福是快乐和意义的结合。</strong></p>
<blockquote>
<p>一个幸福的人，必须有一个明确的、可以带来快乐和意义的目标，然后努力地去追求。真正快乐的人，会在自己觉得有意义的生活方式里，享受它的点点滴滴。</p>
</blockquote>
<p>以吃汉堡为例，可以总结出四种人生模型：</p>
<ul>
<li>享乐主义型。第一种汉堡，就是他最先抓起的那只，口味诱人，但却是标准的“垃圾食品”。吃它等于是享受眼前的快乐，但同时也埋下未来的痛苦。用它比喻人生，就是及时享乐，出卖未来幸福的人生。</li>
<li>忙碌奔波型。第二种汉堡，口味很差，里边全是蔬菜和有机食物，吃了可以使人日后更健康，但会吃得很痛苦。牺牲眼前的幸福，为的是追求未来的目标。</li>
<li>虚无主义型。第三种汉堡，是最糟糕的，既不美味，吃了还会影响日后的健康。与此相似的人，对生活丧失了希望和追求，既不享受眼前的事物，也不对未来抱期许。</li>
<li>幸福型。一个幸福的人，是即能享受当下所做的事，又可以获得更美满的未来。</li>
</ul>
<p>生活中的绝大多数人，过的都是 <strong>忙碌奔波型</strong> 的人生。人们习惯性的去关注下一个目标，而常常忽略了当下的事情。</p>
<p>所以我们应该如何去生活，如何去工作呢？</p>
<blockquote>
<p>生命很短暂，在选择道路前，先确定自己能做的事。其中，做那些你想做的。然后再细化，找出你真正想做的。最后，对于那些真正、真正想做的事，付诸行动。</p>
</blockquote>
<p>你需要去想清楚这几个问题：</p>
<ul>
<li>什么带给我意义？</li>
<li>什么带给我快乐？</li>
<li>我的优势是什么？</li>
</ul>
<p>关于我对于这几个问题，在本篇文章中我可能做不出解答，我可能要用接下来的几个月，可能是接下来几年，甚至是我的一生，去回答这个问题。但是不管怎样，你需要给自己设定一些有意义的目标，然后认真的去完成他们，在这个过程中，你要去享受去体会。</p>
<blockquote>
<p>在追求有意义而又快乐的目标时，我们不再是消磨光阴，而是在让时间，闪闪发光。</p>
</blockquote>
<p>最后说一个问题，什么才称得上是一个幸福的人？是那种天天都很开心的人吗？</p>
<p>并不是的。世界上真的有天天都很开心的人吗？很难吧。</p>
<p>漫漫人生，每个人都不可避免地会面临悲伤的时刻，比如经历失败或失去，但我们依然可以活得幸福。事实上，期盼无时无刻的快乐，只会带来失望和不满，并最终导致负面情绪的产生。</p>
<blockquote>
<p>一个幸福的人，也会有情绪上的起伏，但整体上，能保持一种积极的人生态度。他经常被积极的情绪推动着，如欢乐和爱；很少被愤怒或内疚，这些负面情绪所控制。快乐是常态，而痛苦都是小插曲。</p>
</blockquote>
<p>生而为人，你会经历很多很多。<br>但是，你总可以让自己开心一点，幸福一点。</p>
<p>所以，今天晚上的思考解决了我的问题吗？没有完全解决，但是带给了我一些更加积极的观点。你永远可以变得更好一些。</p>
<hr>
<p>今日开心时刻</p>
<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/video/2019-12-02-kitty.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>快乐</tag>
        <tag>个人管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title>春游南国</title>
    <url>/posts/cf1a9e29/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>过年打算和老妈还有姐姐一起去广东转一转，这里是行程计划和安排，有待后续补充和更新。</p>
<a id="more"></a>
<h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><h3 id="广州"><a href="#广州" class="headerlink" title="广州"></a>广州</h3><ul>
<li><a href="http://www.mafengwo.cn/poi/25091.html" target="_blank" rel="external nofollow noopener noreferrer">广州塔</a> 适合下午晚上去，看日落和夜景</li>
<li><a href="http://www.mafengwo.cn/poi/443.html" target="_blank" rel="external nofollow noopener noreferrer">沙面岛</a> 广州重要商埠，为英法租界</li>
<li><a href="http://www.mafengwo.cn/poi/443.html" target="_blank" rel="external nofollow noopener noreferrer">陈家祠</a> 现存规模最大的清代宗祠建筑</li>
<li><a href="http://www.mafengwo.cn/poi/441.html" target="_blank" rel="external nofollow noopener noreferrer">越秀公园</a> 在陈家祠附近</li>
<li><a href="http://www.mafengwo.cn/poi/466.html" target="_blank" rel="external nofollow noopener noreferrer">白云山</a></li>
<li><a href="http://www.mafengwo.cn/poi/469.html" target="_blank" rel="external nofollow noopener noreferrer">石室圣心大教堂</a></li>
</ul>
<h3 id="珠海"><a href="#珠海" class="headerlink" title="珠海"></a>珠海</h3><ul>
<li><a href="http://www.mafengwo.cn/poi/2450.html" target="_blank" rel="external nofollow noopener noreferrer">情侣路</a></li>
<li><a href="http://www.mafengwo.cn/poi/2452.html" target="_blank" rel="external nofollow noopener noreferrer">外伶仃岛</a></li>
<li><a href="http://www.mafengwo.cn/poi/33569496.html" target="_blank" rel="external nofollow noopener noreferrer">港珠澳跨海大桥</a></li>
</ul>
<h3 id="深圳"><a href="#深圳" class="headerlink" title="深圳"></a>深圳</h3><ul>
<li><a href="http://www.mafengwo.cn/poi/5238778.html" target="_blank" rel="external nofollow noopener noreferrer">深圳湾公园</a> 可以看鸟，参考<a href="http://www.mafengwo.cn/gonglve/ziyouxing/246277.html" target="_blank" rel="external nofollow noopener noreferrer">游记</a></li>
<li><a href="http://www.mafengwo.cn/i/16587318.html" target="_blank" rel="external nofollow noopener noreferrer">深圳湾万象城</a> 购物/美食，看夜景</li>
<li><a href>西湾红树林湿地公园</a> 看日落</li>
<li><a href="http://www.mafengwo.cn/i/11926854.html" target="_blank" rel="external nofollow noopener noreferrer">深圳大学</a> 拍照</li>
<li><a href="http://www.mafengwo.cn/poi/2315.html" target="_blank" rel="external nofollow noopener noreferrer">观澜版画村</a> 可以看油菜花</li>
</ul>
<h2 id="关于吃"><a href="#关于吃" class="headerlink" title="关于吃"></a>关于吃</h2><p>早茶</p>
<h3 id="多宝路一带"><a href="#多宝路一带" class="headerlink" title="多宝路一带"></a>多宝路一带</h3><ul>
<li>日月年小食店(大牛丸粉)<ul>
<li>手打牛丸</li>
</ul>
</li>
<li>丽的面家<ul>
<li>云吞面</li>
</ul>
</li>
<li>开记甜品<ul>
<li>糖水</li>
<li>香草绿豆沙</li>
</ul>
</li>
<li>坚记面店</li>
<li>宝华面店(垃圾，不去)</li>
<li>顺记冰室</li>
<li>陈添记</li>
</ul>
<h3 id="西华路、文明路、德政路"><a href="#西华路、文明路、德政路" class="headerlink" title="西华路、文明路、德政路"></a>西华路、文明路、德政路</h3><ul>
<li>珍珍小食店(西华路店)<ul>
<li>牛腩啫啫珍珠粉</li>
</ul>
</li>
<li>沙湾甜品店(西华路店)<ul>
<li>凤凰奶糊</li>
<li>杏仁奶糊</li>
</ul>
</li>
<li>荣生集北水蛇粥(光孝路店) - 饭点人很多<ul>
<li>水蛇粥</li>
<li>煎鱼饼</li>
<li>鱼皮</li>
</ul>
</li>
<li>富临食府(惠福东路店)<ul>
<li>脆皮猪手</li>
</ul>
</li>
<li>美荣粉店<ul>
<li>炒米粉</li>
</ul>
</li>
<li>陶园美食<ul>
<li>煲仔饭</li>
</ul>
</li>
</ul>
<h2 id="具体安排"><a href="#具体安排" class="headerlink" title="具体安排"></a>具体安排</h2><h3 id="第一天-2020-01-21-腊月廿七"><a href="#第一天-2020-01-21-腊月廿七" class="headerlink" title="第一天 2020-01-21 腊月廿七"></a>第一天 2020-01-21 腊月廿七</h3><p>上午从家里出发，乘坐高铁 G93 从 武汉站 到达 广州南，历时近 4 个小时</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">G93 武汉 - 广州南 <span class="number">09</span>:<span class="number">58</span> - <span class="number">13</span>:<span class="number">50</span> 历时 <span class="number">03</span>:<span class="number">52</span> 票价 <span class="number">463.5</span> * <span class="number">3</span> = <span class="number">1390.5</span></span><br></pre></td></tr></table></figure>
<p>到达广州南车站已经是下午 2 点了，直接去酒店，然后休息一下午，晚上出来转转的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">定的酒店是 广州悦享家公寓</span><br><span class="line"></span><br><span class="line">城景双人床 <span class="number">191</span> RMB</span><br></pre></td></tr></table></figure>
<p>到晚上再回酒店休息。</p>
<h3 id="第二天-2020-01-22-腊月廿八"><a href="#第二天-2020-01-22-腊月廿八" class="headerlink" title="第二天 2020-01-22 腊月廿八"></a>第二天 2020-01-22 腊月廿八</h3><p>上午乘坐从 广州南 到 珠海，历时 1 个小时</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">D7157 广州南 - 珠海 <span class="number">8</span>:<span class="number">56</span> - <span class="number">09</span>:<span class="number">57</span> 历时 <span class="number">00</span>:<span class="number">59</span> 票价 <span class="number">70</span> * <span class="number">3</span> = <span class="number">210</span></span><br></pre></td></tr></table></figure>
<p>乘坐 11 路车 从珠海站到香洲港，历时 1 个小时</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">香洲港 - 外伶仃岛 <span class="number">11</span>:<span class="number">50</span> - <span class="number">13</span>:<span class="number">00</span> 历时 <span class="number">1</span> 小时 <span class="number">10</span> 分钟 票价 <span class="number">120</span> * <span class="number">3</span> = <span class="number">360</span></span><br></pre></td></tr></table></figure>
<p>先去找地方吃饭，吃完饭直奔岛上酒店 </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">岛上酒店 蔚蓝美域客栈海景双床房 RMB <span class="number">259</span></span><br></pre></td></tr></table></figure>
<p>下午在岛上转</p>
<h3 id="第三天-2020-01-23-腊月廿九"><a href="#第三天-2020-01-23-腊月廿九" class="headerlink" title="第三天 2020-01-23 腊月廿九"></a>第三天 2020-01-23 腊月廿九</h3><p>上午在岛上转，吃完午饭后</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">外伶仃岛 - 蛇口 <span class="number">11</span>:<span class="number">50</span> - <span class="number">13</span>:<span class="number">20</span> 历时 <span class="number">1</span> 小时 <span class="number">30</span> 分钟 票价 <span class="number">160</span> * <span class="number">3</span> = <span class="number">480</span></span><br></pre></td></tr></table></figure>
<p>然后直奔酒店 回酒店休息</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">深圳华里酒店 RMB <span class="number">369</span></span><br></pre></td></tr></table></figure>
<p>晚上出来转</p>
<h3 id="第四天-2020-01-24-腊月三十"><a href="#第四天-2020-01-24-腊月三十" class="headerlink" title="第四天 2020-01-24 腊月三十"></a>第四天 2020-01-24 腊月三十</h3><p>在深圳湾附近转</p>
<p>或者深大</p>
<p>晚上还是在深圳湾，看烟火</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">深圳华里酒店 RMB <span class="number">369</span></span><br></pre></td></tr></table></figure>
<h3 id="第五天-2020-01-25-正月初一"><a href="#第五天-2020-01-25-正月初一" class="headerlink" title="第五天 2020-01-25 正月初一"></a>第五天 2020-01-25 正月初一</h3><p>上午乘坐高铁从深圳到广州</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">G6234 深圳北 - 广州南 <span class="number">09</span>:<span class="number">40</span> - <span class="number">10</span>:<span class="number">16</span> 历时 <span class="number">36</span> 分钟 票价 <span class="number">74.5</span> * <span class="number">3</span> = <span class="number">223.5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">广州煌子酒店 RMB <span class="number">223</span></span><br></pre></td></tr></table></figure>
<p>继续在广州转</p>
<h3 id="第六天-2020-01-26-正月初二"><a href="#第六天-2020-01-26-正月初二" class="headerlink" title="第六天 2020-01-26 正月初二"></a>第六天 2020-01-26 正月初二</h3><p>回武汉</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">G1108 广州南 - 深圳 <span class="number">09</span>:<span class="number">16</span> - <span class="number">13</span>:<span class="number">30</span> 历时 <span class="number">4</span> 小时 <span class="number">14</span> 分钟 票价 <span class="number">463.5</span> * <span class="number">3</span> = <span class="number">1390.5</span></span><br></pre></td></tr></table></figure>
<h2 id="Cost"><a href="#Cost" class="headerlink" title="Cost"></a>Cost</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">1390.5</span></span><br><span class="line">+  <span class="number">191</span></span><br><span class="line">+  <span class="number">210</span></span><br><span class="line">+  <span class="number">360</span></span><br><span class="line">+  <span class="number">259</span></span><br><span class="line">+  <span class="number">480</span></span><br><span class="line">+  <span class="number">369</span></span><br><span class="line">+  <span class="number">223.5</span></span><br><span class="line">+  <span class="number">223</span></span><br><span class="line">+ <span class="number">1390.5</span></span><br><span class="line">--------</span><br><span class="line">  <span class="number">5465.5</span></span><br></pre></td></tr></table></figure>
<hr>
<div class="note info">
            <p>2020.01.23更新，一场突如其来的不明肺炎彻底扰乱了这次的行程。</p><p>2020.01.19，坐高铁从北京回武汉，我没有戴口罩。<br>2020.01.20，上午还在为21日的出行做准备，当晚听到钟南山院士<strong>肯定人传人</strong>的论断，还是想去广东。<br>2020.01.21，早晨刷着微博上的各种新闻，开始意识到这次的严重性，终止了这段行程。<br>2020.01.23，武汉封城。</p><hr><p>2020.02.14，庆幸这次选择出发的时间点，庆幸当时的选择。</p>
          </div>
]]></content>
      <categories>
        <category>行万里路</category>
      </categories>
  </entry>
  <entry>
    <title>2019 未来へ</title>
    <url>/posts/2ecc368/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天我们来到了 2019 年的最后一天，也是 2010 年代的最后一天。按照惯例，每年的年底都会给自己写一个年终总结，只是因为之前学生时代的新历年底总是忙于考试，最后的年终总结总是以旧历年底作为分割点。从今年开始，虽然依旧是学生，但是那些考试的记忆已经渐渐离我远去，似乎可以开心地给自己每一年定一个 DDL —— 在每年新历的 12 月 31 日，给自己过去的一年做一个好好的总结，给自己未来的一年有一个好好的规划。</p>
<p><code>2019 未来へ</code> 是这个系列的第一篇，期待 UP 主在后续的日子里也能够保持持续更新。<code>未来へ</code> 是日本女子组合 kiroro 的一首讲母女情的歌曲，这里只是借用其歌曲名，向着2020，向着未来。</p>

    <div id="aplayer-cbRXpSFi" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="22746144" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<blockquote>
<p>ほら 足元を見てごらん</p>
<p>これがあなたの歩む道</p>
<p>ほら 前を見てごらん</p>
<p>あれがあなたの未来</p>
<p>夢はいつも空高くあるから</p>
<p>届かなくて怖いね</p>
<p>だけど追い続けるの</p>
<p>自分の物語だからこそ</p>
<p>諦めたくない</p>
</blockquote>
<p>从新历的角度来看，就会越发觉得一年时光匆匆。2019 年的春节在 2 月 5 日，从元旦开始，整个心思就已经开始想着如何回家放假过年了。等到年假回来学校开学，就感觉二月份已经快要逝去了。身为一个即将毕业的老学长，今年的主要重点当然是找工作，从过完年回来，到国庆之前，一直兵荒马乱着找工作的事情。当然，生活不能总是只有工作，还得有生活。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2019 年以在香侬的实习结束作为开始。说起来，其实自己在香侬断断续续呆了将近一年。从最开始的 KBQA 项目，到后来基础架构组的工作，自己也越发确定了之后的工作方向。</p>
<p>在实习的前期，自己还在想之后是不是要找算法方向的工作，还会去看关于深度学习相关的材料。算法是不难，自己也能够很快的理解。但是一个问题在于，之前没有实际做过相关的项目。当 JW 可能想让我做搜索相关的事情，自己没有相关的经验，没有果断接下来。自那之后，便和算法没有了太多的联系，开始专注在基础架构相关的事情上。</p>
<p>和 Shibo，CR 他们一起，基于云原生的生态体系，把整个公司的微服务架构给搭了起来，然后专注在 ceph 一块。接触的面很多，但是一个很大的问题在于，基础架构的人很少，但是整个微服务生态牵扯的事情有很多。这就决定了大家做的事情都不会太深，经常得去解决这种细枝末节的事情。</p>
<p>春节前从公司离职了，开始想好好的准备开年春招实习的事情，期待能够去 Google 实习，准备起 LeetCode。然而事实证明，寒假回家的我果然是不会学习的。开年回来，依次面各家公司，Google、Hulu、阿里、腾讯、微软、旷视等公司，Google 和 Hulu 挂了，最后阴差阳错拿到了 MSRA 的 offer。</p>
<p>MSRA是一段难忘的经历，我喜欢那里的工作方式和工作态度。可以说，这是我经历的所有实习中体验最好的一次。事先准备好的工作目标，每周的讨论与更新，工作的方向和内容，周围同事的素质，还有每天不限量的酸奶，都让我特别喜欢。在这个过程中，自己也存在各种问题可以改进，总能够做的更好。遗憾的是，最后没有能够在 MSRA 留用，在面试、在做题上面还是有很多可以改进的地方。</p>
<p>与 MSRA 转正面试并行，拿到了阿里、腾讯、美团、商汤、旷视和华为的 offer，没有去面字节，Hulu 都没有给面试机会。感觉自己在秋招中后期越发的佛系，拿到了几个 offer 之后都不想去投递新的公司了，本来以为 MSRA 转正是可以通过的，所以当时连 Airbnb 都没有投递，导致最后一个外企的 offer 也没有拿到。</p>
<p>现在想一下，其实当时正是秋招的时候，自己的目标可以更加明确一些。很多公司拿了 offer 根本就不会去，可以拿来练手，但是不需要太多。然后就是自己过于自信，接到 MSRA HR 电话之后以为自己基本稳了，但是不到最后一刻，各种问题总有可能出现。</p>
<p>Anyway，到最后自己拿的几个 offer 也还算不错，最后还是选择了腾讯。也不知道之后能不能拿到北京户口，也不知道自己之后会不会留在北京。未来变化太大，可能现在想的很好的事情，最后会完全改变。</p>
<p>在整个秋招期间，想了很多的问题，其实主要就是关于未来方向选择的问题：</p>
<ol>
<li><p><strong>是选择技术方向还是选择业务方向</strong> </p>
<p>两个典型的选择，比如去华为软件研究院做底层基础软件，专注于自己的方向，很少和业务线的人打交道；另外一个选择，就是去抖音业务产品线，针对具体的功能产品直接负责，会经常和业务线、产品线的人打交道，但是做的技术深度可能就不太多。两个方向各有自己的利弊，做技术的可以深度钻研技术，可以一直做到技术专家类型，但是长期如此对于业务线缺乏了解；做业务的熟悉产品，产品成功自己也可以获得经济上不错的回报，但是可能就需要一直盯着业务，持续性 on call 这种。</p>
<p>以前我是非常排斥业务方向的，因为我觉得这都是些啥，没有技术含量，个人技术上没有成长。但是后来逐渐改变了自己的想法，所有的公司，都是通过业务获得收益的。没有具承载的具体业务，对应的技术研究也就没有意义。</p>
<p>这个世界是一个多元的世界，身为技术人，往往会沉溺于自己对于技术的孤芳自赏，而忘却了这世上万千的更多复杂有意义的事情。一个人的厉害之处，在于能够把别人做不成的事情给做成。不论是做技术，还是做产品，或者是做投资，都是如此。</p>
<p>对于自己以后的发展方向，并不需要局限在某个点上，还是要有全局眼光。我是做云计算，当然有自己专注的方向，但是对于整个行业的发展和变化也要有所关注，云计算和 人工智能，和 IoT，和 5G 的结合。这将是未来 10 年会迅猛发展的方向。</p>
</li>
<li><p><strong>未来要去哪个城市</strong></p>
<p>关于城市的选择，自己并没有特别的倾向，留在北京可以，去上海好像也不错，杭州可以考虑，深圳和广州也都是不错的选择。现在自己一个人选择很轻松。也许以后有那个她之后，会有更多的牵绊。在那之前，也可以考虑去国外待一段时间，感受一下那边的工作状态。</p>
<p>也许，自己的这种没有特别倾向，更多的是缺乏对于城市，对于自己的思考吧。不同的城市有自己不同的品性，就像不同的人一样。关于这一点，需要我以后更多的去感受吧。</p>
</li>
<li><p><strong>小公司还是大公司</strong></p>
</li>
<li><p><strong>外企还是国内企业</strong></p>
</li>
<li><p><strong>是否考虑体制内</strong></p>
</li>
<li><p><strong>工作与生活的关系</strong></p>
</li>
</ol>
<p>种种的这些问题，或多或少会有自己的答案。随着时间的推移，自己的答案有的会越发坚定，有的会慢慢改变。</p>
<p><em>Time will tell.</em></p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>我一直认为，<code>人是一个可动态变化的实体</code>。人是可以改变的，你永远可以变得更好。今天，我想在这句话后面再加一句，<code>但是与此同时，人内在的惰性会拒绝改变</code>。</p>
<p>你永远想要自己变得更好，你也总是在嘴上喊着要上自己变得更好。但是呢，实际的结果总是会让你失望，比如每年的年终总结和新年计划。这里的问题在哪呢？</p>
<p>方法论是这样的：</p>
<ul>
<li>想要变得更好，你首先得提出自己的目标，比如新年计划</li>
<li>有了目标之后，就会想办法去一点一点的让目标实现</li>
</ul>
<p>然而实际的常态是，往往是起初兴致很高，但是后来却慢慢忘却了自己的这个目标，最后是自己也渐渐羞于提起。是即，偶然性觉醒，日常性摸鱼。</p>
<p>这里面最重要的是，<strong>数据</strong>。任何目标都可以提出，但是具体的实现，需要去一步一步的执行。在执行的过程中，可能会发现目标的不合理，要去定期校正自己的目标。每隔一段时间，需要根据数据去总结去反思。我永远相信，数据是不会骗人的。</p>
<h3 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h3><p>找完工作之后，实验室的四人组就越发浪了起来。定期的约饭约酒，大家都玩的很嗨。PT喜欢摄影，经常给我们拍照。</p>
<p>比如这种</p>
<p><img alt="电影般的剧情" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-13_fight.jpg"></p>
<p>或者这种</p>
<p><img alt="楼梯上的沉思" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-11_stair.jpg"></p>
<p>一直以来自己也喜欢用手机随手拍，在 PT 的影响下，终于在九月底给自己也买了一个 Sony A7m3，算是开始正式踏入了摄影的门。有了自己的微单之后，才开始去认真的想该如何拍摄。以前自己喜欢用手机记录生活，拍的时候取景、构图都没有任何的主管想法，后期也基本上无感。刚开始拿到相机之后，也是这么无意识的随便拍，但是拍着拍着，发现自己有很多的废片。现在觉得，每拍一张照片，都要有自己的想法，好不容易出来一张作品，要能够反映当时自己感受的状态。</p>
<p>一方面，要求自己去更好的感受生活，更好的去观察；另外一方面，也要去更好的提高自己的摄影技术。今天的封面图是我拍的，这也是我今年最喜欢的一张照片。</p>
<p>下面还有一张，拍的是学校的冬日未名湖</p>
<p><img alt="冬日未名湖" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/album/Period/artwork/2019-12-16_lakeside.jpg"></p>
<p>在学习李涛老师的后期课程的时候，他讲的一点我非常认同，美是相通的。不管是摄影，还是绘画，或者是音乐，都有其内在的美感，不需要经过任何艺术训练的人都可以感受到它的美。</p>
<p>Ansel Adams 说，</p>
<blockquote>
<p>我们不只是用相机拍照，我们带到摄影中去的是所有我们读过的书、看过的电影、听过的音乐、走过的路、爱过的人。</p>
</blockquote>
<p>摄影不仅仅是记录，它也可以传达情感。理论上是这样的，但是对于我而言，实操上还是有很多可进步的空间的。毕竟，<code>能够感受到一个东西的美</code>和 <code>观察出它为什么美</code> 这中间还是有 gap 的，更多的是需要自己刻意的训练。</p>
<p>不管怎么样，总算是开了一个头。对于 2020 年的期待呢，在摄影上能够更加有所进步，争取每个月都能出一张自己超级喜欢的作品，最后年终的时候能够设计出一份属于自己的年历。</p>
<h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>今年只有一次旅行，也就是 11 月四人组一起去云南的大理和丽江。大理很美，苍山洱海，风景令人心醉。</p>
<p><img alt="这是我们从苍山回到洱海旁酒店的路上，山岚和云彩特别的漂亮" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/album/Cosmos/artwork/2019-11-21_moutain-and-cloud.jpg"></p>
<p>一路回来，骑着电动车特别的舒服，玩的非常开心</p>
<p><img alt="机车play" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-11-21_play.jpg"></p>
<p><img alt="PT拍的我和HT，可以忽略我和PT之间的调色差异，哈哈哈" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-11-21_elemobile.jpg"></p>
<p>之后我们去的丽江古城，其中最难忘的还是丽江的玉龙雪山。景色超美，越来越喜欢去这种自然景观的地方了，古城什么的，还是算了吧。</p>
<p>2019 年只有一次旅行，而现在已经规划了 2020 的两场旅行。一个是和老妈和老姐的广东过年之旅，一个是和 PF 的湖南之行。除此之外，期待明年能够出国走一趟。</p>
<h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>2019 年的另外一个重大收获就是，我学会弹琴了。哦不，还不是钢琴，而是卡林巴琴。</p>
<p>这里是我在练习 20 天之后弹奏青花瓷的效果</p>
<p><iframe src="//player.bilibili.com/player.html?aid=80837939&cid=138355848&page=1" width="450" height="800" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>在此之前，我对乐理一无所知，小学时候接受的音乐教育基本为零。非常感谢皮皮老师的指导和入坑推荐，我自己去学习了一下乐理的相关知识，学学简谱和五线谱啥的，然后就可以开始练习了。</p>
<p>音乐不就是不同频率的波形的相互作用吗，学过傅氏变换的人还会怕这些乐理知识吗，哈哈哈。虽然现在表演还是很挫，但是我还是很有信心能够呈现出更完美的状态的。虽然只练习了三个星期左右，从最简单的小星星，到现在能够完整的弹下来青花瓷，自己感到非常开心。现在每天晚上都会花一个小时左右的时间去练习，不断的加深自己的肌肉记忆，做一个顽强的正确机。</p>
<p>卡林巴琴算是开始，期待之后能够入手更多的乐器。就想皮皮老师说的一样，卡林巴就像乐器里面的 Python一样，钢琴可能更像C++。你既然已经学会了 C++，Python和 Go等等语言，那么有了卡林巴，之后其他乐器未尝不可能。</p>
<p>2020 年，在现在的基础上，从单音青花瓷，到加上伴奏，到扩展到其他的乐曲。如果可以的话，可以入门一个新的乐器，期待明年变成社畜的我还能够有时间在这上面。</p>
<h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><p>其实在 2018 年的时候已经入坑了股市，但是自己啥都不懂，完全是凭感觉买。从 18年 4 月份开始，正好碰到了当时的一波熊市，一直亏亏亏。好在投入也不算太多，损失还在可接受范围内。</p>
<p>2019 年，仍然不是太能够搞懂股市相关操作，稀里糊涂的买卖，最后倒也有将近 40 个点的收益。</p>
<p><img alt="2019年股市投资收益" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-12-31_investment.jpg"></p>
<p>可能是运气吧，无论如何也算是一个不错的结果。</p>
<p>2020 年，希望自己对于投资，对于股市能够有更多的认识，明白自己每次操作逻辑。除了股市之外，还有基金市场。</p>
<p>给自己定一个小目标，期待自己明年在投资上至少能够有 20 个点的收入，最好能够到 40 个点的收入。</p>
<h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>这一年的锻炼荒废了很多。</p>
<p>健身房的无氧运动经常性的不去，五四操场的跑步也没有坚持下来。唯一坚持下来的，就是每周和 Y 老师的羽毛球运动。发现自己越来越喜欢上了羽毛球，每次打完球之后的那种感觉真的很畅快。双打的时候，那种快节奏的拼杀让我感觉非常刺激。</p>
<p>2019 年，给自己配置了一个好的羽毛球拍 天斧 88d 和一个还不错的羽毛球鞋，自己的技术也在慢慢的提高。</p>
<p>2020 年，期待自己的技术能够进一步提高，或者能够参加啥比赛感觉感觉。</p>
<p>除此之外，健身房和跑步也不能够荒废。</p>
<p>数据是最重忠实的记录者，每周 3 次跑步，每次 5 公里，期待明年能够达到 700 公里的跑步量。</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>略</p>
<h3 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h3><p>略</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>本来还想接着说一下阅读和观影的事情，但是发现今年不论是阅读量还是观影量都有很大的减少。以前确实也翻了很多的书，但是发现自己在输出方面还是做得很差。看是看了，但是是否真的落到实处了，自己能够在合适的时候很好的输出，也是一个需要锻炼和培养的能力。</p>
<p>今年的我仍然是单身一个人。现在发现，有时候会忘了自己单身的事情，因为发现有很多很多有意思的事情可以做。明年 会怎样呢？一切顺其自然吧，你总会碰到你喜欢她并且她也喜欢你的女孩子呀。</p>
<hr>
<p>再见，2019</p>
<p>你好，2020</p>
<p>新年快乐！</p>
]]></content>
      <categories>
        <category>岁末围炉</category>
      </categories>
  </entry>
  <entry>
    <title>Carpe Diem</title>
    <url>/posts/3e030bdb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>「朝花夕拾」是我给自己安排的每周总结。在 2020 年的年度计划里面，我给自己定的一个目标就是在 2020 年度每一周，能够有一份自己的总结，用以复盘自己在过去做过的事情，思考过的问题。这里是 2020 年朝花夕拾第一篇 <code>Carpe Diem</code>，今天我们来聊一聊数据和时间管理。</p>

    <div id="aplayer-dMQcSxWN" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="499957703" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<p>在2019 年的年终总结里面，提到了一个思路，<code>用数据记录生活</code>。我下了一个粗暴的论断，<code>数据不会骗人</code>。这句话的前提是在展现数据的时候采用公平客观的方式，否则的话 —— <a href="https://www.zhihu.com/question/19578400" target="_blank" rel="external nofollow noopener noreferrer">「数据会说谎」的真实例子有哪些？</a></p>
<p>话说回来，生活中的数据无处不在。大到国家统计局统计的国计民生的宏观经济数据，小到生活中每天点的外卖数据、滴滴的出行数据、微信的聊天数据，在当今的大数据时代，已经完全可以通过技术手段利用数据解析出你个人的生活。一个典型的例子，就是抖音等移动应用可以通过对你行为的追踪，精确地构建出你的 <code>用户画像</code> 。很多时候，可能你都不如抖音了解你自己。</p>
<p>想起来之前在百度实习的时候发生的事情，当时我们内容团队在做百度 Feed 流的智能推荐，所以当时我也做了一段时间的手机百度的用户。要做智能推荐，要做千人千面，那么必须要对不同的用户做出精准的用户画像。（不然，如果给Robin 推荐了娱乐相关的内容，不仅是推荐的正确率大大降低，还会被 Robin 在群里直接发问。对，17 年那会 Robin 会直接和 Feed 流这边团队的人每日追踪 Feed 流的效果）。当时内部有一个用户画像系统，对于系统内的每一个用户，可以直接给出非常详细的用户画像描述。通过各种 tag 和图之间的关系，可以完整地看到一个用户在各个方面的特征。我尝试看了一下我自己的用户画像，当时真的是惊了。它非常诚实的记录了我的每一次浏览、每一次点击、每一次搜索，并被很精准的抽出了我的特征。我甚至都没有意识到我会那么频繁的关注小米新闻（果然当时是个米粉），我对于科技内容方面的关于也是远远大于其他内容（这还算符合预期的）。</p>
<p>人是一个容易遗忘的物种。你可能不太记得你点外卖最长点的那家，你可能不太记得你花费了那么多的时间在刷短视频上，你可能不太清楚过去一年你购物上花费最多的一笔资金，你可能不太记得你过去一年 12 点之后才睡觉的比例……凡此总总，你所使用的应用，都在忠实客观地记录着这一切。所以，一年一度的年度总结里，互联网公司们就会出来刷存在感了。「来，看呀，这是你过去一年在我们这里经历的故事呀」。但是，他们没有告诉你的是，这些数据他们一直都在记录着，而且这里的年度总结里面只是一些他们想告诉你的数据。更多的数据，涉及到商业利益的，他们从不会告诉你。</p>
<p>从理论上讲，如果当前各大互联网公司的数据能够共享的话，或者加上政府机构、医疗机构、电信系统、教育系统等等系统数据的话，对了还有满大街的摄像头数据，我们完全可以清楚的记录你这一生的所有，这在技术上完全是可行的。正如马云所说，<code>未来数据是生产资料，计算是生产力，互联网是生产关系</code>。整体上，整个社会、整个世界都是在朝着这个方向前进的。</p>
<p>所以，这篇文章的主题是要控诉万恶的资本、万恶的政府，正是因为他们我们的生活才没有一点点隐私吗？哦不，我今天想聊的并不是这，也许以后可以再仔细聊一聊这个话题。实际上，身为技术人，我也是这个宏大系统的一份子，我也在推动着世界在朝着这个方向继续前进。并且，我是支持这个趋势的，数据化、智能化是未来。我们见过太多原始化的数据记录方式了，卷帙浩繁的法院系统的案卷信息，公安系统、教育系统、医疗系统莫不如是，技术上我们完全具有信息化智能化的能力，而且我也以为我们应当如此。至于上面说的问题，更多的是从技术和伦理的一个矛盾罢了，在合理的系统设计下，是可以解决上述问题的。</p>
<p>那么，回归我想说的主题，「数据与时间管理」（今天真的是扯太远了）</p>
<p><code>Carpe diem</code> 出自于 Horace 的 「Ode」中</p>
<blockquote>
<p>carpe diem, quam minimum credula postero</p>
</blockquote>
<p>意思是 <code>seize the day, put very little trust in tomorrow</code>。以这个作为本期朝花夕拾标题的用意在于，期待自己能够好好的过好每一天，对得起自己每一天的生活。</p>
<hr>
<p>还是那个观点，人本性是懒惰的，人本身是想要待在自己的舒适区里面的。为什么有时候刷抖音会一直刷下去呢？抖音几千个工程师就为了让你在上面呆的时间更长一点，专门针对人性的弱点进攻，沉迷于此完全合理。所以呢，为了能够更好的时间管理，你需要运用工具，突破自己的舒适区。</p>
<p>关于时间管理，目前主要将其分成了以下四个部分</p>
<h2 id="时间追踪"><a href="#时间追踪" class="headerlink" title="时间追踪"></a>时间追踪</h2><p>时间追踪就是记录自己每天的时间花在了哪里。时间是不会作假的，通过记录时间，你会清楚的看到你每天的时间花在了哪里，就可以看出来你是一个怎样的人。而不是自己的错觉，觉得自己有多么多么努力。</p>
<p>对于计算设备上的时间追踪，我使用的是 RescueTime 这个工具，它会常驻在内存，记录你在各个软件上使用的时间。包括移动平台和非移动平台。比如这里是我在今天各个平台上花费的时间统计：</p>
<p><img alt="RescueTime" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-04_recue-time.png"></p>
<p>对于非计算设备上的时间记录呢？当然也有很多工具，比如 <code>iHour</code>，但是 iHour 的问题就在于每次做完一件事情时候你得手动去记录下来。另外一个可以的选择就是利用日历，比如 <code>Google Calender</code>，这是一个全平台通用的日历工具，而且你手机或者是笔记本上的日历都可以导入谷歌日历。另外一个优点就是，谷歌日历采用标准的 iCalender 的数据存储。即使谷歌日历不能用了之后也可以转到其他平台。不像小米手机自带的日历，不能导出。</p>
<p>因为你本来就需要通过日历来做行程安排，所以另一方面也可以通过日历来记录自己的时间。当你把谷歌日历用到了极致之后，你甚至可以用谷歌日历来记日记，比如<a href="https://james-sun.blogspot.com/2013/05/google-calendar.html" target="_blank" rel="external nofollow noopener noreferrer">这个例子</a>。</p>
<p>记录时间只是一个中性的行为，但是它可以帮助你更好的复盘。比如通过 RescueTime 我可以清楚地知道我每天在各个平台上面花费的时间，至少能够给自己以警醒。另外，通过谷歌日历，我可以查到在过去任意一段时间我干了啥。通过给自己设置一个每日总结的 list，可以督促自己每天用谷歌日历来复盘自己一天的生活。</p>
<h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><p>任务清单就是为了帮助你完成计划，可以记录计划进度，添加任务，任务可以有分类，也可以设置任务重要优先级。日历当然也能够设置任务清单，但是它总是会和时间强相关，并不是专为任务清单而设计的。</p>
<p>常见的任务清单有比如 <code>TickTick</code>和 <code>WunderList</code>，但是使用了一下不能够任务导出让我心里总是会有一些担心。</p>
<p>后来我想到了 <code>Trello</code>，这个是我在香侬实习的时候 Shibo 推荐我们使用的。Trello 适合小团队协作，可以完成更多的工作。它采用看板的思路，通过看板、列表和卡片的形式组织项目并区分优先级。除了小团队，当然也可以给个人使用，可以参考 <a href="https://www.zhihu.com/question/28683908/answer/139282848" target="_blank" rel="external nofollow noopener noreferrer">这个知乎问题</a>了解更多关于 Trello 使用的方法。</p>
<p>使用了一下之后发现，Trello 不仅支持 Markdown 格式，还可以将数据以 JSON 的格式导出，还可以和其他的工具比如 slack、github 协同工作，简直专门为程序猿设计，完美！</p>
<p>每一个工具只干一件事，然后可以和其他工具协同工作，这不就是 UNIX 的KISS设计哲学吗？</p>
<p>这里是我当前的一个看板，主要用于个人计划管理，也许以后工作会专门在开一个看板。</p>
<p><img alt="Trello" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-04_trello.png"></p>
<p>对每一个 card 还能有自己详细的计划</p>
<p><img alt="比如这里是我的 2020 年度音乐计划" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-04_trello-list.png"></p>
<h2 id="习惯养成"><a href="#习惯养成" class="headerlink" title="习惯养成"></a>习惯养成</h2><p>坚持 21 天就可以养成一个习惯。除了上述的工具，还可以有习惯养成打卡工具，我这里选用的是小日常。</p>
<p><img alt="萌萌的界面" data-src="https://pic1.zhimg.com/v2-95047deef1fca85441ce9a6319eef3cc_r.jpg"></p>
<p>这里的习惯养成主要就是督促自己养成一些生活中的小习惯啦，比如早睡早起、热水泡脚等习惯，作为上面的工具的一个辅助。</p>
<h2 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h2><p>最后一个就是番茄工作法，如何能够让自己在工作的时候尽量的投入到其中。一个解决的思路就是番茄工作法，就是说工作一段时间比如 30 分钟之后，休息 5 分钟，可以看手机、起来动一动啥的。</p>
<p>这方面的工具有很多，比如番茄时钟，番茄土豆之类的，我这里选用的是 <code>forest</code></p>
<hr>
<p>上面说的种种，都只是这几天选择的工具，并在确定的工具下设定了自己的工作流模式。2020 年的第一周，一切都只是刚刚开始，所有的数据记录和打卡也都是刚刚开始，每周总结朝花夕拾也才刚刚开始。期待自己在 2020 年底的时候，看着所有的这些数据，能够自豪的作出自己的年终总结。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客容器化</title>
    <url>/posts/f5d73ad0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>容器化技术已经越来越成为互联网应用的潮流，本文记录了我的 Hexo 博客容器化的过程。</p>
<a id="more"></a>
<p>容器化应用，不仅可以提高现有应用的安全性和可移植性，还能节省成本。想一想，如果每一次更换云服务器，都需要重新把 <a href="../a63a603e">这篇博文</a> 的操作重复一遍，该是多么痛苦的一件事情。容器化之后，我们只需要有一个 <code>Dockerfile</code> 就可以方便的迁移博客，所有的网站和博客的更新都可以版本化控制。</p>
<p>下面所有的操作，默认是在一个已经配置好 docker 环境的云服务器上。首先我会简单说一下系统的模块设计，然后针对三个不同的模块详细介绍，实现系统的基本功能。在之后是在已经实现的基本功能基础上，一步一步的加上一些扩展功能，更加完善当前系统，使其更加方便易用。</p>
<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>在 <a href="./a63a603e">深度定制Hexo博客</a> 这篇文章中，服务器所有的模块其实可以分为三个部分:</p>
<ul>
<li>Git 服务器模块</li>
<li>Hexo 解析渲染模块</li>
<li>Nginx 服务器模块</li>
</ul>
<p>整个系统的操作逻辑如下：</p>
<ul>
<li>Git 服务器模块存储了 blog 的 repo，这个 repo 里面保存的是网站所有源代码的内容，而不是像 github 那种保存源文件渲染之后的内容。还需要注意的是，这里的 repo 是对应的 blog.git，而客户端存储的是 blog。</li>
<li>客户端，也就是自己的笔记本也存储了 blog 的源文件。每次更新博客是在客户端进行，更新完之后会自动上修改上传到 Git 服务器。</li>
<li>Git 服务器自己的 hook 工具会自动将这份更新同步到 Hexo 解析渲染模块。</li>
<li>Hexo 解析渲染模块有一份和客户端同步的 blog 源文件。每次客户端 push 到 git 服务器之后，git 服务器就会自动同步 Hexo 解析渲染模块的文件。然后执行 <code>hexo generate</code> 的命令，生成对应的网站的 HTML 文件，放在对应的 <code>public</code> 文件夹中</li>
<li>Nginx 服务器根据配置，指定对应的 root 目录即可</li>
</ul>
<p>虽然在 <a href="./a63a603e">深度定制Hexo博客</a> 这篇文章中我还增加了一些扩展功能，比如 https，比如 在线编辑 的功能，但是基本的操作实际上就是上面这个模型的。</p>
<p>对应于微服务化，我应该如何去设计我自己的Docker镜像和对应的配置文件呢？</p>
<p>最直接的，我们按照这个功能划分，把这个系统分为三个模块，具体的用 <code>docker-compose</code>的方式展现出来，就是</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">git-server:</span></span><br><span class="line">    <span class="attr">container-name:</span> <span class="string">hexo-git-server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">houmin/git-server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./git-server/keys:/git-server/keys</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./git-server/repos:/git-server/repos</span></span><br><span class="line">	  <span class="attr">ports:</span></span><br><span class="line">	    <span class="bullet">-</span> <span class="string">"2222:22"</span></span><br><span class="line">  <span class="attr">hexo:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo_build</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">houmin/alpine-hexo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./source:/hexo/source:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./themes:/hexo/themes:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./public:/hexo/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node_modules:/hexo/node_modules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"4000:4000"</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo_web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./public:/usr/share/nginx/html:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./conf:/ect/nginx/conf.d</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br></pre></td></tr></table></figure>
<p>看起来很不错，我们期待的是，每次客户端更新博客之后，将更新 push 到 git 服务器，然后 git 服务器上面的 hook 就会自动去更新 hexo 解析渲染模块的内容，渲染出最新的网页内容。然后因为 hexo 解析渲染模块的生成目录，实际上就是 Nginx 服务内容的目录，所以渲染之后网页内容就可以及时的更新。</p>
<p>现在的一个问题就是，如果把 git 服务器模块和 hexo 渲染模块放在两个容器里面运行，在 git 服务器模块中怎么使用 hook 去更新 hexo 渲染模块里面命令，具体的就是 <code>hexo generate</code>。</p>
<p>在同一台物理机上，我的 hook 操作如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">HEXO_PATH="/home/git/hexo"</span><br><span class="line">unset GIT_DIR</span><br><span class="line">git -C $HEXO_PATH fetch origin;</span><br><span class="line">git -C $HEXO_PATH rebase origin/master;</span><br><span class="line">hexo --cwd $HEXO_PATH generate;</span><br></pre></td></tr></table></figure>
<p>直接去执行本机的 hexo 命令，指定本机的路径。这个操作在同一台物理机上是可以的，但是微服务化之后容器间就不太行了。到了这一步，就回到了微服务化的常见套路了，两个可选方案：</p>
<ul>
<li>RPC</li>
<li>REST</li>
</ul>
<p>两种方案都可以，但是既然只是作为一个简单的博客，我想实现的事情很简单，就是一个容器让另外一个容器执行一个命令。考虑到 hexo 解析渲染模块已经有 js 的所有环境，使用 js 实现一个 REST server 服务也不难，所以就直接采用 REST 了。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="Git-服务器模块"><a href="#Git-服务器模块" class="headerlink" title="Git 服务器模块"></a>Git 服务器模块</h3><p>这里的 git 服务器主要是参考了 <a href="https://github.com/jkarlosb/git-server-docker" target="_blank" rel="external nofollow noopener noreferrer">git-server-docker</a>，针对自己的需求做了定制。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> houmin &lt;houmin.wei@pku.edu.cn&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache \</span></span><br><span class="line"><span class="bash">        openssh \</span></span><br><span class="line"><span class="bash">        git \</span></span><br><span class="line"><span class="bash">        curl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Key generation on the server</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ssh-keygen -A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /git-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -D flag avoids password generation</span></span><br><span class="line"><span class="comment"># -s flag changes user's shell</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /git-server/keys \</span></span><br><span class="line"><span class="bash">  &amp;&amp; adduser -D -s /usr/bin/git-shell git \</span></span><br><span class="line"><span class="bash">  &amp;&amp; <span class="built_in">echo</span> git:12345 | chpasswd \</span></span><br><span class="line"><span class="bash">  &amp;&amp; mkdir /home/git/.ssh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> git-shell-commands /home/git/git-shell-commands</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> sshd_config /etc/ssh/sshd_config</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> start.sh start.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/git-server/keys"</span>]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/git-server/repos"</span>]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"start.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>注意，为了使得 <code>git-shell-commands</code> 能够生效，需要使得其具有执行权限 <code>chmod +x -R git-shell-commands</code></p>
<p><code>start.sh</code> 具体内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If there is some public key <span class="keyword">in</span> keys folder</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">then</span> it copies its contain <span class="keyword">in</span> authorized_keys file</span></span><br><span class="line">if [ "$(ls -A /git-server/keys/)" ]; then</span><br><span class="line">  cd /home/git</span><br><span class="line">  cat /git-server/keys/*.pub &gt; .ssh/authorized_keys</span><br><span class="line">  chown -R git:git .ssh</span><br><span class="line">  chmod 700 .ssh</span><br><span class="line">  chmod -R 600 .ssh/*</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Checking permissions and fixing SGID bit <span class="keyword">in</span> repos folder</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> More info: https://github.com/jkarlosb/git-server-docker/issues/1</span></span><br><span class="line">if [ "$(ls -A /git-server/repos/)" ]; then</span><br><span class="line">  cd /git-server/repos</span><br><span class="line">  chown -R git:git .</span><br><span class="line">  chmod -R ug+rwX .</span><br><span class="line">  find . -type d -exec chmod g+s '&#123;&#125;' +</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">clone</span> hexo from <span class="built_in">local</span> git repo</span></span><br><span class="line">cd /hexo</span><br><span class="line">git init .</span><br><span class="line">git remote add origin /git-server/repos/hexo.git</span><br><span class="line">git fetch</span><br><span class="line">git branch master origin/master</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">chown -R 1000:1000 /hexo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -D flag avoids executing sshd as a daemon</span></span><br><span class="line">/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>
<p>编译 docker 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/git$: docker build -t houmin/alpine-git-server .</span><br></pre></td></tr></table></figure>
<p>通过 <code>docker-compose</code> 运行 git-server</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">git-server:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">git-server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">houmin/alpine-git-server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/git-server/keys:/git-server/keys</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/git-server/repos:/git-server/repos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo:/hexo</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"2222:22"</span></span><br></pre></td></tr></table></figure>
<p>把本地 <code>public key</code> 复制到 git server 的 keys 目录，并且重启 git server</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">Copy Public Key To Git <span class="symbol">Server:</span> <span class="variable">$ </span>scp ~<span class="regexp">/.ssh/id</span>_rsa.pub user<span class="variable">@host</span><span class="symbol">:~/git-server/keys</span></span><br><span class="line">You need restart the container <span class="keyword">when</span> keys are <span class="symbol">updated:</span></span><br><span class="line"><span class="variable">$ </span>docker restart &lt;container-id&gt;</span><br></pre></td></tr></table></figure>
<p>这时候使用通过如下命令测试</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">$ ssh git@&lt;ip-docker-<span class="built_in">server</span>&gt; -p <span class="number">2222</span></span><br><span class="line">...</span><br><span class="line">Welcome <span class="keyword">to</span> git-<span class="built_in">server</span>-docker!</span><br><span class="line">You<span class="comment">'ve successfully authenticated, but I do not</span></span><br><span class="line">provide interactive shell access.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>把 blog.git 上传到 <code>git-server/repos</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">From remote:</span><br><span class="line"><span class="meta">$</span><span class="bash"> scp -r myrepo.git user@host:~/git-server/repos</span></span><br></pre></td></tr></table></figure>
<p>从而可以在客户端本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://git@&lt;ip-docker-server&gt;:2222/git-server/repos/myrepo.git</span></span><br></pre></td></tr></table></figure>
<h3 id="Hexo-解析渲染模块"><a href="#Hexo-解析渲染模块" class="headerlink" title="Hexo 解析渲染模块"></a>Hexo 解析渲染模块</h3><p>Dockerfile 如下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mhart/alpine-node:<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /hexo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HEXO_VERSION <span class="number">4.0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="bash">  &amp;&amp; npm install -g hexo@<span class="variable">$&#123;HEXO_VERSION&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo"</span>]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo/node_modules"</span>]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/hexo/public"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /hexo/package.json</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entrypoint.sh /hexo/entrypoint.sh</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> _config.yml /hexo/_config.yml</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> server.js /hexo/server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"/hexo/entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>entrypoint.sh 如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">npm install hexo@4.0.0 --save</span><br><span class="line">npm install --production</span><br><span class="line"></span><br><span class="line">hexo douban -bm</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">node server.js</span><br></pre></td></tr></table></figure>
<p>server.js 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> execSync = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/list'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'Response from REST request /list'</span>);</span><br><span class="line">    <span class="keyword">const</span> output = execSync(<span class="string">'hexo generate'</span>, &#123;<span class="attr">encoding</span>: <span class="string">'utf-8'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'output:\n'</span> + output);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> port = server.address().port</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'application instance, access address: port: %s'</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker-compose</code> 启动 hexo-parser 模块</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hexo-parser:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo-parser</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">houmin/alpine-hexo-parser</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/blog/source:/hexo/source:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/blog/themes:/hexo/themes:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/blog/public:/hexo/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/blog/node_modules:/hexo/node_modules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br></pre></td></tr></table></figure>
<h3 id="Nginx-服务器模块"><a href="#Nginx-服务器模块" class="headerlink" title="Nginx 服务器模块"></a>Nginx 服务器模块</h3><p>用 <code>docker-compose</code> 启动 nginx 服务器</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo-nginx-server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/blog/public:/usr/share/nginx/html:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/blog/conf:/ect/nginx/conf.d</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br></pre></td></tr></table></figure>
<h3 id="微服务整合"><a href="#微服务整合" class="headerlink" title="微服务整合"></a>微服务整合</h3><p>至此，通过一个yaml文件就可以启动所有的服务了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hexo-git-server:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo-git-server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">houmin/alpine-git-server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/git-server/keys:/git-server/keys</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/git-server/repos:/git-server/repos</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"2222:22"</span></span><br><span class="line">  <span class="attr">hexo-parser:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo-parser</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">houmin/alpine-hexo-parser</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/source:/hexo/source:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/themes:/hexo/themes:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/public:/hexo/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/node_modules:/hexo/node_modules</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">  <span class="attr">hexo-nginx-server:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo-nginx-server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/public:/usr/share/nginx/html:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/conf:/ect/nginx/conf.d</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br></pre></td></tr></table></figure>
<p>在上面三个模块中，交互比较紧密的是 <code>git-server</code> 和 <code>hexo-parser</code>。每次用户在本地更新完博客之后，将新的 commit 上传到 <code>git-server</code> 中，<code>git-server</code> 通过 hook 更新 hexo 博客中的源文件，然后向 <code>hexo-parser</code> 发出请求，具体的 hook 如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="string">HEXO_PATH="/hexo"</span></span><br><span class="line"><span class="string">unset</span> <span class="string">GIT_DIR</span></span><br><span class="line"><span class="string">git</span> <span class="string">-C</span> <span class="string">$HEXO_PATH</span> <span class="string">fetch</span> <span class="string">origin;</span></span><br><span class="line"><span class="string">git</span> <span class="string">-C</span> <span class="string">$HEXO_PATH</span> <span class="string">rebase</span> <span class="string">origin/master;</span></span><br><span class="line"><span class="string">curl</span> <span class="string">-X</span> <span class="string">GET</span> <span class="string">http://hexo-parser:8080/list</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>http://hexo-parser:8080/list</code> 也就是 <code>server.js</code> 提供的服务。</p>
<div class="note info">
            <p>注：为了能够在 <code>git-server</code> 实现 <code>git fetch</code>的功能，在 <code>git-server</code>中 clone 的是 local 的 git repo，而不是通过远端的 ssh 协议，详见 <code>entrypoint.sh</code>。</p>
          </div>
<h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><h3 id="支持-HTTPS"><a href="#支持-HTTPS" class="headerlink" title="支持 HTTPS"></a>支持 HTTPS</h3><p>众所周知，HTTPS 是一件特别繁琐的事情，关于 HTTPS 可以看一看 <a href="https://www.aneasystone.com/archives/2016/04/java-and-https.html" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a> 。</p>
<p>简单来说，为了避免中间人攻击，网站服务器需要用证书 certificate 证明自己的身份，下面是用户和网站交互流程图。</p>
<p><img alt="SSL Handshake" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-15_ssl-handshake.png"></p>
<p>证书需要从 <code>CA（Certificate Authority）</code> 申请。CA是权威的证书颁发机构，比如GeoTrust、GlobalSign，也有像  <a href="https://letsencrypt.org/" target="_blank" rel="external nofollow noopener noreferrer">Let’s Encrypt</a>  这样的免费证书颁发机构，下面是从 CA 申请证书的示意图。</p>
<p><img alt="从CA申请证书" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/PublicKeyCertificateDiagram_It.svg/1024px-PublicKeyCertificateDiagram_It.svg.png"></p>
<p>对于 Nginx，我们通过下面的配置文件来配置证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name houmin.site;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;.well-known&#x2F;acme-challenge&#x2F; &#123;</span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;certbot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name houmin.site;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        error_page 404 &#x2F;404&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;houmin.site&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;houmin.site&#x2F;privkey.pem;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf;</span><br><span class="line">    ssl_dhparam &#x2F;etc&#x2F;letsencrypt&#x2F;ssl-dhparams.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>fullchain.pem</code> 和 <code>privkey.pem</code> 就是网站从 CA 申请到的证书。</p>
<p><a href="https://letsencrypt.org/" target="_blank" rel="external nofollow noopener noreferrer">Let’s Encrypt</a> 给我们提供了 <code>certbot</code> 工具便于更好的申请和管理证书。这里有一个鸡生蛋蛋生鸡的问题，到底是先有 nginx 呢，还是申请到证书呢？<a href="https://medium.com/@pentacent/nginx-and-lets-encrypt-with-docker-in-less-than-5-minutes-b4b8a60d3a71" target="_blank" rel="external nofollow noopener noreferrer">Nginx and Let’s Encrypt with Docker</a> 的解决方法是，<code>Create a dummy certificate, start nginx, delete the dummy and request the real certificates.</code> </p>
<p>令人开心的是，这篇博文的作者也顺手给我们提供了一个 bootstrap 的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if ! [ -x "$(command -v docker-compose)" ]; then</span><br><span class="line">  echo 'Error: docker-compose is not installed.' &gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">domains=(example.org www.example.org)</span><br><span class="line">rsa_key_size=4096</span><br><span class="line">data_path="./data/certbot"</span><br><span class="line">email="" # Adding a valid address is strongly recommended</span><br><span class="line">staging=0 # Set to 1 if you're testing your setup to avoid hitting request limits</span><br><span class="line"></span><br><span class="line">if [ -d "$data_path" ]; then</span><br><span class="line">  read -p "Existing data found for $domains. Continue and replace existing certificate? (y/N) " decision</span><br><span class="line">  if [ "$decision" != "Y" ] &amp;&amp; [ "$decision" != "y" ]; then</span><br><span class="line">    exit</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ ! -e "$data_path/conf/options-ssl-nginx.conf" ] || [ ! -e "$data_path/conf/ssl-dhparams.pem" ]; then</span><br><span class="line">  echo "### Downloading recommended TLS parameters ..."</span><br><span class="line">  mkdir -p "$data_path/conf"</span><br><span class="line">  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf &gt; "$data_path/conf/options-ssl-nginx.conf"</span><br><span class="line">  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem &gt; "$data_path/conf/ssl-dhparams.pem"</span><br><span class="line">  echo</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "### Creating dummy certificate for $domains ..."</span><br><span class="line">path="/etc/letsencrypt/live/$domains"</span><br><span class="line">mkdir -p "$data_path/conf/live/$domains"</span><br><span class="line">docker-compose run --rm --entrypoint "\</span><br><span class="line">  openssl req -x509 -nodes -newkey rsa:1024 -days 1\</span><br><span class="line">    -keyout '$path/privkey.pem' \</span><br><span class="line">    -out '$path/fullchain.pem' \</span><br><span class="line">    -subj '/CN=localhost'" certbot</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo "### Starting nginx ..."</span><br><span class="line">docker-compose up --force-recreate -d nginx</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo "### Deleting dummy certificate for $domains ..."</span><br><span class="line">docker-compose run --rm --entrypoint "\</span><br><span class="line">  rm -Rf /etc/letsencrypt/live/$domains &amp;&amp; \</span><br><span class="line">  rm -Rf /etc/letsencrypt/archive/$domains &amp;&amp; \</span><br><span class="line">  rm -Rf /etc/letsencrypt/renewal/$domains.conf" certbot</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo "### Requesting Let's Encrypt certificate for $domains ..."</span><br><span class="line"><span class="meta">#</span><span class="bash">Join <span class="variable">$domains</span> to -d args</span></span><br><span class="line">domain_args=""</span><br><span class="line">for domain in "$&#123;domains[@]&#125;"; do</span><br><span class="line">  domain_args="$domain_args -d $domain"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Select appropriate email arg</span></span><br><span class="line">case "$email" in</span><br><span class="line">  "") email_arg="--register-unsafely-without-email" ;;</span><br><span class="line">  *) email_arg="--email $email" ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enable staging mode <span class="keyword">if</span> needed</span></span><br><span class="line">if [ $staging != "0" ]; then staging_arg="--staging"; fi</span><br><span class="line"></span><br><span class="line">docker-compose run --rm --entrypoint "\</span><br><span class="line">  certbot certonly --webroot -w /var/www/certbot \</span><br><span class="line">    $staging_arg \</span><br><span class="line">    $email_arg \</span><br><span class="line">    $domain_args \</span><br><span class="line">    --rsa-key-size $rsa_key_size \</span><br><span class="line">    --agree-tos \</span><br><span class="line">    --force-renewal" certbot</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo "### Reloading nginx ..."</span><br><span class="line">docker-compose exec nginx nginx -s reload</span><br></pre></td></tr></table></figure>
<p>准备好脚本和 <code>docker-compose.yml</code> 之后，就可以得到网站的证书了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── certbot</span><br><span class="line">│   │   ├── conf</span><br><span class="line">│   │   │   ├── accounts</span><br><span class="line">│   │   │   │   └── acme-v02.api.letsencrypt.org</span><br><span class="line">│   │   │   │       └── directory [error opening dir]</span><br><span class="line">│   │   │   ├── archive [error opening dir]</span><br><span class="line">│   │   │   ├── csr</span><br><span class="line">│   │   │   │   └── 0000_csr-certbot.pem</span><br><span class="line">│   │   │   ├── keys [error opening dir]</span><br><span class="line">│   │   │   ├── live</span><br><span class="line">│   │   │   │   ├── houmin.site</span><br><span class="line">│   │   │   │   │   ├── cert.pem -&gt; ../../archive/houmin.site/cert1.pem</span><br><span class="line">│   │   │   │   │   ├── chain.pem -&gt; ../../archive/houmin.site/chain1.pem</span><br><span class="line">│   │   │   │   │   ├── fullchain.pem -&gt; ../../archive/houmin.site/fullchain1.pem</span><br><span class="line">│   │   │   │   │   ├── privkey.pem -&gt; ../../archive/houmin.site/privkey1.pem</span><br><span class="line">│   │   │   │   │   └── README</span><br><span class="line">│   │   │   │   └── README</span><br><span class="line">│   │   │   ├── options-ssl-nginx.conf</span><br><span class="line">│   │   │   ├── renewal</span><br><span class="line">│   │   │   │   └── houmin.site.conf</span><br><span class="line">│   │   │   ├── renewal-hooks</span><br><span class="line">│   │   │   │   ├── deploy</span><br><span class="line">│   │   │   │   ├── post</span><br><span class="line">│   │   │   │   └── pre</span><br><span class="line">│   │   │   └── ssl-dhparams.pem</span><br><span class="line">│   │   └── www</span><br><span class="line">│   └── nginx</span><br><span class="line">│       └── app.conf</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── init-letsencrypt.sh</span><br></pre></td></tr></table></figure>
<p>这之后，就可以用 <code>docker-compose</code> 启动网站了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"443:443"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/public:/usr/share/nginx/html:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/hexo/nginx:/etc/nginx/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/certbot/conf:/etc/letsencrypt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/certbot/www:/var/www/certbot</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">"/bin/sh -c 'while :; do sleep 6h &amp; wait $$&#123;!&#125;; nginx -s reload; done &amp; nginx -g \"daemon off;\"'"</span></span><br><span class="line">  <span class="attr">certbot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/certbot/conf:/etc/letsencrypt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/certbot/www:/var/www/certbot</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">"/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h &amp; wait $$&#123;!&#125;; done;'"</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>注：如果在申请证书是失败，有可能是因为这个时候 Nginx 没有启动。而 Nginx 没有启动原因有可能是执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem</span><br></pre></td></tr></table></figure><p>命令的时候，在阿里云上 443错误导致没有获得 <code>ssl-dhparams.pem</code> 导致 Nginx 启动失败</p>
          </div>
<p>至此，HTTPS已经配置完毕。</p>
<h3 id="支持-Hexo-Admin"><a href="#支持-Hexo-Admin" class="headerlink" title="支持 Hexo Admin"></a>支持 Hexo Admin</h3><p> 在 <a href="../a63a603e">这篇博文</a> 中，我利用 Hexo Admin 配置了网站后台，但是后来实践起来发现这个功能倒不是很实用，所以在容器化的这篇文章中暂时没有支持 Hexo Admin。等以后如果需要了，可以再配置。</p>
<h2 id="多版本网站支持"><a href="#多版本网站支持" class="headerlink" title="多版本网站支持"></a>多版本网站支持</h2><p>促成这篇文章最主要的动力，是因为阿里云通知我 <code>houmin.site</code> 这个域名备案成功，让我在 2 月份之前将网站的备案加上。那么现在我拥有两份网站，<code>houmin.cc</code> 和 <code>houmin.site</code>，其中 <code>houmin.site</code> 是 <code>houmin.cc</code> 的备份。其中，<code>houmin.cc</code> 是在 AWS 上，<code>houmin.site</code> 是在阿里云上。等 AWS 的一年免费体验结束之后，我需要把 <code>houmin.cc</code> 也迁移到 <code>houmin.site</code>中，到时候可能需要用 Nginx 做反向代理，或者玩玩 traefik 也不错🤔</p>
<p>当网站的一切都版本化和容器化之后，多版本网站显得容易了很多。对于两个网站，分别创建两个branch，网站主要内容相同，区别在于</p>
<ul>
<li>站点配置文件<ul>
<li>url 的配置</li>
<li>Nofollow</li>
</ul>
</li>
<li>NexT 配置文件<ul>
<li>备案</li>
<li>SEO推广</li>
<li>Valine Appid</li>
</ul>
</li>
<li>robots.txt</li>
</ul>
<p>针对上述几点配置之后，每次更新的网站的时候，将更新同步到不同的 branch，推送到不同的 git server 就可以了。</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>Hexo</tag>
        <tag>container</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机体系结构】Cache Memory</title>
    <url>/posts/9bccd097/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本博文是我对计算机系统中的缓存做的备忘笔记，参考资料来自于互联网。</p>
<a id="more"></a>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Memory-Hierarchy"><a href="#Memory-Hierarchy" class="headerlink" title="Memory Hierarchy"></a>Memory Hierarchy</h3><p>众所周知，对于不同的存储设备，更高的性能意味着更高的成本和更小的容量。随着 CPU 越做越快，CPU 和主存之间的速度差距正在不断扩大。好在，<strong>软件的局部性原理</strong> 拯救了这一切，在现代计算机体系中通过 <code>Memory Hierarchy</code> 的设计，使得系统在性能、成本和制造工艺之间作出取舍，从而达到了一个平衡。</p>
<p>下图是现在可以看到的常见的存储器层次机构：</p>
<p><img alt="Memory Hierarchy" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_memory-hierarchy.png"></p>
<h3 id="Principle-of-Locality"><a href="#Principle-of-Locality" class="headerlink" title="Principle of Locality"></a>Principle of Locality</h3><p><code>程序访问的局部性原理</code>指的是，<strong>内存中某个地址被访问后，短时间内还有可能继续访问这块地址。内存中的某个地址被访问后，它相邻的内存单元被访问的概率也很大。</strong></p>
<p>程序访问的局部性包含两种：</p>
<ul>
<li>时间局部性：某个内存单元在较短时间内很可能被再次访问</li>
<li>空间局部性：某个内存单元被访问后相邻的内存单元较短时间内很可能被访问</li>
</ul>
<p>出现这种情况的原因很简单，因为程序是指令和数据组成的，指令在内存中按顺序存放且地址连续，如果运行一段循环程序或调用一个方法，又或者再程序中遍历一个数组，都有可能符合上面提到的局部性原理。</p>
<p>那既然在执行程序时，内存的某些单元很可能会经常的访问或写入，那可否在CPU和内存之间，加一个缓存，CPU在访问数据时，先看一下缓存中是否存在，如果有直接就读取缓存中的数据即可。如果缓存中不存在，再从内存中读取数据。</p>
<p>事实证明利用这种方式，程序的运行效率会提高90%以上，这个缓存也叫做<strong>高速缓存Cache</strong>。</p>
<h2 id="Big-Picture"><a href="#Big-Picture" class="headerlink" title="Big Picture"></a>Big Picture</h2><p>在深入了解 Cache 的技术细节之前，我们可以先看看关于 Cache 在现代计算机系统中的 big picture。如下图所示，ALU 不是直接和主存相连，所有的 load 和 store 通过 Cache 完成，Cache 是 CPU 芯片组成的一部分。</p>
<p><img alt="Cache System Structure" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-system-structure.png"></p>
<p>随着计算机系统的发展，Cache 不仅仅只有一层，可能被分为多层。于此同时，人们发现，将指令的 Cache 和 数据的 Cache 分开可以获得更大的系统增益。而且，CPU也从单核单处理器逐渐发展到多核多处理器，所以一个现代的计算机系统中，Cache 的组成方式可能如下图所示：</p>
<p><img alt="Intel Core i7 Cache Hierarchy" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_intel-core-i7-cache-hierarchy.png"></p>
<p>在这个图中，只显示了一个处理器(Processor)，处理器中有四个核(Core)，每个 Core 会有自己的L1数据缓存和L1指令缓存，也有自己统一的 L2 缓存。四个核之间会共享 L3 缓存，L3 缓存和主存直接沟通。</p>
<h2 id="General-Cache-Organization"><a href="#General-Cache-Organization" class="headerlink" title="General Cache Organization"></a>General Cache Organization</h2><p>Cache 是以 <code>缓存行(Cache Line)</code> 为基本组织单位的，下图是一个通用的缓存组织结构。</p>
<p><img alt="General Cache Organization (S, E, B, m)" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-organization.png"></p>
<p>假设内容容量是 M，内存物理地址为 <code>m</code> 个bit。CPU 在访问缓存时，物理地址会被解析成如下的格式</p>
<p><img alt="Cache Line 地址解析" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-line-address.png"></p>
<p>这里，有如下的关系</p>
<script type="math/tex; mode=display">
\begin{gather}
S = 2^s \\
B = 2^b \\
m = t + s + b \\
\end{gather}</script><p>参数具体意义如下：一个 Cache 被分成 S 个 <code>set</code>，每个 set 有 E 路 Cache Line。在一个 Cache Line 中，有 B 个字节的存储单元。所以，在一个内存地址中，中间的 s 个 bit 决定了该寻址单元被映射到哪个 set，而最低的 b 个 bit 决定了该单元在一个缓存行中的偏移量。<code>tag</code> 是内存地址的高 t 个 bit，因为可能有多个内存地址映射到同一个 Cache Line 中，所以用 tag 来校验该 Cache Line 是否是 CPU 要访问的内存单元。</p>
<p>上面是从内存地址的角度看访问 Cache 时候的地址参数解析，对应到实际的 Cache Line 的组成，可以看第一张图。可以看到，对于每一个 Cache Line，除了 tag 用来校验是否是 CPU 要访问的内存单元，还有一个 <code>valid bit</code> 来确认该缓存行是否有效，然后就是一个含有 $B = 2^b$ 个字节的 <code>Cache Block</code>。在目前的 x86 CPU 的 Cache Line 中，一般都是 64 字节的。</p>
<p>当 tag 和 valid 校验成功时，我们称为 <code>Cache Hit</code>，这时就可以将cache中的单元取出，放入到 CPU 中的寄存器。</p>
<p>当 tag 或 valid 校验失败时，说明要访问的内存单元并不在cache中，需要去内存中或者下一级的 Cache 中取出，这就是 <code>Cache Miss</code>。当不命中的情况发生时，系统就会从内存中或者下一级缓存中取得该单元，将其装入cache中，与此同时也放入CPU寄存器中，等待下一步处理。</p>
<p>下图是一个典型的 Cache Read 的流程</p>
<p><img alt="Cache Read" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-read.png"></p>
<h2 id="Cache-Implement-Details"><a href="#Cache-Implement-Details" class="headerlink" title="Cache Implement Details"></a>Cache Implement Details</h2><p>根据上面参数 E 的不同选择，可以把 Cache 到 Memory 的映射分为以下几种类型</p>
<ul>
<li>全相联(Fully Associative)<ul>
<li>$s = 0$，每个内存块数据可以映射到任意缓存行中</li>
</ul>
</li>
<li>直接映射(Direct Mapped)，也称单路组相连(Single Way Set Associative)<ul>
<li>$E = 1$，每个内存块数据只能映射到固定的缓存行中</li>
</ul>
</li>
<li>多路组相联(N Way Set Associative)<ul>
<li>$E = N$, 每个内存块数据可以映射到固定 set 的任意缓存行中</li>
</ul>
</li>
</ul>
<h3 id="Fully-Associative-Cache"><a href="#Fully-Associative-Cache" class="headerlink" title="Fully Associative Cache"></a>Fully Associative Cache</h3><p>全相联把内存方位两个字段，<code>tag</code> 和 <code>offset</code>，没有了 set index 的字段。</p>
<p>在访问数据时，直接根据内存地址中的 <code>tag</code>，去遍历对比每一个缓存行，直到找到 <code>tag</code>一致的缓存行，然后访问其中的数据。</p>
<p>如果遍历完所有的缓存行之后，没有找到一致的<code>tag</code>, 那么就会从内存中获取数据，然后找到空闲的缓存行，直接写入<code>tag</code>和 数据即可。</p>
<p>全相联意味着主存中的数据块可以出现在任意一个缓存行中。这种方式下替换算法(Replacement Policy)有最大的灵活度，也意味着可以有最低的 <code>Cache Miss Rate</code>。但是因为没有索引可以使用，检查一个缓存行是否命中需要在整个 Cache 范围内搜索，这带来了查找电路的大量延时。因此只有在缓存极小的情况下才有可能使用这种映射方式。</p>
<p><img alt="Fully Associative" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-fully-associative.png"></p>
<h3 id="Direct-Mapped-Cache"><a href="#Direct-Mapped-Cache" class="headerlink" title="Direct Mapped Cache"></a>Direct Mapped Cache</h3><p>直接映射是一种<code>多对一</code>的映射关系。在这种映射下，主存中的每一个数据块只能有一个缓存行与之对应。可能有多个主存中的数据块被映射到统一个缓存行，但是每一个数据块只能被映射到确定的缓存行。</p>
<p>在 1990 年代初期，直接映射是当时最流行的机制。但是随着 CPU 主频的提高，直接映射机制正在逐渐退出舞台。</p>
<p>直接映射最大的问题在于，每个数据块在哪个缓存行是确定的，没有替换策略(Replacement Policy)。如果两个数据块被映射到同一个缓存行时，它们会不停的把对方替换出去。由于严重的冲突，频繁刷新 Cache 会造成大量的延时，而且未能有效利用程序运行期所具有的时间局部性。这样导致了缓存命中率(cache miss rate)明显提高。</p>
<p>下图是一个Memory 为 16Kbytes， Cache Line 为 4bytes 的直接映射缓存例子。</p>
<p><img alt="Direct Mapped" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-direct-mapped.png"></p>
<h3 id="Set-Associative-Cache"><a href="#Set-Associative-Cache" class="headerlink" title="Set Associative Cache"></a>Set Associative Cache</h3><p>组相联映射结合了以上两种映射方式的优点。具体的方法就是</p>
<ul>
<li>首先通过 set index 来确认数据块应该放在哪一个 set 中</li>
<li>确认到 set 之后，通过 cache 替换策略(Replacement Policy)来确定到底放在组中的那个缓存行</li>
</ul>
<p><img alt="Set Associative" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_cache-set-associative.png"></p>
<h2 id="Cache-Replacement-Policy"><a href="#Cache-Replacement-Policy" class="headerlink" title="Cache Replacement Policy"></a>Cache Replacement Policy</h2><p>Cache容量比内存小，所以内存数据映射到Cache时，必然会导致Cache满的情况，那之后的内存映射要替Cache中的哪些行呢？这就需要制定一种策略。</p>
<p>常见的替换算法有如下几种：</p>
<ul>
<li>先进先出算法（FIFO)：总是把最早装入Cache的行替换掉，这种算法实现简单，但不能正确反映程序的访问局部性，命中率不高</li>
<li>最近最少使用算法（LRU)：总是选择最近最少使用的Cache行替换，这种这种算法稍微复杂一些，但可以正确反映程序访问的局部性，命中率最高</li>
<li>最不经常使用算法（LFU）：总是替换掉Cache中引用次数最少的行，与LRU类似，但没有LRU替换方式更精准</li>
<li>随机替换算法（Random）：随机替换掉Cache中的行，与使用情况无关，命中率不高</li>
</ul>
<p>现实使用最多的是最近最少使用算法（LRU)进行Cache行的替换方案，这种方案使得缓存的命中率最高。</p>
<h2 id="Cache-in-Real-World"><a href="#Cache-in-Real-World" class="headerlink" title="Cache in Real World"></a>Cache in Real World</h2><p>可以通过如下的方式查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">----- 如果启动时间比较短，可以通过如下方式查看</span><br><span class="line"><span class="meta">#</span><span class="bash"> dmesg | grep cache</span></span><br><span class="line"></span><br><span class="line">----- 比较详细的硬件信息，包括了Cache的详细信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> dmidecode</span></span><br><span class="line"></span><br><span class="line">----- 查看硬件信息，例如CPU、内存等</span><br><span class="line"><span class="meta">#</span><span class="bash"> lshw</span></span><br><span class="line"></span><br><span class="line">----- 查看CPU相关信息，两者比较类似</span><br><span class="line"><span class="meta">#</span><span class="bash"> lscpu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/cpuinfo</span></span><br></pre></td></tr></table></figure>
<p>另外，由专门针对 x86 信息的程序，也就是 <code>x86info</code> ，可以直接安装对应的包。</p>
<p>注意，现在多数的 CPU 采用的是超线程，也就是说对于一个物理核来说，对于内核看到的是两个，而实际的物理核是一个。</p>
<p>另外，在 <code>/sys/devices/system/cpu/</code> 中包含了一些相关的指标，例如。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">----- 查看cpu0的一级缓存中的有多少组</span><br><span class="line"><span class="meta">#</span><span class="bash"> /sys/devices/system/cpu/cpu0/cache/index0/number_of_sets</span></span><br><span class="line">64</span><br><span class="line">----- 查看cpu0的一级缓存中一组中的行数</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/devices/system/cpu/cpu0/cache/index0/ways_of_associativity</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>通过类似 lscpu 查看到对应 CPU0 的一级缓存大小是 32K ，包含了 64 个组 (sets)，每组有 8 ways，则可以算出每一个 way (也就是 Cache Line) 的大小是 <code>32*1024/(64*8)=64</code> 。</p>
<p>可以通过如下方式查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</span></span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>这里是 Intel Core i7 L1数据缓存的实际例子</p>
<p><img alt="Intel Core i7 L1 Data Cache" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-07_intel-i7-l1-data-cache.png"></p>
<h2 id="Cache-Write"><a href="#Cache-Write" class="headerlink" title="Cache Write"></a>Cache Write</h2><p>试想，如果CPU想要修改某个内存的数据，这块内存的数据刚好在Cache中存在，那么是不是要同时更新Cache中的数据？对于写入的数据，如何保证Cache和内存数据的一致性？</p>
<h3 id="Cache-Write-Hit"><a href="#Cache-Write-Hit" class="headerlink" title="Cache Write Hit"></a>Cache Write Hit</h3><ul>
<li><strong>Write through</strong><ul>
<li>在写操作时，如果Cache命中，则同时写Cache和内存。</li>
</ul>
</li>
<li><strong>Write back</strong><ul>
<li>在写操作时，如果Cache命中，则只更新Cache而不更新内存。</li>
<li>所以每一个 Cache Line需要有一个 dirty bit</li>
</ul>
</li>
</ul>
<h3 id="Cache-Write-Miss"><a href="#Cache-Write-Miss" class="headerlink" title="Cache Write Miss"></a>Cache Write Miss</h3><ul>
<li>Write Allocate<ul>
<li>先更新内存数据，然后再写入空闲的Cache行中，保证Cache有数据，提高了缓存命中率，但增加了写入Cache的开销</li>
</ul>
</li>
<li>No Write Allocate<ul>
<li>只更新内存数据，不写入Cache，只有等访问不命中时，再进行缓存写入 </li>
</ul>
</li>
</ul>
<p>关于缓存一致性的问题，可以参考我的另一篇博文 <a href="http://houmin.cc">Cache Coherency</a>，此处不再赘述。</p>
<h2 id="Cache-Friendly-Code"><a href="#Cache-Friendly-Code" class="headerlink" title="Cache Friendly Code"></a>Cache Friendly Code</h2><p>针对缓存的这种特殊的结构，作为程序猿，如果一不小心，可能会带来重大的性能问题。</p>
<p>一些典型的案例可以参考我的另一篇博文 <a href="http://houmin.cc">Cache Friendly Code</a>，此处不再赘述。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://lwn.net/Articles/252125/" target="_blank" rel="external nofollow noopener noreferrer">https://lwn.net/Articles/252125/</a></li>
<li><a href="http://hedengcheng.com/?p=648" target="_blank" rel="external nofollow noopener noreferrer">http://hedengcheng.com/?p=648</a></li>
<li>CMU 15213 Cache Memories Slide</li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Do You Want To Build A Snowman?</title>
    <url>/posts/c924112f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是 2020 年 「朝花夕拾」第二期，这一期我们来聊一聊 <code>个人知识管理</code></p>
<p>哦对了，上周的「朝花夕拾」发布之后，北京就迎来了 2020 年的第一场雪。冬雪覆盖的燕园美丽的让人心醉，今天的封面图是大雪的第二天早上在学校转悠的时候拍的。古色古香的静园，加上堆雪人的活泼小姐姐们，很喜欢。</p>

    <div id="aplayer-aXpMdlFQ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28031114" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<h2 id="路上的风景"><a href="#路上的风景" class="headerlink" title="路上的风景"></a>路上的风景</h2><p>今年的雪特别的多，没过几天，又下了 2020 的第一场雪。趁着大雪，又拿着相机在学校到处拍了好些，这里是其中的些许片段。</p>
<p><img alt="冰雪中仍然在工作的雷达气象车" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-05_snow-car.jpg"></p>
<p><img alt="一直想拍的大眼睛" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-05_big-eye.jpg"></p>
<p><img alt="走到百讲，晚上大学中风雪中飘舞的国旗" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-05_flag.jpg"></p>
<p><img alt="雪中的枝丫" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-05_snow-branch.jpg"></p>
<p><img alt="快回到宿舍，还在抓紧时间送外卖的小哥" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-05_carrier.jpg"></p>
<p>第二天早上起来，继续拍照，哈哈哈</p>
<p><img alt="从燕南过去，不知哪位聪明的小可爱在墙上种上了小鸭子" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_snow-duck.jpg"></p>
<p><img alt="其实，我的第一反应是葫芦娃，哈哈哈哈" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_calabash.jpg"></p>
<p><img alt="二体" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_roof.jpg"></p>
<p><img alt="在静园堆雪人的小姐姐们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_build-snowman.jpg"></p>
<p><img alt="玲珑剔透的南北阁" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_south-north.jpg"></p>
<p><img alt="大雅之堂" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_daya.jpg"></p>
<p><img alt="风雪中的塞万提斯" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-06_cervantes.jpg"></p>
<h2 id="一周复盘"><a href="#一周复盘" class="headerlink" title="一周复盘"></a>一周复盘</h2><p>复盘的基准仍然是数据。根据上次总结的四个工具，这次来好好复盘一下过去一周的工作和生活。</p>
<h3 id="Rescue-Time"><a href="#Rescue-Time" class="headerlink" title="Rescue Time"></a>Rescue Time</h3><p>在过去的一周里，我用通过 Rescue Time 统计的时间达到了 83 个小时，平均每天记录 12 个小时。Productive Time 为 34 个小时，平均每天 Productive Time 为 5 个小时。</p>
<p><img alt="Rescue Time Week Report - Jan 5 ~ Jan 11, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-12_rescue-time-week-report.png"></p>
<ul>
<li>按照每天 8小时睡眠的话，一天的有效时间是16 个小时。</li>
<li>按照早上 3 个小时，中午 4 个小时，晚上 3 个小时的话，一天的可以工作的时间为 10 个小时。不可能每时每刻都在工作，按照 80% 的能效比，Productive Time 为 8 小时。</li>
</ul>
<p>鉴于过去一周包括生病和运动等其他的时间，总体上这个最终有日均 5 小时的产出时间还是很满意的。显而易见，Red Part 主要是微信、微博和 B 站的时间，这也是我每天消耗时间最多的几个 App。倒也不是说，用这几个 App 都一定是在划水，比如有时候会用 B 站看一些学习的视频，有时候用微信公众号看一些有意思的文章。Anyway，姑且用这个分类，在下周的话，期待自己的日均 Productive Time 能够达到 6 个小时。在 Productive Time 里面，目前主要是写作和后期，代码写的还不是很多，期待以后在产出时间上会更加的多样性。</p>
<h3 id="Google-Calender-和-Forest"><a href="#Google-Calender-和-Forest" class="headerlink" title="Google Calender 和 Forest"></a>Google Calender 和 Forest</h3><p>在过去的一周，我基本上把 <code>Google Calender</code>当做了自己的日记本。不仅能够记录下每天的所有行程，做明日计划，还能够通过每日总结直接在上面记录复盘一天的所有的得失。这种数据采集方式，我很满意。</p>
<p>对于 Forest，主要就是在番茄工作法的时候使用。目前对于这个的使用程度还不是很熟练，好像是可有可无？但是如果记起来的话，确实能够很大程度的减少你耍手机的频率。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Google Calender - Jan 5 ~ Jan 11, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-12_google-calender.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Forest - Jan 5 ~ Jan 11, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-12_forest.jpg"></div></div></div></div>
<p>可以看到，过去一周</p>
<ul>
<li>基本上保持在 8 点半能够起床，12 点前睡觉。虽然和我自己定的早睡早起的目标还有差距，但是继续努力嘛</li>
<li>一周能够运动三次，虽然这周只是跑了 10 公里，没有达到 15 公里，但是生病了还是可以理解的</li>
<li>卡林巴琴在这周后半段有点懈怠了，最近想练伴奏版青花瓷，还需继续努力</li>
<li>本周的开始，本来是想把之前无锁队列的坑给填了，但是做的时候还有越来越多的坑需要去填，最后是完成了两篇总结性的技术博客，下周争取完成这个系列</li>
<li>校园采风三次，两次大雪，一次是第一次上了理二的九楼</li>
<li>最后两天也是病恹恹的，一口气看了 3 部电影</li>
<li>总体上还算 OK，但是是不是太单调？下周出去转转？</li>
</ul>
<h3 id="Trello"><a href="#Trello" class="headerlink" title="Trello"></a>Trello</h3><p>在过去的一周，我的 Trello 的「朝花夕拾」看板里面把所有的事情分为</p>
<ul>
<li>2020 年度目标    -&gt;    主要是 2020 年想要完成的目标</li>
<li>Hold                    -&gt;    不紧急但是需要做的事情但是被搁置的事情</li>
<li>To Do                  -&gt;    最近要做的事情</li>
<li>Doing                  -&gt;    当前正在做的事情</li>
<li>Done                   -&gt;    已经完成的事情</li>
<li>Inbox                   -&gt;    突然想起但是还没有排期的事情</li>
<li>White Note          -&gt;    一些有意思的课题</li>
</ul>
<p>经过一周的实践，现在尝试做一点简单的修正。正如我曾经说过，如果你想要做成一件事情，那么你首先要 <code>set a goal</code>, 然后根据这个 goal 你要 <code>set a plan</code>，接下来就是 <code>follow the plan and adjust it according your state</code>。（或者关于目标这个话题下次可以再聊一期？）</p>
<p>很明显，在我的这个看板中，我设定了一个一年期的中长期目标。但是，正如所有的年度目标一样，如果没有一个切实的短期目标和计划的话，过了一段时间个人的轨迹就很容易和目标偏离。幸好呀，我们还有定期的复盘：）</p>
<p>根据过去的经验，我把看板重新调整为以下样式，下周再试行一周。</p>
<p><img alt="Trello Board" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-12_trello.png"></p>
<h3 id="小日常"><a href="#小日常" class="headerlink" title="小日常"></a>小日常</h3><p>emmm…这个工具的数据采集工作这周只用了 3 天，后面完全忘记。</p>
<p>下周再看看？不然，这个工具可能就要被淘汰了…</p>
<h2 id="个人知识管理"><a href="#个人知识管理" class="headerlink" title="个人知识管理"></a>个人知识管理</h2><p>Finally，总算到了这周的主题，<code>个人知识管理</code>，也就是 <code>PKM(Personal Knowledge Management)</code></p>
<p>这是一个长期以来伴随我们整个学生时代的课题。在工作之后，这个课题也将会继续存在。这一期，我不追求能够给自己定下一个完美的知识管理范式，只是期待能够有一个简单的开始。根据之前十几年的经验，能够总结出一个也许粗略的模型，和一些持久易用的工具。在面向未来几十年的时间里，这个模型能够动态的变化和修正，以期未来能够更好的符合我的节奏。</p>
<h3 id="DIKW"><a href="#DIKW" class="headerlink" title="DIKW"></a>DIKW</h3><p>在 <code>知识管理</code> 领域有一个经典的 <code>DIKW</code> 体系，DIKW是即 <code>Data, Information, Knowledge, Wisdom</code>。这个体系最早可以追溯到诗人 <code>Thomas Stearns Eliot</code>的诗：</p>
<blockquote>
<p>Where is the life we have lost in living ?</p>
<p>Where is the wisdom we have lost in knowledge ?</p>
<p>Where is the knowledge we have lost in information ?</p>
</blockquote>
<p>下面是该模型的具体内容</p>
<p><img alt="DIKW Pyramid" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-14_dimw-pyramid-adaptation.png"></p>
<ul>
<li><code>Data</code>是即在上一周我认真谈过的数据，是我们从各个地方采集到的原始数据</li>
<li><code>Information</code> 是我们从数据从提取出来的信息，需要我们有选择的从数据中去掉无用的噪声和干扰信息 —&gt; 对应于 <code>What</code></li>
<li><code>Knowledge</code> 是我们对信息进一步加工整理，从众多信息中发现信息之间的关系，并提炼出的规范化、体系化的知识 —&gt; 对应于 <code>How</code></li>
<li><code>Wisdom</code> 是对知识的灵活整理和创造性运用，智慧的生成过程是知识的内化过程 —&gt; 对应于 <code>Why</code></li>
</ul>
<p>其实这个模型就对应着我们对于知识从输入到内化的整个过程，知识体系化之后就可以自如的向外输出，乃至总结出属于自己的智慧。</p>
<p>生活中经常会遇见的一个问题是，读过一本书或者一篇文章之后，当时觉得很好，但是过段时间之后，再让自己说些什么的时候，却言之无物。为什么呢？这就是典型的缺乏内化的过程。</p>
<p><strong>读了那么多书，却仍然一无所知</strong></p>
<ul>
<li>免费让我们获得各种有用和无用的知识，但却没有一个很好的吸收消化方式；<ul>
<li>学会内化，将看到知识分类，转化为自己的知识体系</li>
</ul>
</li>
<li>穿梭在信息流中，常常感觉自己会了很多，又突然感觉自己什么都不会，没有沉淀下来的知识；<ul>
<li>知识输出，提升自己的思考深度，持续迭代</li>
</ul>
</li>
</ul>
<p>在我看来，一个知识内化的过程应该是下面这样的 Pipeline:</p>
<pre class="mermaid">graph LR
Input[输入] --> Collect(收集)
Collect --> System[系统化]
System --> Output(输出)</pre>

<p>针对于这个 Pipeline，下面我会探讨一下现在常用的工具</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>在我看来，信息收集分为两类：</p>
<ul>
<li>主动式信息收集：自己有问题，去上网查询、去看书，根据问题去爬取获得相应的信息</li>
<li>被动式信息收集：订阅一些优质微信公众号、订阅 RSS 信息源，刷微博等等</li>
</ul>
<p>主动的信息收集，有一个最常见的思路，就是用书签。但是历史的经验告诉我，看到了一些好的内容，如果只是用书签收藏下来，绝大多数的情况是并不会再去打开。既然这样，还不如一开始就一次性的纳入到自己的整理箱，从而更快速的归于整体的知识体系的一部分。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/書籤_(瀏覽器" target="_blank" rel="external nofollow noopener noreferrer">书签 (万维网) - 维基百科，自由的百科全书</a>)：<strong>书签</strong>是<a href="https://zh.wikipedia.org/wiki/瀏覽器" target="_blank" rel="external nofollow noopener noreferrer">浏览器</a>中用以存储<a href="https://zh.wikipedia.org/wiki/網址" target="_blank" rel="external nofollow noopener noreferrer">网址</a>的一个设计，方便用户不须以纸笔抄写或记住网址即能迅速链接至网站。所有现代网页浏览器都有书签功能。书签在<a href="https://zh.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="external nofollow noopener noreferrer">Internet Explorer</a>中叫<strong>收藏夹</strong>（简体中文）或<strong>我的最爱</strong>（繁体中文）。</p>
</blockquote>
<p>从 Wiki 的解释就可以看出，书签在最初被设计时（可想而知当时的门户网页其实很少）的功能应当更加偏向于如何<strong>让用户更快抵达某一网站</strong>，作为用户所收藏的网页集合而不至于每次都要重新输入链接。从这个角度来理解现在网络环境下的书签功能，则更应当只是把它<strong>作为常用网站首页（即主站）的索引，而不是存储资料的方式</strong>，毕竟保存的链接是有可能失效的，而保存的内容则永远不会发生变化。</p>
<p>比如在搜索一些资料的时候，在当前因为各种原因看不了，我们可以很简单的直接用印象笔记的 <code>Web Clipper</code> 插件直接将其保存到印象笔记的 <code>Inbox</code> 笔记本。收集完成之后，则需要我们通过定期总结去消化它。</p>
<p>对于被动接受的一些信息，可以通过 <code>Read it later</code>工具，这里我用的是 <code>Pocket</code>。基本上你在刷微信、知乎、微博的时候，觉得有意思可以再读一次的内容可以直接发送到Pocket，然后在合适的时间去消化处理吸收。</p>
<p>在 <code>Pocket</code> 中，如果觉得某一篇特别有价值，可以利用 IFTTT 工具直接保存在 EverNote。</p>
<h3 id="知识内化"><a href="#知识内化" class="headerlink" title="知识内化"></a>知识内化</h3><p>关于知识内化的几个误区：</p>
<ul>
<li>逃离记忆：任何事情百度一下，不需要再专门记录了，遇到再百度<ul>
<li>搜索成本一次次重复，而且下次未必能找到，永远不是自己的。比如excel函数</li>
</ul>
</li>
<li>记忆和内化一样：背下来就行<ul>
<li>背诵是一方面，了解逻辑并融入自己的理解是另一方面。看了直通车打款计划，但店铺和自己的品类、体量、推广费用都没有可比性。</li>
</ul>
</li>
<li>过于依赖：保存在电脑中就不用记了<ul>
<li>依赖一些知识存储后，只要用到再搜索。关键常调用知识还需要记忆，提升效率；另外知识组块，比如新零售概念等，脑中要随时有，才能持续迸发创意。</li>
</ul>
</li>
<li>多重复来记忆：脑子不好只能多看<ul>
<li>利用必要难度、间隔记忆、遗忘曲线、复述意识、图像记忆等（思维导图的视觉化可以起到很好提升记忆效果）</li>
</ul>
</li>
</ul>
<h4 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h4><p>Wiki 是组织知识非常有效的形式，维基百科就是一个最成功的范例。之前曾经用 <code>MediaWiki</code> 搭过一套自己的 wiki 平台，但是后来没有持续性的维护，就放弃了。现在可以在自己的博客中，在不同博文之间链接，也能够基本实现 wiki 的功能。</p>
<p>现在这个还在探索中。</p>
<h4 id="Mindmap"><a href="#Mindmap" class="headerlink" title="Mindmap"></a>Mindmap</h4><p>思维导图对于思路整理是一个非常有效的工具。现在准备用 Xmind 作为自己的思维导图工具。</p>
<p>持续性探索中。</p>
<h4 id="EverNote"><a href="#EverNote" class="headerlink" title="EverNote"></a>EverNote</h4><p>现在用的是印象笔记作为自己的笔记类应用（EverNote 的中国区版本），加上有道云笔记作为辅助。</p>
<p>持续性探索中。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>PKM</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机体系结构】NUMA架构详解</title>
    <url>/posts/b893097a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本博文是我对计算机系统中的NUMA 架构做的备忘笔记，参考资料来自于互联网。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="SMP-VS-AMP"><a href="#SMP-VS-AMP" class="headerlink" title="SMP VS. AMP"></a>SMP VS. AMP</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing" target="_blank" rel="external nofollow noopener noreferrer">SMP(Symmetric Multiprocessing)</a>， 即对称多处理器架构，是目前最常见的多处理器计算机架构。</li>
<li><a href="https://en.wikipedia.org/wiki/Asymmetric_multiprocessing" target="_blank" rel="external nofollow noopener noreferrer">AMP(Asymmetric Multiprocessing)</a>， 即非对称多处理器架构，则是与SMP相对的概念。</li>
</ul>
<p>那么两者之间的主要区别是什么呢？ 总结下来有这么几点，</p>
<ol>
<li>SMP的多个处理器都是同构的，使用相同架构的CPU；而AMP的多个处理器则可能是异构的。</li>
<li>SMP的多个处理器共享同一内存地址空间；而AMP的每个处理器则拥有自己独立的地址空间。</li>
<li>SMP的多个处理器操通常共享一个操作系统的实例；而AMP的每个处理器可以有或者没有运行操作系统， 运行操作系统的CPU也是在运行多个独立的实例。</li>
<li>SMP的多处理器之间可以通过共享内存来协同通信；而AMP则需要提供一种处理器间的通信机制。</li>
</ol>
<p>SMP和AMP的深入介绍很多经典文章书籍可参考，此处不再赘述。现今主流的x86多处理器服务器都是SMP架构的， 而很多嵌入式系统则是AMP架构的。</p>
<h3 id="NUMA-VS-UMA"><a href="#NUMA-VS-UMA" class="headerlink" title="NUMA VS. UMA"></a>NUMA VS. UMA</h3><p><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access" target="_blank" rel="external nofollow noopener noreferrer">NUMA(Non-Uniform Memory Access)</a> 非均匀内存访问架构是指多处理器系统中，内存的访问时间是依赖于处理器和内存之间的相对位置的。 这种设计里存在和处理器相对近的内存，通常被称作本地内存；还有和处理器相对远的内存， 通常被称为非本地内存。</p>
<p><a href="https://en.wikipedia.org/wiki/Uniform_memory_access" target="_blank" rel="external nofollow noopener noreferrer">UMA(Uniform Memory Access)</a> 均匀内存访问架构则是与NUMA相反，所以处理器对共享内存的访问距离和时间是相同的。</p>
<p>由此可知，不论是NUMA还是UMA都是SMP架构的一种设计和实现上的选择。</p>
<p>阅读文档时，也常常能看到<strong>ccNUMA(Cache Coherent NUMA)</strong>，即缓存一致性NUMA架构。 这种架构主要是在NUMA架构之上保证了多处理器之间的缓存一致性。降低了系统程序的编写难度。</p>
<p>x86多处理器发展历史上，早期的多核和多处理器系统都是UMA架构的。这种架构下， 多个CPU通过同一个北桥(North Bridge)芯片与内存链接。北桥芯片里集成了内存控制器(Memory Controller)，</p>
<p>下图是一个典型的早期 x86 UMA 系统，四路处理器通过 FSB (前端系统总线, Front Side Bus) 和主板上的内存控制器芯片 (MCH, Memory Controller Hub) 相连，DRAM 是以 UMA 方式组织的，延迟并无访问差异。</p>
<p><img alt="x86 UMA" data-src="http://oliveryang.net/media/images/2018/numa-fsb-3.png"></p>
<blockquote>
<p>注：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Platform_Controller_Hub" target="_blank" rel="external nofollow noopener noreferrer">PCH(Platform Controller Hub)</a>，Intel 于 2008 年起退出的一系列晶片组，用于取代以往的 I/O Controller Hub（ICH)</li>
</ul>
</blockquote>
<p>在 UMA 架构下，CPU 和内存控制器之间的前端总线 (FSB) 在系统 CPU 数量不断增加的前提下， 成为了系统性能的瓶颈。因此，AMD 在引入 64 位 x86 架构时，实现了 NUMA 架构。之后， Intel 也推出了 x64 的 Nehalem 架构，x86 终于全面进入到 NUMA 时代。x86 NUMA 目前的实现属于 ccNUMA。</p>
<p>从 Nehalem 架构开始，x86 开始转向 NUMA 架构，内存控制器芯片被集成到处理器内部，多个处理器通过 QPI 链路相连，从此 DRAM 有了远近之分。 而 Sandybridge 架构则更近一步，将片外的 IOH 芯片也集成到了处理器内部，至此，内存控制器和 PCIe Root Complex 全部在处理器内部了。 下图就是一个典型的 x86 的 NUMA 架构：</p>
<p><img alt="x86 典型 NUMA 架构" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-09_numa-imc-iio-smb.png"></p>
<div class="note info">
            <p><img alt="Intel 处理器微架构路线" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-09-Intel-Processor-Roadmap.png"></p>
          </div>
<h2 id="NUMA-Hierarchy"><a href="#NUMA-Hierarchy" class="headerlink" title="NUMA Hierarchy"></a>NUMA Hierarchy</h2><h3 id="NUMA-Node-内部"><a href="#NUMA-Node-内部" class="headerlink" title="NUMA Node 内部"></a>NUMA Node 内部</h3><p>一个NUMA Node内部是由一个<strong>物理CPU</strong>和它所有的<strong>本地内存(Local Memory)</strong>组成的。广义得讲， 一个NUMA Node内部还包含<strong>本地IO资源</strong>，对大多数Intel x86 NUMA平台来说，主要是PCIe总线资源。 ACPI规范就是这么抽象一个NUMA Node的。</p>
<h4 id="物理-CPU"><a href="#物理-CPU" class="headerlink" title="物理 CPU"></a>物理 CPU</h4><p>一个CPU Socket里可以由多个CPU Core和一个Uncore部分组成。每个CPU Core内部又可以由两个CPU Thread组成。 每个CPU thread都是一个操作系统可见的逻辑CPU。对大多数操作系统来说，一个八核HT打开的CPU会被识别为16个CPU。 下面就说一说这里面相关的概念，</p>
<ul>
<li><p>Socket</p>
<p>一个Socket对应一个物理CPU。 这个词大概是从CPU在主板上的物理连接方式上来的，可以理解为 Socket 就是主板上的 CPU 插槽。处理器通过主板的Socket来插到主板上。 尤其是有了多核(Multi-core)系统以后，Multi-socket系统被用来指明系统到底存在多少个物理CPU。</p>
</li>
<li><p>Node</p>
<p>NUMA体系结构中多了Node的概念，这个概念其实是用来解决core的分组的问题。每个node有自己的内部CPU，总线和内存，同时还可以访问其他node内的内存，NUMA的最大的优势就是可以方便的增加CPU的数量。通常一个 Socket 有一个 Node，也有可能一个 Socket 有多个 Node。</p>
</li>
<li><p>Core</p>
<p>CPU的运算核心。 x86的核包含了CPU运算的基本部件，如逻辑运算单元(ALU), 浮点运算单元(FPU), L1和L2缓存。 一个Socket里可以有多个Core。如今的多核时代，即使是Single Socket的系统， 也是逻辑上的SMP系统。但是，一个物理CPU的系统不存在非本地内存，因此相当于UMA系统。</p>
</li>
<li><p>Uncore</p>
<p>Intel x86物理CPU里没有放在Core里的部件都被叫做Uncore。Uncore里集成了过去x86 UMA架构时代北桥芯片的基本功能。 在Nehalem时代，内存控制器被集成到CPU里，叫做iMC(Integrated Memory Controller)。 而PCIe Root Complex还做为独立部件在IO Hub芯片里。到了SandyBridge时代，PCIe Root Complex也被集成到了CPU里。 现今的Uncore部分，除了iMC，PCIe Root Complex，还有QPI(QuickPath Interconnect)控制器， L3缓存，CBox(负责缓存一致性)，及其它外设控制器。</p>
</li>
<li><p>Threads</p>
<p>这里特指CPU的多线程技术。在Intel x86架构下，CPU的多线程技术被称作超线程(Hyper-Threading)技术。 Intel的超线程技术在一个处理器Core内部引入了额外的硬件设计模拟了两个逻辑处理器(Logical Processor)， 每个逻辑处理器都有独立的处理器状态，但共享Core内部的计算资源，如ALU，FPU，L1，L2缓存。 这样在最小的硬件投入下提高了CPU在多线程软件工作负载下的性能，提高了硬件使用效率。 x86的超线程技术出现早于NUMA架构。</p>
</li>
</ul>
<h3 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h3><p>在Intel x86平台上，所谓本地内存，就是CPU可以经过Uncore部件里的iMC访问到的内存。而那些非本地的， 远程内存(Remote Memory)，则需要经过QPI的链路到该内存所在的本地CPU的iMC来访问。 曾经在Intel IvyBridge的NUMA平台上做的内存访问性能测试显示，远程内存访问的延时时本地内存的一倍。</p>
<p>可以假设，操作系统应该尽量利用本地内存的低访问延迟特性来优化应用和系统的性能。</p>
<h3 id="本地-IO-资源"><a href="#本地-IO-资源" class="headerlink" title="本地 IO 资源"></a>本地 IO 资源</h3><p>如前所述，Intel自从SandyBridge处理器开始，已经把PCIe Root Complex集成到CPU里了。 正因为如此，从CPU直接引出PCIe Root Port的PCIe 3.0的链路可以直接与PCIe Switch或者PCIe Endpoint相连。 一个PCIe Endpoint就是一个PCIe外设。这就意味着，对某个PCIe外设来说，如果它直接于哪个CPU相连， 它就属于哪个CPU所在的NUMA Node。</p>
<p>与本地内存一样，所谓本地IO资源，就是CPU可以经过Uncore部件里的PCIe Root Complex直接访问到的IO资源。 如果是非本地IO资源，则需要经过QPI链路到该IO资源所属的CPU，再通过该CPU PCIe Root Complex访问。 如果同一个NUMA Node内的CPU和内存和另外一个NUMA Node的IO资源发生互操作，因为要跨越QPI链路， 会存在额外的访问延迟问题。</p>
<p>其它体系结构里，为降低外设访问延迟，也有将IB(Infiniband)总线集成到CPU里的。 这样IB设备也属于NUMA Node的一部分了。</p>
<p>可以假设，操作系统如果是NUMA Aware的话，应该会尽量针对本地IO资源低延迟的优点进行优化。</p>
<p><img alt="PCIe Root Complex Location" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-09_pcie-root-complex.png"></p>
<h3 id="NUMA-Node-互联"><a href="#NUMA-Node-互联" class="headerlink" title="NUMA Node 互联"></a>NUMA Node 互联</h3><p>在Intel x86上，NUMA Node之间的互联是通过 <a href="https://en.wikipedia.org/wiki/Intel_QuickPath_Interconnect" target="_blank" rel="external nofollow noopener noreferrer">QPI((QuickPath Interconnect) Link</a>的。 CPU的Uncore部分有QPI的控制器来控制CPU到QPI的数据访问。</p>
<p>下图就是一个利用 QPI Switch 互联的 8 NUMA Node 的 x86 系统，</p>
<p><img alt="img" data-src="http://oliveryang.net/media/images/2018/numa-imc-iio-qpi-switch-3.png"></p>
<h2 id="NUMA-Affinity"><a href="#NUMA-Affinity" class="headerlink" title="NUMA Affinity"></a>NUMA Affinity</h2><p>NUMA Affinity(亲和性)是和NUMA Hierarchy(层级结构)直接相关的。对系统软件来说， 以下两个概念至关重要，</p>
<ul>
<li><p><strong>CPU NUMA Affinity</strong></p>
<p>CPU NUMA的亲和性是指从CPU角度看，哪些内存访问更快，有更低的延迟。如前所述， 和该CPU直接相连的本地内存是更快的。操作系统如果可以根据任务所在CPU去分配本地内存， 就是基于CPU NUMA亲和性的考虑。因此，CPU NUMA亲和性就是要尽量让任务运行在本地的NUMA Node里。</p>
</li>
<li><p><strong>Device NUMA Affinity</strong></p>
<p>设备NUMA亲和性是指从PCIe外设的角度看，如果和CPU和内存相关的IO活动都发生在外设所属的NUMA Node， 将会有更低延迟。这里有两种设备NUMA亲和性的问题，</p>
<ol>
<li><p><strong>DMA Buffer NUMA Affinity</strong></p>
<p>大部分PCIe设备支持DMA功能的。也就是说，设备可以直接把数据写入到位于内存中的DMA缓冲区。 显然，如果DMA缓冲区在PCIe外设所属的NUMA Node里分配，那么将会有最低的延迟。 否则，外设的DMA操作要跨越QPI链接去读写另外一个NUMA Node里的DMA缓冲区。 因此，操作系统如果可以根据PCIe设备所属的NUMA node分配DMA缓冲区， 将会有最好的DMA操作的性能。</p>
</li>
<li><p><strong>Interrupt NUMA Affinity</strong></p>
<p>设备DMA操作完成后，需要在CPU上触发中断来通知驱动程序的中断处理例程(ISR)来读写DMA缓冲区。 很多时候，ISR触发下半部机制(SoftIRQ)来进入到协议栈相关(Network，Storage)的代码路径来传送数据。 对大部分操作系统来说，硬件中断(HardIRQ)和下半部机制的代码在同一个CPU上发生。 因此，DMA缓冲区的读写操作发生的位置和设备硬件中断(HardIRQ)密切相关。假设操作系统可以把设备的硬件中断绑定到自己所属的NUMA node， 那之后中断处理函数和协议栈代码对DMA缓冲区的读写将会有更低的延迟。</p>
</li>
</ol>
</li>
</ul>
<h2 id="Firmware-接口"><a href="#Firmware-接口" class="headerlink" title="Firmware 接口"></a>Firmware 接口</h2><p>由于NUMA的亲和性对应用的性能非常重要，那么硬件平台就需要给操作系统提供接口机制来感知硬件的NUMA层级结构。 在x86平台，<a href="http://acpi.info/" target="_blank" rel="external nofollow noopener noreferrer">ACPI规范</a>提供了以下接口来让操作系统来检测系统的NUMA层级结构。</p>
<p>ACPI 5.0a规范的第17章是有关NUMA的章节。ACPI规范里，NUMA Node被第9章定义的Module Device所描述。 ACPI规范里用<strong>Proximity Domain</strong>对NUMA Node做了抽象，两者的概念大多时候等同。</p>
<ul>
<li><p><strong>SRAT(System Resource Affinity Table)</strong></p>
<p>主要描述了系统boot时的CPU和内存都属于哪个Proximity Domain(NUMA Node)。 这个表格里的信息时静态的，如果是启动后热插拔，需要用OSPM的_PXM方法去获得相关信息。</p>
</li>
<li><p><strong>SLIT(System Locality Information Table)</strong></p>
<p>提供CPU和内存之间的位置远近信息。在SRAT表格里，只能告诉给定的CPU和内存是否在一个NUMA Node。 对某个CPU来说，不在本NUMA Node里的内存，即远程内存们是否都是一样的访问延迟取决于NUMA的拓扑有多复杂(QPI的跳数)。 总之，对于不能简单用<strong>远近</strong>来描述的NUMA系统(QPI存在0，1，2等不同跳数)， 需要SLIT表格给出进一步的说明。同样的，这个表格也是静态表格，热插拔需要使用OSPM的_SLI方法。</p>
</li>
<li><p><strong>DSDT(Differentiated System Description Table)</strong></p>
<p>从Device NUMA角度看，这个表格给出了系统boot时的外设都属于哪个Proximity Domain(NUMA Node)。</p>
</li>
</ul>
<p>ACPI规范OSPM(Operating System-directed configuration and Power Management) 和OSPM各种方法就是操作系统里的ACPI驱动和ACPI firmware之间的一个互动的接口。 x86启动OS后，没有ACPI之前，firmware(BIOS)的代码是无法被执行了，除非通过SMI中断处理程序。 但有了ACPI，BIOS提前把ACPI的一些静态表格和AML的bytecode代码装载到内存， 然后ACPI驱动就会加载AML的解释器，这样OS就可以通过ACPI驱动调用预先装载的AML代码。 AML(ACPI Machine Language)是和Java类似的一种虚拟机解释型语言，所以不同操作系统的ACPI驱动， 只要有相同的虚拟机解释器，就可以直接从操作系统调用ACPI写好的AML的代码了。 所以，前文所述的所有热插拔的OSPM方法，其实就是对应ACPI firmware的AML的一段函数代码而已。 (关于ACPI的简单介绍，这里给出两篇延伸阅读：<a href="http://rdist.root.org/2008/10/17/all-about-acpi/" target="_blank" rel="external nofollow noopener noreferrer">1</a> 和<a href="https://www.usenix.org/legacy/events/usenix02/tech/freenix/full_papers/watanabe/watanabe_html/index.html" target="_blank" rel="external nofollow noopener noreferrer">2</a>。)</p>
<h2 id="NUMA-Optimization"><a href="#NUMA-Optimization" class="headerlink" title="NUMA Optimization"></a>NUMA Optimization</h2><ul>
<li><a href="https://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/</a></li>
<li><a href="https://frankdenneman.nl/2016/07/08/numa-deep-dive-part-2-system-architecture/" target="_blank" rel="external nofollow noopener noreferrer">https://frankdenneman.nl/2016/07/08/numa-deep-dive-part-2-system-architecture/</a></li>
<li><a href="http://oliveryang.net/2016/02/linux-numa-optimization-1/" target="_blank" rel="external nofollow noopener noreferrer">http://oliveryang.net/2016/02/linux-numa-optimization-1/</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>numa</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊行业</title>
    <url>/posts/8082c63c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>每个行业确实都存在知识壁垒，也从不缺利用行业壁垒忽悠甚至行骗的投机者……我相信行业的知识壁垒都有其最大载重量，每一个从业者 UP 主的出现，都是在加速壁垒的灭亡。</p>
</blockquote>
<p>这是来自 B站 UP 主 「巫师财经」在 2019 年终总结说的一段话，也是本期「朝花夕拾」话题来源。最近开始对行业研究产生兴趣，越发感受到每一个行业都有自己的一套运行规则，每一个行业都有自己的行业周期。有时候和不同专业的同学聊天，听他们讲自己行业的种种，会觉得是一件很有意思的事情。</p>
<p>这里是「朝花夕拾」第三期，我们来聊一聊行业，并以 <code>新能源汽车产业链</code> 作为一个基本范例，看一看<code>行业研究</code>是如何对一个行业建模分析的。本篇算是「行业研究」的开篇，这里先挖个坑，以后还会慢慢去挖其他各个行业有意思的事情。作为信息行业的从业者，这里的文章内容大部分来自网络搜索的资料，不能确保内容的完全正确性，但是也算是初窥门径，之后深入了解的时候总可以按图索骥。</p>
<a id="more"></a>
<h2 id="行业研究"><a href="#行业研究" class="headerlink" title="行业研究"></a>行业研究</h2><h3 id="行业分类"><a href="#行业分类" class="headerlink" title="行业分类"></a>行业分类</h3><p>要进行行业研究的话，首先要对我们身边的行业分类有一个基本的认识。我查了一下国家统计局归纳的<a href="http://www.stats.gov.cn/tjsj/tjbz/201709/P020171009408912690353.pdf" target="_blank" rel="external nofollow noopener noreferrer">国民经济行业分类</a>，整理了一下得到了下面的行业分类思维导图。</p>
<embed src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-24_industry.svg
" style="display:block;width:100%;height:100%" onclick>

<p>总的来说，行业分类是一个持续动态变化的过程。就像细胞一样，行业有成长、有消亡，也总会有新的行业产生。</p>
<h3 id="行业研究框架"><a href="#行业研究框架" class="headerlink" title="行业研究框架"></a>行业研究框架</h3><p>行业研究是我们能够快速建立一个行业认知的基本途径。最简单的做法，就是通过网络等各种信息渠道去看各种行业研报。然而研报纷纷杂杂，看研报之前，最好有自己的一套思考框架。我们要意识到，各种行业都在做着自己的生意，生意的本质就是将产品（What）以什么方式（How）卖给谁（Who）。简单的说，你需要弄清楚下面的这些问题</p>
<ul>
<li>这个行业的盈利模式是什么？ </li>
<li>这个行业的老大是谁？ </li>
<li>这个行业的上游供应链，下游消费者是谁？ </li>
<li>这个行业的产能如何？其在整体经济结构中的地位。</li>
<li>这个行业的法律监管如何？</li>
</ul>
<p>弄清楚这些问题之后，可以再进一步分析这个行业的业务和财务情况，未来发展趋势等。下面是行业研究的一个基本框架，可以作为参考。</p>
<embed src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_industry-research.svg" style="display:block;width:100%;height:100%" onclick>

<p>行业研究是一个有意思的事情，有了基本的研究框架之后，下面以新能源汽车作为范例，来好好研究这个近来的当红行业。</p>
<h2 id="新能源汽车概述"><a href="#新能源汽车概述" class="headerlink" title="新能源汽车概述"></a>新能源汽车概述</h2><p>2019年特斯拉上海超级工厂的建成投产，是新能源汽车行业的一个重要转折点，也是我真正对于新能源汽车产生兴趣的时候。众所周知，随着科学技术的发展，行业与行业之间的界限越来越模糊。自从 2007 年苹果公司推出 iPhone，围绕着这一全新产品，电子、通信、半导体、计算机等行业融合在一起，相对于传统的诺基亚等智能手机，iPhone 将软硬件解耦，硬件标准化、软件可重复开发利用，释放出巨大的能量，创造了十年蓬勃发展的移动互联网浪潮，极大的改变了整个社会。</p>
<p>传统的汽车，已经是融合了材料、电子、机械、能源等行业的极度复杂的产品，也是很多国家的支柱产业。但是未来的汽车，将会像十年前的智能手机一样产生进一步的融合，结合通信、计算机、交通、人工智能等行业，爆发出相比智能手机更大的能量。正如一篇研报所说，</p>
<blockquote>
<p>从 1885 年卡尔本茨发明第一台现代汽车以来，汽车产业从未像今天一样成为如此多技术变革的交汇点，设计能源、交通、通信、计算机等诸多行业。<strong>汽车现代化——电动化、智能化、网联化、共享化浪潮开启，百年汽车产业正站在大变局大洗牌的黎明前夜</strong>。</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="竞争格局重塑，价值链重构"><a href="#竞争格局重塑，价值链重构" class="headerlink" title="竞争格局重塑，价值链重构"></a>竞争格局重塑，价值链重构</h4><p><strong>特斯拉等造车新势力崛起，互联网、半导体等科技巨头跨界进入，汽车产业竞争格局重塑、核心价值链重构，部分 OEM 未来或将沦为代工厂。</strong></p>
<p>以特斯拉为代表的造车新势力利用自身的先发优势和互联网基因，正不断抢占传统车企市场份额。</p>
<p>另一方面，通用、福特等传统车企陆续裁员，FCA（菲亚特克莱斯勒）和 PSA（标致雪铁龙）合并成为全球第四大车企，传统车企报团取暖与新势力的高歌猛进行程鲜明对比。</p>
<p><strong>未来汽车产业的核心价值将不再是发动机、车身、底盘，而是电池、芯片、车载系统、数据。</strong></p>
<p>2019 年初，大众 CEO 在达沃斯论坛上宣布，大众将成为一家软件驱动的公司，并设立了 「Digital Car &amp; Service」部门，大力推动数字化转型。丰田公司宣布，丰田将从汽车公司转型为移动出行公司，他们的竞争对手已经不是曾经的奔驰、宝马和大众，而是苹果、谷歌等。谷歌、高通、英伟达、华为、阿里、百度等巨头已通过合作、授权或供应商等身份等嵌入智能驾驶细分环节，未来可能占据行业重要的价值点。部分无法掌握核心技术的车企只能逐渐变边缘化，甚至沦为代工厂。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="售价20万的燃油车制造成本分布（单位：万元）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_petrol-car-cost.png"></div><div class="group-picture-column" style="width: 50%;"><img alt="售价20万的新能源汽车制造成本分布（单位：万元）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_electric-car-cost.png"></div></div></div></div>
<p><strong>新能源汽车以“三电”为核心，汽车电子技术的飞速发展有助于其技术进步和推广普及。</strong></p>
<p>汽车电子由半导体器件组成，用以感知、计算、执行汽车的各个状态和功能。由于新能源汽车以“三电”为核心，电池、 电机、电控都离不开“电”，随着电子技术的不断发展，电子元器件将在新能源汽车中得到更多的应用(目前汽车电子在新能源汽车中价值量占比约 65%，远高于传统燃油车)。 而电子领域的“摩尔定律”则有望助力新能源汽车发展，使其进化迭代速度远远快于传统燃油汽车。</p>
<h4 id="中国的先发优势和规模优势"><a href="#中国的先发优势和规模优势" class="headerlink" title="中国的先发优势和规模优势"></a>中国的先发优势和规模优势</h4><p>中国新能源汽车产业经过十年的规划和培育，已具备一定先发优势和规模优势。三电系统、充电基础设施等产业链配套初步形成。</p>
<p>根据《汽车产业中长期发展规划》和《节能与 新能源汽车技术路线图》提出的目标，未来 10-15 年新能源汽车逐渐成为主流产品， 汽车产业初步实现电动化转型。</p>
<ul>
<li>到 2020 年，汽车产销规模将达到 3000 万辆，其中 新能源汽车年产量将达到 200 万辆</li>
<li>到 2025 年，汽车产销规模将达到 3500 万辆， 其中新能源汽车年占比 20%以上</li>
<li>到 2030 年，汽车产销规模将达到 3800 万辆，其中新能源汽车占比 40%以上。</li>
<li>相对于我国传统汽车每年接近 3000 万辆的销售市场， 新能源汽车销量渗透率不到 3%，行业处于高速增长的初期阶段。</li>
</ul>
<p><img alt="中国新能源汽车销量预测" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_china-electric-vehicle.png"></p>
<p>我国的新能源汽车行业，将会呈现出四大发展阶段，每个阶段的侧重点都会有所不同，每一个阶段都会有数量级的提升。</p>
<p><img alt="中国新能源汽车未来发展的四个阶段" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_china-electric-vehicle-period.png"></p>
<h4 id="软件定义的智能移动终端"><a href="#软件定义的智能移动终端" class="headerlink" title="软件定义的智能移动终端"></a>软件定义的智能移动终端</h4><p><strong>硬件变革</strong></p>
<ul>
<li>电池、电机、电控将取代发动机，汽车动力总成面临百年来最大变革</li>
<li>智能网联将提升对于整车感知、交互与决策的需求，传感器、中控屏、芯片将成为汽车的核心零部件</li>
</ul>
<p><strong>软件变革</strong></p>
<ul>
<li>汽车电子电气架构将有分布式向类似于智能手机的集中式架构（底层操作系统、芯片 SOC）进化</li>
<li>软硬件结构，既实现硬件标准化，又实现软件可重复开发利用，大量减少内部冗余</li>
</ul>
<p><strong>服务与生态变革</strong></p>
<ul>
<li>智能网联汽车可以在生命周期内通过 OTA 空中升级持续更新应用，界面交互将赋予汽车更多应用场景</li>
<li>自动驾驶技术的发展将为司机提供更多的自由时间</li>
<li>车联网技术的网站将使汽车随时与办公室、家、公共设施相联，实现远程控制</li>
<li>汽车将成为各种服务和应用的入口</li>
</ul>
<h3 id="市场规模"><a href="#市场规模" class="headerlink" title="市场规模"></a>市场规模</h3><p>新能源汽车发展空间巨大，随着新能源汽车性能提升以及痛点的改善，新能源汽车带来的冲击越来越大，渗透率随之提升。根据 BNEF 预测，</p>
<ul>
<li>到 2025 年全球新 能源汽车的销量将达到 1100 万辆，渗透率达到 11%，同年燃油汽车销量将达到拐点，步入下行趋势;</li>
<li>到 2030 年全球销量将继续攀升至 3000 万辆，渗透率达到 28%; </li>
<li>到 2040 年全球销量有望达到 6000 万辆，渗透率提升至 55%。</li>
<li><strong>长期看，全球新能源汽车市场空间有望成长到 10 万亿元量级。</strong></li>
</ul>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="2015-2040年新能源汽车销量及渗透率发展趋势" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_long-term-electric-vehicle-sales.png"></div><div class="group-picture-column" style="width: 50%;"><img alt="2015-2040年新能源汽车与内燃机占比发展趋势" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_shares-ice-ev.png"></div></div></div></div>
<h2 id="新能源汽车行业环境"><a href="#新能源汽车行业环境" class="headerlink" title="新能源汽车行业环境"></a>新能源汽车行业环境</h2><h3 id="政策分析"><a href="#政策分析" class="headerlink" title="政策分析"></a>政策分析</h3><h4 id="双积分政策"><a href="#双积分政策" class="headerlink" title="双积分政策"></a>双积分政策</h4><p><strong>「双积分政策」从生产端激励新能源车型的规模化生产</strong></p>
<p>2017 年 9 月 27 日，工信部等五部委正式发布 「乘用车企业平均燃料消耗量与新能源积分并行管理办法」，也就是<code>双积分政策</code>。双积分政策于 2018 年 4 月 1 日期执行但不考核，预留一年缓冲期；执行范围包含境内乘用车生产企业和进口乘用车供应企业。</p>
<p><img alt="双积分政策" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_double-score-policy.png"></p>
<p>什么是双积分？简单来说就是生产燃油车减分，生产新能源车加分，积分可以交易。</p>
<p>由于纯电动车型的生产积分获取与车型续航呈高度正相关，高续航纯电动车获得了更为有力的政策支持。</p>
<h4 id="购置补贴与税费减免"><a href="#购置补贴与税费减免" class="headerlink" title="购置补贴与税费减免"></a>购置补贴与税费减免</h4><p><strong>补贴政策鼓励高续航里程、高能量密度、低能耗的车型。续航里程和能量密度双高的车型补贴不降反升，补贴政策开始向扶强扶优转变，有利于淘汰行业内落后 产能，促进行业龙头企业业务发展。</strong></p>
<p><img alt="中国新能源汽车补贴政策历程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_elctric-vehicle-subsidy-policy.png"></p>
<h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><h4 id="动力电池技术发展与应用情况"><a href="#动力电池技术发展与应用情况" class="headerlink" title="动力电池技术发展与应用情况"></a>动力电池技术发展与应用情况</h4><p><strong>锂电池技术加速商业化，能量密度不断提升，成本逐步降低</strong></p>
<p>在新能源汽车的三电系统中，相较电动机与电控系统而言，动力电池是新能源汽车主要技术突破方向。动力电池领域也存在类似于「摩尔定律」一样的技术进步时间线，电池能量密度每经过一段时间会出现大幅度提升。</p>
<p><img alt="电池能量密度发展" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_battery-energy-density.png"></p>
<p>随着电池能量密度的不断提升，电动车平均续航里程也在不断增长。第 17 批新能源汽车免征购置税目录中电动车的平均续航里程已达到 313 公里，较第 10 批平均值提升约 41%。</p>
<p><img alt="电动车平均续航里程发展" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_recharge-mileage.png"></p>
<p>随着电池技术的发展，电动车与燃油车之间续航里程的差距将不断缩小甚至反超。</p>
<ul>
<li>宝马计划在 2025 年前推出 12 款纯电动车型，续航里程均超过 700 公里</li>
<li>奔驰计划在 2025 年推出 1000 公里续航的电动车</li>
</ul>
<h4 id="充电设施建设与分布情况"><a href="#充电设施建设与分布情况" class="headerlink" title="充电设施建设与分布情况"></a>充电设施建设与分布情况</h4><p>电动车在充电、续航的劣势也在不断改进优化。截止 2018 年 12 月，我国公共充电桩达到 33.1 万台，私人充电桩达到 47.7 万台。政府加强对充电基础设施的产业扶持力度，2019 年补贴政策指出，新能源地方补贴资金转向充电设施补贴。</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="全国新增公共充电桩数量" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_public-charging-pile-by-time.png"></div><div class="group-picture-column" style="width: 50%;"><img alt="各地区公共桩保有量" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_public-charging-pile-by-region.png"></div></div></div></div>
<h4 id="车联网技术发展与应用情况"><a href="#车联网技术发展与应用情况" class="headerlink" title="车联网技术发展与应用情况"></a>车联网技术发展与应用情况</h4><p><strong>车联网高速增长，借助新能源汽车实现电动化与网联化融合</strong></p>
<p>我国 5G 从 2020 年将正式进入商用阶段。5G 技术的发展使车辆可以与外界(V2X)进行大容量、高速度、 低延迟的大数据传输，让自动驾驶成为可能。相比传统燃油车的发动机，新能源汽车通过电机控制电压电流的输入输出，与智能汽车中大量的线传电控技术融合性更好。</p>
<p><img alt="中国移动筛选的5G网络应用" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_5g-application.png"></p>
<h4 id="自动驾驶技术发展与应用情况"><a href="#自动驾驶技术发展与应用情况" class="headerlink" title="自动驾驶技术发展与应用情况"></a>自动驾驶技术发展与应用情况</h4><p><strong>自动驾驶技术正向 L4 阶段迈进，与纯电动汽车的兼容性绝佳</strong></p>
<p>自动驾驶将是未来出行不可或缺的智能配置，也是汽车智能化的标志之一。</p>
<p><img alt="自动驾驶发展图" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_roadmap-to-automation.png"></p>
<p>纯电动汽车较内燃机而言具备绝佳的自动驾驶技术兼容性，其电力驱动与电子控制系统可与自动驾驶技术必须的传感器和计算机硬件设备高效对接。自动驾驶技术与车联网技术也是互为表里，二者在新能源汽车上的规模化应用是必然趋势。</p>
<h2 id="新能源汽车产业链结构"><a href="#新能源汽车产业链结构" class="headerlink" title="新能源汽车产业链结构"></a>新能源汽车产业链结构</h2><p>这里用思维导图理出了新能源汽车产业链上下游的组成部分，关于各个部分的深入研究等以后继续填坑。</p>
<embed src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-18_electric-vehicle-industry-chain.svg" style="display:block;width:100%;height:100%" onclick>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>行业研究</tag>
        <tag>新能源汽车</tag>
        <tag>产业链</tag>
        <tag>投资</tag>
      </tags>
  </entry>
  <entry>
    <title>武汉日记</title>
    <url>/posts/4119174d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第四期，这一期我会梳理过去三周发生种种迷幻的事情。是的，如你所知，我最近给自己放了三个星期的假，「朝花夕拾」已经停更了两期；如你所知，我是一个武汉人，身在局中，这场疫情还在继续发展，往者不谏，来者可追。</p>
<p>我们到底，还要付出多大代价？</p>
<a id="more"></a>
<h2 id="突如其来"><a href="#突如其来" class="headerlink" title="突如其来"></a>突如其来</h2><p>这是一场突如起来的疫情。</p>
<p>直到 2020 年 1 月 19 日我从北京回武汉时，我都没有把之前关于这场疫情放在心上；</p>
<p>在 1 月 3 日，KF 在看到新加坡和香港对疫情预警处理新闻，在寝室和我们讨论的时候，我依然毫不在意；</p>
<p>在1 月 8 日，KM 从武汉来湖北找我的时候，我们还开玩笑是否他不会把不明肺炎传染给我吧；</p>
<p>到 20 日上午的时候，我还在为 21 日和老妈老姐去广东过年的行程做着准备；</p>
<p>即使在 20 日晚上听到了钟南山肯定不明肺炎人传人新闻的时候，即使心中有些许担忧，还是决定去广东；</p>
<p>21 日上午一大早，躺在床上刷着一条又一条关于不明肺炎新闻的时候，我才开始意识到这次肺炎的严重性，赶紧跑到老妈房里向她说明当时的情况，此时的她正在兴冲冲的整理行李，对于头天晚上的新闻毫不在意；</p>
<p>到 23 日早上传出武汉封城新闻的时候，我还在想这次能不能在元宵节前结束，说不定还能赶上和 PF 的湖南之行。</p>
<p>随着每天通报的确诊数越来越多，随着病情从武汉向湖北、向全国、向全世界扩散，随着春节假期延长，随着各地返工时间不断延迟，随着每天网络上此起彼伏的新闻的轰炸，我终于意识到了这次疫情对我造成的后果了：</p>
<p><strong>这一次我至少在家要呆在 3 月份了，甚至可能 5 月份才能返校</strong></p>
<p>因为这次疫情，全国人民都不得不呆在家中，服务业全方面停摆… 虽然这次新冠肺炎对我的影响只是上面简单的几笔，于国家于社会却已经造成了巨大的国民经济损失。这是一次影响远超 SARS 的历史疫情，不仅仅是经济损失，还有公共卫生变革、社会舆情管理、政治体制改革，到底如何还要由历史检验。</p>
<h2 id="蓄谋已久"><a href="#蓄谋已久" class="headerlink" title="蓄谋已久"></a>蓄谋已久</h2><p>这不是一场突如其来的疫情。</p>
<p>恰恰相反，这次新冠肺炎蓄谋已久，它巧妙地在武汉和湖北两会期间扩散，并在春节期间爆发，为自己争取到了可以匹敌 <code>非典型肺炎</code>的名称：<code>新冠肺炎</code>。我用思维导图整理了疫情开始到现在的时间线，种种的一切表明这不仅仅是一场天灾，更是人祸。</p>
<embed src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-08_wuhan-timeline.svg" style="display:block;width:100%;height:100%" onclick>

<p>根据后期披露出来的各种信息，我们可以看到，早在 <code>2019年12月1日</code>已有患者发病。</p>
<p> <code>2019年12月20日</code>稳健医疗取消在湖北召开高管年会，作为一个局外人的医疗企业，凭借当时和医疗系统联系的信息，已经推演出了大规模的人传人疫情传播的可能性，及早取消了湖北的年会。那么身为局内人的卫生系统呢？后续的时间线证明了一线的医生在 12 月 25 日时已经意识到了此次新冠肺炎的传染性，并且按照规定向疾控中心上报疫情。截止到 2019 年底，事件都还在正常的路线上发展着，不好不坏无可指摘，国家卫健委专家组也抵达武汉正式介入调查。</p>
<p>可是进入 2020 年之后，事情的发展开始走偏：</p>
<ul>
<li>央视报道武汉8名散布谣言者被查出</li>
<li>提前在微信群中给身边朋友预警的李文亮医生遭到武汉警方训诫</li>
<li>武汉医护感染病例逐渐增加，而武汉市卫健委直到 1 月 19 日之前仍在宣称 「未发现明显人传人」和「医护感染」，此次疫情「可防可控」</li>
<li><strong>武汉市两会和湖北省两会接连召开</strong>，武汉卫健委连续 12 天或者无通告，或者通告无新增病例</li>
<li>武汉市百步亭社区万家宴按期举办</li>
</ul>
<p>直到 1 月 20 日，钟南山面对央视采访，明确肯定「确认人传人」，并且已有「医护感染」</p>
<p>然而庞大的官僚系统显示了它巨大的惯性、对于专业意见的蔑视，和 03 年没有什么不同：</p>
<ul>
<li>1 月 20 日晚间，湖北省应急管理厅成功举办春节联欢会</li>
<li>1 月 21 日晚间，湖北省春节团拜文艺演出成功举办</li>
</ul>
<p>到了 1 月 22 日，整个事件的发展陡转直下：</p>
<ul>
<li>湖北省启动突发公共卫生事件II级应急响应</li>
<li>国务院副总理孙春兰开始检查指导肺炎疫情防控工作</li>
</ul>
<p>终于，1 月 23 日，武汉封城。一个人口超 1100 万人的城市封城，这是人类历史上首次，这一刻，我见证了历史，我也是历史的参与者。另一个令人注意的点是，还有一天，就是中国的春节，此时距离 2020 年铁路春运已经过去了两个星期。</p>
<p>以武汉封城作为一个时间节点，接下来的两个星期，放假在家的人们经历了一次又一次爆炸性的舆论浪潮。就像是一场全民直播，所有人既是看直播的人，也是在镜头面前表演的人。</p>
<h2 id="现场直播"><a href="#现场直播" class="headerlink" title="现场直播"></a>现场直播</h2><p>过去的两个星期，从春节假期的开始，我们经历了一波又一波的舆论浪潮，就像是一场高维空间现场直播。所有的人，都拥有大量的空闲时间来生产和消费信息。春晚早就失去了它在上世纪 90 年代曾经拥有过的关注度和讨论价值。取代春晚的，是在这次疫情中发生的一个又一个与所有人都息息相关的故事。</p>
<p>信息的开始「高维化」。在过去的两个星期中，得益于移动互联网和自媒体时代信息的传播，关于这场疫情所有的细节，都被不同行业、不同方向的人们，从不同的角度捕捉、深挖，通过微博微信等自媒体平台，形成了一个又一个热点。就像在春晚直播的同时，摄影师也开了直播，台下的观众开了直播，台上的道具也开了直播，事件各方的一线参与者、一颗颗螺丝钉们都在输出这信息。那些虽然没有在一线，但是对于整个体系和链条熟悉的专业人士也在输出着信息。最终，形成了这次多年不见的持续到舆论浪潮。</p>
<p>距今为止，这次疫情中最大的三个热点是</p>
<ul>
<li>红十字会事件</li>
<li>CDC论文事件</li>
<li>李文亮事件</li>
</ul>
<p>而这三个热点不仅仅是一件事，而是伴随着牵扯出了一系列的热点</p>
<ul>
<li>央视报道武汉 8 名散布谣言者被查处</li>
<li>百步亭社区万家宴</li>
<li>湖北省春节团拜会</li>
<li>湖北省长 108 亿口罩产能</li>
<li>武汉市长称此前信息披露不及时是因为作为地方政府需要授权</li>
<li>火神山渣土车被蔡甸城管锁扣</li>
<li>黄冈唐主任一问三不知事件</li>
<li>武汉病毒所所长履历问题</li>
<li>双黄连事件</li>
<li>…</li>
</ul>
<p>接下来我想以这几个热点为出发点，讨论一下事情发生到现在，到底是哪出了问题？当然，开始之前，你就知道，这根本就不是一点的问题，这是一艘到处都露着洞的破船，它亟需一些全面的更新换代，未来还需要它承担更多。</p>
<h3 id="物资到底去哪了"><a href="#物资到底去哪了" class="headerlink" title="物资到底去哪了"></a>物资到底去哪了</h3><p>这不是红十字会第一次出问题。从2011 年的郭美美事件，到更早之前汶川地震时红十字会涉嫌贪污问题，中国红十字会在中国的公信力早已经大大降低。 这一次，因为新冠肺炎疫情，红十字会的问题再一次暴露在大家面前。连续几天，红十字会事件持续发酵：</p>
<ul>
<li>最开始大家热情捐赠，国家也积极拨款物资，但是前线医护人员持续爆出医疗物资紧缺的问题，人们开始质疑物资到底去哪了</li>
<li>接下来有人报出武汉红十字会将医用口罩等物资捐赠给莆田系医院</li>
<li>然后是央视直播红十字会被保安打断事件引发广泛的舆论热潮，人们对红十字会长期的不满开始爆发</li>
<li>紧接着鄂 A0260 车辆取口罩事件</li>
<li>然后是惯常套路红十字会道歉，表示内疚自责</li>
<li>红十字会被九州通接管效率大幅提高</li>
<li>最后以湖北省红十字会3名领导被问责结束</li>
</ul>
<p>这样的事情不是没有发生过，为什么一而再再而三透支红会的公信力？在这个过程中，中国人民、中国企业的慈善行动是非常积极的，他们踊跃地捐出了自己的一份力，但是因为红十字会低效的分发能力一直没能分发下去。在中国物流行业超级发达的今天，红十字会在物资发放的时候，还在按传统的人工填表方式汇总需求，再按领导评估分配，然后通知领取，最后各单位凭介绍信来核查验证。所有的这些，在习惯了互联网高效便捷生活的人们看来简直不可思议，物资的分配发放怎么会如此原始低效。事情的最后，物资分发被委托给九州通这家专业机构，整个效率得到了大幅的提高。</p>
<p>为什么会发生这样尴尬的事情？社会上有这么多专业力量，却没有得到激活，更没有和政府的社会治理高效融合，从而造成了这样一个尴尬的现象：政府很忙却力不从心，社会力量闲置却只能干着急。更令人质疑气愤的是，即使红十字会如此不给力，政府还是号召大家捐赠要通过红十字会统一处理，理由是这样便于统计分发。</p>
<p>怎么办？还是那句话，让专业的人做专业的事情。政府需要分权，和社会力量一起，共同高效治理。期待经过这一次，中国的慈善能够有一次系统升级。</p>
<p>慈善不应该垄断，慈善不应该只有中国红十字会这样的官方政府机构。这一次，韩红慈善基金会得到了大家的广泛赞扬，「一包方便面都能公示，为什么你不做？」，这是我们看到的民间慈善力量的积极发展。于此同时，所有的慈善机构都应该得到监管，需要有强制的信息公开机制，不论是官方慈善机构还是民间慈善机构，这些都需要在法律法规中得到体现。</p>
<p>另一方面，这一次只是红十字会在放大镜下得到了我们的审视。由此思之，还有多少政府行政单位的效率是一样的低下。在上一波移动互联网浪潮发展下，我们拥有了便携的线上线下生活。下一波「智慧城市」，还有多少这样原始的政府办事流程可以得到优化可想而知。</p>
<h3 id="到底是谁在瞒报"><a href="#到底是谁在瞒报" class="headerlink" title="到底是谁在瞒报"></a>到底是谁在瞒报</h3><p>梳理时间线，我们可以看到早在 1 月 8 日，<strong>国家卫健委已经确认了新型冠状病毒为疫情病源</strong>，在此期间，也一直有病例确诊，为什么在湖北和武汉的两会期间，一直无通报或者通报无新确诊案例。整个武汉无新增病例的平静时间长达12天，为什么没有通报？这段时间里，医疗体系和疾控部门以及湖北省、武汉市政府的内部到底发生了什么？</p>
<p>武汉市长在 1 月 27 日的央视采访上表示，说他需要授权才能依法披露：</p>
<blockquote>
<p>这次我们的疫情其实各方面对我们信息的披露是不满意的，我们既有披露不及时的一面，也有我们利用很多有效信息来完善我们的工作不到位的一面。前面这个披露的不及时，这一点大家要理解，因为它是传染病，传染病有<strong>「传染病防治法」</strong>，它必须依法披露，作为地方政府，我获得这个信息以后，授权以后，我才能披露，所以这一点在当时很多不理解。</p>
</blockquote>
<p>周市长说的很明确，他承认了自己的责任：</p>
<ul>
<li>信息披露不及时</li>
<li>有效信息下工作不到位</li>
</ul>
<p>先不论信息披露的责任到底在谁，稳健医疗作为一个医疗企业都能够凭借自己获得的信息做到预警，武汉市长根据他所获得的信息是应该能够意识到问题的严重性的。可以说，相对 SARS本次新冠肺炎早期的防治工作是很不错的。从 2019 年 12 月 8 日发现第一例通报，12 月中旬获得病毒样本并传至 CDC，12 月 29 日聚焦到华南海鲜市场，次日启动调查，1 月 1 日关闭市场，1 月 9 日成功破译确定发现新型冠状病毒基因组，并随即将该病毒基因组信息共享到相关国际网站。这么短的时间找到病因，甚至病毒测序都得以完成发表，是一个非常了不起的成绩。在这个时候，通过媒体的民众教育十分关键。佩戴口罩，勤洗手，公布早起患病人员的行动轨迹，这都是应该在早期做到的。这不会引起恐慌，与此相反反而能够在早期就遏制疫情的发展。我在 1 月 19 日从北京回武汉时，基本上没有多少人佩戴口罩。这真的不是武汉市民心大，这是武汉市政府没有起到应有的教育预警功能，甚至还发生了万家宴这种事情。</p>
<p>OK，接下来再看信息披露的问题。</p>
<p>为什么在平静的 12 天内，武汉不通报确诊信息，其中<a href="https://mp.weixin.qq.com/s/DDP846cgEhkiFhTgNVIXxw" target="_blank" rel="external nofollow noopener noreferrer">试剂盒是主要问题</a>。直到 1 月 16 日，首批针对新型冠状病毒生产的PCR试剂盒才被下发到各省级疾控中心。而下达到省级疾控中心并不会下达到一线的医院，于此同时，试剂盒的生产也成为瓶颈。</p>
<p>查阅<strong>中华人民共和国传染病防治法</strong> 第三十八条显示：</p>
<blockquote>
<p>国家建立传染病疫情信息公布制度。</p>
<p>国务院卫生行政部门定期公布全国传染病疫情信息。省、自治区、直辖市人民政府卫生行政部门定期公布本行政区域的传染病疫情信息。</p>
<p><strong>传染病暴发、流行时，国务院卫生行政部门负责向社会公布传染病疫情信息，并可以授权省、自治区、直辖市人民政府卫生行政部门向社会公布本行政区域的传染病疫情信息。</strong></p>
<p>公布传染病疫情信息应当及时、准确。</p>
</blockquote>
<p>确实如周市长所言，地方政府卫生行政部门需要国务院卫生行政部门的授权才能向社会公布本行政区域的疫情信息。依据行政区划分类，武汉市是副省级城市，行政区划类别为省辖市，并非省、自治区、直辖市，基于现行法律法规，武汉市的卫生行政部门不是疫情公布主体，因此，武汉市市长无权决定公布传染病疫情。</p>
<p>国务院的卫生行政部门是什么呢？当前的国家卫生行政部门即是国家卫生健康委员会。此次舆论中心的中国疾控中心（CCDC）则是国家卫健委直属的事业单位，CDC 作为一个研究性单位，是一个科研机构+公益机构+政策咨询机构。</p>
<p>查阅<strong>中华人民共和国传染病防治法</strong> 第三十三条显示：</p>
<blockquote>
<p>疾病预防控制机构应当主动收集、分析、调查、核实传染病疫情信息。接到甲类、乙类传染病疫情报告或者发现传染病暴发、流行时，<strong>应当立即报告当地卫生行政部门</strong>，由当地卫生行政部门立即报告当地人民政府，同时报告上级卫生行政部门和国务院卫生行政部门。</p>
<p>疾病预防控制机构应当设立或者指定专门的部门、人员负责传染病疫情信息管理工作，及时对疫情报告进行核实、分析。</p>
</blockquote>
<p>依据当前法律，CDC 是没有权力向公众公布信息的，他只能向卫生行政部门报告。我不相信高福院士他们为了抢发论文不向公众公布数据，实际上疾控中心1月23日拿到数据开始做的研究分析，25日到26日提交的论文，这是在确认人传人之后的工作。从法律上来说，他们本就没有公布数据的权力。于此同时，因为 PCR 试剂盒的限制，导致武汉地方确诊数目一直不变。根据那张广为流传的直方图，CDC 早在 1 月 6 日已经给出了二级预警。那么为什么给出了二级预警之后地方行政部门还是无动于衷呢？为什么卫健委不向公众公布相关疫情情况呢？</p>
<p>这里不是在给 CDC 洗白，这一次 CDC 在法律上没有做错任何事情，其最大的错误在于：<strong>「在需要他们以预防医学的思维来指导整个疫情控制的时候，他们错误的选择了科研思维。」</strong></p>
<p>根据<a href="https://zhuanlan.zhihu.com/p/104541604" target="_blank" rel="external nofollow noopener noreferrer">知识分子的报道</a>:</p>
<blockquote>
<p><strong>CDC承认早有推论人传人，但下结论“保守”“谨慎”</strong></p>
<p>在1月31日接受《新京报》采访时，论文的通讯作者之一、中国CDC的副主任冯子健承认，从“未发现明显人传人现象” 到 “不能排除有限人传人的可能”，CDC是 “保守的”， “谨慎的”。</p>
<p>关于 “人传人” 的推论，冯子健说，他们比较早就已经有这样的看法，但需要调查核实，包括详细询问、核实每个患者的暴露史。</p>
<p>冯子健同时表示，中国CDC从最早开始，就把它（新型冠状病毒）当作有高度传染性的疾病来对待，第一时间采取了密切接触者管理等措施。</p>
<p>他说，对疾病的认识有个过程，公布信息要谨慎，所以从开始的“未发现明显人传人现象” 到 “不能排除有限人传人的可能”，和病例诊断、实验室检测结果逐步用于病人的甄别有关。</p>
<p>而根据《第一财经》的报道，高福表示，回顾性调查的工作正是CDC的职责之一，找到元凶，回顾性调查，指导未来防控。“我们的防控一直没有停，一个月来大家都没有觉睡。”</p>
<p>对于中国CDC在此次疫情中的表现，一位不愿具名的资深流行病学家认为，”<strong>中国疾控中心在7天之内成功地对新型冠状病毒进行了测序，并将结果推向了国际社会，这令人印象深刻。</strong>”</p>
<p>“从发表于425例患者的论文中，高福博士被批评掩盖了数据，却没有在官方网站上报告。据我了解，作为中国疾控中心主任，<strong>高福博士无意掩盖流行病学数据。政府中可能有一些行政程序，延迟了报告过程。如果不将这些数据发布到国际文献中，我们可能永远不知道真正发生了什么</strong>。” 上述流行病学家告诉《知识分子》。</p>
<p>“由于政府和管理部门对预防医学公共卫生的不重视，中国疾病预防控制中心失去了许多优秀的流行病学家和公共卫生专家。自从这一流行病开始以来，他不是第一组专家也没有说该病毒不是人传人传播。实际上，<strong>在全国范围内爆发疫情的主要原因在很大程度上是由于武汉市政府无法遏制这种流行病，并不断告诉人们该病并非人传人，是有限人传人，在很长时间内，最基本防疫系统和程序没有得到认真的实施（例如戴口罩）。从实践的过程中促进了武汉肺炎在本地的社区感染，向全省、全国的扩散。与地方政府相反，高博士在文章评论中清楚地提到了该病毒是人传人。</strong>” 他继续说道。</p>
</blockquote>
<p>至此，责任到底在谁明白了，CDC 早就已经有了人传人的推论，但是下结论过于保守慎重，以科研思维去验证疫情人传人的证据，而没有以预防医学的思维去指导控制整个疫情控制。从而国家卫健委的持续发布「可防可控」，不排除「有限人传人」的消息，地方政府与此同时也失灵，疏忽了对于疫情的基本防控，最终导致了最后的疫情大爆发。</p>
<p>所以，教训是什么，以后怎么办？<a href="https://mp.weixin.qq.com/s/-VhdDtf2A-dA86J5VB010A" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>给出了非常专业的建议。</p>
<blockquote>
<p>建议人大以后修法要明文规定，<strong>CDC重大疫情预警发布应该自主独立</strong>…</p>
<p>CDC掌握疫情后，当然<strong>要与有关专家充分沟通，防止重大差错</strong>。也应该<strong>知会政府主管机构和相关部门</strong>。但这不应该是征求许可，而是<strong>需要政府支持和做具体工作</strong>。比如关闭野生动物市场，必须假手工商管理部门，医院清空病房需要卫健委部署执行，关停剧院图书馆等公共设施，取消大会团拜等，需要政府做出姿态。</p>
<p><strong>在疫情监测数据采集处理分析到发布，都是非常专业的技术活儿</strong>。拿这些去考问官员，如果不是学有关专业出身的，不具备相应学识，这不是赶鸭子上架么？不是学医出身的，死人的事儿都沒有机会亲历，不知道历害，从何来做决策需要的胆识？</p>
</blockquote>
<h3 id="不应该只有一种声音"><a href="#不应该只有一种声音" class="headerlink" title="不应该只有一种声音"></a>不应该只有一种声音</h3><blockquote>
<p>真相更重要，一个健康的社会不应该只有一种声音。</p>
</blockquote>
<p>上面这句话，来自一个刚刚离开我们不久的鲜活的生命，而它的代价，更是数以千计的生命与家庭。李文亮的去世，在互联网上造就了罕见的流量热度，是疫情发生以来人们对于湖北武汉政府防控不力不满的一次强烈的情感宣泄，也是人们对于一直以来官方网络管控的一次声讨。</p>
<p>李文亮医生只是一个普通人，他从没有想过当英雄，他所做的只是在微信群里小范围的提醒身边的人注意可能传染的微信。然而仅仅就是因为这，他得到的是武汉警方粗暴的训诫。</p>
<blockquote>
<p>「你能做到吗」 —— 「能」</p>
<p>「你明白了吗」 —— 「明白」</p>
</blockquote>
<p>在一月初最开始看到新闻报道武汉八名散播谣言者被查处的时候，我对于官方的报道基本确信无疑的。没想到的是，所谓的造谣者，竟然是专业的医生，他也并没有特意的想要传播出去，还在微信群里提醒大家不要传出去。李文亮医生不是经典意义上的英雄，他没有想对抗谁，也没有想破坏什么，甚至也没有想要去救苦救难。他不过是一个有职业精神和职业道德的专业人士，忽然被自己的政府打压训诫，然后继续兢兢业业奋战在一线，直到最后染病身亡。他不想做英雄，却比经典意义上有强大对立面需要对抗的英雄更加悲剧。</p>
<p>我们见过了太多的辟谣与反辟谣，弄得现在我们都不太敢在互联网上发表意见。每一次发表意见，都会有人出来质疑是不是在带节奏，是不是在吃馒头，我们似乎需要像上帝一样成为全知者才能发表意见，而且还得表现出自己的理性客观中立周全。我们被告知要等权威部门发布权威信息，然后是的，我们等到了权威部门的报道。我们相信权威，我们相信可防可控，我们不是心大，我们相信政府部门，但最后我们得到了什么？</p>
<p><img alt="权威部门报道" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-02_rumor.png"></p>
<p>为什么会这个样子？为什么你不容得一点批评？为什么是一次又一次的 404？</p>
<p>我承认改革是一件长久的事情，我承认这是一个艰巨的任务，我承认我们每一个人都需要为了更好的中国去奋斗。但是，这个和我发表意见并不冲突。与其让网友失控责骂，不如让专业的人干专业的事，让你们自己的专业媒体去作出专业的批评，去正确引导舆论方向。我们听过了太多的假话、空话、套话，我们想听真话、实话。</p>
<p>在当下的中国，有太多的问题值得讨论。与我们息息相关的教育、医疗、科研等等问题，有关具体的政策措施，都应该让民众知道更多的事情，不能仅仅就以民众科学素质太差而推脱。正是因为国民基础素养薄弱，才需要你做更多的工作啊。</p>
<p>这一次疫情，我们看到了良心媒体如三联、如财新的报道，可是他们却也要承担很多的压力。我们看到了湖北武汉本地媒体长达一个月的集体失语，本地媒体的监督功能完全瘫痪。我们看到了官媒关于疫情中各种感人事迹的报道，是的他们是伟大的，但是能否请你们更多的发出一些理性监督的声音，而不是像人民日报那样愚蠢而又不负责的双黄连新闻。</p>
<p>我总是说「未来会更好的」，我现在也仍然相信，我会努力的，只是希望你们也能够努力一些。</p>
<h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>未来怎么办？</p>
<p>这么多天来，我们见识了太多光怪陆离的事情，我们见证了太多感动人心的事情。疫情还在继续，医护人员们还在前线奋斗，也有很多基层工作人员在辛苦工作，也仍然有领导继续发布一些愚蠢的行政措施。我相信，这场战役我们终将取得胜利，区别在于我们将付出多大的代价。03 年我们已经付出了沉重的代价，未来怎么办？</p>
<p>为什么人们会怀念 03 年的王岐山市长，因为他在说人话，没有说官话。这一次湖北政府和武汉政府的表现让人大跌眼镜，这是一个连续几年经济增速在全国名列前茅的政府所应该有的素质吗？发布会期间通篇不敢通稿，对于自己所说的数字没有概念，一而再再而三的发生错误，对说的就是你，湖北省长王晓东。面对媒体质询视而不见或者答非所问，对说的就是你，湖北省委书记蒋超良。我们不需要那么多的讲话、我们不需要那么多的会议。</p>
<p>很多的基层干部是很辛苦的，距今已有多起地方公务人员以身殉职的报道，他们是官僚主义最直接的受害者。我们不否认各级政府对于此次疫情的重视，此次疫情的响应速度也很快，但是问题在于意识到位、文件到位、人也到位，可就是方法不到位，只能说狠话， 干着急，使蛮力。再好的讲话精神，也只会层层下压，在基层造成各种粗暴、混乱、过激、非法且低效的高压管制（封路、封门）。我不是一个专业人员，我现在只是一个略带情绪的评论者。我想到的办法就是，让专业的人干专业的事，政府需要更多的专业人士进入官僚系统，不论是来自于医疗、科研，还是来自于企业的专业人才。</p>
<p>还有呢？</p>
<p>这不是一个简单的整改，这里涉及到整个社会体制、整个社会治理体系的全方位更新换代。这个不是一天两天的事情，也不是喊一个口号就完了。我在这里键盘侠很简单，具体落实下来的是一张又一张的法律条文，一个又一个新的行政体系，一点又一点新的风气风貌。</p>
<p>未来会好的吧，我相信。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这是一篇在 2 月 7 日的开始编写的文章，直到 2 月 12 日才基本写完，真的是够拖的了。从最开始查阅各方的资料用思维导图绘制时间线，到去看过去两个星期发生的各种事情的细节，时而激动，时而感动。我一向认为自己是一个政治观念保守的人，我不认同激进的变革，任何事情都是妥协的产物，我们需要的是温和的改革。我理解治理一省一市之艰难，但这也正能体现出不同官员能力的巨大差别。我不想偏激，但是有时候我是真的想骂人，尤其这段时间。</p>
<p>这里只是一个普通公民自己的思考，这是我在这段时间里的记忆。这段历史绝不能够被忘记，正如非典一样。在 GitHub 上，也已经有人开始为这段历史存档，这些都是很好的参考资料。</p>
<ul>
<li><a href="https://github.com/2019ncovmemory/nCovMemory" target="_blank" rel="external nofollow noopener noreferrer">nCovMemory</a></li>
<li><a href="https://github.com/Pratitya/wuhan2020-timeline" target="_blank" rel="external nofollow noopener noreferrer">wuhan2020-timeline</a></li>
<li><a href="https://shimo.im/docs/onq7MwVO6pf4FjA9/read" target="_blank" rel="external nofollow noopener noreferrer">Anti404 - 2019nCov信息ICU</a></li>
<li><a href="https://shimo.im/sheets/QjTYy6rgVV3WDRkh/MODOC/" target="_blank" rel="external nofollow noopener noreferrer">2020新型冠状病毒报道汇总</a></li>
</ul>
<p>根据官方统计，截止到现在因为新冠肺炎死去的人数已经上千了。这些不是简单的数字，而是一条又一条的生命，一个又一个的家庭。作为一个普通人，除了每天看新闻，除了宅在家里，我们还能做什么呢？已经给自己放了三个多星期的假，是时候收假了，是时候重启之前的数据收集机制了，做好自己的本职工作吧，等待雨后天晴的那一天。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>武汉</tag>
        <tag>新冠肺炎</tag>
      </tags>
  </entry>
  <entry>
    <title>【交易笔记】MACD 分析</title>
    <url>/posts/91ee7b9b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>MACD</code>是股票交易中一种常见的技术分析工具，用于研判股票价格变化的强度、方向、能量，以及趋势周期，以便把握股票买进和卖出的时机，这里是对其的总结笔记。</p>
<a id="more"></a>
<h2 id="总体认识"><a href="#总体认识" class="headerlink" title="总体认识"></a>总体认识</h2><p>MACD 全称是 <code>Moving Average Convergence / Divergence</code>，在 1970年代由Gerald Appel 提出，既是一个<code>趋势追踪</code>工具，也是一个<code>市场动能指标</code>（震荡指标）。MACD体现了一条快速的指数移动平均线和一条慢速的指数移动平均线之间的差距，故其中文叫做 <code>指数平滑移动平均线</code>。</p>
<p><img alt="MACD" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-18_macd-indicator.png"></p>
<p>这是一张典型的 MACD 指标图，我们可以看到它有以下4个部分组成：</p>
<ul>
<li><strong>MACD line</strong><ul>
<li>由快的指数移动平均线（通常为<script type="math/tex">EMA_{12}</script>）减去慢的指数移动平均线（通常为 <script type="math/tex">EMA_{26}</script>）得到，称为快线，也称作 <code>DIF线</code></li>
</ul>
</li>
<li><strong>Signal line</strong><ul>
<li>信号线是MACD线的9日指数平滑移动算出，称为慢线，也称作<code>DEA线</code></li>
</ul>
</li>
<li><strong>Zero line</strong><ul>
<li>就是快线和慢线相同的时候</li>
</ul>
</li>
<li><strong>Histogram</strong><ul>
<li>代表的是 MACD 线和 信号线 之间的距离，MACD 线在信号线上方时即在零轴线上，反之在下</li>
</ul>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="Bullish-Crossover-黄金交叉"><a href="#Bullish-Crossover-黄金交叉" class="headerlink" title="Bullish Crossover (黄金交叉)"></a>Bullish Crossover (黄金交叉)</h3><ul>
<li>当DIF与DEA都在零轴以上，而DIF向上突破DEA时，表明股市处于一种强势之中，股价将再次上涨，可以加码买进股票或持股待涨，这就是MACD指标<strong>“黄金交叉”</strong>的一种形式。</li>
<li>当DIF和DEA都在零轴以下，而DIF向上突破DEA时，表明股市即将转强，股价跌势已尽将止跌朝上，可以开始买进股票或持股，这是MACD指标<strong>“黄金交叉</strong>”的另一种形式。</li>
</ul>
<h3 id="Bearish-Crossover-死亡交叉"><a href="#Bearish-Crossover-死亡交叉" class="headerlink" title="Bearish Crossover (死亡交叉)"></a>Bearish Crossover (死亡交叉)</h3><ul>
<li>当DIF与DEA都在零轴以上，而DIF却向下突破DEA时，表明股市即将由强势转为弱势，股价将大跌，这时应卖出大部分股票而不能买股票，这就是MACD指标的<strong>“死亡交叉”</strong>的一种形式。</li>
<li>当DIF和DEA都在零轴以下，而DIF向下突破DEA时，表明股市将再次进入极度弱市中，股价还将下跌，可以再卖出股票或观望，这是MACD指标<strong>“死亡交叉”</strong>的另一种形式。</li>
</ul>
<h3 id="Bearish-Divergence-（顶背离）"><a href="#Bearish-Divergence-（顶背离）" class="headerlink" title="Bearish Divergence （顶背离）"></a>Bearish Divergence （顶背离）</h3><p>MACD指标的背离就是指 <code>MACD指标图形的走势</code>正好和<code>K线图的走势</code>方向正好相反。</p>
<p>当股价K线图上的股票走势一峰比一峰高，股价一直在向上涨，而MACD指标图形上的由红柱构成的图形的走势是一峰比一峰低，即当股价的高点比前一次的高点高、而MACD指标的高点比指标的前一次高点低，这叫 <code>顶背离现象</code>。</p>
<p><img alt="MACD顶背离" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-18_macd-bearish-divergence.png"></p>
<p><strong>顶背离现象一般是股价在高位即将反转转势的信号，表明股价短期内即将下跌，是卖出股票的信号。</strong></p>
<h3 id="Bullish-Divergence-底背离"><a href="#Bullish-Divergence-底背离" class="headerlink" title="Bullish Divergence (底背离)"></a>Bullish Divergence (底背离)</h3><p>底背离一般出现在股价的低位区。当股价K线图上的股票走势，股价还在下跌，而MACD指标图形上的由绿柱构成的图形的走势是一底比一底高，即当股价的低点比前一次低点底，而指标的低点却比前一次的低点高，这叫 <code>底背离现象</code>。</p>
<p><img alt="MACD底背离" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-18_macd-bullish-divergence.png"></p>
<p><strong>底背离现象一般是预示股价在低位可能反转向上的信号，表明股价短期内可能反弹向上，是短期买入股票的信号。</strong></p>
<blockquote>
<p>在实践中，MACD指标的背离一般出现在强势行情中比较可靠，股价在高价位时，通常只要出现一次背离的形态即可确认位股价即将反转，而股价在低位时，一般要反复出现几次背离后才能确认。因此，<strong>MACD指标的顶背离研判的准确性要高于底背离</strong>，这点投资者要加以留意。</p>
</blockquote>
<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p>首先看一下 EMA 的定义： </p>
<p>​    <script type="math/tex">EMA_n = ClosingPrice_n \frac{2}{TimePeriod + 1} + EMA_{n-1}(1 - \frac{2}{TimePeriod + 1})</script></p>
<p>MACD默认参数是12、26、9，计算过程分三步:</p>
<ul>
<li><p><strong>计算两个长短周期的指数移动平均线</strong></p>
<script type="math/tex; mode=display">EMA_{12} = ClosingPrice_{today} \frac{2}{12 + 1} + EMA_{yesterday}(1- \frac{2}{12 + 1})</script><script type="math/tex; mode=display">EMA_{26} = ClosingPrice_{today} \frac{2}{26 + 1} + EMA_{yesterday}(1- \frac{2}{26 + 1})</script></li>
<li><p><strong>计算 MACD</strong></p>
<script type="math/tex; mode=display">MACD_{today} = EMA_{12} - EMA_{26}</script></li>
<li><p><strong>计算 Signal，就是对MACD进行9日平滑移动平均得到的</strong></p>
<script type="math/tex; mode=display">Signal_{today} = MACD_{today} \frac{2}{26 + 1} + Signal_{yesterday}(1 - \frac{2}{9 + 1})</script></li>
<li><p><strong>计算 Histogram</strong></p>
<script type="math/tex; mode=display">Histogram = 2 * (MACD_{today} - Signal_{today})</script></li>
</ul>
<p>看完公式问题就马上来了，如果说要算今日的值，必须得到昨日的对应值，可是刚上市的股票如何得到昨日的值呢?</p>
<p>这里就规定第一个EAM值就是当天的收盘价，同时MACD，Signal，柱值为零。</p>
<div class="note info">
            <p>在现在的股票软件中，和 MACD 相关的参数一般命名为 <code>DIF</code>，<code>DEA</code> 和 <code>MACD</code>，其实本质一样，具体的对应关系为</p><script type="math/tex; mode=display">DIF = MACD_{today} = EMA_{12} - EMA_{26}</script><script type="math/tex; mode=display">DEA  = Signal_{today} = DIF \frac{2}{26 + 1} + Signal_{yesterday}(1 - \frac{2}{9 + 1})</script><script type="math/tex; mode=display">MACD = Histogram = 2 * (DIF - DEA)</script>
          </div>
<h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><ul>
<li><p><strong>MACD指标与均线的关系</strong></p>
<p>MACD指标源于股价的平滑移动平均线EMA，所以具有均线指标稳定，能追随趋势的特点，能够对市场动能做出客观的反映。与此同时，MACD指标在均线的基础上还有超越，主要是去掉了均线有时频繁发出假信号的缺陷，使得指标在对中长期趋势的把握上准确率较高。</p>
</li>
<li><p><strong>MACD是市场动能最直接的反映</strong></p>
<p>MACD指标实际上围绕两个离差值进行分析，一个是DIF线，是快慢均线的差值，可以理解为股价上涨或下跌的速度;另一个是MACD柱线，是快慢DIFF线的差值，可以理解为股价上涨或下跌的加速度。MACD指标对市场动能有着极大的敏感性。</p>
</li>
<li><p><strong>MACD指标具有一定的滞后性</strong></p>
<p>在区间振荡行情中，MACD的价值会大打折扣，甚至会出现紊乱。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>资本不眠</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>股票</tag>
        <tag>MACD</tag>
      </tags>
  </entry>
  <entry>
    <title>也谈「远程办公」</title>
    <url>/posts/cab4606c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是武汉封城的第二十四天，疫情还在焦灼，距离湖北外很多地方计划的 2 月 10 日复工也已经过去了一周。很多员工也在陆续返回上海、深圳等城市，开始复工的节奏。尽管如此，事实上仍旧有很多行业的很多公司处于停摆状态，一场突如其来的疫情注定会影响各行各业的发展。</p>
<p>距离 2 月 3 日春节假期结束已经过去了两周，在经济整体下行的背景下，「推动企业复工复产」成为和「疫情防控」同等重要的工作。一时间，「远程办公」成为热点，这里是「朝花夕拾」第五期，这一期我们来聊一聊 <code>远程办公</code>, 它到底是不是一种先进的工作模式。</p>
<a id="more"></a>
<h2 id="为什么我们可以远程工作"><a href="#为什么我们可以远程工作" class="headerlink" title="为什么我们可以远程工作"></a>为什么我们可以远程工作</h2><p>毫无疑问，你必须承认「远程办公」可以拥有巨大的生产力。君不见，在远程办公和开源协作下，我们有了全世界最伟大的软件作品 <code>linux</code> （没有之一，不服来辩）。</p>
<p><img alt="Linus在家办公" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-15_linus-working-at-home.jpg"></p>
<p>这是一张让我印象深刻的图片，是 linux 的主要创造者 <code>Linus</code> 在家办公的场景。想象一下，全世界超过两万个软件开发者，通过<code>git</code> 和 <code>MailList</code>进行远程协作，像 <code>Linus</code>一样远程为 Linux 提交代码，这是一件多么酷的事情。</p>
<p>关于 Linus 家中办公的具体环境，可以参见下面的视频（如果看不到，你应该意识到你被墙了 ：）</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/LE0JtUeyVJA" frameborder="0" allowfullscreen></iframe></div>
<p>可是如果远程办公室如此的高效，为何这种方式还迟迟没有得到推广呢？为什么还有那么多人要忍受大城市每天 996 的生活，要忍受大城市拥挤的交通，长时间的通勤，要忍受高额的房租？作为信息时代的原住民，作为信息行业的从业者，我们为何不能远程工作呢？</p>
<p>事实上，远程工作这个概念在欧美已经很流行了，也有很多公司原生支持远程工作。在近几年，随着各种协作的效率工具的发展，远程工作的条件已经成熟，国内也已经有一些远程工作的先行者：</p>
<ul>
<li>比如<a href="https://mp.weixin.qq.com/s/alygC64BnIKbuuxBBZAOxA" target="_blank" rel="external nofollow noopener noreferrer">做出了TiDB的PingCAP 公司</a></li>
<li>比如<a href="http://wangcong.org/" target="_blank" rel="external nofollow noopener noreferrer">这位在大理远程工作同时还在大理找到另一半的老哥</a></li>
<li>比如<a href="https://coolshell.cn/articles/20765.html" target="_blank" rel="external nofollow noopener noreferrer">陈皓的MegaEase公司</a></li>
<li>还有<a href="https://github.com/greatghoul/remote-working" target="_blank" rel="external nofollow noopener noreferrer">种种</a>，不胜枚举</li>
</ul>
<h2 id="为什么他们不远程工作"><a href="#为什么他们不远程工作" class="headerlink" title="为什么他们不远程工作"></a>为什么他们不远程工作</h2><p>可是，尽管有这么多成功的先例，绝大多数的公司都没有选择这种远程工作的模式，为什么呢？</p>
<blockquote>
<p><strong>远程办公很多沟通不方便，反馈不及时，协作体验不好</strong></p>
</blockquote>
<p>这真的是最本质的原因吗？更多的时候，问题就来自于原有工作模式的低效性。作为一个已经在好几家公司实习过的小白鼠，就已经可以切身感受到当前国内互联网工作存在的问题，只不过这些问题在远程工作的情境下被放大了而已。</p>
<h3 id="缺位的目标管理"><a href="#缺位的目标管理" class="headerlink" title="缺位的目标管理"></a>缺位的目标管理</h3><p>有那么多的老板认为，在公司呆的时间越久产出才能越多。这是造成当前互联网行业著名 996 现象的主要原因，那么多的员工在虽然是在公司，实际上是在摸鱼。</p>
<p>我一直认同的工作理念，应该是把事情在 DDL 做完，而不管你在哪个地方，以何种方式完成，这一点来说，<code>OKR (Objectives and Key Results)</code>是一个很好的目标管理工具。</p>
<blockquote>
<ul>
<li>相比 KPI 来说，OKR 首先更加强调由团队成员共同制定团队目标，这样带来的好处是易于让整个团队就目标和关键结果达成共识，始终保持团队的目标导向一致。</li>
<li>OKR 能够让团队成员更加明白做手头上的事情对于团队以及对于公司的意义，这一点对于远程团队尤为重要，极大的有利于促进部门与部门、人与人的协作，让团队更加具有整体性。</li>
<li>OKR 还有一个很重要的特点：透明，在我们的实践中，每个团队都可以看到别的团队的 OKRs，大家在制定完各自团队的 OKR 后，还需要在公司级别宣布，确保大家都能了解。</li>
</ul>
</blockquote>
<p>公司的管理和个人的管理是相通的，要做一件事情，首先得有可以量化的 Objectives，对应的目标是会有一些 Key Results 的，自己可以一步一步的完成。关于 OKR 的更多内容，可以参考 <a href="https://www.zhihu.com/question/22471467" target="_blank" rel="external nofollow noopener noreferrer">这个知乎问答</a>。</p>
<h3 id="失效的会议"><a href="#失效的会议" class="headerlink" title="失效的会议"></a>失效的会议</h3><p>很多时候的会议主题并不明晰，在进入会议之前很多人对会议内容并不熟悉，可能整个会议都不明所以。</p>
<blockquote>
<p>世界上最大的电话会议运营商研究了与会者开会时都在干些什么：65%的人在干别的事情，63%的人在发邮件，55%的人在吃东西或做饭，47%的人去洗手间，6%的人在参加另外一场电话会议。</p>
</blockquote>
<p>不是说会议是无用的，恰恰相反，好的会议是可以高效解决问题的。问题在于，绝大多数的会议是低效的。真正好的会议应该是这样的：</p>
<ul>
<li>会议目标明确，或者是决策型会议，或者是讨论型会议。</li>
<li>会议人数精简，会议时间不能过长，即Amazon 的「两个 Pizza 原则」</li>
<li>每个参会的人都应该明确会议议程，在会议前就能够有自己的一些想法，然后集合起来，解决问题。</li>
<li>要合理拆分会议议题，谨慎对待新议题。</li>
</ul>
<p>可以说，这些问题都和是否远程工作无关。恰恰相反，在远程工作的条件下，我们通过对于工具的利用，能够更加有效的展开会议。</p>
<h3 id="糟糕的管理"><a href="#糟糕的管理" class="headerlink" title="糟糕的管理"></a>糟糕的管理</h3><p>真正好的管理，不应该是传统的监管思维，而应该是自我驱动式的管理思维。要做到这一点，不仅仅要求在公司层面营造良好的工作氛围，另一方面对于合作的同事提出了更高的要求。</p>
<blockquote>
<p>远程团队需要的人的一般需要有这些特质：</p>
<ul>
<li><strong>能独挡一面的人</strong>。这样交给他的事能独立完成，没有路能自己找路，这样可以省很多管理成本。</li>
<li><strong>沟通能力很强的人</strong>。一方面，他们把模糊的事能变清楚，另一方面，他能有效地说服他人。不然就会非常扯皮和消耗时间。</li>
<li><strong>能自管理和自驱动</strong>。不能自管理和自驱的人，会增加大量的管理和教育成本。能自驱动的人，都是对负责的事情有认同的人。</li>
</ul>
<p>如果你仔细思考一下，<strong>你会发现，这样的人是任何一家公司所渴望的人，和远不远程无关</strong>。只不过，如果是远程团队的话，你会被逼着要招到这样的人。</p>
</blockquote>
<p>找到优秀的人才，是团队管理成功的第一步。正如Bezos 所说，「我宁愿面50个人一个人都招不到，我也不愿意降低我的面试标准」。</p>
<h2 id="我们该如何远程工作"><a href="#我们该如何远程工作" class="headerlink" title="我们该如何远程工作"></a>我们该如何远程工作</h2><h3 id="工作范式"><a href="#工作范式" class="headerlink" title="工作范式"></a>工作范式</h3><h4 id="Documentation-Driven"><a href="#Documentation-Driven" class="headerlink" title="Documentation Driven"></a>Documentation Driven</h4><p>文档可以很好的将信息结构化，相对于会议、语音、slack等工具可以促使你更加深入的思考。于此同时，文档可以作为以后参考，是项目记录很好的资料。</p>
<h4 id="Design-Review"><a href="#Design-Review" class="headerlink" title="Design Review"></a>Design Review</h4><p>对于一些重要的问题或是工作（每个人都能够判断什么是关键问题和工作）， <strong>需要先把自己的想法share出来，而不是先实现</strong> 。</p>
<p>一个好的 Design 文档需要包括如下项：</p>
<ul>
<li><strong>Background</strong>。交待这个事的背景、需求和要解决问题。</li>
<li><strong>Objectives</strong>。说明这个事的目标和意义。</li>
<li><strong>Alternative Solutions</strong>。给出多个解决方案，并能够进行 Pros/Cons 对比。<ul>
<li><strong>Reference</strong>。方案需要有权威引用支持。</li>
<li><strong>Data</strong>。方案需要有相关数据数据支持。</li>
</ul>
</li>
<li><strong>Conclusion</strong>。结论是什么。</li>
</ul>
<h4 id="Simplification-amp-Automation"><a href="#Simplification-amp-Automation" class="headerlink" title="Simplification &amp; Automation"></a>Simplification &amp; Automation</h4><p>对于远程工作来说，能交给机器做的，尽量不要人来做，自动化是至关重要的。尤其对于线上的协作来说，多一个人的参与就意味着多一份沟通成本。现在像 slack 和 github 等工具都有一些 bot 可以使用，能够极大的提高工作效率。 </p>
<p>简化是对事物一种抽象和归纳能力，其能够提升软件的复用能力和扩展性，自动化是工程能力的重要体现，一方面，远程工作中自动化的能力可以让整个团队更高效地协作，另一方面，自动化是规模化的提条件。</p>
<h4 id="Effective-Meeting"><a href="#Effective-Meeting" class="headerlink" title="Effective Meeting"></a>Effective Meeting</h4><p>会议组织者需要在事前收集会议议题，其中包括如下分类：</p>
<ul>
<li><strong>项目类</strong>：需要事先有项目进度计划表（任何分项最好控制在1-2人周内）</li>
<li><strong>方案类</strong>：需要事先写好相关的方案和设计才能讨论（参看 Design Review 章节）</li>
<li><strong>问题类</strong>：需要事先写好相关的问题和解决提案（参看 Design Review 章节）</li>
<li><strong>决策类</strong>：需要事先写好整事的前因后果以及利弊分析</li>
<li><strong>信息类</strong>：需要事先写好相关的事宜说明</li>
</ul>
<p>组织者需要在会议前发出会议议题收集，其中包括：</p>
<ul>
<li>自己知道的项目的进度跟进（需要相相关的项目负责人准备相关的项目计划）</li>
<li>方案和问题类的需要各个项目负责人提出来，并有相关的设计文档可供Review</li>
<li>信息类和决策类的事宜可以写在Google Doc上，也可以写在 Team 的 Issue 里</li>
</ul>
<p>其它负责人可以在会议上加入自己团队的东西，或是要求其他团队提供更多的信息。</p>
<h3 id="远程工具"><a href="#远程工具" class="headerlink" title="远程工具"></a>远程工具</h3><p>下面列出一些远程工作中可以用到的工具，其中的一些也在我个人管理中得到了运用。</p>
<h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul>
<li>GitHub：代码托管，公开的 RFC，社区 Issue 反馈，产品发布，Code Review 等。</li>
<li>Jenkins：持续集成，daily build。</li>
</ul>
<h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><ul>
<li>在线文档：文档协作，幻灯片，表格。</li>
<li>邮件，日历。</li>
<li>Trello：看板，记录一些重要客户和事件的备忘。</li>
</ul>
<h4 id="沟通交流"><a href="#沟通交流" class="headerlink" title="沟通交流"></a>沟通交流</h4><ul>
<li>Zoom：在线会议。</li>
<li>Slack：即时通讯，机器人消息中枢。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这一次对于「远程办公」这个话题的讨论，主要是根据自己的几段实习工作经历和网络上的一些在线经验分享而来，这是一个极度缺乏实践的一次「远程办公」的思考。我认为，「远程办公」的小众性，绝大多数的来源于绝大多数公司管理的无能，也因为没有把那些聪明的、具备自我管理能力的人聚集在一起。</p>
<p>我期待着「远程办公」，期望在以后的某一段时间里，可以自己切身来实践这上面的种种，这才是云时代应该有的工作范式。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>远程办公</tag>
        <tag>会议</tag>
        <tag>OKR</tag>
      </tags>
  </entry>
  <entry>
    <title>愿望清单</title>
    <url>/posts/2338e312/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这两天看到有人在朋友圈打卡 <a href="https://www.zhihu.com/question/373711344" target="_blank" rel="external nofollow noopener noreferrer">人生中必做的100件事</a>，自己也看了看，做了一些事，也有很多没实现。这是「朝花夕拾」第六期，这一期我们来聊聊 <code>愿望清单</code>。</p>
<a id="more"></a>
<p>我给自己创建了一个 <a href="../../wishlist">愿望清单</a> 的页面，这是一个动态的列表，随时都会有愿望被加入或者被完成。</p>
<p>当我尝试给自己做这么一个清单的时候，写完常见的条目之后，我发现自己无从下笔了。人生，是一个很沉重的话题，区区百年，你活在这个世上能够做些什么事情？作为一个世俗之人，你拥有自己的欲望，你想要过上优质的生活，你想要做出有价值的工作，你想要拥有幸福的家庭，你想要健康的身体…</p>
<p>你想要的东西有很多，作为万千世界中的一份子，你逃不出这个时代所具备的局限性。你知道这个世界有它丑陋的一面，它是如此的不堪而你却无能为力，你只能把你做到最好。你开始有一些恐惧，<code>Is that it ?</code> 哦不不，我知道即使是要实现列表中的这些，已经可以过滤一大堆的人了。可是，你为什么还是不满足呢？</p>
<p>不，我只是感到害怕，因为在这个过程中，我好像可以看到未来几十年的大致路径。唯一的不确定性，就是来自这段过程中我在人生上下限中的波动了。好，能够有多好？坏，能够有多坏？</p>
<p>Hey man，别在这无病呻吟了，你告诉我。接下来再想下去，就应该是那几个问题了：</p>
<blockquote>
<ul>
<li>我从哪里来？</li>
<li>我要到哪里去？</li>
<li>我要做什么？</li>
</ul>
</blockquote>
<p>人生的意义是什么？我曾经给自己的答案是，如果我这辈子能够做出一些有价值的事，那种我自己都觉得牛X的事情，那我就很满足了。去大公司？拿到高工资？这些都不算。真正的有价值，应该是我具体做的事情，而不是这些外界的标签。前两天在微博上看到了一个有意思的人<code>陈行甲</code>，这种人生状态是我所倾羡的。</p>
<iframe src="//player.bilibili.com/player.html?aid=90194626&cid=154019449&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>不是说要去官场斗智斗勇，而是说对于自己的专业工作能够做的问心无愧，而且也实实在在的创造了其巨大的价值。我一向声称自己是对于生活是十分乐观的，我也能够看到那些我想要成为人的样子。</p>
<p>再回头去看，未来的生活真的是那么的循规蹈矩吗？你做到了你想要成为的样子吗？这些所谓的上下波动是无意义的吗？不，这些才是真正区分你人生的地方。是那种始终保持向上，知道自己的不足，始终去扩展自己边界的人生态度。除了本职工作之外，也有那么多有意思的事情，音乐历史地理经济心理，有那么多的东西你都不懂，生活真的是乏味的吗？</p>
<p>时间是如此的少，你总可以去做一些有意思的事情。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>wishlist</tag>
      </tags>
  </entry>
  <entry>
    <title>像计算机一样思考</title>
    <url>/posts/b5e52cf1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是武汉封城第三十八天，新冠疫情继续发展，国内开始呈现控制好转之势，国外却急转直下大面积蔓延。日韩成为东亚新的焦点，可能要历史以来第一次因为非战争原因停办奥运会；伊朗多个高官确诊新冠，实际疫情恐引爆中东；意大利人数持续攀升，欧洲呈现燎原之势；美国真的是可防可控吗，Donald你看，道琼斯指数四天内已经有两天下跌超过 1000 点了诶。</p>
<p>这里是 「朝花夕拾」第七期，这一期我们聊聊 <code>Critical Thinkinng</code>，我们到底应该如何去思考？这应该是关于「思维模式」系列的开篇，话题来源于 <a href="http://mindhacks.cn/" target="_blank" rel="external nofollow noopener noreferrer">Mind Hacks</a> （这也是一个很有意思的老哥，我喜欢他的「暗时间」理论）</p>

    <div id="aplayer-jFeUEwDU" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="3053558" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<h2 id="Writing-As-Cache"><a href="#Writing-As-Cache" class="headerlink" title="Writing As Cache"></a>Writing As Cache</h2><p>书写是为了更好的思考。</p>
<p>如果把大脑当做一台计算机的话，大脑这台机器也需要面对我们在计算机中经常遇到的问题：</p>
<ul>
<li>Memory is Limited</li>
</ul>
<p>在认知心理学领域有一个 <a href="https://en.wikipedia.org/wiki/Working_memory" target="_blank" rel="external nofollow noopener noreferrer">Working Memory</a> 的概念，说的就是大脑在思考在计算的时候，Working Memory 的容量是有限的，正如我们的计算机一样。一个常见的现象就是，当我们大脑在自由思考的时候，很容易偏离主题，以至于我们甚至会忘记半个小时之前大脑中在想些什么。从思考的起点，会面临一个又一个的分叉，而在思维前进的路上，又很容易会忘记之前得到过的结论，以至于无法持续性的获得进展。</p>
<ul>
<li>Writing As Cache</li>
</ul>
<blockquote>
<p>Working memory as part of long-term memory.</p>
<p>The Central Executive of Working Memory is retrieving memory from the unlimited Long-term Memory.</p>
</blockquote>
<p>正如计算机的存储除了内存外还有持久性的外存作为辅助一样，大脑也有长期记忆。而为了整个计算过程能够更加高效的进行，我们需要 Cache，在我们的思维过程中，书写即可达到这个效果。不需要长篇累牍的书写，一个简单的思维导图即可，清醒的列出思维过程的主干，可以极大的提高计算过程。在书写的过程中，我们极大的提高了信息的容量，不同信息间的碰撞，也许可以不经意间刺激出新的思考。</p>
<ul>
<li>Background Jobs</li>
</ul>
<p>很多时候，我们的思考都是在潜意识中进行。一个典型的例子，就是上周在看金融危机相关纪录片的时候，大量的信息向我涌来，一个个名词在我脑海中跳动：<code>美联储</code>、<code>格林斯潘</code>、<code>量化宽松</code>、<code>金融监管</code>… 我好像搞懂了这究竟是怎么一回事，但是事实并不是这个样子。所有的这些信息只是在我的脑海流过罢了，但是我并没有真正的弄懂它。当下次有一个人要让我讲讲的时候，我并不能够说出个所以然来。我可能说出量化宽松、缺乏监管、CDS 等等几个词，但是我并不能够从逻辑上讲清楚整个的事情。</p>
<p>这就是典型的 <code>看起来懂了，却说不出个所以然</code>。因为很多的思考只是在我们潜意识中进行的，像后台进程一样，很多的推理都想当然的完成，自己并没有认真地梳理其正确性。最好的方法，就是通过书写来整理其来龙去脉，构建自己的思维体系。</p>
<h2 id="Avoid-Context-Switching"><a href="#Avoid-Context-Switching" class="headerlink" title="Avoid Context Switching"></a>Avoid Context Switching</h2><p>继续刚才的逻辑，大脑作为计算机，应该极力避免上下文切换。</p>
<p>学过操作系统的人都知道每一次进程上下文切换是多大的损耗，在设计系统的时候都会要去极力避免上下文切换。想一想，一个跑的正欢的程序，突然被计算机调度出内存，系统需要去刷新缓存、将原来的进程存放好以便于下次启用……对于大脑来说也是一样，我们最反感的事情就是，自己一件事情做的正起劲，被突如其来的会议或者其他事情所打断。因为我们知道，再要进到刚才的那个状态不是一件容易的事情，系统需要预热。</p>
<p>我们的计算资源是有限的，我们的时间和精力都是有限的，大脑作为一个计算系统，我们应该尽量提高其效率，<strong>在有限资源的情况下做到全局最优</strong>。要提高效率则需要优化我们的调度系统，把资源投入到最需要的地方。在有限的资源下，尽量避免上下文切换也是一个不错的算法。</p>
<h2 id="Correct-Logic-Code"><a href="#Correct-Logic-Code" class="headerlink" title="Correct Logic Code"></a>Correct Logic Code</h2><p>如果代码的逻辑写错，一个程序是永远不可能获得正确的答案的。</p>
<p><code>逻辑</code> 在近些年的讨论中越发被强调，因为我们越来越发现有那么多的人在讨论问题的时候 逻辑 本身就是混乱的。也许有些话初听起来好像很正确，但是实际上却犯了各种 <code>概念偷换</code>、<code>模糊因果</code>的问题。这里是一个 <code>认知偏见</code>的 <a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases" target="_blank" rel="external nofollow noopener noreferrer">清单</a> ，在忽视逻辑的情况下，我们经常或有意或无意的重复着上面的问题。（关于 认知偏见 这个话题，以后可以专门聊一聊）</p>
<p>以前段时间的一个热点问题为例：</p>
<blockquote>
<p>如果你觉得你的祖国不好，你就去建设它；如果你觉得政府不好，你就去考公务员去做官；如果你觉得人民没素质，就从你开始做一个高素质的公民；如果你觉得同胞愚昧无知，就从你开始学习并改变身边的人，她有缺点，我们一起修正，而不是一昧的谩骂，抱怨，逃离。横眉冷对千夫指，俯首甘为孺子牛。“你所站立的地方，正是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你若光明，中国便不黑暗。”</p>
<p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我们便是唯一的光。</p>
</blockquote>
<p>这句话在当时引起了很大的争议，表面上它看起来很正确，鼓励你去努力从自身做起去改变这个国家，但本质上它的逻辑是有问题的。</p>
<p>第一个问题，<code>偷换概念</code>。正在讨论的问题是 「为什么红十字会有这么多的问题」、「为什么李文亮医生他们会遭到训诫」、「为什么武汉市政府这次应对疫情的表现这么糟糕」。他说了这句话之后，讨论的问题一下子就变成了 「你应该去做什么」。</p>
<p>第二个问题，<code>推理无效</code>。</p>
<blockquote>
<p>事实A: 红十字会做的很糟糕</p>
<p>事实B: 你没有参与红十字会的工作</p>
<p>假设C: 只有参与红十字会工作的人才能批评它</p>
<p>推理D：你不应该一味的谩骂、抱怨、逃离</p>
</blockquote>
<p>很明显，假设 C 错误，他直接否认了我批评的权利，整个推理是无效的推理。</p>
<blockquote>
<p>事实E：武汉市政府做的很糟糕</p>
<p>事实F：你没有参与武汉市政府的工作</p>
<p>假设G：只有去做公务员才能真正的改变它</p>
<p>推理H：你应该去考公务员去做官来改变它</p>
</blockquote>
<p>Again，假设 G 错误，难道舆论监督就不能改变他吗？</p>
<blockquote>
<p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我们便是唯一的光。</p>
</blockquote>
<p>我是同意鲁迅先生这段话的，希望每一个中国青年都能够做自己的事情，能做事的做事，能发声的发声。但是，如果因此，你就剥夺了我们的批评权，我就要思考你说这句话背后的动机了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>「思维模式」这个话题是一个深坑，我也需要不断的去学习、去思考、去改变。本篇为序，以后这个系列应该还会有更多的思考。</p>
<p>一转眼，二月就要结束了呀。</p>
<p><img alt="Rescue Time 二月数据" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-29_rescue-time-feb.png"></p>
<p>看了下二月份搜集的时间数据，还需要加油呀。</p>
<p>武大的早樱已经开了，三月应该会好起来吧。</p>
<p>再见，二月；</p>
<p>你好，三月。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>思维模式</tag>
        <tag>Critical Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>The Big Short</title>
    <url>/posts/787197ce/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>没错，这里是最近新开的另一个专栏「资本不眠」，这个专栏会总结股票市场的交易笔记，比如第一期聊到的 <code>MACD</code>；也会聊在资本世界里面各种有意思的事情，比如这一期就是通过 <code>The Big Short</code>这部电影对 2007 年 到 2008 年那次由 <code>次贷危机</code>引发的全球经济危机进行的梳理复盘。如果以后有机会的话，我会专门在这个专栏复盘自己在股市中的每日操作（当然，我是十分期待自己能够开这个坑的，如果我对自己每次操作都能够知其所以然的话）。</p>
<p>哦对了，最近 A 股的半导体和新能源等科技股都炒疯了。呵，愚蠢的人类。</p>
<a id="more"></a>
<h2 id="大崩盘"><a href="#大崩盘" class="headerlink" title="大崩盘"></a>大崩盘</h2><p>让我们再回顾一下那一年的大崩盘</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/oyiCuAVcQDs" frameborder="0" allowfullscreen></iframe></div>
<p>这是一场席卷全球的金融风暴，它承接过去一百年内发生的种种，在 2008 年达到了高潮，彻底改变了全世界成千上万人们的生命轨迹。尽管已经过去了十二年，我们还是能够感受这场风暴的余波：英国脱欧、特朗普当选莫不如是，甚至你都能从最近奥斯卡最佳电影 <code>寄生虫</code>感受到那场危机带来的影响。</p>
<p>那么今天，我会从头梳理，在那场危机中到底发生了什么？是什么导致了这场危机？它对我们到底造成了那些影响？</p>
<h3 id="主角"><a href="#主角" class="headerlink" title="主角"></a>主角</h3><p>在 2000 年代，经过多轮的兼并重组，美国的金融行业被几家巨型公司所主宰，下面是我梳理的这场金融风暴中的主要玩家：</p>
<embed src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_america-financial-industry.svg" style="display:block;width:100%;height:100%" onclick>

<p>总的来说，主要分为以下几个部分，他们是管理着数万亿美元资产的美国五大投资银行和四大商业银行，影响着上亿人养老金和保险的三大保险公司，为这场游戏制定规则的美联储、财政部以及美国证券交易委员会，作为第三方应该独立的评级机构。</p>
<h3 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h3><p>在这场危机中，他们粉墨登场，表现各异，最后的结局也大相径庭：</p>
<ul>
<li>2007 年 4 月，开始有从事次级抵押贷款的公司申请破产</li>
<li>2007 年 10 月 9 日，道琼斯指数达到最高收盘 <code>14164</code>点</li>
<li>2008 年 3 月 17 日，美国第五大投资银行<code>Bear Stearns</code>现金流耗尽，美联储帮助其被 <code>JPMorgan Chase</code>收购</li>
<li>2008 年 9 月 7 日，美国最大两家房地产公司 <code>房地美</code> 和 <code>房利美</code> 被美国联邦政府接管</li>
<li>2008 年 9 月 15 日<ul>
<li>在美联储拒绝担保其贷款后，美国第三大投资银行 <code>雷曼兄弟</code> 破产，导致道琼斯指数下跌 504 点，为七年来最大跌幅。</li>
<li>美国第四大投资银行 <code>Merrill Lynch</code> 被美国银行收购。</li>
</ul>
</li>
<li>2008 年 9 月 16 日，美国最大的保险公司 <code>AIG</code> 资不抵债，美联储宣布提供 <code>850亿美元</code>短期紧急贷款，接管 AIG。</li>
<li>2008 年 9 月 19 日，美国财政部长 <code>Paulson</code> 和 美联储主席 <code>Ben Bernanke</code> 提出不良资产解决方案(Troubled Assets Relief Program, <code>TARP</code>)要求国会授权支出<code>7000 亿美元</code>以允许美国财政部从金融机构中购买不良资产。此救市方案获得投资者积极反应，但是其注资计划仍需众议院落实。</li>
<li>2008 年 9 月 21 日，幸存的两家投资银行 <code>高盛</code> 和 <code>摩根士坦利</code>申请从 <code>投资银行</code> 转变为 <code>银行控股公司</code>以更多的获得来自美联储的救助。</li>
<li><p>2008 年 9 月 29 日，美国国会否决了包含了 7000 亿美元 <code>TARP</code> 计划的<code>经济稳定紧急法案</code>，造成道琼斯指数指数当日下跌 700 点，创历史以来单日最大跌幅。</p>
</li>
<li><p>2008 年 10 月 3 日，国会通过经济稳定紧急法案，该方案同意美国财政部从九大银行购买优先股以为其纾困：</p>
<ul>
<li>花旗集团：450 亿美元</li>
<li>美国银行：450 亿美元</li>
<li>AIG：400 亿美元</li>
<li>摩根大通：250 亿美元</li>
<li>富国银行：250 亿美元</li>
<li>高盛：100 亿美元</li>
<li>摩根士坦利：100 亿美元</li>
<li>纽约梅隆银行：30 亿美元</li>
<li>道富银行：20 亿美元</li>
</ul>
</li>
<li>2008 年 12 月 16 日，美联储降低基金利率至 0。</li>
<li>2009 年 1 月，美国三大汽车制造商 <code>通用电气</code>、<code>克莱斯特</code>和 <code>福特汽车</code>申请 <code>TARP</code>计划的纾困。</li>
<li>2009 年 3 月 6 日，道琼斯指数触及最低 <code>6443</code> 点。</li>
</ul>
<p>当我一个字一个字敲下这场危机时间线的时候，我的脑海里只有一个词：<code>一地鸡毛</code>。可以看到，危机早在2007年已经发出了信号，可是绝大部分人都选择忽略它，股市继续狂热火爆并一度达到巅峰。直到最后，灰犀牛如期而至，整个市场一地鸡毛。</p>
<h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p>众所周知，<code>次贷危机</code>源自于房地产泡沫。可是，什么是<code>次贷</code>? 为什么房地产的泡沫会导致全球的金融海啸呢？有人说这归咎于华尔街精英们发明的各种神奇的<code>金融衍生品</code>，扔出了一堆的专有名词。绝大部分人看到这里就开始晕了，WTF，什么是 <code>MBS</code>，什么是 <code>CDO</code>，什么是 <code>CDS</code>。别怕，所有的这些就是华尔街故意发明出来的看起来高大上的一些词。相信我，所有接受过基本数学教育的人都能够弄懂他们到底在玩些什么花样。接下来，让我们来学一些术语 ：）</p>
<h3 id="MBS"><a href="#MBS" class="headerlink" title="MBS"></a>MBS</h3><p><strong>Mortgage Backed Securities</strong>，也即<strong>房贷抵押证券</strong></p>
<p>首先忽略这个看起来不明所以的名词，我们知道它和房贷有关。房贷我们很清楚，你为了买房向银行申请贷款，银行对你进行信贷审核，符合条件的人可以获得贷款。</p>
<p><img alt="住房贷款基本模型" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_mortgage-old-system.png"></p>
<p>在这种模型下，住房贷款需要花费几十年的时间才能偿还，如果借贷者信用不够，银行面临着违约风险，所以银行在发放住房贷款的时候都十分谨慎。所以，当时的银行业完全是垃圾：</p>
<blockquote>
<p>In the late 70s, banking wasn’t a job you went into to make large sums of money. It was a fucking snooze. Filled with losers, like selling insurance or accounting. And if the banking was boring, then the bond department at the bank was straight-up comatose.</p>
</blockquote>
<p>然而当时的现状是，由于婴儿潮（1946-1964年）带来的人口膨胀，导致了住房短缺。房贷需求始终存在，有需求就有供给，<code>Leiws Ranieri</code>在 1977 年发明了MBS。</p>
<p>MBS是什么？一句话说，就是银行或者房产中介把不同的<strong>房贷抵押</strong>卖给投资银行，投行将这些<strong>房贷抵押</strong>打包起来，发起 <code>房贷抵押债券</code> 来融资，把借款人偿还的分期本金和利息传递给投资者（债券持有人）。</p>
<p><img alt="MBS基本模型" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_mbs-system.png"></p>
<p>这种方式对银行来说当然是一笔好生意了，不仅仅把风险都转嫁给投资者，自己还回笼了资金赚了息差和服务费。</p>
<p>问题是，投资者真的这么傻吗？前面说的银行面临的风险此时依然存在，而且这些证券是 <code>non-agency</code>的，没有国家担保，完全不值得信赖。</p>
<p>问题就两个，一是谁担风险，二是谁来担保。</p>
<p>第一个问题：<strong>谁来担风险？</strong></p>
<p>投行把从商业银行、贷款公司、中介公司收集来的房贷抵押，形成一个资产池。然后找来评级机构，将这个资产池里面的每一份 MBS 做一个评级。</p>
<p>在这个资产池里，按照信用评分高低，将MBS分为<code>Prime</code>, <code>Alt-A,</code> <code>Subprime</code>三档。这里的 <code>Subprime</code>，说的就是次一级别的贷款，也即次级贷，我们说的<strong>次贷危机(Subprime Crisis)</strong>就是来源于此。</p>
<p><img alt="具有不同等级风险和回报的MBS" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_subprime-rating.jpg"></p>
<p>由于 Prime 和 Alt-A 的评级高，很快就被抢光了，问题是怎么对 Subprime 这档好好设计，让它能够更好的卖出去。这里就是对 Sumprime 这一档进行<strong>分层(tranching)</strong>，然后在对这些层次进行评级：AAA, AA, A, BBB, BB,B…，形成优先级、夹层、劣后级不同风险和收益率的结构化份额。</p>
<p>评级越高的风险越低，期望回报也越低。反之评级越低的风险越高，期望回报也就越高（因为风险越高，银行的贷款利率也就越高，相应的期望回报也就越高）</p>
<p><img alt="Subprime不同评级对应的风险与回报" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_mbs-risk-return-for-investors.png"></p>
<p>当这一步没有任何问题，只是将不同的房贷抵押进行风险评级，以满足不同风险偏好的投资者。</p>
<p>第二个问题：<strong>谁来担保？</strong></p>
<p>这就引入了 CDO。</p>
<h3 id="CDO"><a href="#CDO" class="headerlink" title="CDO"></a>CDO</h3><p><strong>collateralized debt obligation，担保债务凭证</strong></p>
<p>话说回来，评级好的 MBS ，比如 Prime 和 Alt-A 的 MBS 都很快被卖出去了，毕竟风险低和收益可观。那么 Subprime 的 MBS 怎么办呢？于是华尔街投行的精英们发明了 CDO。</p>
<p>CDO 是什么？它是一种带有担保性质的抵押债券，这里的担保方可以是第三方，比如AIG, Ambac, MBIA这些大型保险公司。</p>
<p>那么问题来了，这么高风险的tranche（贷款中的一部分，华尔街发明的晦涩难懂的词，具体就是 MBS 中的B级部分），保险公司为什么要给他们担保啊？</p>
<blockquote>
<p>投行说，数学证明了这样的资产配置风险极低，更何况现在房价蹭蹭往上涨，即便是有人违约断供了，我们还是可以收回房产来拍卖，全国的房子集体断供这是不可能。</p>
<p>这时候评级机构又跳出来了，“咳咳，经过我们的评估，这些整合的MBS风险极低，我们给评个 double-A, 不给trible-A的原因是怕他们骄傲。” 事实上，大部分BB/BBB级的tranches被直接提升为AAA。</p>
</blockquote>
<p>对于保险公司来说，这个数学模型看起来好像很厉害，而且房价也一直在涨，即使收不回贷款拿房产抵押投行也可以盈利。再加上评级机构都这么捧场，自己还能拿保费，不干白不干。</p>
<blockquote>
<p>So mortgage bonds are dogshits, CDOs are dogshit wrapped in catshit.</p>
</blockquote>
<p>正如剧中人所说，CDO就像一个垃圾场，把各种垃圾倒进去，重新回收、打包、分类。经过这么一折腾，B 级评级直接被提升为 AAA 级。</p>
<p>厉害的是，CDO A可以包含CDO B，CDO B也可以包含CDO A，他们又可以组合成CDO C（包含CDO的CDO，CDO的平方…… $CDO^2$）。在实际的金融市场中，不仅有$CDO^2$，甚至还有$CDO^3$（包含$CDO^2$的CDO）、$CDO^4$（包含$CDO^3$的CDO）。</p>
<p>在那几年，华尔街精英们不断的用 CDO 打包再打包将其作为证券买到市场上，因为一堆风险高的资产组合收益率普遍大于一堆风险低的资产组合的收益率，房地产继续繁荣，CDO 得到了市场的广泛追捧。</p>
<h3 id="CDS"><a href="#CDS" class="headerlink" title="CDS"></a>CDS</h3><p><strong>Credit Default Swap，信用违约互换</strong></p>
<p>我们继续聊，刚才我们提到了投行让保险公司给他们担保，这实际上就是一种保险。</p>
<p>保险是什么？投保人给保险公司保费，如果出现了意外事故，保险公司则需要给投保人赔偿。对应到上面的 CDO 产品，投资银行为上面的 MBS 投保，如果<strong>标的资产</strong>（这里的标的资产就是住房贷款抵押）没有违约，投保人（也就是投资银行，Protection Buyer）需要按季度给被投保人（也就是保险公司，Protection Seller）支付保费。这对保险公司来说听起来是一件很棒的事情，毕竟房地产行情持续火热，住房贷款在同一时间集体违约的概率也那么小，CDO 怎么会违约呢？这种保费不赚白不赚。</p>
<p>到现在为止，我们还只是在谈保险，如果仅仅是这样，房地产的次贷危机还不至于引发整个金融海啸。</p>
<p>对，CDS！</p>
<p>对于持有 CDO 的投资者来说，CDS 相当于保险机制。购买了 CDS 的投资者，按季度向保险公司支付保费。如果 CDO发生违约，保险公司承诺会补偿投资者的损失。是的，这个和保险听起来没有什么区别。</p>
<p><img alt="除了资产拥有者，CDS允许所有人都可以进行投保" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_cds-bonus.png"></p>
<p>但是问题在于，CDS 不是简单的保险。在保险领域，你只能对拥有的东西投保， 比如我拥有一处房地产，我只能对它投保一次。 但是对于 CDS，它可以允许任何人对这个房子进行投保，换句话说，可能有上百个人对同一个标的资产投保。</p>
<p><img alt="资产违约，AIG需要向购买CDS的所有买家支付赔偿" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-02-20_cds-fail.png"></p>
<p>那么，如果这个房子烧毁了呢，那么保险公司（比如这里的 AIG）除了要向作为房地产拥有者的我赔偿损失，还要向成千上万购买了 CDS 的投机者赔偿。这样一来，在系统的损失就会成比例的扩大，Boom！</p>
<p>再来回顾下 CDS 的特点：</p>
<ul>
<li>CDS 所投保的资产可以跟投资者没有任何关系，这是区别于保险的最大特点</li>
<li>CDS 可以面向各类投资者，个人、银行、对冲基金、社保、养老金、保险公司等等</li>
<li>CDS 和 CDO 一样，也可以在一级、二级市场交易，可以使投行转移风险。</li>
</ul>
<p>到这一步，CDS 已经变成了<strong>双方对违约事件的对赌</strong>，承保方相当于博彩行业里对某事件发生概率而自行计算并开出赔率的庄家。买家交付一定比例的保费，产品违约即由承保方赔付，不一定是保险公司，也可以是金融机构，例如高盛。华尔街的人，把 CDS 叫做 <code>Synthetic CDO</code>。利用CDS灵活性，可以制造出无数个赌场。我们可以赌MBS，可以赌cash CDO，也可以赌某一层tranche，还可以赌价格的跌幅。</p>
<p>关于这里的 CDS 交易，还要在仔细说一说。对于一般的投资者，他们可以作为 CDS 的卖方 （Protection Seller），来获取固定收益，是卖出<strong>看跌期权</strong>（Sell CDS），认为后市看涨。而对于 <code>Michael Burry</code>来说，他是 CDS 的买方（Protection Buyer），定期支付保费，是买入<strong>看跌期权</strong> （Buy CDS），赌房地产市场下跌，博高杠杆的违约保金收益。原来这个买方角色一直是由发行bonds的投行担任，是为了卖产品。</p>
<p>对应到 2008 年次贷危机，我们来看一看各个玩家到底都做了些什么事情：</p>
<ul>
<li>AIG销售了价值至少 5000 亿美元的 CDS。当房地产泡沫破裂时，账上资金耗尽，不得不被财政部接管，用纳税人的钱为他们买单。</li>
<li>高盛从 AIG 购买了价值至少 200 亿美元的CDS，数额大到连高盛也担心 AIG 会破产。与此同时，高盛还在大量售卖了 CDO，所以他们的客户损失的越多，他们也就赚的越多。</li>
<li>不光是高盛，摩根士坦利、摩根大通、美林、雷曼兄弟也买入了数十亿美元的 CDS。</li>
<li>那么，为什么这些 CDO 能够被大众投资者买入呢？评级机构，他们的 AAA 评级。在整个房地产泡沫期间，评级机构们发放了大量的 AAA 评级，并从中获利众多。</li>
<li>救市计划开始实行，拯救 AIG 花费了纳税人1500 亿美元，其中 610 亿美元被支付给高盛。与此同时，美国财政部长 <code>Paulson</code> 要求 AIG 放弃起诉高盛和其他银行的权利。</li>
</ul>
<h2 id="大而不倒"><a href="#大而不倒" class="headerlink" title="大而不倒"></a>大而不倒</h2><p>在回顾这场金融危机的时候，脑海中一直有个问题。</p>
<blockquote>
<p>为什么政府一定要出手呢？为什么要用纳税人的钱来给他们收拾烂摊子呢？就让他们倒闭不行吗？</p>
</blockquote>
<p>是的，政府担保了贝尔斯登使其被摩根大通收购，政府接管了房利美和房地美，但是政府不想传递出一种信息说自己会收拾所有华尔街的烂摊子，于是没有帮助雷曼兄弟，但是后面事态的发展让财政部和美联储无法再旁观下去。</p>
<p>整个市场失去了信心，银行挤兑，市场失去了流动性，就连仅存的两家投行高盛和摩根士坦利都面临着巨大的撤资和空头压力。与此同时，AIG 深陷困境，作为全美最大的保险公司，影响着成千上万人的退休金。市场的恐慌让信贷停滞，就连像通用电气和克莱斯勒这种汽车制造业公司也出现了财务危机。危机持续扩散，世界上成千上万的公司出现衰退，消费者收紧钱包，成千上万的人失去了他们的工作、住房，整个金融系统停摆，濒临崩溃。</p>
<p>如果 AIG 倒下，一切不堪设想，政府必须出手。之后呢？</p>
<blockquote>
<p>In the years of followed, hundreds of bankers and rating-agency’s executives went to jail. The SEC was completely overhauled and congress have no choice but to break up the big banks and regulate the mortgage and derivative industries.</p>
<p>Just kidding!</p>
<p>Banks took the money the American people gave them and used it to pay themselves huge bonuses and lobby the congress to kill the reform, and then they blame immigrants and poor people. And this time, even teachers.</p>
</blockquote>
<h2 id="历史循环"><a href="#历史循环" class="headerlink" title="历史循环"></a>历史循环</h2><p><strong>Break up the big banks</strong></p>
<p>这件事情我们不是没有做过。你不觉得在看前面主角的时候，<code>Morgan Stanley</code> 和 <code>JPMorgan Chase</code>两家听起来好像有点关联吗？是的，在那次著名的<a href="https://en.wikipedia.org/wiki/Great_Depression" target="_blank" rel="external nofollow noopener noreferrer">大萧条</a>发生之前，他们俩是一家公司。（大萧条也是一个很值得研究的问题，这里先挖个坑）</p>
<p>当时美国政府认为是超级银行（Universal bank）是造成大萧条的原因，于是出台法案禁止商业银行同时从事投资银行业务。在此背景下，摩根银行一分为三，JP摩根成为纯商业银行，摩根士丹利成为投资银行，还有一个摩根负责海外业务，于1990年被德国银行收购。当时的JP摩根，就是摩根大通的前身，2000年并入摩根大通，不再独立存在。</p>
<p>然而，正如中国上千年农业社会的治乱历史循环一样：王朝建立土地重新分配 -&gt; 小农经济土地兼并 -&gt; 农民失地矛盾加重 -&gt; 天灾触发造成叛乱 -&gt; 新的王朝建立开始下一轮循环。看这次金融危机的历史，突然也有了这种感觉。拆分大银行，我们历史上并不是没有做过，但是资本的惯性就是倾向于兼并垄断，拆分之后小公司还是会不停的并购，再一次变成更大的公司，就像这一次发生的一样。</p>
<p>我们这一次没有拆分大的公司，只是因为矛盾还没有那么尖锐而已，真正的矛盾还在酝酿。有人说，科学技术的快速发展使得我们可以脱离这种历史循环。真的是这样吗？我持悲观态度，下一次大萧条并不是没有可能。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这一篇 「资本不眠」是我在看了 <code>The Big Short</code>这部电影的时候一时兴起，尝试去理解那次金融海啸到底发生了什么。在这个过程中，我去搜索那些名词到底意味着什么，这场海啸中到底是谁在参与这次游戏，为什么它会造成那么大的后果，它对于我们又意味着什么。为此，我又看了 <code>Inside Job</code> 和 <code>Too Big To Fail</code>两部纪录片，分别从不同的角度去看这场危机。</p>
<p>看的越多，我越来越意识到，这次 <code>房地产泡沫</code> 绝不是偶然。它和 2000 年的那场 <code>互联网泡沫</code>密切相关，它和 90 年代冷战后美国霸主地位的建立密切相关，它和 80 年代的<code>里根大循环</code>密切相关，它和 70 年代<code>布雷顿森林体系</code>的解散密切相关，它和那两次世界大战密切相关……</p>
<p>到这里就结束了吗？哦不，上面这么多的坑都还没有填呢，还有 <code>Margin Call</code> 和 <code>Panic: The Untold Story of the 2008 Financial Crisis</code>还没有看呢。资本永不眠，这里只是一个程序猿尝试用自己的方式去理解这个世界，下次再见：）</p>
<p>P.S. 本来想把所有的这些内容做成一个视频传到 B 站上的，但是发现视频剪辑真的是一个深坑，下次一定？</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://movie.douban.com/subject/26303622/" target="_blank" rel="external nofollow noopener noreferrer">The Big Short</a></li>
<li><a href="https://movie.douban.com/subject/4843480/" target="_blank" rel="external nofollow noopener noreferrer">Inside Job</a></li>
<li><a href="https://movie.douban.com/subject/6013501/" target="_blank" rel="external nofollow noopener noreferrer">Too Big To Fail</a></li>
<li><a href="https://www.zhihu.com/question/39012069" target="_blank" rel="external nofollow noopener noreferrer">如何评价电影《大空头》的专业性</a></li>
</ul>
]]></content>
      <categories>
        <category>资本不眠</category>
      </categories>
      <tags>
        <tag>经济危机</tag>
        <tag>电影评论</tag>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title>【交易笔记】看懂经济新闻</title>
    <url>/posts/43a993d5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>昨天晚上美联储会议中紧急降息，将联邦基准利率下调 50 个基点，理由是新冠肺炎疫情不断变化的风险。美联储降息是正常的，但是会议中紧急降息是少见的，而且还是下降 50 个基点。可是，降息并没有带来股市的大幅反弹，道指盘中冲高回落，最终收于 25917.41 点，较前日下跌 785.91 点，跌幅 2.94%。有人说这次大跌是因为市场害怕桑德斯，也有人说这是因为今年七月即将迎来美国企业债务大规模到期。</p>
<p>我不懂，只是感觉害怕，看看那些为数不多美联储紧急加息的情况吧：</p>
<ul>
<li>2020.03.03，新冠疫情全球扩散，美联储紧急降息 50 个基点到 1%~1.25%的范围</li>
<li>2008.10.08，雷曼兄弟破产，市场恐慌情绪蔓延，美联储紧急降息 50 个基点到 1.5%</li>
<li>2008.01.22，次贷危机继续蔓延，美联储紧急降息 75 个基点到 3.5%以应对危机</li>
<li>2007.08.17，次贷危机开始爆发，美联储紧急降息 50 个基点到 5.75%以提供流动性</li>
<li>2001.09.17，911 恐怖袭击之后，美联储紧急降息 50 个基点到 3%以承诺给市场罕见巨大的流动性</li>
<li>2001.04.18，互联网泡沫破灭后经济持续低迷，美联储紧急降息 50 个基点到 4.5%</li>
<li>2001.01.03，互联网泡沫破灭，美联储紧急降息 50 个基点到 6%</li>
<li>1998.10.15，俄罗斯债务危机爆发，美联储紧急降息25 个基点到 5%</li>
</ul>
<p>可是即使是这样，Donald 还是觉得不够，还在喊着<code>More easing and cutting</code>。我不懂发生了什么，于是整理了一份关于新闻中常见经济名词指标的笔记，感觉要见证历史了。</p>
<a id="more"></a>
<h2 id="基本面"><a href="#基本面" class="headerlink" title="基本面"></a>基本面</h2><h3 id="GDP"><a href="#GDP" class="headerlink" title="GDP"></a>GDP</h3><iframe src="https://www.ceicdata.com/datapage/embed/o_china_gdp-ytd?type=column&period=max&lang=zh-hans&start_date_full=1991-12-01&end_date_full=2019-12-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fgross-domestic-product-quarterly%2Fgdp-ytd" width="1200" height="500" frameborder="0"></iframe>

<p>到 2020 年，国内 GDP 已经增长到 100 万亿元人民币的规模。</p>
<h3 id="PMI"><a href="#PMI" class="headerlink" title="PMI"></a>PMI</h3><p>PMI，<code>Purchasing Managers&#39; Index</code>，采购经理指数。</p>
<p>PMI 是通过对采购经理的月度调查汇总出来的指数，能够反映经济的变化趋势，是一个具有风向标性质的先行指标。PMI是一套<strong>月度发布</strong>的、综合性的经济监测指标体系，分为<strong>制造业PMI</strong>、<strong>服务业PM</strong>I，也有一些国家建立了建筑业PMI。</p>
<p>按照国际上通用的做法，制造业PMI综合指数由五个扩散指数即新<strong>订单</strong>指数、<strong>生产</strong>指数、<strong>从业人员</strong>指数、供应商<strong>配送</strong>时间指数、主要原材料<strong>库存</strong>指数加权而成。</p>
<p>计算公式如下：</p>
<script type="math/tex; mode=display">PMI = 订单权重×0.3+产品生产权重×0.25+就业情况权重×0.2+厂商表现权重×0.15+存货权重比例×0.10</script><p>采购经理人指数是以百分比来表示,常以50%作为经济强弱的分界点：当指数高于50%时，则被解释为经济扩张的讯号。当指数低于50%，尤其是非常接近40%时，则有经济萧条的忧虑。一般在40~50之间时，说明制造业处于衰退，但整体经济还在扩张。</p>
<iframe src="https://www.ceicdata.com/datapage/embed/o_china_purchasing-managers-index?type=area&period=max&lang=zh-hans&start_date_full=2005-01-01&end_date_full=2020-02-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fpurchasing-managers-index-manufacturing%2Fpurchasing-managers-index" width="1200" height="500" frameborder="0"></iframe>

<iframe src="https://www.ceicdata.com/datapage/embed/o_china_cn-pmi-non-mfg-business-activity?type=area&from=2019-03-01&to=2020-02-01&lang=zh-hans&start_date_full=2007-01-01&end_date_full=2020-02-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fpurchasing-managers-index-non-manufacturing" width="1200" height="500" frameborder="0"></iframe>

<p>看上图的PMI指数，有两次严重低于 50 荣枯线一下，一次是 2008 年金融危机，另一次就是这次的新冠疫情。2008年金融危机时，2008年11月，也就是四万亿刺激计划出台当月，中国的制造业PMI指数是38.8，而目前（2020 年 2 月）为35.7；2008 年 11 月，非制造业PMI指数为51.2，目前为29.6，从PMI看目前的形势可能非常严峻。</p>
<h3 id="CPI"><a href="#CPI" class="headerlink" title="CPI"></a>CPI</h3><p>CPI, <code>Consumer Price Index</code>，消费者价格指数。</p>
<p>对于某个具体商品的 CPI 指数计算如下，也就是该商品今年价格相对于基期价格的比值。</p>
<script type="math/tex; mode=display">Consumer\ Price\ Index = \frac{Market\ Basket\ of\ Desired\ Year}{Market\ Basket\ of\ Base\ Year} * 100</script><p>对于整个经济社会的 CPI 指数计算如下，也就是说一篮子商品按照各自权重算出来的 CPI 指数。</p>
<script type="math/tex; mode=display">CPI = \frac{\sum_{i=1}^{n}CPI_i * weight_i}{\sum_{i=1}^{n}weight_i}</script><p>在这里，我国的<code>一篮子商品</code>的权重如下所示，可以看到<strong>食品占到了三成以上，是CPI里面权重占比最大的构成</strong>，所以有人也笑称，CPI 在中国是 <code>China Pig Index</code>，过去半年来猪肉价格猛涨，也直接促成了 CPI 的快速增长。</p>
<p><img alt="2018年中国CPI一篮子组成" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-03_cpi-basket-weight.jpg"></p>
<p>CPI 是评价通货膨胀最重要的指标之一。<strong>一般来说，当CPI&gt;3%的增幅时通常会被认定为进入了通货膨胀的区间</strong>，这里的3%是同比上一年对应月份的统计指标，例如2010年7月份我国居民消费价格总水平比2009年7月居民消费价格水平上涨3%以上。但是，一般不能以某一个月涨幅超过3%来判断是否发生通货膨胀，而是以连续几个月超过3%来判断是否进入通货膨胀。2010年，我国全年平均CPI同比上涨3.3%，显然已进入通货膨胀区间。<strong>而当CPI同比&gt;5%的增幅并持续数月时，我们把它称为严重通货膨胀</strong>。当然如果在通货紧缩或者经济低迷时期，CPI指数出现升值，对我们观察经济企稳回升提供了积极的市场信号。</p>
<p>这里是中国近四十年的 CPI 指数变化情况：</p>
<iframe src="https://www.ceicdata.com/datapage/embed/ipc_china_consumer-price-index-cpi-growth?type=area&period=max&lang=zh-hans&start_date_full=1985-01-01&end_date_full=2020-01-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Findicator%2Fchina%2Fconsumer-price-index-cpi-growth" width="1200" height="500" frameborder="0"></iframe>

<p>可以看到，在上世纪八十年代末物价闯关失败，CPI 一度超过 25%，这直接造成了那一年春夏之交的政治风波。事件发生后，连续三年改革停滞，CPI 停留在 5%以下。邓小平南巡后，物价双轨制改革继续，全面放开商品价格，CPI 再度高涨。九十年代后期，价格并轨完成，CPI 指数从此在没有大幅超过 5%。进入新世纪，2008 年和 2011 年两次 CPI 大幅上涨，一时间房价暴涨，<code>豆你玩 蒜你狠 姜你军</code>甚嚣尘上。</p>
<p>最近一年来，猪肉价格显著上升，根据最新数据，2020 年 1 月的 CPI 指数同比上涨 5.4%，其中猪肉价格上涨116.0%， 影响CPI上涨约2.76个百分点。</p>
<h3 id="PPI"><a href="#PPI" class="headerlink" title="PPI"></a>PPI</h3><p>PPI，<code>Producer Price Index</code>，生产价格指数。</p>
<p>与CPI不同，PPI主要的目的是衡量企业购买的一篮子物品和劳务的总费用，通常以大宗商品作为计算对象，比如<strong>水泥，玻璃，有色，钢铁，煤炭</strong>等。</p>
<iframe src="https://www.ceicdata.com/datapage/embed/o_china_producer-price-index-industrial-products?type=area&period=max&lang=zh-hans&start_date_full=1996-10-01&end_date_full=2019-12-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fproducer-price-index-monthly%2Fproducer-price-index-industrial-products" width="1200" height="500" frameborder="0"></iframe>

<p>一般来说，当工业品涨价以后（PPI上涨），下游制造企业因为成本增加，也会涨价，最后消费者买的的商品价格上涨（CPI上涨），所以<strong>PPI对CPI有一定的传导性</strong>。</p>
<p>对比上面的 CPI 曲线，我们可以发现，在2012年3月-2016年5月，PPI增速为负而CPI增速为正，说明上游企业在降价卖，而下游企业却在涨价卖。这是因为2008年<strong>4万亿计划</strong>，导致基建相关上游企业过度扩张，产量飙升。到2012年，上游企业生产的大量的工业品，消费端用不完，供大于求，此时已经是<strong>买方市场</strong>。可怜的上游企业只能挤压自己的利润空间，降价促销（也不见得卖的出去）。2016年后，随着中国<strong>供给侧改革</strong>，环保督察的推进，工业企业主动去库存，淘汰了过剩的低端产能，导致了此后维持2年的PPI上涨。</p>
<p>通过PPI我们可以观察企业生产的活跃情况。如果PPI呈现通缩状态，说明企业生产不积极，经济有下行风险。如果PPI温和膨胀，反映经济正积极增长。如果PPI严重通胀，说明经济有过热风险。</p>
<h3 id="M2"><a href="#M2" class="headerlink" title="M2"></a>M2</h3><p>M2，<strong>广义货币供应量</strong>，是指流通于银行体系之外的现金加上企业存款、居民储蓄存款以及其他存款，它包括了一切可能成为现实购买力的货币形式，通常反映的是社会总需求变化和未来通胀的压力状态。近年来，很多国家都把M2作为货币供应量的调控目标。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">M0</span> = 流通中的现金</span><br><span class="line"><span class="attr">M1</span> = M0 + 企业活期存款</span><br><span class="line"><span class="attr">M2</span> = M1 + 定期存款 + 居民储蓄存款 + 其他存款</span><br></pre></td></tr></table></figure>
<iframe src="https://www.ceicdata.com/datapage/embed/o_china_money-supply-m0?type=area&from=2019-02-01&to=2020-01-01&lang=zh-hans&start_date_full=1997-01-01&end_date_full=2020-01-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fmoney-supply%2Fmoney-supply-m0" width="1200" height="500" frameborder="0"></iframe>

<iframe src="https://www.ceicdata.com/datapage/embed/o_china_money-supply-m1?type=area&period=max&lang=zh-hans&start_date_full=1997-01-01&end_date_full=2020-01-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fmoney-supply%2Fmoney-supply-m1" width="1200" height="500" frameborder="0"></iframe>

<iframe src="https://www.ceicdata.com/datapage/embed/o_china_money-supply-m2?type=area&from=2019-02-01&to=2020-01-01&lang=zh-hans&start_date_full=1997-01-01&end_date_full=2020-01-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Fmoney-supply%2Fmoney-supply-m2" width="1200" height="500" frameborder="0"></iframe>

<p>到 2020 年 1 月，国内 M2 已经增长到 200 万亿元人民币的规模。</p>
<h3 id="社会融资规模"><a href="#社会融资规模" class="headerlink" title="社会融资规模"></a>社会融资规模</h3><iframe src="https://www.ceicdata.com/datapage/embed/o_china_aggregate-financing?type=column&period=1y&lang=zh-hans&start_date_full=2002-12-01&end_date_full=2020-01-01&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Faggregate-financing" width="1200" height="500" frameborder="0"></iframe>

<p>到 2020 年，社会融资总量已经到达 200 万亿人民币的规模。</p>
<h2 id="货币政策"><a href="#货币政策" class="headerlink" title="货币政策"></a>货币政策</h2><p>货币政策是指<strong>中央银行</strong>为实现其特定的经济目标而采用的各种控制和调节<strong>货币供应量</strong>和<strong>信用量</strong>的方针、政策和措施的总称</p>
<h3 id="调整存款准备金率"><a href="#调整存款准备金率" class="headerlink" title="调整存款准备金率"></a>调整存款准备金率</h3><p>现代银行是建立在<strong>准备金制度</strong>上的，银行通过贷出绝大部分存款来获得利润。<strong>法定存款准备金率</strong>是指商业银行按法律规定存放在中央银行的存款与其<strong>吸收存款</strong>的比率。</p>
<p>若中央银行采取<strong>紧缩政策</strong>，中央银行<strong>提高法定存款准备金率</strong>，则限制了商业银行的信用扩张能力，<strong>降低了货币乘数</strong>，最终起到收缩<strong>货币供应量</strong>和<strong>信贷量</strong>的效果，反之亦然。</p>
<iframe src="https://www.ceicdata.com/datapage/embed/o_china_cn-required-reserve-ratio?type=area&period=max&lang=zh-hans&start_date_full=2003-09-21&end_date_full=2020-03-05&ref=https%3A%2F%2Fwww.ceicdata.com%2Fzh-hans%2Fchina%2Frequired-reserve-ratio%2Fcn-required-reserve-ratio" width="1200" height="500" frameborder="0"></iframe>

<p>因为法定存款准备金率对货币乘数的影响很大，作用力度很强，而且一般成效慢，所以不会轻易使用。</p>
<h3 id="调整基准利率"><a href="#调整基准利率" class="headerlink" title="调整基准利率"></a>调整基准利率</h3><h3 id="调整再贴现率"><a href="#调整再贴现率" class="headerlink" title="调整再贴现率"></a>调整再贴现率</h3><p><strong>再贴现</strong>是指商业银行持客户贴现的商业票据向中央银行请求贴现，以取得中央银行的信用支持。就广义而言，再贴现政策并不单纯指中央银行的再贴现业务，也包括中央银行向商业银行提供的其他放款业务。</p>
<p>再贴现政策的基本内容是中央银行根据政策需要调整<strong>再贴现率</strong>，当中央银行提高再贴现率时，存款货币银行借入资金的成本上升，基础货币得到收缩，反之亦然。</p>
<h3 id="公开市场操作"><a href="#公开市场操作" class="headerlink" title="公开市场操作"></a>公开市场操作</h3><p>公开市场操作，<code>Open Market Operations</code>，是指中央银行通过买进或者卖出有价证券，吞吐基础货币，调节货币供应量的活动。</p>
<p>根据经济形势的发展，当中央银行认为需要收缩银根时，便卖出证券，相应地收回一部分基础货币，减少金融机构可用资金的数量；相反，当中央银行认为需要放松银根时，便买入证券，扩大基础货币供应，直接增加金融机构可用资金的数量。</p>
<h4 id="回购"><a href="#回购" class="headerlink" title="回购"></a>回购</h4><p>正回购为中国人民银行向<strong>一级交易商</strong>卖出有价证券，并约定在未来特定日期买回有价证券的交易行为，正回购为<strong>央行从市场收回流动性的操作</strong>，正回购到期则为央行向市场投放流动性的操作。</p>
<h4 id="逆回购"><a href="#逆回购" class="headerlink" title="逆回购"></a>逆回购</h4><p>逆回购为中国人民银行向一级交易商<strong>购买有价证券</strong>，并约定在未来特定日期将有价证券卖给一级交易商的交易行为，<strong>逆回购为央行向市场上投放流动性的操作</strong>，逆回购到期则为央行从市场收回流动性的操作</p>
<h4 id="SLO"><a href="#SLO" class="headerlink" title="SLO"></a>SLO</h4><p>SLO，<code>Short-term Liquidity Operations</code>，即公开市场短期流动性调节工具，本质上是<strong>超短期的逆回购</strong>。这里的短期以7天期以内短期回购为主，遇节假日可适当延长操作期限。</p>
<h3 id="创新型货币工具"><a href="#创新型货币工具" class="headerlink" title="创新型货币工具"></a>创新型货币工具</h3><h4 id="SLF"><a href="#SLF" class="headerlink" title="SLF"></a>SLF</h4><p><code>Standing Lending Facility</code>，常备借贷便利。</p>
<p>大型金融机构缺钱了，可以向央行一对一申请抵押贷款，期限一般是1到3个月。一般在市场缺钱的时候，才用SLF来补充流动性。央行可以通过SFL进行短期利率引导，将其作为“利率走廊”上限（下限是超额存款准备金率），就是说，如果市场利率大于某个值，有可能触发央行强制使用，阻止金融机构之间的拆借，转向央行贷款。这个工具不常用，平常备着，所以叫“常备”。</p>
<h4 id="MLF"><a href="#MLF" class="headerlink" title="MLF"></a>MLF</h4><p><code>Medium-term Lending Facility</code>，中期借贷便利。</p>
<p>这工具要求借钱的银行投放于<strong>三农</strong>和<strong>小微贷款</strong>，期限一般为3个月、6个月和1年。MLF的量很大，央行每月进行常态化操作，2016年前三季度累计开展操作 3.2万亿元，期末余额为 1.9万亿元，成为基础货币供给的重要渠道，并以此引导中期利率。</p>
<h4 id="PSL"><a href="#PSL" class="headerlink" title="PSL"></a>PSL</h4><p><code>Pledged Supplementary Lending</code>，抵押补充贷款。</p>
<p>央妈为了支持特定政策性银行完成国家重点项目（例如国开行的棚改项目），直接提供一部分低成本抵押资金，期限是3-5年，这就是抵押补充贷款。</p>
<h4 id="LPR"><a href="#LPR" class="headerlink" title="LPR"></a>LPR</h4><p><code>Loan Prime Rate</code>，贷款基础利率</p>
<h3 id="外汇市场操作"><a href="#外汇市场操作" class="headerlink" title="外汇市场操作"></a>外汇市场操作</h3><h2 id="财政政策"><a href="#财政政策" class="headerlink" title="财政政策"></a>财政政策</h2><p>财政政策是指<strong>政府</strong>根据一定时期政治、经济、社会发展的任务而规定的财政工作的指导原则，通过<strong>财政支出</strong>与<strong>税收政策</strong>来调节<strong>总需求</strong>。</p>
<h3 id="政策分类"><a href="#政策分类" class="headerlink" title="政策分类"></a>政策分类</h3><ul>
<li><strong>扩张性</strong>财政政策<ul>
<li>通过财政分配活动来增加和刺激社会的总需求</li>
<li>主要措施有：<strong>增加国债</strong>、<strong>降低税率</strong>、<strong>提高政府购买</strong>和<strong>转移支付</strong>。</li>
</ul>
</li>
<li><strong>紧缩性</strong>财政政策<ul>
<li>通过财政分配活动来减少和抑制总需求</li>
<li>主要措施有：减少国债、提高税率、减少政府购买和转移支付。</li>
</ul>
</li>
<li>中性财政政策<ul>
<li>财政的分配活动对社会总需求的影响保持中性。</li>
</ul>
</li>
</ul>
<h3 id="政策工具"><a href="#政策工具" class="headerlink" title="政策工具"></a>政策工具</h3><ul>
<li>国家预算</li>
<li>税收</li>
<li>财政投资</li>
<li>财政补贴</li>
<li>财政信用</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这里只是简单列出了新闻中常见的一些经济学名词，对于这些名词之间的内在逻辑性自己还没有一个清晰的体系和框架。不过幸好，在查阅资料的时候，我在 B 站发现了国发院男神徐高老师的 <a href="https://www.bilibili.com/video/av70557114" target="_blank" rel="external nofollow noopener noreferrer">宏观经济学二十五讲：中国视角</a> 课程。简单听了两节课，一下子勾起了我的兴趣，这不就是我想要的教学逻辑嘛：）</p>
<p>先把坑挖在这里，等我把课程看完，应该对这里的各种指标有自己的认识吧。至少，你对于中国经济问题，可以得到一个体系化的思考范式，这就是我想要的。</p>
]]></content>
      <categories>
        <category>资本不眠</category>
      </categories>
      <tags>
        <tag>股票</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 插入 Mermaid 图表</title>
    <url>/posts/3fcce178/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Mermaid</code> 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。本文介绍了在 Hexo 中集成 <code>Mermaid</code>图表的过程，并展示了 <code>Mermaid</code>的使用方法。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>NexT 主题已经支持了 <code>mermaid</code> 功能，我们只需要在主题配置文件中打开即可</p><a id="more"></a>

<figure class="highlight yaml"><figcaption><span>next/_config.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>
<p>同时，在本地 typora 编辑器也原生支持了 <code>mermaid</code>的功能，二者可无缝切换。</p>
<div class="note info">
            <p>在 NexT 的<a href="https://theme-next.org/docs/tag-plugins/mermaid.html" target="_blank" rel="external nofollow noopener noreferrer">说明文档中</a>使用 mermaid 应该用下面这种语法</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">mermaid</span> <span class="string">type</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">endmermaid</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure><p>但是，typora 编辑器本地是使用 <span class="label primary">mermaid</span> 语法，也即是我们常见的三个反引号插入代码的语法。</p><p>经过测试，发现即使写成<span class="label primary">mermaid</span>语法，NexT 也是能够解析的，棒！</p>
          </div>
<div class="note warning">
            <p>按照 NexT 的<a href="https://theme-next.org/docs/tag-plugins/mermaid.html" target="_blank" rel="external nofollow noopener noreferrer">说明文档</a>，我们只需要修改主题配置文件，但是最开始的时候并不 work，尝试后发现安装好 <code>hexo-filter-mermaid-diagrams</code>插件就好了，疑惑。</p>
          </div>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>流程图语法如下：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  单独节点</span><br><span class="line">  开始 -- 带注释写法<span class="number">1</span><span class="function"> --&gt;</span> 结束</span><br><span class="line">  开始<span class="function"> --&gt;</span>|带注释写法<span class="number">2</span>| 结束</span><br><span class="line">  实线开始 --- 实线结束</span><br><span class="line">  实线开始<span class="function"> --&gt;</span> 实线结束</span><br><span class="line">  实线开始<span class="function"> --&gt;</span>|带注释| 实线结束</span><br><span class="line">  虚线开始 -.- 虚线结束</span><br><span class="line">  虚线开始 -.-&gt; 虚线结束</span><br><span class="line">  虚线开始 -.-&gt;|带注释| 虚线结束</span><br><span class="line">  粗线开始 === 粗线结束</span><br><span class="line">  粗线开始 ==&gt; 粗线结束</span><br><span class="line">  粗线开始 ==&gt;|带注释| 粗线结束</span><br><span class="line">  subgraph 子图标题</span><br><span class="line">    子图开始<span class="function"> --&gt;</span> 子图结束</span><br><span class="line">  end</span><br><span class="line">  节点<span class="number">1</span>[方形文本框]<span class="function"> --&gt;</span> 节点<span class="number">2</span>&#123;菱形文本框&#125;</span><br><span class="line">  节点<span class="number">3</span><span class="function"><span class="params">(括号文本框)</span> --&gt;</span> 节点<span class="number">4</span>((圆形文本框))</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<pre class="mermaid">graph LR
  单独节点
  开始 -- 带注释写法1 --> 结束
  开始 -->|带注释写法2| 结束
  实线开始 --- 实线结束
  实线开始 --> 实线结束
  实线开始 -->|带注释| 实线结束
  虚线开始 -.- 虚线结束
  虚线开始 -.-> 虚线结束
  虚线开始 -.->|带注释| 虚线结束
  粗线开始 === 粗线结束
  粗线开始 ==> 粗线结束
  粗线开始 ==>|带注释| 粗线结束
  subgraph 子图标题
    子图开始 --> 子图结束
  end
  节点1[方形文本框] --> 节点2{菱形文本框}
  节点3(括号文本框) --> 节点4((圆形文本框))</pre>



<ul>
<li>图的方向支持一下几种方式：</li>
</ul>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">TB - 从上到下(<span class="built_in">top</span> buttom)</span><br><span class="line">BT - 从下到上(buttom <span class="built_in">top</span>)</span><br><span class="line">LR - 从左到右(<span class="built_in">left</span> <span class="built_in">right</span>)</span><br><span class="line">RL - 从右到左(<span class="built_in">right</span> <span class="built_in">left</span>)</span><br><span class="line">TD - 跟 TB 相同</span><br></pre></td></tr></table></figure>
<ul>
<li>三种线类型</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">--- </span>: 实线</span><br><span class="line">-.- : 虚线</span><br><span class="line"><span class="section">=== : 粗线</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虚线带箭头的话加 <code>&gt;</code> ，实线和粗线则最后一个字符替换成 <code>&gt;</code></li>
<li>注释的两种写法(中间加注释，后边加注释)</li>
</ul>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">-- <span class="comment">中间加注释写法</span> --&gt;</span><br><span class="line">--&gt;<span class="comment">|后边加注释写法|</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文本框类型</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[]</span> <span class="selector-tag">-</span> 方形文本框</span><br><span class="line">&#123;&#125; <span class="selector-tag">-</span> 菱形文本框</span><br><span class="line">() <span class="selector-tag">-</span> 边角圆滑文本框</span><br><span class="line">(()) <span class="selector-tag">-</span> 圆形文本框</span><br></pre></td></tr></table></figure>
<ul>
<li>子图</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">subgraph 子图标题</span><br><span class="line">  子图开始 <span class="comment">--&gt; 子图结束</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基础fontawesome支持</li>
</ul>
<p>如果想加入来自frontawesome的图表字体,需要像frontawesome网站上那样引用的那样，详情请点击：<a href="http://fontawesome.io/" target="_blank" rel="external nofollow noopener noreferrer">fontawdsome</a></p>
<p>引用的语法为：++fa:#icon class name#++</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">      B[<span class="string">"fa:fa-twitter for peace"</span>]</span><br><span class="line">      B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">      B--&gt;D(fa:fa-spinner);</span><br><span class="line">      B--&gt;E(A fa:fa-camerra-retro perhaps?);</span><br></pre></td></tr></table></figure>
<p>渲染图如下：</p>
<pre class="mermaid">graph TD
      B["fa:fa-twitter for peace"]
      B-->C[fa:fa-ban forbidden]
      B-->D(fa:fa-spinner);
      B-->E(A fa:fa-camera-retro perhaps?);</pre>







<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>时序图以 <code>sequenceDiagram</code> 开头声明，语法如下所示</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    A<span class="function"><span class="title">lice</span>-&gt;</span>&gt;John: Hello John, how are you?</span><br><span class="line">    <span class="keyword">loop</span> Healthcheck</span><br><span class="line">        J<span class="function"><span class="title">ohn</span>-&gt;</span>&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail!</span><br><span class="line">    J<span class="function"><span class="title">ohn</span>--&gt;</span>&gt;Alice: Great!</span><br><span class="line">    J<span class="function"><span class="title">ohn</span>-&gt;</span>&gt;Bob: How about you?</span><br><span class="line">    B<span class="function"><span class="title">ob</span>--&gt;</span>&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<pre class="mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice->>John: Hello John, how are you?
    loop Healthcheck
        John->>John: Fight against hypochondria
    end
    Note right of John: Rational thoughts <br>prevail!
    John-->>Alice: Great!
    John->>Bob: How about you?
    Bob-->>John: Jolly good!</pre>

<ul>
<li>参与者（participant）</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">participant 名称<span class="number">1</span></span><br><span class="line">participant 名称<span class="number">2</span></span><br><span class="line">participant A <span class="keyword">as</span> <span class="string">Alice  :</span> 通过 <span class="keyword">as</span> 定义别名，后续使用 A 比较方便</span><br></pre></td></tr></table></figure>
<p><strong>注：声明的顺序与画图的顺序一致</strong></p>
<ul>
<li>箭头类型（一个<code>&gt;</code>不带箭头, 两个<code>&gt;</code>带箭头; 一个<code>-</code>实线，两个<code>-</code>虚线）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center">实线不带箭头</td>
</tr>
<tr>
<td style="text-align:center">—&gt;</td>
<td style="text-align:center">虚线不带箭头</td>
</tr>
<tr>
<td style="text-align:center">-&gt;&gt;</td>
<td style="text-align:center">实线带箭头</td>
</tr>
<tr>
<td style="text-align:center">—&gt;&gt;</td>
<td style="text-align:center">虚线带箭头</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:center">实线结尾带X</td>
</tr>
<tr>
<td style="text-align:center">—x</td>
<td style="text-align:center">虚线结尾带X</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>激活参与者</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">activate <span class="string">John    :</span> 激活参与者</span><br><span class="line">deactivate <span class="string">John  :</span> 去激活参与者</span><br><span class="line"></span><br><span class="line">也可以通过在 &gt; 后面使用 +/- 符号表示激活和去激活，例如：</span><br><span class="line"></span><br><span class="line">Alice-&gt;&gt;+<span class="string">John:</span> Hello John, how are you?</span><br></pre></td></tr></table></figure>
<ul>
<li>注释</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Note [ right of | left of | over ] [Actor]: Text <span class="keyword">in</span><span class="built_in"> note </span>content</span><br><span class="line"></span><br><span class="line">注: Actor 可以是多个，通过逗号分割，例如：</span><br><span class="line"></span><br><span class="line">Note over Alice,John: A typical interaction</span><br></pre></td></tr></table></figure>
<ul>
<li>循环序列</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> 描述文本</span><br><span class="line"><span class="params">...</span> 时序图语句 <span class="params">...</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    A<span class="function"><span class="title">lice</span>-&gt;</span>John: Hello John, how are you?</span><br><span class="line">    <span class="keyword">loop</span> Every minute</span><br><span class="line">        J<span class="function"><span class="title">ohn</span>--&gt;</span>Alice: Great!</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p>显示效果</p>
<pre class="mermaid">sequenceDiagram
    Alice->John: Hello John, how are you?
    loop Every minute
        John-->Alice: Great!
    end</pre>

<ul>
<li>条件时序</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">alt 描述文本</span><br><span class="line"><span class="params">...</span> statements <span class="params">...</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="params">...</span> statements <span class="params">...</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    A<span class="function"><span class="title">lice</span>-&gt;</span>&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt <span class="keyword">is</span> sick</span><br><span class="line">        B<span class="function"><span class="title">ob</span>-&gt;</span>&gt;Alice: Not so good</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">is</span> well</span><br><span class="line">        B<span class="function"><span class="title">ob</span>-&gt;</span>&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p>显示效果</p>
<pre class="mermaid">sequenceDiagram
    Alice->>Bob: Hello Bob, how are you?
    alt is sick
        Bob->>Alice: Not so good
    else is well
        Bob->>Alice: Feeling fresh like a daisy
    end</pre>

<ul>
<li>可选时序</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">opt 描述文本</span><br><span class="line">... statements ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sequenceDiagram</span></span><br><span class="line">    Alice-&gt;&gt;<span class="keyword">Bob: </span>Hello <span class="keyword">Bob, </span>how are you?</span><br><span class="line">    <span class="meta">opt</span> Extra response</span><br><span class="line">        <span class="keyword">Bob-&gt;&gt;Alice: </span>Fine,Thanks</span><br><span class="line">    <span class="meta">end</span></span><br></pre></td></tr></table></figure>
<p>显示效果</p>
<pre class="mermaid">sequenceDiagram
    Alice->>Bob: Hello Bob, how are you?
    opt Extra response
        Bob->>Alice: Fine,Thanks
    end</pre>



<h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h2><p>甘特图以 <code>gantt</code> 开头，用 <code>section</code>划分任务集，语法如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 甘特图的标题</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, <span class="number">2014</span><span class="number">-01</span><span class="number">-01</span>, <span class="number">30</span>d</span><br><span class="line">    Another task     :after a1  , <span class="number">20</span>d</span><br><span class="line">    section Another</span><br><span class="line">    Task <span class="keyword">in</span> sec      :<span class="number">2014</span><span class="number">-01</span><span class="number">-12</span>  , <span class="number">12</span>d</span><br><span class="line">    another task      : <span class="number">24</span>d</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">       dateFormat  YYYY-MM-DD</span><br><span class="line">       title Adding GANTT diagram functionality <span class="keyword">to</span> mermaid</span><br><span class="line"></span><br><span class="line">       section A section</span><br><span class="line">       Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">       Active task               :active,  des2, 2014-01-09, 1d</span><br><span class="line">       Future task               :         des3, after des2, 1d</span><br><span class="line">       Future task2              :         des4, after des3, 1d</span><br><span class="line"></span><br><span class="line">       section Critical tasks</span><br><span class="line">       Completed task <span class="keyword">in</span> the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">       Implement parser <span class="keyword">and</span> jison          :crit, done, after des1, 1d</span><br><span class="line">       Create tests <span class="keyword">for</span> parser             :crit, active, 1d</span><br><span class="line">       Future task <span class="keyword">in</span> critical line        :crit, 10h</span><br><span class="line">       Create tests <span class="keyword">for</span> renderer           :1d</span><br><span class="line">       <span class="builtin-name">Add</span> <span class="keyword">to</span> mermaid                      :1d</span><br><span class="line"></span><br><span class="line">       section Documentation</span><br><span class="line">       Describe gantt syntax               :active, a1, after des1, 1d</span><br><span class="line">       <span class="builtin-name">Add</span> gantt diagram <span class="keyword">to</span> demo<span class="built_in"> page </span>     :after a1  , 20h</span><br><span class="line">       <span class="builtin-name">Add</span> another diagram <span class="keyword">to</span> demo<span class="built_in"> page </span>   :doc1, after a1  , 8h</span><br><span class="line"></span><br><span class="line">       section Last section</span><br><span class="line">       Describe gantt syntax               :after doc1, 30h</span><br><span class="line">       <span class="builtin-name">Add</span> gantt diagram <span class="keyword">to</span> demo<span class="built_in"> page </span>     :20h</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<pre class="mermaid">gantt
       dateFormat  YYYY-MM-DD
       title Adding GANTT diagram functionality to mermaid

       section A section
       Completed task            :done,    des1, 2014-01-06,2014-01-08
       Active task               :active,  des2, 2014-01-09, 1d
       Future task               :         des3, after des2, 1d
       Future task2              :         des4, after des3, 1d

       section Critical tasks
       Completed task in the critical line :crit, done, 2014-01-06,24h
       Implement parser and jison          :crit, done, after des1, 1d
       Create tests for parser             :crit, active, 1d
       Future task in critical line        :crit, 10h
       Create tests for renderer           :1d
       Add to mermaid                      :1d

       section Documentation
       Describe gantt syntax               :active, a1, after des1, 1d
       Add gantt diagram to demo page      :after a1  , 20h
       Add another diagram to demo page    :doc1, after a1  , 8h

       section Last section
       Describe gantt syntax               :after doc1, 30h
       Add gantt diagram to demo page      :20h</pre>



<h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Key elements <span class="keyword">in</span> Product X</span><br><span class="line">    <span class="string">"Calcium"</span> : 42.96</span><br><span class="line">    <span class="string">"Potassium"</span> : 50.05</span><br><span class="line">    <span class="string">"Magnesium"</span> : 10.01</span><br><span class="line">    <span class="string">"Iron"</span> :  5</span><br></pre></td></tr></table></figure>
<pre class="mermaid">pie
    title Key elements in Product X
    "Calcium" : 42.96
    "Potassium" : 50.05
    "Magnesium" : 10.01
    "Iron" :  5</pre>

<h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><p>这个用 mermaid 简单的画了下 TCP 的状态转换图，更多的可以参考<a href="https://mermaid-js.github.io/mermaid/#/stateDiagram" target="_blank" rel="external nofollow noopener noreferrer">Mermaid 文档</a></p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">  CLOSED --&gt; LISTEN: Listen/-</span><br><span class="line"></span><br><span class="line">  LISTEN --&gt; CLOSED: <span class="keyword">Close</span>/-</span><br><span class="line">  LISTEN --&gt; SYN_RECEIVED: SYN/SYN+ACK</span><br><span class="line">  LISTEN --&gt; SYN_SENT: Send/SYN</span><br><span class="line"></span><br><span class="line">	SYN_RECEIVED --&gt; LISTEN: RST/-</span><br><span class="line">	SYN_RECEIVED --&gt; FIN_WAIT1: <span class="keyword">Close</span>/FIN</span><br><span class="line">	SYN_RECEIVED --&gt; ESTABLISED: ACK/-</span><br><span class="line">	</span><br><span class="line">	SYN_SENT --&gt; CLOSED: <span class="keyword">Close</span>/-</span><br><span class="line">	SYN_SENT --&gt; SYN_RECEIVED: SYN/SYN+ACK</span><br><span class="line">	SYN_SENT --&gt; ESTABLISED: SYN+ACK/ACK</span><br><span class="line"></span><br><span class="line">	ESTABLISED --&gt; FIN_WAIT1: <span class="keyword">Close</span>/FIN</span><br><span class="line">	ESTABLISED --&gt; CLOSE_WAIT: FIN/ACK</span><br><span class="line"></span><br><span class="line">	FIN_WAIT1 --&gt; CLOSING: FIN/ACK</span><br><span class="line">	FIN_WAIT1 --&gt; FIN_WAIT2: ACK/-</span><br><span class="line">	FIN_WAIT1 --&gt; TIME_WAIT: FIN+ACK/ACK</span><br><span class="line">	</span><br><span class="line">	FIN_WAIT2 --&gt; TIME_WAIT: FIN/ACK</span><br><span class="line">		</span><br><span class="line">	CLOSING --&gt; TIME_WAIT: ACK/-</span><br><span class="line"></span><br><span class="line">	TIME_WAIT --&gt; CLOSED2: <span class="keyword">Timeout</span></span><br><span class="line">	</span><br><span class="line">	CLOSE_WAIT --&gt; LAST_ACK: <span class="keyword">Close</span>/FIN</span><br><span class="line">	</span><br><span class="line">	LAST_ACK --&gt; CLOSED2: ACK/-</span><br></pre></td></tr></table></figure>
<pre class="mermaid">stateDiagram
  CLOSED --> LISTEN: Listen/-

  LISTEN --> CLOSED: Close/-
  LISTEN --> SYN_RECEIVED: SYN/SYN+ACK
  LISTEN --> SYN_SENT: Send/SYN

    SYN_RECEIVED --> LISTEN: RST/-
    SYN_RECEIVED --> FIN_WAIT1: Close/FIN
    SYN_RECEIVED --> ESTABLISED: ACK/-

    SYN_SENT --> CLOSED: Close/-
    SYN_SENT --> SYN_RECEIVED: SYN/SYN+ACK
    SYN_SENT --> ESTABLISED: SYN+ACK/ACK

    ESTABLISED --> FIN_WAIT1: Close/FIN
    ESTABLISED --> CLOSE_WAIT: FIN/ACK

    FIN_WAIT1 --> CLOSING: FIN/ACK
    FIN_WAIT1 --> FIN_WAIT2: ACK/-
    FIN_WAIT1 --> TIME_WAIT: FIN+ACK/ACK

    FIN_WAIT2 --> TIME_WAIT: FIN/ACK

    CLOSING --> TIME_WAIT: ACK/-

    TIME_WAIT --> CLOSED2: Timeout

    CLOSE_WAIT --> LAST_ACK: Close/FIN

    LAST_ACK --> CLOSED2: ACK/-</pre>

<h2 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h2><p>这里是 <a href="https://mermaid-js.github.io/mermaid-live-editor/" target="_blank" rel="external nofollow noopener noreferrer">Mermaid 在线编辑器</a>，你可以在这里实验 Mermaid 语法，还可以导出 SVG 或者 PNG 图片。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="external nofollow noopener noreferrer">https://mermaid-js.github.io/mermaid/</a></li>
<li><a href="https://theme-next.org/docs/tag-plugins/mermaid" target="_blank" rel="external nofollow noopener noreferrer">https://theme-next.org/docs/tag-plugins/mermaid</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>Key Numbers Every Programmer Should Know</title>
    <url>/posts/fb3d782a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文整理了作为程序员应该知道的关键数字，封面图源自 <a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html" target="_blank" rel="external nofollow noopener noreferrer">伯克利每年更新的动态图表</a> ，可视化的展示了每年各种操作的耗时变化，非常形象。</p>
<p><img alt="Key Numbers" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-10_key-numbers.png"></p>
<a id="more"></a>
<h2 id="数据变化"><a href="#数据变化" class="headerlink" title="数据变化"></a>数据变化</h2><p>这里是 2020 年的具体数据：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">           <span class="number">1</span>   ns - CPU L1 CACHE <span class="built_in">ref</span>erence</span><br><span class="line">           <span class="number">1</span>   ns - speed-of-light (a photon) travel a <span class="number">1</span> ft (<span class="number">30.5</span>cm) distance</span><br><span class="line">           <span class="number">3</span>   ns - CPU L1 CACHE Branch mispredict</span><br><span class="line">           <span class="number">4</span>   ns - CPU L2 CACHE <span class="built_in">ref</span>erence</span><br><span class="line">          <span class="number">17</span>   ns - MUTEX lock/unlock</span><br><span class="line">          <span class="number">44</span>   ns - Send <span class="number">2</span>K bytes over Commodity NETWORK</span><br><span class="line">          <span class="number">71</span>   ns - CPU cross-QPI/NUMA best  <span class="keyword">case</span> on XEON E5<span class="number">-46</span>*</span><br><span class="line">         <span class="number">100</span>   ns - own DDR MEMORY <span class="built_in">ref</span>erence</span><br><span class="line">         <span class="number">135</span>   ns - CPU cross-QPI/NUMA best  <span class="keyword">case</span> on XEON E7-*</span><br><span class="line">         <span class="number">202</span>   ns - CPU cross-QPI/NUMA worst <span class="keyword">case</span> on XEON E7-*</span><br><span class="line">         <span class="number">325</span>   ns - CPU cross-QPI/NUMA worst <span class="keyword">case</span> on XEON E5<span class="number">-46</span>*</span><br><span class="line">       <span class="number">2</span>,<span class="number">000</span>   ns - Compress <span class="number">1</span>K bytes with Zippy PROCESS</span><br><span class="line">       <span class="number">3</span>,<span class="number">000</span>   ns - Read <span class="number">1</span> MB sequentially <span class="keyword">from</span> MEMORY</span><br><span class="line">      <span class="number">49</span>,<span class="number">000</span>   ns - Read <span class="number">1</span> MB sequentially <span class="keyword">from</span> SSD</span><br><span class="line">     <span class="number">825</span>,<span class="number">000</span>   ns - Read <span class="number">1</span> MB sequentially <span class="keyword">from</span> DISK</span><br><span class="line">     <span class="number">500</span>,<span class="number">000</span>   ns - Round trip within a same DataCenter</span><br><span class="line">   <span class="number">2</span>,<span class="number">000</span>,<span class="number">000</span>   ns - DISK seek</span><br><span class="line"> <span class="number">150</span>,<span class="number">000</span>,<span class="number">000</span>   ns - Send a NETWORK packet CA -&gt; Netherlands</span><br><span class="line">|   |   |   |</span><br><span class="line">|   |   | ns|</span><br><span class="line">|   | us|</span><br><span class="line">| ms|</span><br></pre></td></tr></table></figure>
<p>根据伯克利每年的数据，可以总结出：</p>
<ul>
<li>从 2005 年后数据有所减少，但是基本稳定的有<ul>
<li>L1 和 L2 的缓存访问稳定在 ns 量级</li>
<li>互斥锁的代价稳定在 17 ns 量级（关于互斥锁的代价，以后可以专门讨论</li>
<li>访问本地内存的代价基本稳定在 100 ns</li>
<li>同一个数据中心的 RTT 稳定在 500 us</li>
<li>从加州到荷兰的 RTT 稳定在 150 ms</li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span> ns        L1 cache</span><br><span class="line">    <span class="number">3</span> ns        Branch mispredict</span><br><span class="line">    <span class="number">4</span> ns        L2 cache</span><br><span class="line">   <span class="number">17</span> ns        Mutex lock/unlock</span><br><span class="line">  <span class="number">100</span> ns        Main memory (RAM)</span><br><span class="line"><span class="number">2</span> <span class="number">000</span> ns (<span class="number">2</span>µs)  <span class="number">1</span>KB Zippy-compress</span><br></pre></td></tr></table></figure>
<ul>
<li>还有很多性能现在获得巨大的改善<ul>
<li>通过网络发送 2KB 数据损耗的时间，从 05 年的 8000ns 改善到现在的 44ns</li>
<li>从内存顺序读出 1MB 数据损耗的时间，从 05 年的 95,000 ns 改善到现在 3,000 ns</li>
<li>从 SSD 顺序读出 1MB 数据损耗的时间，从 05 年的 2,000,000 ns 改善到现在 49,000 ns，也就是从 2ms 优化到 50us 量级</li>
<li>从磁盘顺序读出 1MB 数据损耗的时间，从 05 年的 7,000,000 ns 改善到现在 825,000 ns，也就是从 7ms 优化到 800us 量级</li>
</ul>
</li>
</ul>
<h2 id="数据理解"><a href="#数据理解" class="headerlink" title="数据理解"></a>数据理解</h2><p>下面从定性角度来理解这些数据。</p>
<p><strong>内存</strong>、<strong>SSD</strong>、<strong>磁盘</strong>、<strong>网络</strong> 之间速度的巨大差别了，粗略地讲：</p>
<ul>
<li>SSD比内存慢 10 倍</li>
<li>磁盘比内存慢 300 倍，比 SSD 慢 30 倍</li>
<li>网络比内存慢 10 万倍，比硬盘慢 200 倍</li>
</ul>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>最开始为了提高计算机速度，选择将 CPU 的频率提高，后来计算机的频率到达 3GHz 之后，很难再提高了，所以访问 Cache 和内存的速度也基本不再变化了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Core i7 Xeon <span class="number">5500</span> Series Data Source Latency (approximate)               [Pg. <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line">local  L1 CACHE hit,                              ~<span class="number">4</span> cycles (   <span class="number">2.1</span> -  <span class="number">1.2</span> ns )</span><br><span class="line">local  L2 CACHE hit,                             ~<span class="number">10</span> cycles (   <span class="number">5.3</span> -  <span class="number">3.0</span> ns )</span><br><span class="line">local  L3 CACHE hit, line unshared               ~<span class="number">40</span> cycles (  <span class="number">21.4</span> - <span class="number">12.0</span> ns )</span><br><span class="line">local  L3 CACHE hit, <span class="keyword">shared</span> line <span class="keyword">in</span> another core ~<span class="number">65</span> cycles (  <span class="number">34.8</span> - <span class="number">19.5</span> ns )</span><br><span class="line">local  L3 CACHE hit, modified <span class="keyword">in</span> another core    ~<span class="number">75</span> cycles (  <span class="number">40.2</span> - <span class="number">22.5</span> ns )</span><br><span class="line"></span><br><span class="line">remote L3 CACHE (Ref: Fig<span class="number">.1</span> [Pg. <span class="number">5</span>])        ~<span class="number">100</span><span class="number">-300</span> cycles ( <span class="number">160.7</span> - <span class="number">30.0</span> ns )</span><br><span class="line"></span><br><span class="line">local  DRAM                                                   ~<span class="number">60</span> ns</span><br><span class="line">remote DRAM                                                  ~<span class="number">100</span> ns</span><br></pre></td></tr></table></figure>
<h3 id="NIC"><a href="#NIC" class="headerlink" title="NIC"></a>NIC</h3><p>网卡的速度越来越快，从最早的万兆网卡，到现在100Gb的网卡。</p>
<p>网络带宽越大，<strong>传输延时</strong>越小。</p>
<h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><p>roundtrip in same datacenter 和 packet roundtrip CA to Netherlands 耗时没有任何变化，一致保持 500us 和 150ms，原因很好理解，毕竟信号在光纤中以近似光速传播，该时间由物理规律决定，这里说的是<strong>传播延时</strong>。</p>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>SSD 的随机读取速度从 1990 年到 2019 年变化不同，不过从 19us 提升到 16us，但顺序读取速度却从 50ms 提升到 49us，提升巨大。</p>
<h3 id="DISK"><a href="#DISK" class="headerlink" title="DISK"></a>DISK</h3><p>从 2006 年开始，前两列操作的数值不再变化，只有后两列在变化，说明近十年来存储介质的速度有较大提升。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex的lock或unlock操作代价是17 ns。（所以加锁解锁的操作不耗费时间，锁的大量竞争才耗费，思路降低锁粒度，每个锁对象只保护一小部分数据）</p>
<h3 id="写的代价是很昂贵的"><a href="#写的代价是很昂贵的" class="headerlink" title="写的代价是很昂贵的"></a>写的代价是很昂贵的</h3><ul>
<li>数据存储是事务型的：写需要磁盘访问</li>
<li>磁盘访问意味着磁盘寻道</li>
<li>拇指法则（经验规则）：一次磁盘寻道就往往浪费了10 ms（毫秒）</li>
<li>简单的计算一下： 1s / 10ms = 100 seeks / sec, 也就是1秒磁盘最大寻道次数在100次</li>
</ul>
<p>所以，根据以上法则，要时刻考虑你的数据大小和数据结构，并且要以批量的思想来做，批量写和批量读。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/4087280/approximate-cost-to-access-various-caches-and-main-memory</a></p>
</li>
<li><p><a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html" target="_blank" rel="external nofollow noopener noreferrer">https://colin-scott.github.io/personal_website/research/interactive_latency.html</a></p>
</li>
<li><p><a href="http://www.eecs.berkeley.edu/~rcs/research/hw_trends.xlsx" target="_blank" rel="external nofollow noopener noreferrer">http://www.eecs.berkeley.edu/~rcs/research/hw_trends.xlsx</a></p>
</li>
<li><p><a href="https://software.intel.com/sites/products/collateral/hpc/vtune/performance_analysis_guide.pdf" target="_blank" rel="external nofollow noopener noreferrer">https://software.intel.com/sites/products/collateral/hpc/vtune/performance_analysis_guide.pdf</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>latency</tag>
      </tags>
  </entry>
  <entry>
    <title>Melodies Are Just Math</title>
    <url>/posts/987306d8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>两周前我在 YouTube 上看到一个好玩的视频，讲的是一个斜杠中年 <a href="https://www.linkedin.com/in/damienriehl" target="_blank" rel="external nofollow noopener noreferrer">Damien Riehl</a> 用计算机程序 6 天暴力跑完 C 调所有音乐旋律的事情。<code>Damien Riehl</code> 是一个特别有意思的老哥，他从 2002 年以来一直是一名律师，从 1985 年开始从事编码工作；与此同时，他还是一个音乐家。天…这不是我一直想要成为的样子吗，So Cool ！</p>
<p>在这个视频中，包括他做的一个 TED 演讲，<code>Damien Riehl</code>探讨了人工智能时代音乐与版权等值得思考与讨论的问题。这里是「朝花夕拾」第八期，作为一个音乐小白兼程序猿，我尝试来理解他们到底做了什么。另外，作为一个法盲，也尝试聊一聊音乐版权中的法律问题。</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/sfXn_ecH5Rw" frameborder="0" allowfullscreen></iframe></div>
<a id="more"></a>
<h2 id="Get-Hands-Dirty"><a href="#Get-Hands-Dirty" class="headerlink" title="Get Hands Dirty !"></a>Get Hands Dirty !</h2><p>令人开心的是，<code>Damien Riehl</code>已经把他们工作的代码传到了 <a href="https://github.com/allthemusicllc/atm-cli" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>。看了看，代码使用 <code>Rust</code> 写的，除了一个简单的命令行工具外，还写了一个专门的库 <a href="https://github.com/allthemusicllc/libatm" target="_blank" rel="external nofollow noopener noreferrer">libatm</a>。对于程序猿来说，不怕新语言，就怕没代码。不就是 Rust 吗，看看<a href="https://kaisery.github.io/trpl-zh-cn" target="_blank" rel="external nofollow noopener noreferrer">教程</a>, 就可以开始干活了（正好一直想学一学 Rust ：）</p>
<p>拿到代码，可以看到 client 的代码简单，只是对于 library 的简单封装。（谁说不是呢，一个命令行要多复杂）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">houmin@cosmos:~/atm-cli/src$ ls</span><br><span class="line">cli.rs  directives.rs  lib.rs  main.rs  utils.rs</span><br></pre></td></tr></table></figure>
<p>看看 library，实际上也只有一个简单的 <code>lib.rs</code>，参考他的<a href="https://allthemusicllc.github.io/libatm/libatm/" target="_blank" rel="external nofollow noopener noreferrer">文档</a>可以看到这就是一个专门针对 MIDI 文件的库。它在这里定义了 MIDI 的文件格式，定义了音符，定义了音符序列，定义了音轨…</p>
<p>什么是 MIDI，Why MIDI？</p>
<h2 id="About-MIDI"><a href="#About-MIDI" class="headerlink" title="About MIDI"></a>About MIDI</h2><p>MIDI，<code>Musical Instrument Digital Interface</code>，乐器数字接口 ，是20 世纪80 年代初为解决电声乐器之间的通信问题而提出的。MIDI是编曲界最广泛的音乐标准格式，可称为「计算机能理解的乐谱」。它用音符的数字控制信号来记录音乐。</p>
<p>一首完整的MIDI音乐只有几十KB大，而能包含数十条<strong>音乐轨道</strong>。几乎所有的现代音乐都是用<strong>MIDI</strong>加上<strong>音色库</strong>来制作合成的。MIDI 传输的不是声音信号， 而是音符、控制参数等指令, 它指示 MIDI 设备要做什么，怎么做，如演奏哪个音符、多大音量等，它们被统一表示成 <strong>MIDI消息</strong> (<code>MIDI Message</code>) 。</p>
<h3 id="MIDI-File-Format"><a href="#MIDI-File-Format" class="headerlink" title="MIDI File Format"></a>MIDI File Format</h3><p>MIDI 文件是由一系列的 <code>chunk</code>组成的，每个 <code>chunk</code> 的组成格式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">length</th>
<th style="text-align:center">data</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">length bytes</td>
</tr>
</tbody>
</table>
</div>
<p>这里的  <code>Chunk Type</code>有两种类型：</p>
<ul>
<li><strong>Header Trunks</strong>，也就是 <code>MThd</code>类型</li>
<li><strong>Track Chunks</strong>，也就是 <code>MTrk</code>类型</li>
</ul>
<p>那么一个 MIDI 文件组成如下，开始是一个 <code>Header Trunk</code>，之后跟随着一个或多个<code>Track Chunks</code></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Format|<span class="string">  type  </span>|<span class="string">  length  </span>|<span class="string">                        Data                        </span>|</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">REAL  |<span class="string">  MThd  </span>|<span class="string">    6     </span>|<span class="string">    &lt;format&gt;    </span>|<span class="string">    &lt;tracks&gt;    </span>|<span class="string">    &lt;division&gt;    </span>|</span><br><span class="line">MIDI  |<span class="string">  MTrk  </span>|<span class="string"> &lt;length&gt; </span>|<span class="string">            &lt;delta_time&gt; &lt;event&gt; ...                </span>|</span><br><span class="line">FILE  |<span class="string">                                :                                       </span>|</span><br><span class="line">DATA  |<span class="string">  MTrk  </span>|<span class="string"> &lt;length&gt; </span>|<span class="string">            &lt;delta_time&gt; &lt;event&gt; ...                </span>|</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h4 id="Header-Chunk"><a href="#Header-Chunk" class="headerlink" title="Header Chunk"></a>Header Chunk</h4><p>这里是 <code>MIDI Header</code>的组成</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI file header</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Unlike the [MIDITrackHeader](struct.MIDITrackHeader.html), this structure is</span></span><br><span class="line"><span class="comment">/// specified in the official MIDI spec (as "Header Chunk"), though the last three 16-bit</span></span><br><span class="line"><span class="comment">/// fields are simply referred to as "Data".  For a more detailed discussion of the</span></span><br><span class="line"><span class="comment">/// Header Chunk, see section 2.1 of the document here:</span></span><br><span class="line"><span class="comment">/// &lt;https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf&gt;.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MIDIHeader</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> chunk_type: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> length: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> format: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> tracks: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span> division: <span class="built_in">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对着几个参数依次分析</p>
<ul>
<li><strong>format</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI file format</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// MIDI files have three different formats: 0, 1, and 2.  Format 0 means the MIDI file</span></span><br><span class="line"><span class="comment">/// has a single track chunk, whereas formats 1 and 2 indicate one _or more_ track chunks.</span></span><br><span class="line"><span class="comment">/// A longer discussion of these formats can be found in section 2.2 of the document here:</span></span><br><span class="line"><span class="comment">/// &lt;https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf&gt;.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MIDIFormat</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Single track.</span></span><br><span class="line">    Format0,</span><br><span class="line">    <span class="comment">/// One or more simultaneous tracks.</span></span><br><span class="line">    Format1,</span><br><span class="line">    <span class="comment">/// One or more independent tracks.</span></span><br><span class="line">    Format2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>tracks</strong></p>
<p>指在这个 MIDI 文件中有多少个 <code>Track chunks</code></p>
</li>
<li><p><strong>division</strong></p>
<p>指定基本时间格式，根据最高位的不同，这两个字节有不同的含义。</p>
<blockquote>
 <figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string">     bit 15    </span>|<span class="string">    bits 14 thru 8         </span>|<span class="string">        bits 7 thru 0      </span>|</span><br><span class="line">|<span class="string">       0       </span>|<span class="string">              ticks per quarter-note                   </span>|</span><br><span class="line">|<span class="string">       1       </span>|<span class="string">  negative SMPTE format    </span>|<span class="string">        ticks per frame    </span>|</span><br></pre></td></tr></table></figure>
<ul>
<li><p>bit 15 = 0:</p>
<ul>
<li>bits 0-14<br>number of delta-time units in each a quarter-note.</li>
</ul>
</li>
<li><p>bit 15 = 1:</p>
<ul>
<li><p>bits 0-7<br>number of delta-time units per SMTPE frame</p>
</li>
<li><p>bits 8-14<br>form a negative number, representing the number of SMTPE frames per second. Valid values correspond to those in the MTC Quarter Frame message.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">-24</span> = <span class="number">24</span> frames per second</span><br><span class="line"><span class="number">-25</span> = <span class="number">25</span> frames per second</span><br><span class="line"><span class="number">-29</span> = <span class="number">30</span> frames per second, drop frame</span><br><span class="line"><span class="number">-30</span> = <span class="number">30</span> frames per second, non-drop frame</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Track-Chunk"><a href="#Track-Chunk" class="headerlink" title="Track Chunk"></a>Track Chunk</h4><p>对于每一个 <code>Track Chunk</code>也是一样，具有和上面相同的 <code>Track Header</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI track chunk header</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  Encapsulates the chunk type ('MTrk') and the length</span></span><br><span class="line"><span class="comment">///  of a MIDI track chunk.  The official MIDI spec does</span></span><br><span class="line"><span class="comment">///  not refer to these data as the truck chunk header, this</span></span><br><span class="line"><span class="comment">///  library simply makes the distinction for ease of use.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MIDITrackHeader</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> chunk_type: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着 <code>Track Header</code>就是音轨实际的数据，是由一系列的 <code>MTrk event</code>组成，写成公式表达如下（+ means one or more）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Track</span> <span class="attr">Chunk</span>&gt;</span> = <span class="tag">&lt;<span class="name">chunk</span> <span class="attr">type</span>&gt;</span><span class="tag">&lt;<span class="name">length</span>&gt;</span><span class="tag">&lt;<span class="name">MTrk</span> <span class="attr">event</span>&gt;</span>+</span><br></pre></td></tr></table></figure>
<p>而<code>MTrk event</code>的组成很简单，由<code>delta time</code> 和 <code>event</code>组成。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MTrk</span> <span class="attr">event</span>&gt;</span> = <span class="tag">&lt;<span class="name">delta-time</span>&gt;</span><span class="tag">&lt;<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;delta-time&gt;</code> is stored as a variable-length quantity. It represents the amount of time before the following event. If the first event in a track occurs at the very beginning of a track, or if two events occur simultaneously, a delta-time of zero is used. Delta-times are always present. (Not storing delta-times of 0 requires at least two bytes for any other value, and most delta-times aren’t zero.) Delta-time is in some fraction of a beat (or a second, for recording a track with SMPTE times), as specified in the header chunk.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span>&gt;</span> = <span class="tag">&lt;<span class="name">MIDI</span> <span class="attr">event</span>&gt;</span> | <span class="tag">&lt;<span class="name">sysex</span> <span class="attr">event</span>&gt;</span> | <span class="tag">&lt;<span class="name">meta-event</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>event</code>分为三种类型：</p>
<ul>
<li>MIDI event：指 MIDI 通道信息，也是描述 MIDI 音乐的主要部分，参见<a href="###MIDI Message">下小节</a></li>
<li>Sysex event：指系统控制信息，参见<a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_file_format.htm#sysex_event" target="_blank" rel="external nofollow noopener noreferrer">这里</a></li>
<li>Meta event：主要记录一些元信息，包括版权信息、歌词、乐器名等，参见<a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_file_format.htm#meta_event" target="_blank" rel="external nofollow noopener noreferrer">这里</a></li>
</ul>
<h4 id="Put-Things-Together"><a href="#Put-Things-Together" class="headerlink" title="Put Things Together"></a>Put Things Together</h4><p><img alt="MIDI文件格式" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-07_midi-file-format.png"></p>
<h3 id="MIDI-Messages"><a href="#MIDI-Messages" class="headerlink" title="MIDI Messages"></a>MIDI Messages</h3><p><code>MIDI Messages</code>可以分为两大类，专门用于某个特定 MIDI 通道的消息称为<strong>Channel Messages</strong>，而有些消息会影响到整个MIDI 系统（或者至少整个 MIDI 设备），称作 <strong>System Messages</strong>，系统消息不会和某个特定通道有关系。更加详细的可以分为以下几类：</p>
<ul>
<li><strong><a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_channel_voice_messages.htm" target="_blank" rel="external nofollow noopener noreferrer">Channel Voice Messages</a></strong>：开始、改变或者停止声音的消息</li>
<li><strong><a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_channel_mode_messages.htm" target="_blank" rel="external nofollow noopener noreferrer">Channel Mode Messages</a></strong>：影响整个通道的控制消息</li>
<li><a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_system_real.htm" target="_blank" rel="external nofollow noopener noreferrer">System Real-Time Messages</a>：用来同步时序，只有状态字节，没有数据字节</li>
<li><a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_system_common_messages.htm" target="_blank" rel="external nofollow noopener noreferrer">System Common Messages</a>**：系统通用信息，比如 <code>song select</code>等</li>
<li><strong><a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_system_exclusive_messages.htm" target="_blank" rel="external nofollow noopener noreferrer">System Exclusive Messages</a></strong>：设备专用的扩展信息，每个设备厂家可以自己定义</li>
</ul>
<p>不管分类如何，所有的 MIDI 消息组成的结构都一样：</p>
<ul>
<li>A <strong>Status Byte</strong>，一个状态字节<br><code>range: 0x80..FF</code></li>
<li>Zero or more <strong>Data Bytes</strong>，0 或多个数据字节<br><code>range: 0x00..7F</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI channel voice message</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// MIDI supports two main types of messages: Channel and System.</span></span><br><span class="line"><span class="comment">/// Channel messages are tied to a specific MIDI channel, whereas</span></span><br><span class="line"><span class="comment">/// System messages are not (and thus don't contain a channel number).</span></span><br><span class="line"><span class="comment">/// This library only supports channel messages, and more specifically</span></span><br><span class="line"><span class="comment">/// the `NoteOn` and `NoteOff` channel _voice_ messages,</span></span><br><span class="line"><span class="comment">/// which actually produce sounds.  For a detailed explanation of</span></span><br><span class="line"><span class="comment">/// MIDI messages, see appendix 1.1 of the document here:</span></span><br><span class="line"><span class="comment">/// &lt;https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf&gt;.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MIDIChannelVoiceMessage</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> delta_time: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span> status: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span> note: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span> velocity: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是典型的 <code>Channel Voice Message</code>的例子，更多内容可以参考<a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_channel_voice_messages.htm#note1" target="_blank" rel="external nofollow noopener noreferrer">这里</a>。</p>
<p><img alt="MIDI Channel Voice Messages" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-07_midi-channel-voice-messages.png"></p>
<p>根据代码，我们可以一一对应起来，比如这里的 <code>NoteOn</code>就是 <code>0b1001</code>(0b 是二进制表示)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI message status</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Each MIDI event (message) has a status, which sets the message type and thus the meaning</span></span><br><span class="line"><span class="comment">/// of the associated message data.  Technically the status bits also include the channel number,</span></span><br><span class="line"><span class="comment">/// but this library currently only supports single track, single channel MIDI files (and thus</span></span><br><span class="line"><span class="comment">/// defaults to channel 0).  For a detailed description of each status type, see Appendix 1.1 of the document here:</span></span><br><span class="line"><span class="comment">/// &lt;https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf&gt;.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MIDIStatus</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Assume status bytes of previous MIDI channel message</span></span><br><span class="line">    RunningStatus = <span class="number">0b0000</span>,</span><br><span class="line">    <span class="comment">/// Note released</span></span><br><span class="line">    NoteOff = <span class="number">0b1000</span>,</span><br><span class="line">    <span class="comment">/// Note pressed</span></span><br><span class="line">    NoteOn = <span class="number">0b1001</span>,</span><br><span class="line">    <span class="comment">/// Pressure on key after pressed down</span></span><br><span class="line">    PolyphonicAftertouch = <span class="number">0b1010</span>,</span><br><span class="line">    <span class="comment">/// Controller value change</span></span><br><span class="line">    ControlChange = <span class="number">0b1011</span>,</span><br><span class="line">    <span class="comment">/// Change program (patch) number</span></span><br><span class="line">    ProgramChange = <span class="number">0b1100</span>,</span><br><span class="line">    <span class="comment">/// Greatest pressure on key after pressed down</span></span><br><span class="line">    Aftertouch = <span class="number">0b1101</span>,</span><br><span class="line">    <span class="comment">/// Chainge pitch wheel</span></span><br><span class="line">    PitchWheelChange = <span class="number">0b1110</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>MIDI Note</strong></li>
</ul>
<p>在上图中我们可以看到，MIDI 消息的数据中有一个 <code>kk</code>字段，说的是按下的 Key，也就是我们通常说的<code>音符 Note</code>。这里是按照每个<code>八度 Octave</code>一组进行排列，其中 <code>Middle C</code>，也就是 C4 的序号是 60（十进制）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Octave #</strong></th>
<th>C</th>
<th>C#</th>
<th>D</th>
<th>D#</th>
<th>E</th>
<th>F</th>
<th>F#</th>
<th>G</th>
<th>G#</th>
<th>A</th>
<th>A#</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td>0</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
</tr>
<tr>
<td>1</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>32</td>
<td>33</td>
<td>34</td>
<td>35</td>
</tr>
<tr>
<td>2</td>
<td>36</td>
<td>37</td>
<td>38</td>
<td>39</td>
<td>40</td>
<td>41</td>
<td>42</td>
<td>43</td>
<td>44</td>
<td>45</td>
<td>46</td>
<td>47</td>
</tr>
<tr>
<td>3</td>
<td>48</td>
<td>49</td>
<td>50</td>
<td>51</td>
<td>52</td>
<td>53</td>
<td>54</td>
<td>55</td>
<td>56</td>
<td>57</td>
<td>58</td>
<td>59</td>
</tr>
<tr>
<td>4</td>
<td><strong>60</strong></td>
<td>61</td>
<td>62</td>
<td>63</td>
<td>64</td>
<td>65</td>
<td>66</td>
<td>67</td>
<td>68</td>
<td>69</td>
<td>70</td>
<td>71</td>
</tr>
<tr>
<td>5</td>
<td>72</td>
<td>73</td>
<td>74</td>
<td>75</td>
<td>76</td>
<td>77</td>
<td>78</td>
<td>79</td>
<td>80</td>
<td>81</td>
<td>82</td>
<td>83</td>
</tr>
<tr>
<td>6</td>
<td>84</td>
<td>85</td>
<td>86</td>
<td>87</td>
<td>88</td>
<td>89</td>
<td>90</td>
<td>91</td>
<td>92</td>
<td>93</td>
<td>94</td>
<td>95</td>
</tr>
<tr>
<td>7</td>
<td>96</td>
<td>97</td>
<td>98</td>
<td>99</td>
<td>100</td>
<td>101</td>
<td>102</td>
<td>103</td>
<td>104</td>
<td>105</td>
<td>106</td>
<td>107</td>
</tr>
<tr>
<td>8</td>
<td>108</td>
<td>109</td>
<td>110</td>
<td>111</td>
<td>112</td>
<td>113</td>
<td>114</td>
<td>115</td>
<td>116</td>
<td>117</td>
<td>118</td>
<td>119</td>
</tr>
<tr>
<td>9</td>
<td>120</td>
<td>121</td>
<td>122</td>
<td>123</td>
<td>124</td>
<td>125</td>
<td>126</td>
<td>127</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>对应在代码中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI note</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Represents key on a piano, combining a [note type](enum.MIDINoteType.html)</span></span><br><span class="line"><span class="comment">/// with an octave.  For example, middle C would be represented as</span></span><br><span class="line"><span class="comment">/// `MIDINote &#123; note_type: MIDINoteType::C, octave: 4 &#125;`.  For a detailed table</span></span><br><span class="line"><span class="comment">/// of MIDI notes and octave numbers, see document here:</span></span><br><span class="line"><span class="comment">/// &lt;https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf&gt;.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MIDINote</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> note_type: MIDINoteType,</span><br><span class="line">    <span class="keyword">pub</span> octave: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Program Change</strong></li>
</ul>
<p>在上面的 status 中有一个 <code>Program Change</code>，说的是改变乐器。</p>
<p><img alt="Program Change" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-07_midi-program-change.png"></p>
<p>在 MIDI 中，对于不同的乐器也有相应的数字定义，这里简单列出了几个 Family 的序列范围。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">PC#</th>
<th style="text-align:center">Family</th>
<th style="text-align:center">PC#</th>
<th style="text-align:center">Family</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1-8</td>
<td style="text-align:center">Piano</td>
<td style="text-align:center">65-72</td>
<td style="text-align:center">Reed</td>
</tr>
<tr>
<td style="text-align:center">9-16</td>
<td style="text-align:center">Chromatic Percussion</td>
<td style="text-align:center">73-80</td>
<td style="text-align:center">Pipe</td>
</tr>
<tr>
<td style="text-align:center">17-24</td>
<td style="text-align:center">Organ</td>
<td style="text-align:center">81-88</td>
<td style="text-align:center">Synth Lead</td>
</tr>
<tr>
<td style="text-align:center">25-32</td>
<td style="text-align:center">Guitar</td>
<td style="text-align:center">89-96</td>
<td style="text-align:center">Synth Pad</td>
</tr>
<tr>
<td style="text-align:center">33-40</td>
<td style="text-align:center">Bass</td>
<td style="text-align:center">97-104</td>
<td style="text-align:center">Synth Effects</td>
</tr>
<tr>
<td style="text-align:center">41-48</td>
<td style="text-align:center">Strings</td>
<td style="text-align:center">105-112</td>
<td style="text-align:center">Ethnic</td>
</tr>
<tr>
<td style="text-align:center">49-56</td>
<td style="text-align:center">Ensemble</td>
<td style="text-align:center">113-120</td>
<td style="text-align:center">Percussive</td>
</tr>
<tr>
<td style="text-align:center">57-64</td>
<td style="text-align:center">Brass</td>
<td style="text-align:center">121-128</td>
<td style="text-align:center">Sound Effects</td>
</tr>
</tbody>
</table>
</div>
<h3 id="MIDI-File"><a href="#MIDI-File" class="headerlink" title="MIDI File"></a>MIDI File</h3><p>这里我们定义了 <code>MIDIFile</code>类：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MIDI file representation</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// MIDI files can be complex, allowing for any number of tracks with</span></span><br><span class="line"><span class="comment">/// different notes and instruments playing simultaneously.  This library</span></span><br><span class="line"><span class="comment">/// was created for the express purpose of brute-forcing melodies, and thus</span></span><br><span class="line"><span class="comment">/// only supports a subset of the official MIDI standard.  More specifically,</span></span><br><span class="line"><span class="comment">/// this class is optimized for creating the smallest possible single track MIDI</span></span><br><span class="line"><span class="comment">/// files.</span></span><br><span class="line"><span class="meta">#[derive(Clone, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MIDIFile</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Sequence of notes ([MIDINoteSequence](struct.MIDINoteSequence.html)) from which the track chunk is generated</span></span><br><span class="line">    <span class="keyword">pub</span> sequence: MIDINoteSequence,</span><br><span class="line">    <span class="comment">/// Format specification (should always be [MIDIFormat::0](enum.MIDIFormat.html#variant.Format0))</span></span><br><span class="line">    <span class="keyword">pub</span> format: MIDIFormat,</span><br><span class="line">    <span class="comment">/// Number of tracks in MIDI file (should always be `1`)</span></span><br><span class="line">    <span class="keyword">pub</span> tracks: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="comment">/// Number of ticks to represent a quarter-note (recommended to use `1`)</span></span><br><span class="line">    <span class="keyword">pub</span> division: <span class="built_in">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过输入音符序列，我们即可生成对应的 MIDI 文件。比如这里输入序列为<code>C:4,D:5,CSharp:8,DSharp:3</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mfile = libatm::MIDIFile::new(</span><br><span class="line">    libatm::MIDINoteSequence::new(<span class="built_in">vec!</span>[</span><br><span class="line">        libatm::MIDINote::new(libatm::MIDINoteType::C, <span class="number">4</span>),</span><br><span class="line">        libatm::MIDINote::new(libatm::MIDINoteType::D, <span class="number">5</span>),</span><br><span class="line">        libatm::MIDINote::new(libatm::MIDINoteType::CSharp, <span class="number">8</span>),</span><br><span class="line">        libatm::MIDINote::new(libatm::MIDINoteType::DSharp, <span class="number">3</span>),</span><br><span class="line">    ]),</span><br><span class="line">    libatm::MIDIFormat::Format0,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">"607410951"</span>, mfile.gen_hash());</span><br></pre></td></tr></table></figure>
<h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>到现在为止，我们对 MIDI 文件已经有了很深的理解，可能关于时序方面还不是很了解，但是我们知道这些参数足以完整的描述一个旋律，接下来我们看如何遍历所有的旋律。</p>
<p>暴力枚举，那么我们需要知道总共有多少种可能，怎么判断呢？下面的公式</p>
<script type="math/tex; mode=display">Total\ Possiblity = {number\ of\ pitch\ classes }^{number\ of\ note\ in\ time}</script><p>对于一个钢琴而言，总共有 88 种音高，对于一个有 12 个音符的旋律来说，总共有 $88^{12}$ 种可能。这意味着什么？即使是每个旋律只占 1 个字节的话，这将会占据 186 ZB，是不可能将所有旋律都存储在一个硬盘上的。</p>
<p>那么，我们来看看<code>Damien Riehl</code>是如何做到的：</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/sJtm0MoOgiU" frameborder="0" allowfullscreen></iframe></div>
<blockquote>
<p>Now you might say <strong>what consititutes a melody</strong> ?</p>
<p> We were initially going to take the entire piano keyboard and to do the all at the entire piano keyboard. But let’s focus on the <strong>vocal range</strong> which is actually 2 octaves and we thought actually we’re thinking about <strong>pop music</strong>, which is the only thing that makes money that people sue over,  doesn’t go to octaves. It goes a <strong>single octave</strong> so that’s what we landed on <strong>eight notes</strong>. </p>
<p>Now you might say <strong>how may notes consititutes a melody</strong> ?</p>
<p>So we looked at musicologists…and we landed at <strong>twelve notes</strong>.</p>
</blockquote>
<p><code>Damien Riehl</code>做了一个很巧妙的范围缩小，通过将研究目标锁定到人可歌唱的流行音乐，我们得出结论</p>
<ul>
<li>一个旋律的每个音符通常只有 8 种选择，比如 C 大调，<code>do re mi fa so la ti do</code></li>
<li>只需要 12 个音符即可组成几乎所有的旋律。</li>
<li>那么在这种情况下，有 $8^{12} = 68.7 million$ 种可能。</li>
</ul>
<p>基于这个认知，我们就可以暴力枚举了。</p>
<p>下面这段代码很简单，就是遍历所有的 <code>Sequence</code>，对于每一个 <code>Sequence</code>生成 MIDI 文件，同时写到压缩包中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">atm_batch</span></span>(args: BatchDirectiveArgs) &#123;</span><br><span class="line">    <span class="comment">// Initialize progress bar and set refresh rate</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> pb = pbr::ProgressBar::new(args.max_count <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">    pb.set_max_refresh_rate(<span class="literal">Some</span>(std::time::Duration::from_millis(args.update)));</span><br><span class="line">    <span class="comment">// Initialize output archive</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> archive = crate::utils::BatchedMIDIArchive::new(</span><br><span class="line">        &amp;args.target,</span><br><span class="line">        args.partition_depth,</span><br><span class="line">        args.max_files,</span><br><span class="line">        args.partition_size,</span><br><span class="line">        args.batch_size,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// For each generated sequence</span></span><br><span class="line">    <span class="keyword">for</span> (idx, notes) <span class="keyword">in</span> crate::utils::gen_sequences(&amp;args.sequence.notes, args.length).enumerate() &#123;</span><br><span class="line">        <span class="comment">// if reached max count, finish</span></span><br><span class="line">        <span class="keyword">if</span> idx == args.max_count &#123;</span><br><span class="line">            archive.finish().unwrap();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clone libatm::MIDINoteSequence from Vec&lt;&amp;libatm::MIDINote&gt;</span></span><br><span class="line">        <span class="keyword">let</span> seq = libatm::MIDINoteSequence::new(</span><br><span class="line">            notes</span><br><span class="line">                .iter()</span><br><span class="line">                .map(|note| *note.clone())</span><br><span class="line">                .collect::&lt;<span class="built_in">Vec</span>&lt;libatm::MIDINote&gt;&gt;(),</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// Create MIDIFile from libatm::MIDINoteSequence</span></span><br><span class="line">        <span class="keyword">let</span> mfile = libatm::MIDIFile::new(seq, libatm::MIDIFormat::Format0, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Add MIDIFile to archive</span></span><br><span class="line">        archive.push(mfile).unwrap();</span><br><span class="line">        <span class="comment">// Increment progress bar</span></span><br><span class="line">        pb.inc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Stop progress bar</span></span><br><span class="line">    pb.finish_println(<span class="string">""</span>);</span><br><span class="line">    <span class="comment">// Finish archive if not already finished</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> crate::utils::BatchedMIDIArchiveState::Open = archive.state &#123;</span><br><span class="line">        archive.finish().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，这里的 <code>gen_sequence</code>是关键。下面这段代码说明了它的原理：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Generate all permutations (with replacement) of given length</span></span><br><span class="line"><span class="comment">/// from the given sequence of MIDI notes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Arguments:</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// * `notes`: sequence of MIDI notes (see: [libatm::MIDINote](../../libatm/struct.MIDINote.html))</span></span><br><span class="line"><span class="comment">/// * `length`: length of sequences to generate</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// // Create MIDI note sequence</span></span><br><span class="line"><span class="comment">/// let sequence = "C:4,C:4,D:4,E:4,F:4,G:5".parse::&lt;libatm::MIDINoteSequence&gt;().unwrap();</span></span><br><span class="line"><span class="comment">/// // Create iterable over all permutations, which in this example would be</span></span><br><span class="line"><span class="comment">/// // 6^8 = 1,679,616 instances of `Vec&lt;&amp;libatm::MIDINote&gt;`.</span></span><br><span class="line"><span class="comment">/// let permutations = atm::utils::gen_sequences(&amp;sequence.notes, 8);</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">gen_sequences</span></span>(</span><br><span class="line">    notes: &amp;[libatm::MIDINote],</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">) -&gt; itertools::MultiProduct&lt;std::slice::Iter&lt;libatm::MIDINote&gt;&gt; &#123;</span><br><span class="line">    (<span class="number">0</span>..(length))</span><br><span class="line">        .map(|_| notes.iter())</span><br><span class="line">        .multi_cartesian_product()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输入是一段 <code>C:4,C:4,D:4,E:4,F:4,G:5</code>序列，这里一共有 6 个 Note，说的是我们遍历的时候所有可以的选择</li>
<li>然后我们会传递一个 <code>length</code> 参数，比如这里传递的参数是 8</li>
<li>输出是一个有 8 个音符的旋律，每个音符可以有 6 种选择，这 6 种来自 <code>C:4,C:4,D:4,E:4,F:4,G:5</code>序列</li>
<li>那么，我们可以产生 $6^8$ 种遍历可能</li>
</ul>
<p>至此，我们已经搞懂了<code>Damien Riehl</code>到底做了什么。其实做法很简单，就是用 Rust 写了一个 MIDI 库，然后遍历了所有流行歌曲可能产生的旋律。但是这么简单的过程却给我们揭示了一个道理，旋律创作在这里只是一个<strong>数学问题</strong>。</p>
<blockquote>
<p>Maybe melodies are just math which is just facts, which maybe are not copyrightable. If somebody is suing over a melody alone, not lyrics, not recordings, but just melody alone, maybe those cases go away.</p>
</blockquote>
<p>到现在，我们还只是粗暴的遍历进行旋律创作，没有涉及到编曲等其他进一步的创作。这几年随着深度学习的进一步发展，已经有很多人开始把眼光投到了音乐生成这个领域。比如这篇论文 <a href="https://mp.weixin.qq.com/s/VkDlfbuKWd6WiLZVzxJTEg" target="_blank" rel="external nofollow noopener noreferrer">KDD 2018 Research Track 最佳学生论文详解：流行音乐的旋律与编曲生成</a> 就把深度学习技术运用到了音乐生成这个领域。这个话题先停留在这里，或许以后会再回来填这个坑吧 ：）</p>
<h2 id="Post-Script"><a href="#Post-Script" class="headerlink" title="Post Script"></a>Post Script</h2><p>两周前看到 <code>Damien Riehl</code>那个视频的时候，就对这个话题非常感兴趣。且先不说版权这个话题(这是另外一个要填的坑)，就只是用计算机编曲这个事情就足以让我兴奋了。如果再加上人工智能编曲，那又是另外一个深坑了。大一的时候在学校听过一个讲座，一个帅气美国小哥讲了他用人工智能创作音乐的故事（好久远啊，好像是那次信科学院本科生科研成果展示会？可是当时自己对这些完全没有概念）。</p>
<p>过去的两个星期我尝试去学习编曲，对着B站上一个台湾小哥的 <a href="https://www.bilibili.com/video/av23248675" target="_blank" rel="external nofollow noopener noreferrer">GarageBand 教程</a> 玩起了 GarageBand。在这个过程中，我越来越发现这是一个超级深的坑 ：）</p>
<p><img alt="编曲技能树" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-07_composer-tech-tree.jpg"></p>
<p>这是我在知乎上看到的一张图，还能怎么办呢 ：）</p>
<p>慢慢来吧，作曲编曲，也许有一天，我能够自己创作出自己的歌曲呢 👀</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.personal.kent.edu/~sbirch/Music_Production/MP-II/MIDI/midi_file_format.htm" target="_blank" rel="external nofollow noopener noreferrer">The MIDI File Format</a></li>
<li><a href="https://www.jianshu.com/p/31d02765e1ec" target="_blank" rel="external nofollow noopener noreferrer">如何看懂一份 MIDI 文件</a></li>
</ul>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>音乐</tag>
        <tag>法律</tag>
        <tag>斜杠青年</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 插入 ECharts 动态图表</title>
    <url>/posts/d823886b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://echarts.baidu.com/index.html" target="_blank" rel="external nofollow noopener noreferrer">ECharts</a>，是百度开源的一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图。</p>
<p>本文介绍了在 Hexo 博客中插入 ECharts 动态图表的方法，并展示了 ECharts 图表的常用情景。</p>
<a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>Hexo 需要安装插件来渲染 ECharts 代码，这里使用的是 <a href="https://github.com/Cloving/hexo-tag-echarts-chart" target="_blank" rel="external nofollow noopener noreferrer">hexo-tag-echarts-chart</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-tag-echarts-chart --save</span></span><br></pre></td></tr></table></figure>
<p>之后在文章内使用 ECharts 的 <code>tag</code> 就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% echarts <span class="number">400</span> <span class="string">'85%'</span> %&#125;</span><br><span class="line">\\TODO echarts codes goes here</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>echarts</code> 是标签名，不需要更改，<code>400</code> 是图表容器的高度，<code>85%</code> 是图表容器的相对宽度。而在 <code>tag</code> 之间的部分，则是需要自己填充的图表数据了。</p>
<p>关于 ECharts 的语法，可以参考<a href="https://www.echartsjs.com/zh/tutorial.html" target="_blank" rel="external nofollow noopener noreferrer">教程</a></p>
<h2 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h2><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% echarts <span class="number">600</span> <span class="string">'100%'</span> %&#125;</span><br><span class="line">option = &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: <span class="string">'堆叠区域图'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span>,</span><br><span class="line">        axisPointer: &#123;</span><br><span class="line">            type: <span class="string">'cross'</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                backgroundColor: <span class="string">'#6a7985'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data: [<span class="string">'邮件营销'</span>, <span class="string">'联盟广告'</span>, <span class="string">'视频广告'</span>, <span class="string">'直接访问'</span>, <span class="string">'搜索引擎'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        feature: &#123;</span><br><span class="line">            dataView: &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">readOnly</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            magicType: &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">type</span>: [<span class="string">'line'</span>, <span class="string">'bar'</span>]&#125;,</span><br><span class="line">            restore: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            saveAsImage: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: <span class="string">'3%'</span>,</span><br><span class="line">        right: <span class="string">'4%'</span>,</span><br><span class="line">        bottom: <span class="string">'3%'</span>,</span><br><span class="line">        containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">'category'</span>,</span><br><span class="line">            boundaryGap: <span class="literal">false</span>,</span><br><span class="line">            data: [<span class="string">'周一'</span>, <span class="string">'周二'</span>, <span class="string">'周三'</span>, <span class="string">'周四'</span>, <span class="string">'周五'</span>, <span class="string">'周六'</span>, <span class="string">'周日'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">'value'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'邮件营销'</span>,</span><br><span class="line">            type: <span class="string">'line'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            areaStyle: &#123;&#125;,</span><br><span class="line">            data: [<span class="number">120</span>, <span class="number">132</span>, <span class="number">101</span>, <span class="number">134</span>, <span class="number">90</span>, <span class="number">230</span>, <span class="number">210</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'联盟广告'</span>,</span><br><span class="line">            type: <span class="string">'line'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            areaStyle: &#123;&#125;,</span><br><span class="line">            data: [<span class="number">220</span>, <span class="number">182</span>, <span class="number">191</span>, <span class="number">234</span>, <span class="number">290</span>, <span class="number">330</span>, <span class="number">310</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'视频广告'</span>,</span><br><span class="line">            type: <span class="string">'line'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            areaStyle: &#123;&#125;,</span><br><span class="line">            data: [<span class="number">150</span>, <span class="number">232</span>, <span class="number">201</span>, <span class="number">154</span>, <span class="number">190</span>, <span class="number">330</span>, <span class="number">410</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'直接访问'</span>,</span><br><span class="line">            type: <span class="string">'line'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            areaStyle: &#123;&#125;,</span><br><span class="line">            data: [<span class="number">320</span>, <span class="number">332</span>, <span class="number">301</span>, <span class="number">334</span>, <span class="number">390</span>, <span class="number">330</span>, <span class="number">320</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'搜索引擎'</span>,</span><br><span class="line">            type: <span class="string">'line'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'top'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            areaStyle: &#123;&#125;,</span><br><span class="line">            data: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts4524" style="width: 100%;height: 600px;margin: 0 auto"></div>
<script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script>
<script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script>
<script type="text/javascript">
  // 基于准备好的dom，初始化echarts实例
  var myChart = echarts.init(document.getElementById('echarts4524'));
  // 指定图表的配置项和数据
  option = {
    title: {
        text: '堆叠区域图'
    },
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross',
            label: {
                backgroundColor: '#6a7985'
            }
        }
    },
    legend: {
        data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎']
    },
    toolbox: {
        feature: {
            saveAsImage: {}
        }
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis: [
        {
            type: 'category',
            boundaryGap: false,
            data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日']
        }
    ],
    yAxis: [
        {
            type: 'value'
        }
    ],
    series: [
        {
            name: '邮件营销',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [120, 132, 101, 134, 90, 230, 210]
        },
        {
            name: '联盟广告',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [220, 182, 191, 234, 290, 330, 310]
        },
        {
            name: '视频广告',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [150, 232, 201, 154, 190, 330, 410]
        },
        {
            name: '直接访问',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [320, 332, 301, 334, 390, 330, 320]
        },
        {
            name: '搜索引擎',
            type: 'line',
            stack: '总量',
            label: {
                normal: {
                    show: true,
                    position: 'top'
                }
            },
            areaStyle: {},
            data: [820, 932, 901, 934, 1290, 1330, 1320]
        }
    ]
};
  // 使用刚指定的配置项和数据显示图表。
  myChart.setOption(option);
</script>

<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% echarts <span class="number">600</span> <span class="string">'100%'</span> %&#125;</span><br><span class="line">option = &#123;</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span>,</span><br><span class="line">        axisPointer: &#123;</span><br><span class="line">            type: <span class="string">'cross'</span>,</span><br><span class="line">            crossStyle: &#123;</span><br><span class="line">                color: <span class="string">'#999'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        feature: &#123;</span><br><span class="line">            dataView: &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">readOnly</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">            magicType: &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">type</span>: [<span class="string">'line'</span>, <span class="string">'bar'</span>]&#125;,</span><br><span class="line">            restore: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            saveAsImage: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data: [<span class="string">'蒸发量'</span>, <span class="string">'降水量'</span>, <span class="string">'平均温度'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">'category'</span>,</span><br><span class="line">            data: [<span class="string">'1月'</span>, <span class="string">'2月'</span>, <span class="string">'3月'</span>, <span class="string">'4月'</span>, <span class="string">'5月'</span>, <span class="string">'6月'</span>, <span class="string">'7月'</span>, <span class="string">'8月'</span>, <span class="string">'9月'</span>, <span class="string">'10月'</span>, <span class="string">'11月'</span>, <span class="string">'12月'</span>],</span><br><span class="line">            axisPointer: &#123;</span><br><span class="line">                type: <span class="string">'shadow'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">'value'</span>,</span><br><span class="line">            name: <span class="string">'水量'</span>,</span><br><span class="line">            min: <span class="number">0</span>,</span><br><span class="line">            max: <span class="number">250</span>,</span><br><span class="line">            interval: <span class="number">50</span>,</span><br><span class="line">            axisLabel: &#123;</span><br><span class="line">                formatter: <span class="string">'&#123;value&#125; ml'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">'value'</span>,</span><br><span class="line">            name: <span class="string">'温度'</span>,</span><br><span class="line">            min: <span class="number">0</span>,</span><br><span class="line">            max: <span class="number">25</span>,</span><br><span class="line">            interval: <span class="number">5</span>,</span><br><span class="line">            axisLabel: &#123;</span><br><span class="line">                formatter: <span class="string">'&#123;value&#125; °C'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'蒸发量'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            data: [<span class="number">2.0</span>, <span class="number">4.9</span>, <span class="number">7.0</span>, <span class="number">23.2</span>, <span class="number">25.6</span>, <span class="number">76.7</span>, <span class="number">135.6</span>, <span class="number">162.2</span>, <span class="number">32.6</span>, <span class="number">20.0</span>, <span class="number">6.4</span>, <span class="number">3.3</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'降水量'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            data: [<span class="number">2.6</span>, <span class="number">5.9</span>, <span class="number">9.0</span>, <span class="number">26.4</span>, <span class="number">28.7</span>, <span class="number">70.7</span>, <span class="number">175.6</span>, <span class="number">182.2</span>, <span class="number">48.7</span>, <span class="number">18.8</span>, <span class="number">6.0</span>, <span class="number">2.3</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'平均温度'</span>,</span><br><span class="line">            type: <span class="string">'line'</span>,</span><br><span class="line">            yAxisIndex: <span class="number">1</span>,</span><br><span class="line">            data: [<span class="number">2.0</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.5</span>, <span class="number">6.3</span>, <span class="number">10.2</span>, <span class="number">20.3</span>, <span class="number">23.4</span>, <span class="number">23.0</span>, <span class="number">16.5</span>, <span class="number">12.0</span>, <span class="number">6.2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts5287" style="width: 100%;height: 600px;margin: 0 auto"></div>
<script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script>
<script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script>
<script type="text/javascript">
  // 基于准备好的dom，初始化echarts实例
  var myChart = echarts.init(document.getElementById('echarts5287'));
  // 指定图表的配置项和数据
  option = {
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross',
            crossStyle: {
                color: '#999'
            }
        }
    },
    toolbox: {
        feature: {
            dataView: {show: true, readOnly: false},
            magicType: {show: true, type: ['line', 'bar']},
            restore: {show: true},
            saveAsImage: {show: true}
        }
    },
    legend: {
        data: ['蒸发量', '降水量', '平均温度']
    },
    xAxis: [
        {
            type: 'category',
            data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
            axisPointer: {
                type: 'shadow'
            }
        }
    ],
    yAxis: [
        {
            type: 'value',
            name: '水量',
            min: 0,
            max: 250,
            interval: 50,
            axisLabel: {
                formatter: '{value} ml'
            }
        },
        {
            type: 'value',
            name: '温度',
            min: 0,
            max: 25,
            interval: 5,
            axisLabel: {
                formatter: '{value} °C'
            }
        }
    ],
    series: [
        {
            name: '蒸发量',
            type: 'bar',
            data: [2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3]
        },
        {
            name: '降水量',
            type: 'bar',
            data: [2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3]
        },
        {
            name: '平均温度',
            type: 'line',
            yAxisIndex: 1,
            data: [2.0, 2.2, 3.3, 4.5, 6.3, 10.2, 20.3, 23.4, 23.0, 16.5, 12.0, 6.2]
        }
    ]
};
  // 使用刚指定的配置项和数据显示图表。
  myChart.setOption(option);
</script>

<h3 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% echarts <span class="number">600</span> <span class="string">'85%'</span> %&#125;</span><br><span class="line">option = &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: <span class="string">"某站点用户访问来源"</span>,</span><br><span class="line">        subtext: <span class="string">"纯属虚构"</span>,</span><br><span class="line">        x: <span class="string">"center"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: <span class="string">"item"</span>,</span><br><span class="line">        formatter: <span class="string">"&#123;a&#125; &#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        orient: <span class="string">"vertical"</span>,</span><br><span class="line">        x: <span class="string">"left"</span>,</span><br><span class="line">        data: [<span class="string">"直接访问"</span>, <span class="string">"邮件营销"</span>, <span class="string">"联盟广告"</span>, <span class="string">"视频广告"</span>, <span class="string">"搜索引擎"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        show: <span class="literal">true</span>,</span><br><span class="line">        feature: &#123;</span><br><span class="line">            mark: &#123;</span><br><span class="line">                show: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            dataView: &#123;</span><br><span class="line">                show: <span class="literal">true</span>,</span><br><span class="line">                readOnly: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            restore: &#123;</span><br><span class="line">                show: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            saveAsImage: &#123;</span><br><span class="line">                show: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    calculable: <span class="literal">true</span>,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">"访问来源"</span>,</span><br><span class="line">            type: <span class="string">"pie"</span>,</span><br><span class="line">            radius: <span class="string">"55%"</span>,</span><br><span class="line">            center: [<span class="string">"50%"</span>, <span class="string">"60%"</span>],</span><br><span class="line">            data: [</span><br><span class="line">                &#123;</span><br><span class="line">                    value: <span class="number">335</span>,</span><br><span class="line">                    name: <span class="string">"直接访问"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: <span class="number">310</span>,</span><br><span class="line">                    name: <span class="string">"邮件营销"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: <span class="number">234</span>,</span><br><span class="line">                    name: <span class="string">"联盟广告"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: <span class="number">135</span>,</span><br><span class="line">                    name: <span class="string">"视频广告"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    value: <span class="number">1548</span>,</span><br><span class="line">                    name: <span class="string">"搜索引擎"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts5041" style="width: 85%;height: 600px;margin: 0 auto"></div>
<script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script>
<script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script>
<script type="text/javascript">
  // 基于准备好的dom，初始化echarts实例
  var myChart = echarts.init(document.getElementById('echarts5041'));
  // 指定图表的配置项和数据
  option = {
    title: {
        text: "某站点用户访问来源",
        subtext: "纯属虚构",
        x: "center"
    },
    tooltip: {
        trigger: "item",
        formatter: "{a} {b} : {c} ({d}%)"
    },
    legend: {
        orient: "vertical",
        x: "left",
        data: ["直接访问", "邮件营销", "联盟广告", "视频广告", "搜索引擎"]
    },
    toolbox: {
        show: true,
        feature: {
            mark: {
                show: true
            },
            dataView: {
                show: true,
                readOnly: true
            },
            restore: {
                show: true
            },
            saveAsImage: {
                show: true
            }
        }
    },
    calculable: true,
    series: [
        {
            name: "访问来源",
            type: "pie",
            radius: "55%",
            center: ["50%", "60%"],
            data: [
                {
                    value: 335,
                    name: "直接访问"
                },
                {
                    value: 310,
                    name: "邮件营销"
                },
                {
                    value: 234,
                    name: "联盟广告"
                },
                {
                    value: 135,
                    name: "视频广告"
                },
                {
                    value: 1548,
                    name: "搜索引擎"
                }
            ]
        }
    ]
};
  // 使用刚指定的配置项和数据显示图表。
  myChart.setOption(option);
</script>

<h3 id="地理图"><a href="#地理图" class="headerlink" title="地理图"></a>地理图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: <span class="string">"疫情地图: 2020-03-09"</span>,</span><br><span class="line">        subtext: <span class="string">"作者：@Houmin"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        triggerOn: <span class="string">"click"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        feature: &#123;</span><br><span class="line">            dataView: &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">readOnly</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            restore: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            saveAsImage: &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    visualMap: &#123;</span><br><span class="line">        min: <span class="number">0</span>,</span><br><span class="line">        max: <span class="number">100000</span>,</span><br><span class="line">        left: <span class="number">26</span>,</span><br><span class="line">        bottom: <span class="number">40</span>,</span><br><span class="line">        showLabel: !<span class="number">0</span>,</span><br><span class="line">        text: [<span class="string">"高"</span>, <span class="string">"低"</span>],</span><br><span class="line">        pieces: [&#123;</span><br><span class="line">            gt: <span class="number">10000</span>,</span><br><span class="line">            label: <span class="string">"&gt; 10000"</span>,</span><br><span class="line">            color: <span class="string">"#7f1100"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            gte: <span class="number">1000</span>,</span><br><span class="line">            lte: <span class="number">10000</span>,</span><br><span class="line">            label: <span class="string">"1000 - 9999"</span>,</span><br><span class="line">            color: <span class="string">"#cf1e06"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            gte: <span class="number">100</span>,</span><br><span class="line">            lt: <span class="number">1000</span>,</span><br><span class="line">            label: <span class="string">"100 - 999"</span>,</span><br><span class="line">            color: <span class="string">"#ff5428"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            gte: <span class="number">10</span>,</span><br><span class="line">            lt: <span class="number">100</span>,</span><br><span class="line">            label: <span class="string">"10 - 99"</span>,</span><br><span class="line">            color: <span class="string">"#ff8c71"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            gte: <span class="number">1</span>,</span><br><span class="line">            lt: <span class="number">10</span>,</span><br><span class="line">            label: <span class="string">"1 - 9"</span>,</span><br><span class="line">            color: <span class="string">"#ffd768"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            color: <span class="string">"#ffffff"</span></span><br><span class="line">        &#125;],</span><br><span class="line">        show: !<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    geo: &#123;</span><br><span class="line">        map: <span class="string">"china"</span>,</span><br><span class="line">        roam: !<span class="number">1</span>,</span><br><span class="line">        scaleLimit: &#123;</span><br><span class="line">            min: <span class="number">1</span>,</span><br><span class="line">            max: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        zoom: <span class="number">1.23</span>,</span><br><span class="line">        top: <span class="number">120</span>,</span><br><span class="line">        label: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">                show: !<span class="number">0</span>,</span><br><span class="line">                fontSize: <span class="string">"14"</span>,</span><br><span class="line">                color: <span class="string">"rgba(0,0,0,0.7)"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">                borderColor: <span class="string">"rgba(0, 0, 0, 0.2)"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            emphasis: &#123;</span><br><span class="line">                areaColor: <span class="string">"#f2d5ad"</span>,</span><br><span class="line">                shadowOffsetX: <span class="number">0</span>,</span><br><span class="line">                shadowOffsetY: <span class="number">0</span>,</span><br><span class="line">                borderWidth: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name: <span class="string">"确诊病例"</span>,</span><br><span class="line">        type: <span class="string">"map"</span>,</span><br><span class="line">        geoIndex: <span class="number">0</span>,</span><br><span class="line">        data: dataList # 这里的 dataList 是描述现存确诊病例的 JSON 数据</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">&#123;% endecharts %&#125;</span><br></pre></td></tr></table></figure>
<div id="echarts6886" style="width: 85%;height: 700px;margin: 0 auto"></div>
<script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script>
<script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script>
<script type="text/javascript">
  // 基于准备好的dom，初始化echarts实例
  var myChart = echarts.init(document.getElementById('echarts6886'));
  // 指定图表的配置项和数据
  dataList = [{
        name: "南海诸岛",
        value: 0
    },
    {
        name: '北京',
        value: 105
    },
    {
        name: '天津',
        value: 3
    },
    {
        name: '上海',
        value: 24
    },
    {
        name: '重庆',
        value: 42
    },
    {
        name: '河北',
        value: 5
    },
    {
        name: '河南',
        value: 3
    },
    {
        name: '云南',
        value: 2
    },
    {
        name: '辽宁',
        value: 15
    },
    {
        name: '黑龙江',
        value: 45
    },
    {
        name: '湖南',
        value: 35
    },
    {
        name: '安徽',
        value: 0
    },
    {
        name: '山东',
        value: 52
    },
    {
        name: '新疆',
        value: 0
    },
    {
        name: '江苏',
        value: 10
    },
    {
        name: '浙江',
        value: 38
    },
    {
        name: '江西',
        value: 11
    },
    {
        name: '湖北',
        value: 18248
    },
    {
        name: '广西',
        value: 20
    },
    {
        name: '甘肃',
        value: 35
    },
    {
        name: '山西',
        value: 6
    },
    {
        name: '内蒙古',
        value: 4
    },
    {
        name: '陕西',
        value: 17
    },
    {
        name: '吉林',
        value: 2
    },
    {
        name: '福建',
        value: 0
    },
    {
        name: '贵州',
        value: 21
    },
    {
        name: '广东',
        value: 84
    },
    {
        name: '青海',
        value: 0
    },
    {
        name: '西藏',
        value: 0
    },
    {
        name: '四川',
        value: 70
    },
    {
        name: '宁夏',
        value: 4
    },
    {
        name: '海南',
        value: 3
    },
    {
        name: '台湾',
        value: 29
    },
    {
        name: '香港',
        value: 53
    },
    {
        name: '澳门',
        value: 0
    }
];
option = {
    title: {
        text: "疫情地图: 2020-03-09",
        subtext: "作者：@Houmin"
    },
    tooltip: {
        triggerOn: "click",
    },
    toolbox: {
        feature: {
            dataView: {show: true, readOnly: true},
            restore: {show: true},
            saveAsImage: {show: true}
        }
    },
    visualMap: {
        min: 0,
        max: 100000,
        left: 26,
        bottom: 40,
        showLabel: !0,
        text: ["高", "低"],
        pieces: [{
            gt: 10000,
            label: "> 10000",
            color: "#7f1100"
        }, {
            gte: 1000,
            lte: 10000,
            label: "1000 - 9999",
            color: "#cf1e06"
        }, {
            gte: 100,
            lt: 1000,
            label: "100 - 999",
            color: "#ff5428"
        }, {
            gte: 10,
            lt: 100,
            label: "10 - 99",
            color: "#ff8c71"
        }, {
            gte: 1,
            lt: 10,
            label: "1 - 9",
            color: "#ffd768"
        }, {
            value: 0,
            color: "#ffffff"
        }],
        show: !0
    },
    geo: {
        map: "china",
        roam: !1,
        scaleLimit: {
            min: 1,
            max: 2
        },
        zoom: 1.23,
        top: 120,
        label: {
            normal: {
                show: !0,
                fontSize: "14",
                color: "rgba(0,0,0,0.7)"
            }
        },
        itemStyle: {
            normal: {
                borderColor: "rgba(0, 0, 0, 0.2)"
            },
            emphasis: {
                areaColor: "#f2d5ad",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                borderWidth: 0
            }
        }
    },
    series: [{
        name: "确诊病例",
        type: "map",
        geoIndex: 0,
        data: dataList
    }]
};
  // 使用刚指定的配置项和数据显示图表。
  myChart.setOption(option);
</script>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ECharts 可以画出各种各样漂亮的图表，包括 <code>K 线图</code>、<code>雷达图</code>、<code>关系图</code>、<code>矩形树图</code>等等，可以参考<a href="https://www.echartsjs.com/examples/zh/index.html" target="_blank" rel="external nofollow noopener noreferrer">官方案例</a>。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>当前画图时，如果需要从外部引入数据，比如引入 JSON 文件，在这个插件下会有部分问题。</p>
<ul>
<li>识别不了 <code>jquery</code>中的 <code>$</code>符号，这个可以通过修改 <code>template.html</code>来实现，在 <code>echarts.js</code>上一行引用 <code>jquery.js</code>即可</li>
<li>插入多个图表的时候会有重叠，这个坑以后再填？</li>
<li>ECharts 确实很好看，以后 Python 专用库，以后画图也可以直接用 Python 来画。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Cloving/hexo-tag-echarts-chart" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/Cloving/hexo-tag-echarts-chart</a></li>
<li><a href="https://kchen.cc/2016/11/05/echarts-in-hexo" target="_blank" rel="external nofollow noopener noreferrer">https://kchen.cc/2016/11/05/echarts-in-hexo</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title>Nobody Knows</title>
    <url>/posts/3bdce0a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>美股熔断历史上只发生过三次。上一次熔断，还要追溯到2020年3月9号。那天我的记忆很深刻，那感觉，仿佛就在几天之前。</p>
</blockquote>
<p>新的一周，原油市场黑天鹅突如其来，<code>OPEC+</code>会议上俄罗斯拒绝减产，沙特打响原油价格战。布伦特原油周一大跌 31%，报 32.14 美元/桶，创 1991 年海湾战争以来最大跌幅。另一方面，新冠疫情这头灰犀牛越来越近，美国 10 年期国债收益率跌破 0.5%，创 100年来的历史新低；黄金作为避险资产，价格一举突破 1700 美元/盎司。与此同时，美股一周内发生两次熔断；要知道，美股自1988年开始设立熔断机制，距今一共发生了三次，第一次是1997年的亚洲金融危机，这周内就发生了两次。</p>
<p>这里是「朝花夕拾」第九期 <code>Nobody Knows</code>，标题来自橡树资本创始人 <code>Howard Marks</code>在其官网上发表的<a href="https://www.oaktreecapital.com/docs/default-source/memos/nobody-knows-ii.pdf" target="_blank" rel="external nofollow noopener noreferrer">最新备忘录</a>。上次使用 <code>Nobody Knows</code>作为备忘录的标题，是在2008年9月19日，即雷曼兄弟递交破产申请的四天之后。作为一个经济学小白，我将在这一期回顾上世纪 70 年代的石油危机，尝试去理解<code>原油</code>、<code>美元</code>、<code>黄金</code>背后的逻辑，探讨布雷顿森林体系崩溃以来它们之间的恩怨纠葛。</p>
<a id="more"></a>
<h2 id="古典金本位制"><a href="#古典金本位制" class="headerlink" title="古典金本位制"></a>古典金本位制</h2><p>金本位制是一套体系，在该体系下，所有国家都将其货币的价值与一定黄金数量挂钩，或者是将他们的货币与另一国家已经与一定黄金数量挂钩的货币实行挂钩。国内货币能够以固定的价格自由兑换成黄金，黄金输入输出不受限制。金币与其他金属硬币和纸币一起作为国内货币流通，而各国的金币组分不尽相同。由于各币种的价值都以一定黄金数量来确定，参与这一体系的各币种间的汇率因此也是确定的。</p>
<p>在古典金本位体系下，央行有两项最重要的货币政策职能：</p>
<ul>
<li>确保纸币能够以固定价格兑换成黄金，以及维护汇率。</li>
<li>加快国际收支失衡调整过程，但事实上这一项往往不能得到遵守。</li>
</ul>
<p>古典金本位制从1870年代创立，一直延续至1914年第一次世界大战爆发。19世纪初，拿破仑战争造成的动荡平息后，货币不是硬币（金、银或铜币），就是以硬币为基础发行的银行纸币。但是，开始只有英国和英国部分殖民地采用金本位制，1854年，葡萄牙也加入了该体系。其他国家通常采用银本位，有些国家还采用双金属货币制。</p>
<p>1871年，德意志帝国刚统一，受益于1870年普法战争结束后法国的赔款，德意志帝国开始采取措施，使其在实质上也采用了金本位制。德意志帝国这个决定的影响力，加上英国当时的经济和政治统治地位，以及伦敦金融市场的吸引力，足以促使其他国家转投金本位体系。但是，也有人认为，这个向纯金本位制的转换更多地是因为金银相对供应上出现的变化。不管原因何在，到1900年，除中国和部分中美国家外，所有国家都加入了金本位制。这一格局一直延续到第一次世界大战才被打破。两次世界大战之间，人们曾不时尝试回归纯粹的、古典金本位制，但都未能成功延续到1930年代的大萧条期之后。</p>
<h3 id="金本位制原理"><a href="#金本位制原理" class="headerlink" title="金本位制原理"></a>金本位制原理</h3><p>在金本位制下，国家的货币发行量与黄金挂钩。由于发行的纸币必须要能够兑换成黄金，对流通的纸币量有严格的限制——必须是央行黄金储备量的一定倍数范围内。大多数国家都对黄金与发行纸币/货币比例设有法定最低值，或是其他类似限制。国际收支差异也以黄金结算。拥有国际收支顺差的国家将增持黄金，而逆差国家则减持黄金。</p>
<p>理论上，采用黄金进行国际结算意味着，以金本位为基础的国际货币体系具备自我修正功能。也就是说，出现国际收支逆差的国家黄金储备将减持，那么货币供应量就会减少，继而国内价格水平下降，竞争力相应提升，国际收支情况随之开始被改变。国际收支顺差的国家则反之。这就是18世纪哲学家、经济学家大卫·休谟提出的“物价—现金流动机制”。</p>
<p>它是金本位制运行的基本原理，尽管在现实中情况更为复杂。央行调控可以加速这个适应过程。其中的主要工具是贴现率（即央行向商业银行或金融机构贷款的利率），由贴现率影响市场利率。利率上浮将通过两方面加快调节过程。第一，它会提高贷款成本，从而减少投资支出和国内需求，而这会对国内物价产生下行压力，进而提高产品竞争力、刺激出口。第二，更高的利率会吸引海外资金，改善国际收支资本账户。利率降低将得到相反的效果。央行也可以通过买卖国内资产直接影响流通货币量，但这要求具备深厚的金融市场，所以只有在英国及后来在德国曾大力采用。</p>
<p>运用上述方法能够加快调整经济失衡的过程，一般不必等到需要将大量黄金从一个国家运到另一个国家。</p>
<h3 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h3><p>“游戏规则”这个说法是由凯恩斯提出的（是他在1920年代首先使用了这个短语）。“规则”虽然没有明文条例，但是在古典金本位制时期，各国政府和央行均需要遵循一套行事方式。除了确定并维护固定的黄金价格、使用他国货币自由兑换黄金，以及允许黄金自由进出口外，如上所述，央行通常还需要采取相应措施，促进和加快金本位体系的运做。国家可以在战争等危机时期停用金本位制，但也需要在战争结束后尽快恢复至危机前的平价。</p>
<p>实际上，后来诸多研究人员表示<a href="https://www.gold.org/cn/about-gold/history-of-gold/the-gold-standard#1" target="_blank" rel="external nofollow noopener noreferrer">[1]</a> ，央行并未总是遵循这些“游戏规则”，有时央行通过买入或卖出国内资产，抵消黄金流动对国内货币供应的影响，从而“抑制”黄金流动。央行也可能通过影响“黄金输出点”来影响黄金流动。黄金输出点指从当地铸币商或央行购买的价格与出口黄金价格之间的差价，基本上反映了融资、保险和运送黄金至海外的成本。如果出口黄金的成本低于汇价（即海外黄金售出价），那么黄金出口能够获得利润，反之则无法获得利润。</p>
<p>央行可以通过“黄金工具”操纵上述黄金输出点，从而提高或降低黄金出口的利润，进而影响黄金流动。例如，如果某银行希望阻挠黄金外流，它可以通过提高黄金出口者的融资成本来抬高黄金售价，或者完全拒绝出售黄金、更改黄金提取地点从而提高运输成本。</p>
<p>但是，如果此类违反“规则”的行为只是少数，且与法定平价偏离不多，尤其是出于某一明确目的而停止采用金本位、且此种做法完全属暂时性，那么该体系的信誉还是不会被质疑的。迈克·波尔多<a href="https://www.gold.org/cn/about-gold/history-of-gold/the-gold-standard#2" target="_blank" rel="external nofollow noopener noreferrer">[2]</a> 认为，金本位制首先是一套“承诺”体系，能有效确保政策制定者保持诚信并维护对价格稳定的承诺。</p>
<p>帮助维持该体系的另一个因素是各央行之间开展的合作。例如，英格兰银行（1890年巴林银行危机以及1906至1907年期间）、美国财政部（1893年）和德国国家银行（1898年）均得到过其他央行的援助。</p>
<h2 id="布雷顿森林体系"><a href="#布雷顿森林体系" class="headerlink" title="布雷顿森林体系"></a>布雷顿森林体系</h2><h3 id="布雷顿森林体系建立"><a href="#布雷顿森林体系建立" class="headerlink" title="布雷顿森林体系建立"></a>布雷顿森林体系建立</h3><p>1914年，第一次世界大战爆发，参战国争相用黄金购买军备物资，并<strong>停止了黄金的自由输出和银行券的自由兑换，这一举措基本宣告了国际金本位制的结束</strong>，世界货币体系陷入混乱状态，急需确立新的货币体系。</p>
<p>美元地位的崛起，可以说是从“一战”爆发开始。美国由于远离战火，成功的在“一战”、“二战”中大发了一笔“战争财”。战争期间，<strong>美国通过为参战国提供军火武器及战略物资，吸收了大量的黄金。</strong></p>
<p>另一方面，战后欧洲各国生产力低下，需要从美国购买大量物资。欧洲各国对美国贸易逆差严重，黄金储备告罄。<strong>美元逐渐超越了英镑，成为了世界上最重要的国际储备货币。</strong>美国一跃成为了世界上最大的债权国及黄金储备最多的国家。</p>
<p>1944年，布雷顿森林体系签订，自此，美元具备了世界货币职能。</p>
<p><strong>布雷顿森林体系的核心内容在于“双挂钩“机制：</strong></p>
<ul>
<li><strong>美元与黄金直接挂钩</strong>。规定黄金官价为35美元/盎司。</li>
<li><strong>其他国家货币与美元挂钩</strong>。其他国家通过规定含金量的比例确定同美元的汇率。<strong>实行可调整的固定汇率</strong>，但汇率只能在法定汇率偏差1%之间浮动。各国需在外汇市场上进行干预以维持法定汇率。</li>
</ul>
<p>布雷顿森林体系的确立，使得美元的国际地位与储备价值基本与黄金等同，<strong>美元也因此被称为“美金”</strong>。美元崛起的背后，是美国强大的经济实力和丰富的黄金储备。</p>
<p><strong>布雷顿森林体系建立了以美元为中心、以美国经济实力为依托的世界货币体系，其本质是以美国的国家信用为背书的美元信用本位体系</strong>。此时，美元所包含的国家信用价值已高于黄金所具备的贵金属价值。</p>
<h3 id="特里芬难题"><a href="#特里芬难题" class="headerlink" title="特里芬难题"></a>特里芬难题</h3><blockquote>
<p>二次大战后，各国政府为了保证纸币不崩溃，基本都跟黄金挂钩，国库有多少黄金，就印刷多少纸币，于是跟原始社会一样，又出现通货紧缩，钱不够用了。</p>
</blockquote>
<p>特里芬难题（特里芬悖论，Triffin Dilemma）由美国经济学家罗伯特·特里芬提出，指的是：</p>
<p>一方面，由于美元与黄金挂钩，而其他国家的货币与美元挂钩，美元虽然取得了国际核心货币的地位，但是各国为了发展国际贸易，必须用美元作为结算与储备货币，导致<strong>流出美国的货币在海外不断沉淀，对美国国际收支来说会发生长期逆差</strong>；</p>
<p>另一方面，美元作为国际货币核心的前提是必须保持美元币值坚挺，这又<strong>要求美国保持国际贸易收支长期顺差。</strong></p>
<p><strong>以美元为核心的国际货币体系，对于美元的提出的以上两个要求在客观上存在矛盾。</strong>也就是说，单一主权货币充当国际储备货币，最终一定会陷入特里芬难题。</p>
<p>特里芬难题揭示了布雷顿森林体系的缺陷。</p>
<p>布雷顿森林体系其根本缺陷在于：美元既是国家货币，又是世界货币。美元的发行受制于美国的货币政策和黄金储备。<strong>在“双挂钩”机制下，美元陷入了一个矛盾的处境：世界经济增长对国际支付手段和储备货币的需要，要求美元的供应不断增长。但另一方面，美元供应的不断增加又会导致美元的含金量难以维持。</strong></p>
<h3 id="布雷顿森林体系的解体"><a href="#布雷顿森林体系的解体" class="headerlink" title="布雷顿森林体系的解体"></a>布雷顿森林体系的解体</h3><p>1946年丘吉尔铁幕演说，1947年杜鲁门主义提出，标志着资本主义国家与社会主义国家的“冷战”开始。美国由于与苏联长期的军备竞赛，巨额的军费支出使得美国贸易收支逆差、财政赤字严重。<strong>美元所具备的国家信用下降。</strong></p>
<p>另一方面，1955年，越南战争爆发，此时美国的黄金储备已不足以支撑其债务，国内高通胀率与高失业率并存，经济水平下滑，<strong>美国的国家信用与黄金储备已无力维持美元的国际货币地位</strong>。</p>
<p>1971年8月15日，美国总统尼克松宣布<strong>放弃美元与黄金挂钩</strong>，自此，布雷顿森林体系彻底瓦解。1976年，牙买加体系签订，美元、欧元等多种货币开始争相充当世界货币的角色，<strong>美元不再具备世界货币的职能</strong>。</p>
<h3 id="后布雷顿森林体系与美元霸权演变"><a href="#后布雷顿森林体系与美元霸权演变" class="headerlink" title="后布雷顿森林体系与美元霸权演变"></a>后布雷顿森林体系与美元霸权演变</h3><p><strong>NOT FINISHED YET !!!</strong></p>
<h2 id="石油危机"><a href="#石油危机" class="headerlink" title="石油危机"></a>石油危机</h2><h3 id="OPEC-的愤怒"><a href="#OPEC-的愤怒" class="headerlink" title="OPEC 的愤怒"></a>OPEC 的愤怒</h3><h3 id="美元与石油挂钩"><a href="#美元与石油挂钩" class="headerlink" title="美元与石油挂钩"></a>美元与石油挂钩</h3><h3 id="海湾战争"><a href="#海湾战争" class="headerlink" title="海湾战争"></a>海湾战争</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.oaktreecapital.com/docs/default-source/memos/nobody-knows-ii.pdf" target="_blank" rel="external nofollow noopener noreferrer">https://www.oaktreecapital.com/docs/default-source/memos/nobody-knows-ii.pdf</a></li>
<li><a href="https://pic.bankofchina.com/bocappd/rareport/201906/P020190625709521989301.pdf" target="_blank" rel="external nofollow noopener noreferrer">https://pic.bankofchina.com/bocappd/rareport/201906/P020190625709521989301.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25158741" target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/25158741</a></li>
<li><a href="http://www.iags.org/LuftKorinFAChinese.pdf" target="_blank" rel="external nofollow noopener noreferrer">http://www.iags.org/LuftKorinFAChinese.pdf</a></li>
<li><a href="https://www.zhitongcaijing.com/content/detail/247296.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhitongcaijing.com/content/detail/247296.html</a></li>
</ul>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>经济</tag>
        <tag>货币</tag>
        <tag>黄金</tag>
        <tag>原油</tag>
        <tag>石油危机</tag>
        <tag>布雷顿森林体系</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 使用 Vagrant 管理虚拟机</title>
    <url>/posts/ccdd2b68/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://www.vagrantup.com/" target="_blank" rel="external nofollow noopener noreferrer"><strong>Vagrant</strong></a> 是由 <code>HashiCorp</code>公司开发的构建在 <code>虚拟化技术</code> 之上的虚拟机运行环境管理工具。通过Vagrant可以方便实现的对虚拟机的管理，包括<strong>建立和删除虚拟机</strong>、<strong>配置虚拟机运行参数</strong>、<strong>管理虚拟机运行状态</strong>、<strong>自动化配置和安装开发环境必须的各类软件</strong>、<strong>打包和分发虚拟机运行环境</strong>等。</p>
<a id="more"></a>
<h2 id="关于-Vagrant"><a href="#关于-Vagrant" class="headerlink" title="关于 Vagrant"></a>关于 Vagrant</h2><h3 id="Vagrant-是什么"><a href="#Vagrant-是什么" class="headerlink" title="Vagrant 是什么"></a>Vagrant 是什么</h3><p>Vagrant的运行，需要依赖某项具体的虚拟化技术。由于 <code>VirtualBox</code> 是一项开源的虚拟化软件，可以同时在Windows、Linux、Macintosh、SSolaris等操作系统上运行并支持众多对众多操作系统的虚拟化，因此，在Vagrant开发的初期，唯一支持的是VirtualBox。随着虚拟化技术的快速发展，现在已经有了更多的虚拟化技术可供选择。<code>VMware</code>、<code>HyperV</code>、<code>Docker</code>等都已经可以通过Vagrant的管理而工作。Windows的HyperV技术在部分Windows发行版本中的集成，使得Vagrant在「开盒即用」的特性方面前进了一大步。</p>
<p>因此，<strong>Vagrant是 虚拟机管理工具，不是某项具体的虚拟化技术</strong>。对于各项虚拟化技术而言，Vagrant提供了一套基于配置文件和命令行的管理工具。也正是因为如此，Vagrant完成了对虚拟化技术在一定程度上的封装。这为将虚拟化技术引入到基于桌面运行环境的开发工作流中创造了便利条件。</p>
<h3 id="为什么要使用-Vagrant"><a href="#为什么要使用-Vagrant" class="headerlink" title="为什么要使用 Vagrant"></a>为什么要使用 Vagrant</h3><ul>
<li>使用Vagrant，可以尽可能避免「Work on my machine」错误，保证所有人的开发环境一致。</li>
<li>Vagrant 脚本化配置文件，可以实现开发环境的快速建立。<ul>
<li>使用统一的配置文件（ <code>vagrantfile</code> ）实现对服务器的统一配置。</li>
<li>使用共享文件夹（ <code>shared folder</code> ）实现代码编辑向服务器的快速提交</li>
<li>使用软件配置脚本（ <code>Provisioning scripts</code> ）实现服务器上的运行环境的快速建立</li>
<li>拥有标准化的虚拟机分享网络，极大缓解了分享开发环境配置时的网络带宽压力</li>
<li>可以具备一个供安装维护测试使用的可抛弃的服务器端环境。</li>
</ul>
</li>
</ul>
<h2 id="macOS-配置-Vagrant-环境"><a href="#macOS-配置-Vagrant-环境" class="headerlink" title="macOS 配置 Vagrant 环境"></a>macOS 配置 Vagrant 环境</h2><p>如上所说，「Vagrant是虚拟机管理工具，而不是某项具体的虚拟化技术」。既然是管理虚拟机，那么自然需要虚拟机程序和被虚拟的操作系统镜像（Image）。前者常用的选择有VirtualBox和VMWare，后者则包括Ubuntu、FreeBSD等等。Vagrant称前者为<code>provider</code>，称后者为<code>box</code>。</p>
<ul>
<li>安装 VirtualBox</li>
</ul>
<p><code>VirtualBox</code>作为一项广泛使用的开源虚拟化软件，理所当然成为我们的首选。在 macOS 上安装 virtualbox 直接去其官网上下载安装即可，具体可以参考 <a href="https://www.cnblogs.com/andong2015/p/7688120.html" target="_blank" rel="external nofollow noopener noreferrer">这里</a></p>
<ul>
<li>安装 Vagrant</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install vagrant</span><br></pre></td></tr></table></figure>
<ul>
<li>添加镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vagrant box add ubuntu/trusty64</span><br><span class="line">==&gt; box: Loading metadata <span class="keyword">for</span> box <span class="string">'ubuntu/xenial64'</span></span><br><span class="line">    box: URL: https://vagrantcloud.com/ubuntu/xenial64</span><br><span class="line">==&gt; box: Adding box <span class="string">'ubuntu/xenial64'</span> (v20190514.0.0) <span class="keyword">for</span> provider: virtualbox</span><br><span class="line">    box: Downloading: https://vagrantcloud.com/ubuntu/boxes/xenial64/versions/20190514.0.0/providers/virtualbox.box</span><br><span class="line">    box: Download redirected to host: cloud-images.ubuntu.com</span><br><span class="line">    box: Progress: 1% (Rate: 7173/s, Estimated time remaining: 16:02:42)</span><br></pre></td></tr></table></figure>
<p><code>ubuntu/trusty64</code>是一个公开 Boxes，运行上面第一行命令后，Vagrant 会在工作目录下创建 Vagrantfile 配置文件。在线下载 Box 会比较慢，你可以先下载 Box 之后，再加载本地的 Box 进行初始化。</p>
<p>在<a href="https://vagrantcloud.com/search" target="_blank" rel="external nofollow noopener noreferrer">这里</a>可以下载到各种系统镜像。</p>
<ul>
<li>生成虚拟机</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/Vagrant/xenial64 &amp;&amp; <span class="built_in">cd</span> ~/Vagrant/xenial64</span><br><span class="line">$ vagrant init ubuntu/xenial64</span><br><span class="line">A `Vagrantfile` has been placed <span class="keyword">in</span> this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please <span class="built_in">read</span></span><br><span class="line">the comments <span class="keyword">in</span> the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` <span class="keyword">for</span> more information on using Vagrant.</span><br><span class="line">$ ls -a</span><br><span class="line">.  ..  Vagrantfile</span><br></pre></td></tr></table></figure>
<p>可以看到，执行 <code>vagrant init</code>命令会生成一个 <code>Vagrantfile</code>文件</p>
<ul>
<li>启动虚拟机</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vagrant up</span><br><span class="line">Bringing machine <span class="string">'default'</span> up with <span class="string">'virtualbox'</span> provider...</span><br><span class="line">==&gt; default: Importing base box <span class="string">'ubuntu/xenial64'</span>...</span><br><span class="line">==&gt; default: Matching MAC address <span class="keyword">for</span> NAT networking...</span><br><span class="line">==&gt; default: Checking <span class="keyword">if</span> box <span class="string">'ubuntu/xenial64'</span> is up to date...</span><br><span class="line">==&gt; default: A newer version of the box <span class="string">'ubuntu/xenial64'</span> <span class="keyword">for</span> provider <span class="string">'virtualbox'</span> is</span><br><span class="line">==&gt; default: available! You currently have version <span class="string">'20181220.0.0'</span>. The latest is version</span><br><span class="line">==&gt; default: <span class="string">'20200229.0.0'</span>. Run `vagrant box update` to update.</span><br><span class="line">==&gt; default: Setting the name of the VM: xenial_default_1584000787335_65590</span><br><span class="line">==&gt; default: Fixed port collision <span class="keyword">for</span> 22 =&gt; 2222. Now on port 2200.</span><br><span class="line">==&gt; default: Clearing any previously <span class="built_in">set</span> network interfaces...</span><br><span class="line">==&gt; default: Preparing network interfaces based on configuration...</span><br><span class="line">    default: Adapter 1: nat</span><br><span class="line">==&gt; default: Forwarding ports...</span><br><span class="line">    default: 22 (guest) =&gt; 2200 (host) (adapter 1)</span><br><span class="line">==&gt; default: Running <span class="string">'pre-boot'</span> VM customizations...</span><br><span class="line">==&gt; default: Booting VM...</span><br><span class="line">==&gt; default: Waiting <span class="keyword">for</span> machine to boot. This may take a few minutes...</span><br><span class="line">    default: SSH address: 127.0.0.1:2200</span><br><span class="line">    default: SSH username: vagrant</span><br><span class="line">    default: SSH auth method: private key</span><br><span class="line">    default: Vagrant insecure key detected. Vagrant will automatically replace</span><br><span class="line">    default: this with a newly generated keypair <span class="keyword">for</span> better security.</span><br><span class="line">    default:</span><br><span class="line">    default: Inserting generated public key within guest...</span><br><span class="line">    default: Removing insecure key from the guest <span class="keyword">if</span> it<span class="string">'s present...</span></span><br><span class="line"><span class="string">    default: Key inserted! Disconnecting and reconnecting using new SSH key...</span></span><br><span class="line"><span class="string">==&gt; default: Machine booted and ready!</span></span><br><span class="line"><span class="string">==&gt; default: Checking for guest additions in VM...</span></span><br><span class="line"><span class="string">    default: The guest additions on this VM do not match the installed version of</span></span><br><span class="line"><span class="string">    default: VirtualBox! In most cases this is fine, but in rare cases it can</span></span><br><span class="line"><span class="string">    default: prevent things such as shared folders from working properly. If you see</span></span><br><span class="line"><span class="string">    default: shared folder errors, please make sure the guest additions within the</span></span><br><span class="line"><span class="string">    default: virtual machine match the version of VirtualBox you have installed on</span></span><br><span class="line"><span class="string">    default: your host and reload your VM.</span></span><br><span class="line"><span class="string">    default:</span></span><br><span class="line"><span class="string">    default: Guest Additions Version: 5.1.38</span></span><br><span class="line"><span class="string">    default: VirtualBox Version: 5.2</span></span><br><span class="line"><span class="string">==&gt; default: Mounting shared folders...</span></span><br><span class="line"><span class="string">    default: /vagrant =&gt; /Users/houmin/Vagrant/xenial</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SSH 登录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vagrant ssh</span><br><span class="line">Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-140-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  Get cloud support with Ubuntu Advantage Cloud Guest:</span><br><span class="line">    http://www.ubuntu.com/business/services/cloud</span><br><span class="line"></span><br><span class="line">0 packages can be updated.</span><br><span class="line">0 updates are security updates.</span><br><span class="line"></span><br><span class="line">New release <span class="string">'18.04.4 LTS'</span> available.</span><br><span class="line">Run <span class="string">'do-release-upgrade'</span> to upgrade to it.</span><br><span class="line"></span><br><span class="line">vagrant@ubuntu-xenial:~$ ls</span><br></pre></td></tr></table></figure>
<ul>
<li>关机</li>
</ul>
<h2 id="Vagrantfile-定制"><a href="#Vagrantfile-定制" class="headerlink" title="Vagrantfile 定制"></a>Vagrantfile 定制</h2><p>这里是一个典型的 Vagrantfile 示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># All Vagrant configuration is done below. The "2" in Vagrant.configure</span></span><br><span class="line"><span class="comment"># configures the configuration version (we support older styles for</span></span><br><span class="line"><span class="comment"># backwards compatibility). Please don't change it unless you know what</span></span><br><span class="line"><span class="comment"># you're doing.</span></span><br><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  <span class="comment"># The most common configuration options are documented and commented below.</span></span><br><span class="line">  <span class="comment"># For a complete reference, please see the online documentation at</span></span><br><span class="line">  <span class="comment"># https://docs.vagrantup.com.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Every Vagrant development environment requires a box. You can search for</span></span><br><span class="line">  <span class="comment"># boxes at https://vagrantcloud.com/search.</span></span><br><span class="line">  config.vm.box = <span class="string">"ubuntu/xenial64"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Disable automatic box update checking. If you disable this, then</span></span><br><span class="line">  <span class="comment"># boxes will only be checked for updates when the user runs</span></span><br><span class="line">  <span class="comment"># `vagrant box outdated`. This is not recommended.</span></span><br><span class="line">  <span class="comment"># config.vm.box_check_update = false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a forwarded port mapping which allows access to a specific port</span></span><br><span class="line">  <span class="comment"># within the machine from a port on the host machine. In the example below,</span></span><br><span class="line">  <span class="comment"># accessing "localhost:8080" will access port 80 on the guest machine.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">NOTE:</span> This will enable public access to the opened port</span></span><br><span class="line">  <span class="comment"># config.vm.network "forwarded_port", guest: 80, host: 8080</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a forwarded port mapping which allows access to a specific port</span></span><br><span class="line">  <span class="comment"># within the machine from a port on the host machine and only allow access</span></span><br><span class="line">  <span class="comment"># via 127.0.0.1 to disable public access</span></span><br><span class="line">  <span class="comment"># config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a private network, which allows host-only access to the machine</span></span><br><span class="line">  <span class="comment"># using a specific IP.</span></span><br><span class="line">  config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.10"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a public network, which generally matched to bridged network.</span></span><br><span class="line">  <span class="comment"># Bridged networks make the machine appear as another physical device on</span></span><br><span class="line">  <span class="comment"># your network.</span></span><br><span class="line">  <span class="comment"># config.vm.network "public_network"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Share an additional folder to the guest VM. The first argument is</span></span><br><span class="line">  <span class="comment"># the path on the host to the actual folder. The second argument is</span></span><br><span class="line">  <span class="comment"># the path on the guest to mount the folder. And the optional third</span></span><br><span class="line">  <span class="comment"># argument is a set of non-required options.</span></span><br><span class="line">  config.vm.synced_folder <span class="string">"../data"</span>, <span class="string">"/home/vagrant/workspace"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Provider-specific configuration so you can fine-tune various</span></span><br><span class="line">  <span class="comment"># backing providers for Vagrant. These expose provider-specific options.</span></span><br><span class="line">  <span class="comment"># Example for VirtualBox:</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|vb|</span></span><br><span class="line">    <span class="comment"># Display the VirtualBox GUI when booting the machine</span></span><br><span class="line">    vb.gui = <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Customize the amount of memory on the VM:</span></span><br><span class="line">    vb.memory = <span class="string">"2048"</span></span><br><span class="line">    vb.cpus = <span class="string">"2"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># View the documentation for the provider you are using for more</span></span><br><span class="line">  <span class="comment"># information on available options.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable provisioning with a shell script. Additional provisioners such as</span></span><br><span class="line">  <span class="comment"># Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the</span></span><br><span class="line">  <span class="comment"># documentation for more information about their specific syntax and use.</span></span><br><span class="line">  <span class="comment"># config.vm.provision "shell", inline: &lt;&lt;-SHELL</span></span><br><span class="line">  <span class="comment">#   apt-get update</span></span><br><span class="line">  <span class="comment"># SHELL</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Hostname"><a href="#Hostname" class="headerlink" title="Hostname"></a>Hostname</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.vm.hostname = <span class="string">"cosmos"</span></span><br></pre></td></tr></table></figure>
<h3 id="Port-Mapping"><a href="#Port-Mapping" class="headerlink" title="Port Mapping"></a>Port Mapping</h3><p>对宿主机器上 8080 端口的访问请求 forward 到虚拟机的 80 端口的服务上：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.vm.network <span class="symbol">:forwarded_port</span>, <span class="symbol">guest:</span> <span class="number">80</span>, <span class="symbol">host:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><p>Vagrant 有两种方式来进行网络连接：</p>
<ul>
<li><strong>host-only (主机模式)</strong><ul>
<li>这种模式下所有的虚拟系统是可以互相通信的，但虚拟系统和真实的网络是被隔离开的，虚拟机和宿主机是可以互相通信的，相当于两台机器通过双绞线互联。</li>
</ul>
</li>
<li><strong>Bridge(桥接模式)</strong><ul>
<li>该模式下的 VM 就像是局域网中的一台独立的主机，可以和局域网中的任何一台机器通信，这种情况下需要手动给 VM 配 IP 地址，子网掩码等。</li>
</ul>
</li>
</ul>
<p>我们一般选择 host-only 模式，配置如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.33.10"</span></span><br></pre></td></tr></table></figure>
<h3 id="Shared-Folder"><a href="#Shared-Folder" class="headerlink" title="Shared Folder"></a>Shared Folder</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.vm.synced_folder <span class="string">"../data"</span>, <span class="string">"/home/vagrant/workspace"</span></span><br></pre></td></tr></table></figure>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|vb|</span></span><br><span class="line">  <span class="comment"># Display the VirtualBox GUI when booting the machine</span></span><br><span class="line">  vb.gui = <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Customize the amount of memory on the VM:</span></span><br><span class="line">  vb.memory = <span class="string">"2048"</span></span><br><span class="line">  vb.cpus = <span class="string">"2"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Provision"><a href="#Provision" class="headerlink" title="Provision"></a>Provision</h3><blockquote>
<p>Cloud provisioning is the allocation of a cloud provider’s resources and services to a customer. </p>
</blockquote>
<p><code>Provision</code>是云计算中常见的一个概念，指的是云计算提供商给客户分配资源和服务，Provisioner 也就是资源分配者，在 Vagrant 中可以使用 <code>shell</code>来进行资源分配过程，当然也提供了 <code>docker</code>、<code>salt</code>等其他方式。</p>
<blockquote>
<p>Provisioners in Vagrant allow you to automatically install software, alter configurations, and more on the machine as part of the <code>vagrant up</code> process.</p>
</blockquote>
<p>下面是一个简单地例子，里面主要配置了一些常用软件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config.vm.provision <span class="string">"shell"</span>, inline: &lt;&lt;-SHELL</span><br><span class="line">    <span class="built_in">set</span> -ex</span><br><span class="line">	  <span class="built_in">export</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line">    USER_HOME=/home/vagrant</span><br><span class="line">    mkdir -p /home/vagrant/workspace</span><br><span class="line">    mkdir -p /home/vagrant/software</span><br><span class="line">    PYTHON_VERSION=3.6.6</span><br><span class="line">    <span class="comment"># use aliyun source</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse'</span> &gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse'</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># install package</span></span><br><span class="line">    apt-get -yqq update</span><br><span class="line">    <span class="comment"># install common packages</span></span><br><span class="line">    apt-get install -yqq --no-install-recommends gcc build-essential apt-utils rsync netcat procps libssl-dev</span><br><span class="line">    apt-get install -yqq --no-install-recommends vim htop git tree pv libmysqlclient-dev language-pack-zh-hans ack-grep curl</span><br><span class="line">    <span class="comment"># set git</span></span><br><span class="line">    git config --system push.default simple</span><br><span class="line">    git config --system alias.co checkout</span><br><span class="line">    git config --system alias.br branch</span><br><span class="line">    git config --system alias.ci commit</span><br><span class="line">    git config --system alias.st status</span><br><span class="line">    git config --system core.editor <span class="string">"vim"</span></span><br><span class="line">    git config --system alias.unstage <span class="string">'reset HEAD --'</span></span><br><span class="line">    git config --system alias.lg <span class="string">'log --graph --abbrev-commit --decorate --format=format:"%C(cyan)%h%C(reset) - %C(white)%s%C(reset) %C(yellow)%d%C(reset) %C(dim white) - %anC(reset) %C(dim green)(%ci)%C(reset)" --all'</span></span><br><span class="line">    <span class="comment"># set locales</span></span><br><span class="line">    grep -q -F <span class="string">'LANG=zh_CN.UTF-8'</span> /etc/environment ||  <span class="built_in">echo</span> <span class="string">'LANG=zh_CN.UTF-8'</span> &gt;&gt; /etc/environment</span><br><span class="line">    grep -q -F <span class="string">'LC_ALL=zh_CN.UTF-8'</span> /etc/environment ||  <span class="built_in">echo</span> <span class="string">'LC_ALL=zh_CN.UTF-8'</span> &gt;&gt; /etc/environment</span><br><span class="line">    grep -q -F <span class="string">'LANGUAGE=zh_CN.UTF-8'</span> /etc/environment ||  <span class="built_in">echo</span> <span class="string">'LANGUAGE=zh_CN.UTF-8'</span> &gt;&gt; /etc/environment</span><br><span class="line">    <span class="comment"># set HOST_IP environment</span></span><br><span class="line">    grep -q -F <span class="string">'export HOST_IP=$(ifconfig enp0s8 | grep inet | grep -oE "\\b([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;\\b" | head -1)'</span> /etc/profile || \</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'export HOST_IP=$(ifconfig enp0s8 | grep inet | grep -oE "\\b([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;\\b" | head -1)'</span> &gt;&gt; /etc/profile</span><br><span class="line">    <span class="comment"># set timezone</span></span><br><span class="line">    TZ=Asia/Shanghai</span><br><span class="line">    <span class="comment"># configure ssh</span></span><br><span class="line">    sed -i <span class="string">"s/PasswordAuthentication no/PasswordAuthentication yes/"</span> /etc/ssh/sshd_config</span><br><span class="line">    systemctl restart sshd.service</span><br><span class="line">    <span class="comment"># clean</span></span><br><span class="line">    apt-get autoremove -yqq --purge</span><br><span class="line">    apt-get clean &amp;&amp; apt-get autoclean</span><br><span class="line">    <span class="comment"># set bashrc</span></span><br><span class="line">    grep -q -F <span class="string">"HISTSIZE=1000"</span> <span class="variable">$USER_HOME</span>/.bashrc &amp;&amp; sed -i <span class="string">'s/^HISTSIZE=1000/HISTSIZE=100000/'</span> <span class="variable">$USER_HOME</span>/.bashrc</span><br><span class="line">    grep -q -F <span class="string">"HISTFILESIZE=2000"</span> <span class="variable">$USER_HOME</span>/.bashrc &amp;&amp; sed -i <span class="string">'s/^HISTFILESIZE=2000/HISTFILESIZE=200000/'</span> <span class="variable">$USER_HOME</span>/.bashrc</span><br><span class="line">    <span class="comment"># set prefix sensitive command prompt</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'"\\e[A": history-search-backward'</span> &gt; <span class="variable">$USER_HOME</span>/.inputrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'"\\e[B": history-search-forward'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.inputrc</span><br><span class="line">    chown vagrant: <span class="variable">$USER_HOME</span>/.inputrc</span><br><span class="line">    <span class="comment"># config vimrc</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'filetype plugin indent on'</span> &gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set nocompatible'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'filetype off'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set mouse-=a'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set fileencodings=utf-8'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set termencoding=utf-8'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set fileencoding=utf-8'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'syntax on'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set nu'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set tabstop=4'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set shiftwidth=4'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set expandtab'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set cindent'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set autoindent'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set showmatch'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set cursorline'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set cursorcolumn'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set incsearch'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set hlsearch'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set ignorecase smartcase'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set nowrapscan'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set laststatus=2'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set nostartofline'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'set ruler'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">':color desert'</span> &gt;&gt; <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">    chown vagrant: <span class="variable">$USER_HOME</span>/.vimrc</span><br><span class="line">SHELL</span><br></pre></td></tr></table></figure>
<h2 id="问题索引"><a href="#问题索引" class="headerlink" title="问题索引"></a>问题索引</h2><h3 id="增加磁盘"><a href="#增加磁盘" class="headerlink" title="增加磁盘"></a>增加磁盘</h3><p>为了让虚拟机能够加载新的磁盘，首先我们需要创建磁盘，使用<a href="https://www.virtualbox.org/manual/ch08.html" target="_blank" rel="external nofollow noopener noreferrer"> <code>VBoxManage</code></a>命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ VBoxManage createmedium disk --filename mydisk.vmdk --format vmdk --size 40960</span><br></pre></td></tr></table></figure>
<p>通过 <code>VBoxManage</code>命令把磁盘加载到虚拟机的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ VBoxManage storageattach myvm --storagectl SCSI Controller --port 2 --device 0 --<span class="built_in">type</span> hdd --medium mydisk.vmdk</span><br></pre></td></tr></table></figure>
<p>针对这里的几个参数解释如下：</p>
<ul>
<li>myvm 是想要挂载磁盘的虚拟机名，可以通过 <code>VBoxManage</code>命令查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ VBoxManage list vms</span><br><span class="line"><span class="string">"xenial_default_1584000787335_65590"</span> &#123;7a1ee8ad-2f2a-4433-99d9-15e6e0853962&#125;</span><br><span class="line"><span class="string">"cosmos_default_1584004139557_97080"</span> &#123;c3745cc4-6cea-4868-bca1-ed642722c5a9&#125;</span><br><span class="line"><span class="string">"kernel_default_1584004425866_69721"</span> &#123;394829dd-dc13-4ff2-bee3-02f475d1289a&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>storagectl</code>指明 <code>Name of the storage controller</code>，这部分信息可以通过下列命令看到</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ VBoxManage showvminfo <span class="string">"kernel_default_1584004425866_69721"</span></span><br><span class="line">...</span><br><span class="line">Storage Controller Name (0):            IDE</span><br><span class="line">Storage Controller Type (0):            PIIX4</span><br><span class="line">Storage Controller Instance Number (0): 0</span><br><span class="line">Storage Controller Max Port Count (0):  2</span><br><span class="line">Storage Controller Port Count (0):      2</span><br><span class="line">Storage Controller Bootable (0):        on</span><br><span class="line">Storage Controller Name (1):            SCSI</span><br><span class="line">Storage Controller Type (1):            LsiLogic</span><br><span class="line">Storage Controller Instance Number (1): 0</span><br><span class="line">Storage Controller Max Port Count (1):  16</span><br><span class="line">Storage Controller Port Count (1):      16</span><br><span class="line">Storage Controller Bootable (1):        on</span><br><span class="line">SCSI (0, 0): /Users/houmin/VirtualBox VMs/kernel_default_1584004425866_69721/ubuntu-xenial-16.04-cloudimg.vmdk (UUID: 3f4dfd09-b261-460d-8e2f-bd38923fee10)</span><br><span class="line">SCSI (1, 0): /Users/houmin/VirtualBox VMs/kernel_default_1584004425866_69721/ubuntu-xenial-16.04-cloudimg-configdrive.vmdk (UUID: 01c1e2fc-e8a0-41f5-83c6-4bcf4bcaa158)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，这个虚拟机默认支持 <code>IDE</code>和<code>SCSI</code>两种存储控制器，当前使用<code>SCSI</code>存放了两个磁盘。</p>
<p>进入虚拟机，也可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@cosmos:~$ sudo fdisk -l</span><br><span class="line">Disk /dev/sdb: 10 MiB, 10485760 bytes, 20480 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x602773ce</span><br><span class="line"></span><br><span class="line">设备       启动 Start   末尾   扇区 Size Id 类型</span><br><span class="line">/dev/sda1  *     2048 20971486 20969439  10G 83 Linux</span><br></pre></td></tr></table></figure>
<ul>
<li><code>port</code>指的是存储控制器使用的端口。</li>
<li><code>device</code>指的是 <code>The number of the port&#39;s device which is to be modified</code></li>
<li><code>type</code> 指的是 <code>Define the type of the drive to which the medium is being attached</code></li>
<li><code>medium</code> 指定对应的磁盘文件</li>
</ul>
<p>把上述命令对应到 <code>Vagrantfile</code>，代码如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|vb|</span></span><br><span class="line">  vb.name = <span class="string">"myvm"</span></span><br><span class="line">  vb.memory = <span class="number">2048</span></span><br><span class="line">  vb.cpus = <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  disk = <span class="string">"mydisk.vmdk"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unless</span> File.exist?(disk)</span><br><span class="line">    vb.customize [ <span class="string">"createmedium"</span>, <span class="string">"disk"</span>, <span class="string">"--filename"</span>, disk, <span class="string">"--format"</span>, <span class="string">"vmdk"</span>, <span class="string">"--size"</span>, <span class="number">1024</span> * <span class="number">40</span> ]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  vb.customize [<span class="string">'storageattach'</span>, <span class="symbol">:id</span>, <span class="string">'--storagectl'</span>, <span class="string">"SCSI"</span>, <span class="string">'--port'</span>, <span class="number">0</span>, <span class="string">'--device'</span>, <span class="number">0</span>, <span class="string">'--type'</span>, <span class="string">'hdd'</span>, <span class="string">'--medium'</span>, disk]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>注意这里用的是 <code>SCSI</code>而不是<code>IDE</code>，主要是在使用<code>IDE</code>创建的时候，一直没有成功，显示 <code>Timed out while waiting for the machine to boot.</code></p><p>另外，根据上述配置的时候，可能会出现 <code>Could not find a controller named &#39;SCSI Controller&#39;</code>的问题，参考 GitHub 上的这个 <a href="https://github.com/hashicorp/vagrant/issues/8105" target="_blank" rel="external nofollow noopener noreferrer">issue</a>，我们知道：</p><blockquote><p>This is not a Vagrant isue.</p><p>The issue relies on Virtualbox use different Controller names between os.</p><p>In some OS can be <code>IDE Controller</code> but in other is just <code>IDE</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ VBoxManage list vms</span><br><span class="line"><span class="string">"c7_host01_1481400784099_26895"</span> &#123;97bec202-de3a-4b06-b790-4aa742671dd0&#125;</span><br><span class="line">$ VBoxManage showvminfo 97bec202-de3a-4b06-b790-4aa742671dd0 | grep <span class="string">'Storage Controller Name'</span></span><br><span class="line">Storage Controller Name (0):            IDE </span><br></pre></td></tr></table></figure></blockquote>
          </div>
<h3 id="To-be-added"><a href="#To-be-added" class="headerlink" title="To be added"></a>To be added</h3><p>这部分以后会动态更新。</p>
<h2 id="Vagrant-命令备忘"><a href="#Vagrant-命令备忘" class="headerlink" title="Vagrant 命令备忘"></a>Vagrant 命令备忘</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant box add NAME URL    <span class="comment"># 添加一个box</span></span><br><span class="line">vagrant box list            <span class="comment"># 查看本地已添加的box</span></span><br><span class="line">vagrant box remove NAME     <span class="comment"># 删除本地已添加的box，如若是版本1.0.x，执行vagrant box remove NAME</span></span><br><span class="line">vagrant init NAME           <span class="comment"># 初始化，实质应是创建Vagrantfile文件</span></span><br><span class="line">vagrant up                  <span class="comment"># 启动虚拟机</span></span><br><span class="line">vagrant halt                <span class="comment"># 关闭虚拟机</span></span><br><span class="line">vagrant destroy             <span class="comment"># 销毁虚拟机</span></span><br><span class="line">vagrant reload              <span class="comment"># 重启虚拟机</span></span><br><span class="line">vagrant package             <span class="comment"># 当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box</span></span><br><span class="line">vagrant ssh                 <span class="comment"># 进入虚拟环境</span></span><br><span class="line">vagrant status              <span class="comment"># 查看虚拟机状态</span></span><br></pre></td></tr></table></figure>
<h2 id="VirtualBox-命令备忘"><a href="#VirtualBox-命令备忘" class="headerlink" title="VirtualBox 命令备忘"></a>VirtualBox 命令备忘</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VBoxManage list vms             <span class="comment"># 列出所有的虚拟机</span></span><br><span class="line">VBoxManage list runningvms      <span class="comment"># 列出所有正在运行的虚拟机</span></span><br><span class="line">VBoxManage list hdds            <span class="comment"># 列出VirtualBox当前正在使用的虚拟磁盘的信息</span></span><br><span class="line">VBoxManage showvminfo &lt;uuid|name&gt;                   <span class="comment"># 显示虚拟机的配置信息</span></span><br><span class="line">VBoxManage createvm --name <span class="string">"ubuntu"</span> --register      <span class="comment"># 创建并注册一个虚拟机</span></span><br><span class="line">VBoxManage modifyvm <span class="string">"ubuntu"</span> --name xenial          <span class="comment"># 将虚拟机ubuntu重命名为xenial</span></span><br><span class="line">VBoxManage modifyvm &lt;uuid|name&gt; [--memory &lt;memorysize <span class="keyword">in</span> MB&gt;]   <span class="comment"># 修改虚拟机的内存大小</span></span><br><span class="line">VBoxManage modifyvm win2008 --cpus 2                <span class="comment"># 将虚拟机win2008的CPU个数设为2个</span></span><br><span class="line">VBoxManage modifyvm win2008 --boot1 disk            <span class="comment"># 将虚拟机的第一启动设备设为硬盘</span></span><br><span class="line">VBoxManage modifyvm win2008 --nic1 bridged          <span class="comment"># 将虚拟机win2008的第一个网卡的网络连接方式设为桥接</span></span><br><span class="line">VBoxManage modifyvm win2008 --nictype1 82540EM      <span class="comment"># 将虚拟机win2008的第一个网卡的网卡芯片类型设为82540EM</span></span><br><span class="line">VBoxManage createhd --filename win2008.vdi --size 102400    <span class="comment"># 创建一个大小为100G的虚拟硬盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给虚拟机win2008添加一个IDE控制器</span></span><br><span class="line">VBoxManage storagectl win2008 --name <span class="string">"IDE Controller"</span> --add ide --controller PIIX4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将win2008.vdi文件作为虚拟机win2008的第一块IDE硬盘</span></span><br><span class="line">VBoxManage storageattach win2008 --storagectl <span class="string">"IDE Controller"</span> --port 0 --device 0 --<span class="built_in">type</span> hdd --medium win2008.vdi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置第一个IDE光驱，并挂载安装光盘</span></span><br><span class="line">VBoxManage storageattach win2008 --storagectl <span class="string">"IDE Controller"</span> --port 1 --device 0 --<span class="built_in">type</span> dvddrive --medium server_2008_64.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将主机的/home/vbox目录共享给Guest虚拟机win2008，且共享名为share</span></span><br><span class="line">VBoxManage sharedfolder add win2008 --name share --hostpath /home/vbox</span><br><span class="line">//该命令必须在关闭虚拟机之后才能执行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将主机的/home/vbox目录瞬间共享给Guest虚拟机win2008，且共享名为share</span></span><br><span class="line">VBoxManage sharedfolder add win2008 --name share --hostpath /home/vbox --transient</span><br></pre></td></tr></table></figure>
<p>备注：使用VBoxManage modifyvm命令的前提是虚拟机已经处于关机状态；</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://realworlditblog.wordpress.com/2016/09/23/vagrant-tricks-add-extra-disk-to-box" target="_blank" rel="external nofollow noopener noreferrer">https://realworlditblog.wordpress.com/2016/09/23/vagrant-tricks-add-extra-disk-to-box</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
        <tag>macOS</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>春分</title>
    <url>/posts/b2b4fac7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是武汉封城第五十八天，时值春分，正是郊外踏青的好时节。这些天里，武汉现存确证病例可见地迅速减少到了六千人以内，与此同时海外的疫情仍然在爆发性的增长。这一周资本市场又发生了很多事情，美联储再一次会议中紧急降息100 个基点到 0 ~ 0.25%，美股在接下来的交易日再次熔断，大跌 12 个点，创造 1987 年以来最大历史跌幅。有人开始把这次崩盘和 1929 联系起来，真的会这样吗？</p>
<p>这里是「朝花夕拾」第十期，本来这次打算回顾一下 <code>The Great Depression</code>。看了一些资料觉得那次可以聊得东西太多了，决定在新一期的「资本不眠」单独做一个梳理，这里先挖个坑。今天，我们不聊经济，我们来看看这美丽的春天。</p>

    <div id="aplayer-CNtdKAVQ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="441520" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<p>疫情期间，难得出门，这周和老妈老姐一起出去摘了次草莓。</p>
<p><img alt="小区里的桃花已经开放" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_peach-blossom.jpg"></p>
<p><img alt="路边随处可见的油菜花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_rape-flower.jpg"></p>
<p><img alt="刚过马路，一个大哥拖着一车雪里蕻路过" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_road.jpg"></p>
<p><img alt="因为疫情停止建设的武汉国家航空基地道路" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_construction.jpg"></p>
<p><img alt="仍然在地里劳作的老爷爷" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_oldman.jpg"></p>
<p><img alt="现在正应该是往年春耕繁忙的时节" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_farmer.jpg"></p>
<p><img alt="走到菜地里，已经有小麦抽穗了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_wheat.jpg"></p>
<p><img alt="各个路口仍然有关卡，还有执勤的工作人员" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_rescue.jpg"></p>
<p><img alt="到达农场，养鸡和养鸭的小院没有看见人影" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_duck.jpg"></p>
<p><img alt="农场老板写上的草莓价格，这是一个从河南跑到武汉承包农场的大哥，疫情期间也不容易" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_price.jpg"></p>
<p><img alt="狗狗们在很认真的承担他们的责任：）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_dog.jpg"></p>
<p><img alt="一大棚的草莓" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_greenhouse.jpg"></p>
<p><img alt="地里挂满的草莓，老板让我们放开了吃，最后按照摘的价格付钱，可是我吃了一会儿就饱了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_strawberry.jpg"></p>
<p><img alt="下午五点出门，等到我们返回，天已经快黑了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_sunset.jpg"></p>
<p><img alt="傍晚的晚霞，特别漂亮" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-17_sunset2.jpg"></p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>春天</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux启动过程</title>
    <url>/posts/e27e5d75/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文介绍了 Linux 启动的整个过程。</p>
<p><img alt="Linux Startup Process" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_linux-startup-process.svg"></p>
<a id="more"></a>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>总的来说我们可以把 Linux 系统启动的过程分为下面几个阶段：</p>
<ul>
<li>ROM Stage<ul>
<li>在这个阶段没有内存，需要在ROM上运行代码。这时因为没有内存，没有C语言运行需要的栈空间，开始往往是汇编语言，直接在ROM空间上运行。在找到个临时空间（Cache空间用作RAM，Cache As Ram, CAR）后，C语言终于可以粉墨登场了，后期用C语言初始化内存和为这个目的需要做的一切服务。</li>
</ul>
</li>
<li>RAM Stage<ul>
<li>经过 ROM阶段的困难情况后，我们终于有了可以大展拳脚的内存，很多额外需要大内存的东西可以开始运行了。在这时我们开始进行初始化芯片组、CPU、主板模块等等核心过程。</li>
</ul>
</li>
<li>Find Something To Boot Stage<ul>
<li>终于要进入正题了，需要启动，我们找到启动设备。就要枚举设备，发现启动设备，并把启动设备之前需要依赖的节点统统打通。然后开始移交工作，Windows或者Linux的时代开始。</li>
</ul>
</li>
</ul>
<p>具体来说，</p>
<ul>
<li>在 ROM/RAM Stage，运行的代码我们一般称作固件，也就是 Firmware，最早是 BIOS，现在 UEFI 应用越来越广泛。</li>
<li>固件初始化执行完毕后，Firmware 会将控制权交给 <code>boot loader</code>，最常见的是 GRUB。</li>
<li><code>boot loader</code>之后会将OS内核加载进内存，开始进入操作系统。</li>
<li>OS 一般通过一个 init 进程启动所有的进程，最开始用的是 <code>SysVinit</code>，现在 <code>Systemd</code>应用越来越广泛。</li>
</ul>
<h2 id="Firmware"><a href="#Firmware" class="headerlink" title="Firmware"></a>Firmware</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>BIOS， <code>Basic Input-Output System</code></p>
<p>BIOS 是一组固化在计算机主板ROM里的程序代码，其主要功能是在计算机上电时对硬件进行初始化配置，并将硬件操作封装为BIOS中断服务。这样，各种硬件间的差异便由BIOS负责维护，程序直接调用BIOS中断服务即可实现对硬件的控制。</p>
<p><img alt data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Elitegroup_761GX-M754_-_AMIBIOS_%28American_Megatrends%29_in_a_Winbond_W39V040APZ-5491.jpg/1600px-Elitegroup_761GX-M754_-_AMIBIOS_%28American_Megatrends%29_in_a_Winbond_W39V040APZ-5491.jpg"></p>
<p>在系统上电后，CPU运行于<strong>实模式</strong>工作环境中，数据位宽为16位，最大物理地址寻址范围是0~1MB，其中的物理地址0x0C0000~0x0FFFFF保留给BIOS使用。开机后，CPU硬件逻辑设计为在加电瞬间强行将CS值置为0XF000，IP为0XFFF0，这样CS:IP就指向<strong>0XFFFF0</strong>这个位置，这个位置正是BIOS程序的入口地址。一般情况下，这里是一条跳转指令，CPU通过执行此处的跳转指令跳转到真正的BIOS入口地址处执行，以下是BIOS的启动流程：</p>
<p><img alt="BIOS Boot Process" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_bios-boot-process.png"></p>
<h4 id="加电自检"><a href="#加电自检" class="headerlink" title="加电自检"></a>加电自检</h4><p>BIOS代码首先做的是<strong>POST</strong>（Power On Self Test，<strong>加电自检</strong>）操作，主要是检测关键设备是否正常工作，设备设置是否与CMOS中的设置一致。如果发现硬件错误，则通过喇叭报警；如果没有问题，屏幕就会显示出CPU、内存等信息。</p>
<p><img alt="BIOS POST" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_bios-post.png"></p>
<h4 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h4><p>BIOS的第二步动作就是<strong>枚举本地设备并初始化</strong>。</p>
<p>有一项对启动操作系统至关重要的工作，那就是<strong>BIOS在内存中建立中断向量表和中断服务程序</strong>。</p>
<p>BIOS程序在内存最开始的位置（0x00000）用1KB的内存空间（0x00000~0x003FF）构建中断向量表，在紧挨着它的位置用256KB的内存空间构建BIOS数据区（0x00400~0x004FF），并在大约57KB以后得位置（0x0e05b）加载了8KB左右的与中断向量表相应的若干中断服务程序。</p>
<p>中断向量表有256个中断向量，每个中断向量占4个字节，其中两个字节是CS值，两个字节是IP值。每个中断向量都指向一个具体的中断服务程序。</p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>
<p>这时，BIOS需要知道「下一阶段的启动程序」具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p>
<p>打开BIOS的操作界面，里面有一项就是<code>设定启动顺序</code>。</p>
<p><img alt="BIOS Boot Sequence" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_bios-boot-order.png"></p>
<p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</p>
<div class="note info">
            <p>CMOS又被称作互补金属氧化物半导体，电压控制的一种放大器件，是组成CMOS数字集成电路的基本单元。在计算机领域，CMOS常指保存计算机基本启动信息（如日期、时间、启动设置等）的位于微机主板上的一块<strong>可读写RAM芯片</strong>。在今日，CMOS制造工艺也被应用于制作数码影像器材的感光元件，尤其是片幅规格较大的单反数码相机。</p><p>CMOS主要用来保存当前系统的硬件配置和操作人员对某些参数的设定，CMOS RAM芯片由系统通过<strong>后备电池</strong>供电，在关机状态中，还是遇到系统掉电，<strong>CMOS信息不会丢失</strong>。</p>
          </div>
<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p>
<p>这最前面的512个字节，就叫做<a href="http://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="external nofollow noopener noreferrer">“主引导记录”</a>（Master boot record，缩写为<code>MBR</code>）。</p>
<p><img alt="MBR Structure" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_bios-mbr.png"></p>
<p>MBR 只有 512 字节，由以下三个部分组成：</p>
<ul>
<li>Bootstrap Code Area，前 446 字节，它里面就包含有可执行代码以及错误消息文本。</li>
<li>Partition Table，接下来的64字节，其中包含有四个分区的各自的记录（一个分区占16字节）。</li>
<li>Boot Signature，最后两个字节，0x55AA</li>
</ul>
<p>简单来说，MBR 从 BIOS 获得控制权之后，主要做的事情就是寻找并加载 <code>boot loader</code>。MBR 的前 446 字节包含某个启动引导器，像 <a href="https://wiki.archlinux.org/index.php/GRUB_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">GRUB</a>) 、<a href="https://wiki.archlinux.org/index.php/Syslinux_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">Syslinux</a>) 和 <a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external nofollow noopener noreferrer">LILO</a> 之类的第一启动阶段代码。</p>
<p>MBR 接管后，执行它之后的第二阶段代码，如果后者存在的话，它一般就是Boot Loader。在这之后，我们就进入了 <code>Boot Loader Phase</code>。</p>
<h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>UEFI，<code>Unified Extensible Firmware Interface</code>，前身是EFI规范1.10。UEFI规范描述了<strong>操作系统</strong>和<strong>平台固件</strong>之间的接口，其目的是为操作系统和平台固件定义一种通信方法。</p>
<p>UEFI规范仅提供<strong>操作系统引导过程</strong>所需的信息，旨在无需对平台或操作系统进行深入定制便可在处理器规范兼容的平台上运行操作系统。UEFI规范还允许平台引入创新的特性和功能，在<strong>无需为OS引导程序重新编程的情况下增强平台功能</strong>。UEFI规范适用于从移动系统到服务器的各种硬件平台，并允许原始设备制造商具有最大的<strong>扩展性和定制能力</strong>，以实现差异化。</p>
<p>UEFI接口的表现形式是<strong>数据表</strong>，其中包括<strong>与平台相关的信息</strong>，以及<strong>操作系统加载器</strong>和<strong>操作系统可使用的引导服务</strong>和<strong>运行时服务</strong>。它们一起为启动操作系统提供了一个<strong>标准环境</strong>。UEFI规范设计为纯接口规范。因此，UEFI规范定义了平台固件必须实现的一组接口和结构。</p>
<p>以下是UEFI设计的基本要素：</p>
<ul>
<li><strong>重用现有接口表</strong>。为了让操作系统和固件中的代码可以在现有设计结构中持续使用。凡是兼容UEFI规范的处理器平台都必须遵照UEFI规范进行实现。</li>
<li><strong>系统分区</strong>。系统分区定义了一个独立的、可共享的分区和文件系统，这个系统分区可允许多个供应商之间安全共享数据，即使这些供应商出于不同目的去访问系统分区。</li>
<li><strong>引导服务</strong>。引导服务提供了在启动期间可以使用的设备和系统功能的接口。设备的访问是通过句柄（Handle）和协议（Protocol）抽象出来的。UEFI通过将基础实现隔离在规范之外，以避免给设备的访问者带来负担，进而促进现有BIOS代码的重用。</li>
<li><strong>运行时服务</strong>。运行时服务为操作系统提供了正常运行期间可以使用的基础平台硬件资源的接口。</li>
</ul>
<p>UEFI 不仅能读取分区表，还能自动支持文件系统。所以它不像 BIOS，已经没有仅仅 440 字节可执行代码即 MBR 的限制了，它完全用不到 MBR。</p>
<p>不管第一块上有没有 MBR，UEFI 都不会执行它。相反，它依赖分区表上的一个特殊分区，叫 EFI 系统分区，里面有 UEFI 所要用到的一些文件。计算机供应商可以在 <code>/EFI//</code> 文件夹里放官方指定的文件，还能用固件或它的 shell，即 UEFI shell，来启动引导程序。EFI 系统分区一般被格式化成 FAT32，或比较非主流的 FAT16。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_uefi-platform-overview.png"></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>系统开机 - 上电自检（Power On Self Test 或 POST）。</span><br><span class="line"><span class="bullet">- </span>UEFI 固件被加载，并由它初始化启动要用的硬件。</span><br><span class="line"><span class="bullet">- </span>固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个 UEFI 应用。</span><br><span class="line"><span class="bullet">- </span>固件按照引导管理器中的启动项目，加载UEFI 应用。</span><br><span class="line"><span class="bullet">- </span>已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况）或者启动内核及initramfs（对应于GRUB之类引导器的情况），这取决于 UEFI 应用的配置。</span><br></pre></td></tr></table></figure>
<p><img alt="UEFI Platform Initilization Boot Process" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-24_uefi-pi-boot-process.jpg"></p>
<h4 id="Security-Phase"><a href="#Security-Phase" class="headerlink" title="Security Phase"></a>Security Phase</h4><p>验证阶段 （Security，SEC）</p>
<p>系统上电后，CPU开始执行第一条指令，此时系统就进入SEC阶段。这个阶段的内存尚未被初始化，不可使用。所以，SEC阶段最主要的工作是建立一些临时内存并将CPU切换到保护模式，这里提到的临时内存可以是处理器的缓存，亦或者系统的物理内存。</p>
<h4 id="Pre-EFI-Initailization-Phase"><a href="#Pre-EFI-Initailization-Phase" class="headerlink" title="Pre-EFI Initailization Phase"></a>Pre-EFI Initailization Phase</h4><p>EFI环境预初始化阶段（Pre-EFI Initialization Environment，PEI）</p>
<p>PEI阶段最主要的工作就是对内存、CPU以及芯片组等关键设备进行初始化。由于这部分代码没有进行压缩，因此代码必须越精简越好。而且，在PEI阶段还要确定操作系统的引导路径，初始化UEFI驱动和固件需要的内存。</p>
<h4 id="Driver-eXecution-Environment-Phase"><a href="#Driver-eXecution-Environment-Phase" class="headerlink" title="Driver eXecution Environment Phase"></a>Driver eXecution Environment Phase</h4><p>驱动运行环境阶段（Driver Execution Environment，DXE）</p>
<p>DXE是EFI最重要的阶段，大部分的驱动、固件加载工作都是在这个阶段完成的。</p>
<h4 id="Boot-Device-Selection-Phase"><a href="#Boot-Device-Selection-Phase" class="headerlink" title="Boot Device Selection Phase"></a>Boot Device Selection Phase</h4><p>引导设备选择阶段（Boot Device Select，BDS）</p>
<p>BDS阶段的主要工作是初始化控制台设备的环境变量，尝试加载环境变量列表中记录的驱动，并尝试从环境变量列表中记录的启动设备中启动。</p>
<h4 id="Transient-System-Load-Phase"><a href="#Transient-System-Load-Phase" class="headerlink" title="Transient System Load Phase"></a>Transient System Load Phase</h4><p>临时系统运行阶段（Transient System Load，TSL）</p>
<p>这个阶段将进入UEFI的临时Shell系统环境。</p>
<h4 id="Run-Time-Phase"><a href="#Run-Time-Phase" class="headerlink" title="Run Time Phase"></a>Run Time Phase</h4><p>运行时阶段（RunTime，RT）</p>
<p>当操作系统调用 <code>EFI_BOOT_SERVICES.ExitBootServices</code> 服务后，系统进入RT阶段。此时，DXE与引导服务都将销毁，只有EFI运行时服务和EFI系统表可以继续使用。</p>
<h4 id="After-Life-Phase"><a href="#After-Life-Phase" class="headerlink" title="After Life Phase"></a>After Life Phase</h4><p>后世阶段（After Life，AL）</p>
<p>当操作系统调用 <code>EFI_RUNTIME_SERVICES.ResetSystem</code> 服务或者调用<code>ACPI Sleep State</code>，系统进入AL阶段。触发异步事件（比如：SMI、NMI）亦可使系统进入AL阶段，这在服务器和工作站中比较常见。</p>
<h3 id="UEFI-VS-BIOS"><a href="#UEFI-VS-BIOS" class="headerlink" title="UEFI VS BIOS"></a>UEFI VS BIOS</h3><ul>
<li><p>开发效率</p>
<ul>
<li>BIOS开发一般采用汇编语言，代码大多与硬件控制相关。</li>
<li>在UEFI中，绝大部分代码采用C语言编写，UEFI应用程序和驱动甚至可以使用C++编写。UEFI通过固件-操作系统接口（引导服务和运行时服务）为操作系统和操作系统加载器屏蔽了底层硬件细节，使得UEFI上层应用可以方便重用。</li>
</ul>
</li>
<li><p>可扩展性</p>
<p>大部分硬件的初始化通过UEFI驱动实现。每个驱动是一个独立的模块，可以包含在固件中，也可以放在设备上，运行时根据需要动态加载。UEFI中的每个表和协议（包括驱动）都有版本号，这使得系统升级过程更加简单、平滑。</p>
<p>UEFI系统的可扩展性体现在两个方面</p>
<ul>
<li>一是驱动的模块化设计</li>
<li>二是软硬件升级的兼容性</li>
</ul>
</li>
<li><p>性能</p>
<p>相比BIOS，UEFI有了很大的性能提升，从启动到进入操作系统的时间大大缩短。性能的提高源于以下几个方面：</p>
<ul>
<li>UEFI提供了<strong>异步操作</strong>。基于事件的异步操作，提高了CPU利用率，减少了总的等待时间。</li>
<li>UEFI舍弃了中断这种比较耗时的操作外部设备的方式，仅仅保留了时钟中断。外部设备的操作采用“事件+异步操作”完成。</li>
<li>可伸缩的设备遍历方式，启动时可以仅仅遍历启动所需的设备，进而加速系统启动。</li>
</ul>
</li>
<li><p>安全性</p>
<p>UEFI的一个重要突破就是其安全方面的考虑。当系统的安全启动功能被打开后，UEFI在执行应用程序和驱动前会先检测程序和驱动的证书，仅当证书被信任时才会执行这个应用程序或驱动。UEFI应用程序和驱动采用PE/COFF格式，其签名放在签名块中。</p>
</li>
</ul>
<h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p><code>bootloader</code>是 <a href="https://en.wikipedia.org/wiki/BIOS" target="_blank" rel="external nofollow noopener noreferrer">BIOS</a> 或 <a href="https://wiki.archlinux.org/index.php/UEFI" target="_blank" rel="external nofollow noopener noreferrer">UEFI</a> 启动的第一个程序。它负责使用正确的 <a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="external nofollow noopener noreferrer">内核参数</a> 加载内核, 并根据配置文件加载 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio" target="_blank" rel="external nofollow noopener noreferrer">初始化 RAM disk</a>。对于 UEFI，内核本身可以由 UEFI 使用 EFI boot stub 直接启动，也可以使用单独的引导加载程序或引导管理器来在引导之前编辑内核参数。</p>
<p>在 Linux 中，GRUB是最常用的一个<code>boot loader</code>。在 <code>/boot</code>目录下，我们可以看到，除了内核的四个文件，另外就是<code>grub</code>的相关文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@cosmos:/boot$ tree -L 2</span><br><span class="line">.</span><br><span class="line">├── config-4.4.0-140-generic</span><br><span class="line">├── grub</span><br><span class="line">│   ├── default</span><br><span class="line">│   ├── fonts</span><br><span class="line">│   ├── gfxblacklist.txt</span><br><span class="line">│   ├── grub.cfg</span><br><span class="line">│   ├── grubenv</span><br><span class="line">│   ├── i386-pc</span><br><span class="line">│   ├── locale</span><br><span class="line">│   ├── menu.lst</span><br><span class="line">│   └── unicode.pf2</span><br><span class="line">├── initrd.img-4.4.0-140-generic</span><br><span class="line">├── System.map-4.4.0-140-generic</span><br><span class="line">└── vmlinuz-4.4.0-140-generic</span><br></pre></td></tr></table></figure>
<p>在这里，内核的四个文件解释如下：</p>
<ul>
<li>vmlinuz<ul>
<li>vmlinuz是可引导的、压缩的内核。“vm”代表“Virtual Memory”。</li>
<li>vmlinuz的建立有两种方式。<ul>
<li>zImage<ul>
<li>编译内核时执行<code>make zImage</code></li>
<li>然后通过：<code>cp /usr/src/linux-2.4/arch/i386/linux/boot/zImage /boot/vmlinuz</code>产生</li>
<li>zImage适用于小内核的情况，它的存在是为了向后的兼容性。</li>
</ul>
</li>
<li>bzImage<ul>
<li>内核编译时执行<code>make bzImage</code></li>
<li>然后通过：<code>cp /usr/src/linux-2.4/arch/i386/linux/boot/bzImage /boot/vmlinuz</code>产生</li>
<li>bzImage是压缩的内核映像，需要注意，bzImage不是用bzip2压缩的，bzImage中的bz容易引起误解，bz表示<code>big zImage</code>。</li>
</ul>
</li>
<li>zImage和bzImage都是用gzip压缩的。它们不仅是一个压缩文件，而且在这两个文件的开头部分内嵌有gzip解压缩代码。所以你不能用gunzip 或 gzip –dc解包vmlinuz。</li>
<li>内核文件中包含一个微型的gzip用于解压缩内核并引导它。两者的不同之处在于，老的zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么可以采用zImage 或bzImage之一，两种方式引导的系统运行时是相同的。大的内核采用bzImage，不能采用zImage。</li>
<li>vmlinux是未压缩的内核，vmlinuz是vmlinux的压缩文件。</li>
</ul>
</li>
</ul>
</li>
<li>initrd.img<ul>
<li>initrd是<code>initial ramdisk</code>的简写，值得是一个临时文件系统，它在启动阶段被内核调用。</li>
<li><code>initrd</code>和<code>initramfs</code>是实现的两种技术。<ul>
<li>initrd 是kernel 2.4 及更早的用法</li>
<li>initramfs 是kernel 2.6的技术，现在看到的 initrd文件基本上都是initramfs 了。启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs 的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。</li>
</ul>
</li>
<li>Initrd是在实际根文件系统可用之前挂载到系统中的一个<strong>初始根文件系统</strong>。initrd 与内核绑定在一起，并作为内核引导过程的一部分进行加载。内核然后会将这个 initrd 文件作为其两阶段引导过程的一部分来加载模块，这样才能稍后使用真正的文件系统，并挂载实际的根文件系统。</li>
<li>initrd 中包含了实现这个目标所需要的目录和可执行程序的最小集合，例如将内核模块加载到内核中所使用的 insmod 工具。在桌面或服务器 Linux 系统中，initrd 是一个临时的文件系统。其生存周期很短，只会用作到真实文件系统的一个桥梁。在没有存储设备的嵌入式系统中，initrd 是永久的根文件系统。</li>
</ul>
</li>
<li>System.map<ul>
<li>System.map 内核符号映射表，顾名思义就是将内核中的符号（也就是内核中的函数）和它的地址能联系起来的一个列表。是所有符号及其对应地址的一个列表。之所以这样就使为了用户编程方便，直接使用函数符号就可以了，而不用去记要使用函数的地址。当你编译一个新内核时，原来的System.map中的符号信息就不正确了。随着每次内核的编译，就会产生一个新的 System.map文件，并且需要用该文件取代原来的文件。System.map是一个特定内核的内核符号表。它是你当前运行的内核的System.map的链接。</li>
</ul>
</li>
<li>config<ul>
<li>内核编译时的配置选项。</li>
</ul>
</li>
</ul>
<p>下面是一个典型的 <code>grub.cfg</code></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shutdown menu</span></span><br><span class="line">menuentry <span class="string">"System shutdown"</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"System shutting down..."</span></span><br><span class="line">	halt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># restart menu</span></span><br><span class="line">menuentry <span class="string">"System restart"</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"System rebooting..."</span></span><br><span class="line">	reboot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># UEFI shell</span></span><br><span class="line">menuentry <span class="string">"UEFI Shell"</span> &#123;</span><br><span class="line">	insmod fat</span><br><span class="line">	insmod chain</span><br><span class="line">	search <span class="params">--no-floppy</span> <span class="params">--set=root</span> <span class="params">--file</span> <span class="string">/shellx64.efi</span></span><br><span class="line">	chainloader <span class="string">/shellx64.efi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux boot menu</span></span><br><span class="line">menuentry <span class="string">"Linux"</span> &#123;</span><br><span class="line">	<span class="keyword">set</span> root=<span class="params">(hd0,1)</span></span><br><span class="line">	linux <span class="string">/boot/vmlinuz</span> <span class="params">(add other options here as required)</span></span><br><span class="line">	initrd <span class="string">/boot/initrd.img</span> <span class="params">(if the other kernel uses/needs one)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Linux内核处理所有操作系统进程，如内存管理、任务调度、I/O、进程间通信和系统总体控制。</p>
<p>在 <code>bootloader</code>加载 kernel 和可用的 initramfs 文件，并执行 kernel 之后，kernel 将 initramfs（初始RAM文件系统）压缩包解压缩到（然后清空）rootfs（初始根文件系统，特别是ramfs或tmpfs）。首先提取的 initramfs 是在 kernel 构建过程中嵌入 kernel 二进制Update translation.的 initramfs，然后提取可用的外部 initramfs 文件。因此，外部 initramfs 中的文件会覆盖嵌入式 initramfs 中具有相同名称的文件。然后， kernel 执行 <code>/init</code> （在rootfs中）作为第一个进程。<em>early userspace</em>开始。</p>
<p>initramfs 之所以存在，是为了帮系统访问真正的根文件系统（参见 <a href="https://wiki.archlinux.org/index.php/Arch_filesystem_hierarchy_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">Arch filesystem hierarchy (简体中文)</a>)）。也就是说，那些硬件 IDE, SCSI, SATA, USB/FW 所要求的 kernel 模块，如果并没有内置在 kernel 里，就会被 initramfs 负责加载。一旦通过 <a href="https://wiki.archlinux.org/index.php/Udev_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">udev (简体中文)</a>) 之类的程序或脚本加载好模块，启动流程才会继续下去。所以，initramfs 只要有能够让系统访问真实根文件系统的模块就可以了，不用尽可能地包含一切模块。当然，其它真正有用的模块之后会在 init 流程中被 udev 加载好。</p>
<h2 id="Init-Process"><a href="#Init-Process" class="headerlink" title="Init Process"></a>Init Process</h2><p>在「早期用户空间」的最终环节里，<strong>真正</strong>的根文件系统被挂载好后，就会替换掉原来的<strong>伪</strong>根文件系统。接着 <code>/sbin/init</code> 被执行，同样也替换掉原来的 <code>/init</code> 进程。</p>
<h3 id="SysVinit"><a href="#SysVinit" class="headerlink" title="SysVinit"></a>SysVinit</h3><p>1983 年以来，System V 便是 Unix 和类 Unix （例如 Linux）系统中的经典启动过程。它包括小程序 init 用于 启动诸如 login （由 getty 启动）这样的基础程序，并运行着名为 rc 的脚本。该脚本，控制着一众附加脚本的 执行，而那些附加脚本便是实施系统初始化所需要的任务的脚本。 </p>
<p>程序 init 由文件 /etc/inittab 控制着，并且被组织成用户能够运行的运行级别形式：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>— 停止</span><br><span class="line"><span class="symbol">1 </span>— 单用户模式</span><br><span class="line"><span class="symbol">2 </span>— 多用户，无网络</span><br><span class="line"><span class="symbol">3 </span>— 完整的多用户模式</span><br><span class="line"><span class="symbol">4 </span>— 用户可定义</span><br><span class="line"><span class="symbol">5 </span>— 完整的多用户模式，附带显示管理</span><br><span class="line"><span class="symbol">6 </span>— 重启</span><br></pre></td></tr></table></figure>
<p>常用的默认运行级为 3 或 5。 </p>
<ul>
<li>启动时间长，init是串行启动，只有前一个进程启动完，才会启动下一个进程</li>
<li>启动脚本复杂，Init进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况，这往往使得脚本变得很长</li>
<li>由Linux内核加载运行，位于 <code>/sbin/init</code>   ,是系统中第一个进程，PID永远为1</li>
</ul>
<h3 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h3><ul>
<li>按需启动服务，减少系统资源消耗。</li>
<li>尽可能并行启动进程，减少系统启动等待时间</li>
<li>由Linx内核加载运行，位于 <code>/usr/lib/systemd/systemd</code> ，是系统中第一个进程，PID永远为1</li>
</ul>
<h3 id="命令对比"><a href="#命令对比" class="headerlink" title="命令对比"></a>命令对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>动作</th>
<th style="text-align:left">SystemV</th>
<th style="text-align:left">Systemd</th>
</tr>
</thead>
<tbody>
<tr>
<td>停止某服务</td>
<td style="text-align:left">service httpd stop</td>
<td style="text-align:left">systemctl stop httpd</td>
</tr>
<tr>
<td>重启某服务</td>
<td style="text-align:left">service httpd restart</td>
<td style="text-align:left">systemctl restart httpd</td>
</tr>
<tr>
<td>检查服务状态</td>
<td style="text-align:left">service httpd status</td>
<td style="text-align:left">systemctl status httpd</td>
</tr>
<tr>
<td>删除某服务</td>
<td style="text-align:left">chkconfig —del  httpd</td>
<td style="text-align:left">停掉应用，删除其配置文件</td>
</tr>
<tr>
<td>使服务开机自启动</td>
<td style="text-align:left">chkconfig —level 5 httpd on</td>
<td style="text-align:left">systemctl enable httpd</td>
</tr>
<tr>
<td>使服务开机不自启动</td>
<td style="text-align:left">chkconfig —level 5 httpd off</td>
<td style="text-align:left">systemctl disable httpd</td>
</tr>
<tr>
<td>显示所有已启动的服务</td>
<td style="text-align:left">chkconfig —list</td>
<td style="text-align:left">systemctl list-unit-files</td>
</tr>
<tr>
<td>加入自定义服务</td>
<td style="text-align:left">chkconfig —add  test</td>
<td style="text-align:left">systemctl load test</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h2><p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>命令行登录</li>
<li>ssh登录</li>
<li>图形界面登录　</li>
</ul>
<p>这三种情况，都有自己的方式对用户进行认证。</p>
<ul>
<li>命令行登录：init进程调用getty程序（意为get teletype），让用户输入用户名和密码。输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序/etc/pam.d/login）。如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。</li>
<li>ssh登录：这时系统调用sshd程序（Debian还会再运行/etc/pam.d/ssh ），取代getty和login，然后启动shell。</li>
<li>图形界面登录：init进程调用显示管理器，Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://wiki.archlinux.org/index.php/Arch_boot_process" target="_blank" rel="external nofollow noopener noreferrer">https://wiki.archlinux.org/index.php/Arch_boot_process</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>BIOS</tag>
        <tag>UEFI</tag>
        <tag>GRUB</tag>
        <tag>systemd</tag>
        <tag>sysvinit</tag>
      </tags>
  </entry>
  <entry>
    <title>流れ行く雲</title>
    <url>/posts/d4ef9777/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是武汉封城第六十七天，两个多月过去了，武汉现存的确诊数由当初的 5 万已经减少到了今天的 2045。武汉重启的时间表也已经提上日程，公交地铁开始恢复运营，武汉中欧班列携带防疫物资启程，城市里开始迎来了烟火气，4 月 8 日这座沉睡了两个多月的城市就要迎来解封。三月即将结束，武汉等到了春暖花开。</p>
<p>这里是「朝花夕拾」第十一期，这是一次难忘的春天，不知道以后还有没有机会在家里呆这么长的时间。享受当下，这一期，我们继续来看这美丽的家乡。</p>

    <div id="aplayer-uFGOIJku" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="441532" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<h2 id="始"><a href="#始" class="headerlink" title="始"></a>始</h2><p><img alt="从街道出发，人们还是很谨慎的戴着口罩" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_rumor.jpg"></p>
<p><img alt="走到大堤边，江边的人家就地养鸡" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_chicken2.jpg"></p>
<p><img alt="一群鸡躲在坑里，似乎在抢什么东西吃" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_chicken1.jpg"></p>
<p><img alt="走上大堤，依稀过往的车辆，春天的油菜花，嫩绿的新草" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_levee.jpg"></p>
<h2 id="亭"><a href="#亭" class="headerlink" title="亭"></a>亭</h2><p><img alt="接着往前走，走到了小时候差点在丧命的一个亭子，这又是一个遥远的故事了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_loft1.jpg"></p>
<p><img alt="对称" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_loft2.jpg"></p>
<p><img alt="走进去，可以看到远处的长江" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_loft4.jpg"></p>
<p><img alt="豁然开朗" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_loft3.jpg"></p>
<h2 id="花"><a href="#花" class="headerlink" title="花"></a>花</h2><p>一路上走走拍拍，看到了许多的花花草草。</p>
<p><img alt="蚕豆的花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_flower1.jpg"></p>
<p><img alt="萝卜也开花啦" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_flower2.jpg"></p>
<p><img alt="不知道是什么花，好像是油菜花？" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_flower3.jpg"></p>
<p><img alt="人间四月芳菲尽，山寺桃花始盛开，还在三月，桃花已残" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_flower4.jpg"></p>
<h2 id="草"><a href="#草" class="headerlink" title="草"></a>草</h2><p><img alt="野火烧不尽，春风吹又生" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_grass2.jpg"></p>
<p><img alt="焦土下崭新的生命" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_grass3.jpg"></p>
<p><img alt="很常见却叫不出名字的藤蔓" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_leave6.jpg"></p>
<p><img alt="一片翠绿的草地" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_grass5.jpg"></p>
<h2 id="叶"><a href="#叶" class="headerlink" title="叶"></a>叶</h2><p><img alt="最常见的构树，我们这叫蔲树，已经长出了花果" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_leave2.jpg"></p>
<p><img alt="苦楝树，我们这里叫苦溜子树，小时候经常在这个树上捉到星天牛" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_leave3.jpg"></p>
<p><img alt="这也是我们这很常见的枫杨，也叫大叶柳，长大后会有长条状的果序" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_leave4.jpg"></p>
<p><img alt="嘿嘿，这个我最熟，桑树嘛，毕竟是小时候养过蚕的男人" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_leave5.jpg"></p>
<h2 id="江"><a href="#江" class="headerlink" title="江"></a>江</h2><p><img alt="长江上的大货轮" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_boat1.jpg"></p>
<p><img alt="家附近新建了一个大水厂，好像是在这里抽水" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_boat2.jpg"></p>
<p><img alt="来往长江两岸的轮渡" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_boat3.jpg"></p>
<p><img alt="一度停歇的打渔船" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_river-boat.jpg"></p>
<p><img alt="来来往往的拖沙船" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_cloud.jpg"></p>
<h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p>之前在大理的时候拍过一次延时，那次完全不懂。今天简单学习了一下，还不是很熟悉，用的是 PR 制作的，Final Cut Pro 也试了试，不知道为什么时间轴总是没有设置正确。之后在专门学习下这几个软件，摸索出自己的工作流。</p>
<p>BGM 用的是岸部真明的「流れ行く雲」，和江边流动的烟，流动的云很搭。弹得很好听，以后要玩玩吉他🤔</p>
<iframe src="//player.bilibili.com/player.html?aid=100203108&bvid=BV1P7411D7k2&cid=170913370&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p><img alt="居家小三轮，嘻嘻" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_grass1.jpg"></p>
<p><img alt="不知从何来到这里的摩拜单车" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_mobike.jpg"></p>
<p><img alt="水天一色" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_water.jpg"></p>
<p><img alt="这次再出门，麦子已经开始灌浆了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-03-28_grass4.jpg"></p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>春天</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 initramfs</title>
    <url>/posts/7c0e6000/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是 linux kernel <a href="../../tags/Documentation">Documentation</a> 阅读系列第一篇，在这个系列中，我会记录每一次阅读到的 linux 内核文档。这一篇阅读的是 <a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="external nofollow noopener noreferrer">ramfs, rootfs and initramfs</a>，主要是介绍 <code>initramfs</code>。</p>
<a id="more"></a>
<h2 id="What-is-ramfs"><a href="#What-is-ramfs" class="headerlink" title="What is ramfs?"></a>What is ramfs?</h2><p><code>ramfs</code>是 linux 中利用linux的<code>disk caching</code>机制（page cache 和 dentry cache）实现的可动态伸缩的基于RAM做存储的文件系统。</p>
<p>文件一般放在磁盘上，当需要对其读写的时候会将其加载到内存中。为了提高文件的读写效率，根据局部性原理，linux 基本上都会文件缓存到内存中。</p>
<ul>
<li>当文件的数据被 OS 从后端存储读取到内存的时候，因为这段数据可能之后会被用到，并不会被马上释放，这块数据将会被标记为 <code>clean</code>，就是说可以被释放掉。只有当 VM 系统需要用到这块内存做其他事情的时候，这些数据才会被释放掉。</li>
<li>当有数据写到文件后，这段数据也会被标记为 <code>clean</code>，但是仍然保存在内存中而不释放，以用作缓存的目的。只有当 VM 系统重新申请这块内存的时候，这段数据才会被释放掉。</li>
</ul>
<p>对于 <code>dentry cache</code>，linux 也有类似的机制，从而大大加快了对于目录的访问。</p>
<p>上述说的是我们常见文件系统的机制，对于 <code>ramfs</code>而言，这里根本没有所谓的后端存储。当你要向 <code>ramfs</code>写文件时，我们像原来一样，在内存上分配 <code>page cache</code>和<code>dentry cache</code>，但是这些 cache 不会被写到磁盘这些后端存储中 。所以，这些 cache根本不会被标记为 <code>clean</code>，而会一直存在于内存中，VM系统也无法回收他们的内存，重新分配做它用。</p>
<p>实现 <code>ramfs</code>需要的代码量非常的少，因为他们基本上就是依靠Linux现有的<code>caching infastructure</code>。对于用户而言，我们只是把一个 <code>disk cache</code>加载成文件系统。因此，<code>ramfs</code>就不是通过<code>menuconfig</code>可以被移去的可选模块，它底层的机制是 linux 所必须的。</p>
<p>下面做了一个简单的实验，这是当前系统能够看到的文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@cosmos:~$ df -a</span><br><span class="line">文件系统                   1K-块      已用     可用 已用% 挂载点</span><br><span class="line">sysfs                          0         0        0     - /sys</span><br><span class="line">proc                           0         0        0     - /proc</span><br><span class="line">udev                     1014960         0  1014960    0% /dev</span><br><span class="line">devpts                         0         0        0     - /dev/pts</span><br><span class="line">tmpfs                     204804      5784   199020    3% /run</span><br><span class="line">/dev/sda1               10098468   1978740  8103344   20% /</span><br><span class="line">tmpfs                    1024004         0  1024004    0% /dev/shm</span><br><span class="line">tmpfs                       5120         0     5120    0% /run/lock</span><br><span class="line">home_vagrant_workspace 244810132 199558164 45251968   82% /home/vagrant/workspace</span><br></pre></td></tr></table></figure>
<p>我们可以通过下列命令自己创建 <code>ramfs</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vagrant@cosmos:~$ mkdir ramfs</span><br><span class="line">vagrant@cosmos:~$ sudo mount -t ramfs -o size=10M ramfs ./ramfs/</span><br><span class="line">vagrant@cosmos:~$ df -a</span><br><span class="line">文件系统                   1K-块      已用     可用 已用% 挂载点</span><br><span class="line">sysfs                          0         0        0     - /sys</span><br><span class="line">proc                           0         0        0     - /proc</span><br><span class="line">udev                     1014960         0  1014960    0% /dev</span><br><span class="line">devpts                         0         0        0     - /dev/pts</span><br><span class="line">tmpfs                     204804      5784   199020    3% /run</span><br><span class="line">/dev/sda1               10098468   1978740  8103344   20% /</span><br><span class="line">tmpfs                    1024004         0  1024004    0% /dev/shm</span><br><span class="line">tmpfs                       5120         0     5120    0% /run/lock</span><br><span class="line">home_vagrant_workspace 244810132 199558164 45251968   82% /home/vagrant/workspace</span><br><span class="line">ramfs                          0         0        0     - /home/vagrant/ramfs</span><br><span class="line">vagrant@cosmos:~$ ls -alh ramfs/</span><br><span class="line">总用量 21M</span><br><span class="line">drwxr-xr-x 2 root    root       0 3月  30 09:34 .</span><br><span class="line">drwxr-xr-x 7 vagrant vagrant 4.0K 3月  30 09:32 ..</span><br><span class="line">-rw-r--r-- 1 root    root     20M 3月  30 09:25 test.file</span><br></pre></td></tr></table></figure>
<h2 id="ramfs-and-ramdisk"><a href="#ramfs-and-ramdisk" class="headerlink" title="ramfs and ramdisk"></a>ramfs and ramdisk</h2><p><code>ramdisk</code>是比<code>ramfs</code>出现更早的机制，是利用 RAM 模拟生成一个块设备，以此作为文件系统的后端存储。这个块设备是固定大小的，所以它上面 mount 的文件系统也是固定大小的。和实际的块设备一样，我们需要把<code>page cache</code>从这块假的块设备复制到内存，然后把改变复制回去，对于 <code>dentry cache</code>也是一样。除此之外，它还需要文件系统驱动（比如 ext2）去格式化和解释这段数据。</p>
<p>相较于<code>ramfs</code>，<code>ramdisk</code>会浪费更多的内存，占用更多的内存总线带宽，给 CPU 带来更多的工作，并且污染 CPU 的 cache。相较而言，<code>ramfs</code>的实现机制更加简单和高效。</p>
<p><code>loopback devices</code>是导致 <code>ramdisk</code> 淘汰的另一个原因，它相对于<code>ramdisk</code>而言提供了一种更加灵活和方便的方式来创建块设备，现在是通过文件而不是通过内存。</p>
<h2 id="ramfs-and-tmpfs"><a href="#ramfs-and-tmpfs" class="headerlink" title="ramfs and tmpfs"></a>ramfs and tmpfs</h2><p><code>ramfs</code>的一个问题是，你可以一直往 <code>ramfs</code>里面写数据，直到你用完了所有的内存。而且 VM 系统也不能释放这段内存，因为 VM 认为这些数据应该被写到后端存储，而对于 <code>ramfs</code>而言他没有后端存储。因此，只有 root用户能够往 <code>ramfs</code>写数据。</p>
<p>为了解决上述问题，linux 内核开发者又发明了 <code>tmpfs</code>，给添加了大小的限制和普通用户写数据的权限。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">tmpfs</th>
<th style="text-align:center">ramfs</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">达到空间上限时继续写入</td>
<td style="text-align:center">提示错误信息并终止</td>
<td style="text-align:center">可以继续写尚未分配的空间</td>
</tr>
<tr>
<td style="text-align:center">是否固定大小</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">是否使用swap</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">具有易失性</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
</div>
<h2 id="What-is-rootfs"><a href="#What-is-rootfs" class="headerlink" title="What is rootfs?"></a>What is rootfs?</h2><p><code>rootfs</code>是<code>ramfs</code>或者<code>tmpfs</code>的一种特殊实例，根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件。例如：</p>
<ul>
<li>init进程的应用程序必须运行在根文件系统上</li>
<li>根文件系统提供了根目录“/”</li>
<li>linux挂载分区时所依赖的信息存放于根文件系统/etc/fstab这个文件中</li>
<li>shell命令程序必须运行在根文件系统上，譬如ls、cd等命令</li>
</ul>
<p>一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin /sbin等目录下的shell命令，还有/lib目录下的库文件等···）相配合才能工作。</p>
<p>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。成功之后可以自动或手动挂载其他的文件系统。</p>
<p>下面是 linux 的内核代码。rootfs是基于内存的文件系统，所有操作都在内存中完成；也没有实际的存储设备，所以不需要设备驱动程序的参与。基于以上原因，linux在启动阶段使用rootfs文件系统，当磁盘驱动程序和磁盘文件系统成功加载后，linux系统会将系统根目录从rootfs切换到磁盘文件系统。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init/main.c-&gt;</span><br><span class="line">  start_kernel()-&gt;</span><br><span class="line">  	vfs_caches_init(totalram_pages)–&gt;</span><br><span class="line">  		mnt_init()–&gt;</span><br><span class="line">　　　　　<span class="comment">/* sysfs用来记录和展示linux驱动模型，sysfs先于rootfs挂载是为全面展示linux驱动模型做好准备 */</span></span><br><span class="line">　　　　　sysfs_init();</span><br><span class="line">　　　　　<span class="comment">/* mnt_init()调用sysfs_init()注册并挂载sysfs文件系统，然后调用kobject_create_and_add()创建fs目录 */</span></span><br><span class="line">				fs_kobj = kobject_create_and_add(<span class="string">"fs"</span>, <span class="literal">NULL</span>);</span><br><span class="line">　　　　　<span class="comment">/* init_rootfs()注册rootfs，然后调用init_mount_tree()挂载rootfs */</span></span><br><span class="line">　　　　　init_rootfs();</span><br><span class="line">　　　　　init_mount_tree();</span><br></pre></td></tr></table></figure>
<p>下面是 <code>init_rootfs</code>的代码，可以看到，如果 <code>CONFIG_TMPFS</code>开启，rootfs 将会默认使用 <code>tmpfs</code>，否则使用 <code>ramfs</code>。</p>
<figure class="highlight c"><figcaption><span>init/do_mounts.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">init_rootfs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = register_filesystem(&amp;rootfs_fs_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; !saved_root_name[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">		(!root_fs_names || <span class="built_in">strstr</span>(root_fs_names, <span class="string">"tmpfs"</span>))) &#123;</span><br><span class="line">		err = shmem_init();</span><br><span class="line">		is_tmpfs = <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = init_ramfs_fs();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		unregister_filesystem(&amp;rootfs_fs_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="What-is-initramfs"><a href="#What-is-initramfs" class="headerlink" title="What is initramfs?"></a>What is initramfs?</h2><p>initramfs是一种ramfs文件系统，在内核启动完成后把它复制到rootfs中，作为内核初始的根文件系统，它的任务是挂载系统真正的根文件系统。所有的 2.6 版本的 linux 内核都包含一个gzip 压缩过的 cpio 存档，在kernel 启动的时候，将会将其解压成 <code>rootfs</code>。解压之后，内核将会检查 rootfs 是否有一个 <code>init</code>文件，如果有的话，将会执行 <code>init</code>程序作为 PID 为 1 的进程。在这之后，<code>init</code>进程将会负责其启动整个系统，包括找到并加载真正的根设备。</p>
<p>相对于老的 <code>initrd</code>机制，<code>initramfs</code>有以下几点区别：</p>
<ul>
<li>老的 <code>initrd</code>总是一个独立的文件，而<code>initramfs</code>存档是被链接到内核镜像中去的</li>
<li>老的 <code>initrd</code>文件是一个 gzip 压缩过的文件系统镜像，新的 <code>initramfs</code>是 gzip 压缩过的 cpio存档，相对而言更简单</li>
<li>以往的基于ramdisk 的initrd 使用pivot_root命令切换到新的根文件系统，然后卸载ramdisk。但是initramfs是rootfs，而rootfs既不能pivot_root，也不能umount。为了从initramfs中切换到新根文件系统，需要作如下处理：<ul>
<li>删除rootfs的全部内容，释放空间<br><code>find -xdev / -exec rm &#39;{}&#39; &#39;;&#39;</code></li>
<li>安装新的根文件系统，并切换<br><code>cd /newmount; mount --move . /; chroot .</code></li>
<li>把stdin/stdout/stderr 附加到新的/dev/console，然后执行新文件系统的init程序</li>
</ul>
</li>
</ul>
<p>上述步骤比较麻烦，而且要解决一个重要的问题：第一步删除rootfs的所有内容也删除了所有的命令，那么后续如何再使用这些命令完成其他步骤？busybox的解决方案是，提供了switch_root命令，完成全部的处理过程，使用起来非常方便。</p>
<p><code>switch_root</code>命令的格式是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ switch_root [options] &lt;newrootdir&gt; &lt;init&gt; &lt;args to init&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>newrootdir</code>是实际的根文件系统的挂载目录，执行switch_root命令前需要挂载到系统中</li>
<li>init<code>是实际根文件系统的init程序的路径，一般是/sbin/init；</code></li>
<li>args to init`则是传递给实际的根文件系统的init程序的参数，也是可选的。</li>
</ul>
<p><strong>需要特别注意的是</strong>：switch_root命令必须由PID=1的进程调用，也就是必须由initramfs的init程序直接调用，不能由init派生的其他进程调用，否则会出错，提示：<code>switch_root: not rootfs</code>。也是同样的原因，init脚本调用switch_root命令必须用exec命令调用，否则也会出错，提示：<code>switch_root: not rootfs</code></p>
<h2 id="Contents-of-initramfs"><a href="#Contents-of-initramfs" class="headerlink" title="Contents of initramfs"></a>Contents of initramfs</h2><blockquote>
<p>An initramfs archive is a complete self-contained root filesystem for Linux.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat &gt; hello.c &lt;&lt; EOF</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">  sleep(999999999);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ gcc -static hello.c -o init</span><br><span class="line">$ <span class="built_in">echo</span> init | cpio -o -H newc | gzip &gt; test.cpio.gz</span><br><span class="line"><span class="comment"># Testing external initramfs using the initrd loading mechanism.</span></span><br><span class="line">$ qemu -kernel /boot/vmlinuz -initrd test.cpio.gz /dev/zero</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="external nofollow noopener noreferrer">https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>Documentation</tag>
        <tag>ramfs</tag>
        <tag>rootfs</tag>
        <tag>initramfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu自动选择镜像源</title>
    <url>/posts/63a566a0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>众所周知，Ubuntu 使用官方源执行 <code>apt update</code> 等命令有时候会非常慢。国内有很多镜像服务，但是某些时候偶尔也会抽风，这就导致我们需要日常修改 apt 源。 apt 源是支持 <code>mirror</code> 协议的，从而自动选择可用的一个。</p>
<a id="more"></a>
<p>以下即是使用 mirror 协议后的 <code>/etc/apt/sources.list</code></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">###### Ubuntu Main Repos</span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">###### Ubuntu Update Repos</span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-security main restricted universe multiverse</span></span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
<p>当使用 <code>mirror</code> 协议后，执行 <code>apt update</code> 时会首先<strong>通过 http 访问</strong> <code>mirrors.ubuntu.com/mirrors.txt</code> 文本；文本内容实际上就是<strong>本地</strong>当前可用的镜像源列表，如下所示</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.ustc.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.huaweicloud.com/repository/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.yun-idc.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.nju.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirror.lzu.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.sohu.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.cn99.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//ftp.sjtu.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.cqu.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.aliyun.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.dgut.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//archive.ubuntu.com/ubuntu/</span></span><br></pre></td></tr></table></figure>
<p>得到列表后 apt 会自动选择一个网速快的作为镜像源。</p>
<p>另外一种使用 mirror 协议的方法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ perl -pi -e <span class="string">'s@^\s*(deb(\-src)?)\s+http://us.archive.*?\s+@\1 mirror://mirrors.ubuntu.com/mirrors.txt @g'</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>在命令行执行完上述命令后，<code>/etc/apt/sources.list</code>变为如下，说明其选择了阿里云作为源。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>mirror</tag>
      </tags>
  </entry>
  <entry>
    <title>清明</title>
    <url>/posts/95185ec7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是一个非同寻常的清明节，如同汶川大地震那次的全国默哀一样，今天注定会成为所有国民的国家记忆。封面图是我特别喜欢的一个镜头，<code>20200404</code>、清明、武汉、江汉关、降半旗，在 2020 年的伊始，根本没有人会将这几个词组合在一起。此刻才真正理解了生命无常，在历史、灾难、自然面前，人类是多么的弱小，所有之前的预设都推倒全来。</p>
<p>这里是「朝花夕拾」第十二期，今天我们为他们哀悼，为我们逝去的先辈哀悼，为所有在新冠疫情斗争中牺牲的英烈，为在西昌凉州山火中牺牲的英烈哀悼，为已经逝去的伟大的中国人民哀悼。逝者已去，我们追思低首，缅怀往事；生者继续，我们看向未来，在磨难中不断前行。</p>

    <div id="aplayer-eOeSQdMR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1298843453" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-04-04_qingming.jpg"></p>
<a id="more"></a>
<p>今年清明没有下雨，难得清明在家（虽然去年春招结束清明也跑了回来），像小时候一样，跟着爸妈去两边的祖坟祭扫。小时候不懂得清明扫墓的意义，听着爸妈的安排，坟头黑土盖瓦、黄纸标墓、火盆烧纸、红香磕头。听着爸妈的絮语，希望他们在地下安好，希望他们能够保佑我们在世的孩子。整个过程不许嬉笑，潜移默化中认识了中国这种传统的祖先崇拜。</p>
<p>年岁渐长，开始对于生死有了更多认识。</p>
<hr>
<p>六年级春末奶奶逝去，心里更多的是害怕，看着奶奶越来越消瘦，也知道奶奶是胃癌晚期。直到有一天中午放学回家的路上，突然碰到村里人告知我奶奶去世的消息。回到家中，整个家里白事帐篷已经搭起，看到奶奶一动不动的躺在大堂。心里还是害怕，不愿意接受这个事实。爸妈忙着接待往来客人，无暇顾及我，我也不愿意呆在那个环境下，没吃午饭就自己回到了学校。奶奶是一个典型的传统中国劳动妇女，她勤劳坚忍，和爷爷一起在那个贫乏的年代养活了他们的儿女，也正是因此落下了胃部疾病。她爱她的儿孙们，即使在她病重的时候，还会把家里人买给她好吃的零食分给她那傻傻的孙子吃。当时的我对于死亡还是麻木的，只知道一个疼我爱我的奶奶离开了，但是我却不怎么流泪。</p>
<p>十年后，在我大四即将本科毕业的时候，爷爷也去世了。我仍然记得，接到电话的时候，我正在艺园吃午饭，手机上刷到的是吴文俊院士去世的消息。从北京赶回武汉，协助爸妈打理接待，送爷爷的遗体火葬。</p>
<p>火葬那天下午六点，八大脚用豪华的寿衣将爷爷打扮好，旁边的人问爸爸，「这一套得好几千吧」。「老人生前没穿过这么好的衣服，走的时候希望他能享受一下」，爸爸答道。遗体抬出家门，姑姑们立即高声哭起来。八大脚将爷爷的遗体抬到灵车，我和爸爸一起坐在灵车最前面，前往火葬场。回家以后，我一直没哭过，觉得自己已经在内心接受了这件事情。然而，灵车发动，哀乐奏起，鞭炮响起，突然间抑制不住自己的眼泪。灵车缓缓地从村子里开出，沿路上村里的老人听到音乐，停在路边想这里张望。这样的一幕顿时让我想到了侯孝贤的电影。出来看的主要是老人，看着村里有一个老人走了，他们心里在想着什么呢？也许他们在心里默数，和他们一样大的还剩下哪些人，他们自己距离这件事还有多远，走的时候自己的儿孙们能否料理好自己？出了村，现在还在地里劳作的依然是上了年纪的人，他们停下自己手中的事情，向这边张望着。</p>
<p>回来的路上，田里的麦子开始熟了。家乡所在处早在那之前两年就被设置为拆迁区，武船正在积极建设，武汉国家航天基地的拆迁区也被标识了出来。在走向殡仪馆的路上，沿路黄色的麦子仿佛和以前没有什么不同，而拆迁的标识却告诉我，这里不久就将不复存在了。我看到，麦子熟了，而在麦地里，已经竖下了标语——「航天创造美好生活」。</p>
<hr>
<p>今天，那片麦田早已被繁忙建设的航天基地所取代，村里也马上就要拆迁，家里已经搬到了街道。在这次疫情中，家里人身体都安好，这算是难得的幸运吧。</p>
<p>你们保重，我们会好好的。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>清明</tag>
        <tag>死亡</tag>
      </tags>
  </entry>
  <entry>
    <title>自动抓取经济学人</title>
    <url>/posts/d1848f4f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>作为信息源建设的一部分，最近突然想把「经济学人」阅读捡起来。为了能够固定获取「经济学人」文本，研究了一下其爬取过程，记录如下，希望能够有所帮助。</p><h2 id="经济学人是什么"><a href="#经济学人是什么" class="headerlink" title="经济学人是什么"></a>经济学人是什么</h2><p>经济学人是一份创办于 1843 年 9 月 2 日的英国杂志。这是一本涉及全球政治、经济、文化、科技等多方面事务的综合性新闻评论刊物，着重于对这些议题提供深入的分析和评论。它的社论持有<a href="https://zh.wikipedia.org/wiki/古典自由主義" target="_blank" rel="external nofollow noopener noreferrer">古典自由主义</a>与<a href="https://zh.wikipedia.org/wiki/經濟自由主義" target="_blank" rel="external nofollow noopener noreferrer">经济自由主义</a>的立场，倾向于支持<a href="https://zh.wikipedia.org/wiki/自由貿易" target="_blank" rel="external nofollow noopener noreferrer">自由贸易</a>、<a href="https://zh.wikipedia.org/wiki/全球化" target="_blank" rel="external nofollow noopener noreferrer">全球化</a>、<a href="https://zh.wikipedia.org/w/index.php?title=人口自由流動&amp;action=edit&amp;redlink=1" target="_blank" rel="external nofollow noopener noreferrer">人口自由流动</a>和<a href="https://zh.wikipedia.org/wiki/社會自由主義" target="_blank" rel="external nofollow noopener noreferrer">社会自由主义</a>。</p><a id="more"></a>

<ul>
<li>在创刊之初，其议题主要囊括英国及其殖民地的政治、经济及自由贸易等范围。</li>
<li>1941 年珍珠港事件后首次开辟美国专栏，这是其第一个专门报道某个国家的栏目。</li>
<li>2012年1月，首次开设了中国专栏，这是继1941年的美国栏目之后的首个国家栏目。</li>
</ul>
<h2 id="神奇的calibre"><a href="#神奇的calibre" class="headerlink" title="神奇的calibre"></a>神奇的calibre</h2><p><a href="https://calibre-ebook.com/" target="_blank" rel="external nofollow noopener noreferrer">calibre</a>是一个开源的多平台（支持 Linux，macOS，Windows）电子书管理工具，它支持以下功能：</p>
<ul>
<li>强大的电子书管理工具，支持从网络上下载电子书的元数据。</li>
<li>强大的电子书阅读工具，支持 ToC，搜索，复制等功能。</li>
<li>支持从网络上下载新闻杂志，比如 <code>The Economist</code>, <code>New York Times</code>等，甚至是 RSS源。</li>
<li>内置 web 服务器，可以更加方便的分享和备份图书库</li>
<li>支持编辑电子书，进行格式转换，包括 epub，mobi 等格式</li>
</ul>
<p>calibre 支持一种 <code>recipe</code>的概念，calibre 可以通过 <code>recipe</code>从网络上下载新闻，并且组织成电子书。</p>
<blockquote>
<p><strong>A recipe is a set of instructions that teach calibre how to convert an online news source</strong>, such as a magazine or a blog, into an e-book.</p>
</blockquote>
<p><code>recipe</code>本质上都是 Python 代码，最简单的时候他们只是一些变量，比如 URL，用来告诉 calibre 要从哪里下载新闻。</p>
<p>下面以 <a href="https://lwn.net/" target="_blank" rel="external nofollow noopener noreferrer">LWN</a> 为例（对的，calibre 也可以爬 LWN，但是我太穷了，还订不起）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env  python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> calibre.web.feeds.news <span class="keyword">import</span> BasicNewsRecipe</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LWN</span><span class="params">(BasicNewsRecipe)</span>:</span></span><br><span class="line">    title = <span class="string">u'lwn'</span></span><br><span class="line">    __author__ = <span class="string">'Oliver Niesner'</span></span><br><span class="line">    description = <span class="string">'Linux Weekly News'</span></span><br><span class="line">    oldest_article = <span class="number">54</span></span><br><span class="line">    language = _(<span class="string">'English'</span>)</span><br><span class="line">    max_articles_per_feed = <span class="number">100</span></span><br><span class="line">    needs_subscription = <span class="literal">True</span></span><br><span class="line">    language = <span class="string">'en'</span></span><br><span class="line">    remove_javascript = <span class="literal">True</span></span><br><span class="line">    simultaneous_downloads = <span class="number">1</span></span><br><span class="line">    delay = <span class="number">1</span></span><br><span class="line">    LOGIN = <span class="string">'https://lwn.net/login'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_browser</span><span class="params">(self)</span>:</span></span><br><span class="line">        br = BasicNewsRecipe.get_browser(self)</span><br><span class="line">        <span class="keyword">if</span> self.username <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.password <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            br.open(self.LOGIN)</span><br><span class="line">            br.select_form(name=<span class="string">'loginform'</span>)</span><br><span class="line">            br[<span class="string">'Username'</span>] = self.username</span><br><span class="line">            br[<span class="string">'Password'</span>] = self.password</span><br><span class="line">            br.submit()</span><br><span class="line">        <span class="keyword">return</span> br</span><br><span class="line"></span><br><span class="line">    remove_tags = [</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'LeftColumn'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'NavLink'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'FormattedComment'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'MCTopBanner'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'CommentBox'</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    feeds = [</span><br><span class="line">        (<span class="string">u'lwn'</span>, <span class="string">u'http://lwn.net/headlines/newrss'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postprocess_html</span><span class="params">(self, soup, first)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> tag <span class="keyword">in</span> soup.findAll(name=[<span class="string">'table'</span>, <span class="string">'tr'</span>, <span class="string">'td'</span>]):</span><br><span class="line">            tag.name = <span class="string">'div'</span></span><br><span class="line">        <span class="keyword">return</span> soup</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_version</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> url.replace(<span class="string">'rss'</span>, <span class="string">'?format=printable'</span>)</span><br></pre></td></tr></table></figure>
<p>首先我们看到 LWN 这个 recipe 继承自 <a href="https://manual.calibre-ebook.com/news_recipe.html" target="_blank" rel="external nofollow noopener noreferrer">BasicRecipe</a> 这个基本的类， <a href="https://manual.calibre-ebook.com/news_recipe.html" target="_blank" rel="external nofollow noopener noreferrer">BasicRecipe</a> 实现了所有 recipe 都会用到的逻辑，比如 <strong>get_browser</strong>、<strong>postprocess_html</strong> 等方法，LWN 只需要根据自己的逻辑去重载即可。</p>
<p>我们还可以看到，LWN 这个类下面也定义了很多的参数，这些参数都是根据自己的这次抓取的定制参数。比如最关键的 <code>feeds</code>，这是一个告诉 calibre 从哪下载的 list。</p>
<p>到现在应该明白 calibre 的工作原理了吧。所有下载的源文件都在互联网上以 HTML 的形式你存在，不论是订阅还是非订阅。calibre 通过将这些源文件（HTML 以及图片等）下载后，对 HTML 文本进行再组织，最常用的工具就是 BeautifulSoup。最后，根据 epub 或者 mobi 等格式的要求，进行格式转换即可。</p>
<p>在<a href="https://github.com/kovidgoyal/calibre/blob/master/recipes/economist.recipe" target="_blank" rel="external nofollow noopener noreferrer">这里</a>你可以看到经济学人的 recipe，比较复杂，主要是对 html文本的处理，有时间可以仔细研究。</p>
<p>在 <a href="https://manual.calibre-ebook.com/news.html" target="_blank" rel="external nofollow noopener noreferrer">calibre 的官方文档</a>可以看到关于下载新闻更加详细的教程，以后折腾 RSS 的时候可以再看看。</p>
<h2 id="自动定时抓取经济学人"><a href="#自动定时抓取经济学人" class="headerlink" title="自动定时抓取经济学人"></a>自动定时抓取经济学人</h2><h3 id="ebook-convert"><a href="#ebook-convert" class="headerlink" title="ebook-convert"></a>ebook-convert</h3><p>从 calibre manual 中可以看到，calibre 给我们提供了众多的命令行工具，但是如果只是下载经济学人的话，我们只需要用到 <code>ebook-convert</code>这一工具。其使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ebook-convert input_file output_file [options]</span><br></pre></td></tr></table></figure>
<p>一般情况下，这里的 <code>input_file</code>是需要进行格式转换的输入文件，<code>output_file</code>是格式转换的输出文件。比如我们把一个 epub 格式转换成 <code>mobi</code>格式。但是，calibre 也能够对于 <code>recipe</code>文件进行自动解析，去网络上下载对应的 HTML 文件，并将其输出成需要的格式。具体的，对于经济学人：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ebook-convert <span class="string">"The Economist.recipe"</span> <span class="string">"te2020-04-06.epub'</span></span><br></pre></td></tr></table></figure>
<p>在这里，calibre 会自动根据输出文件的后缀名，将输出文件转换成相应格式，真棒。</p>
<p>对于不同格式的输入输出文件，还有相应的options。</p>
<ul>
<li>对于 Recipe 的输入格式，有以下参数<ul>
<li><code>--username</code>和<code>--password</code>，如果需要用户名和密码的话，可以用于指定相关参数</li>
</ul>
</li>
<li><code>--output-profile</code>可以针对不同设备对输出文件进行优化，比如 <code>--output-profile=kindle_pw3</code></li>
</ul>
<h3 id="什么时候抓取"><a href="#什么时候抓取" class="headerlink" title="什么时候抓取"></a>什么时候抓取</h3><p>根据经济学人的recipe，我们可以看到，其实它每次是以 <a href="https://www.economist.com/printedition" target="_blank" rel="external nofollow noopener noreferrer">https://www.economist.com/printedition</a> 为根节点进行遍历，爬取下面所有的文章。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Economist</span><span class="params">(BasicNewsRecipe)</span>:</span></span><br><span class="line"></span><br><span class="line">    title = <span class="string">'The Economist'</span></span><br><span class="line">    language = <span class="string">'en'</span></span><br><span class="line"></span><br><span class="line">    __author__ = <span class="string">"Kovid Goyal"</span></span><br><span class="line">    INDEX = <span class="string">'https://www.economist.com/printedition'</span></span><br><span class="line">    description = (</span><br><span class="line">        <span class="string">'Global news and current affairs from a European'</span></span><br><span class="line">        <span class="string">' perspective. Best downloaded on Friday mornings (GMT)'</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>什么时候爬取最合适呢，它也写了最好是在 GMT 时间的星期五上午，北京时间是 GMT + 8，所以我们设定自动定时就可以了。</p>
<h3 id="如何抓取音频"><a href="#如何抓取音频" class="headerlink" title="如何抓取音频"></a>如何抓取音频</h3><p>经济学人在官方已经开源了所有的音频文件，其文件地址格式如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>audiocdn.economist.com<span class="regexp">/sites/</span>default<span class="regexp">/files/</span>AudioArchive<span class="regexp">/2013/</span><span class="number">2013</span>MMDD<span class="regexp">/Issue_****_2013MMDD_The_Economist_Full_edition.zip</span></span><br></pre></td></tr></table></figure>
<ul>
<li>MMDD为每周发行日（周六）的月份与日期</li>
<li><code>****</code>为该周六距离1843年9月2日的周数，也就是其期数。</li>
</ul>
<p>为了便于计算，我们计算和查找 <code>2020-01-04</code>是其出版的第 <code>9175</code> 期，之后的期数以这一天为起点计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_date = <span class="string">'2020-01-04'</span></span><br><span class="line">end_date = <span class="string">'2020-04-04'</span></span><br><span class="line">week_start = <span class="number">9175</span></span><br><span class="line">start_sec = time.mktime(time.strptime(start_date,<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line">end_sec = time.mktime(time.strptime(end_date,<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line">week_delta = int((end_sec - start_sec)/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>))</span><br><span class="line">week_now = week_start + week_delta</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>这里的期数应该不是严格按照每一周一期，因为我们发现 <code>20131109</code>这一期的期号为8861，而 <code>20200404</code>这一期的期号为 <code>9188</code>，其间周数间隔为334，而期数间隔为 327，应该是中间有几期没有音频。</p>
          </div>
<h2 id="容器化主宰世界"><a href="#容器化主宰世界" class="headerlink" title="容器化主宰世界"></a>容器化主宰世界</h2><p>将 calibre 容器化，Dockerfile 如下，这里主要是在 alpine 系统上安装了 <code>calibre</code>，然后启动 crontab 定时调用。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ljnelson/docker-calibre-alpine</span><br><span class="line"><span class="keyword">MAINTAINER</span> houmin &lt;houmin.wei@pku.edu.cn&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache python3 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="keyword">if</span> [ ! -e /usr/bin/python ]; <span class="keyword">then</span> ln -sf python3 /usr/bin/python ; <span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> crontab.txt /crontab.txt</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> main.py /main.py</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entry.sh /entry.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /entry.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /usr/bin/crontab /crontab.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/entry.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>为了让外界能够访问这些爬取到的数据，启动一个 FTP 服务器。整体的 <code>docker-compose.yaml</code>如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vsftpd:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">vsftpd</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"fauria/vsftpd"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/calibre/data:/home/vsftpd</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"20:20"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"21:21"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"21100-21110:21100-21110"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FTP_USER=[user]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FTP_PASS=[passwd]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_ADDRESS=127.0.0.1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_MIN_PORT=21100</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_MAX_PORT=21110</span></span><br><span class="line">  <span class="attr">calibre:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">calibre</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"unicosmos/calibre"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/calibre/data/[user]:/data</span></span><br></pre></td></tr></table></figure>
<p>把这里的 <code>user</code> 和 <code>passwd</code> 改成自己服务器的就好了。</p>
<p>程序主函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime, time, os</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"></span><br><span class="line">mail_host = <span class="string">"smtp.163.com"</span></span><br><span class="line">mail_user = <span class="string">"houmin_wei@163.com"</span></span><br><span class="line">mail_pass = <span class="string">"********"</span></span><br><span class="line"></span><br><span class="line">sender = <span class="string">'houmin_wei@163.com'</span></span><br><span class="line">receivers = [<span class="string">'houmin.wei@pku.edu.cn'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_week</span><span class="params">(date)</span>:</span></span><br><span class="line">    start_date = <span class="string">'20200104'</span></span><br><span class="line">    week_start = <span class="number">9175</span></span><br><span class="line">    start_sec = time.mktime(time.strptime(start_date, <span class="string">'%Y%m%d'</span>))</span><br><span class="line">    date_sec = time.mktime(time.strptime(date, <span class="string">'%Y%m%d'</span>))</span><br><span class="line">    week_delta = int((date_sec - start_sec)/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>))</span><br><span class="line">    week_now = week_start + week_delta</span><br><span class="line">    <span class="keyword">return</span> week_now</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_audio</span><span class="params">(date, path)</span>:</span></span><br><span class="line">    week_now = cal_week(date)</span><br><span class="line">    url = <span class="string">"https://audiocdn.economist.com/sites/default/files/AudioArchive/&#123;year&#125;/&#123;date&#125;/Issue_&#123;week&#125;_&#123;date&#125;_The_Economist_Full_edition.zip"</span>.format(year=date[<span class="number">0</span>:<span class="number">4</span>], date=date, week=week_now)</span><br><span class="line">    print(url)</span><br><span class="line">    cmd = <span class="string">"cd &#123;path&#125;/audio &amp;&amp; wget &#123;url&#125; &amp;&amp; cd -;"</span>.format(path=path, url=url)</span><br><span class="line">    os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_book</span><span class="params">(date, path)</span>:</span></span><br><span class="line">    filename = path + <span class="string">"/ebook/te"</span> + date</span><br><span class="line">    <span class="comment">#cmd = 'ebook-convert \"The Economist.recipe\" ' + filename + '.mobi --output-profile=kindle'</span></span><br><span class="line">    cmd = <span class="string">'ebook-convert \"The Economist.recipe\" '</span> + filename + <span class="string">'.epub'</span></span><br><span class="line">    os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(date, path, sender, receivers)</span>:</span></span><br><span class="line">    epubFile = path + <span class="string">"/ebook/te"</span> + date + <span class="string">'.epub'</span></span><br><span class="line">    epubApart = MIMEApplication(open(epubFile, <span class="string">'rb'</span>).read())</span><br><span class="line">    epubApart.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=epubFile)</span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()</span><br><span class="line">    message.attach(epubApart)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = <span class="string">"The Economist "</span> + date</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP(mail_host, <span class="number">465</span>)</span><br><span class="line">        smtpObj.login(mail_user, mail_pass)</span><br><span class="line">        smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">        print(<span class="string">"sending mail success!"</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        print(<span class="string">"Error: cannot send mail"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operator</span><span class="params">(path)</span>:</span></span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    tomorrow = today + datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    date = tomorrow.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line">    print(<span class="string">"==============================================="</span>)</span><br><span class="line">    print(<span class="string">"Fetch The Economist &#123;date&#125; begin..."</span>.format(date=date))</span><br><span class="line">    get_book(date, path)</span><br><span class="line">    <span class="comment">#get_audio(date, path)</span></span><br><span class="line">    <span class="comment">#send_mail(date, path, sender, receivers)</span></span><br><span class="line">    print(<span class="string">"Fetch The Economist &#123;date&#125; end."</span>.format(date=date))</span><br><span class="line">    print(<span class="string">"===============================================\n\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    operator(<span class="string">"./data"</span>)</span><br></pre></td></tr></table></figure>
<p>更多具体的内容，可以参考我的 <a href="https://github.com/SimpCosm/calibre" target="_blank" rel="external nofollow noopener noreferrer">Github Repo</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://manual.calibre-ebook.com/" target="_blank" rel="external nofollow noopener noreferrer">calibre manual</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>calibre</tag>
        <tag>ebook</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化技术概览</title>
    <url>/posts/65866329/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>虚拟化的本质是<strong>抽象</strong>，虚拟化技术本质就是<strong>资源管理与优化</strong>技术。通过将计算机的各种物理资源，比如 <strong>CPU</strong>、<strong>内存</strong>以及磁盘空间、网络适配器等其他 <strong>I/O</strong> 设备，进行抽象转换，呈现出一个可供分割并且可以任意组合的多个计算机的配置环境。通过虚拟化技术，计算、网络、存储等计算机硬件资源得到更好的利用，而这些资源的虚拟形式将不受现有架设方式、地域或物理配置所限制。</p>
<a id="more"></a>
<h2 id="计算虚拟化"><a href="#计算虚拟化" class="headerlink" title="计算虚拟化"></a>计算虚拟化</h2><h3 id="理想数学模型-Turing-Machine"><a href="#理想数学模型-Turing-Machine" class="headerlink" title="理想数学模型 Turing Machine"></a>理想数学模型 Turing Machine</h3><p>在计算机领域，研究的一切问题都是 <strong>可计算问题（Computational Problem）</strong>。</p>
<blockquote>
<p><em>A computational problem</em> is collection of questions that computers might be able to solve.</p>
</blockquote>
<p>通过对问题可计算的判定，我们知道不管计算机的存储和计算能力有多强，有些问题总是不能够被解决的。对于那些可计算的问题，怎么解决呢？1936年，图灵在现代计算领域奠基性论文 「论可计算数及其在判定性问题上的应用」<a href="https://en.wikipedia.org/wiki/On_Computable_Numbers,_with_an_Application_to_the_Entscheidungsproblem" target="_blank" rel="external nofollow noopener noreferrer">On Computable Numbers, with an Application to the Entscheidungsproblem</a> 中提出 <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank" rel="external nofollow noopener noreferrer">图灵机</a> 这一纸带和读写头表示的数学模型，并且证明了<strong>假设</strong>上述模型里所说的功能都能被以某种形式物理实现，<strong>那么</strong> <code>任意可计算问题都可以被解决</code>。</p>
<p><img alt="Turing Machine" data-src="https://upload.wikimedia.org/wikipedia/en/thumb/b/bb/Turing_machine_1.JPG/1024px-Turing_machine_1.JPG"></p>
<h3 id="二战产物-ENIAC"><a href="#二战产物-ENIAC" class="headerlink" title="二战产物 ENIAC"></a>二战产物 ENIAC</h3><p>二战极大促进了电子计算机的诞生，为了帮助美国陆军的弹道研究实验室（BRL）计算火炮的火力表， ENIAC 在 1946 年被设计了出来。ENIAC 并不是二战中第一个被设计出来的计算机，机械和电子计算机器从19世纪就开始出现了，但是20世纪40年代被看作是现代计算机时代的开端。</p>
<ul>
<li>德国<a href="https://zh.wikipedia.org/w/index.php?title=Z3_(计算机" target="_blank" rel="external nofollow noopener noreferrer">Z3</a>&amp;action=edit&amp;redlink=1)计算机于1941年5月公布，这是第一台通用的数字计算机<ul>
<li>使用<a href="https://zh.wikipedia.org/wiki/继电器" target="_blank" rel="external nofollow noopener noreferrer">继电器</a>，机电计算机，不是电子计算机</li>
<li>使用二进制进行逻辑计算</li>
<li>可用打孔纸带编程，但是没有逻辑分支</li>
</ul>
</li>
<li>美国<a href="https://en.wikipedia.org/wiki/Atanasoff–Berry_Computer" target="_blank" rel="external nofollow noopener noreferrer">ABC</a>，1941年夏天公布，是第一台电子计算设备<ul>
<li>使用电子管，电子计算机</li>
<li>使用二进制进行逻辑计算</li>
<li>不是通用的，仅用于求解线性方程组</li>
<li>没有利用电子计算的速度优势，旋转电容鼓存储器，输入输出系统要把中间结果写出到纸片</li>
<li>手动控制的，不可编程</li>
</ul>
</li>
<li>英国的<a href="https://zh.wikipedia.org/wiki/巨人计算机" target="_blank" rel="external nofollow noopener noreferrer">巨人计算机</a> Colossus computer，1943年用于密码分析<ul>
<li>使用电子管，电子计算机</li>
<li>可用插板和开关编程</li>
<li>不是通用的，仅用于密码破译</li>
</ul>
</li>
</ul>
<p>对比这些几乎同时期独立的计算机，ENIAC有以下特点：</p>
<ul>
<li>使用电子管，电子计算机</li>
<li>采用十进制计算</li>
<li>计算速度高，具备逻辑分支能力</li>
<li>符合<strong>图灵完全性</strong>，<strong>能够重新编程</strong>，<strong>解决各种计算问题</strong></li>
<li>缺乏存储程序能力，<strong>冯诺依曼结构</strong>在下一代计算机<a href="https://zh.wikipedia.org/wiki/EDVAC" target="_blank" rel="external nofollow noopener noreferrer">EDVAC</a>上实现</li>
</ul>
<p><img alt="ENIAC, 美国弹道研究实验室" data-src="https://upload.wikimedia.org/wikipedia/commons/4/4e/Eniac.jpg"></p>
<h3 id="多道程序设计-Multiprogramming"><a href="#多道程序设计-Multiprogramming" class="headerlink" title="多道程序设计 Multiprogramming"></a>多道程序设计 Multiprogramming</h3><p>最初的计算机都是串行运行的，一次只能录入并执行一个程序，当程序进行缓慢的 IO 操作时，CPU 只好空转等待。这不仅造成了 CPU 的浪费，也造成了其他计算机硬件资源的浪费。那时的计算机科学家们都在思考着要如何能够提高 CPU 的利用率，直到有人提出了多道程序设计（Multiprogramming，多任务处理的前身）。</p>
<p>在整个上世纪 50-60 年代，多道程序设计的讨论非常流行。它令 CPU 一次性读取多个程序到内存，先运行第一个程序直到它出现了 IO 操作，此时 CPU 切换到运行第二个程序。</p>
<blockquote>
<p>即，<strong>第 n+1 个程序得以执行的条件是第 n 个程序进行 IO 操作或已经运行完毕</strong>。</p>
</blockquote>
<p><img alt data-src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/multiprogramming.jpg"></p>
<p>多道程序设计的特征就是：<strong>多道程序、宏观上并行、微观上串行</strong>。有效的提高了 CPU 的利用率，也充分发挥着其他计算机系统部件的并行性。</p>
<h3 id="分时-Time-Sharing"><a href="#分时-Time-Sharing" class="headerlink" title="分时 Time Sharing"></a>分时 Time Sharing</h3><p>但多道程序设计存在一个问题， 就是<strong>它并不会去考虑分配给各个程序的时间是否均等，很可能第一个程序运行了几个小时而不出现 IO 操作，故第二个程序没有运行</strong>。最初，这个问题是令人接受的，那时的必须多个程序之间的执行顺序更加关心程序的执行结果。直到有人提出了新的需求：多用户同时使用计算机。应需而生的正是时间共享，或者称之为 “分时” 的概念（Time Sharing）。</p>
<p>所谓 “分时” 的含义是将 CPU 占用切分为多个极短（1/100sec）的时间片，每个时间片都执行着不同的任务。分时系统中允许几个、几十个甚至几百个用户通过终端机连接到同一台主机，将处理机时间与内存空间按一定的时间间隔，轮流地切换给各终端用户的程序使用。由于时间间隔很短，每个用户感觉就像他独占了计算机一样。<strong>分时系统达到了多个程序分时共享计算机硬件和软件资源的效果</strong>，本质就是一个多用户交互式操作系统。</p>
<p>分时系统与多道程序设计虽然类似，却也有着底层实现细节的不同</p>
<ul>
<li>分时系统是为了给不同用户提供程序的使用，而多道程序则是为了不同程序间的穿插运行</li>
</ul>
<p>1959 年，牛津大学的计算机教授，Christopher Strachey 发表了一篇名为 <a href="https://archive.org/details/large-fast-computers" target="_blank" rel="external nofollow noopener noreferrer">Time sharing in large fast computers</a> 的学术报告，他在文中首次提出了 “虚拟化” 的基本概念，还论述了什么是虚拟化技术。</p>
<blockquote>
<p><strong>Time sharing</strong>, in the sense of causing the main computer to interrupt its program to perform the arithmetic and control operations required by external or peripheral equipment, has been used on a limited scale for a long time. this paper explores the possibility of applying time sharing to a large fast computer on a very extensive scale.</p>
</blockquote>
<p>本质上，Strachey 是在讨论如何将分时的概念融入到多道程序设计当中，从而实现一个可多用户操作（CPU 执行时间切片），又具有多程序设计效益（CPU 主动让出）的虚拟化系统。可见，<strong>虚拟化概念最初的提出就是为了满足多用户同时操作大型计算机，并充分利用大型计算机各部件资源的现实需求</strong>。而对这一需求的实现与演进，贯穿了整个大型机与小型机虚拟化技术的发展历程。</p>
<p>1961年 MIT 在 IBM7094 型机器上实现了首个分时系统CTSS（Compatible Time-Sharing System，相容分时系统）</p>
<h3 id="超级计算机-Altas"><a href="#超级计算机-Altas" class="headerlink" title="超级计算机 Altas"></a>超级计算机 Altas</h3><p>1962 年 12 月 7 日，第一台 Atlas 超级计算机在英国诞生，Atlas 是第二代晶体管计算机，被认为是当时世界上最强大的计算机。Atlas 开创了许多沿用至今的软件概念：</p>
<ul>
<li>第一次实现名为 Atlas Supervisor 的底层资源管理组件，<strong>Supervisor</strong> 通过特殊的指令或代码来管理主机的硬件资源</li>
<li>第一次实现分页技术（<strong>Paging Techniques</strong>）</li>
<li>第一次实现虚拟内存（<strong>Virtual Memory</strong>），当时被称为一级存储（One-Level Store）</li>
</ul>
<h3 id="第一个支持虚拟化-IBM-M44-44X"><a href="#第一个支持虚拟化-IBM-M44-44X" class="headerlink" title="第一个支持虚拟化 IBM M44/44X"></a>第一个支持虚拟化 IBM M44/44X</h3><p>1964 年的 IBM M44/44X 被认为是世界上第一个支持虚拟化的系统。它采用专门的硬件和软件，能够在一台物理机器上虚拟多个当时流行的 IBM 7044 大型机。它使用的虚拟化方法是非常原始的：像分时系统一样，在每个时间片，一个 IBM 7044 大型机独占所有硬件资源来运行。</p>
<p>值得一提的是，这个研究用的原型系统不仅开启了虚拟化技术的时代，M44/44X 实现了多个具有突破性的虚拟化概念，包括部分<strong>硬件共享（Partial Hardware Sharing）</strong>、<strong>分时（Time Sharing）</strong>、<strong>内存分页（Memory Paging）</strong>以及<strong>虚拟内存（Virtual Memory）</strong>。M44/44X 项目首次使用了 “<strong>Virtual Machine</strong>” 这一术语，所以被认为是世界上第一个支持虚拟机的计算机系统。虽然 M44/44X 只实现了部分的虚拟化功能，但其最大的成功在于证明了虚拟机的运行效率并不一定比传统的方式更低</p>
<p>在那个 “进程” 概念尚未被发明的年代，多任务操作系统和虚拟化技术事实上是难以分开的，因为 “虚拟机” 就是一个任务，而且当时还没有 Intel x86 这种霸主地位的体系结构，各家的大型机各自为政，也谈不上兼容别家的体系结构。这种 “任务级” 或者说 “进程级” 虚拟化，从概念上延续到今天，就是以 LXC 和 OpenVZ 为代表的操作系统级虚拟化。</p>
<h3 id="IBM的豪赌-System-360"><a href="#IBM的豪赌-System-360" class="headerlink" title="IBM的豪赌 System/360"></a>IBM的豪赌 System/360</h3><p>1964 年，IBM推出了著名的 System/360 大型计算机系统，整个研发过程投资巨大，其出货时间也不断延迟。但最终，取得了巨大的商业成功。当时的项目经理 <code>Frederick P. Brooks</code>事后根据这项计划的开发经验写出了同样著名的《人月神话：软件项目管理之道》（“The Mythical Man-Month: Essays on Software Engineering”），记述了人类工程史上一项里程碑式的大型复杂软件系统的开发经验。</p>
<ul>
<li>System/360 实现了基于全硬件的虚拟化解决方案（<strong>Full Hardware Virtualization</strong>）</li>
<li>System/360 实现了 TSS（Time Sharing System）分时系统，TSS 被认为是最原始的 <strong>CPU 虚拟化技术</strong>，它可以让低端电脑连接大型主机，上传和下载程序或资料，将电子数据处理的 “松散终端” 连接起来。</li>
</ul>
<blockquote>
<p><strong>虚拟化技术的应用和发展源于大型机对分时系统的需求</strong>。这种通过硬件的方式来生成多个可以运行独立操作系统软件的虚拟机实例，解决了早期大型计算机只能单任务处理而不能分时多任务处理的问题。由于这种虚拟化技术是基于硬件设备来实现的，故被称为<strong>硬件虚拟化（Hardware virtualization）</strong>。但需要注意的是，这一定义在后来被进一步细分为了狭义的硬件虚拟化技术，<strong>现今更加被公认的硬件虚拟化定义是：一种对计算机或操作系统的虚拟化，能够对用户隐藏真实的计算机硬件，表现出另一个抽象的计算平台。</strong></p>
</blockquote>
<h3 id="伟大实验-MULTICS"><a href="#伟大实验-MULTICS" class="headerlink" title="伟大实验 MULTICS"></a>伟大实验 MULTICS</h3><p>MULTICS，全名 <code>MULTiplexed Information and Computing System</code>，是1964年由贝尔实验室、麻省理工学院及美国通用电气公司所共同参与研发的，是一套安装在大型主机上多人多任务的操作系统，是连接1000部终端机，支持300的用户同时上线。</p>
<p>MULTICS 是一个伟大的实验，得意于第一代分时系统 CTSS 的成功，它在开发之初就提出了很高的要求：</p>
<ul>
<li>首次在大型软件中采用结构化的程序设计方法，使得开发周期大大缩短</li>
<li>首次采用高级语言编写操作系统，使得系统程序在功能上独立于机器</li>
<li>首次采用成熟软件作为工具，MULTICS中的很大一部分程序是用CTSS来编写</li>
<li>首次引入动态链接和分层文件系统的概念</li>
</ul>
<p>然而，由于当时编写 MULTICS 的 PL/I 语言并没有很成熟，无力肩负编写操作系统这样的重担。而且整个开发过程中求大求全，多个单位参与，进展过慢，贝尔实验室退出此计划。</p>
<h3 id="玩具而已-UNIX"><a href="#玩具而已-UNIX" class="headerlink" title="玩具而已 UNIX"></a>玩具而已 UNIX</h3><p>1969年，在 AT&amp;T 的Bell Labs，<code>Ken Thompson</code>为了一项名为<code>Space Travel</code>的游戏，需要一个操作系统。他找了一台闲置的PDP-7 小型机，独自经过 4 个星期的奋斗，以汇编语言写出了一组内核程序，同时包括一些内核工具程序，以及一个小的文件系统，这就是伟大的 UNIX 操作系统的原型。</p>
<p>UNIX 系统本质上是对 MULTICS 系统的简化，当时开发者 <code>Brian Kernighann</code> 开玩笑地戏称这个不完善系统MULTICS其实是 <code>UNiplexed Information and Computing System</code>，缩写为<code>UNICS</code>。后来，大家取其谐音这个名字被改为<code>UNIX</code>。</p>
<p>1973 年，贝尔实验室的<code>Dennis Ritchie</code> 以 B 语言为基础开发了一种称为 C 的编程语言。C 语言的设计原则就是好用，非常自由、弹性很大。<code>Ken Thompson</code>和<code>Dennis Ritchie</code>使用 C 语言完全重写了 UNIX，此后 UNIX 就真正成为了可移植的操作系统，那时已是 1977 年。</p>
<p>1979 年，Unix 的第 7 个版本引入了 chroot 机制，意味着第一个<strong>操作系统虚拟化（OS-level virtualization）</strong>诞生了。chroot 是直到现在我们依然在使用的一个系统调用，这个系统调用会让一个进程把指定的目录作为根目录，它的所有文件系统操作都只能在这个指定目录中进行，本质是一种文件系统层的隔离。</p>
<h3 id="虚拟化准则-VMM"><a href="#虚拟化准则-VMM" class="headerlink" title="虚拟化准则 VMM"></a>虚拟化准则 VMM</h3><p>1974 年，<code>Gerald J. Popek</code> 和 <code>Robert P. Goldberg</code>在合作论文《可虚拟第三代架构的规范化条件》（“Formal Requirements for Virtualizable Third Generation Architectures”）中提出了一组称为虚拟化准则的充分条件，又称波佩克与戈德堡虚拟化需求（<strong>Popek and Goldberg virtualization requirements</strong>），即：虚拟化系统结构的三个基本条件。满足这些条件的控制程序才可以被称为<strong>虚拟机监控器（Virtual Machine Monitor，简称 VMM）</strong>：</p>
<ul>
<li><strong>资源控制（Resource Control）</strong>，控制程序必须能够管理所有的系统资源。</li>
<li><strong>等价性（Equivalence）</strong>，在控制程序管理下运行的程序（包括操作系统），除时序和资源可用性之外的行为应该与没有控制程序时的完全一致，且预先编写的特权指令可以自由地执行。</li>
<li><strong>效率性（Efficiency）</strong>，绝大多数的客户机指令应该由主机硬件直接执行而无需控制程序的参与。</li>
</ul>
<p>该论文尽管基于简化的假设，但上述条件仍为评判一个计算机体系结构是否能够有效支持虚拟化提供了一个便利方法，也为设计可虚拟化的计算机架构给出了指导原则。同时，Gerald J. Popek 和 Robert P. Goldberg 还在论文中介绍了两种 Hypervisor 类型。</p>
<p><img alt="Hypervisor" data-src="https://upload.wikimedia.org/wikipedia/commons/e/e1/Hyperviseur.png"></p>
<ul>
<li>类型 I (<strong>Bare-metal Hypervisors</strong>)<ul>
<li>这些虚拟机管理程序直接运行在宿主机（Host）的硬件上来控制硬件和管理虚拟机。</li>
<li>需要硬件支持</li>
<li>VMM 作为宿主机操作系统（Host OS）</li>
<li>运行效率高</li>
</ul>
</li>
</ul>
<p><img alt="Hypervisor" data-src="https://microkerneldude.files.wordpress.com/2012/01/type1-vs-2.png"></p>
<ul>
<li>类型 II（<strong>Hosted Hypervisorsr</strong>）<ul>
<li>VMM 运行在传统的宿主机操作系统（Host OS）上，就像其他应用程序那样运行。</li>
<li>VMM 作为应用程序运行在宿主机操作系统之上</li>
<li>运行效率一般较类型 I 低</li>
</ul>
</li>
</ul>
<p>由于技术的原因，早期的 VMM 产品大多实现的是寄居式，例如：VMware 5.5 以前的版本、Xen 3.0 以前的版本。随着技术的成熟，主要是硬件虚拟化技术的诞生，几乎所有的 VMM 产品都转向了裸金属 Hypervisor 实现。例如：VMware 5.5 及以后版本、Xen 3.0 及以后版本以及 KVM。</p>
<h3 id="接棒开源-GNU-Linux"><a href="#接棒开源-GNU-Linux" class="headerlink" title="接棒开源 GNU/Linux"></a>接棒开源 GNU/Linux</h3><p><img alt="GNU/Linux" data-src="https://i1.wp.com/www.linuxandubuntu.com/wp-content/uploads/2019/07/What-is-GNU-in-GNULinux.jpg"></p>
<h3 id="软件辅助虚拟化-QEMU"><a href="#软件辅助虚拟化-QEMU" class="headerlink" title="软件辅助虚拟化 QEMU"></a>软件辅助虚拟化 QEMU</h3><p>2001，Fabrice Bellard 发布了目前最流行的、采用了<strong>动态二进制翻译（Binary Translation）</strong>技术的开源虚拟化软件 QEMU（Quick EMUlator）。QEMU 可以模拟 x86、x86_64、ARM、MIPS、SPARC、PowerPC 等多种处理器架构，无修改地运行这些架构上的操作系统。</p>
<p><strong>软件辅助虚拟化</strong> 是通过 <strong>优先级压缩（Ring Compression）</strong>和 <strong>二进制代码翻译（Binary Translation）</strong>这两个技术来完成的。RC 基于 CPU 特权级的原理。也就是 guest、VMM 和 host 分别处于不同的特权级上，guest 要访问 host 就属于越级访问，会抛异常，这时 VMM 会截获这个异常，并模拟出其可能的行为，从而进行相应处理。</p>
<p>以我们最熟悉的 Intel x86 架构为例，分为四个特权级 0~3。一般情况下，操作系统内核（特权代码）运行在 ring 0（最高特权级），而用户进程（非特权代码）运行在 ring 3（最低特权级）。</p>
<p><img alt data-src="https://ring0.me/images/2014/12/9c37a75e8e2164f50ffe76681c6d4522.png"></p>
<p>使用了虚拟机之后，Guest OS 运行在 ring 1，VMM 运行在 ring 0。比如在 Windows 上装个 Linux 虚拟机，Windows 内核运行在 ring 0，而被虚拟的 Linux 内核运行在 ring 1，Linux 系统里的应用程序则运行在 ring 3。当虚拟机系统需要执行特权指令时，VMM 就会立即捕获它（谁让 ring 0 比 ring 1 的特权级高呢！）并模拟执行这条特权指令，再返回到虚拟机系统。</p>
<p>为了提高系统调用、中断处理的性能，有时会利用动态二进制翻译的技术，在运行前把这些特权指令替换成调用虚拟机管理器 API 的指令。如果所有特权指令都模拟得天衣无缝，虚拟机系统就像运行在物理机器上一样，完全不能发现自己运行在虚拟机里。</p>
<h3 id="半虚拟化-Xen"><a href="#半虚拟化-Xen" class="headerlink" title="半虚拟化 Xen"></a>半虚拟化 Xen</h3><p>2003 年，英国剑桥大学的一位讲师发布了开源虚拟化项目 Xen 1.0，通过<strong>半虚拟化技术</strong>为 x86-64 提供虚拟化支持。</p>
<p>既然<strong>动态二进制翻译的难点和性能瓶颈在于模拟执行那些杂七杂八的特权指令</strong>，我们能不能修改虚拟机系统的内核，把那些特权指令改得好看些？毕竟在多数情况下，我们并不需要对虚拟机刻意 “隐瞒” 虚拟化层的存在，而是要在虚拟机之间提供必要的隔离，同时又不造成太多性能开销。</p>
<p>Paravirtualization 这个单词的前缀是 para-，即 “with” “alongside” 之意。也就是虚拟机系统与虚拟化层（主机系统）不再是严格的上下级关系，而是互信合作的关系，<strong>虚拟化层要在一定程度上信任虚拟机系统。在 x86 架构中，虚拟化层（Virtualization Layer）和虚拟机系统的内核（Guest OS）都运行在 ring 0。</strong></p>
<p><img alt data-src="https://ring0.me/images/2014/12/98ce27bf0640053df5db977f6c41cc3e.png"></p>
<p><strong>虚拟机系统的内核需要经过特殊修改，把特权指令改成对虚拟化层 API 的调用</strong>。在现代操作系统中，由于这些体系结构相关的特权操作都被封装起来了（例如 Linux 内核源码中的 arch/ 目录），比起二进制翻译需要考虑各种边角情况，这种对虚拟机内核源码的修改就简单一些了。</p>
<p><strong>相比使用二进制翻译的全虚拟化（full virtualization），半虚拟化是牺牲了通用性来换取性能，因为任何操作系统都可以无修改地运行在全虚拟化平台上，而每个半虚拟化的操作系统内核都要经过人肉修改。</strong></p>
<h3 id="硬件辅助虚拟化-Intel-VT-x"><a href="#硬件辅助虚拟化-Intel-VT-x" class="headerlink" title="硬件辅助虚拟化 Intel VT-x"></a>硬件辅助虚拟化 Intel VT-x</h3><p>2006 年，Intel 和 AMD 等厂商相继将对虚拟化技术的支持加入到 x86 体系结构的CPU中（AMD-V，Intel VT-x/d），使原来纯软件实现的各项功能可以用借助硬件的力量实现提速，此即 <strong>硬件辅助的虚拟化</strong>。</p>
<p>Xen这种<strong>将 Guest OS 中的特权指令改成对虚拟化层 API 的调用</strong>方式<strong>并不通用</strong>，要去改 Guest OS 的代码，只能看作是一种定制。为了能够通用，又能够提高性能，就只能从硬件上去做文章了。通过对硬件本身加入更多的虚拟化功能，就可以截获更多的敏感指令，填补上漏洞。所以后来，以 Intel 的 VT-x 和 AMD 的 AMD-V 为主的硬件辅助的 CPU 虚拟化就被提出来（Intel VT 包括 VT-x （支持 CPU 虚拟化）、EPT（支持内存虚拟化）和 VT-d（支持 I/O 虚拟化））。</p>
<p><img alt data-src="https://ring0.me/images/2014/12/05112238fed78cb9df19c07ec82544cf.png"></p>
<p>CPU 硬件辅助虚拟化在 Ring 模式的基础上引入了一种新的模式，叫 VMX 模式。它包括根操作模式（VMX Root Operation）和非根操作模式（VMX Non-Root Operation）。</p>
<p>引入这种模式的好处就在于，Guest OS 运行在 Ring 0 上，就意味着它的核心指令可以直接下达到硬件层去执行，而特权指令等敏感指令的执行则是由硬件辅助，直接切换到 VMM 执行，这是自动执行的，应用程序是感知不到的，性能自然就提高了。</p>
<p>这种切换 VT-x 定义了一套机制，称为 VM-entry 和 VM-exit。从非根模式切换到根模式，也就是从 Guest 切换到 Host VMM，称为 VM-exit，反之称为 VM-entry。</p>
<ul>
<li>VM-exit ： 如果 Guest OS 运行过程中遇到需要 VMM 处理的事件，比如中断或缺页异常，或者主动调用 <code>VMCAL</code>指 令调用 VMM 服务的时候（类似于系统调用），硬件自动挂起 Guest OS，切换到根模式，VMM 开始执行。</li>
<li>VM-entry： VMM 通过显示调用 <code>VMLAUNCH</code> 或 <code>VMRESUME</code> 指令切换到非根模式，硬件自动加载 Guest OS 的上下文，Guest OS 开始执行。</li>
</ul>
<p><img alt data-src="https://images2018.cnblogs.com/blog/431521/201712/431521-20171203175521851-450299329.png"></p>
<h3 id="基于内核的虚拟化-KVM"><a href="#基于内核的虚拟化-KVM" class="headerlink" title="基于内核的虚拟化 KVM"></a>基于内核的虚拟化 KVM</h3><p>2007 年 2 月，Linux Kernel 2.6.20 合入了 KVM 内核模块，使用 KVM 的前提是 CPU 必须要支持虚拟化技术。</p>
<p>一般 KVM 只负责 CPU 和内存的虚拟化，I/O 的虚拟化则由另外一个技术来完成，即 QEMU。</p>
<p><img alt="Kernel-based Virtual Machine" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Kernel-based_Virtual_Machine.svg/967px-Kernel-based_Virtual_Machine.svg.png"></p>
<p>KVM 是一种硬件辅助的虚拟化技术，支持 Intel VT-x 和 AMD-v 技术，怎么知道 CPU 是否支持 KVM 虚拟化呢？可以通过如下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep -E '(vmx|svm)' /proc/cpuinfo</span></span><br></pre></td></tr></table></figure>
<p>如果输出是 vmx 或 svm，则表明当前 CPU 支持 KVM，Intel 是 vmx，AMD 是svm。</p>
<p>从本质上看，一个 KVM 虚拟机对应 Host 上的一个 qemu-kvm 进程，它和其他 Linux 进程一样被调度，而 qemu-kvm 进程中的一个线程就对应虚拟机的虚拟 CPU （vCPU），虚拟机中的任务线程就被 vCPU 所调度。</p>
<p>比如下面这个例子，Host 机有两个物理 CPU，上面起了两个虚拟机 VM1 和 VM2，VM1 有两个 vCPU，VM2 有 3 个 vCPU，VM1 和 VM2 分别有 2 个 和 3 个线程在 2 个物理 CPU 上调度。VM1 和 VM2 中又分别有 3 个任务线程在被 vCPU 调度。</p>
<p>所以，这里有两级的 CPU 调度，Guest OS 中的 vCPU 负责一级调度，Host VMM 负责另一级调度，即 vCPU 在物理 CPU 上的调度。</p>
<p><img alt data-src="https://images2018.cnblogs.com/blog/431521/201712/431521-20171203175802101-1388918605.png"></p>
<p>我们也可以看到，vCPU 的个数，可以超过物理 CPU 的个数，这个叫 CPU 「超配」，这正是 CPU 虚拟化的优势所在，这表明了虚拟机能够充分利用 Host 的 CPU 资源，进行相应的业务处理，运维人员也可以据此控制 CPU 资源使用，达到灵活调度。</p>
<h3 id="大数据时代-GFS-MapReduce-BigTable"><a href="#大数据时代-GFS-MapReduce-BigTable" class="headerlink" title="大数据时代 GFS/MapReduce/BigTable"></a>大数据时代 GFS/MapReduce/BigTable</h3><ul>
<li>2003 年，Google 发布 <code>The Google File System</code>，讲述了一种可扩展的分布式文件系统</li>
<li>2004 年，Google 发布 <code>MapReduce: Simplified Data Processing on Large Clusters</code>，讲述了大数据的分布式计算方式，即将任务分解然后在多台处理能力较弱的计算节点中同时处理，然后将结果合并从而完成大数据处理。</li>
<li>2006 年，Google 发布 <code>Bigtable: A Distributed Storage System for Structured Data</code>，讲述了用于存储和管理结构化数据的分布式存储系统，其建立在 GFS、MapReduce 等基础之上。该论文启发了后期的很多的 NoSQL 数据库，包括 Cassandra、HBase 等。</li>
</ul>
<p>在 Google 的三篇论文发布之后，大数据时代宣告到来，于此同时，Hadoop 生态开始建立。</p>
<h3 id="云计算吃螃蟹的人-AWS"><a href="#云计算吃螃蟹的人-AWS" class="headerlink" title="云计算吃螃蟹的人 AWS"></a>云计算吃螃蟹的人 AWS</h3><p>2006 年，<strong>Amazon Web Services</strong> 开始以 Web 服务的形式向企业提供 IT 基础设施服务，包括弹性计算网云（EC2）、简单储存服务（S3）、简单数据库（SimpleDB）等，现在通常称为云计算。尽管云计算最早是由谷歌CEO <code>Eric Schmidt</code>，真正第一个吃螃蟹的人却是 Amazon。</p>
<p><img alt data-src="https://img-blog.csdnimg.cn/20190817201518961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"></p>
<h3 id="操作系统级虚拟化-LXC"><a href="#操作系统级虚拟化-LXC" class="headerlink" title="操作系统级虚拟化 LXC"></a>操作系统级虚拟化 LXC</h3><p><strong>2008 年 6 月</strong>，Linux Container（LXC） 发布 0.1.0 版本，其可以提供轻量级的虚拟化，用来隔离进程和资源，是 Docker 最初使用的容器技术支撑。</p>
<p>很多时候，我们并不是想在虚拟机里运行任意的操作系统，而是希望在不同的任务间实现一定程度的隔离。前面提到的虚拟化技术，每个虚拟机都是一个独立的操作系统，有自己的任务调度、内存管理、文件系统、设备驱动程序等，还会运行一定数量的系统服务（如刷新磁盘缓冲区、日志记录器、定时任务、ssh 服务器、时间同步服务），这些东西都会消耗系统资源（主要是内存），而且虚拟机和虚拟机管理器的两层任务调度、设备驱动等也会增加时间开销。能不能让虚拟机共享操作系统内核，又保持一定的隔离性呢？</p>
<p><img alt data-src="https://ring0.me/images/2014/12/30cc029394b7687320fbca8c654b7671.png"></p>
<p>chroot 的文件系统隔离给我们带来部分的思路，但是要成为一个真正的虚拟化解决方案，只有文件系统隔离是不够的。另外两个重要的方面是：</p>
<ul>
<li>进程、网络、IPC（进程间通信）、用户等<strong>命名空间的隔离</strong>。使得虚拟机内部只能看到自己的进程，只能使用自己的虚拟网卡，进程间通信时不会干扰到虚拟机外面，虚拟机内的 UID/GID 与外面的独立。</li>
<li>资源的限制和审计。不能因为虚拟机内的程序 “跑飞了”，就占掉物理机器的所有 CPU、内存、硬盘等资源。必须要能统计虚拟机占了多少资源，并能够对资源进行限制。</li>
</ul>
<p>上述两件事情就是 BSD 和 Linux 社区在进入 21 世纪以来逐步在做的。在 Linux 中，命名空间的隔离叫做用户命名空间，在创建进程时，通过指定 clone 系统调用的参数来创建新的命名空间；资源的限制和审计是 cgroups 做的，它的 API 位于 proc 虚拟文件系统中。</p>
<p>这种虚拟机里运行一个或多个进程、虚拟机与主机共享一个内核的虚拟化方案，被称为 <strong>操作系统级虚拟化</strong> 或 <strong>任务级虚拟化</strong>。由于 Linux Containers（LXC）从 Linux 3.8 版本开始被纳入内核主线，操作系统级虚拟化又被称为 “容器”（container）。为了与虚拟机是一个完整的操作系统的虚拟化方案相区分，被隔离执行的进程（进程组）往往不称为 “虚拟机”，而称为 “容器”。由于没有多余的一层操作系统内核，容器比虚拟机更加轻量，启动更快，内存开销、调度开销也更小，更重要的是访问磁盘等 I/O 设备不需要经过虚拟化层，没有性能损失。</p>
<h3 id="云计算操作系统-OpenStack"><a href="#云计算操作系统-OpenStack" class="headerlink" title="云计算操作系统 OpenStack"></a>云计算操作系统 OpenStack</h3><p>2010 年 7 月，NASA 和 Rackspace 联合发起了 OpenStack 云操作系统开源项目。</p>
<p>OpenStack 要对云上的各种资源进行虚拟化：</p>
<ul>
<li><strong>计算</strong>：OpenStack 可以使用多种多样的虚拟化解决方案，如 Xen、KVM、QEMU、Docker。管理组件 Nova 根据各物理节点的负载决定把虚拟机调度到哪台物理机，再调用这些虚拟化解决方案的 API 来创建、删除、开机、关机等。</li>
<li><strong>存储</strong>：虚拟机镜像如果只能存储在计算节点本地，那么不仅不利于数据的冗余，也不利于虚拟机的迁移。因此在云中，一般采用逻辑上集中、物理上分布式的存储系统，独立于计算节点，也就是计算节点对数据磁盘的访问一般是通过网络访问。</li>
<li><strong>网络</strong>：每个客户要有自己的虚拟网络，如何让不同客户的虚拟网络在物理网络上互不干扰，就是网络虚拟化的事情。</li>
</ul>
<p>除了最核心的虚拟化管理器 Nova，OpenStack 还有虚拟机镜像管理器 Glance、对象存储 Swift、块存储 Cinder、虚拟网络 Neutron、身份认证服务 Keystone、控制面板 Horizon 等众多组件。</p>
<p><img alt="OpenStack Architecture" data-src="https://docs.openstack.org/install-guide/_images/openstack_kilo_conceptual_arch.png"></p>
<h3 id="容器的好管家-Docker"><a href="#容器的好管家-Docker" class="headerlink" title="容器的好管家 Docker"></a>容器的好管家 Docker</h3><p><strong>2014 年 6 月</strong>，Docker 基于 LXC 发布了第一个正式版本 v1.0。</p>
<p>Docker 是为系统运维而生，它大大降低了软件安装、部署的成本。软件的安装之所以是个麻烦事，是因为</p>
<ul>
<li><p><strong>软件之间存在依赖关系</strong>。比如，Linux 上依赖标准 C 库 glibc，依赖密码学库 OpenSSL，依赖 Java 运行环境；Windows 上依赖 .NET Framework，依赖 Flash 播放器。如果每个软件都带上它所有的依赖，那就太臃肿了，如何找到并安装软件的依赖，是一门大学问，也是各个 Linux 发行版的特色所在。</p>
</li>
<li><p><strong>软件之间存在冲突</strong>。比如，程序 A 依赖 glibc 2.13，而程序 B 依赖 glibc 2.14；甲脚本需要 Python 3，乙脚本需要 Python 2；Apache 和 Nginx 两个 Web 服务器都想要监听 80 端口。互相冲突的软件安装在同一个系统里，总是容易带来一些混乱，比如 Windows 早期的 DLL Hell。解决软件冲突之道就是隔离，让多个版本在系统里共存，并提供方法来找到匹配的版本。</p>
</li>
</ul>
<p>我们看看 Docker 如何解决这两个问题：</p>
<ol>
<li>把软件的所有依赖关系和运行环境打包在一个镜像里，而不是使用复杂的脚本来在未知的环境里 “安装” 软件；</li>
<li><p>这个包含了所有依赖的包一定很大，因此 Docker 的镜像是层次化的，即应用程序的镜像一般是基于基本系统镜像，只需要传输和存储增量部分就行了，这依赖于Linux 的 AUFS（Another Union File System）。<br><img alt data-src="https://ring0.me/images/2014/12/f584cb21ff9e39a0164bfc6e7b54900a.png"></p>
</li>
<li><p>Docker 使用基于容器的虚拟化，把每个软件运行在独立的容器里，避免了不同软件的文件系统路径冲突和运行时的资源冲突。<br><img alt data-src="https://ring0.me/images/2014/12/bd0b38dbee5e3dd50e89367a440fc6bf.png"></p>
</li>
</ol>
<p>Docker 最开始基于 LXC 实现，后来则是基于 libcontainer。libcontainer 和 LXC 事实上都是基于 Linux 内核提供的 cgroups 资源审计、chroot 文件系统隔离、命名空间隔离等机制。</p>
<h3 id="云原生时代-Kubernetes"><a href="#云原生时代-Kubernetes" class="headerlink" title="云原生时代 Kubernetes"></a>云原生时代 Kubernetes</h3><p><strong>2015 年 7 月 21 日</strong>：Kubernetes v1.0 发布！进入云原生时代。</p>
<p><img alt="Kubernetes Architecture" data-src="https://platform9.com/wp-content/uploads/2019/05/kubernetes-constructs-concepts-architecture.jpg"></p>
<hr>
<p>实际上，上述从二十世纪四十年代以来的发展历程，主要说的是计算虚拟化的事情，也就是 CPU 虚拟化。CPU 虚拟化固然是核心中的核心，但是计算机其他组件的虚拟化也不容忽视，比如内存的虚拟化，包括存储、网络等在内的 I/O 虚拟化。</p>
<h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><h3 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h3><p>前面讲虚拟化的鼻祖 IBM M44/44X 的时候，提到它提出了 “分页” 的概念。也就是每个任务（虚拟机）似乎独占所有内存空间，分页机制负责把不同任务的内存地址映射到物理内存。如果物理内存不够了，操作系统就会把不常用的任务的内存交换到磁盘之类的外部存储，等那个不常用任务需要执行时再加载回来（当然，这种机制是后来才发明的）。这样，程序的开发者就不需要考虑物理内存空间有多大，也不需要考虑不同任务的内存地址是否会冲突。</p>
<p>现在我们用的计算机都有分页机制，应用程序（用户态进程）看到的是一片广阔无涯的虚拟内存（Virtual Memory），似乎整台机器都被自己独占；操作系统负责设置用户态进程的虚拟内存到物理内存的映射关系；CPU 中的 MMU（Memory Management Unit）负责在用户态程序运行时，通过查询映射关系（所谓的页表），把指令中的虚拟地址翻译成物理地址。</p>
<p><img alt data-src="https://images2018.cnblogs.com/blog/431521/201712/431521-20171203180443851-1606756853.png"></p>
<p>这里要说的不是这种虚拟内存，而是<strong>基于虚拟机的内存虚拟化</strong>，它们本质上是一样的，通过对虚拟内存的理解，再去理解内存虚拟化就比较容易了。</p>
<p>内存虚拟化也分为<strong>基于软件的内存虚拟化</strong>和<strong>硬件辅助的内存虚拟化</strong>，其中，常用的基于软件的内存虚拟化技术为<strong>「影子页表」</strong>技术，硬件辅助内存虚拟化技术为 Intel 的 <strong>EPT（Extended Page Table，扩展页表）</strong>技术。</p>
<h3 id="Shadow-Page-Table"><a href="#Shadow-Page-Table" class="headerlink" title="Shadow Page Table"></a>Shadow Page Table</h3><p>内存软件虚拟化的目标就是要将虚拟机的虚拟地址（Guest Virtual Address, GVA）转化为 Host 的物理地址（Host Physical Address, HPA），中间要经过虚拟机的物理地址（Guest Physical Address, GPA）和 Host 虚拟地址（Host Virtual Address）的转化，即：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">GVA -&gt; GPA -&gt; HVA -&gt; HPA</span><br></pre></td></tr></table></figure>
<p>其中前两步由虚拟机的系统页表完成，中间两步由 VMM 定义的映射表（由数据结构 kvm_memory_slot 记录）完成，它可以将连续的虚拟机物理地址映射成非连续的 Host 机虚拟地址，后面两步则由 Host 机的系统页表完成。如下图所示。</p>
<p><img alt="Shadow Page Table" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-04-07_shadow-page-table.png"></p>
<p>这样做得目的有两个：</p>
<ol>
<li>提供给虚拟机一个从零开始的连续的物理内存空间。</li>
<li>在各虚拟机之间有效隔离、调度以及共享内存资源。</li>
</ol>
<p>我们可以看到，传统的内存虚拟化方式，虚拟机的每次内存访问都需要 VMM 介入，并由软件进行多次地址转换，其效率是非常低的。因此才有了影子页表技术和 EPT 技术。</p>
<p><strong>影子页表简化了地址转换的过程，实现了 Guest 虚拟地址空间到 Host 物理地址空间的直接映射。</strong></p>
<p>要实现这样的映射，必须为 Guest 的系统页表设计一套对应的影子页表，然后将影子页表装入 Host 的 MMU 中，这样当 Guest 访问 Host 内存时，就可以根据 MMU 中的影子页表映射关系，完成 GVA 到 HPA 的直接映射。而维护这套影子页表的工作则由 VMM 来完成。</p>
<p>由于 Guest 中的每个进程都有自己的虚拟地址空间，这就意味着 VMM 要为 Guest 中的每个进程页表都维护一套对应的影子页表，当 Guest 进程访问内存时，才将该进程的影子页表装入 Host 的 MMU 中，完成地址转换。</p>
<p>我们也看到，这种方式虽然减少了地址转换的次数，但本质上还是纯软件实现的，效率还是不高，而且 VMM 承担了太多影子页表的维护工作，设计不好。</p>
<p>为了改善这个问题，就提出了基于硬件的内存虚拟化方式，将这些繁琐的工作都交给硬件来完成，从而大大提高了效率。</p>
<h3 id="Extended-Page-Table"><a href="#Extended-Page-Table" class="headerlink" title="Extended Page Table"></a>Extended Page Table</h3><p>下图是 EPT 的基本原理图示，EPT 在原有 CR3 页表地址映射的基础上，引入了 EPT 页表来实现另一层映射，这样，GVA-&gt;GPA-&gt;HPA 的两次地址转换都由硬件来完成。</p>
<p><img alt="Extended Page Table" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-04-07_ept.png"></p>
<p>这里举一个小例子来说明整个地址转换的过程。假设现在 Guest 中某个进程需要访问内存，CPU 首先会访问 Guest 中的 CR3 页表来完成 GVA 到 GPA 的转换，如果 GPA 不为空，则 CPU 接着通过 EPT 页表来实现 GPA 到 HPA 的转换（实际上，CPU 会首先查看硬件 EPT TLB 或者缓存，如果没有对应的转换，才会进一步查看 EPT 页表），如果 HPA 为空呢，则 CPU 会抛出 EPT Violation 异常由 VMM 来处理。</p>
<p>如果 GPA 地址为空，即缺页，则 CPU 产生缺页异常，注意，这里，如果是软件实现的方式，则会产生 VM-exit，但是硬件实现方式，并不会发生 VM-exit，而是按照一般的缺页中断处理，这种情况下，也就是交给 Guest 内核的中断处理程序处理。</p>
<p>在中断处理程序中会产生 EXIT_REASON_EPT_VIOLATION，Guest 退出，VMM 截获到该异常后，分配物理地址并建立 GVA 到 HPA 的映射，并保存到 EPT 中，这样在下次访问的时候就可以完成从 GVA 到 HPA 的转换了。</p>
<p>有人也许会担心增加的一级映射关系会减慢内存访问速度，事实上不论是否启用二级内存翻译（SLAT），页表高速缓存（Translation Lookaside Buffer，TLB）都会存储虚拟地址（VA）到机器地址（MA）的映射。如果 TLB 的命中率较高，则增加的一级内存翻译不会显著影响内存访问性能。</p>
<p><img alt data-src="https://ring0.me/images/2014/12/a45258f97f500142bfcff56770ba2106.png"></p>
<h2 id="I-O-虚拟化"><a href="#I-O-虚拟化" class="headerlink" title="I/O 虚拟化"></a>I/O 虚拟化</h2><p>首先我们来回顾一下 I/O 模型：</p>
<p><img alt="Interactions With I/O Devices" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-04-07_interaction-with-io-devices.png"> </p>
<h3 id="Emulation"><a href="#Emulation" class="headerlink" title="Emulation"></a>Emulation</h3><p>模拟模型是使用最为广泛的I/O设备虚拟化模型，该模型采用软件的方式模拟设备行为，为虚拟机模拟出与底层硬件完全一致的虚拟化环境，保证虚拟机操作系统的行为与非虚拟化环境下完全一致。</p>
<p>在模拟模型中，虚拟设备必须以某种方式让虚拟机可以发现，导致虚拟机被“欺骗”。当 VM 访问虚拟设备时，访问请求被 VMM 截获，然后VMM 将I/O请求交由domain0 来模拟完成，最后将结果返回给虚拟机。</p>
<p>模拟模型分为以下两类：</p>
<h4 id="Hypervisor-based-device-emulation"><a href="#Hypervisor-based-device-emulation" class="headerlink" title="Hypervisor-based device emulation"></a>Hypervisor-based device emulation</h4><p><img alt="Hypervisor-based device emulation" data-src="https://www.ibm.com/developerworks/library/l-pci-passthrough/figure1.gif"></p>
<h4 id="User-space-device-emulation"><a href="#User-space-device-emulation" class="headerlink" title="User-space device emulation"></a>User-space device emulation</h4><p><img alt="User-space device emulation" data-src="https://developer.ibm.com/developer/tutorials/l-pci-passthrough/images/figure2.gif"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文是对虚拟化概览，也是作为 <a href="../../tags/虚拟化">虚拟化技术系列</a> 的第一篇。开篇概览对整体有了基本的认识，毋庸置疑，里面涉及到的技术细节凡凡总总。掌握了大的方向，后续本系列可以继续扩展，拓展到网络虚拟化、存储虚拟化、GPU 虚拟化等等。不管细节如何，我们做的都是抽象。</p>
<p>纵观虚拟化技术的发展历史，可以看到它始终如一的目标就是实现对 IT 资源的充分利用。虚拟化本质是对 IT 资源的抽象，沿着虚拟化的道路继续发展，我们看到了云计算的开花结果，实现了更上层的对企业业务能力的抽象。抽象之外，我们也可以在这个过程中不断的看到软硬件结合与替代的思路，做一件事软件与硬件只是不同的路径，到底路该怎么走，就得看我们想到哪了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.kernelthread.com/publications/virtualization" target="_blank" rel="external nofollow noopener noreferrer">http://www.kernelthread.com/publications/virtualization</a></li>
<li><a href="https://blog.csdn.net/Jmilk/article/details/99675664" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Jmilk/article/details/99675664</a></li>
<li><a href="https://ring0.me/2014/12/virtualization-overview" target="_blank" rel="external nofollow noopener noreferrer">https://ring0.me/2014/12/virtualization-overview</a></li>
<li><a href="https://developer.ibm.com/tutorials/l-pci-passthrough" target="_blank" rel="external nofollow noopener noreferrer">https://developer.ibm.com/tutorials/l-pci-passthrough</a></li>
<li><a href="https://developer.ibm.com/technologies/linux/articles/l-virtio" target="_blank" rel="external nofollow noopener noreferrer">https://developer.ibm.com/technologies/linux/articles/l-virtio</a></li>
<li><a href="https://developer.ibm.com/tutorials/l-hypervisor" target="_blank" rel="external nofollow noopener noreferrer">https://developer.ibm.com/tutorials/l-hypervisor</a></li>
<li><a href="https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/io_virtualization.pdf" target="_blank" rel="external nofollow noopener noreferrer">https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/io_virtualization.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>hypervisor</tag>
        <tag>VMM</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>政治坐标系</title>
    <url>/posts/125bc0e5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>

<p>「政治坐标系」的概念来源于著名的<code>political compass</code>，用于表明一个人的政治倾向。这里是我的政治坐标测试，其中「中国政治坐标测试」最早是 2007 年北大未名 BBS 的同学们讨论制作的，并在后期根据中国实际情况进行了订正和修改，在 <a href="http://www.zuobiao.me/zuobiao2015/index.php/66331?lang=zh-Hans" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 可以看到目前的版本。令我感到惊讶的是，居然在这个<a href="https://bbs.pku.edu.cn/v2/post-read-single.php?bid=1004&amp;type=3&amp;postid=5656284" target="_blank" rel="external nofollow noopener noreferrer">帖子</a>下面看到了<a href="http://blog.farmostwood.net/" target="_blank" rel="external nofollow noopener noreferrer">木遥</a>的踪迹，世界真小。</p>
<blockquote>
<p>需要强调说明的是，<strong>这个测试初始并且唯一的目标在于给使用者提供一个自我思考和认同的提示器。</strong></p>
<p>「公共政治议题讨论的阙失和长期的无限夸大式的政治宣传方式，使得很多人几乎是凭着脑海中浮现的口号来作出自己的选择，而完全不曾在理性上真正确认过自己的立场。」这是我对现实的悲观理解。这个问卷如此流行，足以反过来说明政治观点的分歧和相关观点在意识层面上（而非政策层面上）的讨论和争锋如何构成了公众生活的禁忌。网上关于这个测试的很多评论都反映出<strong>很多人并不习惯于拥有自己的观点，更不用说是在如此广泛的层面上。我相信这并非出自天性，而只是长期的怠惰使然。</strong></p>
</blockquote>
<p>与此同时，我也附上了来自英文「<a href="https://www.politicalcompass.org/test" target="_blank" rel="external nofollow noopener noreferrer">政治指南针</a>」网站的西方政治坐标测试，这份测试系统建立于西方政治价值体系基础之上，<strong>某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。</strong> 不管怎样，倒也可以提供一个自我思考的提示器。</p>
<a id="more"></a>
<p><img alt="Political Compass" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Political_chart.svg/941px-Political_chart.svg.png"></p>
<h2 id="中国政治坐标"><a href="#中国政治坐标" class="headerlink" title="中国政治坐标"></a>中国政治坐标</h2><h3 id="测试试题"><a href="#测试试题" class="headerlink" title="测试试题"></a>测试试题</h3><p>整个测试有 50 道题，分别从政治、经济、文化三个方面界定。这里列出了我在今天的选择，具体打分可到原网页进行测试。</p>
<p><form id="chinese-questions">
    <ol>
        <li>如果人民没有受过民主教育，他们是不应该拥有普选权的。<br><input name="c1" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c1" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c1" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c1" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>人权高于主权。<br><input name="c2" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c2" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c2" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c2" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
        <li>西方的多党制不适合中国国情。<br><input name="c3" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c3" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c3" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c3" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>由高校自主考试招生比全国统一考试招生更好。<br><input name="c4" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c4" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c4" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c4" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
        <li>在中国照搬西方式的言论自由会导致社会失序。<br><input name="c5" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c5" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c5" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c5" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>应该容许宗教人士在非宗教场所公开传教。<br><input name="c6" type="radio" data-x="-2" data-y="0" data-z="0" checked>强烈反对<br><input name="c6" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c6" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c6" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
        <li>无论中小学生或大学生，都应参加由国家统一安排的军训。<br><input name="c7" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c7" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c7" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c7" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>国家的统一和领土完整是社会的最高利益。<br><input name="c8" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c8" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c8" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c8" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>国家没有义务进行对外援助。<br><input name="c9" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c9" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c9" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c9" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
        <li>哪怕经历了违反程序规定的审讯和取证过程，确实有罪的罪犯也应被处以死刑。<br><input name="c10" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c10" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c10" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c10" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>国家领导人及开国领袖的形象可以作为文艺作品的丑化对象。<br><input name="c11" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c11" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c11" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c11" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
        <li>当法律未能充分制止罪恶行为时，通过极端手段对犯罪进行制裁是可以容忍的。<br><input name="c12" type="radio" data-x="2" data-y="0" data-z="0" checked>强烈反对<br><input name="c12" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c12" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c12" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>应当允许媒体代表某一特定阶层或利益集团发言。<br><input name="c13" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c13" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c13" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c13" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>如果国家综合实力许可，那么中国有权为了维护自己的利益而采取任何行动。<br><input name="c14" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c14" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c14" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c14" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>条件允许的话应该武力统一台湾。<br><input name="c15" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c15" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c15" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c15" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>国家应当采取措施培养和支持体育健儿在各种国际比赛场合为国争光。<br><input name="c16" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c16" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c16" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c16" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>律师即使明知被辩护人的犯罪事实也应当尽力为其进行辩护。<br><input name="c17" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c17" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c17" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c17" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>以美国为首的西方国家不可能真正容许中国崛起成为一流强国。<br><input name="c18" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c18" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c18" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c18" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>
        <li>两个成年人之间自愿的性行为是其自由，无论其婚姻关系为何。<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>
        <li>不应当公开谈论自己的长辈的缺点。<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="-1" checked>同意<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>
        <li>现代中国社会需要儒家思想。<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="-1" checked>同意<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>
        <li>判断艺术作品的价值的根本标准是看是不是受到人民大众喜爱。<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="-1" checked>反对<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="1">同意<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>
        <li>即使有人口压力，国家和社会也无权干涉个人要不要孩子，要几个孩子。<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>
        <li>周易八卦能够有效的解释很多事情。<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="2" checked>强烈反对<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>
        <li>中国传统医学对人体健康的观念比现代主流医学更高明。<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="1" checked>反对<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>
        <li>汉字无需人为推行简化。<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="1" checked>反对<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>
        <li>应当将中国传统文化的经典作品作为儿童基础教育读物。<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="2" checked>强烈反对<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>
        <li>如果是出于自愿，我会认可我的孩子和同性结成伴侣关系。<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>
        <li>最低工资应由国家规定。<br><input name="c29" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c29" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c29" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c29" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>中国改革开放以来经济发展的成果很多都被一小群人占有了，大多数人没得到什么好处。<br><input name="c30" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈反对<br><input name="c30" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c30" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c30" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>在重大工程项目的决策中，个人利益应该为社会利益让路。<br><input name="c31" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c31" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c31" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c31" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>浪费粮食也是个人的自由。<br><input name="c32" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c32" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c32" type="radio" data-x="0" data-y="1" data-z="0" checked>同意<br><input name="c32" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>
        <li>如果猪肉价格过高，政府应当干预。<br><input name="c33" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c33" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c33" type="radio" data-x="0" data-y="1" data-z="0" checked>同意<br><input name="c33" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>
        <li>应当对国外同类产品征收高额关税来保护国内民族工业。<br><input name="c34" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c34" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c34" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c34" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>国有企业的利益属于国家利益。<br><input name="c35" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c35" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c35" type="radio" data-x="0" data-y="1" data-z="0">同意<br><input name="c35" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈同意<br></li>
        <li>试图控制房地产价格会破坏经济发展。<br><input name="c36" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c36" type="radio" data-x="0" data-y="-1" data-z="0" checked>反对<br><input name="c36" type="radio" data-x="0" data-y="1" data-z="0">同意<br><input name="c36" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>
        <li>教育应当尽可能公立。<br><input name="c37" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c37" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c37" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c37" type="radio" data-x="0" data-y="-2" data-z="0" checked>强烈同意<br></li>
        <li>改善低收入者生活的首要手段是国家给予财政补贴和扶持。<br><input name="c38" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c38" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c38" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c38" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>有钱人理应获得更好的医疗服务。<br><input name="c39" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c39" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c39" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c39" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>高收入者应该公开自己的经济来源。<br><input name="c40" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c40" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c40" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c40" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>与其让国有企业亏损破产，不如转卖给资本家。<br><input name="c41" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c41" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c41" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c41" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>那些关系到国家安全、以及其他重要国计民生的领域，必须全部由国有企业掌控。<br><input name="c42" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c42" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c42" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c42" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>市场竞争中自然形成的垄断地位是无害的。<br><input name="c43" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c43" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c43" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c43" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>资本积累的过程总是伴随着对普通劳动人民利益的伤害。<br><input name="c44" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c44" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c44" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c44" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>应该允许中国公民同时具有外国国籍。<br><input name="c45" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c45" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c45" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c45" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
        <li>政府应当提高粮食收购价格以增加农民收入。<br><input name="c46" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c46" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c46" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c46" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>为保障社会公平，对富人征税应采用更高的税率。<br><input name="c47" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈反对<br><input name="c47" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c47" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c47" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>在华外国资本应享受和民族资本同样的待遇。<br><input name="c48" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c48" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c48" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c48" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>私人应当可以拥有和买卖土地。<br><input name="c49" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c49" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c49" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c49" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>
        <li>发生重大社会安全事件时，即使认为信息公开会导致骚乱的风险，政府仍应该开放信息传播。<br><input name="c50" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c50" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c50" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c50" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>
    </ol>
</form><br><div class="note info">
            <ul><li>政治观念坐标，负值为左，即威权主义 (Authoritarianism)，正值为右，即自由主义 (Libertarianism)。</li><li>社会文化观念坐标，负值为保守与复古派 (Conservatism)，正值为自由与激进派 (Liberalism)。</li><li>经济观念坐标，负值为左，即集体主义与福利主义 (Welfarism, Collectivism)，正值为右，即新自由主义(Neoliberalism)。</li></ul><p>三个维度的最大区间均为 [-2,2]。</p><p>本测试系统建立于中国政治价值体系基础之上，试图充分反映中国的特殊国情与政治文化。请注意，很多问题反映的是中国现实语境中的「左与右」，而非严格意义上的西方政治语汇中的「左与右」。</p>
          </div></p>
<h3 id="测试反思"><a href="#测试反思" class="headerlink" title="测试反思"></a>测试反思</h3><p>整个测试做完，我的得分如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">政治立场坐标: <span class="number">0.4</span></span><br><span class="line">文化立场坐标: <span class="number">0.6</span></span><br><span class="line">经济立场坐标: <span class="number">-0.3</span></span><br></pre></td></tr></table></figure>
<p>什么意思呢？也就是说，我政治观念偏自由主义，社会文化观念偏自由主义，经济观念偏集体主义。这个测试结果和我在 <a href="https://www.idrlabs.com/" target="_blank" rel="external nofollow noopener noreferrer">IDRlabs</a>上面的<a href="https://www.idrlabs.com/cn/political-coordinates/test.php" target="_blank" rel="external nofollow noopener noreferrer">政治观点测试</a>大体类似，整体上政治文化偏自由，但是很明显经济方面自己的不确定性太大，整体上属于温和中间派。</p>
<p><img alt="IDRlabs Political Coordinate" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-04-09_political-compass.png"></p>
<p>倒也不是说通过这个测试就对我的左右进行了划分，把我划分成左派或右派。左右意识形态的纠葛在过去一百多年给人类社会带来撕扯与分裂，以至于对于左和右的定义国内国外都不太一样。一直以来，我的观点就是搁置意识形态上的争论，踏踏实实的讨论实际问题。但是搁置争论并不等于没有自己的观点，并不等于不去思考这些问题，而这个测试恰恰提供了这样的机会。</p>
<p>关于这五十个问题，做的时候有的并不是百分百的确定，很多问题涉及到经济问题。经济基础决定上层建筑，经济问题是可以用数学来解释的，过段时间等对于经济问题有了更多的理解后，再来做这个测试，或许答案又不一样了。</p>
<ul>
<li>人权与主权。教科书告诉我们主权高于人权，真的是这样吗？</li>
<li>真的应该公开所有的信息吗？一直以来我认为公开信息是能够促进事情更加透明的，现在我有些犹豫。</li>
<li>关注自主招生，应该认识到，自主招生确实是招到优秀同学的一种重要方式。但是我们也会看到这里面有很多不公平的现象产生，我选择公平。</li>
<li>国家的统一和领土完整真的是社会的最高利益吗？人民的幸福不才应该是吗？犹豫。</li>
<li>国家真的没有义务对外援助吗？大国责任呢？犹豫。</li>
<li>有罪的罪犯，取证不规范，这是程序正义的问题。现在是坚决反对的，即使他确实有问题，我们取证不规范，那和他又有什么区别呢？</li>
<li>国家领导人和开国领袖可以作为丑化对象吗？不能，原因说不清楚，觉得这样不好。</li>
<li>媒体不应该是尽量公正客观的吗？所以直觉认为媒体当然不应该为某一特定利益集团发言，又一转念，这不正是当下的显示吗？哪家媒体不是代表的某些人的利益的呢？</li>
<li>国籍问题是知识盲区，这个不是很懂，到底双重国籍有什么具体的影响。 </li>
<li>武统台湾，我们已经有条件了，但是这是我们最不愿意看到的，难道就没有别的办法吗，中国人这么聪明。 </li>
<li>现代社会需要儒家思想，当然是需要，但是看是那部分，君君臣臣那套还是算了。</li>
<li>判断艺术作品的价值真的是是否受到人民大众喜欢吗？不一定吧。</li>
<li>关于最低工资，这点并不太懂其背后的经济学原理。</li>
<li>个人利益应当为社会利益让路吗？犹豫。</li>
<li>粮食浪费也是个人自由吗？自由应该如何界定？</li>
<li>猪肉价格过高，政府应该干预吗？经济学上怎么说？</li>
<li>应该试图控制房地产吗？经济学上怎么说？</li>
<li>教育应该完全公立吗？从我的角度来说，我是赞成的。</li>
<li>有钱人应该公开自己的收入来源吗？直观感受是应该的。</li>
<li>涉及到国计民生的领域，真的都应该由国企掌控吗？</li>
<li>资本积累的过程看起来确实都伴随着对普通劳动人民利益的伤害。</li>
<li>政府应该高价格收购粮食吗？</li>
<li>私人应该可以自由买卖土地吗？是否会再次出现土地兼并的问题？ </li>
</ul>
<h2 id="西方政治坐标"><a href="#西方政治坐标" class="headerlink" title="西方政治坐标"></a>西方政治坐标</h2><h3 id="测试试题-1"><a href="#测试试题-1" class="headerlink" title="测试试题"></a>测试试题</h3><p>下面是我的测试结果，经济上偏自由，政治上偏自由。</p>
<p><form id="western-questions">
    <p><strong>第一部分</strong>：你如何看待国家与世界。</p>
    <ol>
        <li>如果全球化无法避免，应该首先为人服务而不是跨国公司的利益。<br><input name="c1" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c1" type="radio" data-x="0.25" data-y="0">反对<br><input name="c1" type="radio" data-x="-0.375" data-y="0" checked>同意<br><input name="c1" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>
        <li>我会一直支持我的国家，无论它是对是错。<br><input name="c2" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c2" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c2" type="radio" data-x="0" data-y="0.15">同意<br><input name="c2" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>没有人可以选择祖国，因此为祖国自豪很愚蠢。<br><input name="c3" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c3" type="radio" data-x="0" data-y="0.13" checked>反对<br><input name="c3" type="radio" data-x="0" data-y="-0.13">同意<br><input name="c3" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>我的种族和其他种族相比有很多出众的优点。<br><input name="c4" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c4" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c4" type="radio" data-x="0" data-y="0.13">同意<br><input name="c4" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>敌人的敌人是朋友。<br><input name="c5" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c5" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c5" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c5" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>违反国际法的军事行动有时候是正当的。<br><input name="c6" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c6" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c6" type="radio" data-x="0" data-y="0.11">同意<br><input name="c6" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
        <li>现在信息和娱乐已经令人忧虑的交融在一起。<br><input name="c7" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c7" type="radio" data-x="0" data-y="0.13">反对<br><input name="c7" type="radio" data-x="0" data-y="-0.13">同意<br><input name="c7" type="radio" data-x="0" data-y="-0.23" checked>强烈同意<br></li>
    </ol>
    <p><strong>第二部分</strong>：经济问题。</p>
    <ol>
        <li>人民根本上说是通过阶级而不是国籍来区分的。<br><input name="c8" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c8" type="radio" data-x="0.25" data-y="0">反对<br><input name="c8" type="radio" data-x="-0.375" data-y="0" checked>同意<br><input name="c8" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>
        <li>控制通货膨胀比控制失业要重要。<br><input name="c9" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c9" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c9" type="radio" data-x="0.375" data-y="0">同意<br><input name="c9" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>
        <li>因为无法信任企业能够自觉保护环境，因此需要规章来规范它们。<br><input name="c10" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c10" type="radio" data-x="0.25" data-y="0">反对<br><input name="c10" type="radio" data-x="-0.25" data-y="0">同意<br><input name="c10" type="radio" data-x="-0.5" data-y="0" checked>强烈同意<br></li>
        <li>“各尽所能，各取所需”从根本上说是个好的想法。<br><input name="c11" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c11" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c11" type="radio" data-x="-0.375" data-y="0">同意<br><input name="c11" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>
        <li>令人沮丧的是在我们的社会中一些最基本的事物比如饮用水现在都成为了瓶装、注明商标的商品。<br><input name="c12" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c12" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c12" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c12" type="radio" data-x="-0.75" data-y="0">强烈同意<br></li>
        <li>土地不应当被作为商品买卖。<br><input name="c13" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c13" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c13" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c13" type="radio" data-x="-0.75" data-y="0">强烈同意<br></li>
        <li>靠运作资金赚钱的人对社会的贡献比不上靠劳动赚钱的人。<br><input name="c14" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c14" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c14" type="radio" data-x="-0.375" data-y="0">同意<br><input name="c14" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>
        <li>保护主义对贸易来说有时候是必须的。<br><input name="c15" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c15" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c15" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c15" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>
        <li>公司为它的股东赚取利润就是它仅有的社会职责。<br><input name="c16" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c16" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c16" type="radio" data-x="0.375" data-y="0">同意<br><input name="c16" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>
        <li>对富人征的税太高了。<br><input name="c17" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c17" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c17" type="radio" data-x="0.375" data-y="0">同意<br><input name="c17" type="radio" data-x="0.5" data-y="0">强烈同意<br></li>
        <li>那些付得起钱的人应该有权获得更好的医疗服务。<br><input name="c18" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c18" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c18" type="radio" data-x="0.25" data-y="0">同意<br><input name="c18" type="radio" data-x="0.5" data-y="0">强烈同意<br></li>
        <li>政府应该惩罚误导公众的商业行为。<br><input name="c19" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c19" type="radio" data-x="0.25" data-y="0">反对<br><input name="c19" type="radio" data-x="-0.25" data-y="0">同意<br><input name="c19" type="radio" data-x="-0.375" data-y="0" checked>强烈同意<br></li>
        <li>一个真正的自由市场需要对跨国大公司的垄断进行限制。<br><input name="c20" type="radio" data-x="0" data-y="0">强烈反对<br><input name="c20" type="radio" data-x="0" data-y="0">反对<br><input name="c20" type="radio" data-x="0" data-y="0">同意<br><input name="c20" type="radio" data-x="0" data-y="0" checked>强烈同意<br></li>
        <li>市场越自由，人民越自由。<br><input name="c21" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c21" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c21" type="radio" data-x="0.5" data-y="0">同意<br><input name="c21" type="radio" data-x="0.75" data-y="0">强烈同意<br></li>
    </ol>
    <p><strong>第三部分</strong>：社会价值观。</p>
    <ol>
        <li>除非妇女的生命受到危及，否则总应该禁止堕胎。<br><input name="c22" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c22" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c22" type="radio" data-x="0" data-y="0.11">同意<br><input name="c22" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
        <li>一切当权者都应该受到质询。<br><input name="c23" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c23" type="radio" data-x="0" data-y="0.175">反对<br><input name="c23" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c23" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>以眼还眼，以牙还牙。<br><input name="c24" type="radio" data-x="0" data-y="-0.18">强烈反对<br><input name="c24" type="radio" data-x="0" data-y="-0.125" checked>反对<br><input name="c24" type="radio" data-x="0" data-y="0.08">同意<br><input name="c24" type="radio" data-x="0" data-y="0.18">强烈同意<br></li>
        <li>税收不应该支持那些没法靠商业手段活下去的剧院和博物馆。<br><input name="c25" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c25" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c25" type="radio" data-x="0.5" data-y="0">同意<br><input name="c25" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>
        <li>学校不应该强制学生签到。<br><input name="c26" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c26" type="radio" data-x="0" data-y="0.055">反对<br><input name="c26" type="radio" data-x="0" data-y="-0.15" checked>同意<br><input name="c26" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>
        <li>所有人都有自己的权利，但让不同类型的人保持自己的个性对每个人来说都更好。<br><input name="c27" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c27" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c27" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c27" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>好父母有时候也不得不打孩子。<br><input name="c28" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c28" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c28" type="radio" data-x="0" data-y="0.1" checked>同意<br><input name="c28" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>孩子对父母有秘密很正常。<br><input name="c29" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c29" type="radio" data-x="0" data-y="0.13">反对<br><input name="c29" type="radio" data-x="0" data-y="-0.08" checked>同意<br><input name="c29" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>大麻应该合法。<br><input name="c30" type="radio" data-x="0" data-y="0.2">强烈反对<br><input name="c30" type="radio" data-x="0" data-y="0.045" checked>反对<br><input name="c30" type="radio" data-x="0" data-y="-0.11">同意<br><input name="c30" type="radio" data-x="0" data-y="-0.21">强烈同意<br></li>
        <li>学校的首要职能是让下一代人能找到工作。<br><input name="c31" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c31" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c31" type="radio" data-x="0" data-y="0.1">同意<br><input name="c31" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>应当不允许有严重遗传疾病的残疾人生育。<br><input name="c32" type="radio" data-x="0" data-y="-0.29">强烈反对<br><input name="c32" type="radio" data-x="0" data-y="-0.185">反对<br><input name="c32" type="radio" data-x="0" data-y="0.17" checked>同意<br><input name="c32" type="radio" data-x="0" data-y="0.275">强烈同意<br></li>
        <li>孩子最重要的事是学会遵守纪律。<br><input name="c33" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c33" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c33" type="radio" data-x="0" data-y="0.15">同意<br><input name="c33" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>没有野蛮人和文明人，只有不同的文化。<br><input name="c34" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c34" type="radio" data-x="0" data-y="0.175">反对<br><input name="c34" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c34" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>那些有能力工作却拒绝工作机会的人，不应该接受社会的资助。<br><input name="c35" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c35" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c35" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c35" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>当你遇到困难时，最好不要去想它，而是不断地做令人高兴的事。<br><input name="c36" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c36" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c36" type="radio" data-x="0" data-y="0.11">同意<br><input name="c36" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
        <li>第一代移民永远无法完全融入他们的新国家。<br><input name="c37" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c37" type="radio" data-x="0" data-y="-0.075">反对<br><input name="c37" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c37" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>有利于最成功的企业的事物，最终也总是有利于我们大家的。<br><input name="c38" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c38" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c38" type="radio" data-x="0.75" data-y="0">同意<br><input name="c38" type="radio" data-x="0.875" data-y="0">强烈同意<br></li>
        <li>任何广播电视机构，无论它的内容有多独立，都不应该接受公共资金的支持。<br><input name="c39" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c39" type="radio" data-x="-0.375" data-y="0" checked>反对<br><input name="c39" type="radio" data-x="0.125" data-y="0">同意<br><input name="c39" type="radio" data-x="0.25" data-y="0">强烈同意<br></li>
    </ol>
    <p><strong>第四部分</strong>：你如何看待更广阔的社会。</p>
    <p></p>
    <ol>
        <li>在反恐的名义下，公民自由被过度限制了。<br><input name="c40" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c40" type="radio" data-x="0" data-y="0.155" checked>反对<br><input name="c40" type="radio" data-x="0" data-y="-0.1">同意<br><input name="c40" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>
        <li>一党制国家的一个显著优点是它避免了在民主政体中耽误发展的所有那些争论。<br><input name="c41" type="radio" data-x="0" data-y="-0.29">强烈反对<br><input name="c41" type="radio" data-x="0" data-y="-0.135">反对<br><input name="c41" type="radio" data-x="0" data-y="0.17" checked>同意<br><input name="c41" type="radio" data-x="0" data-y="0.275">强烈同意<br></li>
        <li>尽管在电子时代官方的监听更容易了，但只有坏人才需要对此担忧。<br><input name="c42" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c42" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c42" type="radio" data-x="0" data-y="0.15" checked>同意<br><input name="c42" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>对罪大恶极的犯罪分子，死刑不失为一种选项。<br><input name="c43" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c43" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c43" type="radio" data-x="0" data-y="0.15" checked>同意<br><input name="c43" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>在一个文明社会，一个人必须遵从上级、命令下级。<br><input name="c44" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c44" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c44" type="radio" data-x="0" data-y="0.11">同意<br><input name="c44" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
        <li>那些什么也没有表达的抽象艺术根本就不应该被称为艺术。<br><input name="c45" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c45" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c45" type="radio" data-x="0" data-y="0.15">同意<br><input name="c45" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>在刑事审判中，惩罚比改造更重要。<br><input name="c46" type="radio" data-x="0" data-y="-0.23" checked>强烈反对<br><input name="c46" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c46" type="radio" data-x="0" data-y="0.13">同意<br><input name="c46" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>改造有些犯罪分子就是浪费时间。<br><input name="c47" type="radio" data-x="0" data-y="-0.26" checked>强烈反对<br><input name="c47" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c47" type="radio" data-x="0" data-y="0.15">同意<br><input name="c47" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>商人和制造业者比作家和艺术家更重要。<br><input name="c48" type="radio" data-x="0" data-y="-0.18">强烈反对<br><input name="c48" type="radio" data-x="0" data-y="-0.08" checked>反对<br><input name="c48" type="radio" data-x="0" data-y="0.08">同意<br><input name="c48" type="radio" data-x="0" data-y="0.18">强烈同意<br></li>
        <li>母亲们可以有职业，但她们的首要职责是家庭主妇。<br><input name="c49" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c49" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c49" type="radio" data-x="0" data-y="0.13">同意<br><input name="c49" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>跨国公司正在不道德地开发发展中国家的植物基因资源。<br><input name="c50" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c50" type="radio" data-x="0" data-y="0.13">反对<br><input name="c50" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c50" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>同现有体制和谐相处是成熟的重要一方面。<br><input name="c51" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c51" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c51" type="radio" data-x="0" data-y="0.11" checked>同意<br><input name="c51" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
    </ol>
    <p></p>
    <p><strong>第五部分</strong>：关于宗教。</p>
    <p></p>
    <ol>
        <li>占星术精确地解释了很多东西。<br><input name="c52" type="radio" data-x="0" data-y="-0.23" checked>强烈反对<br><input name="c52" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c52" type="radio" data-x="0" data-y="0.13">同意<br><input name="c52" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>你如果不信宗教就不可能道德。<br><input name="c53" type="radio" data-x="0" data-y="-0.2" checked>强烈反对<br><input name="c53" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c53" type="radio" data-x="0" data-y="0.11">同意<br><input name="c53" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
        <li>慈善捐助在帮助真正的弱势群体时做得比社会保障要好。<br><input name="c54" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c54" type="radio" data-x="-0.375" data-y="0" checked>反对<br><input name="c54" type="radio" data-x="0.625" data-y="0">同意<br><input name="c54" type="radio" data-x="0.75" data-y="0">强烈同意<br></li>
        <li>有些人天生不走运。<br><input name="c55" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c55" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c55" type="radio" data-x="0" data-y="0.13">同意<br><input name="c55" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>我孩子的学校向他传授宗教价值观，这点非常重要。<br><input name="c56" type="radio" data-x="0" data-y="-0.2" checked>强烈反对<br><input name="c56" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c56" type="radio" data-x="0" data-y="0.11">同意<br><input name="c56" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
    </ol>
    <p></p>
    <p><strong>第六部分</strong>：关于性。</p>
    <ol>
        <li>婚姻之外的性是不道德的。<br><input name="c57" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c57" type="radio" data-x="0" data-y="-0.175">反对<br><input name="c57" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c57" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>
        <li>一对稳定、相爱的同性伴侣，应有收养孩子的权利。<br><input name="c58" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c58" type="radio" data-x="0" data-y="0.175">反对<br><input name="c58" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c58" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>由成年人自愿演出的色情影视应该对成人合法化。<br><input name="c59" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c59" type="radio" data-x="0" data-y="0.13">反对<br><input name="c59" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c59" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>
        <li>在私人卧室里两个成年人只见不管做什么，只要是自愿的，国家就管不着。<br><input name="c60" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c60" type="radio" data-x="0" data-y="0.155">反对<br><input name="c60" type="radio" data-x="0" data-y="-0.15" checked>同意<br><input name="c60" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>
        <li>没有人会天生同性恋。<br><input name="c61" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c61" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c61" type="radio" data-x="0" data-y="0.15">同意<br><input name="c61" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>
        <li>社会对性开放并没错，但现在已经开放的过分了。<br><input name="c62" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c62" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c62" type="radio" data-x="0" data-y="0.11">同意<br><input name="c62" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>
    </ol>
</form></p>
<div id="western-wrapper">
    <button id="western-submit" type="button" class="button button-inverse button-rounded">提交</button>
    <br>
    <span id="western-answer" class="red">
    政治立场坐标（左翼&lt;-&gt;右翼）-3.87，经济立场坐标（左翼&lt;-&gt;右翼）-2.42
    </span>
</div>


<script type="text/javascript">
  $(function() {
    $("#western-submit").click(function(){
      var t=0, a=0;
      $('#western-questions input[name^="c"]:checked').each(function(){
        t += parseFloat($(this).attr("data-x")),
        a += parseFloat($(this).attr("data-y"))
      }),
      t = Math.round(100*t)/100,
      a = Math.round(100*a)/100,
      $("#western-answer").html("经济立场坐标（左翼<->右翼）"+ t + "，政治立场坐标（专制<->自由）" + a)
    })
  });
</script>


<div class="note info">
            <p>横坐标反映经济观念，负值为左（Communism, Collectivism），正值为右（Neo-Liberalism, Libertaranism）。纵坐标反映政治社会观念，负值为自由（Anarchism, Libertarian），正值为专制或保守（Facism, Authoritarian）。</p><p>本测试系统建立于西方政治价值体系基础之上，某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。根据周围人群的实验结果，中国人的测试结果普遍位于第三象限（即两坐标均为负值），平均值位于(-2,-2)附近。为了区分中国人习惯意义上的「左与右」，可以以(-2,-2)为坐标原点重新划分坐标平面，即经济坐标小于-2为左，反之为右。政治坐标小于-2为自由，反之为保守或专制。</p><p>下面是著名政治人物的坐标位置以供参考：</p><ul><li>第一象限（经济右，政治保守）：希特勒，撒切尔夫人，布什，布莱尔，希拉克。</li><li>第二象限（经济左，政治保守）：斯大林，萨达姆，教皇本笃十四世。</li><li>第三象限（经济左，政治自由）：甘地，达赖喇嘛，曼德拉。</li><li>第四象限（经济右，政治自由）：弗里德曼，哈耶克。</li></ul>
          </div>
<h3 id="测试反思-1"><a href="#测试反思-1" class="headerlink" title="测试反思"></a>测试反思</h3><ul>
<li>我的种族和其他种族相比有很多出众的优点？我下意识想选择同意。但是真的是这样吗？</li>
<li>各尽所能，各取所需？人类的惰性</li>
<li>土地应该自由买卖吗？</li>
<li>以眼还眼以牙还牙，对吗？主观上会这么做。理性上为了更好的共处，应该放下。</li>
<li>学校应当强制学生签到吗？对于大学生，学不学是你的主观意愿。但是如果是义务教育，需要。</li>
<li>堕胎应当被允许吗？这应该是个人选择吧。 </li>
<li>大麻应该合法吗？介于毒品和香烟之间，但是更偏毒品，偏向于禁止大麻。</li>
<li>应当允许有严重遗传疾病的残疾人生育吗？不应该，遗传疾病生下来对于孩子也是痛苦，领养不好吗？</li>
<li>对于电子监听，我们需要担忧吗？ 对于绝大多数普通人，这应该不是问题。 </li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>还是原来的观点，这个测试结果并不一定代表什么，但是可以作为参考。最重要的是，给自己提供了一个思考的机会。很多问题选择不够坚决，说明很多时候对这方面的思考欠缺。这个测试不应该是一次性的测试，随着人的动态变化，观点也在发生改变。在以后的时间，可以回头再看这些问题。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>politics</tag>
        <tag>价值观</tag>
      </tags>
  </entry>
  <entry>
    <title>【备忘录】播客录</title>
    <url>/posts/d7e805bd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。</p><a id="more"></a>
<h2 id="收听工具"><a href="#收听工具" class="headerlink" title="收听工具"></a>收听工具</h2><p>下面是收听 PodCast 常见的一些工具，目前我选用的是 Moon FM。</p>
<h3 id="Pocket-Casts-全平台的播客老字号"><a href="#Pocket-Casts-全平台的播客老字号" class="headerlink" title="Pocket Casts - 全平台的播客老字号"></a>Pocket Casts - 全平台的播客老字号</h3><p>有条件科学上网、不介意英文界面的朋友，用它绝不会错！</p>
<p>👍优点：</p>
<ul>
<li>目前Android体验第一梯队选手，比较推荐。</li>
<li>主流的播放功能很全，前进后退30s/变速/跳过空白/人声加强/定时关闭都有，还有比较罕见的手动Skipping Intros，给开头废话比较多的节目用上还挺爽的。</li>
<li>有数据统计功能，如果作为主力App的话很适合定期回顾做记录。</li>
<li>全平台可用，即使换了设备也不用转移收听数据。</li>
<li>设计好看，配色可自选，无广告。</li>
</ul>
<p>🤦‍♂️缺点：</p>
<ul>
<li>英文界面，需要爬梯收听。推荐页几乎见不到中文播客。</li>
</ul>
<h3 id="Castbox-主攻海外市场的国产播客App"><a href="#Castbox-主攻海外市场的国产播客App" class="headerlink" title="Castbox - 主攻海外市场的国产播客App"></a>Castbox - 主攻海外市场的国产播客App</h3><p>适合有条件科学上网，且不打算用英文App的朋友。</p>
<p>如果你恰好有多种兴趣，还有查收听数据的习惯，那用它再好不过了！</p>
<p>👍优点：</p>
<ul>
<li>体验第一梯队的选手，比较推荐。</li>
<li>主流功能很全，除了Skipping Intros，Pocket Casts有的它都有。</li>
<li>Castbox支持自建多个播放列表，非常适合兴趣纷杂，喜欢在老节目里寻宝的听众。单集添加到播放列表就会自动下载，听完自动删除，顺滑极了。</li>
<li>可视化的数据统计也是一个亮点。除了收听总时长，还能看到过去一周的每日收听时长</li>
</ul>
<p>🤦‍♂️缺点：</p>
<ul>
<li>需要爬梯收听。主阵地在海外，所以推荐内容里英文浓度高。页面广告略多。</li>
</ul>
<h3 id="Spotify-正版流媒体音乐服务平台"><a href="#Spotify-正版流媒体音乐服务平台" class="headerlink" title="Spotify - 正版流媒体音乐服务平台"></a>Spotify - 正版流媒体音乐服务平台</h3><p>适合正好用Spotify听音乐的朋友，为了听播客而单独下载就不太值。</p>
<p>👍优点：</p>
<ul>
<li>毕竟是老牌音乐App，音频的基本功能它都有。登录后无广告。</li>
<li>如果你正好会使用Spotify听音乐，那顺带用它听播客就不错。</li>
</ul>
<p>🤦‍♂️缺点：</p>
<h3 id="Moon-FM-全平台的国产播客App"><a href="#Moon-FM-全平台的国产播客App" class="headerlink" title="Moon FM - 全平台的国产播客App"></a>Moon FM - 全平台的国产播客App</h3><p>对App颜值有高要求的朋友请一定试试它！</p>
<p>👍优点：</p>
<ul>
<li>去年新诞生的一个播客App，也是目前中文播客应用的佼佼者，对中文用户很友好。</li>
<li>页面灵巧又清爽，设计上是费了心的。好看的App提名必须有它。</li>
<li>有一定的发现功能。基础收听功能虽然比不上老牌应用全面，但变速、睡眠定时都有。</li>
<li>全平台可用。无广告。</li>
</ul>
<p>🤦‍♂️缺点：</p>
<ul>
<li>交互逻辑比较小众，需要接受时间。没有前进后退30s。</li>
<li>发现功能仅限于精选播客，个性化推荐有待完善。</li>
</ul>
<h3 id="海盗电台-快速生长的国产播客App新面孔"><a href="#海盗电台-快速生长的国产播客App新面孔" class="headerlink" title="海盗电台 - 快速生长的国产播客App新面孔"></a>海盗电台 - 快速生长的国产播客App新面孔</h3><ul>
<li>适合已有一些常听节目的爱好者，给“听”换上更干净纯粹的工具。</li>
</ul>
<p>👍优点：</p>
<ul>
<li>开发者更新很积极，功能不断完善中，DarkMode也有了。</li>
<li>基础播放功能不错，除了前进后退30s、变速、睡眠定时，跳过空白的功能也已经有了。</li>
<li>因为是国产App，所以对中文用户很友好。</li>
<li>设计简洁舒适。无广告。</li>
</ul>
<p>🤦‍♂️缺点：</p>
<ul>
<li>暂无发现功能。一些基本功能也待完善，比如自动下载。</li>
</ul>
<h3 id="网易云-播客作为边角料"><a href="#网易云-播客作为边角料" class="headerlink" title="网易云 - 播客作为边角料"></a>网易云 - 播客作为边角料</h3><p>适合正好在用网易云听音乐，且固定只听几个播客节目的朋友。</p>
<p>👍优点：</p>
<ul>
<li>中文播客较全，播客主为了流量几乎都会上传。</li>
<li>沾了音乐区的光，播客的评论氛围还不错。</li>
<li>如果正好在用网易云听音乐，就不用多下一个app专门听播客了。</li>
</ul>
<p>🤦‍♂️缺点：</p>
<ul>
<li>我头一次听播客就是在网易云。当时是iOS的朋友锲而不舍推一档节目给我，而网易云给了我非常便利的起步。但在此之后很久，我都只听那一档播客。</li>
<li>原因很简单，网易云毕竟主业在音乐，播客作为非常边角的板块，甚至没有推荐功能，发现新节目纯靠搜索，也没有播客app的基础播放功能。</li>
</ul>
<h3 id="喜马拉雅-大而全的老牌泛音频平台"><a href="#喜马拉雅-大而全的老牌泛音频平台" class="headerlink" title="喜马拉雅 - 大而全的老牌泛音频平台"></a>喜马拉雅 - 大而全的老牌泛音频平台</h3><p>适合对界面简洁要求不高，希望多多发现中文播客节目的听众。</p>
<p>👍优点：</p>
<ul>
<li>中文播客较全，播客主为了流量几乎都会上传。</li>
<li>毕竟是老牌音频平台，应该是国产app中基础收听功能最全的，前进后退30s/变速/定时关闭/跳过头尾配齐了。</li>
<li>推荐功能对中文用户很友好，尤其发现相关播客的功能，对需要扩充收听列表的朋友来说很实用。</li>
<li>可以顺带听听有声书。</li>
</ul>
<p>🤦‍♂️缺点：</p>
<ul>
<li>页面真的有点繁杂。</li>
<li>不像别的平台广告只出现在屏幕上，喜马拉雅的片头片尾是有音频广告的，需要付费去除。</li>
<li>还有一点有些苛刻了，毕竟是目前播客app的通病：被推荐的来来回回就是几个头部节目，成长中的小众播客很难被发现。</li>
<li>荔枝、蜻蜓和喜马拉雅的情况非常相近。不再赘述。</li>
</ul>
<h2 id="收听栏目"><a href="#收听栏目" class="headerlink" title="收听栏目"></a>收听栏目</h2><p>正在尝试去探索一些比较知名的播客，等过段时间再来反馈。</p>
<h3 id="GQ-Talk"><a href="#GQ-Talk" class="headerlink" title="GQ Talk"></a>GQ Talk</h3><h3 id="忽左忽右"><a href="#忽左忽右" class="headerlink" title="忽左忽右"></a>忽左忽右</h3><h3 id="得意忘形"><a href="#得意忘形" class="headerlink" title="得意忘形"></a>得意忘形</h3><h3 id="内核恐慌"><a href="#内核恐慌" class="headerlink" title="内核恐慌"></a>内核恐慌</h3><h3 id="日谈公园"><a href="#日谈公园" class="headerlink" title="日谈公园"></a>日谈公园</h3><h3 id="面面相趣"><a href="#面面相趣" class="headerlink" title="面面相趣"></a>面面相趣</h3>]]></content>
      <categories>
        <category>好奇计划</category>
      </categories>
      <tags>
        <tag>podcast</tag>
        <tag>rss</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络包收发流程</title>
    <url>/posts/941301e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文记录了Linux网络数据包的接收和发送过程。</p>
<a id="more"></a>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/receive.gif"></p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h3 id="数据包的接收过程"><a href="#数据包的接收过程" class="headerlink" title="数据包的接收过程"></a>数据包的接收过程</h3><h3 id="从网卡到内存"><a href="#从网卡到内存" class="headerlink" title="从网卡到内存"></a>从网卡到内存</h3><p>我们知道，每个网络设备（网卡）需要有驱动才能工作，驱动需要在内核启动时加载到内核中才能工作。事实上，从逻辑上看，驱动是负责衔接网络设备和内核网络栈的中间模块，每当网络设备接收到新的数据包时，就会触发中断，而对应的中断处理程序正是加载到内核中的驱动程序。</p>
<p>下面这张图详细的展示了数据包如何从网络设备进入内存，并被处于内核中的驱动程序和网络栈处理的：</p>
<p><img alt="network-receive-data-1.jpg" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/8ZsXoQ1emVSzJlc.jpg"></p>
<ol>
<li>数据包进入物理网卡。如果目的地址不是该网络设备，且该来网络设备没有开启<a href="https://unix.stackexchange.com/questions/14056/what-is-kernel-ip-forwarding" target="_blank" rel="external nofollow noopener noreferrer">混杂模式</a>，该包会被网络设备丢弃。</li>
<li>物理网卡将数据包通过DMA的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。</li>
<li>物理网卡通过硬件中断（IRQ）通知CPU，有新的数据包到达物理网卡需要处理。</li>
<li>CPU根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数</li>
<li>驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉物理网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。</li>
<li>启动软中断继续处理数据包。这样的原因是硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。</li>
</ol>
<h3 id="内核处理数据包"><a href="#内核处理数据包" class="headerlink" title="内核处理数据包"></a>内核处理数据包</h3><p>上一步中网络设备驱动程序会通过软触发内核网络模块中的软中断处理函数，内核处理数据包的流程如下图所示：</p>
<p><img alt="network-receive-data-2.jpg" data-src="https://i.loli.net/2020/01/27/y2SZleoIwtbxDLs.jpg"></p>
<ol>
<li>对于第6步中驱动发出的软中断，内核中的<code>ksoftirqd</code>进程会调用网络模块的相应软中断所对应的处理函数，这里其实就是调用<code>net_rx_action</code>函数。</li>
<li>接下来<code>net_rx_action</code>调用网卡驱动里的<code>poll</code>函数来一个个地处理数据包。</li>
<li>而<code>poll</code>函数会让驱动会读取网卡写到内存中的数据包。事实上，内存中数据包的格式只有驱动知道。</li>
<li>驱动程序将内存中的数据包转换成内核网络模块能识别的<code>skb</code>(socket buffer)格式，然后调用<code>napi_gro_receive</code>函数</li>
<li><code>napi_gro_receive</code>会处理<a href="https://lwn.net/Articles/358910/" target="_blank" rel="external nofollow noopener noreferrer">GRO</a>相关的内容，也就是将可以合并的数据包进行合并，这样就只需要调用一次协议栈。然后判断是否开启了RPS，如果开启了，将会调用<code>enqueue_to_backlog</code>。</li>
<li><code>enqueue_to_backlog</code>函数会将数据包放入<code>input_pkt_queue</code>结构体中，然后返回。 &gt; Note: 如果<code>input_pkt_queue</code>满了的话，该数据包将会被丢弃，这个queue的大小可以通过<code>net.core.netdev_max_backlog</code>来配置</li>
<li>接下来CPU会在软中断上下文中处理自己<code>input_pkt_queue</code>里的网络数据（调用<code>__netif_receive_skb_core</code>函数）</li>
<li>如果没开启<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L99-L222" target="_blank" rel="external nofollow noopener noreferrer">RPS</a>，<code>napi_gro_receive</code>会直接调用<code>__netif_receive_skb_core</code>函数。</li>
<li>紧接着CPU会根据是不是有<code>AF_PACKET</code>类型的socket（原始套接字），如果有的话，拷贝一份数据给它(<code>tcpdump</code>抓包就是抓的这里的包)。</li>
<li>将数据包交给内核协议栈处理。</li>
<li>当内存中的所有数据包被处理完成后（<code>poll</code>函数执行完成），重新启用网卡的硬中断，这样下次网卡再收到数据的时候就会通知CPU。</li>
</ol>
<h3 id="内核协议栈"><a href="#内核协议栈" class="headerlink" title="内核协议栈"></a>内核协议栈</h3><p>内核网络协议栈此时接收到的数据包其实是三层(IP网络层)数据包，因此，数据包首先会进入到IP网络层层，然后进入传输层处理。</p>
<h4 id="IP网络层"><a href="#IP网络层" class="headerlink" title="IP网络层"></a>IP网络层</h4><p><img alt="network-receive-data-3.jpg" data-src="https://i.loli.net/2020/01/27/oxfqD6Upiw7Blbt.jpg"></p>
<ul>
<li>ip_rcv: <code>ip_rcv</code>函数是IP网络层处理模块的入口函数，该函数首先判断属否需要丢弃该数据包（目的mac地址不是当前网卡，并且网卡设置了混杂模式），如果需要进一步处理就然后调用注册在netfilter中的<code>NF_INET_PRE_ROUTING</code>这条链上的处理函数。</li>
<li>NF_INET_PRE_ROUTING: netfilter放在协议栈中的钩子函数，可以通过iptables来注入一些数据包处理函数，用来修改或者丢弃数据包，如果数据包没被丢弃，将继续往下走。 &gt; <code>NF_INET_PRE_ROUTING</code>等netfilter链上的处理逻辑可以通iptables来设置，详情请移步: <a href="https://morven.life/notes/the_knowledge_of_iptables/" target="_blank" rel="external nofollow noopener noreferrer">https://morven.life/notes/the_knowledge_of_iptables/</a></li>
<li>routing: 进行路由处理，如果是目的IP不是本地IP，且没有开启<code>ip forward</code>功能，那么数据包将被丢弃，如果开启了<code>ip forward</code>功能，那将进入<code>ip_forward</code>函数。</li>
<li>ip_forward: 该函数会先调用<code>netfilter</code>注册的<code>NF_INET_FORWARD</code>链上的相关函数，如果数据包没有被丢弃，那么将继续往后调用<code>dst_output_sk</code>函数。</li>
<li>dst_output_sk: 该函数会调用IP网络层的相应函数将该数据包发送出去，这一步将会在下一章节发送数据包中详细介绍。</li>
<li>ip_local_deliver: 如果上面路由处理发现发现目的IP是本地IP，那么将会调用<code>ip_local_deliver</code>函数，该函数先调用<code>NF_INET_LOCAL_IN</code>链上的相关函数，如果通过，数据包将会向下发送到UDP层。</li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><img alt="network-receive-data-4.jpg" data-src="https://i.loli.net/2020/01/27/Hcyw6pFJDLVtZ8j.jpg"></p>
<ul>
<li>udp_rcv: 该函数是UDP处理层模块的入口函数，它首先调用<code>__udp4_lib_lookup_skb</code>函数，根据目的IP和端口找对应的<code>socket</code>，如果没有找到相应的<code>socket</code>，那么该数据包将会被丢弃，否则继续。</li>
<li>sock_queue_rcv_skb: 该函数一是负责检查这个socket的receive buffer是不是满了，如果满了的话就丢弃该数据包；二是调用<code>sk_filter</code>看这个包是否是满足条件的包，如果当前socket上设置了filter，且该包不满足条件的话，这个数据包也将被丢弃。</li>
<li>__skb_queue_tail: 该函数将数据包放入socket接收队列的末尾。</li>
<li>sk_data_ready: 通知socket数据包已经准备好。</li>
<li>调用完sk_data_ready之后，一个数据包处理完成，等待应用层程序来读取。</li>
</ul>
<blockquote>
<p>Note: 上面所述的所有执行过程都在软中断的上下文中执行。</p>
</blockquote>
<hr>
<h3 id="数据包的发送过程"><a href="#数据包的发送过程" class="headerlink" title="数据包的发送过程"></a>数据包的发送过程</h3><p>从逻辑上看，Linux网络数据包的发送过程和接收过程正好相反，我们仍旧以一个UDP数据包通过物理网卡发送的过程为例来讲解：</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层处理过程的起点是应用程序调用Linux网络接口创建socket（所谓socket基本就是ip+端口组成的基本结构体），下面这张图详细的展示了应用层如何构建socket并发送给下层UDP：</p>
<p><img alt="network-send-data-1.jpg" data-src="https://i.loli.net/2020/01/27/XFTDfq37OQm9ZAa.jpg"></p>
<ul>
<li>socket(…): 调用该函数来创建一个socket结构体，并初始化相应的操作函。</li>
<li>sendto(sock, …): 应用层程序调用该函数开始发送数据包，该函数数会调用后面的<code>inet_sendmsg</code>。</li>
<li>inet_sendmsg: 该函数主要是检查当前socket有没有绑定源端口，如果没有的话，调用<code>inet_autobind</code>分配一个，然后调用UDP层的函数。</li>
<li>inet_autobind: 该函数会调用socket上绑定的<code>get_port</code>函数获取一个可用的端口。</li>
</ul>
<h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p><img alt="network-send-data-2.jpg" data-src="https://i.loli.net/2020/01/27/Eojq5mIZty3zJK7.jpg"></p>
<ul>
<li>udp_sendmsg: 该函数是UDP传输层模块发送数据包的入口。该函数中先调用<code>ip_route_output_flow</code>获取路由信息（主要包括源IP和网卡），然后调用<code>ip_make_skb</code>构造skb结构体，最后将网卡的信息和该skb关联。</li>
<li>ip_route_output_flow: 该函数主要处理路由信息，它会根据路由表和目的IP，找到这个数据包应该从哪个设备发送出去，如果该socket没有绑定源IP，该函数还会根据路由表找到一个最合适的源IP给它。 如果该socket已经绑定了源IP，但根据路由表，从这个源IP对应的网卡没法到达目的地址，则该包会被丢弃，于是数据发送失败将返回错误。该函数最后会将找到的设备和源IP塞进flowi4结构体并返回给<code>udp_sendmsg</code>。</li>
<li>ip_make_skb: 该函数的功能是构造skb包，构造好的skb包里面已经分配了IP包头(包括源IP信息)，同时该函数会调用<code>__ip_append_dat</code>，如果需要分片的话，会在<code>__ip_append_data</code>函数中进行分片，同时还会在该函数中检查socket的send buffer是否已经用光，如果被用光的话，返回ENOBUFS。</li>
<li>udp_send_skb(skb, fl4): 该函数主要是往skb里面填充UDP的包头，同时处理checksum，然后交给IP网络层层的相应函数。</li>
</ul>
<h3 id="IP网络层-1"><a href="#IP网络层-1" class="headerlink" title="IP网络层"></a>IP网络层</h3><p><img alt="network-send-data-3.jpg" data-src="https://i.loli.net/2020/01/28/dRVXQnmpxbZoqwG.jpg"></p>
<ul>
<li>ip_send_skb: IP网络层模块发送数据包的入口，该函数主要是调用后面的一些列函数。</li>
<li>__ip_local_out_sk: 用来设置IP报文头的长度和checksum，然后调用下面netfilter的钩子链<code>NF_INET_LOCAL_OUT</code>。</li>
<li>NF_INET_LOCAL_OUT: netfilter的钩子函数，可以通过iptables来配置处理函数链；如果该数据包没被丢弃，则继续往下走。</li>
<li>dst_output_sk: 该函数根据skb里面的信息，调用相应的output函数<code>ip_output</code>。</li>
<li>ip_output: 将上一层<code>udp_sendmsg</code>得到的网卡信息写入skb，然后调用 <code>NF_INET_POST_ROUTING</code>的钩子链。</li>
<li>NF_INET_POST_ROUTING: 在这一步主要在配置了SNAT，从而导致该skb的路由信息发生变化。</li>
<li>ip_finish_output: 这里会判断经过了上一步后，路由信息是否发生变化，如果发生变化的话，需要重新调用<code>dst_output_sk</code>（重新调用这个函数时，可能就不会再走到<code>ip_output</code>，而是走到被netfilter指定的output函数里，这里有可能是<code>xfrm4_transport_output</code>），否则接着往下走。</li>
<li>ip_finish_output2: 根据目的IP到路由表里面找到下一跳(nexthop)的地址，然后调用<code>__ipv4_neigh_lookup_noref</code>去arp表里面找下一跳的neigh信息，没找到的话会调用<code>__neigh_create</code>构造一个空的neigh结构体。</li>
<li>dst_neigh_output: 该函数调用<code>neigh_resolve_output</code>获取neigh信息，并将neigh信息里面的mac地址填到skb中，然后调用<code>dev_queue_xmit</code>发送数据包。</li>
<li>neigh_resolve_output: 该函数里面会发送arp请求，得到下一跳的mac地址，然后将mac地址填到skb中并调用<code>dev_queue_xmit</code>。</li>
</ul>
<h3 id="内核处理数据包-1"><a href="#内核处理数据包-1" class="headerlink" title="内核处理数据包"></a>内核处理数据包</h3><p><img alt="network-send-data-4.jpg" data-src="https://i.loli.net/2020/01/28/bmCiIl3EBXnsSfY.jpg"></p>
<ul>
<li>dev_queue_xmit: 内核模块开始处理发送数据包的入口函数，该函数会先获取设备对应的qdisc，如果没有的话（如loopback或者IP tunnels），就直接调用<code>dev_hard_start_xmit</code>，否则数据包将经过<code>traffic control</code>模块进行处理。</li>
<li>traffic control：该模块主要对数据包进行过滤和排序，如果队列满了的话，数据包会被丢掉，详情请参考: <a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html" target="_blank" rel="external nofollow noopener noreferrer">http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html</a></li>
<li>dev_hard_start_xmit: 该函数先拷贝一份skb给“packet taps”(tcpdump的数据就从来自于此），然后调用<code>ndo_start_xmit</code>函数。如果<code>dev_hard_start_xmit</code>返回错误的话，调用它的函数会把skb放到一个地方，然后抛出软中断<code>NET_TX_SOFTIRQ</code>，然后交给软中断处理程序<code>net_tx_action</code>稍后重试。</li>
<li>ndo_start_xmit：该函数绑定到具体驱动发送数据的处理函数。</li>
</ul>
<blockquote>
<p>Note: <code>ndo_start_xmit</code>会指向具体网卡驱动的发送数据包的函数，这一步之后，数据包发送任务就交给网络设备驱动了，不同的网络设备驱动有不同的处理方式，但是大致流程基本一致：</p>
</blockquote>
<ol>
<li>将skb放入网卡自己的发送队列</li>
<li>通知网卡发送数据包</li>
<li>网卡发送完成后发送中断给CPU</li>
<li>收到中断后进行skb的清理工作</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解了Linux网络数据包的接收和发送流程，我们就可以知道在哪些地方监控和修改数据包，哪些情况下数据包可能被丢弃，特别是了解了netfilter中相应钩子函数的位置，对于了解iptables的用法有一定的帮助，同时也会帮助我们更好的理解Linux下的网络虚拟设备。</p>
<h2 id="网卡驱动层"><a href="#网卡驱动层" class="headerlink" title="网卡驱动层"></a>网卡驱动层</h2><h3 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h3><p>网卡工作在物理层和数据链路层，主要由PHY/MAC芯片、Tx/Rx FIFO、DMA等组成，其中网线通过变压器接PHY芯片、PHY芯片通过MII接MAC芯片、MAC芯片接PCI总线</p>
<ul>
<li>PHY芯片主要负责：<ul>
<li>CSMA/CD、模数转换、编解码、串并转换</li>
</ul>
</li>
<li>MAC芯片主要负责：<ul>
<li>比特流和帧的转换：7字节的前导码Preamble和1字节的帧首定界符SFD</li>
<li>CRC校验</li>
<li>Packet Filtering：L2 Filtering、VLAN Filtering、Manageability / Host Filtering</li>
</ul>
</li>
</ul>
<p>Intel的千兆网卡以82575/82576为代表、万兆网卡以82598/82599为代表</p>
<h3 id="网卡驱动"><a href="#网卡驱动" class="headerlink" title="网卡驱动"></a>网卡驱动</h3><h4 id="网卡驱动ixgbe初始化"><a href="#网卡驱动ixgbe初始化" class="headerlink" title="网卡驱动ixgbe初始化"></a>网卡驱动ixgbe初始化</h4><p>网卡驱动为每个新的接口在一个全局的网络设备列表里插入一个数据结构。每个接口由一个结构 <code>net_device</code> 项来描述, 它在<code>&lt;linux/netdevice.h&gt;</code>里定义。该结构必须动态分配。</p>
<p>每个网卡，无论是物理还是虚拟的网卡，都必须有一个：<code>net_device</code>，这个struct是在网卡驱动中分配创建的，不同的网卡，对应厂商不同的驱动，那么看看ixgbe的驱动初始化; 创建<code>net_device</code> 的函数是: <code>alloc_etherdev</code>, 或者： <code>alloc_etherdev_mq</code></p>
<p><a href="https://www.cnblogs.com/lidp/archive/2009/05/13/1697981.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/lidp/archive/2009/05/13/1697981.html</a></p>
<h5 id="pci设备："><a href="#pci设备：" class="headerlink" title="pci设备："></a>pci设备：</h5><p>在内核中，一个PCI设备，使用<code>struct pci_driver</code>结构来描述, 因为在系统引导的时候，PCI设备已经被识别，当内核发现一个已经检测到的设备同驱动注册的<code>id_table</code>中的信息相匹配时，<br>它就会触发驱动的<code>probe</code>函数,</p>
<p>比如，看看ixgbe 驱动：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">ixgb_driver</span> = &#123;</span></span><br><span class="line">    .name     = ixgb_driver_name,</span><br><span class="line">    .id_table = ixgb_pci_tbl,</span><br><span class="line">    .probe    = ixgb_probe,</span><br><span class="line">    .<span class="built_in">remove</span>   = ixgb_remove,</span><br><span class="line">    .err_handler = &amp;ixgb_err_handler</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta"># vim drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span></span><br><span class="line">module_init</span><br><span class="line">    ixgbe_init_module</span><br><span class="line">        pci_register_driver</span><br></pre></td></tr></table></figure>
<p>当<code>probe</code>函数被调用，证明已经发现了我们所支持的网卡，这样，就可以调用<code>register_netdev</code>函数向内核注册网络设备了，注册之前，一般会调用<code>alloc_etherdev</code>分配一个<code>net_device</code>，然后初始化它的重要成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ixgbe_probe  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span>;</span></span><br><span class="line">    pci_enable_device_mem(pdev);</span><br><span class="line">    pci_request_mem_regions(pdev, ixgbe_driver_name);</span><br><span class="line">    pci_set_master(pdev);</span><br><span class="line">    pci_save_state(pdev);</span><br><span class="line">    netdev = alloc_etherdev_mq(<span class="keyword">sizeof</span>(struct ixgbe_adapter), indices);<span class="comment">// 这里分配struct net_device</span></span><br><span class="line">    	alloc_etherdev_mqs</span><br><span class="line">    		alloc_netdev_mqs(sizeof_priv, <span class="string">"eth%d"</span>, NET_NAME_UNKNOWN, ether_setup, txqs, rxqs);</span><br><span class="line">    			ether_setup  <span class="comment">// Initial struct net_device</span></span><br><span class="line">    			</span><br><span class="line">    SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);</span><br><span class="line">    adapter = netdev_priv(netdev);</span><br></pre></td></tr></table></figure>
<p>refs: <a href="https://blog.csdn.net/shallnet/article/details/25470775" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/shallnet/article/details/25470775</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alloc_etherdev_mqs() -&gt; ether_setup()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ether_setup</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev-&gt;header_ops     = &amp;eth_header_ops;</span><br><span class="line">    dev-&gt;type       = ARPHRD_ETHER;</span><br><span class="line">    dev-&gt;hard_header_len    = ETH_HLEN;</span><br><span class="line">    dev-&gt;min_header_len = ETH_HLEN;</span><br><span class="line">    dev-&gt;mtu        = ETH_DATA_LEN;</span><br><span class="line">    dev-&gt;addr_len       = ETH_ALEN;</span><br><span class="line">    dev-&gt;tx_queue_len   = <span class="number">1000</span>; <span class="comment">/* Ethernet wants good queues */</span></span><br><span class="line">    dev-&gt;flags      = IFF_BROADCAST|IFF_MULTICAST;</span><br><span class="line">    dev-&gt;priv_flags     |= IFF_TX_SKB_SHARING;</span><br><span class="line"></span><br><span class="line">    eth_broadcast_addr(dev-&gt;broadcast);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ether_setup);</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">ixgbe_driver</span> = &#123;</span></span><br><span class="line">	.name     = ixgbe_driver_name,</span><br><span class="line">	.id_table = ixgbe_pci_tbl,</span><br><span class="line">	.probe    = ixgbe_probe, <span class="comment">// 系统探测到ixgbe网卡后调用ixgbe_probe()</span></span><br><span class="line">	.<span class="built_in">remove</span>   = ixgbe_remove,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">	.suspend  = ixgbe_suspend,</span><br><span class="line">	.resume   = ixgbe_resume,</span><br><span class="line">#endif</span><br><span class="line">	.<span class="built_in">shutdown</span> = ixgbe_shutdown,</span><br><span class="line">	.sriov_configure = ixgbe_pci_sriov_configure,</span><br><span class="line">	.err_handler = &amp;ixgbe_err_handler</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">ixgbe_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	ret = pci_register_driver(&amp;ixgbe_driver); <span class="comment">// 注册ixgbe_driver</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ixgbe_init_module);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">ixgbe_exit_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	pci_unregister_driver(&amp;ixgbe_driver); <span class="comment">// 注销ixgbe_driver</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_exit(ixgbe_exit_module);</span><br></pre></td></tr></table></figure>
<h4 id="中断注册"><a href="#中断注册" class="headerlink" title="中断注册"></a>中断注册</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"> </span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核初始化期间，<code>softirq_init</code>会注册<code>TASKLET_SOFTIRQ</code>以及<code>HI_SOFTIRQ</code>相关联的处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">softirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">    open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网络子系统分两种soft IRQ。<code>NET_TX_SOFTIRQ</code>和<code>NET_RX_SOFTIRQ</code>，分别处理发送数据包和接收数据包。这两个soft IRQ在<code>net_dev_init</code>函数（<code>net/core/dev.c</code>）中注册：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br></pre></td></tr></table></figure>
<p>收发数据包的软中断处理函数被注册为<code>net_rx_action</code>和<code>net_tx_action</code>。<br>其中<code>open_softirq</code>实现为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重要结构体初始化"><a href="#重要结构体初始化" class="headerlink" title="重要结构体初始化"></a>重要结构体初始化</h4><p>每个cpu都有队列来处理接收到的帧，都有其数据结构来处理入口和出口流量，因此，不同cpu之间没有必要使用上锁机制。此队列数据结构为<code>softnet_data</code>(定义在<code>include/linux/netdevice.h</code>中):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Incoming packets are placed on per-cpu queues so that</span></span><br><span class="line"><span class="comment"> * no locking is needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">output_queue</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_headinput_pkt_queue</span>;</span><span class="comment">//有数据要传输的设备列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_headpoll_list</span>;</span> <span class="comment">//双向链表，其中的设备有输入帧等着被处理。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">completion_queue</span>;</span><span class="comment">//缓冲区列表，其中缓冲区已成功传输，可以释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_structbacklog</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>softnet_data</code> 是在<code>start_kernel</code> 中创建的, 并且，每个cpu一个 <code>softnet_data</code> 变量, 这个变量中，最重要的是<code>poll_list</code> , 每当收到数据包时，网络设备驱动会把自己的<code>napi_struct</code>挂到CPU私有变量<code>softnet_data-&gt;poll_list</code>上, 这样在软中断时，<code>net_rx_action</code>会遍历cpu私有变量的<code>softnet_data-&gt;poll_list</code>, 执行上面所挂的<code>napi_struct</code>结构的<code>poll</code>钩子函数,将数据包从驱动传到网络协议栈。</p>
<p>内核初始化流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel()</span><br><span class="line">--&gt; rest_init()</span><br><span class="line">        --&gt; do_basic_setup()</span><br><span class="line">            --&gt; do_initcall</span><br><span class="line">               --&gt;net_dev_init</span><br><span class="line"></span><br><span class="line"><span class="function">__init  <span class="title">net_dev_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//每个CPU都有一个CPU私有变量 _get_cpu_var(softnet_data)</span></span><br><span class="line">    <span class="comment">//_get_cpu_var(softnet_data).poll_list很重要，软中断中需要遍历它的</span></span><br><span class="line">    for_each_possible_cpu(i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">queue</span>;</span></span><br><span class="line">        <span class="built_in">queue</span> = &amp;per_cpu(softnet_data, i);</span><br><span class="line">        skb_queue_head_init(&amp;<span class="built_in">queue</span>-&gt;input_pkt_queue);</span><br><span class="line">        <span class="built_in">queue</span>-&gt;completion_queue = <span class="literal">NULL</span>;</span><br><span class="line">        INIT_LIST_HEAD(&amp;<span class="built_in">queue</span>-&gt;poll_list);</span><br><span class="line">        <span class="built_in">queue</span>-&gt;backlog.poll = process_backlog;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;backlog.weight = weight_p;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//在软中断上挂网络发送handler</span></span><br><span class="line">    open_softirq(NET_TX_SOFTIRQ, net_tx_action, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//在软中断上挂网络接收handler</span></span><br><span class="line">    open_softirq(NET_RX_SOFTIRQ, net_rx_action, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="收发包过程图"><a href="#收发包过程图" class="headerlink" title="收发包过程图"></a>收发包过程图</h3><p><code>ixgbe_adapter</code>包含<code>ixgbe_q_vector</code>数组（一个<code>ixgbe_q_vector</code>对应一个中断），<code>ixgbe_q_vector</code>包含<code>napi_struct</code>:</p>
<p>硬中断函数把<code>napi_struct</code>加入CPU的<code>poll_list</code>，软中断函数<code>net_rx_action()</code>遍历<code>poll_list</code>，执行<code>poll</code>函数<img alt="这里写图片描述" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/70-20200902223053305.png"></p>
<h4 id="发包过程"><a href="#发包过程" class="headerlink" title="发包过程"></a>发包过程</h4><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/2018040220245583?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6NTAzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>1、网卡驱动创建tx descriptor ring（一致性DMA内存），将tx descriptor ring的总线地址写入网卡寄存器TDBA</p>
<p>2、协议栈通过dev_queue_xmit()将sk_buff下送网卡驱动</p>
<p>3、网卡驱动将sk_buff放入tx descriptor ring，更新TDT</p>
<p>4、DMA感知到TDT的改变后，找到tx descriptor ring中下一个将要使用的descriptor</p>
<p>5、DMA通过PCI总线将descriptor的数据缓存区复制到Tx FIFO</p>
<p>6、复制完后，通过MAC芯片将数据包发送出去</p>
<p>7、发送完后，网卡更新TDH，启动硬中断通知CPU释放数据缓存区中的数据包</p>
<h4 id="Tx-Ring-Buffer"><a href="#Tx-Ring-Buffer" class="headerlink" title="Tx Ring Buffer"></a>Tx Ring Buffer</h4><p>SW将sk_buff挂载到从next_to_use开始的N个descriptor，next_to_use += N，tail = next_to_use（写网卡寄存器TDT）</p>
<p>HW使用DMA读从head开始的M个descriptor的sk_buff，发送成功后回写DD(Descriptor Done)，head += M</p>
<p>SW将从next_to_clean的开始的L个sk_buff移出Tx Ring Buffer并清理，next_to_clean += L</p>
<p>注意：每次挂载完sk_buff后，tail和next_to_use指向同一个descriptor</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019081611484082.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6NTAzNA==,size_16,color_FFFFFF,t_70"></p>
<h4 id="收包过程"><a href="#收包过程" class="headerlink" title="收包过程"></a>收包过程</h4><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20180402202508717?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6NTAzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>1、网卡驱动创建rx descriptor ring（一致性DMA内存），将rx descriptor ring的总线地址写入网卡寄存器RDBA</p>
<p>2、网卡驱动为每个descriptor分配sk_buff和数据缓存区，流式DMA映射数据缓存区，将数据缓存区的总线地址保存到descriptor</p>
<p>3、网卡接收数据包，将数据包写入Rx FIFO</p>
<p>4、DMA找到rx descriptor ring中下一个将要使用的descriptor</p>
<p>5、整个数据包写入Rx FIFO后，DMA通过PCI总线将Rx FIFO中的数据包复制到descriptor的数据缓存区</p>
<p>6、复制完后，网卡启动硬中断通知CPU数据缓存区中已经有新的数据包了，CPU执行硬中断函数：</p>
<ul>
<li>NAPI（以e1000网卡为例）：e1000_intr() -&gt; <strong>napi_schedule() -&gt; </strong>raise_softirq_irqoff(NET_RX_SOFTIRQ)</li>
<li>非NAPI（以dm9000网卡为例）：dm9000_interrupt() -&gt; dm9000_rx() -&gt; netif_rx() -&gt; napi_schedule() -&gt; <strong>napi_schedule() -&gt; </strong>raise_softirq_irqoff(NET_RX_SOFTIRQ)</li>
</ul>
<p>7、ksoftirqd执行软中断函数net_rx_action()：</p>
<ul>
<li>NAPI（以e1000网卡为例）：net_rx_action() -&gt; e1000_clean() -&gt; e1000_clean_rx_irq() -&gt; e1000_receive_skb() -&gt; netif_receive_skb()</li>
<li>非NAPI（以dm9000网卡为例）：net_rx_action() -&gt; process_backlog() -&gt; netif_receive_skb()</li>
</ul>
<p>8、网卡驱动通过netif_receive_skb()将sk_buff上送协议栈</p>
<h4 id="Rx-Ring-Buffer"><a href="#Rx-Ring-Buffer" class="headerlink" title="Rx Ring Buffer"></a>Rx Ring Buffer</h4><p>SW向从next_to_use开始的N个descriptor补充sk_buff，next_to_use += N，tail = next_to_use（写网卡寄存器RDT）</p>
<p>HW写Frame到从head开始的M个descriptor的sk_buff，写完后回写EOP(End of Packet)，head += M</p>
<p>SW将从next_to_clean开始的L个sk_buff移出Rx Ring Buffer并上送协议栈，next_to_clean += L，向从next_to_use开始的L个descriptor补充sk_buff，next_to_use += L，tail = next_to_use</p>
<p>注意：每次补充完sk_buff后，tail和next_to_use指向同一个sk_buff</p>
<p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190816115512756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6NTAzNA==,size_16,color_FFFFFF,t_70"></p>
<h3 id="中断上下部"><a href="#中断上下部" class="headerlink" title="中断上下部"></a>中断上下部</h3><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20180402202540611?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h6NTAzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>do_IRQ()是CPU处理硬中断的总入口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在e1000_request_irq()中注册硬中断，中断函数为e1000_intr()</span></span><br><span class="line"><span class="keyword">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line">err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">                  netdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在net_dev_init()中注册软中断，中断函数为net_rx_action()</span></span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在e1000_probe()中注册napi的poll函数为e1000_clean()</span></span><br><span class="line">netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, <span class="number">64</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在net_dev_init()中注册非napi的poll函数为process_backlog()</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;backlog.poll = process_backlog;</span><br></pre></td></tr></table></figure>
<h3 id="netif-rx"><a href="#netif-rx" class="headerlink" title="netif_rx()"></a>netif_rx()</h3><p>在netif_rx()中把skb加入CPU的softnet_data</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netif_rx</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">queue</span>;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* if netpoll wants it, pretend we never saw it */</span></span><br><span class="line">   <span class="keyword">if</span> (netpoll_rx(skb))</span><br><span class="line">      <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (!skb-&gt;tstamp.tv64)</span><br><span class="line">      net_timestamp(skb);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The code is rearranged so that the path is the most</span></span><br><span class="line"><span class="comment">    * short when CPU is congested, but is still operating.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   local_irq_save(flags);</span><br><span class="line">   <span class="built_in">queue</span> = &amp;__get_cpu_var(softnet_data); <span class="comment">// 得到CPU的softnet_data</span></span><br><span class="line"> </span><br><span class="line">   __get_cpu_var(netdev_rx_stat).total++;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) &#123; <span class="comment">// 若队列长度不大于netdev_max_backlog</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;input_pkt_queue.qlen) &#123; <span class="comment">// 若队列长度非0，表示queue-&gt;backlog已被加入poll_list</span></span><br><span class="line">enqueue:</span><br><span class="line">         __skb_queue_tail(&amp;<span class="built_in">queue</span>-&gt;input_pkt_queue, skb); <span class="comment">// 将skb加入队列尾部</span></span><br><span class="line">         local_irq_restore(flags);</span><br><span class="line">         <span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      napi_schedule(&amp;<span class="built_in">queue</span>-&gt;backlog); <span class="comment">// 调度queue-&gt;backlog</span></span><br><span class="line">      <span class="keyword">goto</span> enqueue; <span class="comment">// 将skb加入队列尾部</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   __get_cpu_var(netdev_rx_stat).dropped++;</span><br><span class="line">   local_irq_restore(flags);</span><br><span class="line"> </span><br><span class="line">   kfree_skb(skb);</span><br><span class="line">   <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="硬中断中的netif-rx-函数：把skb加入CPU的softnet-data-gt-input-pkt-queue队列"><a href="#硬中断中的netif-rx-函数：把skb加入CPU的softnet-data-gt-input-pkt-queue队列" class="headerlink" title="硬中断中的netif_rx()函数：把skb加入CPU的softnet_data-&gt; input_pkt_queue队列"></a>硬中断中的<code>netif_rx()</code>函数：把skb加入CPU的<code>softnet_data-&gt; input_pkt_queue</code>队列</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">netif_rx(skb);  <span class="comment">// 在 硬中断中，处理skb</span></span><br><span class="line">	netif_rx_internal(skb);</span><br><span class="line">		trace_netif_rx(skb);</span><br><span class="line">		preempt_disable();</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow); <span class="comment">// 通过rps，获得cpu id</span></span><br><span class="line">		enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail); </span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span>;</span></span><br><span class="line">			sd = &amp;per_cpu(softnet_data, cpu);  <span class="comment">// 根据cpu id，获得sd</span></span><br><span class="line">			rps_lock(sd);</span><br><span class="line">			__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb); <span class="comment">// enqueue 动作</span></span><br><span class="line">			input_queue_tail_incr_save(sd, qtail);</span><br><span class="line">			rps_unlock(sd);</span><br><span class="line">			local_irq_restore(flags)</span><br><span class="line">			<span class="keyword">return</span> NET_RX_SUCCESS</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		preempt_enable();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netif_rx_internal</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    net_timestamp_check(netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line">    trace_netif_rx(skb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">    <span class="keyword">if</span> (static_key_false(&amp;rps_needed)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rps_dev_flow</span> <span class="title">voidflow</span>, *<span class="title">rflow</span> = &amp;<span class="title">voidflow</span>;</span></span><br><span class="line">        <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">        preempt_disable(); <span class="comment">// 关闭抢占</span></span><br><span class="line">        rcu_read_lock(); </span><br><span class="line"></span><br><span class="line">        cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);  </span><br><span class="line">        <span class="keyword">if</span> (cpu &lt; <span class="number">0</span>)</span><br><span class="line">            cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">        ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);  <span class="comment">// 加入队列</span></span><br><span class="line"></span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        preempt_enable();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> qtail;</span><br><span class="line">        ret = enqueue_to_backlog(skb, get_cpu(), &amp;qtail);</span><br><span class="line">        put_cpu();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enqueue_to_backlog()</code>主要工作，就是将skb挂到一个cpu下的<code>softnet_data-&gt; input_pkt_queue</code>队列里，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enqueue_to_backlog</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> cpu,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">int</span> *qtail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> qlen;</span><br><span class="line"></span><br><span class="line">    sd = &amp;per_cpu(softnet_data, cpu);</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    rps_lock(sd);</span><br><span class="line">    <span class="keyword">if</span> (!netif_running(skb-&gt;dev))</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">    <span class="keyword">if</span> (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (qlen) &#123;</span><br><span class="line">enqueue:</span><br><span class="line">            __skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb);  <span class="comment">// 将skb加入到sd-&gt; input_pkt_queue队列</span></span><br><span class="line">            input_queue_tail_incr_save(sd, qtail);</span><br><span class="line">            rps_unlock(sd);</span><br><span class="line">            local_irq_restore(flags);</span><br><span class="line">            <span class="keyword">return</span> NET_RX_SUCCESS; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Schedule NAPI for backlog device</span></span><br><span class="line"><span class="comment">         * We can use non atomic operation since we own the queue lock</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!__test_and_set_bit(NAPI_STATE_SCHED, &amp;sd-&gt;backlog.state)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rps_ipi_queued(sd))</span><br><span class="line">                ____napi_schedule(sd, &amp;sd-&gt;backlog); <span class="comment">// napi方式处理skb</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> enqueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">    sd-&gt;dropped++;</span><br><span class="line">    rps_unlock(sd);</span><br><span class="line"></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">    atomic_long_inc(&amp;skb-&gt;dev-&gt;rx_dropped);</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line">____napi_schedule</span><br><span class="line">	list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br></pre></td></tr></table></figure>
<p>上述，就是硬中断需要做的工作，然后, 软中断<code>net_rx_action()</code>会遍历这个list，进行进一步操作。</p>
<h4 id="中断处理上，处理skb-包含两种方式："><a href="#中断处理上，处理skb-包含两种方式：" class="headerlink" title="中断处理上，处理skb,包含两种方式："></a>中断处理上，处理skb,包含两种方式：</h4><p>硬中断就是上半部，在上半部，有<code>netif_rx</code> 中对napi进行判断，在下半部的softirq (<code>net_rx_action()</code>) 中,同样对napi和非napi进行了判断 ！</p>
<ul>
<li>非NAPI<ul>
<li>非NAPI设备驱动会为其所接收的每一个帧产生一个中断事件，在高流量负载下，会花掉大量时间处理中断事件，造成资源浪费。而NAPI驱动混合了中断事件和轮询，在高流量负载下其性能会比旧方法要好。</li>
</ul>
</li>
<li>NAPI<ul>
<li>NAPI主要思想是混合使用中断事件和轮询，而不是仅仅使用中断事件驱动模型。当收到新的帧时，关中断，再一次处理完所有入口队列。从内核观点来看，NAPI方法因为中断事件少了，减少了cpu负载。</li>
</ul>
</li>
</ul>
<h4 id="默认是napi？还是非napi？"><a href="#默认是napi？还是非napi？" class="headerlink" title="默认是napi？还是非napi？"></a>默认是napi？还是非napi？</h4><p>在初始化时，默认是非napi的模式,poll函数默认是： <code>process_backlog</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">net_dev_init</span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>net_rx_action</code>中将会调用设备的poll函数, 如果没有, 就是默认的<code>process_backlog</code>函数<br><code>process_backlog</code>函数里面将skb出队列之后, <code>netif_receive_skb</code>处理此skb</p>
<h4 id="软中断中，使用net-rx-action-，处理skb"><a href="#软中断中，使用net-rx-action-，处理skb" class="headerlink" title="软中断中，使用net_rx_action()，处理skb:"></a>软中断中，使用<code>net_rx_action()</code>，处理skb:</h4><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>、ksoftirqd执行软中断函数`net_rx_action()`：</span><br><span class="line"></span><br><span class="line">* NAPI（以e1000网卡为例）：`net_rx_action<span class="function"><span class="params">()</span> -&gt;</span> e1000_clean<span class="function"><span class="params">()</span> -&gt;</span> e1000_clean_rx_irq<span class="function"><span class="params">()</span> -&gt;</span> e1000_receive_skb<span class="function"><span class="params">()</span> -&gt;</span> netif_receive_skb()`</span><br><span class="line">* 非NAPI（以dm9000网卡为例）：`net_rx_action<span class="function"><span class="params">()</span> -&gt;</span> process_backlog<span class="function"><span class="params">()</span> -&gt;</span> netif_receive_skb()`</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、网卡驱动通过`netif_receive_skb()`将`sk_buff`上送协议栈</span><br></pre></td></tr></table></figure>
<p>最后，通过<code>netif_receive_skb()</code>, 将skb送上协议栈；</p>
<p>软中断中，对napi和非napi的处理： <code>process_backlog</code></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">net_rx_action</span><br><span class="line">	process_backlog</span><br><span class="line">		<span class="variable">__netif_receive_skb</span></span><br><span class="line">			<span class="variable">__netif_receive_skb_core</span></span><br></pre></td></tr></table></figure>
<h4 id="非NAPI-vs-NAPI"><a href="#非NAPI-vs-NAPI" class="headerlink" title="非NAPI vs NAPI"></a>非NAPI vs NAPI</h4><ul>
<li>(1) 支持NAPI的网卡驱动必须提供轮询方法<code>poll()</code>。</li>
<li>(2) 非NAPI的内核接口为<code>netif_rx()</code>，<br>NAPI的内核接口为<code>napi_schedule()</code>。</li>
<li>(3) 非NAPI使用共享的CPU队列<code>softnet_data-&gt;input_pkt_queue</code>，<br>NAPI使用设备内存(或者设备驱动程序的接收环)。</li>
</ul>
<p><img alt="img" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/970272-20190514155747887-345139752.png"></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h4><figure class="highlight c"><figcaption><span>arch/cris/drivers/ethernet.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_OF_RX_DESC     64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_OF_TX_DESC     256</span></span><br><span class="line"><span class="keyword">static</span> etrax_eth_descr RxDescList[NBR_OF_RX_DESC] __attribute__ ((aligned(<span class="number">32</span>)));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> etrax_eth_descr TxDescList[NBR_OF_TX_DESC] __attribute__ ((aligned(<span class="number">32</span>)));</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>arch/cris/drivers/ethernet.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">etrax_eth_descr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	etrax_dma_descr descr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>* <span class="title">skb</span>;</span></span><br><span class="line">&#125; etrax_eth_descr;</span><br></pre></td></tr></table></figure>
<p>要记住，对于DMA而言，其数据传输不会经过MMU，因此需要一个真实的物理地址，而不是一个虚拟地址。所以，在 <code>extrax_dma_descr</code> 结构体中的 <code>buf/next</code> 指针字段都是 <code>unsigned long</code> 类型，而不是 <code>void *</code>类型。</p>
<figure class="highlight c"><figcaption><span>include/asm-cris/svinto.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">etrax_dma_descr</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short sw_len;                <span class="comment">/* 0-1 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> short ctrl;                  <span class="comment">/* 2-3 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  next;                  <span class="comment">/* 4-7 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  buf;                   <span class="comment">/* 8-11 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> short hw_len;                <span class="comment">/* 12-13 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  status;                <span class="comment">/* 14 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  fifo_len;              <span class="comment">/* 15 */</span></span><br><span class="line">&#125; etrax_dma_descr;</span><br></pre></td></tr></table></figure>
<p>关于这几个字段的含义解释如下：</p>
<ul>
<li>sw_len：表明这个DMA描述符指向的DMA Buffer的空间大小</li>
<li>ctrl：包含了这个DMA Channel的控制信息</li>
<li>next：指向在DMA RingBuffer List中的下一个DMA描述符</li>
<li>buf：指向这个DMA描述符拥有的DMA Buffer的开始地址，这是数据在接收和发送所在的实际地址</li>
<li>hw_len：表明这个DMA描述符指向的DMA Buffer的物理空间大小，它与<code>sw_len</code>大小不一样，因为它还会包含一些控制字段</li>
<li>status：状态/控制字段，比如可以为 <code>d_eop</code>表明这个DMA描述符是最后一个packet。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;                          <span class="comment">/* Available in:  */</span></span><br><span class="line">	d_eol      = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),  <span class="comment">/* flags          */</span></span><br><span class="line">	d_eop      = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),  <span class="comment">/* flags &amp; status */</span></span><br><span class="line">	d_wait     = (<span class="number">1</span> &lt;&lt; <span class="number">2</span>),  <span class="comment">/* flags          */</span></span><br><span class="line">	d_int      = (<span class="number">1</span> &lt;&lt; <span class="number">3</span>),  <span class="comment">/* flags          */</span></span><br><span class="line">	d_txerr    = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>),  <span class="comment">/* flags          */</span></span><br><span class="line">	d_stop     = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>),  <span class="comment">/*         status */</span></span><br><span class="line">	d_ecp      = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>),  <span class="comment">/* flags &amp; status */</span></span><br><span class="line">	d_pri      = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">/* flags &amp; status */</span></span><br><span class="line">	d_alignerr = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>),  <span class="comment">/*         status */</span></span><br><span class="line">	d_crcerr   = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)   <span class="comment">/*         status */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Initilization"><a href="#Initilization" class="headerlink" title="Initilization"></a>Initilization</h4><p>作为一个网络设备，<code>etrax</code> 的初始化方法与其他网络设备基本一致，具体可以参考 <a href="../../">Linux 网络设备</a> 。具体而言，其通过 <code>etrax_ethernet_init</code> 函数来初始化设备。首先通过调用 <code>ether_setup</code> 来设置与以太网协议相关的参数。接下来需要初始化DMA描述符中的接收与发送 Ring Buffer。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init</span><br><span class="line">etrax_ethernet_init(struct net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">	ether_setup(dev);</span><br><span class="line">  ...</span><br><span class="line">	dev-&gt;<span class="built_in">open</span>               = e100_open;</span><br><span class="line">	dev-&gt;hard_start_xmit    = e100_send_packet;</span><br><span class="line">	dev-&gt;<span class="built_in">stop</span>               = e100_close;</span><br><span class="line">	dev-&gt;get_stats          = e100_get_stats;</span><br><span class="line">  ...</span><br><span class="line">	<span class="comment">/* Initialise receive descriptors */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBR_OF_RX_DESC; i++) &#123;</span><br><span class="line">		RxDescList[i].skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE);</span><br><span class="line">		RxDescList[i].descr.ctrl   = <span class="number">0</span>;</span><br><span class="line">		RxDescList[i].descr.sw_len = MAX_MEDIA_DATA_SIZE;</span><br><span class="line">		RxDescList[i].descr.next   = virt_to_phys(&amp;RxDescList[i + <span class="number">1</span>]);</span><br><span class="line">		RxDescList[i].descr.buf    = virt_to_phys(RxDescList[i].skb-&gt;data);</span><br><span class="line">		RxDescList[i].descr.status = <span class="number">0</span>;</span><br><span class="line">		RxDescList[i].descr.hw_len = <span class="number">0</span>;</span><br><span class="line">             </span><br><span class="line">		prepare_rx_descriptor(&amp;RxDescList[i].descr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RxDescList[NBR_OF_RX_DESC - <span class="number">1</span>].descr.ctrl   = d_eol;</span><br><span class="line">	RxDescList[NBR_OF_RX_DESC - <span class="number">1</span>].descr.next   = virt_to_phys(&amp;RxDescList[<span class="number">0</span>]);</span><br><span class="line">	rx_queue_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize transmit descriptors */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBR_OF_TX_DESC; i++) &#123;</span><br><span class="line">		TxDescList[i].descr.ctrl   = <span class="number">0</span>;</span><br><span class="line">		TxDescList[i].descr.sw_len = <span class="number">0</span>;</span><br><span class="line">		TxDescList[i].descr.next   = virt_to_phys(&amp;TxDescList[i + <span class="number">1</span>].descr);</span><br><span class="line">		TxDescList[i].descr.buf    = <span class="number">0</span>;</span><br><span class="line">		TxDescList[i].descr.status = <span class="number">0</span>;</span><br><span class="line">		TxDescList[i].descr.hw_len = <span class="number">0</span>;</span><br><span class="line">		TxDescList[i].skb = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TxDescList[NBR_OF_TX_DESC - <span class="number">1</span>].descr.ctrl   = d_eol;</span><br><span class="line">	TxDescList[NBR_OF_TX_DESC - <span class="number">1</span>].descr.next   = virt_to_phys(&amp;TxDescList[<span class="number">0</span>].descr);</span><br><span class="line">        </span><br><span class="line">	<span class="comment">/* Initialise initial pointers */</span></span><br><span class="line"></span><br><span class="line">	myNextRxDesc  = &amp;RxDescList[<span class="number">0</span>];</span><br><span class="line">	myLastRxDesc  = &amp;RxDescList[NBR_OF_RX_DESC - <span class="number">1</span>];</span><br><span class="line">	myPrevRxDesc  = &amp;RxDescList[NBR_OF_RX_DESC - <span class="number">1</span>];</span><br><span class="line">	myFirstTxDesc = &amp;TxDescList[<span class="number">0</span>];</span><br><span class="line">	myNextTxDesc  = &amp;TxDescList[<span class="number">0</span>];</span><br><span class="line">	myLastTxDesc  = &amp;TxDescList[NBR_OF_TX_DESC - <span class="number">1</span>];</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Initialization-of-DMA-Transmit-Ring-Buffers"><a href="#Initialization-of-DMA-Transmit-Ring-Buffers" class="headerlink" title="Initialization of DMA Transmit Ring Buffers"></a>Initialization of DMA Transmit Ring Buffers</h5><h5 id="Initialization-of-DMA-Receive-Ring-Buffers"><a href="#Initialization-of-DMA-Receive-Ring-Buffers" class="headerlink" title="Initialization of DMA Receive Ring Buffers"></a>Initialization of DMA Receive Ring Buffers</h5><p>中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">e100rx_interrupt(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs * regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *)<span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> irqbits = *R_IRQ_MASK2_RD;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (irqbits &amp; IO_STATE(R_IRQ_MASK2_RD, dma1_eop, active)) &#123;</span><br><span class="line">		<span class="comment">/* acknowledge the eop interrupt */</span></span><br><span class="line"></span><br><span class="line">		*R_DMA_CH1_CLR_INTR = IO_STATE(R_DMA_CH1_CLR_INTR, clr_eop, <span class="keyword">do</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check if one or more complete packets were indeed received */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (*R_DMA_CH1_FIRST != virt_to_phys(myNextRxDesc)) &#123;</span><br><span class="line">			<span class="comment">/* Take out the buffer and give it to the OS, then</span></span><br><span class="line"><span class="comment">			 * allocate a new buffer to put a packet in.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			e100_rx(dev);</span><br><span class="line">			((struct net_local *)dev-&gt;priv)-&gt;stats.rx_packets++;</span><br><span class="line">			<span class="comment">/* restart/continue on the channel, for safety */</span></span><br><span class="line">			*R_DMA_CH1_CMD = IO_STATE(R_DMA_CH1_CMD, cmd, restart);</span><br><span class="line">			<span class="comment">/* clear dma channel 1 eop/descr irq bits */</span></span><br><span class="line">			*R_DMA_CH1_CLR_INTR =</span><br><span class="line">				IO_STATE(R_DMA_CH1_CLR_INTR, clr_eop, <span class="keyword">do</span>) |</span><br><span class="line">				IO_STATE(R_DMA_CH1_CLR_INTR, clr_descr, <span class="keyword">do</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/* now, we might have gotten another packet</span></span><br><span class="line"><span class="comment">			   so we have to loop back and check if so */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="Rx Ring Buffer Initialized" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-09_rx-ring-buffer-initialized.png"></p>
<figure class="highlight c"><figcaption><span>arch/cris/drivers/ethernet.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">e100_rx(struct net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">	length = myNextRxDesc-&gt;descr.hw_len - <span class="number">4</span>;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">if</span> (length &lt; RX_COPYBREAK) &#123;</span><br><span class="line">		<span class="comment">/* Small packet, copy data */</span></span><br><span class="line">		skb = dev_alloc_skb(length - ETHER_HEAD_LEN);</span><br><span class="line">    ...</span><br><span class="line">		skb_put(skb, length - ETHER_HEAD_LEN);        <span class="comment">/* allocate room for the packet body */</span></span><br><span class="line">		skb_data_ptr = skb_push(skb, ETHER_HEAD_LEN); <span class="comment">/* allocate room for the header */</span></span><br><span class="line">    ...</span><br><span class="line">		<span class="built_in">memcpy</span>(skb_data_ptr, phys_to_virt(myNextRxDesc-&gt;descr.buf), length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Large packet, send directly to upper layers and allocate new memory */</span>		 </span><br><span class="line">		skb = myNextRxDesc-&gt;skb;</span><br><span class="line">		skb_put(skb, length);</span><br><span class="line">		myNextRxDesc-&gt;skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE);</span><br><span class="line">		myNextRxDesc-&gt;descr.buf = virt_to_phys(myNextRxDesc-&gt;skb-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">	skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">	<span class="comment">/* Send the packet to the upper layers */</span></span><br><span class="line">	netif_rx(skb);</span><br><span class="line">	<span class="comment">/* Prepare for next packet */</span></span><br><span class="line">	myNextRxDesc-&gt;descr.status = <span class="number">0</span>;</span><br><span class="line">	myPrevRxDesc = myNextRxDesc;</span><br><span class="line">	myNextRxDesc = phys_to_virt(myNextRxDesc-&gt;descr.next);</span><br><span class="line"></span><br><span class="line">	rx_queue_len++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if descriptors should be returned */</span></span><br><span class="line">	<span class="keyword">if</span> (rx_queue_len == RX_QUEUE_THRESHOLD) &#123;</span><br><span class="line">		flush_etrax_cache();</span><br><span class="line">		myPrevRxDesc-&gt;descr.ctrl |= d_eol;</span><br><span class="line">		myLastRxDesc-&gt;descr.ctrl &amp;= ~d_eol;</span><br><span class="line">		myLastRxDesc = myPrevRxDesc;</span><br><span class="line">		rx_queue_len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Reception-of-Packets"><a href="#Reception-of-Packets" class="headerlink" title="Reception of Packets"></a>Reception of Packets</h4><h4 id="Transmission-of-Packets"><a href="#Transmission-of-Packets" class="headerlink" title="Transmission of Packets"></a>Transmission of Packets</h4><h2 id="IP层"><a href="#IP层" class="headerlink" title="IP层"></a>IP层</h2><h2 id="INET-Socket层"><a href="#INET-Socket层" class="headerlink" title="INET Socket层"></a>INET Socket层</h2><h2 id="BSD-Socket层"><a href="#BSD-Socket层" class="headerlink" title="BSD Socket层"></a>BSD Socket层</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>82599：<br><a href="https://www.intel.com/content/www/us/en/embedded/products/networking/82599-10-gbe-controller-datasheet.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.intel.com/content/www/us/en/embedded/products/networking/82599-10-gbe-controller-datasheet.html</a><br>网卡：<br><a href="http://blog.csdn.net/tao546377318/article/details/51602298" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/tao546377318/article/details/51602298</a><br><a href="http://blog.csdn.net/Just_Do_IT_Ye/article/details/47000383" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/Just_Do_IT_Ye/article/details/47000383</a><br>DMA：<br><a href="http://www.wowotech.net/memory_management/DMA-Mapping-api.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.wowotech.net/memory_management/DMA-Mapping-api.html</a><br><a href="http://blog.csdn.net/phunxm/article/details/9452575" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/phunxm/article/details/9452575</a><br><a href="http://blog.chinaunix.net/uid-1858380-id-3261817.html" target="_blank" rel="external nofollow noopener noreferrer">http://blog.chinaunix.net/uid-1858380-id-3261817.html</a><br><a href="http://www.elecfans.com/book/232/" target="_blank" rel="external nofollow noopener noreferrer">http://www.elecfans.com/book/232/</a><br>协议栈收发包过程：<br><a href="https://segmentfault.com/a/1190000008836467" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000008836467</a><br><a href="https://segmentfault.com/a/1190000008926093" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000008926093</a><br>NAPI：<br><a href="http://blog.csdn.net/zhangskd/article/details/21627963" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/zhangskd/article/details/21627963</a></p>
<p><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/</a><br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/</a><br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/</a></li>
</ul>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://wiki.linuxfoundation.org/networking/kernel_flow" target="_blank" rel="external nofollow noopener noreferrer">https://wiki.linuxfoundation.org/networking/kernel_flow</a></li>
<li><a href="http://blog.chinaunix.net/uid-24148050-id-464587.html" target="_blank" rel="external nofollow noopener noreferrer">http://blog.chinaunix.net/uid-24148050-id-464587.html</a></li>
<li><a href="https://www.shuzhiduo.com/A/MyJx3Qq1zn/" target="_blank" rel="external nofollow noopener noreferrer">https://www.shuzhiduo.com/A/MyJx3Qq1zn/</a></li>
<li><a href="https://blog.csdn.net/yangguosb/article/details/103562983" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/yangguosb/article/details/103562983</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员王小波</title>
    <url>/posts/c835f157/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十四期，这一期我要聊一聊「王小波」。<code>20200411</code>是王小波逝世 23 周年祭日，我们对他的第一印象是他那奇妙诡谲的小说，是他那汪洋恣肆的杂文，是他和李银河的爱情故事。我依稀记得他写过自己的软件，直到今天我看到<a href="http://91biji.com/social/leon/framebook/notes/note/9174/" target="_blank" rel="external nofollow noopener noreferrer">这个</a>，我开始了对王小波的重新认识。他是一个真正的斜杠青年，比我上次说到的 <a href="https://www.linkedin.com/in/damienriehl" target="_blank" rel="external nofollow noopener noreferrer">Damien Riehl</a> 老哥还要厉害。</p>
<a id="more"></a>
<h2 id="斜杠青年"><a href="#斜杠青年" class="headerlink" title="斜杠青年"></a>斜杠青年</h2><p>这是我在维基百科上看到的他的经历：</p>
<blockquote>
<ul>
<li>1952年5月13日出生于北京一个知识分子家庭。</li>
<li>1968～1970年云南<strong>农场知青</strong>。这段经历成为他最著名的作品《黄金时代》的背景。</li>
<li>1971～1972年山东牟平插队；后作<strong>民办教师</strong>。</li>
<li>1972～1973年北京牛街<strong>教学仪器厂工人</strong>。</li>
<li>1974～1978年北京西城区<strong>半导体厂工人</strong>。工人生活是他《革命时期的爱情》等小说的写作背景。</li>
<li>1977年与当时在《光明日报》担任编辑的李银河相识相恋，后结合。</li>
<li>1980年王小波和李银河结婚，同年发表处女作《地久天长》。</li>
<li>1978～1982年<strong>中国人民大学贸易经济系本科学生</strong>。就读于贸易经济商品学专业。</li>
<li>1982～1984年中国人民大学一分校教师。开始写作《黄金时代》。</li>
<li>1984～1988年<strong>美国匹兹堡大学东亚研究中心研究生</strong>，获硕士学位。开始写作以唐传奇为蓝本的小说，其间得到许倬云先生的指点。</li>
<li>在美留学期间，游历了美国各地，并利用1986年暑假游历了西欧诸国。</li>
<li>1988～1991年<strong>北京大学社会学系讲师</strong>。</li>
<li>1991～1992年<strong>中国人民大学会计系讲师</strong>教授统计学。</li>
<li>1992～1997年自由撰稿人，他的唯一一部电影剧本《东宫西宫》获阿根廷国际电影节<strong>最佳编剧奖</strong>，并且入围1997年戛纳国际电影节。</li>
<li>1997年4月11日因心脏病逝世于北京。</li>
</ul>
</blockquote>
<p>是的，仅仅只是这些经历，就已经非常惊人了：<code>知青</code>、<code>民办教师</code>、<code>半导体厂工人</code>、<code>经济学</code>、<code>社会学</code>、<code>会计</code>、<code>编剧</code>、<code>小说家</code>。但是，神奇的王小波并不止步于此，看看他自己的描述：</p>
<blockquote>
<p>我现在既不是化学家，也不是数学家，更不是物理学家。我靠写文章为生，与科技绝缘——只是有时弄弄计算机。<strong>这个行当我会得不少，从最低等的汇编语言到最新潮的C++全会写，硬件知识也有一些。</strong>但从我自己的利益来看，我还不如一点都不会，省得整夜不睡，鼓捣我的电脑，删东加西，最后把整个系统弄垮，手头又没有软件备份。</p>
</blockquote>
<p>是的，他不仅仅在人文社科上作出了很多的成绩，还是一个理科 Geek，精通<strong>统计学</strong>，软硬兼修的程序员。为了写文章，他先是学会了FORTRAN，汇编，C等各种语言，接着又要学习数据结构，算法的相关知识，还有编译原理。在做出了自己的中文编辑器和输入法后，他觉得写软件可以赚钱，写小说同样也可以赚钱。</p>
<p>这是知乎上的一个评论：</p>
<blockquote>
<p>王小波可以算的上是个GEEK。大学学的贸易，后来又学化学，再后来转到了数学系。他的同学形容他解数学题就像杀猪一样，特别来劲，一道一道解决，那感觉可能就像打CS拿人头一样爽。不过解多了也觉得没意思。</p>
<p> 王小波小说里的男主角基本都是理工男，除了天天意淫还有一些奇怪的想法。其中一些还有自己的发明，比如《未来世界》里的王二是个工程师，整天想着和单位一起研制的永动机，还有《红拂夜奔》里的李靖发明过一个巨大的开跟号机器，在战场上，这台机器运转起来挥舞着杠杆边开跟攻击敌人，有的人死在根号3下，有的人倒在了根号5下。这些都只有GEEK才会想得出来。</p>
</blockquote>
<h2 id="程序员时间线"><a href="#程序员时间线" class="headerlink" title="程序员时间线"></a>程序员时间线</h2><p>下面是王小波和他朋友的书信中关于计算机内容的汇总。</p>
<h3 id="1988-12"><a href="#1988-12" class="headerlink" title="1988.12"></a>1988.12</h3><blockquote>
<p>回来之前我曾往人大一分校计算机站写过一封信，问他们可要带什么软件，主管的工程师回了封信，我没收到。回来之后人家还提到此事。现在国内软件一面混乱，又逐渐有形成市场之势。首先以年兄学统计这一事实来看，回来做事非有会用的软件不可。<strong>Macintosh根本就没打进中国市场</strong>，你非带几个可用的IBM微机软件回来不可。至于什么机器上能使倒不必太担心。我这个狗屁计算机室，IBMPS/2就有二台。AT机也不少。SAS SPSS Statistx都有，可代表国内上等一般统计微机房的水平，可就是少了一种宜于作统计的语言。年兄如有APL(A Programming Language)之IBM微机本，可给我寄copy来。我在美还有一个户头，连manual复印费一并写支票给你们。Glim我也没有，如年兄有便人可捎来。邮寄太贵，能省就省吧。</p>
</blockquote>
<ul>
<li><strong>Macintosh</strong> 在 1984 年1月24日发布，到 1988 年还没打开市场</li>
<li>那个时候，王小波用的还是 IBM PS/2 和 IBM PC/AT，AT机1984 年发布，他创造了 PC（Personal Computer）的概念</li>
<li>SPSS 是 IBM 1984 年推出的统计分析软件，迄今仍在被广泛使用。SAS，Statistx 也同样是那个时代推出的软件。</li>
<li>APL是哈佛大学的肯尼斯·艾佛于 1962 年设计开发，为此他获得了 1979 年的图灵奖。</li>
</ul>
<h3 id="1990-01"><a href="#1990-01" class="headerlink" title="1990.01"></a>1990.01</h3><blockquote>
<p>我现在正给北大社会学所做统计，手上除<strong>SPSS</strong>没有可用的软件，国内这方面很差。我现在会用<strong>FORTRAN</strong>，编统计程序不方便。闻兄谈起你们用S语言，不知是否好用。工具书也不知好找不。不管好歹，烦兄找个拷贝给我，要就算了。照我看只要能解决各种<strong>矩阵运算</strong>就够：当然也要有各种<strong>分布函数</strong>。反正也是瞎胡混，我就算努把力，少混点吧。</p>
</blockquote>
<ul>
<li>FORTRAN是世界上第一个被正式推广使用的高级语言，1954年被提出来。</li>
<li>S 语言是贝尔实验室的John Chambers等于1976年共同开发的一种用来进行统计分析的解释型语言，R 语言被认为是S 语言的一个分支。</li>
</ul>
<h3 id="1990-05"><a href="#1990-05" class="headerlink" title="1990.05"></a>1990.05</h3><blockquote>
<p>晓阳到底也加入了IBM的行列。照我看，苹果机还是买不得。因为IBM-PC的兼容机队伍庞大。INTEL又总能推出新一代CPU，将来还有大发展。买微机钱的投资是大事，时间、精力投资更为巨大，买<strong>386兼容机</strong>是明智之举。   我最近可能调入人大，投奔班长。最近胡思乱想想出了个理论来，还没认真推导，大抵是设立多个Dummy(两分变量)构成的<strong>联合分布</strong>，其合计样本点构成一球面，点到点的距离以总误差计算。所以一样本点的对点就是它的否，误差最大。其余的正在想。</p>
</blockquote>
<ul>
<li>1985年，Intel 386 CPU 推出</li>
<li>1989年，Intel 486 CPU 推出</li>
</ul>
<h3 id="1991-02"><a href="#1991-02" class="headerlink" title="1991.02"></a>1991.02</h3><blockquote>
<p>兄谈及IBM中文软件不可用，估计是图像版有问题，可至有Color Monitor之机器上一试。Mac机国内亦有，唯不及美国多也。</p>
</blockquote>
<h3 id="1991-03"><a href="#1991-03" class="headerlink" title="1991.03"></a>1991.03</h3><blockquote>
<p>你寄来的严氏2.0A我也收到，还没用。因为一者是3盘要倒，二者我自己写的WK也有重大进展。我也自做了词组功能，是棵<strong>B树</strong>，<strong>我觉得自写的软件自用，感觉是最好的</strong>。词组用处不是很大，主要用于定义人地名等专有名词，但是严氏软件对我还是有重大启示，拼音加四声是个极好的主意，写起东西来声韵铿锵，与其他软件大不一样。自写一遍，从分页到编辑键分配，都能合乎自家习惯，不是存心狗尾续貂也。如能见到严氏，可代为致意。</p>
</blockquote>
<ul>
<li>是的，B 树，你没看错，王小波将 B 树用于词组功能</li>
<li>1991 年就自己开发中文输入法软件，那年雷军刚刚毕业来到北京，认识求伯君</li>
</ul>
<h3 id="1991-05"><a href="#1991-05" class="headerlink" title="1991.05"></a>1991.05</h3><blockquote>
<p>前次寄来软件，上机一试发现<strong>非有浮点处理机</strong>不能运转。因为缺少软件，国内机器一般不装<strong>协处理机</strong>，冷不丁撞出您这一件来，搞得不大有办法。</p>
<p>闲着没事搞了个发明。原有中文软件是用线扫描方式出汉字。我做了一个用调整字模发生器方法出汉字的系统，自以为很优越，可惜还未找到用户。用此法可以很容易地在西文软件上出中文窗口，还在SPSS上加了几句骂娘的话。</p>
</blockquote>
<h3 id="1991-09"><a href="#1991-09" class="headerlink" title="1991.09"></a>1991.09</h3><blockquote>
<p>晓阳托人带来软件，周转很多日才到手里，软盘有些污损，坏一片烂一套，不可用矣。但是十分感念晓阳的好意。去年托人带来的中文软件(严氏By×)，我用着尚好，而且又用C语言仿编了一个，程序是我的，拼音字典是人家的，执此招摇撞骗，骗了一些钱。干这个事，熟悉了<strong>C语言</strong>，都是拜小阳所赐。</p>
<p><strong>不过现在我对微机已无兴趣，因为发现写小说也可赚到钱。</strong></p>
</blockquote>
<h3 id="1992-01"><a href="#1992-01" class="headerlink" title="1992.01"></a>1992.01</h3><blockquote>
<p><strong>编译程序</strong>一盘(有说明书，见shou)，<strong>源程序</strong>一盘。我的音典与严氏同名内容不同。功能上与严氏的近似，但是多了改进拼音字典的功能。按F4后可以把拼音重定义。也可加字，在拼音拣字时，按enter，就进入国标拣字，拣到的字加入字典。这个软件由五个c语言(另有两个头文件)和一个汇编语言文件组成，可用<strong>turboc</strong>编译，但是汇编部分不必重汇了，可以把<strong>汇编文件</strong>写成的部分形成的obj(我的磁盘上叫wk5.obj)放到硬盘上，与其它c语言文件分开，用turboc的<code>command line</code>编译器编一下，命令如下:  <code>tcc-mc-ewka:wk*.ca:wk5.obj graphics.lib</code>  形成wk.exe，但是必须有yindian，cclib，egavga.bgi三文件支持才工作。<em>.bgi是图象板参数表，可以包括到</em>.exe内的。但是要改改程序。你的机器好。我还用个老掉牙的XT机，简直落伍了。turbo.c你一定能找到。假如你用过其它c软件，有一点要提醒你，turbo.c有一种极讨厌的特性，就是你在一个函数内<strong>alloc</strong>的内存，退出该函数时不会<strong>自动释放</strong>；还有一点也很糟，就是模型问题，在大模型下写的程序，到了小模型上一概不能用，我的程序是在<strong>compact</strong>模型下写的，就不能用small来编译，这两条是可以气死人的。据说可以用<strong>far，near之类的前缀</strong>说明指针，其实是屁用不管。我干了一年多c，得到的结论是微机c还不能使人快乐，有时叫人怀念汇编。   f1是提示键。我的打印机有汉卡，F5你恐不能用。这个打印机是人家借给我的，性能非常之好，(美国amt-525)；但是不知能用多久。这个程序我还在修改中。与严氏的软件比，在硬的方面的优点是达到了很好的紧凑性，现在编译后是55k，扩展余地大。缺点是图象更新没他的快(在我的老爷机上可以看出区别)，不知他是怎么搞的，我很佩服。<strong>我的图像部分也是汇编写的，反复优化，也达不到他的水平，不得不承认技不如人。</strong>另外，<strong>磁盘文件的处理</strong>，我也写不好。还要请阳公指教。</p>
</blockquote>
<ul>
<li>Turbo C是美国Borland公司1987年推出的一款集成开发环境（IDE）</li>
</ul>
<h3 id="1992-07"><a href="#1992-07" class="headerlink" title="1992.07"></a>1992.07</h3><blockquote>
<p>小阳的信又用MAC机，看来你的机器不少，可喜可贺。<strong>我这一台老PC/ⅩT，用了六年换不下来，太惭愧，近来老想狠狠心，花几百块买个286主板换上，老婆又不同意，真是要命了。</strong>   我自编软件又有进展，把一部分程序<strong>递归化</strong>，出现了很新奇的特征。等我换了286，就需要能<strong>写虚址方式</strong>的C语言了，未知晓阳能否找到？</p>
</blockquote>
<h3 id="1992-09"><a href="#1992-09" class="headerlink" title="1992.09"></a>1992.09</h3><blockquote>
<p>你给我寄的软件因为是三寸盘，在这里很不通用，所以我也没用。盘上有什么，至今不知。我用C编的软件已经用熟，并做出了各种写小说的工具，别人的软件已不用了。现在主要是写书赚钱。从今年初开始写长篇，首先做了写长篇的专用软件，现在基本<strong>调通</strong>，开始写了。</p>
<p><strong>递归论</strong>我没学过。我哥哥大概懂一些。我和你说的大概是计算机内的<strong>递归算法</strong>。我在美国读的书都是关于机器的。有关<strong>算法</strong>、<strong>数据结</strong>构等等，全在国内看的，也不知英文叫什么。在C语言里是指在一个函数(相当于其他语言的subprocedure)内调用同一个函数。一般程序书里都能查到。   所谓保护方式，是指<strong>286 protected mode</strong>。因为一般的IBM机器，不管是386，486，只要是<strong>dos操作系统</strong>，实际能操作的内存只是640K，相当于一个较快的PC机。想要用到640K以外的<strong>extend memory</strong>，只有用protect mode才能用上，我打算换286，还是想用多于640K的内存。这就要有比现在的C更好的编程工具。当然，我也不一定要用到保护方式，有各种EMS软件，不过我还是想往多里捞摸，多留一手。MSC我只见过5.0版，7.0版的性能还不知道。不过我猜现在流行的C应该有这些手段，到这时候了。   我有一段时间很关心<strong>personal computer</strong>的发展，属于想玩玩不到过干瘾的那种。这路东西的发展都是由处理机片芯的发展开始。从8088到286，386看文献就知道快了很多。从实用的角度来看，286多了虚存保护，386又多了很<strong>多用户多任务</strong>手段。<strong>486据说把386，387，和64K的高速缓存集成到一个片子上，不但整数运算快，浮点也快多了。不过不做科学运算，意义就小了。</strong>586还不知道是个什么东西，想必有惊人之处。不过到了我手上用作文字处理，也是暴殄天物。我有个286用用就算行了。太好的东西我也使不出来。   听说美国微机多媒体搞得甚火，微机接电视，音响，video等等。这玩艺听上去倒是蛮有意思的。</p>
</blockquote>
<ul>
<li>微软的windows 95直到1995年发布以后，才成为了真正意义上的图形界面的操作系统，有了图形用户界面</li>
<li>Linux 的第一个版本在 1991 年发布</li>
<li>王小波那年用的还是 DOS 操作系统</li>
</ul>
<h3 id="1992-10"><a href="#1992-10" class="headerlink" title="1992.10"></a>1992.10</h3><blockquote>
<p>当时不知道你为什么这么干，原来是机器坏了。居然叫人敲去150dollars，老兄真是有钱。这种事叫我遇上，肯定自己修了。<strong>现在的微机修理都是换线换板，机器一坏，先找块表量量是不是电源坏了。</strong>只要不是电源坏，估摸是哪部分不好，就去买块版换上。送出去也是这么修，还要敲你手工钱。我看150什么板子都能买来。万一自己故障没找对，就说人家的板子不好，退给他。我的机器里什么牌子的板子都有了，都像你那样挨人敲，还玩得起吗？这么弄，还能有点乐趣。比方说，你爱486，就去买块486主机板，把自己的主机板换下来，这种搞法不怕杂牌水货，坏了再换，反正便宜。我的问题在于这么搞都搞不起。</p>
<p>我现在从我哥哥那里弄了一套<strong>TurboC++</strong>，软件方面暂时没有问题了。只是286还没买，因为听说中国要加入<strong>关贸总协定</strong>，这类东西要掉价；有钱先买家具。无论如何，我是用不到486的，因为要286也不是为了追求高速度，主要是要解决内存问题。<strong>我现在软件写得出神入化，大概8088上能做到的一切，我都做到了</strong>。自己觉得该告一段落，去写小说了。</p>
</blockquote>
<ul>
<li>是的，王小波对计算机硬件也有很多了解</li>
<li>C++ 90 年代才有了第一次标准化，王小波 92 年开始玩 C++了。</li>
</ul>
<h3 id="1992-11"><a href="#1992-11" class="headerlink" title="1992.11"></a>1992.11</h3><blockquote>
<p>先有朋友把你寄来的软盘倒了一下，看看是数字，就没动它。记得原来有一套干这种事的软件，是你给的，但是盘坏过，再也找不到了。今天写了个小程序倒出来，拜读了大作，甚是有趣。</p>
</blockquote>
<h3 id="1993-03"><a href="#1993-03" class="headerlink" title="1993.03"></a>1993.03</h3><blockquote>
<p>我终于下决心买了一台286，这些日子在改造软件，作了不少汇编工作。其核心是它在<strong>虚拟保护方式(virtual address protected)</strong>下工作，以便利<strong>扩展内存(expanded memory)</strong>。现在终于完全成功，我的软件现在可以编辑400K长的文件，可以把一部长篇小说全部调到内存里编写了。只可惜我这个机器还是低级，只有<strong>1M RAM</strong>，并且没有硬盘，所以也就到此为止了。这个程序的缺点是太低级，有大量对<strong>端口(port)</strong>的操作，虽然效率是高的，兼容性不会太好。我的XT机给山妻用了，算起来我用那台机器已经七年，就如一位老友，骤然割爱，如心头割肉。</p>
</blockquote>
<h3 id="年份不详"><a href="#年份不详" class="headerlink" title="年份不详"></a>年份不详</h3><blockquote>
<p><strong>我们的pc机还没有和Internet连上。本来中国有几个国内网发展得很快，现在又出了问题，谁要上Internet，必须到有关部门去登记，留个案底，以备当局监控，很有一点监狱的气味。</strong>我还不想找这份麻烦，再说，通过Chinanet联网，每月也要交七八百的月费，我也没有这么多的钱。既然×反对信息时代，我们就不进这个时代罢，有什么法子。所以还是写信好了。</p>
</blockquote>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>我是跪着一条一条读着一条有一条的书信的，里面出现了太多太多的熟悉的名词。涉及到基础的数据结构 B 树，涉及到基本的编程语言，涉及到从 8086 到 80286 兼容的保护模式，扩展内存，涉及到统计学分布知识。</p>
<p>这些，都是媒体上广为传播他和李银河美丽爱情同时发生的事情（为什么媒体就知道炒那些爱情故事呢，王小波这么多的传奇都不说一下）</p>
<p>本科的时候草草翻过他的杂文集，当时就觉得很有趣，但是小说没太看懂。我觉得，是时候重新认识王小波了，过段时间再把他的书找回来读一读。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://91biji.com/social/leon/framebook/notes/note/9174/" target="_blank" rel="external nofollow noopener noreferrer">http://91biji.com/social/leon/framebook/notes/note/9174/</a></li>
<li><a href="https://www.zhihu.com/question/20964366" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/20964366</a></li>
</ul>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>斜杠青年</tag>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title>virtio</title>
    <url>/posts/3675eff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>四月物语</title>
    <url>/posts/43b91bee/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。</p>

    <div id="aplayer-FFsDhnLq" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="610725" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<p>最近在忙些啥？对，我在写论文，持续处于焦虑状态，期待能够早点写完，具体心情此处不表。夏天真的来了，眼见着窗外的杉树从冬日的灰冷，到春日的嫩绿，到现在的青翠。一转眼，已经在家呆了三个多月，冬日归来，到现在也不知何日返京。每天早上起来，听到窗外清脆的鸟叫声，会觉得这样每天在家的日子也很不错。但是，实际上这些天的状态并不是很好，毕业的焦虑，每天早上翻看着最新疫情的状况，期待着能够早点回到北京，早点回到正常的生活中。</p>
<p>然而，现实却告诉我，很有可能我们即将面临一种新常态了。在未来的一两年中，新冠可能将会持续潜伏在我们身边。这是一次真正引起全局性改变的疫情。作为毕业生，可以预见，北京应该会在五月份或者六月份让我们回去，可能只是收拾行李，毕业典礼之类的活动很可能都没了，真的是很难得的毕业季。</p>
<p>所有的这些，对我有什么影响？这些都是我所无力改变的现实，相比于父辈祖辈们所见识过的历史，这些都还只能算是开始。我能够做些什么呢？继续沉淀自己吧，好好的完成毕业论文，继续学习和总结。</p>
<p>等，春天。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>春天</tag>
        <tag>新冠</tag>
        <tag>新常态</tag>
      </tags>
  </entry>
  <entry>
    <title>西湖印象</title>
    <url>/posts/2f653e3b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。</p>
<p>这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。</p>
<a id="more"></a>
<h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><img alt="这天去西湖的时候，天空的云彩特别好看，再加上山峦剪影，很有感觉" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_cloud-lake.jpg"></p>
<p><img alt="在这个地方拍了会延时，发现还是日落那会拍延时更好看，这里镜头应该往前推一点" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_cloud-tower.jpg"></p>
<p><img alt="厨师帽？" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_cloud-hat.jpg"></p>
<h2 id="湖"><a href="#湖" class="headerlink" title="湖"></a>湖</h2><p><img alt="集贤亭，走到这里看到很多大爷专业设备都准备好了，经典取景地" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_pavilion.jpg"></p>
<p><img alt="不是三潭印月，拍的晚霞时的小亭子" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_tower.jpg"></p>
<p><img alt="湖边的旅游警察" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_police.jpg"></p>
<h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p><img alt="湖边喂鸽子的小女孩，这个小男孩正在看着下一张图片的场景" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_dove.jpg"></p>
<p><img alt="对，一大堆人正在喂着小松鼠，西湖边的松鼠可真多" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_squirrel.jpg"></p>
<p><img alt="前一天过来转的时候，正好下雨，碰到一对在湖边看风景的情侣，很有感觉" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-06-12_lover.jpg"></p>
<h2 id="霞"><a href="#霞" class="headerlink" title="霞"></a>霞</h2><p>傍晚的时候又拍了会延时，没带三脚架，镜头有一些晃动，下次再弄弄</p>
<iframe src="//player.bilibili.com/player.html?aid=796036715&bvid=BV1CC4y1a7iw&cid=203569493&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>西湖</tag>
        <tag>杭州</tag>
      </tags>
  </entry>
  <entry>
    <title>【普鲁斯特问卷】2020</title>
    <url>/posts/ab5f63d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? </p>
<p>作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）</p>
<a id="more"></a>
<p>话不多说，我们开始。</p>
<h3 id="你认为最完美的快乐是怎样的？"><a href="#你认为最完美的快乐是怎样的？" class="headerlink" title="你认为最完美的快乐是怎样的？"></a><strong>你认为最完美的快乐是怎样的？</strong></h3><ul>
<li>做成一件事之后的满足感。</li>
<li>和好朋友一起无所忌惮的吐槽。</li>
<li>运动完之后多巴胺分泌的快感。</li>
</ul>
<h3 id="你最希望拥有哪种才华？"><a href="#你最希望拥有哪种才华？" class="headerlink" title="你最希望拥有哪种才华？"></a><strong>你最希望拥有哪种才华？</strong></h3><p>羡慕那些拥有绝对音感的人，希望自己能够拥有音乐方面的才华。</p>
<p>最近在玩卡林巴和尤克里里，记谱对我来说真的是一件困难的事情，心手协调更是需要训练。一直觉得那些音乐创作人是很厉害的存在，自己也想要学乐器词曲，期待有一天能够创作出在音乐上自己的作品。</p>
<h3 id="你最恐惧的是什么？"><a href="#你最恐惧的是什么？" class="headerlink" title="你最恐惧的是什么？"></a><strong>你最恐惧的是什么？</strong></h3><p>快节奏的都市生活，害怕自己陷入对升职加薪追求的焦虑，而忘了自己到底想要什么。</p>
<h3 id="你目前的心境怎样？"><a href="#你目前的心境怎样？" class="headerlink" title="你目前的心境怎样？"></a><strong>你目前的心境怎样？</strong></h3><p>现在的我，身处杭州，刚刚提交毕业论文，准备着毕业答辩。将近 20 年的学生生涯即将结束，期待着顺利完成答辩，开始职场的生活。希望能够回到北京，见到那些很久没有见到的朋友。马上就要工作，开始自己独立的生活，希望自己之后的生活忙碌而有节奏，有机会的话也许可以认识我喜欢的人。</p>
<h3 id="还在世的人中你最钦佩的是谁？"><a href="#还在世的人中你最钦佩的是谁？" class="headerlink" title="还在世的人中你最钦佩的是谁？"></a><strong>还在世的人中你最钦佩的是谁？</strong></h3><p>Linus，开源软件之神。</p>
<h3 id="你认为自己最伟大的成就是什么？"><a href="#你认为自己最伟大的成就是什么？" class="headerlink" title="你认为自己最伟大的成就是什么？"></a><strong>你认为自己最伟大的成就是什么？</strong></h3><p>距今为止，没有什么伟大的成就。</p>
<p>希望自己以后能够做出一些有意义，有价值的事情。</p>
<h3 id="你自己的哪个特点让你最觉得痛恨？"><a href="#你自己的哪个特点让你最觉得痛恨？" class="headerlink" title="你自己的哪个特点让你最觉得痛恨？"></a><strong>你自己的哪个特点让你最觉得痛恨？</strong></h3><p>不够勇敢，不能勇敢地说出自己的喜欢。</p>
<h3 id="你最喜欢的旅行是哪一次？"><a href="#你最喜欢的旅行是哪一次？" class="headerlink" title="你最喜欢的旅行是哪一次？"></a><strong>你最喜欢的旅行是哪一次？</strong></h3><p>去年找完工作后，<code>Four Sum</code>一起的云南之旅。</p>
<p>经历了春天的找实习与夏天的找工作，确定完工作去向后，精神一下子放松下来，实验室的四个同学一起说走就走，去了大理和丽江。大理风光很美，苍山洱海，分外惬意；丽江古镇差强人意，玉龙雪山蓝月谷令人惊异。除了美丽的自然风光，主要还是当时四个人都轻松自在，潇洒自得。</p>
<p>大西南可以去很多次，还有大西北，期望以后有机会可以和自己喜欢的人一起去旅行。</p>
<h3 id="你最痛恨别人的什么特点？"><a href="#你最痛恨别人的什么特点？" class="headerlink" title="你最痛恨别人的什么特点？"></a><strong>你最痛恨别人的什么特点？</strong></h3><p>虚伪。</p>
<p>讨厌虚伪的客套，对真诚、聪明、对世界有热情的人自带好感。</p>
<h3 id="你最珍惜的财产是什么？"><a href="#你最珍惜的财产是什么？" class="headerlink" title="你最珍惜的财产是什么？"></a><strong>你最珍惜的财产是什么？</strong></h3><p>宝贵的时间，自由的灵魂。</p>
<h3 id="你最奢侈的是什么？"><a href="#你最奢侈的是什么？" class="headerlink" title="你最奢侈的是什么？"></a><strong>你最奢侈的是什么？</strong></h3><p>爱与被爱。</p>
<h3 id="你认为程度最浅的痛苦是什么？"><a href="#你认为程度最浅的痛苦是什么？" class="headerlink" title="你认为程度最浅的痛苦是什么？"></a><strong>你认为程度最浅的痛苦是什么？</strong></h3><p>不了解万千世界的痛苦。</p>
<h3 id="你认为哪种美德是被过高的评估的？"><a href="#你认为哪种美德是被过高的评估的？" class="headerlink" title="你认为哪种美德是被过高的评估的？"></a><strong>你认为哪种美德是被过高的评估的？</strong></h3><p>艰苦朴素，无私奉献。</p>
<p>哪里有那么多的无私，更多的是无奈与不舍。不是很喜欢新闻里面那些对于无私奉献广泛的宣传，我更喜欢那些给这些人优厚的物质与精神回报，并宣传之，比如最近的海尔救人小哥奖房的宣传我就挺喜欢的。</p>
<h3 id="你最喜欢的职业是什么？"><a href="#你最喜欢的职业是什么？" class="headerlink" title="你最喜欢的职业是什么？"></a><strong>你最喜欢的职业是什么？</strong></h3><p>工程师。</p>
<p>用自己的双手构建自己的世界。</p>
<h3 id="你对自己的外表哪一点不满意？"><a href="#你对自己的外表哪一点不满意？" class="headerlink" title="你对自己的外表哪一点不满意？"></a><strong>你对自己的外表哪一点不满意？</strong></h3><p>整体上挺满意的，就是之前脸上的痘痘让我有些烦恼。</p>
<p>不过，经过最近一段时间的调养，痘痘已经基本消失啦，接下来就是消除痘印了。</p>
<h3 id="你最后悔的事情是什么？"><a href="#你最后悔的事情是什么？" class="headerlink" title="你最后悔的事情是什么？"></a><strong>你最后悔的事情是什么？</strong></h3><p>做过很多后悔的事情，最后悔的还是与人相关。在不懂事的时候，说过一些令人伤心的话，尤其是对那些爱自己的人。现在想起来那些场景，脸上依然会不由自主的发烫。</p>
<h3 id="还在世的人中你最鄙视的是谁？"><a href="#还在世的人中你最鄙视的是谁？" class="headerlink" title="还在世的人中你最鄙视的是谁？"></a><strong>还在世的人中你最鄙视的是谁？</strong></h3><p>不太好说鄙视谁，鄙视那些身在其位不谋其政的人。</p>
<h3 id="你最喜欢男性身上的什么品质？"><a href="#你最喜欢男性身上的什么品质？" class="headerlink" title="你最喜欢男性身上的什么品质？"></a><strong>你最喜欢男性身上的什么品质？</strong></h3><p>大气。</p>
<p>待人接物落落大方，不卑不亢；处理事情自信沉稳，界限分明；对个人专业熟稔明晰，对不是自己的专业充满好奇心，能够积极主动的去了解；对爱的人温柔体贴，以真心告以真心。</p>
<h3 id="你使用过的最多的单词或者是词语是什么？"><a href="#你使用过的最多的单词或者是词语是什么？" class="headerlink" title="你使用过的最多的单词或者是词语是什么？"></a><strong>你使用过的最多的单词或者是词语是什么？</strong></h3><p>哈哈哈。</p>
<h3 id="你最喜欢女性身上的什么品质？"><a href="#你最喜欢女性身上的什么品质？" class="headerlink" title="你最喜欢女性身上的什么品质？"></a><strong>你最喜欢女性身上的什么品质？</strong></h3><p>我最喜欢女性的品质，是温柔与活泼、有自己的思考、善于沟通、具有爱人与被爱的能力。</p>
<h3 id="你最伤痛的事是什么？"><a href="#你最伤痛的事是什么？" class="headerlink" title="你最伤痛的事是什么？"></a><strong>你最伤痛的事是什么？</strong></h3><p>最伤痛的事情，莫过于全然付出的真心不被对方珍视吧。</p>
<h3 id="你最看重朋友的什么特点？"><a href="#你最看重朋友的什么特点？" class="headerlink" title="你最看重朋友的什么特点？"></a><strong>你最看重朋友的什么特点？</strong></h3><p>真诚、靠谱、乐观。</p>
<p>不喜欢虚伪滑头的人，也不喜欢一直悲悲戚戚的人。</p>
<h3 id="你这一生中最爱的人或东西是什么？"><a href="#你这一生中最爱的人或东西是什么？" class="headerlink" title="你这一生中最爱的人或东西是什么？"></a><strong>你这一生中最爱的人或东西是什么？</strong></h3><p>或许是我自己？</p>
<p>我希望我自己永远能够变得更好，也希望自己能够给自己爱的人带来更多的欢乐。</p>
<h3 id="你希望以什么样的方式死去？"><a href="#你希望以什么样的方式死去？" class="headerlink" title="你希望以什么样的方式死去？"></a><strong>你希望以什么样的方式死去？</strong></h3><p>我希望自己能够平平静静的走，就像睡着了那样，不要拖累自己的孩子们，也不要因为化疗等让自己万分痛苦。</p>
<p>另外，如果年老的时候我心爱的人在我身边时，我希望她能够走在我的前面，不要留她一个人在后面。</p>
<h3 id="如果你可以改变你的家庭一件事，那会是什么？"><a href="#如果你可以改变你的家庭一件事，那会是什么？" class="headerlink" title="如果你可以改变你的家庭一件事，那会是什么？"></a><strong>如果你可以改变你的家庭一件事，那会是什么？</strong></h3><p>如果可以改变的话，希望小时候爷爷和妈妈的关系能够好一些吧。两个人都很爱我，但是却因为爷爷的一些难以改变的观念，导致他们两人关系一直很差。即使如此，妈妈在爷爷走的时候仍然贴心的照顾他，如果之前关系能够好一些，那么小时候的家庭可以说很完美吧。</p>
<p>不过这些都是已经过去的事情了，现在家里的孩子都已经长大，爷爷已经离去。虽然不是大富大贵之家，小康家庭倒也过的很好，还记得爸妈为了家里能够过的更好一些而辛苦地工作，朴素的家庭条件也给我们留下了勤恳踏实的作风。</p>
<h3 id="如果你能选择的话，你希望让什么重现？"><a href="#如果你能选择的话，你希望让什么重现？" class="headerlink" title="如果你能选择的话，你希望让什么重现？"></a><strong>如果你能选择的话，你希望让什么重现？</strong></h3><p>爱。</p>
<p>现在仍然单身一人，希望能够找到一个自己喜欢，并且她也喜欢我的人。</p>
<h3 id="你的座右铭是什么？"><a href="#你的座右铭是什么？" class="headerlink" title="你的座右铭是什么？"></a><strong>你的座右铭是什么？</strong></h3><blockquote>
<p>我将融入剧烈争斗的大人世界，要在那边孤军奋战，必须变得比任何人都坚不可摧。</p>
</blockquote>
<p>倒也不是座右铭，一直没有明确的座右铭，只是正好看到这句话比较符合当前的心境罢了。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>价值观</tag>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>网络虚拟化</title>
    <url>/posts/f07e2cff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>网络虚拟化更多关注的是数据中心网络、主机网络这样比较「细粒度」的网络，所谓细粒度，是相对来说的，是深入到某一台物理主机之上的网络结构来谈的。</p><p>如果把传统的网络看作「宏观网络」的话，那网络虚拟化关注的就是「微观网络」。网络虚拟化的目的，是要节省物理主机的网卡设备资源。从资源这个角度去理解，可能会比较好理解一点。</p><a id="more"></a>

<h2 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h2><h3 id="传统网络架构"><a href="#传统网络架构" class="headerlink" title="传统网络架构"></a>传统网络架构</h3><p>在传统网络环境中，一台物理主机包含一个或多个网卡（NIC），要实现与其他物理主机之间的通信，需要通过自身的 NIC 连接到外部的网络设施，如交换机上，如下图所示。</p>
<p><img alt="img" data-src="https://images2017.cnblogs.com/blog/431521/201712/431521-20171214124122201-325159441.png"></p>
<p>这种架构下，为了对应用进行隔离，往往是将一个应用部署在一台物理设备上，这样会存在两个问题，</p>
<ul>
<li>是某些应用大部分情况可能处于空闲状态</li>
<li>是当应用增多的时候，只能通过增加物理设备来解决扩展性问题。</li>
</ul>
<p>不管怎么样，这种架构都会对物理资源造成极大的浪费。</p>
<h3 id="虚拟化网络架构"><a href="#虚拟化网络架构" class="headerlink" title="虚拟化网络架构"></a>虚拟化网络架构</h3><p>为了解决这个问题，可以借助虚拟化技术对一台物理资源进行抽象，将一张物理网卡虚拟成多张虚拟网卡（vNIC），通过虚拟机来隔离不同的应用。</p>
<ul>
<li>针对问题 1），可以利用虚拟化层 Hypervisor 的调度技术，将资源从空闲的应用上调度到繁忙的应用上，达到资源的合理利用；</li>
<li>针对问题 2），可以根据物理设备的资源使用情况进行横向扩容，除非设备资源已经用尽，否则没有必要新增设备。这种架构如下所示。</li>
</ul>
<p><img alt="img" data-src="https://images2017.cnblogs.com/blog/431521/201712/431521-20171214124154982-781297498.png"></p>
<p>其中虚拟机与虚拟机之间的通信，由虚拟交换机完成，虚拟网卡和虚拟交换机之间的链路也是虚拟的链路，整个主机内部构成了一个虚拟的网络，如果虚拟机之间涉及到三层的网络包转发，则又由另外一个角色——虚拟路由器来完成。</p>
<p>一般，这一整套虚拟网络的模块都可以独立出去，由第三方来完成，如其中比较出名的一个解决方案就是 Open vSwitch（OVS）。</p>
<p>OVS 的优势在于它基于 SDN 的设计原则，方便虚拟机集群的控制与管理，另外就是它分布式的特性，可以「透明」地实现跨主机之间的虚拟机通信，如下是跨主机启用 OVS 通信的图示。</p>
<p><img alt="img" data-src="https://images2017.cnblogs.com/blog/431521/201712/431521-20171214124231185-514213579.png"></p>
<p>总结下来，网络虚拟化主要解决的是虚拟机构成的网络通信问题，完成的是各种网络设备的虚拟化，如网卡、交换设备、路由设备等。</p>
<p>在Linux内核中有一个网络设备管理层，处于网络设备驱动和协议栈之间，负责衔接它们之间的数据交互。驱动不需要了解协议栈的细节，协议栈也不需要了解设备驱动的细节。</p>
<p>对于一个网络设备来说，就像一个管道（pipe）一样，有两端，从其中任意一端收到的数据将从另一端发送出去。</p>
<p>比如一个物理网卡eth0，它的两端分别是内核协议栈（通过内核网络设备管理模块间接的通信）和外面的物理网络，从物理网络收到的数据，会转发给内核协议栈，而应用程序从协议栈发过来的数据将会通过物理网络发送出去。</p>
<p>那么对于一个虚拟网络设备呢？首先它也归内核的网络设备管理子系统管理，对于Linux内核网络设备管理模块来说，虚拟设备和物理设备没有区别，都是网络设备，都能配置IP，从网络设备来的数据，都会转发给协议栈，协议栈过来的数据，也会交由网络设备发送出去，至于是怎么发送出去的，发到哪里去，那是设备驱动的事情，跟Linux内核就没关系了，所以说虚拟网络设备的一端也是协议栈，而另一端是什么取决于虚拟网络设备的驱动实现。</p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>网络设备的驱动程序并不直接与内核中的协议栈交互，而是通过内核的网络设备管理模块。这样做的好处是，驱动程序不需要了解协议栈的细节，协议栈也不需要针对特定驱动处理数据包。</p>
<p>对于内核网络设备管理模块来说，虚拟设备和物理设备没有区别，都是网络设备，都能配置IP，甚至从逻辑上来看，虚拟网络设备和物理网络设备并没有什么区别，它们都类似于管道，从任意一端接收到的数据将从另外一端发送出去。比如物理网卡的两端分别是协议栈于外面的物理网络，从外面物理网络接收到的数据包会转发给协议栈，相反，应用程序通过协议栈发送过来的数据包会通过物理网卡发送到外面的物理网络。但是对于具体将数据包发送到哪里，怎么发送，不同的网络设备有不同的驱动实现，与内核设备管理模块以及协议栈没什么关系。</p>
<p>总的来说，虚拟网络设备与物理网络设备没有什么区别，它们的一端连接着内核协议栈，而另一端的行为是什么取决于不同虚拟网络设备的驱动实现。</p>
<h2 id="Tun-Tap"><a href="#Tun-Tap" class="headerlink" title="Tun/Tap"></a>Tun/Tap</h2><p>TUN/TAP虚拟网络设备一端连着协议栈，另外一端不是物理网络，而是另外一个处于用户空间的应用程序。也就是说，协议栈发给TUN/TAP的数据包能被这个应用程序读取到，当然应用程序能直接向TUN/TAP发送数据包。</p>
<p>这里简单介绍 Tun/Tap 设备的用法，关于其在内核中的实现，可以参考 <a href="../">我的另一篇文章</a> 。</p>
<p>一个典型的TUN/TAP的例子如下图所示：</p>
<p><img alt="network-device-tun-tap.jpg" data-src="https://i.loli.net/2020/01/28/yDTFvEohmQfiWz5.jpg"></p>
<p>上图中我们配置了一个物理网卡，IP为<code>18.12.0.92</code>，而tun0为一个TUN/TAP设备，IP配置为<code>10.0.0.12</code>。数据包的流向为：</p>
<ol>
<li><p>应用程序A通过socket A发送了一个数据包，假设这个数据包的目的IP地址是<code>10.0.0.22</code></p>
</li>
<li><p>socket A将这个数据包丢给协议栈</p>
</li>
<li><p>协议栈根据本地路由规则和数据包的目的IP，将数据包由给tun0设备发送出去</p>
</li>
<li><p>tun0收到数据包之后，将数据包转发给给了用户空间的应用程序B</p>
</li>
<li><p>应用程序B收到数据包之后构造一个新的数据包，将原来的数据包嵌入在新的数据包（IPIP包）中，最后通过socket B将数据包转发出去 </p>
<blockquote>
<p>Note: 新数据包的源地址变成了eth0的地址，而目的IP地址则变成了另外一个地址<code>18.13.0.91</code>.</p>
</blockquote>
</li>
<li><p>socket B将数据包发给协议栈</p>
</li>
<li><p>协议栈根据本地路由规则和数据包的目的IP，决定将这个数据包要通过eth0发送出去，于是将数据包转发给eth0</p>
</li>
<li><p>eth0通过物理网络将数据包发送出去</p>
</li>
</ol>
<p>我们看到发送给<code>10.0.0.22</code>的网络数据包通过在用户空间的应用程序B，利用<code>18.12.0.92</code>发到远端网络的<code>18.13.0.91</code>，网络包到达<code>18.13.0.91</code>后，读取里面的原始数据包，读取里面的原始数据包，再转发给本地的<code>10.0.0.22</code>。这就是<a href="https://en.wikipedia.org/wiki/Virtual_private_network" target="_blank" rel="external nofollow noopener noreferrer">VPN</a>的基本原理。</p>
<p>使用TUN/TAP设备我们有机会将协议栈中的部分数据包转发给用户空间的应用程序，让应用程序处理数据包。常用的使用场景包括数据压缩，加密等功能。</p>
<blockquote>
<p>Note: TUN和TAP设备的区别在于，TUN设备是一个虚拟的端到端IP层设备，也就是说用户空间的应用程序通过TUN设备只能读写IP网络数据包（三层），而TAP设备是一个虚拟的链路层设备，通过TAP设备能读写链路层数据包（二层）。在使用<code>ip</code>命令创建设备的时候使用<code>--dev tun</code>和<code>--dev tap</code>来区分。</p>
</blockquote>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>这里写了一个程序，它收到tun设备的数据包之后，只打印出收到了多少字节的数据包，其它的什么都不做，如何编程请参考后面的参考链接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_tun.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tun_alloc</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd, err;</span><br><span class="line">    <span class="keyword">char</span> *clonedev = <span class="string">"/dev/net/tun"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(clonedev, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    ifr.ifr_flags = flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = ioctl(fd, TUNSETIFF, (<span class="keyword">void</span> *) &amp;ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Open tun/tap device: %s for reading...\n"</span>, ifr.ifr_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tun_fd, nread;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)</span></span><br><span class="line"><span class="comment">     *        IFF_TAP   - TAP device</span></span><br><span class="line"><span class="comment">     *        IFF_NO_PI - Do not provide packet information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tun_fd = tun_alloc(IFF_TUN | IFF_NO_PI);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tun_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Allocating interface"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nread = <span class="built_in">read</span>(tun_fd, <span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>));</span><br><span class="line">        <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"Reading from interface"</span>);</span><br><span class="line">            <span class="built_in">close</span>(tun_fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read %d bytes from tun/tap device\n"</span>, nread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟设备演示"><a href="#虚拟设备演示" class="headerlink" title="虚拟设备演示"></a>虚拟设备演示</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="comment">#将上面的程序保存成tun.c，然后编译</span></span><br><span class="line">dev@debian:~$ gcc tun.c -o tun</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动tun程序，程序会创建一个新的tun设备，</span></span><br><span class="line"><span class="comment">#程序会阻塞在这里，等着数据包过来</span></span><br><span class="line">dev@debian:~$ sudo ./tun</span><br><span class="line">Open tun/tap device tun1 <span class="keyword">for</span> reading...</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="comment">#启动抓包程序，抓经过tun1的包</span></span><br><span class="line"><span class="comment"># tcpdump -i tun1</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on tun1, link-type RAW (Raw IP), capture size 262144 bytes</span><br><span class="line">19:57:13.473101 IP 192.168.3.11 &gt; 192.168.3.12: ICMP <span class="built_in">echo</span> request, id 24028, seq 1, length 64</span><br><span class="line">19:57:14.480362 IP 192.168.3.11 &gt; 192.168.3.12: ICMP <span class="built_in">echo</span> request, id 24028, seq 2, length 64</span><br><span class="line">19:57:15.488246 IP 192.168.3.11 &gt; 192.168.3.12: ICMP <span class="built_in">echo</span> request, id 24028, seq 3, length 64</span><br><span class="line">19:57:16.496241 IP 192.168.3.11 &gt; 192.168.3.12: ICMP <span class="built_in">echo</span> request, id 24028, seq 4, length 64</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------第三个shell窗口----------------------</span></span><br><span class="line"><span class="comment">#./tun启动之后，通过ip link命令就会发现系统多了一个tun设备，</span></span><br><span class="line"><span class="comment">#在我的测试环境中，多出来的设备名称叫tun1，在你的环境中可能叫tun0</span></span><br><span class="line"><span class="comment">#新的设备没有ip，我们先给tun1配上IP地址</span></span><br><span class="line">dev@debian:~$ sudo ip addr add 192.168.3.11/24 dev tun1</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认情况下，tun1没有起来，用下面的命令将tun1启动起来</span></span><br><span class="line">dev@debian:~$ sudo ip link <span class="built_in">set</span> tun1 up</span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试ping一下192.168.3.0/24网段的IP，</span></span><br><span class="line"><span class="comment">#根据默认路由，该数据包会走tun1设备，</span></span><br><span class="line"><span class="comment">#由于我们的程序中收到数据包后，啥都没干，相当于把数据包丢弃了，</span></span><br><span class="line"><span class="comment">#所以这里的ping根本收不到返回包，</span></span><br><span class="line"><span class="comment">#但在前两个窗口中可以看到这里发出去的四个icmp echo请求包，</span></span><br><span class="line"><span class="comment">#说明数据包正确的发送到了应用程序里面，只是应用程序没有处理该包</span></span><br><span class="line">dev@debian:~$ ping -c 4 192.168.3.12</span><br><span class="line">PING 192.168.3.12 (192.168.3.12) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.3.12 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3023ms</span><br></pre></td></tr></table></figure>
<h2 id="Veth"><a href="#Veth" class="headerlink" title="Veth"></a>Veth</h2><p>veth虚拟网络设备一端连着协议栈，另外一端不是物理网络，而是另一个veth设备，成对的veth设备中一个数据包发送出去后会直接到另一个veth设备上去。每个veth设备都可以被配置IP地址，并参与三层 IP 网络路由过程。</p>
<p>下面就是一个典型的veth设备对的例子：</p>
<p><img alt="network-device-veth.jpg" data-src="https://i.loli.net/2020/01/28/dOA19SeZHPLanYC.jpg"></p>
<p>我们配置物理网卡eth0的IP为<code>12.124.10.11</code>， 而成对出现的veth设备分别为veth0和veth1，它们的IP分别是<code>20.1.0.10</code>和<code>20.1.0.11</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add veth0 type veth peer name veth1</span></span><br><span class="line"><span class="comment"># ip addr add 20.1.0.10/24 dev veth0</span></span><br><span class="line"><span class="comment"># ip addr add 20.1.0.11/24 dev veth1</span></span><br><span class="line"><span class="comment"># ip link set veth0 up</span></span><br><span class="line"><span class="comment"># ip link set veth1 up</span></span><br></pre></td></tr></table></figure>
<p>然后尝试从veth0设备ping另一个设备veth1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping -c 2 20.1.0.11 -I veth0</span></span><br><span class="line">PING 20.1.0.11 (20.1.0.11) from 20.1.0.11 veth0: 28(42) bytes of data.</span><br><span class="line">64 bytes from 20.1.0.11: icmp_seq=1 ttl=64 time=0.034 ms</span><br><span class="line">64 bytes from 20.1.0.11: icmp_seq=2 ttl=64 time=0.052 ms</span><br><span class="line"></span><br><span class="line">--- 20.1.0.11 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1500ms</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在有些Ubuntu中有可能ping不通，原因是默认情况下内核网络配置导致veth设备对无法返回ARP返回包。解决办法是：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/conf/veth1/accept_local</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/conf/veth0/accept_local</span></span><br><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/net/ipv4/conf/veth0/rp_filter</span></span><br><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/net/ipv4/conf/veth1/rp_filter</span></span><br><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/net/ipv4/conf/all/rp_filter</span></span><br></pre></td></tr></table></figure>
<p>可以尝试使用tcpdump看看在veth设备对上的请求包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -n -i veth1</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on veth1, link-type EN10MB (Ethernet), capture size 458122 bytes</span><br><span class="line">20:24:12.220002 ARP, Request who-has 20.1.0.11 tell 20.1.0.10, length 28</span><br><span class="line">20:24:12.220198 ARP, Request who-has 20.1.0.11 tell 20.1.0.10, length 28</span><br><span class="line">20:24:12.221372 IP 20.1.0.10 &gt; 20.1.0.11: ICMP <span class="built_in">echo</span> request, id 18174, seq 1, length 64</span><br><span class="line">20:24:13.222089 IP 20.1.0.10 &gt; 20.1.0.11: ICMP <span class="built_in">echo</span> request, id 18174, seq 2, length 64</span><br></pre></td></tr></table></figure>
<p>可以看到在veth1上面只有ICMP echo的请求包，但是没有应答包。仔细想一下，veth1收到ICMP echo请求包后，转交给另一端的协议栈，但是协议栈检查当前的设备列表，发现本地有<code>20.1.0.10</code>，于是构造ICMP echo应答包，并转发给lo设备，lo设备收到数据包之后直接交给协议栈，紧接着给交给用户空间的ping进程。</p>
<p>我们可以尝试使用tcpdump抓取lo设备上的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -n -i lo</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 458122 bytes</span><br><span class="line">20:25:49.486019 IP IP 20.1.0.11 &gt; 20.1.0.10: ICMP <span class="built_in">echo</span> reply, id 24177, seq 1, length 64</span><br><span class="line">20:25:50.4861228 IP IP 20.1.0.11 &gt; 20.1.0.10: ICMP <span class="built_in">echo</span> reply, id 24177, seq 2, length 64</span><br></pre></td></tr></table></figure>
<p>由此可见，对于成对出现的veth设备对，从一个设备出去的数据包会直接发给另外一个设备。在实际的应用场景中，比如容器网络中，成对的veth设备对处于不同的<a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/" target="_blank" rel="external nofollow noopener noreferrer">网络命名空间</a>中，数据包的转发在不同网络命名空间之间进行，后续在介绍容器网络的时候会详细说明。</p>
<h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p><a href="https://wiki.linuxfoundation.org/networking/bridge" target="_blank" rel="external nofollow noopener noreferrer">bridge</a>一般叫网桥，它也是一种虚拟网络设备，所以具有虚拟网络设备的特征，可以配置IP、MAC地址等。与其他虚拟网络设备不同的是，bridge是一个虚拟交换机，和物理交换机有类似的功能。bridge一端连接着协议栈，另外一端有多个端口，数据在各个端口间转发是基于MAC地址。</p>
<p>bridge可以工作在二层(链路层)，也可以工作在三层（IP网路层）。默认工作在二层。默认情况下，其工作在二层，可以在同一子网内的的不同主机间转发以太网报文；当给bridge分配了IP地址，也就开启了该bridge的三层工作模式。在Linux下，你可以用<a href="https://wiki.linuxfoundation.org/networking/iproute2" target="_blank" rel="external nofollow noopener noreferrer">iproute2</a>或<code>brctl</code>命令对bridge进行管理。</p>
<p>创建bridge与创建其他虚拟网络设备类似，只需要制定type为<code>bridge</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add name br0 type bridge</span></span><br><span class="line"><span class="comment"># ip link set br0 up</span></span><br></pre></td></tr></table></figure>
<p><img alt="network-device-bridge-1.jpg" data-src="https://i.loli.net/2020/01/28/JljuUAEyNRfb6Dq.jpg"></p>
<p>但是这样创建出来的bridge一端连接着协议栈，其他端口什么也没有连接，因此我们需要将其他设备连接到该bridge才能有实际的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add veth0 type veth peer name veth1</span></span><br><span class="line"><span class="comment"># ip addr add 20.1.0.10/24 dev veth0</span></span><br><span class="line"><span class="comment"># ip addr add 20.1.0.11/24 dev veth1</span></span><br><span class="line"><span class="comment"># ip link set veth0 up</span></span><br><span class="line"><span class="comment"># ip link set veth1 up</span></span><br><span class="line"><span class="comment"># 将veth0连接到br0</span></span><br><span class="line"><span class="comment"># ip link set dev veth0 master br0</span></span><br><span class="line"><span class="comment"># 通过bridge link命令可以看到bridge上连接了哪些设备</span></span><br><span class="line"><span class="comment"># bridge link</span></span><br><span class="line">6: veth0 state UP : &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master br0 state forwarding priority 32 cost 2</span><br></pre></td></tr></table></figure>
<p><img alt="network-device-bridge-2.jpg" data-src="https://i.loli.net/2020/01/28/NCUXi4l7zBo83ev.jpg"></p>
<p>事实上，一旦br0和veth0连接后，它们之间将变成双向通道，但是内核协议栈和veth0之间变成了单通道，协议栈能发数据给veth0，但veth0从外面收到的数据不会转发给协议栈 ，同时br0的MAC地址变成了veth0的MAC地址。我们可以验证一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping -c 1 -I veth0 20.1.0.11</span></span><br><span class="line">PING 20.1.0.11 (20.1.0.11) from 20.1.0.10 veth0: 56(84) bytes of data.</span><br><span class="line">From 20.1.0.10 icmp_seq=1 Destination Host Unreachable</span><br><span class="line"></span><br><span class="line">--- 20.1.0.11 ping statistics ---</span><br><span class="line">1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms</span><br></pre></td></tr></table></figure>
<p>如果我们使用tcpdump在br0上抓包就会发现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -n -i br0</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on br0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">21:45:48.225459 ARP, Reply 20.1.0.10 is-at a2:85:26:b3:72:6c, length 28</span><br></pre></td></tr></table></figure>
<p>可以看到veth0收到应答包后没有给协议栈，而是直接转发给br0，这样协议栈得不到veth1的mac地址，从而ping不通。br0在veth0和协议栈之间数据包给拦截了。但是如果我们给br配置IP，会怎么样呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip addr del 20.1.0.10/24 dev veth0</span></span><br><span class="line"><span class="comment"># ip addr add 20.1.0.10/24 dev br0</span></span><br></pre></td></tr></table></figure>
<p>这样，网络结构就变成了下面这样：</p>
<p><img alt="network-device-bridge-3.jpg" data-src="https://i.loli.net/2020/01/28/nuKtLZyaRhXqjDp.jpg"></p>
<p>这时候再通过br0来ping一下veth1，会发现结果可以通：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping -c 1 -I br0 20.1.0.11</span></span><br><span class="line">PING 20.1.0.11 (20.1.0.11) from 20.1.0.10 br0: 56(84) bytes of data.</span><br><span class="line">64 bytes from 20.1.0.11: icmp_seq=1 ttl=64 time=0.121 ms</span><br><span class="line"></span><br><span class="line">--- 20.1.0.11 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.121/0.121/0.121/0.000 ms</span><br></pre></td></tr></table></figure>
<p>其实当去掉veth0的IP地址，而给br0配置了IP之后，协议栈在路由的时候不会将数据包发给veth0，为了表达更直观，我们协议栈和veth0之间的连接线去掉，这时候的veth0相当于一根网线。</p>
<p>在现实中，bridge常用的使用场景：</p>
<p><strong>虚拟机</strong></p>
<p>典型的虚拟机网络实现就是通过TUN/TAP将虚拟机内的网卡同宿主机的br0连接起来，这时br0和物理交换机的效果类似，虚拟机发出去的数据包先到达br0，然后由br0交给eth0发送出去，这样做数据包都不需要经过host机器的协议栈，运行效率非常高。</p>
<p><img alt="network-device-vm.jpg" data-src="https://i.loli.net/2020/01/28/u4GDayrE3c6kPxs.jpg"></p>
<p><strong>容器</strong></p>
<p>而对于容器网络来说，每个容器的网络设备单独的网络命名空间中，所以很好地不同容器的协议栈，我们在接下来的笔记中进一步讨论不同的容器实现。</p>
<p><img alt="network-device-docker.jpg" data-src="https://i.loli.net/2020/01/28/IPSwuRVbgTDKnhB.jpg"></p>
<h2 id="VxLAN"><a href="#VxLAN" class="headerlink" title="VxLAN"></a>VxLAN</h2><h2 id="IPIP"><a href="#IPIP" class="headerlink" title="IPIP"></a>IPIP</h2><p>上一篇笔记中，我们在介绍网络设备的时候了解了一种典型的通过TUN/TAP设备来实现VPN的原理，但是并没有实践TUN/TAP虚拟网络设备具体在linux中怎么发挥实际的功能。这篇笔记我们就来看看在云计算领域中一种非常典型的IPIP隧道如何TUN设备来实现。</p>
<h3 id="IPIP隧道"><a href="#IPIP隧道" class="headerlink" title="IPIP隧道"></a>IPIP隧道</h3><p>上一篇笔记中我们也提到了，TUN网络设备能将三层（IP）网络包封装在另外一个三层网络包之中，看起来通过TUN设备发送出来的数据包会像会这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MAC: xx:xx:xx:xx:xx:xx</span><br><span class="line">IP Header: &lt;new destination IP&gt;</span><br><span class="line">IP Body:</span><br><span class="line">  IP: &lt;original destination IP&gt;</span><br><span class="line">  TCP: stuff</span><br><span class="line">  HTTP: stuff</span><br></pre></td></tr></table></figure>
<p>这就是典型的IPIP隧道数据包的结构。Linux原生支持好几种不同的IPIP隧道类型，但都依赖于TUN网络设备，我们可以通过命令<code>ip tunnel help</code>来查看IPIP隧道的相关类型以及操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip tunnel help</span></span><br><span class="line">Usage: ip tunnel &#123; add | change | del | show | prl | 6rd &#125; [ NAME ]</span><br><span class="line">          [ mode &#123; ipip | gre | sit | isatap | vti &#125; ] [ remote ADDR ] [ <span class="built_in">local</span> ADDR ]</span><br><span class="line">          [ [i|o]seq ] [ [i|o]key KEY ] [ [i|o]csum ]</span><br><span class="line">          [ prl-default ADDR ] [ prl-nodefault ADDR ] [ prl-delete ADDR ]</span><br><span class="line">          [ 6rd-prefix ADDR ] [ 6rd-relay_prefix ADDR ] [ 6rd-reset ]</span><br><span class="line">          [ ttl TTL ] [ tos TOS ] [ [no]pmtudisc ] [ dev PHYS_DEV ]</span><br><span class="line"></span><br><span class="line">Where: NAME := STRING</span><br><span class="line">       ADDR := &#123; IP_ADDRESS | any &#125;</span><br><span class="line">       TOS  := &#123; STRING | 00..ff | inherit | inherit/STRING | inherit/00..ff &#125;</span><br><span class="line">       TTL  := &#123; 1..255 | inherit &#125;</span><br><span class="line">       KEY  := &#123; DOTTED_QUAD | NUMBER &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>mode</code>代表不同的IPIP隧道类型，Linux原生共支持5种IPIP隧道：</p>
<ol>
<li>ipip: 普通的IPIP隧道，就是在报文的基础上再封装成一个IPv4报文</li>
<li>gre: 通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装其他任意一种网络层协议的机制，所以对于IPv4和IPv6都适用</li>
<li>sit: sit模式主要用于IPv4报文封装IPv6报文，即IPv6 over IPv4</li>
<li>isatap: 站内自动隧道寻址协议（Intra-Site Automatic Tunnel Addressing Protocol），类似于sit也是用于IPv6的隧道封装</li>
<li>vti: 即虚拟隧道接口（Virtual Tunnel Interface），是一种IPsec隧道技术</li>
</ol>
<p>还有一些有用的参数： - ttl N 设置进入隧道数据包的TTL为N（N是一个1—255之间的数字，0是一个特殊的值，表示这个数据包的TTL值是继承(inherit)的），ttl参数的缺省值是为inherit - tos T/dsfield T 设置进入通道数据包的TOS域，缺省是inherit - [no]pmtudisc 在这个隧道上禁止或者打开路径最大传输单元发现(Path MTU Discovery)，默认打开的</p>
<blockquote>
<p>Note: nopmtudisc选项和固定的ttl是不兼容的，如果使用了固定的ttl参数，系统会打开路径最大传输单元发现( Path MTU Discovery)功能</p>
</blockquote>
<h3 id="one-to-one"><a href="#one-to-one" class="headerlink" title="one-to-one"></a>one-to-one</h3><p>我们首先以最基本的one-to-one的IPIP隧道模式为例来介绍如何在linux中搭建IPIP隧道来实现两个不同子网之间的通信。</p>
<p>开始之前需要注意的是，并不是所有的linux发行版都会默认加载<code>ipip.ko</code>模块，可以通过<code>lsmod | grep ipip</code>查看内核是否加载该模块；若没有则用<code>modprobe ipip</code>先加载；如果一切正常则应该显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsmod | grep ipip</span></span><br><span class="line"><span class="comment"># modprobe ipip</span></span><br><span class="line"><span class="comment"># lsmod | grep ipip</span></span><br><span class="line">ipip                   20480  0</span><br><span class="line">tunnel4                16384  1 ipip</span><br><span class="line">ip_tunnel              24576  1 ipip</span><br></pre></td></tr></table></figure>
<p>现在就可开始搭建IPIP隧道了，我们的网络拓扑如下图所示：</p>
<p><img alt="network-ipip-1.jpg" data-src="https://i.loli.net/2020/01/29/bexu9Qt26K7FiND.jpg"></p>
<p>其中有处于在同一个网段<code>172.16.0.0/16</code>的两台主机A和B，因此可以直接联通。我们需要做的是分别在两台主机上创建两个不同的子网：</p>
<blockquote>
<p>Note: 实际上，这两台主机A和B不必要处于同一个子网，只要处于同一个三层网络之中，也就是说能通过三层网络路由得到就可以完成IPIP隧道的搭建。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A: 10.42.1.0/24</span><br><span class="line">B: 10.42.2.0/24</span><br></pre></td></tr></table></figure>
<p>为了简化，我们先在A节点上创建bridge网络设备<code>mybr0</code>，并且设置IP地址为<code>10.42.1.0/24</code>子网的网关地址，然后启用<code>mybr0</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add name mybr0 type bridge</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.1.1/24 dev mybr0</span></span><br><span class="line"><span class="comment"># ip link set dev mybr0 up</span></span><br></pre></td></tr></table></figure>
<p>类似地，然后在B节点上分别执行类似的操作：</p>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add name mybr0 type bridge</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.2.1/24 dev mybr0</span></span><br><span class="line"><span class="comment"># ip link set dev mybr0 up</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们分别在A和B两台节点上</p>
<ol>
<li>创建对应的TUN网络设备</li>
<li>设置对应的local和remote地址为node节点的可路由地址</li>
<li>设置对应的网关地址分别为我们即将创建的TUN网络设备</li>
<li>启用TUN网络设备来创建IPIP隧道</li>
</ol>
<blockquote>
<p>Note: 步骤3是为了节省简化我们创建子网的步骤，直接设置网关地址就可以不用创建额外的网络设备。</p>
</blockquote>
<p>A:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe ipip</span></span><br><span class="line"><span class="comment"># ip tunnel add tunl0 mode ipip remote 172.16.232.194 local 172.16.232.172</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.1.1/24 dev tunl0</span></span><br><span class="line"><span class="comment"># ip link set tunl0 up</span></span><br></pre></td></tr></table></figure>
<p>上面的命令我们创建了新的隧道设备<code>tunl0</code>并且设置了隧道的<code>remote</code>和<code>local</code>的IP地址，这是IPIP数据包的外层地址；对于内层地址，我们分别设置两个子网地址，这样，IPIP数据包会看起来如下如所示：</p>
<p><img alt="network-ipip-2.jpg" data-src="https://i.loli.net/2020/01/29/95RPciVgDqtSmNb.jpg"></p>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe ipip</span></span><br><span class="line"><span class="comment"># ip tunnel add tunl0 mode ipip remote 172.16.232.172 local 172.16.232.194</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.2.1/24 dev tunl0</span></span><br><span class="line"><span class="comment"># ip link set tunl0 up</span></span><br></pre></td></tr></table></figure>
<p>为了保证我们通过创建的IPIP隧道来访问两个不同主机上的子网，我们需要手动添加如下静态路由：</p>
<p>A:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip route add 10.42.2.0/24 dev tunl0</span></span><br></pre></td></tr></table></figure>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip route add 10.42.1.0/24 dev tunl0</span></span><br></pre></td></tr></table></figure>
<p>现在主机AB的路由表如下所示：</p>
<p>A:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip route show</span></span><br><span class="line">default via 172.16.200.51 dev ens3</span><br><span class="line">10.42.1.0/24 dev tunl0 proto kernel scope link src 10.42.1.1</span><br><span class="line">10.42.2.0/24 dev tunl0 scope link</span><br><span class="line">172.16.0.0/16 dev ens3 proto kernel scope link src 172.16.232.172</span><br></pre></td></tr></table></figure>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip route show</span></span><br><span class="line">default via 172.16.200.51 dev ens3</span><br><span class="line">10.42.1.0/24 dev tunl0 scope link</span><br><span class="line">10.42.2.0/24 dev tunl0 proto kernel scope link src 10.42.2.1</span><br><span class="line">172.16.0.0/16 dev ens3 proto kernel scope link src 172.16.232.194</span><br></pre></td></tr></table></figure>
<p>到此我们就可以开始验证IPIP隧道是否正常工作：</p>
<p>A:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping 10.42.2.1 -c 2</span></span><br><span class="line">PING 10.42.2.1 (10.42.2.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.42.2.1: icmp_seq=1 ttl=64 time=0.269 ms</span><br><span class="line">64 bytes from 10.42.2.1: icmp_seq=2 ttl=64 time=0.303 ms</span><br><span class="line"></span><br><span class="line">--- 10.42.2.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1013ms</span><br><span class="line">rtt min/avg/max/mdev = 0.269/0.286/0.303/0.017 ms</span><br></pre></td></tr></table></figure>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping 10.42.1.1 -c 2</span></span><br><span class="line">PING 10.42.1.1 (10.42.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.42.1.1: icmp_seq=1 ttl=64 time=0.214 ms</span><br><span class="line">64 bytes from 10.42.1.1: icmp_seq=2 ttl=64 time=3.27 ms</span><br><span class="line"></span><br><span class="line">--- 10.42.1.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1021ms</span><br><span class="line">rtt min/avg/max/mdev = 0.214/1.745/3.277/1.532 ms</span><br></pre></td></tr></table></figure>
<p>是的，可以ping通，我们通过tcpdump在TUN设备抓取数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -n -i tunl0</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on tunl0, link-type RAW (Raw IP), capture size 262144 bytes</span><br><span class="line">01:32:05.486835 IP 10.42.1.1 &gt; 10.42.2.1: ICMP <span class="built_in">echo</span> request, id 3460, seq 1, length 64</span><br><span class="line">01:32:05.486868 IP 10.42.2.1 &gt; 10.42.1.1: ICMP <span class="built_in">echo</span> reply, id 3460, seq 1, length 64</span><br><span class="line">01:32:06.509617 IP 10.42.1.1 &gt; 10.42.2.1: ICMP <span class="built_in">echo</span> request, id 3460, seq 2, length 64</span><br><span class="line">01:32:06.509668 IP 10.42.2.1 &gt; 10.42.1.1: ICMP <span class="built_in">echo</span> reply, id 3460, seq 2, length 64</span><br></pre></td></tr></table></figure>
<p>到此为止，我们的实验是成功的。但是需要注意的是，如果我们使用的是<code>gre</code>模式，有可能需要设置防火墙才能让两个子网互通，这种情况在搭建IPv6隧道较为常见。</p>
<h3 id="one-to-many"><a href="#one-to-many" class="headerlink" title="one-to-many"></a>one-to-many</h3><p>上一节中我们通过指定TUN设备的local地址和remote地址创建了一个one-to-one的IPIP隧道，实际上，在创建IPIP隧道的时候完全可以不指定remote地址，只要在TUN设备上增加对应的路由，IPIP隧道就知道如何封装新的IP数据包并发送到路由指定的目标地址。</p>
<p>还是举个栗子来说明，假设我们现在有处于同一个三层网络的3个节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A: 172.16.165.33</span><br><span class="line">B: 172.16.165.244</span><br><span class="line">C: 172.16.168.113</span><br></pre></td></tr></table></figure>
<p>同时在这三个节点上分别attach三个不同的子网：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A: 10.42.1.0/24</span><br><span class="line">B: 10.42.2.0/24</span><br><span class="line">C: 10.42.3.0/24</span><br></pre></td></tr></table></figure>
<p>与上一小节不同的是，我们没有直接将子网的网关地址设置为TUN设备的IP地址，而是创建额外的bridge网络设备以模拟实际常用的容器网络模型。我们在A节点上创建bridge网络设备<code>mybr0</code>，并且设置IP地址为<code>10.42.1.0/24</code>子网的网关地址，然后启用<code>mybr0</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add name mybr0 type bridge</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.1.1/24 dev mybr0</span></span><br><span class="line"><span class="comment"># ip link set dev mybr0 up</span></span><br></pre></td></tr></table></figure>
<p>类似地，然后在B和C节点上分别执行类似的操作：</p>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add name mybr0 type bridge</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.2.1/24 dev mybr0</span></span><br><span class="line"><span class="comment"># ip link set dev mybr0 up</span></span><br></pre></td></tr></table></figure>
<p>C:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link add name mybr0 type bridge</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.3.1/24 dev mybr0</span></span><br><span class="line"><span class="comment"># ip link set dev mybr0 up</span></span><br></pre></td></tr></table></figure>
<p>我们的最终目标是在三个节点之间分别俩俩搭建IPIP隧道来保证这三个不同的子网直接能够互相通信，因此下一步是创建TUN网络设备并且设置路由信息。分别在A和B两台节点上：</p>
<ol>
<li>创建对应的TUN网络设备并启用</li>
<li>设置TUN网络设备的IP地址</li>
<li>设置到不同子网的路由，指明下一跳的地址</li>
</ol>
<p>对应的网关地址分别为我们即将创建的TUN网络设备 4. 启用TUN网络设备来创建IPIP隧道</p>
<blockquote>
<p>Note: TUN网络设备的IP地址是对应节点的子网地址，但是子网掩码是32位的，例如A节点上子网地址是<code>10.42.1.0/24</code>，A节点上的TUN网络设备的IP地址是<code>10.42.1.0/32</code>。这样做的原因是有时候同一个子网(例如<code>10.42.1.0/24</code>)的地址会分配相同的MAC地址，因此不能通过二层的链路层直接通信，而如果保证TUN网络设备的IP地址和任何地址都不在同一个子网，也就不存在二层的链路层直接通信了。关于这点请参考calico的实现原理，每个容器会有相同的MAC地址，后面我们有机会在深入探究。</p>
<p>Note: 还有一点需要注意，给TUN网络设备设置路由的时候指定了<code>onlink</code>, 这样做的目的是保证下一跳是直接attach到该TUN网络设备的，这样保证即使节点之间不在同一个子网中也可以搭建IPIP隧道。</p>
</blockquote>
<p>A:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe ipip</span></span><br><span class="line"><span class="comment"># ip tunnel add tunl0 mode ipip</span></span><br><span class="line"><span class="comment"># ip link set tunl0 up</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.1.0/32 dev tunl0</span></span><br><span class="line"><span class="comment"># ip route add 10.42.2.0/24 via 172.16.165.244 dev tunl0 onlink</span></span><br><span class="line"><span class="comment"># ip route add 10.42.3.0/24 via 172.16.168.113 dev tunl0 onlink</span></span><br></pre></td></tr></table></figure>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe ipip</span></span><br><span class="line"><span class="comment"># ip tunnel add tunl0 mode ipip</span></span><br><span class="line"><span class="comment"># ip link set tunl0 up</span></span><br><span class="line"><span class="comment"># ip addr add 10.42.2.0/32 dev tunl0</span></span><br><span class="line"><span class="comment"># ip route add 10.42.1.0/24 via 172.16.165.33 dev tunl0 onlink</span></span><br><span class="line"><span class="comment"># ip route add 10.42.3.0/24 via 172.16.168.113 dev tunl0 onlink</span></span><br></pre></td></tr></table></figure>
<p>C:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe ipip</span><br><span class="line">ip tunnel add tunl0 mode ipip</span><br><span class="line">ip link <span class="built_in">set</span> tunl0 up</span><br><span class="line">ip addr add 10.42.3.0/32 dev tunl0</span><br><span class="line">ip route add 10.42.1.0/24 via 172.16.165.33 dev tunl0 onlink</span><br><span class="line">ip route add 10.42.2.0/24 via 172.16.165.244 dev tunl0 onlink</span><br></pre></td></tr></table></figure>
<p>到此我们就可以开始验证我们搭建的IPIP隧道是否正常工作：</p>
<p>A:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">try</span> to ping IP <span class="keyword">in</span> <span class="number">10.42</span><span class="number">.2</span><span class="number">.0</span>/<span class="number">24</span> on Node B</span><br><span class="line"># ping <span class="number">10.42</span><span class="number">.2</span><span class="number">.1</span> -c <span class="number">2</span></span><br><span class="line">PING <span class="number">10.42</span><span class="number">.2</span><span class="number">.1</span> (<span class="number">10.42</span><span class="number">.2</span><span class="number">.1</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.42</span><span class="number">.2</span><span class="number">.1</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.338</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.42</span><span class="number">.2</span><span class="number">.1</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.302</span> ms</span><br><span class="line"></span><br><span class="line">--- <span class="number">10.42</span><span class="number">.2</span><span class="number">.1</span> ping statistics ---</span><br><span class="line"><span class="number">2</span> packets transmitted, <span class="number">2</span> received, <span class="number">0</span>% packet loss, time <span class="number">1028</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.302</span>/<span class="number">0.320</span>/<span class="number">0.338</span>/<span class="number">0.018</span> ms</span><br><span class="line">...</span><br><span class="line"># <span class="keyword">try</span> to ping IP <span class="keyword">in</span> <span class="number">10.42</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> on Node C</span><br><span class="line"># ping <span class="number">10.42</span><span class="number">.3</span><span class="number">.1</span> -c <span class="number">2</span></span><br><span class="line">PING <span class="number">10.42</span><span class="number">.3</span><span class="number">.1</span> (<span class="number">10.42</span><span class="number">.3</span><span class="number">.1</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.42</span><span class="number">.3</span><span class="number">.1</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.315</span> ms</span><br><span class="line"><span class="number">64</span> bytes <span class="keyword">from</span> <span class="number">10.42</span><span class="number">.3</span><span class="number">.1</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.381</span> ms</span><br><span class="line"></span><br><span class="line">--- <span class="number">10.42</span><span class="number">.3</span><span class="number">.1</span> ping statistics ---</span><br><span class="line"><span class="number">2</span> packets transmitted, <span class="number">2</span> received, <span class="number">0</span>% packet loss, time <span class="number">1029</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.315</span>/<span class="number">0.348</span>/<span class="number">0.381</span>/<span class="number">0.033</span> ms</span><br></pre></td></tr></table></figure>
<p>看起来一切正常，如果反过来从B或者C节点分别ping其他子网，也是可以通的。这就说明我们确实可以创建一对多的IPIP隧道，这中one-to-many的模式在一些典型的多节点网络中创建overlay通信模型中非常有用。</p>
<h3 id="under-the-hood"><a href="#under-the-hood" class="headerlink" title="under the hood"></a>under the hood</h3><p>我们再通过tcpdump在分别在B和C的TUN设备抓取数据：</p>
<p>B:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -n -i tunl0</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on tunl0, link-type RAW (Raw IP), capture size 262144 bytes</span><br><span class="line">22:38:28.268089 IP 10.42.1.0 &gt; 10.42.2.1: ICMP <span class="built_in">echo</span> request, id 6026, seq 1, length 64</span><br><span class="line">22:38:28.268125 IP 10.42.2.1 &gt; 10.42.1.0: ICMP <span class="built_in">echo</span> reply, id 6026, seq 1, length 64</span><br><span class="line">22:38:29.285595 IP 10.42.1.0 &gt; 10.42.2.1: ICMP <span class="built_in">echo</span> request, id 6026, seq 2, length 64</span><br><span class="line">22:38:29.285629 IP 10.42.2.1 &gt; 10.42.1.0: ICMP <span class="built_in">echo</span> reply, id 6026, seq 2, length 64</span><br></pre></td></tr></table></figure>
<p>C:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -n -i tunl0</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on tunl0, link-type RAW (Raw IP), capture size 262144 bytes</span><br><span class="line">22:36:18.236446 IP 10.42.1.0 &gt; 10.42.3.1: ICMP <span class="built_in">echo</span> request, id 5894, seq 1, length 64</span><br><span class="line">22:36:18.236499 IP 10.42.3.1 &gt; 10.42.1.0: ICMP <span class="built_in">echo</span> reply, id 5894, seq 1, length 64</span><br><span class="line">22:36:19.265946 IP 10.42.1.0 &gt; 10.42.3.1: ICMP <span class="built_in">echo</span> request, id 5894, seq 2, length 64</span><br><span class="line">22:36:19.265997 IP 10.42.3.1 &gt; 10.42.1.0: ICMP <span class="built_in">echo</span> reply, id 5894, seq 2, length 64</span><br></pre></td></tr></table></figure>
<p>其实，从创建one-to-many的IPIP隧道的过程中我们就能大致猜到Linux的ipip模块基于路由信息获取IPIP包的内部ip然后再用外部IP封装成新的IP包。至于怎么解封IPIP数据包的呢，我们来看看ipip模块收数据包的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ip_protocol_deliver_rcu</span><span class="params">(struct net *net, struct sk_buff *skb, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">ipprot</span>;</span></span><br><span class="line">	<span class="keyword">int</span> raw, ret;</span><br><span class="line"></span><br><span class="line">resubmit:</span><br><span class="line">	raw = raw_local_deliver(skb, protocol);</span><br><span class="line"></span><br><span class="line">	ipprot = rcu_dereference(inet_protos[protocol]);</span><br><span class="line">	<span class="keyword">if</span> (ipprot) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ipprot-&gt;no_policy) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb)) &#123;</span><br><span class="line">				kfree_skb(skb);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			nf_reset_ct(skb);</span><br><span class="line">		&#125;</span><br><span class="line">		ret = INDIRECT_CALL_2(ipprot-&gt;handler, tcp_v4_rcv, udp_rcv,</span><br><span class="line">				      skb);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			protocol = -ret;</span><br><span class="line">			<span class="keyword">goto</span> resubmit;</span><br><span class="line">		&#125;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!raw) &#123;</span><br><span class="line">			<span class="keyword">if</span> (xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb)) &#123;</span><br><span class="line">				__IP_INC_STATS(net, IPSTATS_MIB_INUNKNOWNPROTOS);</span><br><span class="line">				icmp_send(skb, ICMP_DEST_UNREACH,</span><br><span class="line">					  ICMP_PROT_UNREACH, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);</span><br><span class="line">			consume_skb(skb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From <a href="https://github.com/torvalds/linux/blob/master/net/ipv4/ip_input.c#L187-L224" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/torvalds/linux/blob/master/net/ipv4/ip_input.c#L187-L224</a></p>
<p>可以看到，ipip模块会根据数据包的协议类型去解封，然后将解封后的skb数据包再做一次解封。以上只是一些非常浅显的分析，如果大家感兴趣，推荐去多看看ipip模块的源代码实现。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://ring0.me/2014/02/network-virtualization-techniques/" target="_blank" rel="external nofollow noopener noreferrer">https://ring0.me/2014/02/network-virtualization-techniques/</a></li>
<li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/" target="_blank" rel="external nofollow noopener noreferrer">https://backreference.org/2010/03/26/tuntap-interface-tutorial/</a></li>
<li><a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/" target="_blank" rel="external nofollow noopener noreferrer">https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/</a></li>
<li><a href="http://ifeanyi.co/posts/linux-namespaces-part-1/" target="_blank" rel="external nofollow noopener noreferrer">http://ifeanyi.co/posts/linux-namespaces-part-1/</a></li>
<li><a href="http://www.opencloudblog.com/?p=66" target="_blank" rel="external nofollow noopener noreferrer">http://www.opencloudblog.com/?p=66</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt" target="_blank" rel="external nofollow noopener noreferrer">Universal TUN/TAP device driver</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业快乐</title>
    <url>/posts/959c2cfa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。</p>
<a id="more"></a>
<h2 id="欢迎回家"><a href="#欢迎回家" class="headerlink" title="欢迎回家"></a>欢迎回家</h2><p>在 7 月 5 日，我得到一次毕业生返校机会，用于打包行李。在此之前，我已经委托 HT 和 CR 帮忙把行李寄了出来，事实上已经没有什么东西需要打包。但是我仍然申请了返校，为的是再以毕业生的身份看一看燕园。在去年冬天，刚开始迷上摄影的我在下雪的燕园拍了好些照片，当时的我还想着要好好利用这最后的半年，多拍一些学校的照片。没想到这次的疫情直接导致了这半年完全不能回来，真的很遗憾了。</p>
<p><img alt="欢迎回家，半年后再次回到燕园" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_welcome-back.jpg"></p>
<p>作为 <a href="../c924112f">对比</a>，我在去年冬天拍照的机位再次拍摄了夏天的景色，再见燕园已经是另一幅样子。</p>
<p><img alt="夏日翠影中的塞万提斯" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_cervantes.jpg"></p>
<p><img alt="大雅之堂" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_daya.jpg"></p>
<p><img alt="上次拍的这个视角，正是几个女孩子在这里堆雪人，今天的静园静悄悄的，只有偶尔几个毕业生过来拍照" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_green.jpg"></p>
<p><img alt="南北阁，夏天的味道" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_south-north.jpg"></p>
<p><img alt="二体，与冬天下雪时不同，这次回来正下着零星的小雨" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_roof.jpg"></p>
<p><img alt="夏日未名湖，没有冰场，没有雪花，只有满满的绿色" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-05_tower.jpg"></p>
<h2 id="毕业快乐"><a href="#毕业快乐" class="headerlink" title="毕业快乐"></a>毕业快乐</h2><p>2013年8月29日，我和大姐二姐第一次来到燕园，那天还没有正式开学，小雨迷蒙，绕着燕园转了好半天，当时觉得燕园很大，一切都很新，未来充满希望；2020年7月5日，我最后一次以学生的身份回到燕园，同样是小雨淅沥，时隔半年，燕园显得熟悉而又陌生。在2017年的夏天，我已经毕业过一次。只是那一次，从本专业本科保研到对应实验室，毕业的感觉并没有很强烈。但是这一次，是彻底结束了学生生涯，走向社会，走向独立。七年前，我对于未来会如何发展一无所知，不知道自己未来会去向何处；今天，我对于自己想做什么内心大致有了方向，但是不确定性仍然存在。在这七年间，我见到了很多很厉害，很努力，很有趣的同学，他们始终是我前进和奋斗的榜样。我一直会告诉自己，我永远可以变得更好。</p>
<p>当我坐着自如搬家师傅帮我把好几大箱的行李搬到租住的房间，看着行李我累得完全不想动，我清醒地意识到，从此刻开始，我的学生生涯永远不再。我甚至还不争气的流下了眼泪，仿佛是为了给自己一个正式的道别。毋庸置疑，毕业是人生中的一个重要节点，从社会意义上来讲你完成了你身份的转变。但是毕业真的是那么值得伤感的一件事情吗？看到一些师兄毕业后的生活状态，按照他们的话说，从此成为一名社畜，日常995，还得承受工作的压力。也许这就是现实，但是我还是愿意乐观一点。对我来说，毕业标志着我进入了人生新的一个阶段，你需要在这个阶段去做更有意义、有价值的事情。也许有时候会很辛苦，但是作为一个独立的人，你可以探索更多有意思的事情。</p>
<p>毕业快乐。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title>再出发</title>
    <url>/posts/4987aa35/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。</p>
<a id="more"></a>
<h2 id="饮食起居"><a href="#饮食起居" class="headerlink" title="饮食起居"></a>饮食起居</h2><p>这是我整理完毕的工作台，其中购置了墙布用于装饰墙面，购买了可组装的书桌（拼了将近两个小时才拼好），又自己买了ikbc c87的键盘，从姐姐家里带来的蓝牙音响，还有之前买的LAMY钢笔，皮皮送拇指琴，真的是很喜欢很舒适的工作台了。</p>
<p><img alt="整理完毕的工作台" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-06_settle-down.jpg"></p>
<p>在上学时曾经期待过工作之后的生活场景，想着是自己每天上能够自己准备早餐，晚上下班后能够自己在家安排自己的生活。但是一周的上班生活马上用现实教育了我，每天早上8.30点出门直接在公司吃早饭，工作到9点半后下班，到家就10点后了，基本上洗漱完后就可以直接睡觉了。做饭这种事情，只能发生在周末了。然而，在入职前我就反了一个错误，一口气买了好多菜，平时也不做，好些都给浪费了。而且，为了简单，平时做的最多的就是面了。不过，不管怎样，总算是开伙了。即使只是在周末下厨，也不能丧失了生活的乐趣了啊，趁这个机会好好学习做菜是一个不错的想法。为此，我特地创建了一个<a href="../../categories/吃顿好的/">「吃顿好的」</a>专栏，用于记录我周末下厨房的菜谱。在后续的工作生涯中，这个专栏会持续更新。</p>
<h2 id="追光计划"><a href="#追光计划" class="headerlink" title="追光计划"></a>追光计划</h2><p>「追光计划」源自我在微博上看到一个<a href="https://weibo.com/ttarticle/p/show?id=2309404521623347921078" target="_blank" rel="external nofollow noopener noreferrer">摄影师小姐姐</a>为自己在北京最后一段时间留下记录影像的规划，她这样说道</p>
<blockquote>
<p>不知道你是否也有过类似的感觉——越是长久的生活在一个城市，反而越少了了解它的冲动。</p>
<p>就好比在武汉生活的四五年里，我一次都没有去过黄鹤楼，也几乎不去武大。那些外地游客心心念念的美景，本地人好像都因为太过习惯而熟视无睹。</p>
<p>在北京我也一样。除了故宫外，其他大众或冷门的景点，我鲜少踏足，也很少抓紧特别的天气去拍点什么，总想着：“以后还有机会的”。我拍过很多日出日落，那些绝美的光影，几乎都来自旅途，却独独少了我生活的北京。</p>
<p>似乎人总是这样，偶尔难得旅行，就总想紧紧抓住异乡风景。会起早贪黑去追逐日出日落，也乐于打卡各种陌生的小众景点。而你生活的地方，却总忘了多看几眼。</p>
<p>故事的转机发生在我决定离开北京之后。</p>
</blockquote>
<p>小姐姐和我有着类似的生活坐标（武汉与北京），直到决定离开北京后才开始意识到好好拍摄北京的风景。我也是一样，本来决定在离校前好好拍摄北大的风光，却也最终没能够实现。在过去的一两周里，我一直在质疑自己，为什么要留在北京呢？在这里呆了都七年了，为什么不换一个地方生活呢？</p>
<p>想到这里，我给自已一个三年之期：如果在未来三年，我没能够找到留在北京的理由，或者是因为一个人，或者是因为一件事，三年到期之时也许就是我离开北京的日子。不管到时候是否离开，在这三年里，我也有自己的追光计划。我要好好记录在北京的日子，记录那些光影。作为最基本的示例，我开创了一个新的相册，<a href="../../album/知春里知春/">知春里知春</a>，用于记录我在知春里生活的时光。另外，随着追光计划的开展，我也会把那些美丽的景色放到另一个相册，<a href="../../album/Beijing">北京</a> 。</p>
<h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><p>我职业生涯的正式起点，开启于腾讯云的kubernetes团队。在过去的一周里，我开始阅读kubernetes源码，在阅读的过程中，我越来越感觉到自己积淀的欠缺。不仅是CNCF云原生的生态发展，还有kubernetes本身机制的原理，或者是Go语言的最佳实践，以及Linux操作系统的基础原理，自己都知之甚少。或者说有时候只是知道一些名词，但是对其原理，发展机制都不太了解。</p>
<p>作为一个工程师，这些技术点是我的立身之本，必须在接下来的一年内能够快速积淀，给自己的职业发展奠定一个扎实的基础。为此，我列出了在接下来两年我要去点亮的技能树，这只是最基础的专业内容。它涉及的范围很广泛，但是要戒骄戒躁，一步一步来。</p>
<p><img alt="Kubernetes技能树" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-12_kubernetes-skill-map.png"></p>
<h2 id="运动健身"><a href="#运动健身" class="headerlink" title="运动健身"></a>运动健身</h2><p>在年初的时候，我大言不惭的说：</p>
<blockquote>
<p>数据是最重忠实的记录者，每周 3 次跑步，每次 5 公里，期待明年能够达到 700 公里的跑步量。</p>
</blockquote>
<p>现在每一次的跑步都是通过Keep记录，翻开Keep，发现上半年的记录只有27公里，真的是完全不达标啊。也许你可以归因于疫情，但是如此懈怠真的太不自律了。下半年开始，发现在公司地下有免费健身房，正好可以每天中午午饭时间去跑一个小时的步。按照下半年25周，每周5次每次5公里的跑步记录，勉强可以达到625公里的目标。如果再加上周末的户外跑步，比如附近的人民大学，海淀黄庄一带，可以大体满足700公里的目标，加油呀！</p>
<h2 id="阅读观影"><a href="#阅读观影" class="headerlink" title="阅读观影"></a>阅读观影</h2><p>翻了翻豆瓣，上半年的阅读依旧还是颗粒无收。主要还是没有一个Read List，也没有一个阅读规划，匆匆半年过去，一本书也没读过很正常。预计下半年看书还是会很少，更多的看的是专业相关的技术文档的内容。</p>
<p>至于观影，上半年看了很多金融相关的电影和纪录片，比如大空头等，对金融与市场有了更多的认识。另外，还入坑了「Rick and Morty」，这个系列可以慢慢刷。不知道为什么，现在好像对刷新的剧没有了之前那么大的激情，更多的是看木鱼和电影最Top对电影的讲解，整体开始偏快餐。</p>
<h2 id="行万里路"><a href="#行万里路" class="headerlink" title="行万里路"></a>行万里路</h2><p>在年初的时候，我给自己计划了两场旅行：</p>
<ul>
<li>和家里的春节南国之旅</li>
<li>和鹏飞的节后湖南之行</li>
</ul>
<p>然而这场疫情改变了一切，上半年创造了上大学以后呆在家的最长纪录，从1.19到5.7的一百多天。之后，我去杭州呆了两个月，好好逛了逛杭州，见识了西湖之美。本来计划的毕业旅行也因为一再爆发的疫情而最终取消，残念。</p>
<p>今年下半年，有意去新疆走一趟，趁着国庆，看看壮美的新疆，期待最终能够成行。作为一个已经毕业的人，除了国庆之外，已经没有了出去玩的机会，想一想真是心酸。不管怎么样，国庆一定要出去走走，可不能浪费这次假期。</p>
<h2 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h2><p>去年年末给自己定了一个理财的小目标：</p>
<blockquote>
<p>给自己定一个小目标，期待自己明年在投资上至少能够有 20 个点的收入，最好能够到 40 个点的收入。</p>
</blockquote>
<p>截止到现在，得益于行情好，已经获得了40个点的收益，希望可以在后面半年继续努力：）整体来说，上半年还是偏保守，在2.3春节开盘千股跌停的那天，我几近满仓。然而后面行情低迷是多年不遇的打底没敢全仓进入，只是半仓观望。加上进入资金也不多，最后的收益其实了了。</p>
<p><img alt="2020上半年收益曲线" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-12_investment.jpg"></p>
<p>关于理论知识，上半年在疫情期间听了徐高老师的「宏观经济十六讲中国专题」，看了一些炒股的基础知识，但是一直没有落实成文本的形式积淀下来，下半年在空余时间要在落实层面做到更好。毕竟，现在的股票买卖还是没有任何理论依据，选股的原因，买入的时机，抛出的选择都十分无脑，有时候迷之自信，没有任何逻辑。构建自己的交易体系，长路漫漫。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>卡林巴琴停了很久，年初的规划仍在，今天又弹了段「青花瓷」，找回了感觉，下半年的音乐计划继续。</p>
<p>2020上半年继续单身，工作以后社交状态越发封闭，这段时间先好好调整自己的状态吧，期待在工作上更好的适应，做出自己的成绩。</p>
<p>这次的半年总结拖了两个星期，工作和生活开始慢慢进入状态，继续加油呀，努力做更好的自己：）</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>个人管理系统</tag>
        <tag>职场</tag>
        <tag>追光计划</tag>
      </tags>
  </entry>
  <entry>
    <title>【下厨房】酸甜麻辣咸</title>
    <url>/posts/8f35743d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出<code>Hello World</code>，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印<code>Hello World</code>，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。</p>
<a id="more"></a>
<h2 id="基本调料"><a href="#基本调料" class="headerlink" title="基本调料"></a>基本调料</h2><h3 id="食盐"><a href="#食盐" class="headerlink" title="食盐"></a>食盐</h3><ul>
<li>盐乃百味之首，主要用于调出咸味。</li>
<li>做菜时，<strong>在多数情况下</strong>都是在<strong>最后调味阶段再放盐</strong>的，例如炒菜、炖汤、炖菜时，因为这样可以保证盐不会破坏掉其他的味道，也可以保证碘元素少挥发，还能保证菜品不会过咸。</li>
<li>但如果在准备<strong>食材时需要提前入味</strong>的情况下，就<strong>需要先放盐了</strong>，例如蒸肉、蒸鱼。</li>
</ul>
<p><img alt="盐" data-src="https://pic1.zhimg.com/v2-f828837cbf0cf989cfb25b5b1bbdac78_b.webp"></p>
<h3 id="酱油"><a href="#酱油" class="headerlink" title="酱油"></a>酱油</h3><ul>
<li>我国传统调料，主要用来增咸提鲜。酱油可分为生抽和老抽。</li>
<li><strong>老抽</strong>吃到嘴里很浓稠，一般用于给食物上色提鲜。</li>
<li><strong>生抽</strong>颜色比较淡，味道稍咸，主要用来调味，炒菜或者凉拌菜的时候用得比较多。</li>
</ul>
<h3 id="鸡精和味精"><a href="#鸡精和味精" class="headerlink" title="鸡精和味精"></a>鸡精和味精</h3><ul>
<li>调鲜专用，主要成分都是谷氨酸钠，两者其实在原料上差别不大，只是口感上，<strong>鸡精更鲜，更有风味</strong>。</li>
<li>值得一提的是，<strong>鸡精和味精其实真的不会致癌</strong>，所以正常做菜使用是没有问题的！</li>
</ul>
<p><strong>使用鸡精和味精的注意事项：</strong></p>
<ul>
<li>高汤烹制的菜肴不必使用，因为已经很鲜美了；</li>
<li>酸性强的菜肴，如糖醋、醋溜菜等不宜使用；</li>
<li>腌菜不要使用味精；</li>
<li>不宜过早放味精，要在将出锅时放入；</li>
<li>如果用于凉拌菜，可以先溶解再使用;</li>
<li>不能在高温下使用。</li>
</ul>
<p><img alt="鸡精和味精" data-src="https://pic3.zhimg.com/v2-73bbb13a22c0b7fd1ec322934b73c1ec_b.jpg"></p>
<h3 id="醋"><a href="#醋" class="headerlink" title="醋"></a>醋</h3><p>我国古代传统调味料之一。有三千多年的历史。醋在分类上通常有以下几类：<strong>米醋、陈醋、白醋。</strong></p>
<ul>
<li><strong>米醋</strong>的口感更好，口感酸甜，可用于糖醋排骨。</li>
<li><strong>陈醋</strong>酸味很浓烈，很开胃，基本上可用于各种常见的调味。</li>
<li><strong>白醋</strong>的酸味口感较淡，多用于凉拌菜或西餐的使用。</li>
</ul>
<p><strong>下面总结一下醋的各种常见功能：</strong></p>
<ul>
<li><strong>去腥去膻：</strong>做鱼做羊的时候可加入少许醋去除异味</li>
<li><strong>减少辣味：</strong>如果炒菜时不小心辣椒放多了，可以放一些醋减少辣味</li>
<li><strong>增香：</strong>做菜时候加入少许醋，可以增加菜肴香味并减少油腻程度</li>
<li><strong>催熟：</strong>炖牛羊肉的时候加一点醋能够让菜肴熟得更快</li>
<li><strong>增甜：</strong>南方朋友做甜粥的时候加入少许醋可以使粥更甜</li>
</ul>
<p><img alt="醋" data-src="https://pic1.zhimg.com/v2-3a5d4fa5e12fd226862b423e39baf703_b.jpg"></p>
<h3 id="糖"><a href="#糖" class="headerlink" title="糖"></a>糖</h3><ul>
<li><p>增甜味的调料，常见的种类有白糖、红糖、冰糖。</p>
<ul>
<li>一般使用白糖作为调料。</li>
<li>红糖可以补血破淤具有益气、缓中、助脾化食的作用。</li>
<li>冰糖可以去痰止咳，一般可用于制作红烧类菜肴时增加色泽及口感，也可用于制作甜品。</li>
</ul>
</li>
<li><p>少许白糖可以提鲜。</p>
</li>
<li><p>白糖还可以综合酸味，可做醋溜系的菜。</p>
</li>
<li><p>由于糖的特性，可做拔丝香蕉等“拔丝类”菜肴</p>
</li>
<li><p>挂霜：白糖入锅，加入适量清水，熬至水近干时，倒入经烘烤或油炸过的原料，离火，翻拌，冷却后，成品表面即似白霜状。如糖霜花生、糖山楂、糖霜核桃等。</p>
</li>
<li><p>炒糖色：广泛用于卤菜、红烧菜的调色、如红烧猪蹄、红烧排骨等。</p>
</li>
<li><p>糖醋菜系必备，开胃可口。</p>
<p><img alt="糖" data-src="https://pic3.zhimg.com/v2-0af08e21b39bc930a099b05f35c3ccfa_b.jpg"></p>
</li>
</ul>
<h2 id="酒类"><a href="#酒类" class="headerlink" title="酒类"></a>酒类</h2><h3 id="料酒"><a href="#料酒" class="headerlink" title="料酒"></a><strong>料酒</strong></h3><ul>
<li><strong>去腥</strong>专家，很多肉类、内脏等食材在初加工时，都会使用料酒去腥。</li>
<li>例如在<strong>炒鸡蛋的时候加入少许料酒也可以去腥提香</strong></li>
</ul>
<h3 id="啤酒"><a href="#啤酒" class="headerlink" title="啤酒"></a><strong>啤酒</strong></h3><ul>
<li>硬菜会用啤酒去腥、调味，请家里常备“宽啤酒”</li>
</ul>
<h3 id="高度白酒"><a href="#高度白酒" class="headerlink" title="高度白酒"></a><strong>高度白酒</strong></h3><ul>
<li>去除腥味较重的食物时可以用到</li>
</ul>
<h2 id="酱类"><a href="#酱类" class="headerlink" title="酱类"></a>酱类</h2><p>酱类调料：各类以酱为形式的调料</p>
<h3 id="豆瓣酱"><a href="#豆瓣酱" class="headerlink" title="豆瓣酱"></a>豆瓣酱</h3><p>川菜之魂，主要<strong>增加菜肴的咸鲜味</strong>。</p>
<h3 id="甜面酱"><a href="#甜面酱" class="headerlink" title="甜面酱"></a>甜面酱</h3><p>以面粉、水和食盐为原料的一种酱料，<strong>鲜香甜味十足</strong>。可以当做酱料使用（例如蘸黄瓜），也可以调味，是炸酱面、京酱肉丝等菜肴的必备调料。　　</p>
<h3 id="番茄酱"><a href="#番茄酱" class="headerlink" title="番茄酱"></a>番茄酱</h3><p>用新鲜番茄经过加工而成的酱料，鲜而酸。常用于<strong>增色、添香、增加酸味口感</strong>，如制作松鼠鱼。</p>
<h3 id="芝麻酱"><a href="#芝麻酱" class="headerlink" title="芝麻酱"></a>芝麻酱</h3><p>顾名思义是芝麻作为原料调制的酱料，非常的香，<strong>增香必备</strong>。可直接作为蘸料，例如北方的同学吃火锅是喜欢蘸麻酱，也常用于制作凉面、凉拌菜等。</p>
<h3 id="蚝油"><a href="#蚝油" class="headerlink" title="蚝油"></a>蚝油</h3><p>以素有”海底牛奶”之称的蚝牗牡蛎牍为原料，经煮熟取汁浓缩，加辅料精制而成。蚝油味道鲜美、蚝香浓郁，黏稠适度，营养价值高。适合烹制多种食材，如蚝油牛肉、蚝油生菜、蚝油荷兰豆等，还可<strong>调拌各种面食、涮海鲜、佐餐食用</strong>等。</p>
<h2 id="香料类"><a href="#香料类" class="headerlink" title="香料类"></a>香料类</h2><p>香料分很多种，主要功能是增加各种风味，使味更有层次感。</p>
<h3 id="干辣椒："><a href="#干辣椒：" class="headerlink" title="干辣椒："></a>干辣椒：</h3><p><strong>增香、增辣。</strong></p>
<p>油热时和葱姜一起放锅内爆香，一般家常菜都可以用。</p>
<h3 id="花椒与麻椒"><a href="#花椒与麻椒" class="headerlink" title="花椒与麻椒"></a>花椒与麻椒</h3><p>增加菜肴的<strong>“麻”味</strong>，同时也是<strong>爆香</strong>的“利器”！炒菜的时候加入花椒可以防止油沸，花椒粉也可以用于包子或者饺子的馅料。麻椒比花椒颜色更重，更麻，喜欢重口味的同学可以用麻椒作为调料。</p>
<h3 id="八角-大料"><a href="#八角-大料" class="headerlink" title="八角(大料)"></a>八角(大料)</h3><p>也叫大茴香，因此无论<strong>卤、酱、烧、炖，</strong>都可以用到它，用以<strong>去腥添香。</strong>不论炒菜、炖肉、腌菜，八角都要提前放。一份菜一般放三瓣，分量多的可以放一整朵。</p>
<h3 id="胡椒"><a href="#胡椒" class="headerlink" title="胡椒"></a>胡椒</h3><ul>
<li>又分<strong>黑胡椒和白胡椒</strong>，常用于提鲜去腥，开胃、促进食欲。</li>
<li>其中<strong>黑胡椒味道更浓，香中带辣</strong>，适用于炖、煎、烤肉类。</li>
<li><strong>白胡椒胡椒香味稍淡，辣味更浓</strong>，能提出鲜味。</li>
<li>需要注意的是，无论黑胡椒、白胡椒皆不能高温油炸，应在菜肴或汤羹即将出锅时加少许。</li>
</ul>
<h3 id="香叶"><a href="#香叶" class="headerlink" title="香叶"></a>香叶</h3><p>干燥后的月桂树叶，用以<strong>去腥添香</strong>，用于炖肉、卤味等。</p>
<h3 id="桂皮"><a href="#桂皮" class="headerlink" title="桂皮"></a>桂皮</h3><p>干燥后的月桂树皮，用以去腥添香，也可以用于炖肉、卤味等。</p>
<h3 id="小茴香"><a href="#小茴香" class="headerlink" title="小茴香"></a>小茴香</h3><p>用以<strong>去腥添香</strong>，用于炖肉等。其茎叶部分即茴香菜。</p>
<h3 id="孜然"><a href="#孜然" class="headerlink" title="孜然"></a>孜然</h3><p>祛<strong>除腥膻异味</strong>的作用很强,！还能<strong>解除肉类的油腻</strong>,常用在烧烤牛羊肉中，令肉质更加鲜美芳香并且去除膻味异味。</p>
<h3 id="五香粉"><a href="#五香粉" class="headerlink" title="五香粉"></a><strong>五香粉</strong></h3><p>花椒、大料、桂皮、丁香等芳香类调料混合研制而成，使用方便。尤其适合用于<strong>烘烤或快炒肉类，炖、焖、煨、蒸、煮菜肴</strong>作调味。</p>
<h2 id="辣椒类"><a href="#辣椒类" class="headerlink" title="辣椒类"></a>辣椒类</h2><p><img alt="辣椒" data-src="https://pic2.zhimg.com/v2-471d6358a188a14ebf240fa500d0164f_b.jpg"></p>
<h3 id="剁椒与糟辣椒"><a href="#剁椒与糟辣椒" class="headerlink" title="剁椒与糟辣椒"></a>剁椒与糟辣椒</h3><p>云贵地区称作糟辣椒、湖南地区叫做剁椒，<strong>口味和制作工艺稍有差别</strong>，但是总体来说外表色泽鲜红，具有香、辣、鲜、酸、嫩、咸、脆、的独特风味，有开胃消食、暖胃驱寒的功效。可以直接食用、当做蘸料，也可用于调料，比如制作剁椒鱼头、鱼香肉丝、鱼香茄子等菜肴，值得注意的是，由于<strong>剁椒和糟辣椒本身就有盐味</strong>，所以调味时就<strong>不用额外添加过多的食盐</strong>了！</p>
<h3 id="红油辣椒"><a href="#红油辣椒" class="headerlink" title="红油辣椒"></a>红油辣椒</h3><p>是川菜中常见的调味料，油色红亮，味道香辣。常用于<strong>凉拌菜、拌面、蘸料等。</strong></p>
<h3 id="泡椒"><a href="#泡椒" class="headerlink" title="泡椒"></a>泡椒</h3><p>四川特产，由新鲜辣椒腌制而成。香、酸、辣味十足，是制作泡椒类菜肴的必备调料（例如川味鱼香肉丝、泡椒牛肉等）。<br>常见的泡椒主要有两种：</p>
<ul>
<li>二荆条泡辣椒：这种辣椒相对较长，辣味适口，香气足，可以切碎了使用，制作传统川菜鱼香肉丝就离不开它</li>
<li>子弹头泡辣椒：这种辣椒较短，呈鸡心状，其辣味足，因成形较好，在泡椒菜肴中常整个使用，很少加工成茸或切成小块。</li>
</ul>
<h2 id="食用油"><a href="#食用油" class="headerlink" title="食用油"></a>食用油</h2><h3 id="菜油-菜籽油"><a href="#菜油-菜籽油" class="headerlink" title="菜油(菜籽油)"></a>菜油(菜籽油)</h3><p>用油菜籽榨出来的一种食用油，有一种“青气味”。菜籽油具有一定的软化血管、延缓衰老的功效。常<strong>用于炒菜，也可以做红油辣椒。不适合凉拌菜。</strong></p>
<h3 id="花生油"><a href="#花生油" class="headerlink" title="花生油"></a>花生油</h3><p>淡黄透明，气味芬芳，滋味可口，是一种比较容易消化的食用油。花生油的脂肪酸构成是比较好的，易于人体消化和吸收。常用于炒菜，<strong>炒蔬菜最好，比较香。</strong> </p>
<h3 id="葵花籽油"><a href="#葵花籽油" class="headerlink" title="葵花籽油"></a>葵花籽油</h3><p>营养价值丰富，含有丰富的胡萝卜素。不适合油炸，常用于<strong>做汤、炒菜、凉拌。</strong></p>
<h3 id="玉米油"><a href="#玉米油" class="headerlink" title="玉米油"></a>玉米油</h3><p>优质玉米油营养含量丰富。也常用于炒菜，清淡不油腻也可增加香味。</p>
<h3 id="大豆油"><a href="#大豆油" class="headerlink" title="大豆油"></a>大豆油</h3><p>通常我们称之为“大豆色拉油”，是最常用的烹调油之一。做面点，但不适合炒菜。</p>
<h3 id="橄榄油"><a href="#橄榄油" class="headerlink" title="橄榄油"></a>橄榄油</h3><p>非常营养健康的油。炒菜时油烟很少，但高温易破坏营养，所以要想营养最大化还是凉拌菜比较好，但是缺点是炒菜炒起来没那么“香”。</p>
<h3 id="猪油"><a href="#猪油" class="headerlink" title="猪油"></a>猪油</h3><p>也称为荤油或猪大油。它是从猪的脂肪中提炼出，初始状态是略黄色半透明液体的食用油，常温下为白色或浅黄色固体，加热后会融化。<strong>猪油含胆固醇较多，对身体不利，建议少吃。</strong>但是炒菜做菜时能增香、添味。另外，由于常温时是固体，故不适合做凉拌食物。</p>
<h3 id="芝麻油"><a href="#芝麻油" class="headerlink" title="芝麻油"></a>芝麻油</h3><p>具有特别的香味，所以也叫香油。凉拌菜、汤类及热菜首选，可以<strong>增香提味。</strong></p>
<h3 id="牛油"><a href="#牛油" class="headerlink" title="牛油"></a>牛油</h3><p>从牛的脂肪组织里提炼出来的油脂，常温时也呈固体。风味浓郁，是做麻辣火锅底料必备调料。</p>
]]></content>
      <categories>
        <category>吃顿好的</category>
      </categories>
      <tags>
        <tag>下厨房</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】开篇</title>
    <url>/posts/d8b96fe4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。</p>
<a id="more"></a>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>Kubernetes来源于希腊词汇<a href="https://en.wiktionary.org/wiki/κυβερνήτης" target="_blank" rel="external nofollow noopener noreferrer">κυβερνήτης</a>，意思是<a href="https://en.wikipedia.org/wiki/Helmsman" target="_blank" rel="external nofollow noopener noreferrer">helmsman</a>，也即是舵手的意思，也可引申为<code>pilot</code>或者<code>governor</code>的含义。与此同时，kubernetes也是<a href="https://en.wikipedia.org/wiki/Cybernetics" target="_blank" rel="external nofollow noopener noreferrer">cybernetics</a>的控制系统的意味。随着容器技术的广泛应用，特别是docker的流行，对于容器编排系统的需求导致了kubernetes的出现。docker具有集装箱的意思，而kubernetes就是管理运送集装箱的舵手。</p>
<p>2014年中，kubernetes首次被宣布，前期的主要开发人员来自于Google的 <a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager" target="_blank" rel="external nofollow noopener noreferrer">Borg</a>)系统，它的发展与设计也深受Borg影响。与Borg采用C++设计不同，kubernetes一开始就采用Go语言实现。</p>
<p>Kubernetes v1.0 was released on July 21, 2015.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-13" target="_blank" rel="external nofollow noopener noreferrer">[13]</a> Along with the Kubernetes v1.0 release, Google partnered with the <a href="https://en.wikipedia.org/wiki/Linux_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Linux Foundation</a> to form the <a href="https://en.wikipedia.org/wiki/Cloud_Native_Computing_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Cloud Native Computing Foundation</a> (CNCF)<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-14" target="_blank" rel="external nofollow noopener noreferrer">[14]</a> and offered Kubernetes as a seed technology. On March 6, 2018, Kubernetes Project reached ninth place in commits at GitHub, and second place in authors and issues to the <a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="external nofollow noopener noreferrer">Linux kernel</a>.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-15" target="_blank" rel="external nofollow noopener noreferrer">[15]</a></p>
<p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p>
<p>这是一艘载着一堆集装箱的轮船，轮船在大海上运着集装箱奔波，把集装箱送到它们该去的地方。我们之前其实介绍过一个概念叫做 container，container 这个英文单词也有另外的一个意思就是“集装箱”。Kubernetes 也就借着这个寓意，希望成为运送集装箱的一个轮船，来帮助我们管理这些集装箱，也就是管理这些容器。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/1f/a7/1f5c9e99df79ea86ca5062fef22e21a7.png"></p>
<h3 id="应用部署演进"><a href="#应用部署演进" class="headerlink" title="应用部署演进"></a>应用部署演进</h3><ul>
<li>传统部署时代：直接在物理服务器上部署应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。<ul>
<li>如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。</li>
<li>一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li>
</ul>
</li>
<li>虚拟化部署时代：引入虚拟化功能，允许在单个物理服务器的 CPU 上运行多个虚拟机（VM）。<ul>
<li>虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。</li>
<li>因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。</li>
<li>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li>
</ul>
</li>
<li>容器化部署时代：容器是轻量级的虚拟化，相对于虚拟机，其具有更多的优势<ul>
<li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li>持续开发、集成和部署：通过快速简单的回滚(由于镜像不可变性)，提供可靠且频繁的容器镜像构建和部署。</li>
<li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像，从而将应用程序与基础架构分离。</li>
<li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li>
<li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li>
<li>云和操作系统分发的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、Google Kubernetes Engine 和其他任何地方运行。</li>
<li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li>
<li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li>
<li>资源隔离：可预测的应用程序性能。</li>
<li>资源利用：高效率和高密度。</li>
</ul>
</li>
</ul>
<p><img alt="Container Evolution" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-07_container-evolution.svg"></p>
<p>沿着虚拟化的路径，容器流行后需要有容器编排管理的服务，于是诞生了kubernetes。</p>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul>
<li><p><strong>服务发现与负载均衡</strong></p>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
</li>
<li><p><strong>存储编排</strong></p>
<p>Kubernetes 允许自动挂载选择的存储系统，例如本地存储、公共云提供商等。</p>
</li>
<li><p><strong>自动二进制打包</strong><br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p>
</li>
<li><p><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p>
</li>
<li><p><strong>密钥与配置管理</strong><br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 </p>
</li>
</ul>
<h2 id="Kubernetes-Components"><a href="#Kubernetes-Components" class="headerlink" title="Kubernetes Components"></a>Kubernetes Components</h2><p>Kubernetes集群是由众多的Node组成，遵循主从架构，整个Kubernetes集群可以被划分为控制面和控制面管理的众多Node。</p>
<p><img alt="Kubernetes Components" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-07_components-of-kubernetes.png"></p>
<h3 id="Control-Plane-Components"><a href="#Control-Plane-Components" class="headerlink" title="Control Plane Components"></a>Control Plane Components</h3><p>Kubernetes 的控制面负责对集群作出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的Pod）。控制面的组建可以在集群中的任意节点中运行，但是通常会在同一个节点上启动所有控制面的组建，并且这个节点不再运行用户容器，此即称作Master节点。控制面的每一个组件都既可以运行在单master节点，也可以运行在多master节点以实现高可用。</p>
<p>Master节点包含四个主要的组件：API Server、Controller Manager、Scheduler 以及 Etcd，如下图所示。</p>
<p><img alt="Control Plane" data-src="https://platform9.com/wp-content/uploads/2019/05/kubernetes-constructs-concepts-architecture.jpg"></p>
<h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>kube-apiserver 是 Kubernetes 最重要的核心组件之一，暴露了Kubernetes API，是控制面的前端组件，它主要提供以下的功能：</p>
<ul>
<li>提供集群管理的 REST API 接口，实现了认证、授权、准入控制等安全校验功能，同时也负责集群状态的存储操作（通过 etcd）。</li>
<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</li>
</ul>
<p><img alt="Kube Api Server" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-07_kube-apiserver.png"></p>
<p>在实际使用中，通常通过 <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/" target="_blank" rel="external nofollow noopener noreferrer">kubectl</a> 来访问 apiserver，也可以通过 Kubernetes 各个语言的 client 库来访问 apiserver。在使用 kubectl 时，打开调试日志也可以看到每个 API 调用的格式，比如</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl --v=8 get pods</span><br></pre></td></tr></table></figure>
<p>可通过 <code>kubectl api-versions</code> 和 <code>kubectl api-resources</code> 查询 Kubernetes API 支持的 API 版本以及资源对象。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl api-versions</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br><span class="line">apiextensions.k8s.io/v1beta1</span><br><span class="line">apiregistration.k8s.io/v1</span><br><span class="line">apiregistration.k8s.io/v1beta1</span><br><span class="line">apps/v1</span><br><span class="line">apps/v1beta1</span><br><span class="line">apps/v1beta2</span><br><span class="line">authentication.k8s.io/v1</span><br><span class="line">authentication.k8s.io/v1beta1</span><br><span class="line">authorization.k8s.io/v1</span><br><span class="line">authorization.k8s.io/v1beta1</span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">batch/v1</span><br><span class="line">batch/v1beta1</span><br><span class="line">certificates.k8s.io/v1beta1</span><br><span class="line">events.k8s.io/v1beta1</span><br><span class="line">extensions/v1beta1</span><br><span class="line">metrics.k8s.io/v1beta1</span><br><span class="line">networking.k8s.io/v1</span><br><span class="line">policy/v1beta1</span><br><span class="line">rbac.authorization.k8s.io/v1</span><br><span class="line">rbac.authorization.k8s.io/v1beta1</span><br><span class="line">scheduling.k8s.io/v1beta1</span><br><span class="line">storage.k8s.io/v1</span><br><span class="line">storage.k8s.io/v1beta1</span><br><span class="line">v1</span><br><span class="line"></span><br><span class="line">$ kubectl api-resources --api-group=storage.k8s.io</span><br><span class="line">NAME                SHORTNAMES   APIGROUP         NAMESPACED   KIND</span><br><span class="line">storageclasses      sc           storage.k8s.io   <span class="literal">false</span>        StorageClass</span><br><span class="line">volumeattachments                storage.k8s.io   <span class="literal">false</span>        VolumeAttachment</span><br></pre></td></tr></table></figure>
<h4 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h4><p>Etcd是一个分布式的键值数据库，兼具一致性和高可用性，API Server 中所需要的这些原信息都被放置在 etcd 中。Etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。</p>
<h4 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h4><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p>
<p><img alt="controller manager" data-src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/controller-manager.png"></p>
<p>每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。从逻辑上讲，每个<a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="external nofollow noopener noreferrer">控制器</a>都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p>
<p>这些控制器包括:</p>
<ul>
<li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li>
<li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li>
<li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li>
<li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li>
</ul>
<p>我们刚刚提到的 API Server，它本身在部署结构上是一个可以水平扩展的一个部署组件；Controller 是一个可以进行热备的一个部署组件，它只有一个 active，它的调度器也是相应的，虽然只有一个 active，但是可以进行热备。</p>
<h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>Scheduler是Master节点上的调度器组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p>
<p>Scheduler在整个系统中起”承上启下”作用：</p>
<ul>
<li>承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node</li>
<li>启下：Node上的kubelet接管Pod的生命周期。</li>
</ul>
<p>Scheduler的主要工作：</p>
<ul>
<li><p>通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中</p>
</li>
<li><p>kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</p>
<p><img alt="Scheduler" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/scheduler.png"></p>
</li>
</ul>
<p>Scheduler的调度流程：</p>
<ul>
<li>预选调度过程，即遍历所有目标Node，筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择</li>
<li>确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。</li>
</ul>
<p>调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。</p>
<h3 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a><strong>Node Components</strong></h3><p>Kubernetes 的 Node 是真正运行业务负载的，每个业务负载会以 Pod 的形式运行。一个 Pod 中运行的一个或者多个容器，真正去运行这些 Pod 的组件的是叫做 <strong>kubelet</strong>，也就是 Node 上最为关键的组件，它通过 API Server 接收到所需要 Pod 运行的状态，然后提交到 Container Runtime 组件中。</p>
<p>在 OS 上去创建容器所需要运行的环境，最终把容器或者 Pod 运行起来，也需要对存储跟网络进行管理。Kubernetes 并不会直接进行网络存储的操作，他们会靠 Storage Plugin 或者是网络的 Plugin 来进行操作。用户自己或者云厂商都会去写相应的 <strong>Storage Plugin</strong> 或者 <strong>Network Plugin</strong>，去完成存储操作或网络操作。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/5c/f8/5c9fe50067821e9e86a74cae4cbdd9f8.png"></p>
<h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>Kubelet是Node上的pod管家。在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。</p>
<h4 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h4><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="external nofollow noopener noreferrer">kube-proxy</a> 是集群中每个节点上运行的网络代理,实现 Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service</a> 概念的一部分。</p>
<p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。</p>
<h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>Container Runtime（容器运行时）是负责容器运行的软件。</p>
<p>Kubernetes支持几种容器运行时环境：Docker、Containerd、CRI-O等。</p>
<h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a><strong>Addons</strong></h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>尽管并非严格要求其他附加组件，但所有示例都依赖<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="external nofollow noopener noreferrer">集群 DNS</a>，因此所有 Kubernetes 集群都应具有 DNS。</p>
<p>除了您环境中的其他 DNS 服务器之外，集群 DNS 还是一个 DNS 服务器，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Cluster DNS 是一个 DNS 服务器，和您部署环境中的其他 DNS 服务器一起工作，为 Kubernetes 服务提供DNS记录。</p>
<p>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中。</p>
<h4 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h4><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="external nofollow noopener noreferrer">Dashboard</a> 是 Kubernetes 集群的通用基于 Web 的 UI。它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p>
<h4 id="Container-Resource-Monitoring"><a href="#Container-Resource-Monitoring" class="headerlink" title="Container Resource Monitoring"></a>Container Resource Monitoring</h4><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="external nofollow noopener noreferrer">容器资源监控</a>将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p>
<h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="external nofollow noopener noreferrer">集群层面日志</a> 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面我们以一个例子再去看一下 Kubernetes 架构中的这些组件，是如何互相进行 interaction 的。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/04/9b/047e4723316d6424b26341de5007329b.png"></p>
<p>用户可以通过 UI 或者 CLI 提交一个 Pod 给 Kubernetes 进行部署，这个 Pod 请求首先会通过 CLI 或者 UI 提交给 Kubernetes API Server，下一步 API Server 会把这个信息写入到它的存储系统 etcd，之后 Scheduler 会通过 API Server 的 watch 或者叫做 notification 机制得到这个信息：有一个 Pod 需要被调度。</p>
<p>这个时候 Scheduler 会根据它的内存状态进行一次调度决策，在完成这次调度之后，它会向 API Server report 说：“OK！这个 Pod 需要被调度到某一个节点上。”</p>
<p>这个时候 API Server 接收到这次操作之后，会把这次的结果再次写到 etcd 中，然后 API Server 会通知相应的节点进行这次 Pod 真正的执行启动。相应节点的 kubelet 会得到这个通知，kubelet 就会去调 Container runtime 来真正去启动配置这个容器和这个容器的运行环境，去调度 Storage Plugin 来去配置存储，network Plugin 去配置网络。</p>
<p>这个例子我们可以看到：这些组件之间是如何相互沟通相互通信，协调来完成一次 Pod 的调度执行操作的。</p>
<h2 id="The-Kubernetes-API"><a href="#The-Kubernetes-API" class="headerlink" title="The Kubernetes API"></a>The Kubernetes API</h2><p>Kubernetes API 允许你查询和操作 Kubernetes 集群中对象的状态。Kubernetes集群控制面的核心是 Api Server 以及他暴露的 HTTP API。用户，集群中的其他部分，还有外部组件都是通过API Server进行通信。</p>
<h3 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h3><p>为了使删除字段或者重构资源表示更加容易，Kubernetes 支持 多个API版本。每一个版本都在不同API路径下，例如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1</code>。</p>
<p>我们选择在API级别进行版本化，而不是在资源或字段级别进行版本化，以确保API提供清晰，一致的系统资源和行为视图，并控制对已废止的API和/或实验性API的访问。 JSON和Protobuf序列化模式遵循架构更改的相同准则 - 下面的所有描述都同时适用于这两种格式。</p>
<p>请注意，API版本控制和软件版本控制只有间接相关性。 <a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md" target="_blank" rel="external nofollow noopener noreferrer">API和发行版本建议</a> 描述了API版本与软件版本之间的关系。</p>
<p>不同的API版本名称意味着不同级别的软件稳定性和支持程度。 每个级别的标准在<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions" target="_blank" rel="external nofollow noopener noreferrer">API变更文档</a>中有更详细的描述。 内容主要概括如下：</p>
<ul>
<li>Alpha 测试版本：<ul>
<li>版本名称包含了 <strong><code>alpha</code></strong> (例如：<strong><code>v1alpha1</code></strong>)。</li>
<li>可能是有缺陷的。启用该功能可能会带来隐含的问题，默认情况是关闭的。</li>
<li>支持的功能可能在没有通知的情况下随时删除。</li>
<li>API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知。</li>
<li>由于bugs风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</li>
</ul>
</li>
<li>Beta 测试版本：<ul>
<li>版本名称包含了 <strong><code>beta</code></strong> (例如: <strong><code>v2beta3</code></strong>)。</li>
<li>代码已经测试过。启用该功能被认为是安全的，功能默认已启用。</li>
<li>所有已支持的功能不会被删除，细节可能会发生变化。</li>
<li>对象的模式和/或语义可能会在后续的beta测试版或稳定版中以不兼容的方式进行更改。 发生这种情况时，我们将提供迁移到下一个版本的说明。 这可能需要删除、编辑和重新创建API对象。执行编辑操作时需要谨慎行事，这可能需要停用依赖该功能的应用程序。</li>
<li>建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。 如果您有多个可以独立升级的集群，则可以放宽此限制。</li>
<li><strong>请尝试我们的 beta 版本功能并且给出反馈！一旦他们退出 beta 测试版，我们可能不会做出更多的改变。</strong></li>
</ul>
</li>
<li>稳定版本：<ul>
<li>版本名称是 <strong><code>vX</code></strong>，其中 <strong><code>X</code></strong> 是整数。</li>
</ul>
</li>
</ul>
<h3 id="API-描述"><a href="#API-描述" class="headerlink" title="API 描述"></a>API 描述</h3><p>下面我们介绍一下 Kubernetes 的 API 的基础知识。从 high-level 上看，Kubernetes API 是由 <strong>HTTP+JSON </strong> 组成的：用户访问的方式是 HTTP，访问的 API 中 content 的内容是 JSON 格式的。</p>
<p>Kubernetes 的 kubectl 也就是 command tool，Kubernetes UI，或者有时候用 curl，直接与 Kubernetes 进行沟通，都是使用 HTTP + JSON 这种形式。</p>
<p>下面有个例子：比如说，对于这个 Pod 类型的资源，它的 HTTP 访问的路径，就是 API，然后是 apiVesion: V1, 之后是相应的 Namespaces，以及 Pods 资源，最终是 Podname，也就是 Pod 的名字。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/23/2e/23921b341e482ad31ce28fc15269ad2e.png"></p>
<p>如果我们去提交一个 Pod，或者 get 一个 Pod 的时候，它的 content 内容都是用 JSON 或者是 YAML 表达的。上图中有个 yaml 的例子，在这个 yaml file 中，对 Pod 资源的描述也分为几个部分。</p>
<p>第一个部分，一般来讲会是 API 的 <strong>version</strong>。比如在这个例子中是 V1，它也会描述我在操作哪个资源；比如说我的 <strong>kind</strong> 如果是 pod，在 Metadata 中，就写上这个 Pod 的名字；比如说 nginx，我们也会给它打一些 <strong>label</strong>，我们等下会讲到 label 的概念。在 Metadata 中，有时候也会去写 <strong>annotation</strong>，也就是对资源的额外的一些用户层次的描述。</p>
<h2 id="Kubernetes-Objects"><a href="#Kubernetes-Objects" class="headerlink" title="Kubernetes Objects"></a>Kubernetes Objects</h2><p>Kubernetes对象是Kubernetes集群中持久化的实体，通过这些实体可以代表集群的状态。具体的，它们可以描述以下内容：</p>
<ul>
<li>哪些容器化应用在运行（以及在哪个 Node 上）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li>
</ul>
<p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p>
<p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>。比如，当使用 <code>kubectl</code> 命令行接口时，CLI 会执行必要的 Kubernetes API 调用，也可以在程序中使用 <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="external nofollow noopener noreferrer">客户端库</a> 直接调用 Kubernetes API。</p>
<h3 id="Object-Spec-and-Status"><a href="#Object-Spec-and-Status" class="headerlink" title="Object Spec and Status"></a>Object Spec and Status</h3><p>每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象 <em>spec</em> 和 对象 <em>status</em> 。 <em>spec</em> 是必需的，它描述了对象的 <em>期望状态（Desired State）</em> —— 希望对象所具有的特征。 <em>status</em> 描述了对象的 <em>实际状态（Actual State）</em> ，它是由 Kubernetes 系统提供和更新的。在任何时刻，Kubernetes 控制面一直努力地管理着对象的实际状态以与期望状态相匹配。</p>
<p>例如，Kubernetes Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能需要设置 Deployment 的规约，以指定该应用需要有 3 个副本在运行。 Kubernetes 系统读取 Deployment 规约，并启动我们所期望的该应用的 3 个实例 —— 更新状态以与规约相匹配。 如果那些实例中有失败的（一种状态变更），Kubernetes 系统通过修正来响应规约和状态之间的不一致 —— 这种情况，会启动一个新的实例来替换。</p>
<p>关于对象 spec、status 和 metadata 的更多信息，查看 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 约定</a>。</p>
<h3 id="Describing-a-Kubernetes-object"><a href="#Describing-a-Kubernetes-object" class="headerlink" title="Describing a Kubernetes object"></a>Describing a Kubernetes object</h3><p>当创建 Kubernetes 对象时，必须提供对象的Spec，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>），API 请求必须在请求体中包含 JSON 格式的信息。 <strong>大多数情况下，需要在 .yaml 文件中为 <code>kubectl</code> 提供这些信息</strong>。 <code>kubectl</code> 在发起 API 请求时，将这些信息转换成 JSON 格式。</p>
<p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：</p>
<figure class="highlight yaml"><figcaption><span>application/deployment.yaml </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h3 id="Required-Fields"><a href="#Required-Fields" class="headerlink" title="Required Fields"></a>Required Fields</h3><p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p>
<ul>
<li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><code>kind</code> - 想要创建的对象的类型</li>
<li><code>metadata</code> - 帮助识别对象唯一性的数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li>
<li><code>spec</code> - 你对该对象期望的状态</li>
</ul>
<p>对象 <code>spec</code> 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 参考</a>能够帮助我们找到任何我们想创建的对象的 spec 格式。 例如，可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Pod</code> 的 <code>spec</code> 格式， 并且可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deploymentspec-v1-apps" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Deployment</code> 的 <code>spec</code> 格式。</p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是 Kubernetes 应用程序的基本执行单元，是Kubernetes对象模型中创建的最小单元，Pod表示集群是运行的进程。</p>
<p>用户可以通过 Kubernetes 的 Pod API 生产一个 Pod，让 Kubernetes 对这个 Pod 进行调度，也就是把它放在某一个 Kubernetes 管理的节点上运行起来。一个 Pod 简单来说是对一组容器的抽象，它里面会包含一个或多个容器。</p>
<p>比如像下面的这幅图里面，它包含了两个容器，每个容器可以指定它所需要资源大小。比如说，一个核一个 G，或者说 0.5 个核，0.5 个 G。</p>
<p>当然在这个 Pod 中也可以包含一些其他所需要的资源：比如说我们所看到的 Volume 卷这个存储资源；比如说我们需要 100 个 GB 的存储或者 20GB 的另外一个存储。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/b2/9f/b246d174b3169a242ac5799bc962f69f.png"></p>
<p>在 Pod 里面，我们也可以去定义容器所需要运行的方式。比如说运行容器的 Command，以及运行容器的环境变量等等。Pod 这个抽象也给这些容器提供了一个共享的运行环境，它们会共享同一个网络环境，这些容器可以用 localhost 来进行直接的连接。而 Pod 与 Pod 之间，是互相有 isolation 隔离的。</p>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume 就是卷的概念，它是用来管理 Kubernetes 存储的，是用来声明在 Pod 中的容器可以访问文件目录的，一个卷可以被挂载在 Pod 中一个或者多个容器的指定路径下面。</p>
<p>而 Volume 本身是一个抽象的概念，一个 Volume 可以去支持多种的后端的存储。比如说 Kubernetes 的 Volume 就支持了很多存储插件，它可以支持本地的存储，可以支持分布式的存储，比如说像 ceph，GlusterFS ；它也可以支持云存储，比如说阿里云上的云盘、AWS 上的云盘、Google 上的云盘等等。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/54/5b/542cf5c317c5e567ba63a720802ae85b.png"></p>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 是在 Pod 这个抽象上更为上层的一个抽象，它可以定义一组 Pod 的副本数目、以及这个 Pod 的版本。一般大家用 Deployment 这个抽象来做应用的真正的管理，而 Pod 是组成 Deployment 最小的单元。</p>
<p>Kubernetes 是通过 Controller，也就是我们刚才提到的控制器去维护 Deployment 中 Pod 的数目，它也会去帮助 Deployment 自动恢复失败的 Pod。</p>
<p>比如说我可以定义一个 Deployment，这个 Deployment 里面需要两个 Pod，当一个 Pod 失败的时候，控制器就会监测到，它重新把 Deployment 中的 Pod 数目从一个恢复到两个，通过再去新生成一个 Pod。通过控制器，我们也会帮助完成发布的策略。比如说进行滚动升级，进行重新生成的升级，或者进行版本的回滚。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/4e/e2/4ea8feaad09e871bbca804e7f61738e2.png"></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 提供了一个或者多个 Pod 实例的稳定访问地址。</p>
<p>比如在上面的例子中，我们看到：一个 Deployment 可能有两个甚至更多个完全相同的 Pod。对于一个外部的用户来讲，访问哪个 Pod 其实都是一样的，所以它希望做一次负载均衡，在做负载均衡的同时，我只想访问某一个固定的 VIP，也就是 Virtual IP 地址，而不希望得知每一个具体的 Pod 的 IP 地址。</p>
<p>我们刚才提到，这个 pod 本身可能 terminal go（终止），如果一个 Pod 失败了，可能会换成另外一个新的。</p>
<p>对一个外部用户来讲，提供了多个具体的 Pod 地址，这个用户要不停地去更新 Pod 地址，当这个 Pod 再失败重启之后，我们希望有一个抽象，把所有 Pod 的访问能力抽象成一个第三方的一个 IP 地址，实现这个的 Kubernetes 的抽象就叫 Service。</p>
<p>实现 Service 有多种方式，Kubernetes 支持 Cluster IP，上面我们讲过的 kuber-proxy 的组网，它也支持 nodePort、 LoadBalancer 等其他的一些访问的能力。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/bb/4a/bbcd5a617d228099f69ddc987ca18f4a.png"></p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace 是用来做一个集群内部的逻辑隔离的，它包括鉴权、资源管理等。Kubernetes 的每个资源，比如刚才讲的 Pod、Deployment、Service 都属于一个 Namespace，同一个 Namespace 中的资源需要命名的唯一性，不同的 Namespace 中的资源可以重名。</p>
<p>Namespace 一个用例，比如像在阿里巴巴，我们内部会有很多个 business units，在每一个 business units 之间，希望有一个视图上的隔离，并且在鉴权上也不一样，在 cuda 上面也不一样，我们就会用 Namespace 来去给每一个 BU 提供一个他所看到的这么一个看到的隔离的机制。</p>
<p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/a0/4d/a00719f494ae94a40be0be6012e5134d.png"></p>
<h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><p>参考 <a href="https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl</span></span><br><span class="line"><span class="comment">## 声明式资源管理</span></span><br><span class="line"><span class="comment"># kubectl apply</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令式资源管理</span></span><br><span class="line"><span class="comment"># kubectl create</span></span><br><span class="line"><span class="comment"># kubectl expose</span></span><br><span class="line"><span class="comment"># kubectl scale</span></span><br><span class="line"><span class="comment"># kubectl annotate</span></span><br><span class="line"><span class="comment"># kubectl label</span></span><br><span class="line"><span class="comment"># kubectl delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl get</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl get [(-o|--output=)](TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags] [options]</span><br><span class="line"><span class="comment"># Examples: </span></span><br><span class="line">kubectl get services                          <span class="comment"># 列出当前NS中所有service资源</span></span><br><span class="line">kubectl get pods --all-namespaces             <span class="comment"># 列出集群所有NS中所有的Pod</span></span><br><span class="line">kubectl get pods -o wide                      <span class="comment"># -o wide也比较常用，可以显示更多资源信息，比如pod的IP等</span></span><br><span class="line">kubectl get deployment my-dep                 <span class="comment"># 可以直接指定资源名查看</span></span><br><span class="line">kubectl get deployment my-dep --watch         <span class="comment"># --watch 参数可以监控资源的状态，在状态变换时输出。在跟踪服务部署情况时很有用</span></span><br><span class="line">kubectl get pod my-pod -o yaml                <span class="comment"># 查看yaml格式的资源配置，这里包括资实际的status，可以用--export排除</span></span><br><span class="line">kubectl get pod my-pod -l app=nginx           <span class="comment"># 查看所有带有标签app: nginx的pod</span></span><br><span class="line"><span class="comment"># kubectl describe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器管理</span></span><br><span class="line"><span class="comment"># kubectl log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl exec</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> POD [-c CONTAINER] -- COMMAND [args...] [options]</span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod ls                         <span class="comment"># 对my-pod执行ls命令</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -t -i nginx-78f5d695bd-czm8z bash <span class="comment"># 进入pod的shell，并打开伪终端和标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl cp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 集群管理</span></span><br><span class="line"><span class="comment"># kubectl cluster-info</span></span><br><span class="line"><span class="comment"># kubectl version</span></span><br><span class="line"><span class="comment"># kubectl cordon/uncordon</span></span><br><span class="line"><span class="comment"># kubectl drain</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>k8s</tag>
        <tag>CNCF</tag>
        <tag>源码阅读</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>【Awesome Go】Cobra</title>
    <url>/posts/171a4821/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Cobra是一个为创建命令行程序提供了强大接口的Go Library，同时也是一个用来生成应用框架的应用程序。在Go的世界中，很多 <a href="https://github.com/spf13/cobra/blob/master/projects_using_cobra.md" target="_blank" rel="external nofollow noopener noreferrer">知名项目</a> 比如Docker、Kubernetes、Hugo等都使用了Cobra。本文将介绍Cobra包的基本使用，并介绍其实现原理，本文中使用的代码可以参考我的 <a href="https://github.com/SimpCosm/cobrademo" target="_blank" rel="external nofollow noopener noreferrer">github</a>。</p>
<a id="more"></a>
<p>Cobra包提供了以下特性：</p>
<ul>
<li>简易的子命令行模式，如 app server， app fetch 等等</li>
<li>完全兼容 posix 命令行模式，包括short&amp;long versions</li>
<li>嵌套子命令 subcommand</li>
<li>支持全局，局部，级联 flags</li>
<li>使用 cobra 很容易的生成应用程序和命令，使用 <code>cobra init appname</code> 和 <code>cobra add cmdname</code></li>
<li>如果命令输入错误，将提供智能建议，如 <code>app srver</code>，将提示 <code>did you mean app server</code></li>
<li>自动生成 commands 和 flags 的帮助信息</li>
<li>自动生成详细的 help 信息，如 app help</li>
<li>自动识别帮助 flag -h，—help</li>
<li>自动生成应用程序在 bash 下命令自动完成功能</li>
<li>自动生成应用程序的 man 手册</li>
<li>命令行别名</li>
<li>自定义 help 和 usage 信息</li>
<li>可选的与 viper apps 的紧密集成</li>
</ul>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>cobra 中有个重要的概念，分别是 commands、arguments 和 flags。其中 commands 代表行为，arguments 就是命令行参数(或者称为位置参数)，flags 代表对行为的改变(也就是我们常说的命令行选项)。执行命令行程序时的一般格式为：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">APPNAME COMMAND ARG <span class="comment">--FLAG</span></span><br></pre></td></tr></table></figure>
<p>比如下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server是 commands，port 是 flag</span></span><br><span class="line">hugo server --port=1313</span><br><span class="line"></span><br><span class="line"><span class="comment"># clone 是 commands，URL 是 arguments，brae 是 flag</span></span><br><span class="line">git <span class="built_in">clone</span> URL --bare</span><br></pre></td></tr></table></figure>
<p>如果是一个简单的程序(功能单一的程序)，使用 commands 的方式可能会很啰嗦，但是像 git、docker 等应用，把这些本就很复杂的功能划分为子命令的形式，会方便使用(对程序的设计者来说又何尝不是如此)。</p>
<p>Cobra支持像 <a href="https://golang.org/pkg/flag/" target="_blank" rel="external nofollow noopener noreferrer">Go flag</a> 一样的兼容POSIX的命令行参数，通过 <a href="https://github.com/spf13/pflag" target="_blank" rel="external nofollow noopener noreferrer">pflag library</a> 支持。</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="创建-cobra-应用"><a href="#创建-cobra-应用" class="headerlink" title="创建 cobra 应用"></a>创建 cobra 应用</h3><p>在创建 cobra 应用前需要先安装 cobra 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/spf13/cobra/cobra</span><br></pre></td></tr></table></figure>
<p>然后就可以使用 cobra 生成应用程序框架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $</span><br><span class="line">╰─ cobra init cobrademo --pkg-name github.com/SimpCosm/cobrademo                            </span><br><span class="line">Your Cobra application is ready at</span><br><span class="line">/Users/houmin/go/src/github.com/SimpCosm/cobrademo</span><br></pre></td></tr></table></figure>
<p>生成目录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $</span><br><span class="line">╰─ tree                                                                                     </span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── cmd</span><br><span class="line">│   └── root.go</span><br><span class="line">└── main.go</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>
<p>查看生成代码：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/SimpCosm/cobrademo/cmd"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>main.go</code> 非常简单，主要代码逻辑在 <code>cmd/root.go</code> 中</p>
<figure class="highlight go"><figcaption><span>cmd/root.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">	homedir <span class="string">"github.com/mitchellh/go-homedir"</span></span><br><span class="line">	<span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cfgFile <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rootCmd represents the base command when called without any subcommands</span></span><br><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">	Use:   <span class="string">"cobrademo"</span>,</span><br><span class="line">	Short: <span class="string">"A brief description of your application"</span>,</span><br><span class="line">	Long: <span class="string">`A longer description that spans multiple lines and likely contains</span></span><br><span class="line"><span class="string">examples and usage of using your application. For example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Cobra is a CLI library for Go that empowers applications.</span></span><br><span class="line"><span class="string">This application is a tool to generate the needed files</span></span><br><span class="line"><span class="string">to quickly create a Cobra application.`</span>,</span><br><span class="line">	<span class="comment">// Uncomment the following line if your bare application</span></span><br><span class="line">	<span class="comment">// has an action associated with it:</span></span><br><span class="line">	<span class="comment">//	Run: func(cmd *cobra.Command, args []string) &#123; &#125;,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute adds all child commands to the root command and sets flags appropriately.</span></span><br><span class="line"><span class="comment">// This is called by main.main(). It only needs to happen once to the rootCmd.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cobra.OnInitialize(initConfig)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here you will define your flags and configuration settings.</span></span><br><span class="line">	<span class="comment">// Cobra supports persistent flags, which, if defined here,</span></span><br><span class="line">	<span class="comment">// will be global for your application.</span></span><br><span class="line"></span><br><span class="line">	rootCmd.PersistentFlags().StringVar(&amp;cfgFile, <span class="string">"config"</span>, <span class="string">""</span>, <span class="string">"config file (default is $HOME/.cobrademo.yaml)"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cobra also supports local flags, which will only run</span></span><br><span class="line">	<span class="comment">// when this action is called directly.</span></span><br><span class="line">	rootCmd.Flags().BoolP(<span class="string">"toggle"</span>, <span class="string">"t"</span>, <span class="literal">false</span>, <span class="string">"Help message for toggle"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initConfig reads in config file and ENV variables if set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cfgFile != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// Use config file from the flag.</span></span><br><span class="line">		viper.SetConfigFile(cfgFile)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Find home directory.</span></span><br><span class="line">		home, err := homedir.Dir()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Search config in home directory with name ".cobrademo" (without extension).</span></span><br><span class="line">		viper.AddConfigPath(home)</span><br><span class="line">		viper.SetConfigName(<span class="string">".cobrademo"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	viper.AutomaticEnv() <span class="comment">// read in environment variables that match</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a config file is found, read it in.</span></span><br><span class="line">	<span class="keyword">if</span> err := viper.ReadInConfig(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Using config file:"</span>, viper.ConfigFileUsed())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译程序并运行，可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./main                                                                                </span><br><span class="line">A longer description that spans multiple lines and likely contains</span><br><span class="line">examples and usage of using your application. For example:</span><br><span class="line"></span><br><span class="line">Cobra is a CLI library <span class="keyword">for</span> Go that empowers applications.</span><br><span class="line">This application is a tool to generate the needed files</span><br><span class="line">to quickly create a Cobra application.</span><br></pre></td></tr></table></figure>
<p>下面依次分析创建命令的每个部分。</p>
<h3 id="创建-rootCmd"><a href="#创建-rootCmd" class="headerlink" title="创建 rootCmd"></a>创建 rootCmd</h3><p>Cobra 不需要额外的创建特殊的构造函数，只需要简单的创建你自己的命令。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"hugo"</span>,</span><br><span class="line">  Short: <span class="string">"Hugo is a very fast static site generator"</span>,</span><br><span class="line">  Long: <span class="string">`A Fast and Flexible Static Site Generator built with</span></span><br><span class="line"><span class="string">                love by spf13 and friends in Go.</span></span><br><span class="line"><span class="string">                Complete documentation is available at http://hugo.spf13.com`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Do Stuff Here</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在 <code>init</code> 函数中定义命令行参数并处理配置文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">	homedir <span class="string">"github.com/mitchellh/go-homedir"</span></span><br><span class="line">	<span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">	<span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// Used for flags.</span></span><br><span class="line">	cfgFile     <span class="keyword">string</span></span><br><span class="line">	userLicense <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">		Use:   <span class="string">"cobra"</span>,</span><br><span class="line">		Short: <span class="string">"A generator for Cobra based Applications"</span>,</span><br><span class="line">		Long: <span class="string">`Cobra is a CLI library for Go that empowers applications.</span></span><br><span class="line"><span class="string">This application is a tool to generate the needed files</span></span><br><span class="line"><span class="string">to quickly create a Cobra application.`</span>,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute executes the root command.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rootCmd.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cobra.OnInitialize(initConfig)</span><br><span class="line"></span><br><span class="line">	rootCmd.PersistentFlags().StringVar(&amp;cfgFile, <span class="string">"config"</span>, <span class="string">""</span>, <span class="string">"config file (default is $HOME/.cobra.yaml)"</span>)</span><br><span class="line">	rootCmd.PersistentFlags().StringP(<span class="string">"author"</span>, <span class="string">"a"</span>, <span class="string">"YOUR NAME"</span>, <span class="string">"author name for copyright attribution"</span>)</span><br><span class="line">	rootCmd.PersistentFlags().StringVarP(&amp;userLicense, <span class="string">"license"</span>, <span class="string">"l"</span>, <span class="string">""</span>, <span class="string">"name of license for the project"</span>)</span><br><span class="line">	rootCmd.PersistentFlags().Bool(<span class="string">"viper"</span>, <span class="literal">true</span>, <span class="string">"use Viper for configuration"</span>)</span><br><span class="line">	viper.BindPFlag(<span class="string">"author"</span>, rootCmd.PersistentFlags().Lookup(<span class="string">"author"</span>))</span><br><span class="line">	viper.BindPFlag(<span class="string">"useViper"</span>, rootCmd.PersistentFlags().Lookup(<span class="string">"viper"</span>))</span><br><span class="line">	viper.SetDefault(<span class="string">"author"</span>, <span class="string">"NAME HERE &lt;EMAIL ADDRESS&gt;"</span>)</span><br><span class="line">	viper.SetDefault(<span class="string">"license"</span>, <span class="string">"apache"</span>)</span><br><span class="line"></span><br><span class="line">	rootCmd.AddCommand(addCmd)</span><br><span class="line">	rootCmd.AddCommand(initCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">er</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Error:"</span>, msg)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cfgFile != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// Use config file from the flag.</span></span><br><span class="line">		viper.SetConfigFile(cfgFile)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Find home directory.</span></span><br><span class="line">		home, err := homedir.Dir()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			er(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Search config in home directory with name ".cobra" (without extension).</span></span><br><span class="line">		viper.AddConfigPath(home)</span><br><span class="line">		viper.SetConfigName(<span class="string">".cobra"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	viper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := viper.ReadInConfig(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Using config file:"</span>, viper.ConfigFileUsed())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动生成子命令"><a href="#自动生成子命令" class="headerlink" title="自动生成子命令"></a>自动生成子命令</h3><p>除了生成应用程序框架，还可以通过 cobra add 命令生成子命令的代码文件，比如下面的命令会添加子命令 image 和 相关的代码文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $                                   </span><br><span class="line">╰─ cobra add image                                                                          </span><br><span class="line">image created at /Users/houmin/go/src/github.com/SimpCosm/cobrademo</span><br><span class="line"></span><br><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $                              </span><br><span class="line">╰─ tree                                                                                     </span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── image.go</span><br><span class="line">│   └── root.go</span><br><span class="line">└── main.go</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure>
<h3 id="创建自定义命令"><a href="#创建自定义命令" class="headerlink" title="创建自定义命令"></a>创建自定义命令</h3><p>打开文件 root.go ，找到变量 rootCmd 的初始化过程并为之设置 Run 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"cobra demo program created by houmin."</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>编译之后并不带参数运行，这次就不再输出帮助信息了，而是执行了 rootCmd 的 Run 方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./main                                  </span><br><span class="line">cobra demo program created by houmin.</span><br></pre></td></tr></table></figure>
<p>再创建一个 version Command 用来输出当前的软件版本。先在 cmd 目录下添加 version.go 文件，编辑文件的内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rootCmd.AddCommand(versionCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"version"</span>,</span><br><span class="line">  Short: <span class="string">"Print the version number of crddemo"</span>,</span><br><span class="line">  Long:  <span class="string">`All software has versions. This is crddemo's`</span>,</span><br><span class="line">  Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"cobrademo version is v0.1"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译程序运行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./main version                                                                           </span><br><span class="line">cobrademo version is v0.1</span><br></pre></td></tr></table></figure>
<p>如果你想要获得执行命令返回的错误，可以使用 <code>RunE</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rootCmd.AddCommand(tryCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tryCmd = &amp;cobra.Command&#123;</span><br><span class="line">  Use:   <span class="string">"try"</span>,</span><br><span class="line">  Short: <span class="string">"Try and possibly fail at something"</span>,</span><br><span class="line">  RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := someFunc(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建命令行-Flags"><a href="#创建命令行-Flags" class="headerlink" title="创建命令行 Flags"></a>创建命令行 Flags</h3><p>选项(flags)用来控制 Command 的具体行为。根据选项的作用范围，可以把选项分为两类：</p>
<ul>
<li><strong>persistent</strong></li>
<li><strong>local</strong></li>
</ul>
<p>对于 persistent 类型的选项，既可以设置给该 Command，又可以设置给该 Command 的子 Command。对于一些全局性的选项，比较适合设置为 persistent 类型，比如控制输出的 verbose 选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Verbose <span class="keyword">bool</span></span><br><span class="line">rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, <span class="string">"verbose"</span>, <span class="string">"v"</span>, <span class="literal">false</span>, <span class="string">"verbose output"</span>)</span><br></pre></td></tr></table></figure>
<p>local 类型的选项只能设置给指定的 Command，比如下面定义的 source 选项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Source <span class="keyword">string</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;Source, <span class="string">"source"</span>, <span class="string">"s"</span>, <span class="string">""</span>, <span class="string">"Source directory to read from"</span>)</span><br></pre></td></tr></table></figure>
<p>该选项不能指定给 rootCmd 之外的其它 Command。<br>默认情况下的选项都是可选的，但一些用例要求用户必须设置某些选项，这种情况 cobra 也是支持的，通过 Command 的 <code>MarkFlagRequired</code> 方法标记该选项即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Name <span class="keyword">string</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;Name, <span class="string">"name"</span>, <span class="string">"n"</span>, <span class="string">""</span>, <span class="string">"user name (required)"</span>)</span><br><span class="line">rootCmd.MarkFlagRequired(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建命令行参数"><a href="#创建命令行参数" class="headerlink" title="创建命令行参数"></a>创建命令行参数</h3><p>首先我们来搞清楚命令行参数(arguments)与命令行选项的区别(flags/options)。以常见的 ls 命令来说，其命令行的格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls [OPTION] ... [FILE] ...</span><br></pre></td></tr></table></figure>
<p>其中的 OPTION 对应本文中介绍的 flags，以 - 或 — 开头；而 FILE 则被称为参数(arguments)或位置参数。一般的规则是参数在所有选项的后面，上面的 … 表示可以指定多个选项和多个参数。</p>
<p>cobra 默认提供了一些验证方法：</p>
<ul>
<li>NoArgs - 如果存在任何位置参数，该命令将报错</li>
<li>ArbitraryArgs - 该命令会接受任何位置参数</li>
<li>OnlyValidArgs - 如果有任何位置参数不在命令的 ValidArgs 字段中，该命令将报错</li>
<li>MinimumNArgs(int) - 至少要有 N 个位置参数，否则报错</li>
<li>MaximumNArgs(int) - 如果位置参数超过 N 个将报错</li>
<li>ExactArgs(int) - 必须有 N 个位置参数，否则报错</li>
<li>ExactValidArgs(int) 必须有 N 个位置参数，且都在命令的 ValidArgs 字段中，否则报错</li>
<li>RangeArgs(min, max) - 如果位置参数的个数不在区间 min 和 max 之中，报错</li>
</ul>
<p>比如要让 Command cmdTimes 至少有一个位置参数，可以这样初始化它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdTimes = &amp;cobra.Command&#123;</span><br><span class="line">    Use: …</span><br><span class="line">    Short: …</span><br><span class="line">    Long: …</span><br><span class="line">    Args: cobra.MinimumNArgs(<span class="number">1</span>),</span><br><span class="line">    Run: …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在前面创建的代码的基础上，为 image 命令添加行为(打印信息到控制台)，并为它添加一个子命令 cmdTimes，下面是更新后的 image.go 文件的内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> echoTimes <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// imageCmd represents the image command</span></span><br><span class="line"><span class="keyword">var</span> imageCmd = &amp;cobra.Command&#123;</span><br><span class="line">	Use:   <span class="string">"image [argument]"</span>,</span><br><span class="line">	Short: <span class="string">"Print images information"</span>,</span><br><span class="line">	Long:  <span class="string">"Print all images information"</span>,</span><br><span class="line">	Args:  cobra.MinimumNArgs(<span class="number">1</span>),</span><br><span class="line">	Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; echoTimes; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Echo: "</span> + strings.Join(args, <span class="string">" "</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rootCmd.AddCommand(imageCmd)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Here you will define your flags and configuration settings.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cobra supports local flags which will only run when this command</span></span><br><span class="line">	<span class="comment">// is called directly, e.g.:</span></span><br><span class="line">	imageCmd.Flags().IntVarP(&amp;echoTimes, <span class="string">"times"</span>, <span class="string">"t"</span>, <span class="number">1</span>, <span class="string">"times to echo the input"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $</span><br><span class="line">╰─ ./main image                                                                            </span><br><span class="line">Error: requires at least 1 arg(s), only received 0</span><br><span class="line">Usage:</span><br><span class="line">  cobrademo image [argument] [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --<span class="built_in">help</span>        <span class="built_in">help</span> <span class="keyword">for</span> image</span><br><span class="line">  -t, --<span class="built_in">times</span> int   <span class="built_in">times</span> to <span class="built_in">echo</span> the input (default 1)</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --config string   config file (default is <span class="variable">$HOME</span>/.cobrademo.yaml)</span><br><span class="line"></span><br><span class="line">requires at least 1 arg(s), only received 0</span><br><span class="line"></span><br><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $</span><br><span class="line">╰─ ./main image -t 3 houmin                                                                 </span><br><span class="line">Echo: houmin</span><br><span class="line">Echo: houmin</span><br><span class="line">Echo: houmin</span><br></pre></td></tr></table></figure>
<h3 id="帮助信息-help-command"><a href="#帮助信息-help-command" class="headerlink" title="帮助信息 help command"></a>帮助信息 help command</h3><p>cobra 会自动添加 —help(-h)选项，所以我们可以不必添加该选项而直接使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─ ~/go/src/github.com/SimpCosm/cobrademo $</span><br><span class="line">╰─ ./main --<span class="built_in">help</span> </span><br><span class="line">long description shows how to use cobra package</span><br><span class="line"></span><br><span class="line">Cobra is a CLI library <span class="keyword">for</span> Go that empowers applications.</span><br><span class="line">This application is a tool to generate the needed files</span><br><span class="line">to quickly create a Cobra application.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  cobrademo [flags]</span><br><span class="line">  cobrademo [<span class="built_in">command</span>]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  <span class="built_in">help</span>        Help about any <span class="built_in">command</span></span><br><span class="line">  image       Print images information</span><br><span class="line">  version     Print the version number of crddemo</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --config string   config file (default is <span class="variable">$HOME</span>/.cobrademo.yaml)</span><br><span class="line">  -h, --<span class="built_in">help</span>            <span class="built_in">help</span> <span class="keyword">for</span> cobrademo</span><br><span class="line">  -t, --toggle          Help message <span class="keyword">for</span> toggle</span><br><span class="line"></span><br><span class="line">Use <span class="string">"cobrademo [command] --help"</span> <span class="keyword">for</span> more information about a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/spf13/pflag" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/spf13/pflag</a></li>
<li><a href="https://github.com/spf13/cobra" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/spf13/cobra</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/10856077.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/sparkdev/p/10856077.html</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>命令行</tag>
        <tag>cobra</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd</title>
    <url>/posts/e27e5d75/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Systemd 是 Linux 系统工具，用来启动<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="external nofollow noopener noreferrer">守护进程</a>，已成为大多数发行版的标准配置。</p><p>本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="external nofollow noopener noreferrer">下一篇</a>介绍如何用于实战。</p><p><img alt="img" data-src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030701.gif"></p><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>历史上，<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="external nofollow noopener noreferrer">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="external nofollow noopener noreferrer"><code>init</code></a>进程。</p><p>下面的命令用来启动服务。</p><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure>
</blockquote><a id="more"></a>





<p>这种方法有两个缺点。</p>
<p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p>
<p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>
<h2 id="Systemd-概述"><a href="#Systemd-概述" class="headerlink" title="Systemd 概述"></a>Systemd 概述</h2><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p>
<p>根据 Linux 惯例，字母<code>d</code>是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p>
<p><img alt="img" data-src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030702.jpg"></p>
<p>（上图为 Systemd 作者 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering" target="_blank" rel="external nofollow noopener noreferrer">Lennart Poettering</a>）</p>
<p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的命令查看 Systemd 的版本。</p>
<p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="external nofollow noopener noreferrer">Unix 哲学</a>。</p>
<p><img alt="img" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/bg2016030703.png"></p>
<p>（上图为 Systemd 架构图）</p>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h3><p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h3><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h3><p><code>localectl</code>命令用于查看本地化设置。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl <span class="built_in">set</span>-keymap en_GB</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h3><p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone America/New_York</span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-time HH:MM:SS</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h3><p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<p>Unit 一共分成12种。</p>
<blockquote>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
</blockquote>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Unit-的状态"><a href="#Unit-的状态" class="headerlink" title="Unit 的状态"></a>Unit 的状态</h3><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示系统状态</span></span><br><span class="line">$ systemctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示单个 Unit 的状态</span></span><br><span class="line">$ systemctl status bluetooth.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示远程主机的某个 Unit 的状态</span></span><br><span class="line">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某个 Unit 是否正在运行</span></span><br><span class="line">$ systemctl is-active application.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 是否处于启动失败状态</span></span><br><span class="line">$ systemctl is-failed application.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 服务是否建立了启动链接</span></span><br><span class="line">$ systemctl is-enabled application.service</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a>Unit 管理</h3><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 立即启动一个服务</span></span><br><span class="line">$ sudo systemctl start apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即停止一个服务</span></span><br><span class="line">$ sudo systemctl stop apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启一个服务</span></span><br><span class="line">$ sudo systemctl restart apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死一个服务的所有子进程</span></span><br><span class="line">$ sudo systemctl <span class="built_in">kill</span> apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载一个服务的配置文件</span></span><br><span class="line">$ sudo systemctl reload apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载所有修改过的配置文件</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 的所有底层参数</span></span><br><span class="line">$ systemctl show httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 的指定属性的值</span></span><br><span class="line">$ systemctl show -p CPUShares httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某个 Unit 的指定属性</span></span><br><span class="line">$ sudo systemctl <span class="built_in">set</span>-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl list-dependencies nginx.service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Unit-的配置文件"><a href="#Unit-的配置文件" class="headerlink" title="Unit 的配置文件"></a>Unit 的配置文件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。</p>
<p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> clamd@scan.service</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ sudo ln -s <span class="string">'/usr/lib/systemd/system/clamd@scan.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/clamd@scan.service'</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">disable</span> clamd@scan.service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p>
<h3 id="配置文件的状态"><a href="#配置文件的状态" class="headerlink" title="配置文件的状态"></a>配置文件的状态</h3><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有配置文件</span></span><br><span class="line">$ systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定类型的配置文件</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个命令会输出一个列表。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl list-unit-files</span><br><span class="line"></span><br><span class="line">UNIT FILE              STATE</span><br><span class="line">chronyd.service        enabled</span><br><span class="line">clamd@.service         static</span><br><span class="line">clamd@scan.service     disabled</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个列表显示每个配置文件的状态，一共有四种。</p>
<blockquote>
<ul>
<li>enabled：已建立启动链接</li>
<li>disabled：没建立启动链接</li>
<li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
</blockquote>
<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status bluetooth.service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h3><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl cat atd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=ATD daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/atd</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Section]</span><br><span class="line">Directive1=value</span><br><span class="line">Directive2=value</span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，键值对的等号两侧不能有空格。</p>
<h3 id="配置文件的区块"><a href="#配置文件的区块" class="headerlink" title="配置文件的区块"></a>配置文件的区块</h3><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Description</code>：简短描述</li>
<li><code>Documentation</code>：文档地址</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li>
<li><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li>
<li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</li>
<li><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
</blockquote>
<p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
</blockquote>
<p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<blockquote>
<ul>
<li><code>Type</code>：定义启动时的进程行为。它有以下几种值。</li>
<li><code>Type=simple</code>：默认值，执行<code>ExecStart</code>指定的命令，启动主进程</li>
<li><code>Type=forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>
<li><code>Type=oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>
<li><code>Type=dbus</code>：当前服务通过D-Bus启动</li>
<li><code>Type=notify</code>：当前服务启动完毕，会通知<code>Systemd</code>，再继续往下执行</li>
<li><code>Type=idle</code>：若有其他任务执行完毕，当前服务才会运行</li>
<li><code>ExecStart</code>：启动当前服务的命令</li>
<li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li>
<li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li>
<li><code>ExecReload</code>：重启当前服务时执行的命令</li>
<li><code>ExecStop</code>：停止当前服务时执行的命令</li>
<li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li>
<li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li>
<li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括<code>always</code>（总是重启）、<code>on-success</code>、<code>on-failure</code>、<code>on-abnormal</code>、<code>on-abort</code>、<code>on-watchdog</code></li>
<li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li>
<li><code>Environment</code>：指定环境变量</li>
</ul>
</blockquote>
<p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></span><br><span class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></span><br><span class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Target 与 传统 RunLevel 的对应关系如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它与<code>init</code>进程的主要差别如下。</p>
<blockquote>
<p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p>
<p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
</blockquote>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<p><code>journalctl</code>功能强大，用法非常多。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"20 min ago"</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h2 id="一、开机启动"><a href="#一、开机启动" class="headerlink" title="一、开机启动"></a>一、开机启动</h2><p>对于那些支持 Systemd 的软件，安装的时候，会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件。</p>
<p>如果你想让该软件开机启动，就执行下面的命令（以<code>httpd.service</code>为例）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的命令相当于在<code>/etc/systemd/system</code>目录添加一个符号链接，指向<code>/usr/lib/systemd/system</code>里面的<code>httpd.service</code>文件。</p>
<p>这是因为开机时，<code>Systemd</code>只执行<code>/etc/systemd/system</code>目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p>
<h2 id="二、启动服务"><a href="#二、启动服务" class="headerlink" title="二、启动服务"></a>二、启动服务</h2><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start httpd</span><br></pre></td></tr></table></figure>
</blockquote>
<p>执行上面的命令以后，有可能启动失败，因此要用<code>systemctl status</code>命令查看一下该服务的状态。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl status httpd</span><br><span class="line"></span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago</span><br><span class="line"> Main PID: 4349 (httpd)</span><br><span class="line">   Status: <span class="string">"Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec"</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─4349 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4350 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4351 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4352 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4353 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─4354 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br><span class="line">12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的输出结果含义如下。</p>
<blockquote>
<ul>
<li><code>Loaded</code>行：配置文件的位置，是否设为开机启动</li>
<li><code>Active</code>行：表示正在运行</li>
<li><code>Main PID</code>行：主进程ID</li>
<li><code>Status</code>行：由应用本身（这里是 httpd ）提供的软件当前状态</li>
<li><code>CGroup</code>块：应用的所有子进程</li>
<li>日志块：应用的日志</li>
</ul>
</blockquote>
<h2 id="三、停止服务"><a href="#三、停止服务" class="headerlink" title="三、停止服务"></a>三、停止服务</h2><p>终止正在运行的服务，需要执行<code>systemctl stop</code>命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop httpd.service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出<code>kill</code>信号。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">kill</span> httpd.service</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此外，重启服务要执行<code>systemctl restart</code>命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、读懂配置文件"><a href="#四、读懂配置文件" class="headerlink" title="四、读懂配置文件"></a>四、读懂配置文件</h2><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p>
<p>前面说过，配置文件主要放在<code>/usr/lib/systemd/system</code>目录，也可能在<code>/etc/systemd/system</code>目录。找到配置文件以后，使用文本编辑器打开即可。</p>
<p><code>systemctl cat</code>命令可以用来查看配置文件，下面以<code>sshd.service</code>文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl cat sshd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenSSH server daemon</span><br><span class="line">Documentation=man:sshd(8) man:sshd_config(5)</span><br><span class="line">After=network.target sshd-keygen.service</span><br><span class="line">Wants=sshd-keygen.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd</span><br><span class="line">ExecStart=/usr/sbin/sshd -D <span class="variable">$OPTIONS</span></span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -HUP <span class="variable">$MAINPID</span></span><br><span class="line">Type=simple</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，配置文件分成几个区块，每个区块包含若干条键值对。</p>
<p>下面依次解释每个区块的内容。</p>
<h2 id="五、-Unit-区块：启动顺序与依赖关系。"><a href="#五、-Unit-区块：启动顺序与依赖关系。" class="headerlink" title="五、 [Unit] 区块：启动顺序与依赖关系。"></a>五、 [Unit] 区块：启动顺序与依赖关系。</h2><p><code>Unit</code>区块的<code>Description</code>字段给出当前服务的简单描述，<code>Documentation</code>字段给出文档位置。</p>
<p>接下来的设置是启动顺序和依赖关系，这个比较重要。</p>
<blockquote>
<p><code>After</code>字段：表示如果<code>network.target</code>或<code>sshd-keygen.service</code>需要启动，那么<code>sshd.service</code>应该在它们之后启动。</p>
</blockquote>
<p>相应地，还有一个<code>Before</code>字段，定义<code>sshd.service</code>应该在哪些服务之前启动。</p>
<p>注意，<code>After</code>和<code>Before</code>字段只涉及启动顺序，不涉及依赖关系。</p>
<p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p>
<p>设置依赖关系，需要使用<code>Wants</code>字段和<code>Requires</code>字段。</p>
<blockquote>
<p><code>Wants</code>字段：表示<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响<code>sshd.service</code>继续执行。</p>
</blockquote>
<p><code>Requires</code>字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么<code>sshd.service</code>也必须退出。</p>
<p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p>
<h2 id="六、-Service-区块：启动行为"><a href="#六、-Service-区块：启动行为" class="headerlink" title="六、[Service] 区块：启动行为"></a>六、[Service] 区块：启动行为</h2><p><code>Service</code>区块定义如何启动当前服务。</p>
<h3 id="6-1-启动命令"><a href="#6-1-启动命令" class="headerlink" title="6.1 启动命令"></a>6.1 启动命令</h3><p>许多软件都有自己的环境参数文件，该文件可以用<code>EnvironmentFile</code>字段读取。</p>
<blockquote>
<p><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。</p>
</blockquote>
<p>上面的例子中，sshd 的环境参数文件是<code>/etc/sysconfig/sshd</code>。</p>
<p>配置文件里面最重要的字段是<code>ExecStart</code>。</p>
<blockquote>
<p><code>ExecStart</code>字段：定义启动进程时执行的命令。</p>
</blockquote>
<p>上面的例子中，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。</p>
<p>与之作用相似的，还有如下这些字段。</p>
<blockquote>
<ul>
<li><code>ExecReload</code>字段：重启服务时执行的命令</li>
<li><code>ExecStop</code>字段：停止服务时执行的命令</li>
<li><code>ExecStartPre</code>字段：启动服务之前执行的命令</li>
<li><code>ExecStartPost</code>字段：启动服务之后执行的命令</li>
<li><code>ExecStopPost</code>字段：停止服务之后执行的命令</li>
</ul>
</blockquote>
<p>请看下面的例子。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/<span class="built_in">echo</span> execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/<span class="built_in">echo</span> execstart2</span><br><span class="line">ExecStartPost=/bin/<span class="built_in">echo</span> post1</span><br><span class="line">ExecStartPost=/bin/<span class="built_in">echo</span> post2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面这个配置文件，第二行<code>ExecStart</code>设为空值，等于取消了第一行的设置，运行结果如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">execstart2</span><br><span class="line">post1</span><br><span class="line">post2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p>
<h3 id="6-2-启动类型"><a href="#6-2-启动类型" class="headerlink" title="6.2 启动类型"></a>6.2 启动类型</h3><p><code>Type</code>字段定义启动类型。它可以设置的值如下。</p>
<blockquote>
<ul>
<li>simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li>
<li>forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li>
<li>oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li>
<li>dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li>
<li>notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li>
<li>idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li>
</ul>
</blockquote>
<p>下面是一个<code>oneshot</code>的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的配置文件，启动类型设为<code>oneshot</code>，就表明这个服务只要运行一次就够了，不需要长期运行。</p>
<p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面配置文件中，<code>RemainAfterExit</code>字段设为<code>yes</code>，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用<code>systemctl stop</code>命令停止服务，<code>ExecStop</code>指定的命令就会执行，从而重新开启触摸板。</p>
<h3 id="6-3-重启行为"><a href="#6-3-重启行为" class="headerlink" title="6.3 重启行为"></a>6.3 重启行为</h3><p><code>Service</code>区块有一些字段，定义了重启行为。</p>
<blockquote>
<p><code>KillMode</code>字段：定义 Systemd 如何停止 sshd 服务。</p>
</blockquote>
<p>上面这个例子中，将<code>KillMode</code>设为<code>process</code>，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p>
<p><code>KillMode</code>字段可以设置的值如下。</p>
<blockquote>
<ul>
<li>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li>
<li>process：只杀主进程</li>
<li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li>
<li>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li>
</ul>
</blockquote>
<p>接下来是<code>Restart</code>字段。</p>
<blockquote>
<p><code>Restart</code>字段：定义了 sshd 退出后，Systemd 的重启方式。</p>
</blockquote>
<p>上面的例子中，<code>Restart</code>设为<code>on-failure</code>，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行<code>systemctl stop</code>命令），它就不会重启。</p>
<p><code>Restart</code>字段可以设置的值如下。</p>
<blockquote>
<ul>
<li>no（默认值）：退出后不会重启</li>
<li>on-success：只有正常退出时（退出状态码为0），才会重启</li>
<li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li>
<li>on-abnormal：只有被信号终止和超时，才会重启</li>
<li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li>
<li>on-watchdog：超时退出，才会重启</li>
<li>always：不管是什么退出原因，总是重启</li>
</ul>
</blockquote>
<p>对于守护进程，推荐设为<code>on-failure</code>。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>。</p>
<p>最后是<code>RestartSec</code>字段。</p>
<blockquote>
<p><code>RestartSec</code>字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。</p>
</blockquote>
<h2 id="七、-Install-区块"><a href="#七、-Install-区块" class="headerlink" title="七、[Install] 区块"></a>七、[Install] 区块</h2><p><code>Install</code>区块，定义如何安装这个配置文件，即怎样做到开机启动。</p>
<blockquote>
<p><code>WantedBy</code>字段：表示该服务所在的 Target。</p>
</blockquote>
<p><code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。</p>
<p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p>
<p>Systemd 有默认的启动 Target。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的结果表示，默认的启动 Target 是<code>multi-user.target</code>。在这个组里的所有服务，都将开机启动。这就是为什么<code>systemctl enable</code>命令能设置开机启动的原因。</p>
<p>使用 Target 的时候，<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 multi-user.target 包含的所有服务</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到另一个 target</span></span><br><span class="line"><span class="comment"># shutdown.target 就是关机状态</span></span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一般来说，常用的 Target 有两个：一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code>。官方文档有一张非常清晰的 <a href="https://www.freedesktop.org/software/systemd/man/bootup.html#System Manager Bootup" target="_blank" rel="external nofollow noopener noreferrer">Target 依赖关系图</a>。</p>
<h2 id="八、Target-的配置文件"><a href="#八、Target-的配置文件" class="headerlink" title="八、Target 的配置文件"></a>八、Target 的配置文件</h2><p>Target 也有自己的配置文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl cat multi-user.target</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，Target 配置文件里面没有启动命令。</p>
<p>上面输出结果中，主要字段含义如下。</p>
<blockquote>
<p><code>Requires</code>字段：要求<code>basic.target</code>一起运行。</p>
<p><code>Conflicts</code>字段：冲突字段。如果<code>rescue.service</code>或<code>rescue.target</code>正在运行，<code>multi-user.target</code>就不能运行，反之亦然。</p>
<p><code>After</code>：表示<code>multi-user.target</code>在<code>basic.target</code> 、 <code>rescue.service</code>、 <code>rescue.target</code>之后启动，如果它们有启动的话。</p>
<p><code>AllowIsolate</code>：允许使用<code>systemctl isolate</code>命令切换到<code>multi-user.target</code>。</p>
</blockquote>
<h2 id="九、修改配置文件后重启"><a href="#九、修改配置文件后重启" class="headerlink" title="九、修改配置文件后重启"></a>九、修改配置文件后重启</h2><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启相关服务</span></span><br><span class="line">$ sudo systemctl restart foobar</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>systemd</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>得意忘形</title>
    <url>/posts/c2f57f16/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Podcast 在我最近的生活中占据了很大的部分，每天走在上下班的路上，带着耳机，听播客中主播与嘉宾的聊天，会觉得是难得自在和舒适的时间。有时候聊到有意思的地方，自己也不禁乐了起来；有时候听到一些新的观点或者事情，自己也好像恍然大悟；或者有时候自己一直以来的感受被主播们说了出来，感同身受豁然开朗。</p>
<p>「得意忘形」是最近听的比较多的一个播客，他的风格偏务虚，更新也并不太频繁，拖更的现象也常有。但是翻看「得意忘形」两年前录的播客，现在听来很多还是觉得会有启发性。毕竟，他关注的是自我与世界这个主题：我到底是一个什么样的人，我作为人整个系统是如何运作的，我与外界是如何产生交互，到底是什么影响了我对这个世界的看法。</p>
<blockquote>
<p>「得意忘形」是一个主张追求个体自由与探寻真理的媒体计划。我们见证了第一次工业革命以来科技对人类社会的极大推动与助益，但也意识到资本主义与市场经济不可避免地催生了消费文化、剥夺了个人价值、并窃取了大众时间。带着对生命的有限性与无目的性的敬畏，我们试图为读者与听众提供更全面的<strong>觉察自我与认知世界</strong>的工具，以不断重建当下的方式穿越时间、抵达生活的本质。</p>
</blockquote>
<p>这里是「朝花夕拾」第二十期，选题来自于最近听「得意忘形」两年前的一期：「快乐」到底是什么东西？选择「得意忘形」作为这期的题目，是因为我非常喜欢得意忘形这个词本来描述的那种 <code>in the zone</code>的状态。这一次，我们再聊聊关于「快乐」的问题。</p>
<blockquote>
<p>嗜酒能啸，善弹琴。当其得意，忽忘形骸。                                —— 《晋书·阮籍传》</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="1500" height="80" src="//music.163.com/outchain/player?type=3&id=904186633&auto=0&height=66"></iframe>

<a id="more"></a>
<h2 id="什么时候会让你开心"><a href="#什么时候会让你开心" class="headerlink" title="什么时候会让你开心"></a>什么时候会让你开心</h2><p>想一想那些让我感觉到开心的时刻</p>
<ul>
<li>在羽毛球场双打时候的那种快节奏的刺激感让我觉得开心，打完球后大汗淋漓的状态</li>
<li>大四时特别喜欢跑步，最开始的时候是比较痛苦的，经过一段时间的适应后，喜欢上了那种<code>Runner&#39;s High</code>的感觉</li>
<li>自己一个人在路上听播客听到好玩的地方的时候</li>
<li>自己做了一道色香味俱全的菜的时候，看着开心，吃着也开心</li>
<li>北京的秋天那种蓝天白云，清风徐来的状态</li>
<li>去云南玩的时候和同伴们插科打诨，完全自由的那种状态</li>
<li>自己实验达到预期的效果的时候</li>
<li>和喜欢的女孩子聊天时候那种自在惬意的感觉</li>
<li>朋友圈收到很多赞的时候</li>
</ul>
<p>总结这些时刻，可以把它大体分为以下几类：</p>
<ul>
<li>运动及其带来的成就</li>
<li>做成一件事情的成就感</li>
<li>人与人之间的交互和融洽感</li>
<li>良好的环境，包括天气、美景等</li>
</ul>
<h2 id="为什么这些会让我感到快乐？多巴胺？"><a href="#为什么这些会让我感到快乐？多巴胺？" class="headerlink" title="为什么这些会让我感到快乐？多巴胺？"></a>为什么这些会让我感到快乐？多巴胺？</h2><p>多巴胺到底是什么？很多媒体把多巴胺描述成人类感到愉悦的来源，是人类通过药物、运动、食物、性或者地位来追求高潮体验的本质。实际上现在的医学研究表明，多巴胺的作用有很多，其中的一个就是并不是给人带来快乐，而是向大脑承诺奖赏、承诺快乐并控制人的行为。这里需要区分的是，你渴望得到某个东西的快乐，和你实际做那个东西的快乐，这两件事情是不一样的。</p>
<p>一个典型的例子，你喜欢跑步。跑步的时候确实会感到开心，可能由于分泌了内啡肽等东西，让人体感觉到舒适。但是跑步让你感到快乐的，可能更多的是来源于，「你觉得你是一个跑步的人」以及随之发朋友圈的行为。当你每次跑完步的时候，你会进一步更新你的认知，觉得自己做了一件有意义的事情，然后会觉得开心。</p>
<p>多巴胺会让人上瘾，你可以因为多巴胺而沉迷于刷手机，也可能因为多巴胺坚持跑步。这是一个固有的生理机制，关键在于你如何利用它。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>快乐</tag>
        <tag>个人管理系统</tag>
        <tag>podcast</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】Scheduling Framework</title>
    <url>/posts/83a17de0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes Scheduling Framework 是在Kubernetes 1.15版本后新出现的一种调度框架。Scheduling Framework 在原有的调度流程中, 定义了丰富扩展点接口，开发者可以通过实现扩展点所定义的接口来实现插件，将插件注册到扩展点。Scheduling Framework 在执行调度流程时，运行到相应的扩展点时，会调用用户注册的插件，影响调度决策的结果。通过这种方式来将用户的调度逻辑集成到 Scheduling Framework 中。</p>
<a id="more"></a>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>随着越来越多的Feature被加入到Kubernetes调度器，整个调度器的代码量越来越大，逻辑越来越复杂，使得对其的维护和调试越来越困难。与此同时，对于那些自己定制调度器的研发人员来说，跟上社区的进展也越来越难。在Kubernetes 1.15版本前的调度器支持了Scheduler Extender的方式来基于HTTP的Webhook来对调度器支持的功能扩展。但是，他们明显存在以下几个问题：</p>
<ul>
<li>调度器功能扩展点的数目有限。Extender只有Filter、Prioritize、Preempt和Bind这几个扩展点，而没有起其他的扩展点，比如不能在运行Predicate函数前调用</li>
<li>每一次调用调度器都需要Marshaling和Unmarshaling JSON数据，相比于直接调用原生函数而言Webhook的HTTP请求方式更慢</li>
<li>难以通知Extender调度器已经放弃调度一个Pod</li>
<li>因为Extender以独立进程形式运行，他们不能使用Scheduler Cache</li>
</ul>
<p>以上的问题影响了Scheduler的性能与扩展新的特性，基于此提出的Framework框架会将现有的功能转换为Plugin的形式，比如Predicate函数和Prioritize函数。这些Plugin将会被编译进调度器的二进制文件中。此外，对于那些自己定制调度器的研发人员可以基于未经修改的调度器代码和自己的插件代码编译自己的调度器。</p>
<p>目标：</p>
<ul>
<li>让调度器更加可扩展</li>
<li>通过移动调度器的代码到Plugin从而让其核心代码更加简单</li>
<li>在Framework中提出扩展点</li>
<li>提出一个机制来接收Plugin的结果，并且根结收到的结果来继续或者终止调度</li>
<li>提出一个机制来处理问题并且和Plugin通信</li>
</ul>
<h2 id="Proposals"><a href="#Proposals" class="headerlink" title="Proposals"></a>Proposals</h2><p>Scheduling Framework定义了新的扩展点和Go API，这种方式称作Plugin。通过配置Scheduler的ComponentConfig可以开启、关闭或者重排序这些插件。such</p>
<h2 id="Scheduling-Cycle-amp-Binding-Cycle"><a href="#Scheduling-Cycle-amp-Binding-Cycle" class="headerlink" title="Scheduling Cycle &amp; Binding Cycle"></a>Scheduling Cycle &amp; Binding Cycle</h2><p>每次尝试调度一个Pod都会经历两个阶段：</p>
<ul>
<li>Scheduling Cycle：为Pod选择一个Node进行调度</li>
<li>Binding Cycle：将Scheduling Cycle阶段的决定应用到集群</li>
</ul>
<p>这两个阶段一起被称作是 <code>Scheduling Context</code>，也就是调度上下文。</p>
<p>不同的Scheduling Cycle间串行运行，同一个时间只有一个 scheduling cycle，是线程安全的。binding cycle 是异步执行的，同一个时间中可能会有多个 binding cycle 在运行，是线程不安全的。</p>
<p>如果一个Pod被认为是Unschedulable，或者是发生了内存错误，那么一个Scheduling Cycle或者Binding Cycle会被终止。然后这个Pod可能被返回到调度队列中。如果一个Binding Cycle终止了，那么会触发 <code>Un-reserve</code>插件。</p>
<h2 id="Extension-points"><a href="#Extension-points" class="headerlink" title="Extension points"></a>Extension points</h2><p>下图定义了Scheduling Framework中暴露的扩展点，其中Filter等同于原来的Predicate，Scoring等同于之前的Prioritize。对于一个插件，它可能在一个或者多个扩展点注册，从而满足业务的不同逻辑。</p>
<p><img alt="Scheduling Framework" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-01-25_scheduling-framework-extensions.png"></p>
<h3 id="Queue-Sort"><a href="#Queue-Sort" class="headerlink" title="Queue Sort"></a>Queue Sort</h3><p>这里的插件用来对调度队列中的Pod排序，同一时间只有一个Queue Sort可以被启用。</p>
<h3 id="Pre-filter"><a href="#Pre-filter" class="headerlink" title="Pre-filter"></a>Pre-filter</h3><p>这里的插件用来预处理Pod信息，或者检查集群或Pod需满足的特定条件。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter用于过滤那些不能运行对应Pod的Node，调度器可能会同时评估这些Node，在一个Scheduling Cycle中Filter插件可能被运行多次。</p>
<h3 id="Pre-Score"><a href="#Pre-Score" class="headerlink" title="Pre-Score"></a>Pre-Score</h3><p>在V1alpha2中，Pre-Score已经可用，之前被称作Post-Filter。</p>
<p>这个插件会接收来自Filter阶段的Node列表，可以用这些数据来更新内部状态或者产生日志或Metrics。</p>
<h3 id="Scoring"><a href="#Scoring" class="headerlink" title="Scoring"></a>Scoring</h3><p>Score插件会有两个阶段：</p>
<ul>
<li>Scoring：为Filter阶段的Node列表中的Node排序，调度器对于每个Node调用每个Score插件中的 <code>Score</code>方法</li>
<li>Normalize Scoring：用于修改各个Score插件的分数，从而计算出最终的Node得分列表</li>
</ul>
<p>Score插件最终输出的数值必须在  <strong>[MinNodeScore, MaxNodeScore]</strong> 区间，如果不是，Scheduling Cycle将会被终止。</p>
<h3 id="Reserve"><a href="#Reserve" class="headerlink" title="Reserve"></a>Reserve</h3><p>Reserve插件是一个信息型的插件。当一个Node上的资源被保留给某个Pod的时候，那些需要维护runtime状态的插件，需要利用Reserve扩展点来接收来自Scheduler的通知。这发生在调度器实际上绑定Pod到Node的时候，用来避免在调度器等待Bind成功时候发生Race Condition。</p>
<p>Reserve是Scheduling Cycle的最后一步，一点Pod进入Reserved状态，它之后要么在调度失败的时候触发Un-reserve插件，要么调度成功的时候触发Post-bind插件。</p>
<blockquote>
<p>Note：这个概念以前叫做 Assume</p>
</blockquote>
<h3 id="Permit"><a href="#Permit" class="headerlink" title="Permit"></a>Permit</h3><p>Permit插件用来阻止或者推迟对一个Pod的绑定，一个Permit可以做下面三件操作</p>
<ul>
<li>Allow；执行approve操作后，一个Pod将被送去Binding</li>
<li>Reject：执行deny操作后，Pod被返回调度队列，同时触发Un-reserve插件</li>
<li>Wait (with a timeout)：执行wait操作后，一个Pod保持在Permit阶段知道一个Plugin对它approve；如果timeout了，wait将会变为den y，之后Pod被返回调度队列，触发Un-reserve插件</li>
</ul>
<h4 id="WaitPod"><a href="#WaitPod" class="headerlink" title="WaitPod"></a>WaitPod</h4><p>在framework interface中定义了Permit阶段中处于等待的WaitingPod。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/interface.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// WaitingPod represents a pod currently waiting in the permit phase.</span></span><br><span class="line"><span class="keyword">type</span> WaitingPod <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GetPod returns a reference to the waiting pod.</span></span><br><span class="line">	GetPod() *v1.Pod</span><br><span class="line">	<span class="comment">// GetPendingPlugins returns a list of pending permit plugin's name.</span></span><br><span class="line">	GetPendingPlugins() []<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Allow declares the waiting pod is allowed to be scheduled by plugin pluginName.</span></span><br><span class="line">	<span class="comment">// If this is the last remaining plugin to allow, then a success signal is delivered</span></span><br><span class="line">	<span class="comment">// to unblock the pod.</span></span><br><span class="line">	Allow(pluginName <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// Reject declares the waiting pod unschedulable.</span></span><br><span class="line">	Reject(msg <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitingPod则是一个具体的pod的等待实例，其内部通过pendingPlugins保存插件定义的timer等待时间，对外通过<code>chan *status</code>来接受当前pod的状态，并通过读写锁来进行串行化。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> waitingPod <span class="keyword">struct</span> &#123;</span><br><span class="line">    pod            *v1.Pod</span><br><span class="line">    pendingPlugins <span class="keyword">map</span>[<span class="keyword">string</span>]*time.Timer</span><br><span class="line">    s              <span class="keyword">chan</span> *Status</span><br><span class="line">    mu             sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitingPodsMap其内部通过pod的uid保存一个map映射，同时通过读写锁来进行数据保护</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> waitingPodsMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    pods <span class="keyword">map</span>[types.UID]WaitingPod</span><br><span class="line">    mu   sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会根据每个plugin的wait等待时间构建N个timer, 如果任一的timer到期，则就拒绝</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWaitingPod</span><span class="params">(pod *v1.Pod, pluginsMaxWaitTime <span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration)</span> *<span class="title">waitingPod</span></span> &#123;</span><br><span class="line">    wp := &amp;waitingPod&#123;</span><br><span class="line">        pod: pod,</span><br><span class="line">        s:   <span class="built_in">make</span>(<span class="keyword">chan</span> *Status, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wp.pendingPlugins = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*time.Timer, <span class="built_in">len</span>(pluginsMaxWaitTime))</span><br><span class="line">    <span class="comment">// The time.AfterFunc calls wp.Reject which iterates through pendingPlugins map. Acquire the</span></span><br><span class="line">    <span class="comment">// lock here so that time.AfterFunc can only execute after newWaitingPod finishes.</span></span><br><span class="line">    wp.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> wp.mu.Unlock()</span><br><span class="line">    <span class="comment">// 根据插件的等待时间来构建timer，如果有任一timer到期，还未曾有任何plugin Allow则会进行Reject</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> pluginsMaxWaitTime &#123;</span><br><span class="line">        plugin, waitTime := k, v</span><br><span class="line">        wp.pendingPlugins[plugin] = time.AfterFunc(waitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            msg := fmt.Sprintf(<span class="string">"rejected due to timeout after waiting %v at plugin %v"</span>,</span><br><span class="line">                waitTime, plugin)</span><br><span class="line">            wp.Reject(msg)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>允许操作必须等待所有的plugin都Allow后，才能发送允许事件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *waitingPod)</span> <span class="title">Allow</span><span class="params">(pluginName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> timer, exist := w.pendingPlugins[pluginName]; exist &#123;</span><br><span class="line">        <span class="comment">// 停止当前plugin的定时器</span></span><br><span class="line">        timer.Stop()</span><br><span class="line">        <span class="built_in">delete</span>(w.pendingPlugins, pluginName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only signal success status after all plugins have allowed</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(w.pendingPlugins) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有当所有的plugin都允许，才会发生成功允许事件</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> w.s &lt;- NewStatus(Success, <span class="string">""</span>): <span class="comment">// 发送事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Reject"><a href="#Reject" class="headerlink" title="Reject"></a>Reject</h4><p>任一一个plugin的定时器到期，或者plugin主动发起reject操作，则都会暂停所有的定时器，并进行消息广播</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *waitingPod)</span> <span class="title">Reject</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    w.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.RUnlock()</span><br><span class="line">    <span class="comment">// 停止所有的timer</span></span><br><span class="line">    <span class="keyword">for</span> _, timer := <span class="keyword">range</span> w.pendingPlugins &#123;</span><br><span class="line">        timer.Stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过管道发送拒绝事件</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> w.s &lt;- NewStatus(Unschedulable, msg):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Premit-阶段-Wait-实现"><a href="#Premit-阶段-Wait-实现" class="headerlink" title="Premit 阶段 Wait 实现"></a>Premit 阶段 Wait 实现</h4><p>首先会遍历所有的插件，然后如果发现状态设置为Wait，则会根据插件的等待时间进行wait操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">RunPermitPlugins</span><span class="params">(ctx context.Context, state *CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(status *Status)</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		metrics.FrameworkExtensionPointDuration.WithLabelValues(permit, status.Code().String()).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line">	pluginsWaitTime := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration)</span><br><span class="line">	statusCode := Success</span><br><span class="line">	<span class="keyword">for</span> _, pl := <span class="keyword">range</span> f.permitPlugins &#123;</span><br><span class="line">		status, timeout := f.runPermitPlugin(ctx, pl, state, pod, nodeName)</span><br><span class="line">		<span class="keyword">if</span> !status.IsSuccess() &#123;</span><br><span class="line">			<span class="keyword">if</span> status.IsUnschedulable() &#123;</span><br><span class="line">				msg := fmt.Sprintf(<span class="string">"rejected pod %q by permit plugin %q: %v"</span>, pod.Name, pl.Name(), status.Message())</span><br><span class="line">				klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line">				<span class="keyword">return</span> NewStatus(status.Code(), msg)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> status.Code() == Wait &#123;</span><br><span class="line">				<span class="comment">// Not allowed to be greater than maxTimeout.</span></span><br><span class="line">				<span class="keyword">if</span> timeout &gt; maxTimeout &#123;</span><br><span class="line">					timeout = maxTimeout</span><br><span class="line">				&#125;</span><br><span class="line">				pluginsWaitTime[pl.Name()] = timeout</span><br><span class="line">				statusCode = Wait</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				msg := fmt.Sprintf(<span class="string">"error while running %q permit plugin for pod %q: %v"</span>, pl.Name(), pod.Name, status.Message())</span><br><span class="line">				klog.Error(msg)</span><br><span class="line">				<span class="keyword">return</span> NewStatus(Error, msg)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> statusCode == Wait &#123;</span><br><span class="line">		waitingPod := newWaitingPod(pod, pluginsWaitTime)</span><br><span class="line">		f.waitingPods.add(waitingPod)</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"one or more plugins asked to wait and no plugin rejected pod %q"</span>, pod.Name)</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line">		<span class="keyword">return</span> NewStatus(Wait, msg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WaitOnPermit will block, if the pod is a waiting pod, until the waiting pod is rejected or allowed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">WaitOnPermit</span><span class="params">(ctx context.Context, pod *v1.Pod)</span> <span class="params">(status *Status)</span></span> &#123;</span><br><span class="line">	waitingPod := f.waitingPods.get(pod.UID)</span><br><span class="line">	<span class="keyword">if</span> waitingPod == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.waitingPods.remove(pod.UID)</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"pod %q waiting on permit"</span>, pod.Name)</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	s := &lt;-waitingPod.s</span><br><span class="line">	metrics.PermitWaitDuration.WithLabelValues(s.Code().String()).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !s.IsSuccess() &#123;</span><br><span class="line">		<span class="keyword">if</span> s.IsUnschedulable() &#123;</span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"pod %q rejected while waiting on permit: %v"</span>, pod.Name, s.Message())</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line">			<span class="keyword">return</span> NewStatus(s.Code(), msg)</span><br><span class="line">		&#125;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"error received while waiting on permit for pod %q: %v"</span>, pod.Name, s.Message())</span><br><span class="line">		klog.Error(msg)</span><br><span class="line">		<span class="keyword">return</span> NewStatus(Error, msg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pre-Bind"><a href="#Pre-Bind" class="headerlink" title="Pre-Bind"></a>Pre-Bind</h3><p>执行Bind前的必要工作，比如在目标Node上设置一个网络磁盘并且mount上去。</p>
<h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><p>当所有的Pre-Bind插件执行完毕后，才会执行Bind插件，每一个Bind插件都按照配置的顺序被调用。一个Bind插件可以选择是否处理对应的Pod，一旦一个Bind插件选择处理Pod，剩余的其他Bind插件都被跳过。</p>
<h3 id="Post-Bind"><a href="#Post-Bind" class="headerlink" title="Post-Bind"></a>Post-Bind</h3><p>这是一个信息型的插件，当Bind成功后，可以用来清理一些关联的资源。</p>
<h3 id="Un-reserve"><a href="#Un-reserve" class="headerlink" title="Un-reserve"></a>Un-reserve</h3><p>这是一个信息型的插件，当一个Pod被reserved了，然后在之后的阶段被reject，就会执行Un-reserve插件，主要用来清理一些reserved Pod的状态。</p>
<h2 id="Plugin-API"><a href="#Plugin-API" class="headerlink" title="Plugin API"></a>Plugin API</h2><p>Plugin首先需要注册和配置，然后使用扩展点的接口，一般形式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueSortPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   Less(*PodInfo, *PodInfo) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PreFilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   PreFilter(CycleState, *v1.Pod) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="CycleState"><a href="#CycleState" class="headerlink" title="CycleState"></a>CycleState</h3><p>很多插件函数会调用一个<code>CycleState</code>参数，它代表了当前的调度上下文，主要是负责调度流程中数据的保存和克隆，其对外暴露了读写锁接口，各扩展点插件可以根据需求独立进行加锁选择。</p>
<blockquote>
<p>The <code>CycleState</code> also provides an API similar to <a href="https://godoc.org/context#WithValue" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithValue</code></a> that can be used to pass data between plugins at different extension points. Multiple plugins can share the state or communicate via this mechanism. The state is preserved only during a single scheduling context. It is worth noting that plugins are assumed to be <strong>trusted</strong>. The scheduler does not prevent one plugin from accessing or modifying another plugin’s state.</p>
<p>* <em>The only exception is for <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#queue-sort" target="_blank" rel="external nofollow noopener noreferrer">queue sort</a> plugins.</em></p>
<p><strong>WARNING</strong>: The data available through a <code>CycleState</code> is not valid after a scheduling context ends, and plugins should not hold references to that data longer than necessary.</p>
</blockquote>
<p>CycleState主要保存StateData数据，只需要实现一个clone接口即可，CycleState里面的数据，可以被当前framework所有的插件进行数据增加和修改，里面会通过读写锁来保证线程安全，但并不会针对插件进行限制，即信任所有插件，可以任意进行增删。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CycleState <span class="keyword">struct</span> &#123;</span><br><span class="line">    mx      sync.RWMutex</span><br><span class="line">    storage <span class="keyword">map</span>[StateKey]StateData</span><br><span class="line">    <span class="comment">// if recordPluginMetrics is true, PluginExecutionDuration will be recorded for this cycle.</span></span><br><span class="line">    recordPluginMetrics <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateData is a generic type for arbitrary data stored in CycleState.</span></span><br><span class="line"><span class="keyword">type</span> StateData <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Clone is an interface to make a copy of StateData. For performance reasons,</span></span><br><span class="line">    <span class="comment">// clone should make shallow copies for members (e.g., slices or maps) that are not</span></span><br><span class="line">    <span class="comment">// impacted by PreFilter's optional AddPod/RemovePod methods.</span></span><br><span class="line">    Clone() StateData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对外接口的实现，需要对应的插件主动选择进行加读锁或者加写锁，然后进行相关数据的读取和修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Read</span><span class="params">(key StateKey)</span> <span class="params">(StateData, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v, ok := c.storage[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(NotFound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write stores the given "val" in CycleState with the given "key".</span></span><br><span class="line"><span class="comment">// This function is not thread safe. In multi-threaded code, lock should be</span></span><br><span class="line"><span class="comment">// acquired first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Write</span><span class="params">(key StateKey, val StateData)</span></span> &#123;</span><br><span class="line">    c.storage[key] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete deletes data with the given key from CycleState.</span></span><br><span class="line"><span class="comment">// This function is not thread safe. In multi-threaded code, lock should be</span></span><br><span class="line"><span class="comment">// acquired first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Delete</span><span class="params">(key StateKey)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(c.storage, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock acquires CycleState lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock releases CycleState lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RLock acquires CycleState read lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.RLock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RUnlock releases CycleState read lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FrameworkHandle"><a href="#FrameworkHandle" class="headerlink" title="FrameworkHandle"></a>FrameworkHandle</h3><p>FrameworkHandle提供了对于ApiServer和SchedulerCache的访问。<code>FrameworkHandle</code>作为一个Interface，具体是通过framework结构体实现的。</p>
<blockquote>
<p>While the <code>CycleState</code> provides APIs relevant to a single scheduling context, the <code>FrameworkHandle</code> provides APIs relevant to the lifetime of a plugin. This is how plugins can get a client (<code>kubernetes.Interface</code>) and <code>SharedInformerFactory</code>, or read data from the scheduler’s cache of cluster state. The handle will also provide APIs to list and approve or reject <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#permit" target="_blank" rel="external nofollow noopener noreferrer">waiting pods</a>.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FrameworkHandle <span class="keyword">interface</span> &#123;</span><br><span class="line">	SnapshotSharedLister() schedulerlisters.SharedLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IterateOverWaitingPods acquires a read lock and iterates over the WaitingPods map.</span></span><br><span class="line">	IterateOverWaitingPods(callback <span class="function"><span class="keyword">func</span><span class="params">(WaitingPod)</span>)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// GetWaitingPod returns a waiting pod given its UID.</span></span><br><span class="line">	GetWaitingPod(uid types.UID) WaitingPod</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RejectWaitingPod rejects a waiting pod given its UID.</span></span><br><span class="line">	RejectWaitingPod(uid types.UID)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ClientSet returns a kubernetes clientSet.</span></span><br><span class="line">	ClientSet() clientset.Interface</span><br><span class="line"></span><br><span class="line">	SharedInformerFactory() informers.SharedInformerFactory</span><br><span class="line"></span><br><span class="line">	<span class="comment">// VolumeBinder returns the volume binder used by scheduler.</span></span><br><span class="line">	VolumeBinder() scheduling.SchedulerVolumeBinder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Plugin-Registration"><a href="#Plugin-Registration" class="headerlink" title="Plugin Registration"></a>Plugin Registration</h3><p>对于每一个插件，都需要定义一个构造函数，并且把它加入到注册工厂中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PluginFactory = <span class="function"><span class="keyword">func</span><span class="params">(runtime.Unknown, FrameworkHandle)</span> <span class="params">(Plugin, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">map</span>[<span class="keyword">string</span>]PluginFactory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span> <span class="title">Registry</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Registry&#123;</span><br><span class="line">      fooplugin.Name: fooplugin.New,</span><br><span class="line">      barplugin.Name: barplugin.New,</span><br><span class="line">      <span class="comment">// New plugins are registered here.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>NodeAffinity</code>为例，在定义了<code>NodeAffinity</code>这个插件结构体后，需要有一个<code>New</code>函数，函数参数同上面的<code>PluginFactory</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeAffinity is a plugin that checks if a pod node selector matches the node label.</span></span><br><span class="line"><span class="keyword">type</span> NodeAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line">	handle framework.FrameworkHandle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New initializes a new plugin and returns it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(_ *runtime.Unknown, h framework.FrameworkHandle)</span> <span class="params">(framework.Plugin, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;NodeAffinity&#123;handle: h&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么是在哪里将这些插件注册到Framework的呢？在 <code>NewFramework</code>函数中对Framework初始化时，会对registry中的每一个插件，如果是配置需要的插件，就调用<code>factory</code>工厂函数，对各个插件初始化构造，并注册到 <code>pluginsMap</code>中。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="code"><pre><span class="line">pluginsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Plugin)</span><br><span class="line"><span class="keyword">for</span> name, factory := <span class="keyword">range</span> r &#123;</span><br><span class="line">	<span class="comment">// initialize only needed plugins.</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := pg[name]; !ok &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p, err := factory(pluginConfig[name], f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error initializing plugin %q: %v"</span>, name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	pluginsMap[name] = p</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>pluginsMap</code>是一个临时的字典，真正注册到framework结构体中，是调用<code>updatePluginList</code>函数利用反射进行注册。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> _, e := <span class="keyword">range</span> f.getExtensionPoints(plugins) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := updatePluginList(e.slicePtr, e.plugins, pluginsMap); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>e</code>是framework的插件扩展点</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">getExtensionPoints</span><span class="params">(plugins *config.Plugins)</span> []<span class="title">extensionPoint</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> []extensionPoint&#123;</span><br><span class="line">		&#123;plugins.PreFilter, &amp;f.preFilterPlugins&#125;,</span><br><span class="line">		&#123;plugins.Filter, &amp;f.filterPlugins&#125;,</span><br><span class="line">		&#123;plugins.Reserve, &amp;f.reservePlugins&#125;,</span><br><span class="line">		&#123;plugins.PreScore, &amp;f.preScorePlugins&#125;,</span><br><span class="line">		&#123;plugins.Score, &amp;f.scorePlugins&#125;,</span><br><span class="line">		&#123;plugins.PreBind, &amp;f.preBindPlugins&#125;,</span><br><span class="line">		&#123;plugins.Bind, &amp;f.bindPlugins&#125;,</span><br><span class="line">		&#123;plugins.PostBind, &amp;f.postBindPlugins&#125;,</span><br><span class="line">		&#123;plugins.Unreserve, &amp;f.unreservePlugins&#125;,</span><br><span class="line">		&#123;plugins.Permit, &amp;f.permitPlugins&#125;,</span><br><span class="line">		&#123;plugins.QueueSort, &amp;f.queueSortPlugins&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，slicePtr指向的是对于framework不同扩展点，存储的不同插件具体实现；而 plugins 这个 PluginSet这个配置，主要配置哪些插件开启，哪些插件关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> extensionPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// the set of plugins to be configured at this extension point.</span></span><br><span class="line">	plugins *config.PluginSet</span><br><span class="line">	<span class="comment">// a pointer to the slice storing plugins implementations that will run at this</span></span><br><span class="line">	<span class="comment">// extension point.</span></span><br><span class="line">	slicePtr <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updatePluginList</code>函数其具体实现如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updatePluginList</span><span class="params">(pluginList <span class="keyword">interface</span>&#123;&#125;, pluginSet *config.PluginSet, pluginsMap <span class="keyword">map</span>[<span class="keyword">string</span>]Plugin)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pluginSet == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先通过Elem获取当前数组的类型</span></span><br><span class="line">    plugins := reflect.ValueOf(pluginList).Elem()</span><br><span class="line">    <span class="comment">// 通过数组类型来获取数组内部元素的类型</span></span><br><span class="line">    pluginType := plugins.Type().Elem()</span><br><span class="line">    set := sets.NewString()</span><br><span class="line">    <span class="keyword">for</span> _, ep := <span class="keyword">range</span> pluginSet.Enabled &#123;</span><br><span class="line">        pg, ok := pluginsMap[ep.Name]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s %q does not exist"</span>, pluginType.Name(), ep.Name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合法性检查：如果发现当前插件未实现当前接口，则报错</span></span><br><span class="line">        <span class="keyword">if</span> !reflect.TypeOf(pg).Implements(pluginType) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"plugin %q does not extend %s plugin"</span>, ep.Name, pluginType.Name())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> set.Has(ep.Name) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"plugin %q already registered as %q"</span>, ep.Name, pluginType.Name())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        set.Insert(ep.Name)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加插件到slice中，并保存指针指向</span></span><br><span class="line">        newPlugins := reflect.Append(plugins, reflect.ValueOf(pg))</span><br><span class="line">        plugins.Set(newPlugins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，<code>Registry</code>中的插件是在哪里注册的呢？在 <code>pkg/scheduler/scheduler.go</code>中</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line"><span class="keyword">if</span> err := registry.Merge(options.frameworkOutOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是在plugin目录下硬编码的，也就是Framework内置的插件。对于自己写的插件，需要通过 <code>frameworkOutOfTreeRegistry</code> 配置。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInTreeRegistry</span><span class="params">()</span> <span class="title">framework</span>.<span class="title">Registry</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> framework.Registry&#123;</span><br><span class="line">		defaultpodtopologyspread.Name:              defaultpodtopologyspread.New,</span><br><span class="line">		imagelocality.Name:                         imagelocality.New,</span><br><span class="line">		tainttoleration.Name:                       tainttoleration.New,</span><br><span class="line">		nodename.Name:                              nodename.New,</span><br><span class="line">		nodeports.Name:                             nodeports.New,</span><br><span class="line">		nodepreferavoidpods.Name:                   nodepreferavoidpods.New,</span><br><span class="line">		nodeaffinity.Name:                          nodeaffinity.New,</span><br><span class="line">		podtopologyspread.Name:                     podtopologyspread.New,</span><br><span class="line">		nodeunschedulable.Name:                     nodeunschedulable.New,</span><br><span class="line">		noderesources.FitName:                      noderesources.NewFit,</span><br><span class="line">		noderesources.BalancedAllocationName:       noderesources.NewBalancedAllocation,</span><br><span class="line">		noderesources.MostAllocatedName:            noderesources.NewMostAllocated,</span><br><span class="line">		noderesources.LeastAllocatedName:           noderesources.NewLeastAllocated,</span><br><span class="line">		noderesources.RequestedToCapacityRatioName: noderesources.NewRequestedToCapacityRatio,</span><br><span class="line">		noderesources.ResourceLimitsName:           noderesources.NewResourceLimits,</span><br><span class="line">		volumebinding.Name:                         volumebinding.New,</span><br><span class="line">		volumerestrictions.Name:                    volumerestrictions.New,</span><br><span class="line">		volumezone.Name:                            volumezone.New,</span><br><span class="line">		nodevolumelimits.CSIName:                   nodevolumelimits.NewCSI,</span><br><span class="line">		nodevolumelimits.EBSName:                   nodevolumelimits.NewEBS,</span><br><span class="line">		nodevolumelimits.GCEPDName:                 nodevolumelimits.NewGCEPD,</span><br><span class="line">		nodevolumelimits.AzureDiskName:             nodevolumelimits.NewAzureDisk,</span><br><span class="line">		nodevolumelimits.CinderName:                nodevolumelimits.NewCinder,</span><br><span class="line">		interpodaffinity.Name:                      interpodaffinity.New,</span><br><span class="line">		nodelabel.Name:                             nodelabel.New,</span><br><span class="line">		serviceaffinity.Name:                       serviceaffinity.New,</span><br><span class="line">		queuesort.Name:                             queuesort.New,</span><br><span class="line">		defaultbinder.Name:                         defaultbinder.New,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个问题，对于Plugins目录下的每个插件，是如何决定自己属于那个扩展点呢？</p>
<h2 id="Plugin-Lifecycle"><a href="#Plugin-Lifecycle" class="headerlink" title="Plugin Lifecycle"></a>Plugin Lifecycle</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><blockquote>
<p>There are two steps to plugin initialization. First, <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#plugin-registration" target="_blank" rel="external nofollow noopener noreferrer">plugins are registered</a>. Second, the scheduler uses its configuration to decide which plugins to instantiate. If a plugin registers for multiple extension points, <em>it is instantiated only once</em>.</p>
<p>When a plugin is instantiated, it is passed <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#optional-args" target="_blank" rel="external nofollow noopener noreferrer">config args</a> and a <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#frameworkhandle" target="_blank" rel="external nofollow noopener noreferrer"><code>FrameworkHandle</code></a>.</p>
</blockquote>
<h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><blockquote>
<p>There are two types of concurrency that plugin writers should consider. A plugin might be invoked several times concurrently when evaluating multiple nodes, and a plugin may be called concurrently from <em>different <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#scheduling-cycle--binding-cycle" target="_blank" rel="external nofollow noopener noreferrer">scheduling contexts</a></em>.</p>
<p><em>Note: Within one scheduling context, each extension point is evaluated serially.</em></p>
<p>In the main thread of the scheduler, only one scheduling cycle is processed at a time. Any extension point up to and including <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#reserve" target="_blank" rel="external nofollow noopener noreferrer">reserve</a> will be finished before the next scheduling cycle begins*. After the reserve phase, the binding cycle is executed asynchronously. This means that a plugin could be called concurrently from two different scheduling contexts, provided that at least one of the calls is to an extension point after reserve. Stateful plugins should take care to handle these situations.</p>
<p>Finally, <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#un-reserve" target="_blank" rel="external nofollow noopener noreferrer">un-reserve</a> plugins may be called from either the Permit thread or the Bind thread, depending on how the pod was rejected.</p>
<p>* <em>The queue sort extension point is a special case. It is not part of a scheduling context and may be called concurrently for many pod pairs.</em></p>
<p><img alt="image" data-src="https://github.com/kubernetes/enhancements/raw/master/keps/sig-scheduling/20180409-scheduling-framework-threads.png"></p>
</blockquote>
<h2 id="Configuring-Plugins"><a href="#Configuring-Plugins" class="headerlink" title="Configuring Plugins"></a>Configuring Plugins</h2><h2 id="Interaction-with-Cluster-Autoscaler"><a href="#Interaction-with-Cluster-Autoscaler" class="headerlink" title="Interaction with Cluster Autoscaler"></a>Interaction with Cluster Autoscaler</h2><h1 id="调度器核心组件流程"><a href="#调度器核心组件流程" class="headerlink" title="调度器核心组件流程"></a>调度器核心组件流程</h1><h2 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h2><h3 id="调度器参数初始化"><a href="#调度器参数初始化" class="headerlink" title="调度器参数初始化"></a>调度器参数初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultSchedulerOptions = schedulerOptions&#123;</span><br><span class="line">	profiles: []schedulerapi.KubeSchedulerProfile&#123;</span><br><span class="line">		<span class="comment">// Profiles' default plugins are set from the algorithm provider.</span></span><br><span class="line">		&#123;SchedulerName: v1.DefaultSchedulerName&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	schedulerAlgorithmSource: schedulerapi.SchedulerAlgorithmSource&#123;</span><br><span class="line">		Provider: defaultAlgorithmSourceProviderName(),</span><br><span class="line">	&#125;,</span><br><span class="line">	disablePreemption:        <span class="literal">false</span>,</span><br><span class="line">	percentageOfNodesToScore: schedulerapi.DefaultPercentageOfNodesToScore,</span><br><span class="line">	bindTimeoutSeconds:       BindTimeoutSeconds,</span><br><span class="line">	podInitialBackoffSeconds: <span class="keyword">int64</span>(internalqueue.DefaultPodInitialBackoffDuration.Seconds()),</span><br><span class="line">	podMaxBackoffSeconds:     <span class="keyword">int64</span>(internalqueue.DefaultPodMaxBackoffDuration.Seconds()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插件工厂注册表的初始化"><a href="#插件工厂注册表的初始化" class="headerlink" title="插件工厂注册表的初始化"></a>插件工厂注册表的初始化</h3><p>插件工厂注册表的初始化分为两个部分in tree和out of tree即当前版本自带的和用户自定义的两部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先进行当前版本的插件注册表的注册</span></span><br><span class="line">registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line"><span class="comment">// 加载用户自定义的插件注册表</span></span><br><span class="line"><span class="keyword">if</span> err := registry.Merge(options.frameworkOutOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件informer回调handler绑定"><a href="#事件informer回调handler绑定" class="headerlink" title="事件informer回调handler绑定"></a>事件informer回调handler绑定</h3><p>绑定事件回调主要是通过AddAllEventHandlers主要是将各种资源数据通过SchedulerCache放入本地缓存中，同时针对未调度的pod(!assignedPod即没有绑定Node的pod)加入到调度队列中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">    schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    informerFactory informers.SharedInformerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<h3 id="触发未调度队列中的pod转移"><a href="#触发未调度队列中的pod转移" class="headerlink" title="触发未调度队列中的pod转移"></a>触发未调度队列中的pod转移</h3><p>当资源发生变化的时候，比如service、volume等就会对unschedulableQ中的之前调度失败的pod进行重试，选择将其转移到activeQ或者backoffQ中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveOrBackoffQueue</span><span class="params">(event <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">    unschedulablePods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>, <span class="built_in">len</span>(p.unschedulableQ.podInfoMap))</span><br><span class="line">    <span class="comment">// 获取所有unschedulable的pod</span></span><br><span class="line">    <span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">        unschedulablePods = <span class="built_in">append</span>(unschedulablePods, pInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将unschedulable的pod转移到backoffQ队列或者activeQ队列中</span></span><br><span class="line">    p.movePodsToActiveOrBackoffQueue(unschedulablePods, event)</span><br><span class="line">    <span class="comment">// 修改迁移调度器请求周期, 在失败的时候会进行比较pod的moveRequestCycle是否&gt;=schedulingCycle</span></span><br><span class="line">    p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">    p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h3><p>最后则会启动调度器，其核心流程是在scheduleOne中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先会进行同步缓存</span></span><br><span class="line">    <span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动调度队列的后台定时任务</span></span><br><span class="line">    sched.SchedulingQueue.Run()</span><br><span class="line">    <span class="comment">// 启动调度流程</span></span><br><span class="line">    wait.UntilWithContext(ctx, sched.scheduleOne, <span class="number">0</span>)</span><br><span class="line">    sched.SchedulingQueue.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构建调度器核心组件基础数据"><a href="#构建调度器核心组件基础数据" class="headerlink" title="构建调度器核心组件基础数据"></a>构建调度器核心组件基础数据</h2><h3 id="获取等待调度的pod"><a href="#获取等待调度的pod" class="headerlink" title="获取等待调度的pod"></a>获取等待调度的pod</h3><p>获取等待调度的pod则直接通过NextPod进行，其实内部就是对 <code>schedulingQueue.pop</code>的封装</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从队列中获取等待调度的pod</span></span><br><span class="line">podInfo := sched.NextPod()</span><br><span class="line"><span class="comment">// pod could be nil when schedulerQueue is closed</span></span><br><span class="line"><span class="keyword">if</span> podInfo == <span class="literal">nil</span> || podInfo.Pod == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>NextPod</code> 方法是在Scheduler初始化时候指定的。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/factory.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">	SchedulerCache:  c.schedulerCache,</span><br><span class="line">	Algorithm:       algo,</span><br><span class="line">	Profiles:        profiles,</span><br><span class="line">	NextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class="line">	Error:           MakeDefaultErrorFunc(c.client, podQueue, c.schedulerCache),</span><br><span class="line">	StopEverything:  c.StopEverything,</span><br><span class="line">	VolumeBinder:    c.volumeBinder,</span><br><span class="line">	SchedulingQueue: podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>具体实现方法如下：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/internal/queue/scheduling_queue.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">PodInfo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">PodInfo</span></span> &#123;</span><br><span class="line">        podInfo, err := queue.Pop()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v/%v"</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class="line">            <span class="keyword">return</span> podInfo</span><br><span class="line">        &#125;</span><br><span class="line">        klog.Errorf(<span class="string">"Error while retrieving next pod from scheduling queue: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取调度器Profile"><a href="#获取调度器Profile" class="headerlink" title="获取调度器Profile"></a>获取调度器Profile</h3><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line">prof, err := sched.profileForPod(pod)</span><br></pre></td></tr></table></figure>
<p>这里的Profile是根据每个Pod制定的Scheduler Name获得对应的调度器Profile</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">profileForPod</span><span class="params">(pod *v1.Pod)</span> <span class="params">(*profile.Profile, error)</span></span> &#123;</span><br><span class="line">	prof, ok := sched.Profiles[pod.Spec.SchedulerName]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"profile not found for scheduler name %q"</span>, pod.Spec.SchedulerName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prof, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>Profiles</code>是一个对于Framework的封装</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/profile/profile.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Profile is a scheduling profile.</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">	framework.Framework</span><br><span class="line">	Recorder events.EventRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProfile builds a Profile for the given configuration.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProfile</span><span class="params">(cfg config.KubeSchedulerProfile, frameworkFact FrameworkFactory, recorderFact RecorderFactory)</span> <span class="params">(*Profile, error)</span></span> &#123;</span><br><span class="line">	f, err := frameworkFact(cfg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	r := recorderFact(cfg.SchedulerName)</span><br><span class="line">	<span class="keyword">return</span> &amp;Profile&#123;</span><br><span class="line">		Framework: f,</span><br><span class="line">		Recorder:  r,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map holds profiles indexed by scheduler name.</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]*Profile</span><br></pre></td></tr></table></figure>
<p>在创建scheduler的时候，建立profiles</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">profiles, err := profile.NewMap(c.profiles, c.buildFramework, c.recorderFactory)</span><br></pre></td></tr></table></figure>
<p>关于Profile，可以参考 <a href="https://github.com/kubernetes/kubernetes/pull/88285" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kubernetes/pull/88285</a></p>
<h3 id="跳过提议Pod重调度"><a href="#跳过提议Pod重调度" class="headerlink" title="跳过提议Pod重调度"></a>跳过提议Pod重调度</h3><p>skipPodSchedule即检查当前 pod是否可以进行跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> sched.skipPodSchedule(pod) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面两种情况下Pod就不需要进行重复的调度</p>
<ul>
<li>pod已经被删除</li>
<li>pod已经被提议调度到某个节点，此时如果只是版本的更新，即除了ResourceVersion、Annotations、NodeName三个字段其余的都未曾变化</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skipPodSchedule returns true if we could skip scheduling the pod for specified cases.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">skipPodSchedule</span><span class="params">(prof *profile.Profile, pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// Case 1: pod is being deleted.</span></span><br><span class="line">	<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		prof.Recorder.Eventf(pod, <span class="literal">nil</span>, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Scheduling"</span>, <span class="string">"skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">		klog.V(<span class="number">3</span>).Infof(<span class="string">"Skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 2: pod has been assumed and pod updates could be skipped.</span></span><br><span class="line">	<span class="comment">// An assumed pod can be added again to the scheduling queue if it got an update event</span></span><br><span class="line">	<span class="comment">// during its previous scheduling cycle but before getting assumed.</span></span><br><span class="line">	<span class="keyword">if</span> sched.skipPodUpdate(pod) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的判断规则是</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/eventhandler.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// skipPodUpdate checks whether the specified pod update should be ignored.</span></span><br><span class="line"><span class="comment">// This function will return true if</span></span><br><span class="line"><span class="comment">//   - The pod has already been assumed, AND</span></span><br><span class="line"><span class="comment">//   - The pod has only its ResourceVersion, Spec.NodeName, Annotations,</span></span><br><span class="line"><span class="comment">//     ManagedFields, Finalizers and/or Conditions updated.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">skipPodUpdate</span><span class="params">(pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// Non-assumed pods should never be skipped.</span></span><br><span class="line">	isAssumed, err := sched.SchedulerCache.IsAssumedPod(pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to check whether pod %s/%s is assumed: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isAssumed &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the assumed pod from the cache.</span></span><br><span class="line">	assumedPod, err := sched.SchedulerCache.GetPod(pod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to get assumed pod %s/%s from cache: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compares the assumed pod in the cache with the pod update. If they are</span></span><br><span class="line">	<span class="comment">// equal (with certain fields excluded), this pod update will be skipped.</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">		p := pod.DeepCopy()</span><br><span class="line">		<span class="comment">// ResourceVersion must be excluded because each object update will</span></span><br><span class="line">		<span class="comment">// have a new resource version.</span></span><br><span class="line">		p.ResourceVersion = <span class="string">""</span></span><br><span class="line">		<span class="comment">// Spec.NodeName must be excluded because the pod assumed in the cache</span></span><br><span class="line">		<span class="comment">// is expected to have a node assigned while the pod update may nor may</span></span><br><span class="line">		<span class="comment">// not have this field set.</span></span><br><span class="line">		p.Spec.NodeName = <span class="string">""</span></span><br><span class="line">		<span class="comment">// Annotations must be excluded for the reasons described in</span></span><br><span class="line">		<span class="comment">// https://github.com/kubernetes/kubernetes/issues/52914.</span></span><br><span class="line">		p.Annotations = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// Same as above, when annotations are modified with ServerSideApply,</span></span><br><span class="line">		<span class="comment">// ManagedFields may also change and must be excluded</span></span><br><span class="line">		p.ManagedFields = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// The following might be changed by external controllers, but they don't</span></span><br><span class="line">		<span class="comment">// affect scheduling decisions.</span></span><br><span class="line">		p.Finalizers = <span class="literal">nil</span></span><br><span class="line">		p.Status.Conditions = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> p</span><br><span class="line">	&#125;</span><br><span class="line">	assumedPodCopy, podCopy := f(assumedPod), f(pod)</span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(assumedPodCopy, podCopy) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">3</span>).Infof(<span class="string">"Skipping pod %s/%s update"</span>, pod.Namespace, pod.Name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建调度上下文"><a href="#构建调度上下文" class="headerlink" title="构建调度上下文"></a>构建调度上下文</h3><p>生成CycleState和context, 其中CycleState用于进行调度器周期上线文数据传递共享，而context则负责统一的退出协调管理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建CycleState和context</span></span><br><span class="line">state := framework.NewCycleState()</span><br><span class="line">state.SetRecordPluginMetrics(rand.Intn(<span class="number">100</span>) &lt; pluginMetricsSamplePercent)</span><br><span class="line">schedulingCycleCtx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br></pre></td></tr></table></figure>
<h2 id="正常调度流程"><a href="#正常调度流程" class="headerlink" title="正常调度流程"></a>正常调度流程</h2><h3 id="调度算法执行"><a href="#调度算法执行" class="headerlink" title="调度算法执行"></a>调度算法执行</h3><p>正常调度只需要调度ScheduleAlgorithm来进行调度，具体实现细节可以看之前的文章</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, state, pod)</span><br></pre></td></tr></table></figure>
<h3 id="Assume-Pod"><a href="#Assume-Pod" class="headerlink" title="Assume Pod"></a>Assume Pod</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br></pre></td></tr></table></figure>
<p>如果一个Pod被提议存储到某个节点，则会先将其加入到SchedulerCache中，同时从SchedulingQueue中移除，避免重复调度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    assumed.Spec.NodeName = host</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到SchedulerCache中这样下个调度周期中，pod会占用对应node的资源</span></span><br><span class="line">    <span class="keyword">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"scheduler cache AssumePod failed: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if "assumed" is a nominated pod, we should remove it from internal cache</span></span><br><span class="line">    <span class="comment">// 从调度队列中移除pod</span></span><br><span class="line">    <span class="keyword">if</span> sched.SchedulingQueue != <span class="literal">nil</span> &#123;</span><br><span class="line">        sched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定调度流程"><a href="#绑定调度流程" class="headerlink" title="绑定调度流程"></a>绑定调度流程</h2><p>首先会遍历所有的插件，然后如果发现状态设置为Wait，则会根据插件的等待时间进行wait操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run "permit" plugins.</span></span><br><span class="line">runPermitStatus := prof.RunPermitPlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br></pre></td></tr></table></figure>
<p>运行Permit插件之后，Bind阶段可以异步运行，依次绑定Volumes，运行Prebind插件，执行bind操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bindingCycleCtx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	waitOnPermitStatus := prof.WaitOnPermit(bindingCycleCtx, assumedPod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bind volumes first before Pod</span></span><br><span class="line">	<span class="keyword">if</span> !allBound &#123;</span><br><span class="line">		err := sched.bindVolumes(assumedPod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run "prebind" plugins.</span></span><br><span class="line">	preBindStatus := prof.RunPreBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line"></span><br><span class="line">	err := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Run "postbind" plugins.</span></span><br><span class="line">		prof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>如果是预选失败的，并且当前调度器允许抢占功能，则会进行抢占调度处理即sched.preempt</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> fitError, ok := err.(*core.FitError); ok &#123;</span><br><span class="line">    <span class="comment">// 如果是预选失败则进行</span></span><br><span class="line">    <span class="keyword">if</span> sched.DisablePreemption &#123;</span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">"Pod priority feature is not enabled or preemption is disabled by scheduler configuration."</span> +</span><br><span class="line">            <span class="string">" No preemption is performed."</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preemptionStartTime := time.Now()</span><br><span class="line">        <span class="comment">// 抢占调度</span></span><br><span class="line">        sched.preempt(schedulingCycleCtx, state, fwk, pod, fitError)</span><br><span class="line">        metrics.PreemptionAttempts.Inc()</span><br><span class="line">        metrics.SchedulingAlgorithmPreemptionEvaluationDuration.Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">        metrics.DeprecatedSchedulingDuration.WithLabelValues(metrics.PreemptionEvaluation).Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取抢占者"><a href="#获取抢占者" class="headerlink" title="获取抢占者"></a>获取抢占者</h3><p>首先通过apiserver获取当前需要执行抢占的pod的最新Pod信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">preemptor, err := sched.podPreemptor.getUpdatedPod(preemptor)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">"Error getting the updated preemptor pod object: %v"</span>, err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过抢占算法筛选"><a href="#通过抢占算法筛选" class="headerlink" title="通过抢占算法筛选"></a>通过抢占算法筛选</h3><p>通过Preempt筛选要进行抢占操作的node节点、待驱逐的pod、待驱逐的提议的pod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">node, victims, nominatedPodsToClear, err := sched.Algorithm.Preempt(ctx, state, preemptor, scheduleErr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">"Error preempting victims to make room for %v/%v: %v"</span>, preemptor.Namespace, preemptor.Name, err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新调度队列中的Pod信息"><a href="#更新调度队列中的Pod信息" class="headerlink" title="更新调度队列中的Pod信息"></a>更新调度队列中的Pod信息</h3><p>如果节点抢占一个pod成功，则会更新队列中的抢占节点的提议节点信息，这样在下个调度周期中，就可以使用该信息</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sched.SchedulingQueue.<span class="constructor">UpdateNominatedPodForNode(<span class="params">preemptor</span>, <span class="params">nodeName</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="更新Pod的提议节点信息"><a href="#更新Pod的提议节点信息" class="headerlink" title="更新Pod的提议节点信息"></a>更新Pod的提议节点信息</h3><p>这里会直接调用apiserver中节点的提议节点信息，为什么要这样做呢？因为当前pod已经抢占了node上部分的节点信息，但是在被抢占的pod完全从节点上删除之前的这段时间，该pod调度依然会失败，但是此时不能继续调用抢占流程了，因为你已经执行了抢占，此时只需要等待对应节点上的node都删除，则再次继续尝试调度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = sched.podPreemptor.setNominatedNodeName(preemptor, nodeName)</span><br></pre></td></tr></table></figure>
<h3 id="删除被驱逐节点"><a href="#删除被驱逐节点" class="headerlink" title="删除被驱逐节点"></a>删除被驱逐节点</h3><p>删除被驱逐节点直接调用apiserver进行操作，如果此时发现当前pod还在等待插件的Allow操作，则直接进行Reject</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">        <span class="comment">// 调用apiserver进行删除pod</span></span><br><span class="line">        <span class="keyword">if</span> err := sched.podPreemptor.deletePod(victim); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(<span class="string">"Error preempting pod %v/%v: %v"</span>, victim.Namespace, victim.Name, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the victim is a WaitingPod, send a reject message to the PermitPlugin</span></span><br><span class="line">        <span class="keyword">if</span> waitingPod := fwk.GetWaitingPod(victim.UID); waitingPod != <span class="literal">nil</span> &#123;</span><br><span class="line">            waitingPod.Reject(<span class="string">"preempted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sched.Recorder.Eventf(victim, preemptor, v1.EventTypeNormal, <span class="string">"Preempted"</span>, <span class="string">"Preempting"</span>, <span class="string">"Preempted by %v/%v on node %v"</span>, preemptor.Namespace, preemptor.Name, nodeName)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新被抢占的提议节点"><a href="#更新被抢占的提议节点" class="headerlink" title="更新被抢占的提议节点"></a>更新被抢占的提议节点</h3><p>针对那些已经被提议调度到当前node的pod，会将其node设置为空，重新进行调度选择</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> nominatedPodsToClear &#123;</span><br><span class="line">    <span class="comment">// 清理这些提议的pod</span></span><br><span class="line">    rErr := sched.podPreemptor.removeNominatedNodeName(p)</span><br><span class="line">    <span class="keyword">if</span> rErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Cannot remove 'NominatedPod' field of pod: %v"</span>, rErr)</span><br><span class="line">        <span class="comment">// We do not return as this error is not critical.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Algorithm-Source"><a href="#Algorithm-Source" class="headerlink" title="Algorithm Source"></a>Algorithm Source</h2><h3 id="Algorithm-Provider"><a href="#Algorithm-Provider" class="headerlink" title="Algorithm Provider"></a>Algorithm Provider</h3><h3 id="Algorithm-Policy"><a href="#Algorithm-Policy" class="headerlink" title="Algorithm Policy"></a>Algorithm Policy</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md" target="_blank" rel="external nofollow noopener noreferrer">KEP for scheduling framework</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>k8s</tag>
        <tag>scheduler</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Array</title>
    <url>/posts/b9b1d0f7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在计算机科学中，数组是一种最早期和最重要的数据结构，是由相同类型的元素（Element）的集合所组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用元素的索引（Index）计算出该元素对应的存储地址，从而快速的访问该元素。最简单的数据结构类型是一维数组，多维数组对应于数学中的矩阵概念，在数值计算和图形学等领域应用比较常见。</p>
<p>在Go语言中内置了数组这种内置数据结构，本文将首先介绍数组的一般用法，然后深入到运行时来介绍数组的底层实现原理，包括数组的初始化、访问和赋值等操作。</p>
<a id="more"></a>
<h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><p>数组作为一种基本的数据类型，需要从两个维度来描述它：</p>
<ul>
<li>数组中存储的元素类型</li>
<li>数组最大能够存储的元素个数</li>
</ul>
<p>在 Go 语言中我们可以通过以下方式来表示数组类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">[<span class="number">200</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。在Go语言编译器中，数组的实现表示为：</p>
<figure class="highlight go"><figcaption><span>cmd/compile/internal/types.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array contains Type fields specific to array types.</span></span><br><span class="line"><span class="keyword">type</span> Array <span class="keyword">struct</span> &#123;</span><br><span class="line">	Elem  *Type <span class="comment">// element type</span></span><br><span class="line">	Bound <span class="keyword">int64</span> <span class="comment">// number of elements; &lt;0 if unknown yet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Go 语言中使用数组的简单示例，其中数组的默认值都是0，我们可以通过索引来访问和修改数组中的值，利用内置的 <code>len</code> 方法可以获取数组的长度。另外，我们可以展示了使用多维数组的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Println(<span class="string">"emp:"</span>, a)</span><br><span class="line"></span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">"set:"</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">"get:"</span>, a[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line">    b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"dcl:"</span>, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            twoD[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run arrays.go</span><br><span class="line">emp: [0 0 0 0 0]</span><br><span class="line"><span class="built_in">set</span>: [0 0 0 0 100]</span><br><span class="line">get: 100</span><br><span class="line">len: 5</span><br><span class="line">dcl: [1 2 3 4 5]</span><br><span class="line">2d:  [[0 1 2] [1 2 3]]</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Go 语言中的数组有两种不同的创建方式，一种是显式的指定数组的大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码对数组的大小进行推断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被『转换』成为前一种，这也就是编译器对数组大小的推导，下面将介绍编译器的推导过程。在编译期间，通过 <code>NewArray</code> 函数生成 Array 数据结构类型。如上所说，类型 <code>Array</code> 包含两个字段，一个是元素类型 <code>Elem</code>，另一个是数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型。而当前数组是否应该在堆栈中初始化也在编译期就确定了：对于Array，设定了其不在Heap中。</p>
<figure class="highlight go"><figcaption><span>cmd/compile/internal/types.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewArray returns a new fixed-length array Type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">(elem *Type, bound <span class="keyword">int64</span>)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">		Fatalf(<span class="string">"NewArray: invalid bound %v"</span>, bound)</span><br><span class="line">	&#125;</span><br><span class="line">	t := New(TARRAY)</span><br><span class="line">	t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;</span><br><span class="line">	t.SetNotInHeap(elem.NotInHeap())</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>Type</code> 是Go语言中通用的类型定义，其中的Extra字段包含了对于特定类型相关的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Type represents a Go type.</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Extra contains extra etype-specific fields.</span></span><br><span class="line">	<span class="comment">// As an optimization, those etype-specific structs which contain exactly</span></span><br><span class="line">	<span class="comment">// one pointer-shaped field are stored as values rather than pointers when possible.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// TMAP: *Map</span></span><br><span class="line">	<span class="comment">// TFORW: *Forward</span></span><br><span class="line">	<span class="comment">// TFUNC: *Func</span></span><br><span class="line">	<span class="comment">// TSTRUCT: *Struct</span></span><br><span class="line">	<span class="comment">// TINTER: *Interface</span></span><br><span class="line">	<span class="comment">// TFUNCARGS: FuncArgs</span></span><br><span class="line">	<span class="comment">// TCHANARGS: ChanArgs</span></span><br><span class="line">	<span class="comment">// TCHAN: *Chan</span></span><br><span class="line">	<span class="comment">// TPTR: Ptr</span></span><br><span class="line">	<span class="comment">// TARRAY: *Array</span></span><br><span class="line">	<span class="comment">// TSLICE: Slice</span></span><br><span class="line">	Extra <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Width is the width of this Type in bytes.</span></span><br><span class="line">	Width <span class="keyword">int64</span> <span class="comment">// valid if Align &gt; 0</span></span><br><span class="line"></span><br><span class="line">	methods    Fields</span><br><span class="line">	allMethods Fields</span><br><span class="line"></span><br><span class="line">	Nod  *Node <span class="comment">// canonical OTYPE node</span></span><br><span class="line">	Orig *Type <span class="comment">// original type (type literal or predefined type)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache of composite types, with this type being the element type.</span></span><br><span class="line">	Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">		ptr   *Type <span class="comment">// *T, or nil</span></span><br><span class="line">		slice *Type <span class="comment">// []T, or nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Sym    *Sym  <span class="comment">// symbol containing name, for named types</span></span><br><span class="line">	Vargen <span class="keyword">int32</span> <span class="comment">// unique name for OTYPE/ONAME</span></span><br><span class="line"></span><br><span class="line">	Etype EType <span class="comment">// kind of type</span></span><br><span class="line">	Align <span class="keyword">uint8</span> <span class="comment">// the required alignment of this type, in bytes (0 means Width and Align have not yet been computed)</span></span><br><span class="line"></span><br><span class="line">	flags bitset8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上限推导"><a href="#上限推导" class="headerlink" title="上限推导"></a>上限推导</h3><p>两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 <code>[10]T</code>，那么变量的类型在编译进行到 <strong>类型检查</strong> 阶段就会被提取出来，随后会使用 <a href="https://github.com/golang/go/blob/616c39f6a636166447bdaac4f0871a5ca52bae8c/src/cmd/compile/internal/types/type.go#L473-L481" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/types.NewArray</code></a> 函数创建包含数组大小的 <code>Array</code> 类型。</p>
<p>当我们使用 <code>[...]T</code> 的方式声明数组时，虽然在这一步也会创建一个 <code>Array</code> 类型 <code>Array{Elem: elem, Bound: -1}</code>，但是其中的数组大小上限会是 <code>-1</code>，这里的 <code>-1</code> 只是一个占位符，编译器会在后面的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L2755-L2961" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中对该数组的大小进行推导：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckcomplit</span><span class="params">(n *Node)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">	<span class="keyword">case</span> TARRAY, TSLICE:</span><br><span class="line">		<span class="keyword">var</span> length, i <span class="keyword">int64</span></span><br><span class="line">		nl := n.List.Slice()</span><br><span class="line">		<span class="keyword">for</span> i2, l := <span class="keyword">range</span> nl &#123;</span><br><span class="line">			i++</span><br><span class="line">			<span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">				length = i</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> t.IsDDDArray() &#123;</span><br><span class="line">			t.SetNumElem(length)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个删减后的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L2755-L2961" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数通过遍历元素的方式来计算数组中元素的数量。上述代码中的 <code>DDDArray</code> 指的就是使用 <code>[...]T</code> 声明的数组，因为声明这种数组时需要使用三个点（Dot），所以在编译器中就被称作 <code>DDDArray</code>。</p>
<p>所以我们可以看出 <code>[...]T{1, 2, 3}</code> 和 <code>[3]T{1, 2, 3}</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时就可以通过这种方法较少一些工作。</p>
<h3 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L875-L967" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p>
<ol>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	t := n.Type</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line">		<span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">      <span class="comment">// lay out static data</span></span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fixedlit(inInitFunction, initKindLocalCode, n, var_, init)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数组的元素<strong>小于或者等于四个</strong>时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.fixedlit</code></a> 会负责在函数编译之前将 <code>[3]{1, 2, 3}</code> 转换成更加原始的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedlit</span><span class="params">(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> splitnode <span class="function"><span class="keyword">func</span><span class="params">(*Node)</span> <span class="params">(a *Node, value *Node)</span></span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		a, value := splitnode(r)</span><br><span class="line">		a = nod(OAS, a, value)</span><br><span class="line">		a = typecheck(a, ctxStmt)</span><br><span class="line">		<span class="keyword">switch</span> kind &#123;</span><br><span class="line">		<span class="keyword">case</span> initKindStatic:</span><br><span class="line">			genAsStatic(a)</span><br><span class="line">		<span class="keyword">case</span> initKindLocalCode:</span><br><span class="line">			a = orderStmtInPlace(a, <span class="keyword">map</span>[<span class="keyword">string</span>][]*Node&#123;&#125;)</span><br><span class="line">			a = walkstmt(a)</span><br><span class="line">			init.Append(a)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数组中元素的个数小于四个时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数接受的 <code>kind</code> 是 <code>initKindLocalCode</code>，上述代码会将原有的初始化语句 <code>[3]int{1, 2, 3}</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>但是如果当前数组的元素大于 4 个，<code>anylit</code> 方法会先获取一个唯一的 <code>staticname</code>，然后调用 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数在静态存储区初始化数组中的元素并将临时变量赋值给当前的数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	t := n.Type</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line">		<span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">			vstat := staticname(t)</span><br><span class="line">			vstat.Name.SetReadonly(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">			fixedlit(inNonInitFunction, initKindStatic, n, vstat, init)</span><br><span class="line"></span><br><span class="line">			a := nod(OAS, var_, vstat)</span><br><span class="line">			a = typecheck(a, ctxStmt)</span><br><span class="line">			a = walkexpr(a, init)</span><br><span class="line">			init.Append(a)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们在代码中初始化 <code>[5]int{1, 2, 3, 4, 5}</code> 数组，那么我们可以将上述过程理解成以下的伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">statictmp_0[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">statictmp_0[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">statictmp_0[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">statictmp_0[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">statictmp_0[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">arr = statictmp_0</span><br></pre></td></tr></table></figure>
<p>总结起来，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>和<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/" target="_blank" rel="external nofollow noopener noreferrer">机器码生成</a>两个阶段，最后生成可以执行的二进制文件。</p>
<h2 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h2><p>无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小，如果我们不知道数组中元素的数量，访问时就可能发生越界，而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，如果没有这些信息，我们就无法知道这片连续的内存空间到底存储了什么数据：</p>
<p><img alt="golang-array-memory" data-src="https://img.draveness.me/2019-12-27-15773821941323-golang-array-memory.png"></p>
<p>数组访问越界是非常严重的错误，Go 语言中对越界的判断是可以在编译期间由静态类型检查完成的，<a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2081" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheck1</code></a> 函数会对访问数组的索引进行验证：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OINDEX:</span><br><span class="line">		ok |= ctxExpr</span><br><span class="line">		l := n.Left  <span class="comment">// array</span></span><br><span class="line">		r := n.Right <span class="comment">// index</span></span><br><span class="line">		<span class="keyword">switch</span> n.Left.Type.Etype &#123;</span><br><span class="line">		<span class="keyword">case</span> TSTRING, TARRAY, TSLICE:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> n.Right.Type != <span class="literal">nil</span> &amp;&amp; !n.Right.Type.IsInteger() &#123;</span><br><span class="line">				yyerror(<span class="string">"non-integer array index %v"</span>, n.Right)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">				x := n.Right.Int64()</span><br><span class="line">				<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid array index %v (index must be non-negative)"</span>, n.Right)</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid array index %v (out of bounds for %d-element array)"</span>, n.Right, n.Left.Type.NumElem())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>访问数组的索引是非整数时会直接报错 —— <code>non-integer array index %v</code>；</li>
<li>访问数组的索引是负数时会直接报错 —— <code>&quot;invalid array index %v (index must be non-negative)&quot;</code>；</li>
<li>访问数组的索引越界时会直接报错 —— <code>&quot;invalid array index %v (out of bounds for %d-element array)&quot;</code>；</li>
</ol>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，比如我们直接使用整数或者常量访问数组，但是如果使用变量去访问数组或者字符串时，编译器就无法发现对应的错误了，这时就需要 Go 语言运行时发挥作用了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">4</span>]: invalid array index <span class="number">4</span> (out of bounds <span class="keyword">for</span> <span class="number">3</span>-element array)</span><br><span class="line">arr[i]: <span class="built_in">panic</span>: runtime error: index out of <span class="keyword">range</span> [<span class="number">4</span>] with length <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <code>panicIndex</code> 和 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L86-L89" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goPanicIndex</code></a> 函数触发程序的运行时错误并导致崩溃退出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·panicIndex(SB),NOSPLIT,$<span class="number">0</span><span class="number">-8</span></span><br><span class="line">	MOVL	AX, x+<span class="number">0</span>(FP)</span><br><span class="line">	MOVL	CX, y+<span class="number">4</span>(FP)</span><br><span class="line">	JMP	runtime·goPanicIndex(SB)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goPanicIndex</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	panicCheck1(getcallerpc(), <span class="string">"index out of range"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(boundsError&#123;x: <span class="keyword">int64</span>(x), signed: <span class="literal">true</span>, y: y, code: boundsIndex&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数组的访问操作 <code>OINDEX</code> 成功通过编译器的检查之后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 <code>ssa.html</code> 文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> check</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outOfRange</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	i := <span class="number">4</span></span><br><span class="line">	elem := arr[i]</span><br><span class="line">	<span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOSSAFUNC=outOfRange <span class="keyword">go</span> build array.<span class="keyword">go</span></span><br><span class="line">dumped SSA to ./ssa.html</span><br></pre></td></tr></table></figure>
<p><code>start</code> 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分就是 <code>elem := arr[i]</code> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 <code>IsInBounds</code> 以及当条件不满足时触发程序崩溃的 <code>PanicBounds</code> 指令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v22 (<span class="number">6</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v20</span><br><span class="line">    v23 (<span class="number">6</span>) = IsInBounds &lt;<span class="keyword">bool</span>&gt; v21 v11</span><br><span class="line">If v23 → b2 b3 (likely) (<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">b2: ← b1-</span><br><span class="line">    v26 (<span class="number">6</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v22 v21</span><br><span class="line">    v27 (<span class="number">6</span>) = Copy &lt;mem&gt; v20</span><br><span class="line">    v28 (<span class="number">6</span>) = Load &lt;<span class="keyword">int</span>&gt; v26 v27 (elem[<span class="keyword">int</span>])</span><br><span class="line">    ...</span><br><span class="line">Ret v30 (+<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">b3: ← b1-</span><br><span class="line">    v24 (<span class="number">6</span>) = Copy &lt;mem&gt; v20</span><br><span class="line">    v25 (<span class="number">6</span>) = PanicBounds &lt;mem&gt; [<span class="number">0</span>] v21 v11 v24</span><br><span class="line">Exit v25 (<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><code>PanicBounds</code> 指令最终会被转换成上面提到的 <code>panicIndex</code> 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标，然后利用 <code>PtrIndex</code> 计算出目标元素的地址，再使用 <code>Load</code> 操作将指针中的元素加载到内存中。</p>
<p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 <code>PanicBounds</code> 指令交给运行时进行判断，在使用字面量整数访问数组下标时就会生成非常简单的中间代码，当我们将上述代码中的 <code>arr[i]</code> 改成 <code>arr[2]</code> 时，就会得到如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v21 (<span class="number">5</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v20</span><br><span class="line">    v22 (<span class="number">5</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v21 v14</span><br><span class="line">    v23 (<span class="number">5</span>) = Load &lt;<span class="keyword">int</span>&gt; v22 v20 (elem[<span class="keyword">int</span>])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，而在运行期间这些插入的函数会负责保证不会发生越界错误。</p>
<p>数组的赋值和更新操作 <code>a[i] = 2</code> 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v21 (<span class="number">5</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v19</span><br><span class="line">    v22 (<span class="number">5</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v21 v13</span><br><span class="line">    v23 (<span class="number">5</span>) = Store &lt;mem&gt; &#123;<span class="keyword">int</span>&#125; v22 v20 v19</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="external nofollow noopener noreferrer">编译期间</a>都会转换成对内存的直接读写，在中间代码生成期间，编译器还会插入运行时方法 <code>panicIndex</code> 调用防止发生越界错误。</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>Array</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【备忘录】Linux常见监控指标</title>
    <url>/posts/7f85cd98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。</p>
<a id="more"></a>
<h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><p>CPU使用率衡量的是<strong>程序运行占用的CPU百分比</strong>。Linux的CPU使用率信息可以通过/proc/stat文件计算得到。<code>/proc/stat</code>包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计的，单位为jiffies。如下图所示，cpu一行指的是总的CPU信息，cpu0、cpu1、cpu2、cpu3几行指的是CPU各个核的CPU信息。从这里也可以看出这台服务器共有4个核。每列从左到右的<a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external nofollow noopener noreferrer">意思</a>为</p>
<ul>
<li><strong>user：</strong>从系统启动开始累计到当前时刻，用户态的CPU时间 ，不包含nice值为负进程所占用的时间</li>
<li><strong>nice：</strong>从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间</li>
<li><strong>system：</strong>从系统启动开始累计到当前时刻，内核态时间</li>
<li><strong>idle：</strong>从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间</li>
<li><strong>iowait：</strong>从系统启动开始累计到当前时刻，硬盘IO等待时间</li>
<li><strong>irq：</strong>从系统启动开始累计到当前时刻，硬中断时间</li>
<li><strong>softirq：</strong>从系统启动开始累计到当前时刻，软中断时间</li>
<li><strong>steal：</strong>在虚拟环境下 CPU 花在处理其他操作系统的时间，Linux 2.6.11 开始才开始支持。</li>
<li><strong>guest：</strong>在 Linux 内核控制下 CPU 为 guest 操作系统运行虚拟 CPU 的时间，Linux 2.6.24 开始才开始支持。</li>
<li><strong>guest_nice:</strong> 在 Linux 内核控制下 CPU 为 guest 操作系统在虚拟 CPU 中运行nice进程的时间，Linux 2.6.33 开始才开始支持。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /proc/<span class="built_in">stat</span> | grep cpu</span><br><span class="line">cpu  180296 204 123070 30283108 13956 0 2046 0 0 0</span><br><span class="line">cpu0 45360 53 30785 7560073 10631 0 771 0 0 0</span><br><span class="line">cpu1 45266 47 30779 7573915 1373 0 508 0 0 0</span><br><span class="line">cpu2 44442 54 30724 7574282 1257 0 405 0 0 0</span><br><span class="line">cpu3 45228 48 30781 7574835 693 0 360 0 0 0</span><br></pre></td></tr></table></figure>
<p>根据这些信息，就可以计算出CPU使用率。网管Agent的CPU使用率采集算法如下（以CPU0为例）：</p>
<ul>
<li>cat /proc/stat | grep ‘cpu0’得到cpu0的信息</li>
<li>cpu_total1=user+nice+system+idle+iowait+irq+softirq</li>
<li>cpu_used1=user+nice+system+irq+softirq</li>
<li>sleep 15秒</li>
<li>再次cat /proc/stat | grep ‘cpu0’得到cpu的信息</li>
<li>cpu_total2=user+nice+system+idle+iowait+irq+softirq</li>
<li>cpu_used2=user+nice+system+irq+softirq</li>
<li>得到cpu0在15秒内的平均使用率：(cpu_used2 - cpu_used1) / (cpu_total2 - cpu_total1) * 100%</li>
</ul>
<p>每分钟会采集4次15秒内的CPU平均使用率。为了避免漏采集CPU峰值，可以取这一分钟内四次采集的最大值上报。</p>
<h2 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h2><p>系统负载指的是计算机系统执行计算工作的表现，CPU负载指的是在一段时间内计算机的系统负载，一般用1分钟内、5分钟内、15分钟内这三个数字衡量。通过<code>uptime</code>命令可以显示CPU负载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 14:34:03 up 10:43,  4 users,  load average: 0.06, 0.11, 0.09</span><br></pre></td></tr></table></figure>
<ul>
<li>对于单核单CPU，CPU负载为0表示CPU完全空闲，CPU负载为1.00表示CPU恰好发挥其最大能力，CPU负载大于1表示系统过载，有进程正在等待调度</li>
<li>对于多核或者多CPU系统，CPU负载为每个核的CPU负载总和</li>
</ul>
<p>关于CPU负载的计算机制，可以参考我的另一篇<a href="../">博客</a>。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p> <code>free</code>命令通过读取 <code>/proc/meminfo</code>，可以显示系统中的使用的和空闲的物理内存、Swap内存，同时也可以显示内核使用的buffer和cache，如下图所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -w</span><br><span class="line">              total        used        free      shared     buffers       cache   available</span><br><span class="line">Mem:        7773244      311800     2456280         872      233560     4771604     7169352</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
<p>其中各个字段意义为：</p>
<ul>
<li>total：所有可以使用的内存（包括/proc/meminfo中的MemTotal和SwapTotal）</li>
<li>used：使用的内存，通过 <code>total - free - buffers - cache</code> 计算得到</li>
<li>free：没有使用的内存（包括/proc/meminfo中的MemFree和SwapFree）</li>
<li>shared：主要是指tmpfs使用的内存，现在已经废弃不用，总是为0</li>
<li>buffers：被内核Buffers使用的内存</li>
<li>cache：被内核的Page Cache和Slab使用的内存</li>
<li>buff/cache：buffers和cache的总和</li>
<li>available：对于开启一个新的应用还能使用多少内存的估计，不同于cache和free内存外，还考虑了page cache和可再回收的slab内存</li>
</ul>
<h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p>可以通过 <code>iostat</code>命令来监测磁盘的IO活动，它通过读取 <code>/proc/diskstats</code>文件来获取相关信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/diskstats</span></span><br><span class="line">3    0   hda 446216 784926 9550688 4382310 424847 312726 5922052 19310380 0 3376340 23705160 0 0 0 0</span><br></pre></td></tr></table></figure>
<p>hda后的各个参数含义如下：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Field</span>  <span class="number">1</span> --<span class="meta"> # of reads completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">2</span> --<span class="meta"> # of reads merged, field 6 -- # of writes merged</span></span><br><span class="line">	为了提高IO的效率，两个相邻的读写操作会被合并，所以两个<span class="number">4</span>K的读操作在提交给磁盘之前会被合并为一个<span class="number">8</span>K的读操作，杜宇磁盘来说只会视作只有一个读操作。</span><br><span class="line"><span class="keyword">Field</span>  <span class="number">3</span> --<span class="meta"> # of sectors read</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">4</span> --<span class="meta"> # of milliseconds spent reading</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">5</span> --<span class="meta"> # of writes completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">6</span> --<span class="meta"> # of writes merged</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">7</span> --<span class="meta"> # of sectors written</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">8</span> --<span class="meta"> # of milliseconds spent writing</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">9</span> --<span class="meta"> # of I/Os currently in progress</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">10</span> --<span class="meta"> # of milliseconds spent doing I/Os</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">12</span> --<span class="meta"> # of discards completed</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">13</span> --<span class="meta"> # of discards merged</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">14</span> --<span class="meta"> # of sectors discarded</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">15</span> --<span class="meta"> # of milliseconds spent discarding</span></span><br></pre></td></tr></table></figure>
<p>跟记录CPU信息的/proc/stat文件一样，/proc/diskstats中每个字段的数值也是从系统启动后一直累加的。通过这些参数，可以计算出通过 <code>iostat</code>命令算出的参数，具体可以参考<a href="../#iostat">iostat</a> 。我们用delta来表示在时间t内某个字段的增量。例如<strong>定义delta(reads merged)为当前reads merged的值减去t秒前reads merged的值</strong>。</p>
<ul>
<li>rrqm/s：delta(<em>reads merged</em>) / t  （得到时间t内平均每秒reads merged的值）</li>
<li>wrqm/s：delta(<em>writes merged</em>) / t</li>
<li>r/s：delta(<em>reads completed</em>) / t</li>
<li>w/s：delta(<em>writes completed</em>) / t</li>
<li>rsec/s：delta(<em>sectors read</em>) / t</li>
<li>wsec/s：delta(<em>sectors written</em>) / t</li>
<li>rkB/s：delta(<em>sectors read</em>) / t / 2  （因为1 扇区为512字节，所以rkB/s为rsec/s的一半）</li>
<li>wkB/s：delta(<em>sectors written</em>) / t / 2</li>
<li>avgrq-sz：(delta(<em>sectors read</em>) + delta(<em>sectors written</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li>
<li><strong>avgqu-sz</strong>：<em>*delta(</em>weighted time spent doing I/Os*) / t / 1000 （单位为毫秒，所以除以1000）</li>
<li><strong>await：</strong>(delta(<em>time spent reading</em>) + delta(<em>time spent writing</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li>
<li><strong>svctm：</strong>delta(<em>time spent doing I/Os</em>)/ (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))**</li>
<li><strong>%util：</strong>delta(<em>time spent doing I/Os</em>) / t / 1000 * 100%</li>
</ul>
<p>所有磁盘汇总采集项：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>采集项</th>
<th>采集项说明</th>
<th>是否乘以100以保留精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>avgqu_sz_max</td>
<td>所有磁盘avgqu_sz最大值</td>
<td>是</td>
</tr>
<tr>
<td>svctm_time_max</td>
<td>所有磁盘svctm最大值</td>
<td>是</td>
</tr>
<tr>
<td>await_time_max</td>
<td>所有磁盘await最大值</td>
<td>是</td>
</tr>
<tr>
<td>util_max</td>
<td>所有磁盘%util最大值</td>
<td>否</td>
</tr>
<tr>
<td>disk_total_read</td>
<td>所有磁盘的r/s总和</td>
<td>是</td>
</tr>
<tr>
<td>disk_total_write</td>
<td>所有磁盘的w/s总和</td>
<td>是</td>
</tr>
<tr>
<td>磁盘IO disk_block_in</td>
<td>所有磁盘的rkB/s总和。bi即block in，表示从块设备（如磁盘）读取的块数。Linux块设备的块大小都为1024字节，所以disk_bi等于rkB/s。</td>
<td>否</td>
</tr>
<tr>
<td>磁盘IO disk_block_out</td>
<td>所有磁盘的rkB/s总和bo即block out，表示发给块设备的块数，即写磁盘。Linux块设备的块大小都为1024字节，所以disk_bi等于wkB/s。</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<p>单个磁盘采集项：</p>
<p>对于安装了1个以上的磁盘的服务器，可以采集单个磁盘的IO数据。最多支持24个盘。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>采集项</th>
<th>采集项说明</th>
<th>是否乘以100以保留精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>disk_n_util（n为0-23）</td>
<td>第n个磁盘的%util值</td>
<td>否</td>
</tr>
<tr>
<td>disk_n_await</td>
<td>第n个磁盘的await值</td>
<td>是</td>
</tr>
<tr>
<td>disk_n_read</td>
<td>第n个磁盘的r/s值</td>
<td>是</td>
</tr>
<tr>
<td>disk_n_write</td>
<td>第n个磁盘的w/s值</td>
<td>是</td>
</tr>
<tr>
<td>disk_n_block_in</td>
<td>第n个磁盘的rkB/s值</td>
<td>否</td>
</tr>
<tr>
<td>disk_n_block_out</td>
<td>第n个磁盘的wkB/s值</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<h2 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h2><h3 id="流量包量"><a href="#流量包量" class="headerlink" title="流量包量"></a>流量包量</h3><p>通过<code>/proc/net/dev</code>文件，可以计算出服务器的流量及包量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/dev</span></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   69570    1756    0    0    0     0          0         0    69570    1756    0    0    0     0       0          0</span><br><span class="line">  eth0: 2012939491 4197833    0    0    0     0          0         0 277523863 3280731    0    0    0     0       0          0</span><br><span class="line">docker0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0</span><br></pre></td></tr></table></figure>
<p>与记录CPU信息的 <code>/proc/stat</code>文件类似，<code>/proc/net/dev</code>中的数值，也是从系统启动后一直累加的。</p>
<p>计算网卡流量方法如下：</p>
<ul>
<li>读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes0、receive_packets0、transmit_bytes0、transmit_packets0</li>
<li>sleep 60秒</li>
<li>再次读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes1、receive_packets1、transmit_bytes1、transmit_packets1</li>
<li>根据60秒前后的/proc/net/dev文件，便可计算出下面的指标：<ul>
<li>60秒内平均每秒入流量：(receive_bytes1 - receive_bytes0) * 8 / 60 / 1000 （kbps）（乘以8是为了把bytes转成bit，除以1000是为了把单位转成k，除以60则是取60秒内的平均值）</li>
<li>60 秒内平均每秒出流量：(transmit_bytes1 - transmit_bytes0) * 8 / 60 / 1000 （kbps）</li>
<li>60秒内平均每秒入包数：(receive_packets1 - receive_packets0) / 60 （个）</li>
<li>60秒内平均每秒出包数：(transmit_packets1 - transmit_packets0) / 60 （个）</li>
</ul>
</li>
</ul>
<h3 id="TCP连接数"><a href="#TCP连接数" class="headerlink" title="TCP连接数"></a>TCP连接数</h3><p><code>/proc/net/snmp</code>记录了一些TCP信息，其中比较有用的是 <code>CurrEstab</code>字段，即当前已建立的TCP连接数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/snmp</span></span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 3527912 0 23 1893737 0 0 1634151 3266670 18 40 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 92566 32 0 65 0 0 0 0 92501 0 0 0 0 0 93265 0 746 0 0 0 18 0 92501 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType8 OutType0 OutType3 OutType5</span><br><span class="line">IcmpMsg: 65 92501 92501 746 18</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 65567 687 59 249 8 1516787 1268763 805 4 33191 4</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">Udp: 22034 822 0 21968 0 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>
<h3 id="UDP接收和发送数据报"><a href="#UDP接收和发送数据报" class="headerlink" title="UDP接收和发送数据报"></a>UDP接收和发送数据报</h3><p><code>/proc/net/snmp</code>还记录了一些UDP信息，其中比较有用的是<code>InDatagrams</code>及<code>OutDatagrams</code>字段。 </p>
<p>UDP接收和发送数据报计算方法与 <code>/proc/net/dev</code>类似，步骤如下：</p>
<ul>
<li>读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data0和out_data0</li>
<li>Sleep 240秒</li>
<li>再次读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data1和out_data1</li>
<li>根据240秒前后的/proc/net/snmp文件，便可计算下面两个指标：<ul>
<li>240秒内平均每秒UDP入数据报：(in_data1 - in_data0) / 240</li>
<li>240秒内平均每秒UDP出数据报：(out_data1 - out_data0) / 240</li>
</ul>
</li>
<li>UDP数据每240上报一次。</li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>stats</tag>
        <tag>monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Slice</title>
    <url>/posts/251346e5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>相对于最基本的 Array 数据结构，在 Go 语言中，使用的更多的是 Slice（切片）。Slice 实质上就是动态数组，类似于C++ STL中的 Vector。Slice 的长度并不固定，可以随意向 Slice 中 Append 元素，Slice 在容量不足时会自动扩容。本篇会首先介绍 Slice 的基本使用，然后介绍 Slice 实现的内部原理。</p>
<a id="more"></a>
<h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><p>在 Go 语言中，切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过以下方式声明 Slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">letters := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>或者也可以使用内置的 <code>make</code> 函数来创建一个 Slice，这里可以指定切片的长度和容量，其中容量可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func make([]T, len, cap) []T</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">byte</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// s == []byte&#123;0, 0, 0, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 cap 参数省略时，默认等同于制定的 len</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以通过对现有切片再切片来获得新的切片，通过 <code>s[1:4]</code> 这种使用下标的方式来实现，这是一个前闭后开区间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := []<span class="keyword">byte</span>&#123;<span class="string">'g'</span>, <span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>&#125;</span><br><span class="line"><span class="comment">// b[1:4] == []byte&#123;'o', 'l', 'a'&#125;, sharing the same storage as b</span></span><br><span class="line"><span class="comment">// b[:2] == []byte&#123;'g', 'o'&#125;</span></span><br><span class="line"><span class="comment">// b[2:] == []byte&#123;'l', 'a', 'n', 'g'&#125;</span></span><br><span class="line"><span class="comment">// b[:] == b</span></span><br></pre></td></tr></table></figure>
<p>我们也可以基于同样的Syntax来从Array生成新的Slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"Лайка"</span>, <span class="string">"Белка"</span>, <span class="string">"Стрелка"</span>&#125;</span><br><span class="line">s := x[:] <span class="comment">// a slice referencing the storage of x</span></span><br></pre></td></tr></table></figure>
<p>可以对切片执行 append 操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func append(s []T, x ...T) []T</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// a == []int&#123;0&#125;</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// a == []int&#123;0, 1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>以可以执行 copy 操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func copy(dst, src []T) int</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br></pre></td></tr></table></figure>
<p>下面是对 Slice 的常见用法汇总：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">"emp:"</span>, s)</span><br><span class="line"></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">"b"</span></span><br><span class="line">    s[<span class="number">2</span>] = <span class="string">"c"</span></span><br><span class="line">    fmt.Println(<span class="string">"set:"</span>, s)</span><br><span class="line">    fmt.Println(<span class="string">"get:"</span>, s[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"d"</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"e"</span>, <span class="string">"f"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"apd:"</span>, s)</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(c, s)</span><br><span class="line">    fmt.Println(<span class="string">"cpy:"</span>, c)</span><br><span class="line"></span><br><span class="line">    l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">"sl1:"</span>, l)</span><br><span class="line"></span><br><span class="line">    l = s[:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">"sl2:"</span>, l)</span><br><span class="line"></span><br><span class="line">    l = s[<span class="number">2</span>:]</span><br><span class="line">    fmt.Println(<span class="string">"sl3:"</span>, l)</span><br><span class="line"></span><br><span class="line">    t := []<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"dcl:"</span>, t)</span><br><span class="line"></span><br><span class="line">    twoD := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        innerLen := i + <span class="number">1</span></span><br><span class="line">        twoD[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, innerLen)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">            twoD[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run slices.go</span><br><span class="line">emp: [  ]</span><br><span class="line"><span class="built_in">set</span>: [a b c]</span><br><span class="line">get: c</span><br><span class="line">len: 3</span><br><span class="line">apd: [a b c d e f]</span><br><span class="line">cpy: [a b c d e f]</span><br><span class="line">sl1: [c d e]</span><br><span class="line">sl2: [a b c d e]</span><br><span class="line">sl3: [c d e f]</span><br><span class="line">dcl: [g h i]</span><br><span class="line">2d:  [[0] [1 2] [2 3 4]]</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>编译期间的切片是 <code>Slice</code> 类型的，但是在运行时切片由如下的 <code>SliceHeader</code> 结构体表示，其中 <code>Data</code> <strong>字段是指向数组的指针</strong>，<code>Len</code> 表示当前切片的长度，而 <code>Cap</code> 表示当前切片的容量，也就是 <code>Data</code> 数组的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Data</code> 作为一个指针指向的数组是一片连续的内存空间，这片内存空间可以用于存储切片中保存的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p><img alt="golang-slice-struct" data-src="https://img.draveness.me/2019-02-20-golang-slice-struct.png"></p>
<p>从上图我们会发现切片与数组的关系非常密切，切片引入了一个抽象层，提供了对数组中部分片段的引用，作为数组的引用，我们可以在运行区间可以修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。</p>
<p>我们在上一节介绍过，获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化，由于数组的内存固定且连续，很多操作都会变成对内存的直接读写。但是切片是运行时才会确定内容的结构，所有的操作还需要依赖 Go 语言的运行时来完成，我们接下来就会介绍切片一些常见操作的实现原理。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Go 语言中的切片有三种初始化的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字 <code>make</code> 创建切片：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><p>使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，<code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 这些操作会由编译器转换成 <code>OpSliceMake</code> 操作，我们可以通过下面的代码来验证一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> opslicemake</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	slice := arr[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>GOSSAFUNC</code> 变量编译上述代码可以得到如下所示的 SSA 中间代码，在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>的 <code>decompose builtin</code> 阶段，<code>slice := arr[0:1]</code> 对应的部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v27 (+<span class="number">5</span>) = SliceMake &lt;[]<span class="keyword">int</span>&gt; v11 v14 v17</span><br><span class="line"></span><br><span class="line">name &amp;arr[*[<span class="number">3</span>]<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.ptr[*<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.<span class="built_in">len</span>[<span class="keyword">int</span>]: v14</span><br><span class="line">name slice.<span class="built_in">cap</span>[<span class="keyword">int</span>]: v17</span><br></pre></td></tr></table></figure>
<p><code>SliceMake</code> 这个操作会接受三个参数创建新的切片，元素类型、数组指针、切片大小和容量，这也就是我们在数据结构一节中提到的切片的几个字段。</p>
<p>也就是说，通过下标的方式，并不会复制切片实际的数据，只是创建了一个新的切片，将其数据指向原来的数组。所以，修改新生成的切片后，原来数组的数据也会改变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d := []<span class="keyword">byte</span>&#123;<span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line">e := d[<span class="number">2</span>:]</span><br><span class="line"><span class="comment">// e == []byte&#123;'a', 'd'&#125;</span></span><br><span class="line">e[<span class="number">1</span>] = <span class="string">'m'</span></span><br><span class="line"><span class="comment">// e == []byte&#123;'a', 'm'&#125;</span></span><br><span class="line"><span class="comment">// d == []byte&#123;'r', 'o', 'a', 'm'&#125;</span></span><br></pre></td></tr></table></figure>
<p>一个切片可以通过下标方式扩展不能超过其容量，否则会产生 <code>runtime panic</code>，就像在数组越界的时候一样。</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>当我们使用字面量 <code>[]int{1, 2, 3}</code> 创建新的切片时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L595-L766" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">3</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:]</span><br></pre></td></tr></table></figure>
<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量，<a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2126" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheck1</code></a> 会对参数进行校验：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> OMAKE:</span><br><span class="line">		args := n.List.Slice()</span><br><span class="line"></span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		<span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">		<span class="keyword">case</span> TSLICE:</span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				yyerror(<span class="string">"missing len argument to make(%v)"</span>, t)</span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			l = args[i]</span><br><span class="line">			i++</span><br><span class="line">			<span class="keyword">var</span> r *Node</span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				r = args[i]</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				yyerror(<span class="string">"len larger than cap in make(%v)"</span>, t)</span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.Left = l</span><br><span class="line">			n.Right = r</span><br><span class="line">			n.Op = OMAKESLICE</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>，除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，随后的中间代码生成阶段在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1315" target="_blank" rel="external nofollow noopener noreferrer"><code>OMAKESLICE</code></a> 分支依据两个重要条件对这里的 <code>OMAKESLICE</code> 进行转换：</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了逃逸，最终在堆上初始化</li>
</ol>
<p>当切片发生逃逸或者非常大时，我们需要 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a> 函数在堆上初始化，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>上述代码会初始化数组并且直接通过下标 <code>[:3]</code> 来得到数组的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组，<code>[:3]</code> 会被转换成上一节提到的 <code>OpSliceMake</code> 操作。</p>
<p>分析了主要由编译器处理的分支之后，我们回到用于创建切片的运行时函数 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a>，这个函数的实现非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">		<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的主要工作就是计算当前切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">内存空间 </span>=<span class="string"> 切片中元素大小 x 切片容量</span></span><br></pre></td></tr></table></figure>
<p>虽然大多的错误都可以在编译期间被检查出来，但是在创建切片的过程中如果发生了以下错误就会直接导致程序触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p><code>mallocgc</code> 就是用于申请内存的函数，这个函数的实现还是比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的一些对象会在堆上初始化，我们会在后面的章节中详细介绍 Go 语言的内存分配器，在这里就不展开分析了。</p>
<p>目前的 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a> 会返回指向底层数组的指针，之前版本的 Go 语言中，数组指针、长度和容量会被合成一个 <code>slice</code> 结构并返回，但是从 <a href="https://github.com/golang/go/commit/020a18c545bf49ffc087ca93cd238195d8dcc411#diff-d9238ca551e72b3a80da9e0da10586a4" target="_blank" rel="external nofollow noopener noreferrer">cmd/compile: move slice construction to callers of makeslice</a> 这次提交之后，构建结构体 <code>SliceHeader</code> 的工作就都交给 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a> 的调用方处理了，这些调用方会在编译期间构建切片结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> OSLICEHEADER:</span><br><span class="line">	<span class="keyword">switch</span> </span><br><span class="line">		t := n.Type</span><br><span class="line">		n.Left = typecheck(n.Left, ctxExpr)</span><br><span class="line">		l := typecheck(n.List.First(), ctxExpr)</span><br><span class="line">		c := typecheck(n.List.Second(), ctxExpr)</span><br><span class="line">		l = defaultlit(l, types.Types[TINT])</span><br><span class="line">		c = defaultlit(c, types.Types[TINT])</span><br><span class="line"></span><br><span class="line">		n.List.SetFirst(l)</span><br><span class="line">		n.List.SetSecond(c)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OSLICEHEADER</code> 操作会创建我们在上面介绍过的结构体 <code>SliceHeader</code>，其中包含数组指针、切片长度和容量，它也是切片在运行时的表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正是因为大多数对切片类型的操作并不需要直接操作原 <code>slice</code> 结构体，所以 <code>SliceHeader</code> 的引入能够减少切片初始化时的少量开销，这个改动能够减少 ~0.2% 的 Go 语言包大小并且能够减少 92 个 <code>panicindex</code> 的调用，占整个 Go 语言二进制的 ~3.5%。</p>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>对切片常见的操作就是获取它的长度或者容量，这两个不同的函数 <code>len</code> 和 <code>cap</code> 被 Go 语言的编译器看成是两种特殊的操作，即 <code>OLEN</code> 和 <code>OCAP</code>，它们会在 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">SSA 生成阶段</a>被 <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L1975-L2724" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.epxr</code></a> 函数转换成 <code>OpSliceLen</code> 和 <code>OpSliceCap</code> 操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OLEN, OCAP:</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">			op := ssa.OpSliceLen</span><br><span class="line">			<span class="keyword">if</span> n.Op == OCAP &#123;</span><br><span class="line">				op = ssa.OpSliceCap</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> s.newValue1(op, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问切片中的字段可能会触发 <code>decompose builtin</code> 阶段的优化，<code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会被直接替换成切片的长度或者容量，不需要运行时从切片结构中获取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(SlicePtr (SliceMake ptr _ _ )) -&gt; ptr</span><br><span class="line">(SliceLen (SliceMake _ <span class="built_in">len</span> _)) -&gt; <span class="built_in">len</span></span><br><span class="line">(SliceCap (SliceMake _ _ <span class="built_in">cap</span>)) -&gt; <span class="built_in">cap</span></span><br></pre></td></tr></table></figure>
<p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OINDEX:</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">			p := s.addr(n, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> s.load(n.Left.Type.Elem(), p)</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用 <code>range</code> 遍历切片时也会在编译期间转换成形式更简单的代码，我们会在后面的 <code>range</code> 关键字一节中介绍使用 <code>range</code> 遍历切片的过程。</p>
<h2 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h2><p>向切片中追加元素应该是最常见的切片操作，在 Go 语言中我们会使用 <code>append</code> 关键字向切片追加元素，中间代码生成阶段的 <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L2732-L2884" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.append</code></a> 方法会拆分 <code>append</code> 关键字，该方法追加元素会根据返回值是否会覆盖原变量，分别进入两种流程，如果 <code>append</code> 返回的『新切片』不需要赋值回原有的变量，就会进入如下的处理流程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// append(slice, 1, 2, 3)</span></span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(slice, newlen)</span><br><span class="line">    newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>
<p>我们会先对切片结构体进行解构获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growslice</code></a> 对切片进行扩容并将新的元素依次加入切片；如果 <code>append</code> 后的切片会覆盖原切片，即 <code>slice = append(slice, 1, 2, 3)</code>， <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L2732-L2884" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.append</code></a> 就会使用另一种方式改写关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice = append(slice, 1, 2, 3)</span></span><br><span class="line">a := &amp;slice</span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint</span>(newlen) &gt; <span class="keyword">uint</span>(<span class="built_in">cap</span>) &#123;</span><br><span class="line">   newptr, <span class="built_in">len</span>, newcap = growslice(slice, newlen)</span><br><span class="line">   vardef(a)</span><br><span class="line">   *a.<span class="built_in">cap</span> = newcap</span><br><span class="line">   *a.ptr = newptr</span><br><span class="line">&#125;</span><br><span class="line">newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">*a.<span class="built_in">len</span> = newlen</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>是否覆盖原变量的逻辑其实差不多，最大的区别在于最后的结果是不是赋值会原有的变量，如果我们选择覆盖原有的变量，也不需要担心切片的拷贝，因为 Go 语言的编译器已经对这种情况作了优化。</p>
<p><img alt="golang-slice-append" data-src="https://img.draveness.me/2020-03-12-15839729948451-golang-slice-append.png"></p>
<p>到这里我们已经通过 <code>append</code> 关键字被转换的控制流了解了在切片容量足够时如何向切片中追加元素，但是当切片的容量不足时就会调用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growslice</code></a> 函数为切片扩容，扩容就是为切片分配一块新的内存空间并将原切片的元素全部拷贝过去，我们分几部分分析该方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在分配内存空间之前需要先确定新的切片容量，Go 语言根据切片的当前容量选择不同的策略进行扩容：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片容量小于 1024 就会将容量翻倍；</li>
<li>如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p>确定了切片的容量之后，就可以计算切片中新数组占用的内存了，计算的方法就是将目标容量和元素大小相乘，计算新容量时可能会发生溢出或者请求的内存超过上限，在这时就会直接 <code>panic</code>，不过相关的代码在这里就被省略了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem, _ = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">		capmem = roundupsize(capmem)</span><br><span class="line">		newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memmove(p, old.array, lenmem)</span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果切片中元素不是指针类型，那么就会调用 <code>memclrNoHeapPointers</code> 将超出切片当前长度的位置清空并在最后使用 <code>memmove</code> 将原数组内存中的内容拷贝到新申请的内存中。这里的 <code>memclrNoHeapPointers</code> 和 <code>memmove</code> 都是用目标机器上的汇编指令实现的，在这里就不展开介绍了。</p>
<p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growslice</code></a> 函数最终会返回一个新的 <code>slice</code> 结构，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会改变原有的切片，帮助 <code>append</code> 完成元素追加的功能。</p>
<h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>切片的拷贝虽然不是一个常见的操作类型，但是却是我们学习切片实现原理必须要谈及的一个问题，当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2980-L3040" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.copyany</code></a> 函数也会分两种情况进行处理，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>memmove</code> 会负责对内存进行拷贝，在其他情况下，编译器会使用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L197-L230" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.slicecopy</code></a> 函数替换运行期间调用的 <code>copy</code>，例如：<code>go copy(a, b)</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := fm.<span class="built_in">len</span></span><br><span class="line">	<span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">		*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数的实现非常直接，两种不同的拷贝方式一般都会通过 <code>memmove</code> 将整块内存中的内容拷贝到目标的内存区域中：</p>
<p><img alt="golang-slice-copy" data-src="https://img.draveness.me/2019-02-20-golang-slice-copy.png"></p>
<p>相比于依次对元素进行拷贝，这种方式能够提供更好的性能，但是需要注意的是，哪怕使用 <code>memmove</code> 对内存成块进行拷贝，但是这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>切片的很多功能都是在运行时实现的了，无论是初始化切片，还是对切片进行追加或扩容都需要运行时的支持，需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要在使用时减少这种情况的发生避免对程序的性能造成影响。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="external nofollow noopener noreferrer">Arrays, slices (and strings): The mechanics of ‘append’</a></li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="external nofollow noopener noreferrer">Go Slices: usage and internals</a></li>
<li><a href="https://stackoverflow.com/questions/30525184/array-vs-slice-accessing-speed" target="_blank" rel="external nofollow noopener noreferrer">Array vs Slice: accessing speed</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>数据结构</tag>
        <tag>Slice</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Hash Table</title>
    <url>/posts/c3c43baa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hash Table（哈希表，也叫散列表） 是在计算机科学中除了 Array 外应用最为广泛的数据结构，它通过 Hash 函数以 Key 为参数，计算出一个在Buckets Array中的 Index，用于将 Key 映射到表中的 Value。在平均情况下，哈希表具有 <code>O(1)</code> 的读写性能，实际证明它比搜索树等其他数据结构查找效率更高，所以也应用最为广泛。理想条件下，Hash 函数会将每个Key分配到不同的Bucket中，但是很多实际哈希表的实现中通常会使用一个不理想的Hash函数，从而会导致Hash冲突，所以哈希表的实现中需要考虑的一个重要问题是Hash冲突。</p>
<p>Go 语言中内置的 Map 类型实现了哈希表的数据结构，本文将介绍 Map 的使用方法与其实现原理。</p>
<a id="more"></a>
<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在 Go 语言中，map 类型如下所示，需要声明 Key 和 Value的数据类型，其中Key需要是一种可以比较的数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map[KeyType]ValueType</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>Map 和 Slice、Pointer类似，是一种 Reference 类型，所以上面的 <code>m</code> 的值是 <code>nil</code>。对于一个 nil 的map，我们可以读，但是不能写，否则会造成 <code>runtime panic</code>。为了初始化一个map，我们可以用 <code>make</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">"houmin"</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">"cosmos"</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>make</code> 函数将申请内存空间，并且初始化一个map的数据结构。</p>
<p>Map 有内置的 <code>len</code> 函数用于计算一个哈希表中有多少 item，也可以通过 <code>delete</code> 函数来删除元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(m)</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"houmin"</span>)</span><br></pre></td></tr></table></figure>
<p>为了访问map，注意这里在循环访问map的时候，并不保证各个key之间的顺序，同一段代码的两次访问顺序也不保证一致：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, ok := m[<span class="string">"houmin"</span>]</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Key:"</span>, key, <span class="string">"Value:"</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以不使用 <code>make</code> 函数来初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">commits := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"rsc"</span>: <span class="number">3711</span>,</span><br><span class="line">    <span class="string">"r"</span>:   <span class="number">2138</span>,</span><br><span class="line">    <span class="string">"gri"</span>: <span class="number">1908</span>,</span><br><span class="line">    <span class="string">"adg"</span>: <span class="number">912</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发访问"><a href="#并发访问" class="headerlink" title="并发访问"></a>并发访问</h3><p><a href="https://golang.org/doc/faq#atomic_maps" target="_blank" rel="external nofollow noopener noreferrer">Go语言中的Map并不是并发安全的哈希表</a> ，Go 并没有定义同时读写 Map 可能发生的情况。如果你需要在并发执行的 Go Routine 中同时读写一个Map，那么一定需要某种同步机制来控制对于Map的访问，最常见的一种方式就是 <code>sync.RWMutex</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>对于这里定义的 counter 变量，Read操作和Write操作如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read Operation</span></span><br><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[<span class="string">"some_key"</span>]</span><br><span class="line">counter.RUnlock()</span><br><span class="line">fmt.Println(<span class="string">"some_key:"</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write Operation</span></span><br><span class="line">counter.Lock()</span><br><span class="line">counter.m[<span class="string">"some_key"</span>]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>根据上面的介绍，哈希表的设计总体可以表示如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func HashTable(key) value &#123;</span><br><span class="line">  hash := HashFunc(key)</span><br><span class="line">  index := hash % array_size</span><br><span class="line">  value = GetValueFromBucketArray(index)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要实现一个性能优异的哈希表，关键点在于哈希函数和冲突解决方法的设计。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数负责将不同的Key映射到不同的Index上，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将每个Key映射到一个唯一的的Index上，这要求<strong>哈希函数Value的范围大于Key的范围</strong>，但是由于实际情况下Key的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。</p>
<p><img alt="perfect-hash-function" data-src="https://img.draveness.me/2019-12-30-15777168478768-perfect-hash-function.png"></p>
<p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。</p>
<p><img alt="bad-hash-function" data-src="https://img.draveness.me/2019-12-30-15777168478778-bad-hash-function.png"></p>
<p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 <code>O(1)</code> 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 <code>O(n)</code> 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。</p>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多最终也会造成冲突。然而我们的哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法 是一种在哈希表中解决哈希碰撞的方法，当哈希碰撞发生时，从发生碰撞的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。 具体的Hash计算方法如下，其中Hash(key) 为散列函数，m 为 散列表长，$D_i$ 为增量序列，i 为已发生冲突的次数。</p>
<script type="math/tex; mode=display">
Hash_i = (Hash(key) + D_i)\ \ mod\ \ m,\ i = 1,2,...,k(k<=m-1)</script><p>根据 $D_i$ 的不同取法，我们有不同的探测方法：</p>
<ul>
<li>线性探测（Linear Probing）：$D_i = i$</li>
<li>平方探测（Quadratic Probing）：$D_i = 1^2, 2^2, …, k^2$</li>
<li>伪随机探测：$D_i$ 为伪随机序列。</li>
</ul>
<p><img alt="Open Addressing" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-25_hash-open-addressing.png"></p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
<p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的「二维数组」：</p>
<p><img alt="Seperate Chaining" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-25_hash-seperate-chaining.png"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 <a href="https://github.com/golang/go/blob/ed15e82413c7b16e21a493f5a647f68b46e965ee/src/runtime/map.go#L115-L129" target="_blank" rel="external nofollow noopener noreferrer"><code>hmap</code></a> 结构体来表示哈希，我们先来看一下这个结构体内部的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="keyword">int</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li>
</ol>
<p><img alt="hmap-and-buckets" data-src="https://img.draveness.me/2019-12-30-15777168478811-hmap-and-buckets.png"></p>
<p>如上图所示哈希表 <code>hmap</code> 的桶就是 <code>bmap</code>，每一个 <code>bmap</code> 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶无法装满时就会使用 <code>extra.overflow</code> 中桶存储溢出的数据。上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 <code>bmap</code> 就是正常桶，绿色的 <code>bmap</code> 是溢出桶，溢出桶是在 Go 语言还使用 C 语言实现时就使用的设计<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>，由于它能够减少扩容的频率所以一直使用至今。</p>
<p>这个桶的结构体 <code>bmap</code> 在 Go 语言源代码中的定义只包含一个简单的 <code>tophash</code> 字段，<code>tophash</code> 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bmap</code> 结构体其实不止包含 <code>tophash</code> 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段，但是我们能根据编译期间的 <a href="https://github.com/golang/go/blob/be64a19d99918c843f8555aad580221207ea35bc/src/cmd/compile/internal/gc/reflect.go#L82-L187" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.bmap</code></a> 函数对它的结构重建：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果哈希表存储的数据逐渐增多，我们会对哈希表进行扩容或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p>
<p>从 Go 语言哈希的定义中就可以发现，它比前面两节提到的数组和切片复杂得多，结构体中不仅包含大量字段，还使用了较多的复杂结构，在后面的小节中我们会详细介绍不同字段的作用。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>既然已经介绍了常见哈希表的基本原理和实现方法，那么可以开始分析 Go 语言中哈希表的实现，首先要分析的就是在 Go 语言中初始化哈希的两种方法 — 通过字面量和运行时。</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>目前的现代编程语言基本都支持使用字面量的方式初始化哈希，一般都会使用 <code>key: value</code> 的语法来表示键值对，Go 语言中也不例外：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">"3"</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">"5"</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在初始化哈希时声明键值对的类型，这种使用字面量初始化的方式最终都会通过 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L768-L873" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.maplit</code></a> 函数初始化，我们来分析一下 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L768-L873" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.maplit</code></a> 函数初始化哈希的过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *Node, m *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	a := nod(OMAKE, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	a.Esc = n.Esc</span><br><span class="line">	a.List.Set2(typenod(n.Type), nodintconst(<span class="keyword">int64</span>(n.List.Len())))</span><br><span class="line">	litas(m, a, init)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stat, dyn []*Node</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		stat = <span class="built_in">append</span>(stat, r)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(stat) &gt; <span class="number">25</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		addMapEntries(m, stat, init)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当哈希表中的元素数量少于或者等于 25 个时，编译器会直接调用 <code>addMapEntries</code> 将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">"1"</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">"3"</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">"5"</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>这种初始化的方式与前面两节分析的<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/" target="_blank" rel="external nofollow noopener noreferrer">数组</a>和<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="external nofollow noopener noreferrer">切片</a>的几乎完全相同，由此看来集合类型的初始化在 Go 语言中有着相同的处理方式和逻辑。</p>
<p>一旦哈希表中元素的数量超过了 25 个，就会在编译期间创建两个数组分别存储键和值的信息，这些键值对会通过一个如下所示的 for 循环加入目标的哈希：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, ... ， <span class="string">"26"</span>&#125;</span><br><span class="line">vstatv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里展开的两个切片 <code>vstatk</code> 和 <code>vstatv</code> 还会被编辑器继续展开，具体的展开方式可以阅读上一节了解<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="external nofollow noopener noreferrer">切片的初始化</a>，不过无论使用哪种方法，使用字面量初始化的过程都会使用 Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[]</code> 语法向哈希追加元素。</p>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>无论 <code>make</code> 是从哪里来的，只要我们使用 <code>make</code> 创建哈希，Go 语言编译器都会在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/" target="_blank" rel="external nofollow noopener noreferrer">类型检查</a>期间将它们转换成对 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L303-L336" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makemap</code></a> 的调用，使用字面量来初始化哈希也只是语言提供的辅助工具，最后调用的都是 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L303-L336" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makemap</code></a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的执行过程会分成以下几个部分：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用 <code>fastrand</code> 获取一个随机的哈希种子；</li>
<li>根据传入的 <code>hint</code> 计算出需要的最小需要的桶的数量；</li>
<li>使用 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeBucketArray</code></a> 创建用于保存桶的数组；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeBucketArray</code></a> 函数会根据传入的 <code>B</code> 计算出的需要创建的桶数量在内存中分配一片连续的空间用于存储数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="keyword">uint8</span>, dirtyalloc unsafe.Pointer)</span> <span class="params">(buckets unsafe.Pointer, nextOverflow *bmap)</span></span> &#123;</span><br><span class="line">	base := bucketShift(b)</span><br><span class="line">	nbuckets := base</span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)</span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buckets = newarray(t.bucket, <span class="keyword">int</span>(nbuckets))</span><br><span class="line">	<span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">		nextOverflow = (*bmap)(add(buckets, base*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当桶的数量小于 2424 时，由于数据较少、使用溢出桶的可能性较低，这时就会省略创建的过程以减少额外开销；当桶的数量多于 2424 时，就会额外创建 2𝐵−42B−4 个溢出桶，根据上述代码，我们能确定在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <code>hmap</code> 中的不同字段引用，当溢出桶数量较多时会通过 <a href="https://github.com/golang/go/blob/921ceadd2997f2c0267455e13f909df044234805/src/runtime/malloc.go#L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 创建新的溢出桶。</p>
<h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>哈希表作为一种数据结构，我们肯定需要分析它的常见操作，首先就需要了解其读写操作的实现原理，访问哈希表一般都是通过下标或者遍历两种方式进行的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = hash[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">    <span class="comment">// k, v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方式虽然都能读取哈希表中的数据，但是使用的函数和底层的原理完全不同，前者需要知道哈希的键并且一次只能获取单个键对应的值，而后者可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键，在这里我们会介绍前一种访问方式，第二种访问方式会在 <code>range</code> 一节中详细分析。</p>
<p>数据结构的写一般指的都是增加、删除和修改，增加和修改字段都使用索引和赋值语句，而删除字典中的数据需要使用关键字 <code>delete</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash[key] = value</span><br><span class="line">hash[key] = newValue</span><br><span class="line"><span class="built_in">delete</span>(hash, key)</span><br></pre></td></tr></table></figure>
<p>除了这些操作之外，我们还会分析哈希的扩容过程，这能帮助我们深入理解哈希是如何对数据进行存储的。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>在编译的<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/" target="_blank" rel="external nofollow noopener noreferrer">类型检查</a>期间，<code>hash[key]</code> 以及类似的操作都会被转换成对哈希的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1089" target="_blank" rel="external nofollow noopener noreferrer"><code>OINDEXMAP</code></a> 操作，<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>阶段会在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中将这些 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1089" target="_blank" rel="external nofollow noopener noreferrer"><code>OINDEXMAP</code></a> 操作转换成如下的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v     := hash[key] <span class="comment">// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)</span></span><br><span class="line">v, ok := hash[key] <span class="comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span></span><br></pre></td></tr></table></figure>
<p>赋值语句左侧接受参数的个数会决定使用的运行时方法：</p>
<ol>
<li>当接受参数仅为一个时，会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess1</code></a>，该函数仅会返回一个指向目标值的指针；</li>
<li>当接受两个参数时，会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L452-L508" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess2</code></a>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的布尔值：</li>
</ol>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess1</code></a> 函数会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <code>bucketMask</code> 和 <code>add</code> 函数拿到该键值对所在的桶序号和哈希最上面的 8 位数字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>bucketloop</code> 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它会比较这 8 位数字和桶中存储的 <code>tophash</code>，每一个桶都存储键对应的 <code>tophash</code>，每一次读写操作都会与桶中所有的 <code>tophash</code> 进行比较，用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 <code>tophash</code> 的概率。</p>
<p><img alt="hashtable-mapaccess" data-src="https://img.draveness.me/2019-12-30-15777168478817-hashtable-mapaccess.png"></p>
<p><strong>图 3-13 访问哈希表中的数据</strong></p>
<p>如上图所示，每一个桶都是一整片的内存空间，当发现桶中的 <code>tophash</code> 与传入键的 <code>tophash</code> 匹配之后，我们会通过指针和偏移量获取哈希中存储的键 <code>keys[0]</code> 并与 <code>key</code> 比较，如果两者相同就会获取目标值的指针 <code>values[0]</code> 并返回。</p>
<p>另一个同样用于访问哈希表中数据的 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L452-L508" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess2</code></a> 只是在 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess1</code></a> 的基础上多返回了一个标识键值对是否存在的布尔值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="params">(unsafe.Pointer, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>v, ok := hash[k]</code> 的形式访问哈希表中元素时，我们能够通过这个布尔值更准确地知道当 <code>v == nil</code> 时，<code>v</code> 到底是哈希中存储的元素还是表示该键对应的元素不存在，所以在访问哈希时，更推荐使用这一种方式先判断元素是否存在。</p>
<p>上面的过程其实是在正常情况下，访问哈希表中元素时的表现，然而与数组一样，哈希表可能会在装载因子过高或者溢出桶过多时进行扩容，哈希表的扩容并不是一个原子的过程，在扩容的过程中保证哈希的访问是比较有意思的话题，我们在这里其实也省略了相关的代码，不过会在下面展开介绍。</p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>当形如 <code>hash[k]</code> 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign</code></a> 函数，该函数与 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess1</code></a> 比较相似，我们将该其分成几个部分分析，首先是函数会根据传入的键拿到对应的哈希和桶：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br></pre></td></tr></table></figure>
<p>然后通过遍历比较桶中存储的 <code>tophash</code> 和键的哈希，如果找到了相同结果就会获取目标位置的地址并返回，其中 <code>inserti</code> 表示目标元素的在桶中的索引，<code>insertk</code> 和 <code>val</code> 分别表示键值对的地址，获得目标地址之后会直接通过算术计算进行寻址获得键值对 <code>k</code> 和 <code>val</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> inserti *<span class="keyword">uint8</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">	<span class="keyword">var</span> val unsafe.Pointer</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的 for 循环中会依次遍历正常桶和溢出桶中存储的数据，整个过程会依次判断 <code>tophash</code> 是否相等、<code>key</code> 是否相等，遍历结束后会从循环中跳出。</p>
<p><img alt="hashtable-overflow-bucket" data-src="https://img.draveness.me/2019-12-30-15777168478823-hashtable-overflow-bucket.png"></p>
<p><strong>图 3-15 哈希遍历溢出桶</strong></p>
<p>如果当前桶已经满了，哈希会调用 <code>newoverflow</code> 函数创建新桶或者使用 <code>hmap</code> 预先在 <code>noverflow</code> 中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 <code>noverflow</code> 计数器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">		newb := h.newoverflow(t, b)</span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		val = add(insertk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	typedmemmove(t.key, insertk, key)</span><br><span class="line">	*inserti = top</span><br><span class="line">	h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前键值对在哈希中不存在，哈希为新键值对规划存储的内存地址，通过 <code>typedmemmove</code> 将键移动到对应的内存空间中并返回键对应值的地址 <code>val</code>，如果当前键值对在哈希中存在，那么就会直接返回目标区域的内存地址。哈希并不会在 <code>mapassign</code> 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，真正的赋值操作是在编译期间插入的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">00018</span> (+<span class="number">5</span>) CALL runtime.mapassign_fast64(SB)</span><br><span class="line"><span class="number">00020</span> (<span class="number">5</span>) MOVQ <span class="number">24</span>(SP), DI               ;; DI = &amp;value</span><br><span class="line"><span class="number">00026</span> (<span class="number">5</span>) LEAQ <span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"88"</span>(SB), AX   ;; AX = &amp;<span class="string">"88"</span></span><br><span class="line"><span class="number">00027</span> (<span class="number">5</span>) MOVQ AX, (DI)                 ;; *DI = AX</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map_fast64.go#L92-L180" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign_fast64</code></a> 与 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign</code></a> 函数的实现差不多，我们需要关注的是后面的三行代码，<code>24(SP)</code> 就是该函数返回的值地址，我们通过 <code>LEAQ</code> 指令将字符串的地址存储到寄存器 <code>AX</code> 中，<code>MOVQ</code> 指令将字符串 <code>&quot;88&quot;</code> 存储到了目标地址上完成了这次哈希的写入。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>我们在介绍哈希的写入过程时省略了扩容操作，随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign</code></a> 函数会在以下两种情况发生时触发哈希的扩容：</p>
<ol>
<li>装载因子已经超过 6.5；</li>
<li>哈希使用了太多溢出桶；</li>
</ol>
<p>不过由于 Go 语言哈希的扩容不是一个原子的过程，所以 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign</code></a> 函数还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</p>
<p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 <code>sameSizeGrow</code>，<code>sameSizeGrow</code> 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a>。<a href="https://github.com/golang/go/commit/9980b70cb460f27907a003674ab1b9bea24a847c" target="_blank" rel="external nofollow noopener noreferrer">runtime: limit the number of map overflow buckets</a> 引入了 <code>sameSizeGrow</code> 通过重用已有的哈希扩容机制，一旦哈希中出现了过多的溢出桶，它就会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:5" target="_blank" rel="external nofollow noopener noreferrer">5</a>。</p>
<p>扩容的入口是 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1017-L1058" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hashGrow</code></a> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	h.B += bigger</span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets</span><br><span class="line">	h.buckets = newbuckets</span><br><span class="line">	h.nevacuate = <span class="number">0</span></span><br><span class="line">	h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">	h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	h.extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希在扩容的过程中会通过 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeBucketArray</code></a> 创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到 <code>oldbuckets</code> 上并将新的空桶设置到 <code>buckets</code> 上，溢出桶也使用了相同的逻辑进行更新，下图展示了触发扩容后的哈希：</p>
<p><img alt="hashtable-hashgrow" data-src="https://img.draveness.me/2019-12-30-15777168478830-hashtable-hashgrow.png"></p>
<p><strong>图 3-15 哈希表触发扩容</strong></p>
<p>我们在 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1017-L1058" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hashGrow</code></a> 中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移，哈希表的数据迁移的过程在是 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.evacuate</code></a> 函数中完成的，它会对传入桶中的元素进行『再分配』。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	newbit := h.noldbuckets()</span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		x.v = add(x.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">		y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">		y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">		y.v = add(y.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.evacuate</code></a> 函数会将一个旧桶中的数据分流到两个新桶，所以它会创建两个用于保存分配上下文的 <code>evacDst</code> 结构体，这两个结构体分别指向了一个新桶：</p>
<p><img alt="hashtable-evacuate-destination" data-src="https://img.draveness.me/2019-12-30-15777168478836-hashtable-evacuate-destination.png"></p>
<p><strong>图 3-16 哈希表扩容目的</strong></p>
<p>如果这是一等量扩容，旧桶与新桶之间是一对一的关系，所以两个 <code>evacDst</code> 结构体只会初始化一个，当哈希表的容量翻倍时，每个旧桶的元素会都被分流到新创建的两个桶中，我们仔细分析一下分流元素的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="keyword">var</span> useY <span class="keyword">uint8</span></span><br><span class="line">				hash := t.key.alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">				<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">					useY = <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				b.tophash[i] = evacuatedX + useY</span><br><span class="line">				dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">					dst.v = add(dst.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top</span><br><span class="line">				typedmemmove(t.key, dst.k, k)</span><br><span class="line">				typedmemmove(t.elem, dst.v, v)</span><br><span class="line">				dst.i++</span><br><span class="line">				dst.k = add(dst.k, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				dst.v = add(dst.v, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只使用哈希函数是不能定位到具体某一个桶的，哈希函数只会返回很长的哈希，例如：<code>b72bfae3f3285244c4732ce457cca823bc189e0b</code>，我们还需一些方法将哈希映射到具体的桶上，在很多时候我们都会使用取模或者位操作来获取桶的编号，假如当前哈希中包含 4 个桶，那么它的桶掩码就是 <code>0b11(3)</code>，使用位操作就会得到 3， 我们就会在 3 号桶中存储该数据：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">0xb72bfae3f3285244c4732ce457cca823bc189e0b</span> &amp; 0b11 <span class="comment">#=&gt; 0</span></span><br></pre></td></tr></table></figure>
<p>如果新的哈希表有 8 个桶，在大多数情况下，原来经过桶掩码 <code>0b11</code> 结果为 3 的数据会因为桶掩码增加了一位编程 <code>0b111</code> 而分流到新的 3 号和 7 号桶，所有数据也都会被 <code>typedmemmove</code> 拷贝到目标桶中：</p>
<p><img alt="hashtable-bucket-evacuate" data-src="https://img.draveness.me/2019-12-30-15777168478845-hashtable-bucket-evacuate.png"></p>
<p><strong>图 3-17 哈希表桶数据的分流</strong></p>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.evacuate</code></a> 最后会调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1242-L1264" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.advanceEvacuationMark</code></a> 增加哈希的 <code>nevacuate</code> 计数器，在所有的旧桶都被分流后清空哈希的 <code>oldbuckets</code> 和 <code>oldoverflow</code> 字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	h.nevacuate++</span><br><span class="line">	stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">	<span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">		stop = newbit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">		h.nevacuate++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.nevacuate == newbit &#123; <span class="comment">// newbit == # of oldbuckets</span></span><br><span class="line">		h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.flags &amp;^= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前在分析哈希表访问函数 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccess1</code></a> 时其实省略了扩容期间获取键值对的逻辑，当哈希表的 <code>oldbuckets</code> 存在时，就会先定位到旧桶并在该桶没有被分流时从中获取键值对。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">bucketloop:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为旧桶中还没有被 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.evacuate</code></a> 函数分流，其中还保存着我们需要使用的数据，会替代新创建的空桶提供数据。</p>
<p>我们在 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign</code></a> 函数中也省略了一段逻辑，当哈希表正在处于扩容状态时，每次向哈希表写入值时都会触发 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1104-L1113" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growWork</code></a> 对哈希表的内容进行增量拷贝：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然除了写入操作之外，删除操作也会在哈希表扩容期间触发 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1104-L1113" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growWork</code></a>，触发的方式和代码与这里的逻辑几乎完全相同，都是计算当前值所在的桶，然后对该桶中的元素进行拷贝。</p>
<p>我们简单总结一下哈希表的扩容设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，整个扩容过程并不是原子的，而是通过 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1104-L1113" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growWork</code></a> 增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流；除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow</code> 这一机制，在出现较多溢出桶时会对哈希进行『内存整理』减少对空间的占用。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果想要删除哈希中的元素，就需要使用 Go 语言中的 <code>delete</code> 关键字，这个关键的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。</p>
<p><img alt="hashtable-delete" data-src="https://img.draveness.me/2019-12-30-15777168478853-hashtable-delete.png"></p>
<p><strong>图 3-18 哈希表删除操作</strong></p>
<p>在编译期间，<code>delete</code> 关键字会被转换成操作为 <code>ODELETE</code> 的节点，而 <code>ODELETE</code> 会被 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532" target="_blank" rel="external nofollow noopener noreferrer">cmd/compile/internal/gc.walkexpr</a> 转换成 <code>mapdelete</code> 函数簇中的一个，包括 <code>mapdelete</code>、<code>mapdelete_faststr</code>、<code>mapdelete_fast32</code> 和 <code>mapdelete_fast64</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> ODELETE:</span><br><span class="line">		init.AppendNodes(&amp;n.Ninit)</span><br><span class="line">		map_ := n.List.First()</span><br><span class="line">		key := n.List.Second()</span><br><span class="line">		map_ = walkexpr(map_, init)</span><br><span class="line">		key = walkexpr(key, init)</span><br><span class="line"></span><br><span class="line">		t := map_.Type</span><br><span class="line">		fast := mapfast(t)</span><br><span class="line">		<span class="keyword">if</span> fast == mapslow &#123;</span><br><span class="line">			key = nod(OADDR, key, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n = mkcall1(mapfndel(mapdelete[fast], t), <span class="literal">nil</span>, init, typename(t), map_, key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些函数的实现其实差不多，我们来分析其中的 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L685-L791" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapdelete</code></a> 函数，哈希表的删除逻辑与写入逻辑非常相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会对即将操作的桶进行分流，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">search:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> search</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			k2 := k</span><br><span class="line">			<span class="keyword">if</span> !alg.equal(key, k2) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">			v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			*(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">			b.tophash[i] = emptyOne</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们其实只需要知道 <code>delete</code> 关键字在编译期间经过<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/" target="_blank" rel="external nofollow noopener noreferrer">类型检查</a>和<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>阶段被转换成 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L685-L791" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapdelete</code></a> 函数簇中的一员就可以，用于处理删除逻辑的函数与哈希表的 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapassign</code></a> 几乎完全相同，不太需要刻意关注。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。</p>
<p>哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 <code>tophash</code> 就成为了一级缓存帮助哈希快速遍历桶中元素，每一个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会被存储到哈希的溢出桶中。</p>
<p>随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>数据结构</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】String</title>
    <url>/posts/e87a4e07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>字符串是 Go 语言中最常用的基础数据类型之一，虽然字符串往往被看做一个整体，但是实际上字符串是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，在这一节中就会详细介绍字符串的实现原理、相关转换过程以及常见操作的实现。</p>
<a id="more"></a>
<p>字符串虽然在 Go 语言中是基本类型 <code>string</code>，但是它实际上是由字符组成的数组，C 语言中的字符串就使用字符数组 <code>char[]</code> 表示，作为数组会占用一片连续的内存空间，这片内存空间存储了的字节共同组成了字符串，Go 语言中的字符串其实是一个只读的字节数组，下图展示了 <code>&quot;hello&quot;</code> 字符串在内存中的存储方式：</p>
<p><img alt="in-memory-string" data-src="https://img.draveness.me/2019-12-31-15777265631608-in-memory-string.png"></p>
<p><strong>图 3-18 内存中的字符串</strong></p>
<p>如果是代码中存在的字符串，会在编译期间被标记成只读数据 <code>SRODATA</code> 符号，假设我们有以下的一段代码，其中包含了一个字符串，当我们将这段代码编译成汇编语言时，就能够看到 <code>hello</code> 字符串有一个 <code>SRODATA</code> 的标记：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	str := <span class="string">"hello"</span></span><br><span class="line">	println([]byte(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 go tool compile -S main.go</span><br><span class="line">...</span><br><span class="line">go.string.<span class="string">"hello"</span> SRODATA dupok size=5</span><br><span class="line">	0x0000 68 65 6c 6c 6f                                   hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>只读只意味着字符串会分配到只读的内存空间并且这块内存不会被修改，但是在运行时我们其实还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 <code>[]byte</code> 之后就可以进行，修改后通过类型转换就可以变回 <code>string</code>，Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>字符串在 Go 语言中的接口其实非常简单，每一个字符串在运行时都会使用如下的 <code>StringHeader</code> 结构体表示，在运行时包的内部其实有一个私有的结构 <code>stringHeader</code>，它有着完全相同的结构只是用于存储数据的 <code>Data</code> 字段使用了 <code>unsafe.Pointer</code> 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会经常会说字符串是一个只读的<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="external nofollow noopener noreferrer">切片</a>类型，这是因为切片在 Go 语言的运行时表示与字符串高度相似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与切片的结构体相比，字符串少了一个表示容量的 <code>Cap</code> 字段，因为字符串作为只读的类型，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上执行的写入操作实际都是通过拷贝实现的。</p>
<h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>字符串的解析一定是解析器在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/" target="_blank" rel="external nofollow noopener noreferrer">词法分析</a>时就完成的，词法分析阶段会对源文件中的字符串进行切片和分组，将原有无意义的字符流转换成 Token 序列，在 Go 语言中，有两种字面量方式可以声明一个字符串，一种是使用双引号，另一种是使用反引号:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">"this is a string"</span></span><br><span class="line">str2 := <span class="string">`this is another </span></span><br><span class="line"><span class="string">string`</span></span><br></pre></td></tr></table></figure>
<p>使用双引号声明的字符串和其他语言中的字符串没有太多的区别，它只能用于单行字符串的初始化，如果字符串内部出现双引号，需要使用 <code>\</code> 符号避免编译器的解析错误，而反引号声明的字符串就可以摆脱单行的限制，因为双引号不再负责标记字符串的开始和结束，我们可以在字符串内部直接使用 <code>&quot;</code>，在遇到需要手写 JSON 或者其他复杂数据格式的场景下非常方便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">json := <span class="string">`&#123;"author": "draven", "tags": ["golang"]&#125;`</span></span><br></pre></td></tr></table></figure>
<p>两种不同的声明方式其实也意味着 Go 语言的编译器需要在解析的阶段能够区分并且正确解析这两种不同的字符串格式，解析字符串使用的 <code>scanner</code> 扫描器，它的功能就是将输入的字符流转换成 Token 流，<a href="https://github.com/golang/go/blob/cdd2c265cc132a15e20298fbb083a70d7f3b495d/src/cmd/compile/internal/syntax/scanner.go#L641-L669" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/syntax.scanner.stdString</code></a> 方法就是它用来解析使用双引号包裹的标准字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scanner)</span> <span class="title">stdString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s.startLit()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		r := s.getr()</span><br><span class="line">		<span class="keyword">if</span> r == <span class="string">'"'</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r == <span class="string">'\\'</span> &#123;</span><br><span class="line">			s.escape(<span class="string">'"'</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r == <span class="string">'\n'</span> &#123;</span><br><span class="line">			s.ungetr()</span><br><span class="line">			s.error(<span class="string">"newline in string"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r &lt; <span class="number">0</span> &#123;</span><br><span class="line">			s.errh(s.line, s.col, <span class="string">"string not terminated"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.nlsemi = <span class="literal">true</span></span><br><span class="line">	s.lit = <span class="keyword">string</span>(s.stopLit())</span><br><span class="line">	s.kind = StringLit</span><br><span class="line">	s.tok = _Literal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法的实现我们能分析出 Go 语言处理标准字符串的逻辑：</p>
<ol>
<li>标准字符串使用双引号表示开头和结尾；</li>
<li>标准字符串中需要使用反斜杠 <code>\</code> 来 <code>escape</code> 双引号；</li>
<li>标准字符串中不能出现如下所示的隐式换行符号 <code>\n</code>；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">"start</span></span><br><span class="line"><span class="string">end"</span></span><br></pre></td></tr></table></figure>
<p>使用反引号声明的原始字符串的解析规则就非常简单了，<a href="https://github.com/golang/go/blob/cdd2c265cc132a15e20298fbb083a70d7f3b495d/src/cmd/compile/internal/syntax/scanner.go#L671-L693" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/syntax.scanner.rawString</code></a> 会将非反引号的所有字符都划分到当前字符串的范围中，所以我们可以使用它来支持复杂的多行字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scanner)</span> <span class="title">rawString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s.startLit()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		r := s.getr()</span><br><span class="line">		<span class="keyword">if</span> r == <span class="string">'`'</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r &lt; <span class="number">0</span> &#123;</span><br><span class="line">			s.errh(s.line, s.col, <span class="string">"string not terminated"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.nlsemi = <span class="literal">true</span></span><br><span class="line">	s.lit = <span class="keyword">string</span>(s.stopLit())</span><br><span class="line">	s.kind = StringLit</span><br><span class="line">	s.tok = _Literal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是标准字符串还是原始字符串最终都会被标记成 <code>StringLit</code> 类型的 Token 并传递到编译的下一个阶段 — <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-lexer-and-parser/" target="_blank" rel="external nofollow noopener noreferrer">语法分析</a>，在语法分析阶段，与字符串相关的表达式都会使用如下的方法 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/noder.go#L1349-L1408" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.noder.basicLit</code></a> 处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *noder)</span> <span class="title">basicLit</span><span class="params">(lit *syntax.BasicLit)</span> <span class="title">Val</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> s := lit.Value; lit.Kind &#123;</span><br><span class="line">	<span class="keyword">case</span> syntax.StringLit:</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'`'</span> &#123;</span><br><span class="line">			s = strings.Replace(s, <span class="string">"\r"</span>, <span class="string">""</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		u, _ := strconv.Unquote(s)</span><br><span class="line">		<span class="keyword">return</span> Val&#123;U: u&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两遍的引号等无关干扰，还原其本来的面目。</p>
<p><code>strconv.Unquote</code> 方法处理了很多边界条件导致整个函数非常复杂，不仅包括各种不同引号的处理，还包括 UTF-8 等编码的相关问题，所以在这里也就不展开介绍了。</p>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>Go 语言拼接字符串会使用 <code>+</code> 符号，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中调用 <a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.addstr</code></a> 函数生成用于拼接字符串的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> OADDSTR:</span><br><span class="line">		n = addstr(n, init)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.addstr</code></a> 函数能帮助我们在编译期间选择合适的函数对字符串进行拼接，如果需要拼接的字符串小于或者等于 5 个，那么就会直接调用 <code>concatstring{2,3,4,5}</code> 等一系列函数，如果超过 5 个就会直接选择 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.concatstrings</code></a> 传入一个数组切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addstr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	c := n.List.Len()</span><br><span class="line"></span><br><span class="line">	buf := nodnil()</span><br><span class="line">	args := []*Node&#123;buf&#125;</span><br><span class="line">	<span class="keyword">for</span> _, n2 := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		args = <span class="built_in">append</span>(args, conv(n2, types.Types[TSTRING]))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> fn <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> c &lt;= <span class="number">5</span> &#123;</span><br><span class="line">		fn = fmt.Sprintf(<span class="string">"concatstring%d"</span>, c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fn = <span class="string">"concatstrings"</span></span><br><span class="line"></span><br><span class="line">		t := types.NewSlice(types.Types[TSTRING])</span><br><span class="line">		slice := nod(OCOMPLIT, <span class="literal">nil</span>, typenod(t))</span><br><span class="line">		slice.List.Set(args[<span class="number">1</span>:])</span><br><span class="line">		args = []*Node&#123;buf, slice&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cat := syslook(fn)</span><br><span class="line">	r := nod(OCALL, cat, <span class="literal">nil</span>)</span><br><span class="line">	r.List.Set(args)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实无论使用 <code>concatstring{2,3,4,5}</code> 中的哪一个，最终都会调用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.concatstrings</code></a>，该函数会先对传入的切片参数进行遍历，先过滤空字符串并计算拼接后字符串的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstrings</span><span class="params">(buf *tmpBuf, a []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	l := <span class="number">0</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(x)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		l += n</span><br><span class="line">		count++</span><br><span class="line">		idx = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;</span><br><span class="line">		<span class="keyword">return</span> a[idx]</span><br><span class="line">	&#125;</span><br><span class="line">	s, b := rawstringtmp(buf, l)</span><br><span class="line">	<span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="built_in">copy</span>(b, x)</span><br><span class="line">		b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果非空字符串的数量为 1 并且当前的字符串不在栈上就可以直接返回该字符串，不需要进行额外的任何操作。</p>
<p><img alt="string-concat-and-copy" data-src="https://img.draveness.me/2019-12-31-15777265631620-string-concat-and-copy.png"></p>
<p><strong>图 3-19 字符串的拼接和拷贝</strong></p>
<p>但是在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间中，新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>当我们使用 Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 <code>string</code> 和 <code>[]byte</code> 之间来回转换，类型转换的开销并没有想象的那么小，我们经常会看到 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L75-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.slicebytetostring</code></a> 等函数出现在火焰图<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>中，成为程序的性能热点。</p>
<p>从字节数组到字符串的转换就需要使用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L75-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.slicebytetostring</code></a> 函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是字节数组的长度为 0 或者 1，这两个情况处理起来都非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="keyword">byte</span>)</span> <span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(b)</span><br><span class="line">	<span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">		stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">		stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">		p = unsafe.Pointer(buf)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = mallocgc(<span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	stringStructOf(&amp;str).str = p</span><br><span class="line">	stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">	memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理过后会根据传入的缓冲区大小决定是否需要为新的字符串分配一片内存空间，<a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L229-L231" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.stringStructOf</code></a> 会将传入的字符串指针转换成 <code>stringStruct</code> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后通过 <code>memmove</code> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中。</p>
<p>当我们想要将字符串转换成 <code>[]byte</code> 类型时，就需要使用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L155-L165" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.stringtoslicebyte</code></a> 函数，该函数的实现非常容易理解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">		*buf = tmpBuf&#123;&#125;</span><br><span class="line">		b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(b, s)</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果向该函数传入了缓冲区，那么它会使用传入的缓冲区存储 <code>[]byte</code>，没有传入缓冲区时，运行时会调用 <a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L270-L279" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.rawbyteslice</code></a> 创建一个新的字节切片，<code>copy</code> 就会将字符串中的内容拷贝到新的 <code>[]byte</code> 中。</p>
<p><img alt="string-bytes-conversion" data-src="https://img.draveness.me/2019-12-31-15777265631625-string-bytes-conversion.png"></p>
<p><strong>图 3-20 字符串和字节数组的转换</strong></p>
<p>字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的，无论从哪种类型转换到另一种都需要对其中的内容进行拷贝，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>字符串是 Go 语言中相对来说比较简单的一种数据结构，我们在这一节中详细分析了字符串与 <code>[]byte</code> 类型的关系，从词法分析阶段理解字符串是如何被解析的，作为只读的数据类型，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://go101.org/article/string.html" target="_blank" rel="external nofollow noopener noreferrer">Strings in Go</a></li>
<li><a href="https://blog.golang.org/strings" target="_blank" rel="external nofollow noopener noreferrer">Strings, bytes, runes and characters in Go</a></li>
<li><a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="external nofollow noopener noreferrer">UTF-8 · Wikipedia</a></li>
<li><a href="https://stackoverflow.com/questions/29255746/how-encode-rune-into-byte-using-utf8-in-golang" target="_blank" rel="external nofollow noopener noreferrer">How encode []rune into []byte using utf8 in golang?</a></li>
<li><a href="https://golang.org/ref/spec#Conversions_to_and_from_a_string_type" target="_blank" rel="external nofollow noopener noreferrer">Conversions to and from a string type</a></li>
<li><a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="external nofollow noopener noreferrer">十分钟搞清字符集和字符编码</a></li>
</ul>
<hr>
<ol>
<li>火焰图是一种分析程序性能的手段，Flame Graphs <a href="http://www.brendangregg.com/flamegraphs.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.brendangregg.com/flamegraphs.html</a> <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/#fnref:1" target="_blank" rel="external nofollow noopener noreferrer">↩︎</a></li>
</ol>
<hr>
<p>在Go里面，字符串实际上是类型为byte的只读切片。</p>
<p>一个字符串包含了任意个byte。它并不限定Unicode，UTF-8或者任何其他预定义的编码。在内容上，它完全等价于一个类型为byte的切片。</p>
<p>下面是一个字符串变量，它使用\xNN这样的形式来表示一些特殊的byte。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sample = <span class="string">"\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98"</span></span><br><span class="line">fmt.Println(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ��=� ⌘  </span></span><br><span class="line"><span class="comment">// 这个结果和程序执行的环境有关</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="built_in">len</span>(sample); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%x "</span>, sample[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bd b2 3d bc 20 e2 8c 98</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bdb23dbc20e28c98</span></span><br><span class="line">fmt.Printf(<span class="string">"% x\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bd b2 3d bc 20 e2 8c 98</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// \xbd\xb2=\xbc ⌘</span></span><br><span class="line">fmt.Printf(<span class="string">"%+q\n"</span>, sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">// "\xbd\xb2=\xbc \u2318"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> placeOfInterest = <span class="string">`⌘`</span></span><br><span class="line">    fmt.Printf(<span class="string">"plain string: "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%s"</span>, placeOfInterest)</span><br><span class="line">    fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"quoted string: "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+q"</span>, placeOfInterest)</span><br><span class="line">    fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"hex bytes: "</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(placeOfInterest); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%x "</span>, placeOfInterest[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain string: ⌘</span></span><br><span class="line"><span class="comment">// quoted string: "\u2318"</span></span><br><span class="line"><span class="comment">// hex bytes: e2 8c 98</span></span><br><span class="line"><span class="keyword">const</span> nihongo = <span class="string">"日本語"</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> nihongo &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// U+65E5 '日' starts at byte position 0</span></span><br><span class="line"><span class="comment">// U+672C '本' starts at byte position 3</span></span><br><span class="line"><span class="comment">// U+8A9E '語' starts at byte position 6</span></span><br><span class="line"></span><br><span class="line">s = u<span class="string">"你好，中国"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))   # <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])     # 打印<span class="string">'好'</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"你好，中国"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))   # <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])     # 打印的不是<span class="string">'好'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"hello，中国"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    r[<span class="number">6</span>] = <span class="string">'美'</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(r))</span><br><span class="line"></span><br><span class="line">    e := <span class="keyword">string</span>(r)</span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 14</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// hello，美国</span></span><br></pre></td></tr></table></figure>
<p>关于Unicode，UTF-8和多语言文本处理，还有很多可以聊的。现在，我们希望您已经更好地了解Go字符串，尽管它们可能包含任意字节，但UTF-8是其设计的核心。</p>
<p>回答文章刚开始时提出的问题：字符串是由字节构建的，所以索引它们返回字节，而不是字符。字符串甚至可能不包含字符。事实上，“字符”的定义是不明确的，尝试通过定义字符串由字符组成来解决歧义是一个错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上面的例子也可以看到，需要统计中文字符串长度时，也需要转换成对应的rune数组</p>
<p>因此必须先将字符串转换成字节数组(或者rune数组，对于中文等)，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式。</p>
<p>因为Go 语言中的字符串是不可变的，也就是说 str[index] 这样的表达式是不可以被放在等号左侧的。如果尝试运行 str[i] = ‘D’会得到错误：cannot assign to str[i]。</p>
<p>字符串的本质就是一个字节数组。在Go 语言里面字符串和字节数组可以相互进行显式转换，这一性质通常被用来“修改”字符串的内容。</p>
<p>同样我们知道string[index]获取的是字符byte,就无法像Python中通过加u前缀之后直接索引，在Go中需要将字符串转换成rune数组，runne数组中就可以通过数组下标获取一个汉字所标识的Unicode码，再将Unicode码按创建成字符串即可。</p>
<p>分析Python代码，我们可以看到，字符串前面加了u标识符，表示按照unicode方式索引，否则默认情况下按照索引得到的是字节索引(unicode下面中文用三个字节表示)。</p>
<p>编码过程中避免不了中文字符，那我们该如何提取一个中文呢？ 在Python中，我们有：</p>
<h2 id="中文字符相关"><a href="#中文字符相关" class="headerlink" title="中文字符相关"></a>中文字符相关</h2><p>下面是一个使用<code>%#U</code>格式化的例子，它显示了代码点的Unicode值及其打印的表现形式。</p>
<p>而一个range循环会在每次迭代时，解码一个UTF-8编码的符文。每次循环时，循环的索引是当前文字的起始位置，以字节为单位，代码点是它的值。</p>
<p>除了Go源码是UTF-8外，Go只提供一种方法特殊处理UTF-8，那就是在字符串上使用for range循环。我们已经知道使用for循环会发生什么了。</p>
<h2 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h2><ul>
<li>Go源码总是UTF-8</li>
<li>一个字符串包含任意个byte</li>
<li>字符串常量如果缺少字节级转义，将始终保持UTF-8序列。</li>
<li>Unicode的代码点在Go语言中被称为rune</li>
<li>Go不保证字符串中的字符是规范化的。</li>
</ul>
<p>总结一些前面的内容：</p>
<p>Go语言将rune定义为int32类型的别名，因此在使用一个整型值表达一个“代码点”时，代码更加清晰。此外，一个你可能认为是字符常数在Go中是符文常数。’⌘’的类型和值分别是rune和0x2318。</p>
<p>“代码点”这样的说法有点绕口，所以Go语言介绍了一个较短的术语概念：rune，符文。该术语出现字库和源代码中，和“代码点”表达的意思完全相同。还有一个有趣的补充。</p>
<p>因此，计算中的字符概念是模糊的，至少是混乱的，所以我们需要谨慎地使用它。有规范化的技术来保证字符和代码点的映射，不过这个领域和本文讨论的内容相去甚远。</p>
<p>举一个更普遍的例子，Unicode代码点U+0061表示小写拉丁字母’A’：a。但是小写的重音字母’A’: à怎么表示呢？这是一个字符，它可以用代码点U+00E0表示，但也有其它表示。例如，可以“组合”严重重音代码点U+0300，并将其附加到小写字母a，U+0061，以创建字符à。通常情况下，字符可以由多个不同的代码点序列表示，由此可以用不同的UTF-8字节序列表示。</p>
<p>我们一直非常小心地使用“字节”和“字符”这样说法。这部分是因为字符串中保存了字节，还有部分是因为“字符”的概念有点难以定义。Unicode标准使用术语“代码点”来用单个值表示一个字符。比如具有16进制值2318的代码点，U+2318表示符号⌘。</p>
<h2 id="字节点，字符和rune"><a href="#字节点，字符和rune" class="headerlink" title="字节点，字符和rune"></a>字节点，字符和rune</h2><p>总而言之，字符串可以包含任意字节，但是当从字符串文字构造时，这些字节（几乎总是）是UTF-8。</p>
<p>有些人认为Go字符串总是UTF-8，但是不是这样：只有字符串字面量是UTF-8。正如上面所示，字符串值可以包含任意字节，只要没有字节级转义，字符串文字总是包含UTF-8文本。</p>
<p>简单来说，Go源码是UTF-8，因此字符串文字的源代码是UTF-8文本。如果该字符串文字不包含转义序列，构造的字符串将精确保存引号之间的源文本。因此，通过定义和构造，原始字符串将总是包含其内容的有效UTF-8表示。类似的，除非它包含类似上面例子中的UTF-8拆分转义，否则常规字符串字面值也将始终包含有效的UTF-8。</p>
<p>Go语言中的源代码定义为UTF-8文本，不允许其他的表示。也就是说，在代码中写下字符<code>⌘</code>时，用于创建程序的文本编辑器将符号⌘的UTF-8编码放入源文本中。当打印16进制字节时，我们只是将文件中的数据打印出来。</p>
<p>上面的例子告诉我们，Unicode字符值U+2318，名胜古迹符号”⌘”的字节表示为”e2 8c 98”，这些字节是16进制值”2318”的UTF-8编码。</p>
<p>下面的程序用三种不同的方式打印一个字符串常量，一次作为纯字符串，一次作为只有ASCII的字符串，一次作为16进制的字节。为了避免混淆，创建一个“原始字符串”，用反括号括起来，因此它只包含文本。</p>
<p>正如我们看到的，索引一个字符串返回的是byte，而不是字符：一个字符串就是一堆字节。这意味着，当我们将字符存储在字符串中时，实际存储的是这个字符的字节。来看一个例子。</p>
<h2 id="UTF-8和字符串"><a href="#UTF-8和字符串" class="headerlink" title="UTF-8和字符串"></a>UTF-8和字符串</h2><p>这些打印的小技巧在调试字符串内容的时候很有用，并且会方便下面的讨论。值得注意的是，上面的小技巧对于byte的切片一样适用。</p>
<p>如果不熟悉字符串中奇怪的字符，可以在打印的时候使用”+q”标识，这个标识采用UTF-8编码，它不仅会转义不可打印的字节序列，还会转义非ASCII码的字节。下面的代码将字符串中非ASCII数据对应的Unicode值打印出来。字符串中的瑞典字符作为Unicode字符，打印出来带有\u的转义符。</p>
<p>仔细观察，在一堆乱码中我们可以看到一个’=’号和一个空格符号，最后面是瑞典表示“名胜古迹”的符号，这个符号的Unicode值为U+2318，UTF-8编码为”e28c98”。</p>
<p>还有一些小技巧。使用q标识，可以将字符串中任何不可打印的字节序列转义。</p>
<p>还有一个打印的小技巧。</p>
<p>下面一种更简单的打印方式。</p>
<p>使用for循环遍历所有的字节。</p>
<p>要了解这个字符串究竟是什么，我们需要把它分开来检查一下。正如上面提到的，索引一个字符串，得到的是byte，而不是字符。</p>
<p>在上面的例子中，有一些byte并不是ASCII码，甚至也不是UTF-8编码，直接打印出来会出现乱码</p>
<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2>]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>数据结构</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Project Ocean</title>
    <url>/posts/f7bd8265/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。</p>
<p>然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。</p>
<a id="more"></a>
<h2 id="雄心勃勃的计划"><a href="#雄心勃勃的计划" class="headerlink" title="雄心勃勃的计划"></a>雄心勃勃的计划</h2><p>从工程师的角度来说，这个计划毋庸置疑是一个雄心勃勃的伟大的计划。如果这件事情做成了，这将是留给人类的一个伟大礼物。2000年后出版的图书是可以直接电子化的，问题在于将之前存在的纸质的图书电子化。人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。</p>
<p>然而，这么多的知识中，很大的一部分都深藏在世界上各大图书馆深深的房间中，很少有人能够访问。设想一下，如果这些积累了千年的知识电子化后，人们通过浏览器就可以搜索到对应的知识，这将有多么的大的裨益。</p>
<h2 id="技术的问题"><a href="#技术的问题" class="headerlink" title="技术的问题"></a>技术的问题</h2><ul>
<li>首先我们需要知道，有多少本书需要电子化。在2010年8月，也就是10年前，谷歌在博客中发了一条消息，说全世界总共有<code>129864880</code>册图书。这里主要是英文图书，如果算上其他文字的，还是在亿这个量级。</li>
<li>第二个问题，如何电子化。Google给的方法是扫描，他们研发了一套专门的扫描系统，每台仪器一小时可以数字化1000页左右的图书。</li>
</ul>
<blockquote>
<p>待扫描的书会被放在一个特别设计的自动支架上，支架可以适应不同的书脊，并且将图书固定。仪器上方有一排灯，还有价值至少1000美元的光学器材，包括四个摄像头，两个分别照着摊开的书的左右两半，还有一个负责确定扫描范围的光学雷达，它会在图书表面生成一层激光网格，从而捕捉到纸页的曲度。操作员负责手动翻页，因为也没有机器能比得上人手的快捷和轻柔了，然后脚踩踏板来触发相机进行拍照，一系列动作仿佛是在弹一架奇怪的钢琴。</p>
</blockquote>
<ul>
<li>是的，这个系统还是需要人来翻页的，因为也没有机器能比得上人手的快捷和轻柔了。</li>
<li>第三个问题，扫描后如何将这些扫描的照片转化为文字，识别书籍中的插图和图表、提取页码、把脚注转化为引用、将所有的书籍形成网络，形成一个知识库。这个就更多的是OCR和NLP等研究的领域。</li>
</ul>
<p>其实，Google并不是第一个产生这个想法，密歇根大学早就开始了其700万册图书馆藏数字化的计划。按照他们的计划，700万册图书需要1000年，而Google告诉他们，同样的事情，他们只需要六年。</p>
<blockquote>
<p>Google给密歇根大学图书馆提议：图书馆将所有的书借给谷歌，谷歌来替对方完成全部的扫描。最后你能得到你的全部馆藏的电子版，而谷歌将获得海量的还不曾被人问津的数据资源。布林如此描述谷歌对图书馆藏的渴望，“人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。”试想如果所有被尘封在纸页间的知识能够进入搜索引擎？</p>
<p>早在2004年之前，谷歌就开始了扫描工作。之后，谷歌和密歇根大学、哈佛、斯坦福、牛津、纽约公共图书馆和许多其他图书馆系统都订立了合约，并且以超过佩吉预言的速度，在十年多一点的时间里扫描了大约<strong>2500万册图书</strong>。图书扫描工作花掉了谷歌大约4亿美元。这项工作不仅仅依靠技术，还依靠强大的物流支持。</p>
</blockquote>
<ul>
<li>因为有的图书比较古老，在扫描过程中可能会出现错误。谷歌提出了一个机智的<a href="https://en.wikipedia.org/wiki/ReCAPTCHA" target="_blank" rel="external nofollow noopener noreferrer">ReCAPTCHA</a>计划用于解决在扫描中发现的错误。其基本思路是，为了验证人类所输入的文字是正确的，而不是随意输入，有两个字会被显示出来；一个是光学文字识别软件无法辨别的字，另一个是一个已经知道正确答案的字。如果用户正确的回答出已知正确答案的字，那么就假设所输入的另一个光学识别软件无法识别的字是认真的查看后被输入而非随便输入。</li>
</ul>
<h2 id="人的问题"><a href="#人的问题" class="headerlink" title="人的问题"></a>人的问题</h2><p>经过10年的时间，Google已经扫描了2500万册的图书，这是他们之前预计的图书总量五分之一。然而，在这个过程中，逐渐出现了很多反对的声音，并最终导致了这个项目的终止。</p>
<ul>
<li><p>美国作家协会和出版商对Google提出了集体诉讼，<strong>指控谷歌大规模侵犯知识产权</strong>，毕竟他们才有图书的版权。</p>
</li>
<li><p>Google则认为他们的目标是为了让用户能够检索图书，对于那些有版权的书，谷歌只能显示图书的片段，搜索结果中只能显示你搜索到的条目前后的几句话。Google认为他们只是制作了图书的副本，属于对于图书的合理使用。</p>
</li>
<li><p>事实上，这种版权问题早就发生在唱片、广播、有线电视等传统出版商身上，并不是版权所有者想要打压新技术，相反他们是想从新技术中分一杯羹。</p>
</li>
<li><p>随着诉讼的进展，出版商发现，他们实际上并不想阻止Google扫描绝版图书，甚至鼓励这种行为。</p>
</li>
<li><p>于是在这个过程中，Google，作家，出版商，图书馆四方进行了妥协，形成了「谷歌图书搜索修正协议」</p>
<ul>
<li>协议要求谷歌支付1亿2500万美元，其中包括一次性支付给它已经扫描过的图书的版权方的4500万美元（大约按每本书60美元计算），分别向出版商和作者支付的1550万美元和3000万美元诉讼费，以及用来创立图书版权登记处的3450万美元。</li>
<li>这项协议中也规定了到底应该如何展示和出售这些重获新生的绝版图书。按照协议，谷歌可以展示该书至多20%的部分来诱使用户购买，谷歌可以出售可下载的电子版，价格则由算法或者版权所有者来确定，由1.99美元到29.99美元不等。所有绝版书都会被打包存进一个“机构订阅数据库”，大学可以买下这个数据库，供全校师生免费搜索和阅读里面的全部书籍。</li>
<li>这个解决方案像是一个三赢——图书馆可以得到成千上万的图书，谷歌在图书搜索服务上的投资没有白费，作者和出版商能够从已经毫无商业价值的书中获得一笔新的收入来源。</li>
</ul>
</li>
<li><p>但是这个「谷歌图书搜索修正协议」引起了更大的争议</p>
<ul>
<li><p>学校的教授们担心发生在学术期刊市场的事情会在谷歌图书的数据库上重演，一旦图书馆和学校对订购谷歌的数据库产生依赖，订购价格将会像高利贷一样暴涨，最终涨的和各路学术期刊一样高</p>
</li>
<li><p>Google的竞争对手也觉得收到了这份协议的威胁。</p>
<ul>
<li><blockquote>
<p>微软公司就不出所料地声称，如果谷歌是唯一一个可以合法地检索绝版图书的搜索引擎，这无疑会强化谷歌在全世界作为搜索引擎霸主的地位。如果谷歌利用这些绝版图书来满足用户的长尾需求，这将是一个对于其他公司来说很不公平的竞争优势。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- &gt; 
  &gt;
  &gt; 亚马逊公司则担心这项协议会让谷歌建立一个无可匹敌的图书商店。亚马逊认为，任何想要出售绝版图书的人，都必须要一本一本地确认图书版权，这是最好的，但是集体诉讼的协议却让谷歌一次性获得了所有图书的授权。
</code></pre><p>  随着一轮又一轮的诉讼与协议，现在的状态是，Google基本尘封了这个计划。之前扫描的这2500万册图书以50PB的大小的文件存在于硬盘上。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.thepaper.cn/newsDetail_forward_1679335" target="_blank" rel="external nofollow noopener noreferrer">https://www.thepaper.cn/newsDetail_forward_1679335</a></li>
<li><a href="https://www.theatlantic.com/technology/archive/2017/04/the-tragedy-of-google-books/523320/" target="_blank" rel="external nofollow noopener noreferrer">Torching the Modern-Day Library of Alexandria</a></li>
<li>Blow Your Mind</li>
</ul>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>图书</tag>
      </tags>
  </entry>
  <entry>
    <title>【下厨房】电饭锅焖鸡腿</title>
    <url>/posts/45418583/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。</p>
<a id="more"></a>
<h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><div class="table-container">
<table>
<thead>
<tr>
<th>原料</th>
<th>分量</th>
</tr>
</thead>
<tbody>
<tr>
<td>鸡腿</td>
<td>5只</td>
</tr>
<tr>
<td>洋葱</td>
<td>半只</td>
</tr>
<tr>
<td>姜</td>
<td>3片</td>
</tr>
<tr>
<td>水</td>
<td>3汤匙</td>
</tr>
</tbody>
</table>
</div>
<p>腌料</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配料</th>
<th>分量</th>
</tr>
</thead>
<tbody>
<tr>
<td>老抽</td>
<td>1汤匙</td>
</tr>
<tr>
<td>生抽</td>
<td>1汤匙</td>
</tr>
<tr>
<td>料酒</td>
<td>1汤匙</td>
</tr>
<tr>
<td>糖</td>
<td>2汤匙</td>
</tr>
<tr>
<td>芝麻香油</td>
<td>1茶匙</td>
</tr>
<tr>
<td>盐</td>
<td>1/4茶匙</td>
</tr>
<tr>
<td>胡椒粉</td>
<td>适量</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>汤匙：15mL，茶匙：5mL</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>鸡腿洗净切几刀，便于入味</li>
<li>腌料拌匀，研制入味，冷藏半天或者一夜</li>
<li>电饭锅底铺上洋葱丝、小葱、姜片，水</li>
<li>放入腌制好的鸡腿，倒入腌制的汁</li>
<li>铺均匀后按下煮饭按钮，40分钟</li>
<li>中间20分钟翻动一次</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>倒入腌鸡腿的汁后不用加水了，因为洋葱也会出很多的水</li>
</ul>
]]></content>
      <categories>
        <category>吃顿好的</category>
      </categories>
      <tags>
        <tag>下厨房</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】循环</title>
    <url>/posts/44c65087/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>循环是所有编程语言都有的控制结构，除了使用经典的「三段式」循环之外，Go 语言还引入了另一个关键字 range 帮助我们快速遍历<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/" target="_blank" rel="external nofollow noopener noreferrer">数组</a>、<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="external nofollow noopener noreferrer">切片</a>、<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/" target="_blank" rel="external nofollow noopener noreferrer">哈希表</a> 以及 <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/" target="_blank" rel="external nofollow noopener noreferrer">Channel</a> 等集合类型。本节将深入分析 Go 语言的两种不同循环，也就是经典的 for 循环和 for/range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理，</p>
<a id="more"></a>
<p>for 循环能够将代码中的数据和逻辑分离，让同一份代码能够多次复用处理同样的逻辑。我们先来看一下 Go 语言 for 循环对应的汇编代码，下面是一段经典的三段式循环的代码，我们将它编译成汇编指令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">98</span> args=<span class="number">0x0</span> locals=<span class="number">0x18</span></span><br><span class="line">	<span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)	TEXT	<span class="string">""</span>.main(SB), $<span class="number">24</span><span class="number">-0</span></span><br><span class="line">	...</span><br><span class="line">	<span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)	XORL	AX, AX                   ;; i := <span class="number">0</span></span><br><span class="line">	<span class="number">00031</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	JMP	<span class="number">75</span></span><br><span class="line">	<span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	AX, <span class="string">""</span>.i+<span class="number">8</span>(SP)</span><br><span class="line">	<span class="number">00038</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	CALL	runtime.printlock(SB)</span><br><span class="line">	<span class="number">00043</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	<span class="string">""</span>.i+<span class="number">8</span>(SP), AX</span><br><span class="line">	<span class="number">00048</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	AX, (SP)</span><br><span class="line">	<span class="number">00052</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	CALL	runtime.printint(SB)</span><br><span class="line">	<span class="number">00057</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	CALL	runtime.printnl(SB)</span><br><span class="line">	<span class="number">00062</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	CALL	runtime.printunlock(SB)</span><br><span class="line">	<span class="number">00067</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	<span class="string">""</span>.i+<span class="number">8</span>(SP), AX</span><br><span class="line">	<span class="number">00072</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	INCQ	AX                       ;; i++</span><br><span class="line">	<span class="number">00075</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	CMPQ	AX, $<span class="number">10</span>                  ;; 比较变量 i 和 <span class="number">10</span></span><br><span class="line">	<span class="number">00079</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	JLT	<span class="number">33</span>                           ;; 跳转到 <span class="number">33</span> 行如果 i &lt; <span class="number">10</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>我们将上述汇编指令的执行过程分成三个部分进行分析：</p>
<ol>
<li><p>0029 ~ 0031 行负责循环的初始化；</p>
<ol>
<li>对寄存器 <code>AX</code> 中的变量 <code>i</code> 进行初始化并执行 <code>JMP 75</code> 指令跳转到 0075 行；</li>
</ol>
</li>
<li><p>0075 ~ 0079 行负责检查循环的终止条件，将寄存器中存储的数据</p>
</li>
</ol>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">i</span></span><br></pre></td></tr></table></figure>
<p>   与 10 比较；</p>
<ol>
<li><code>JLT 33</code> 命令会在变量的值小于 10 时跳转到 0033 行执行循环主体；</li>
<li><code>JLT 33</code> 命令会在变量的值大于 10 时跳出循环体执行下面的代码；</li>
</ol>
<ol>
<li><p>0033 ~ 0072 行是循环内部的语句；</p>
<ol>
<li>通过多个汇编指令打印变量中的内容；</li>
<li><code>INCQ AX</code> 指令会将变量加一，然后再与 10 进行比较，回到第二步；</li>
</ol>
</li>
</ol>
<p>for/range 循环经过优化的汇编代码有着完全相同的结构。无论是变量的初始化、循环体的执行还是最后的条件判断都是完全一样的，所以这里也就不展开分析对应的汇编指令了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在汇编语言中，无论是经典的 for 循环还是 for/range 循环都会使用 <code>JMP</code> 以及相关的命令跳回循环体的开始位置来多次执行代码的逻辑。从不同循环具有相同的汇编代码可以猜到，使用 for /range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环，后面的分析会印证这一点。</p>
<h2 id="5-1-1-现象"><a href="#5-1-1-现象" class="headerlink" title="5.1.1 现象"></a>5.1.1 现象</h2><p>在深入语言的源代码中了解两种不同循环的实现之前，我们可以先来看一下使用 <code>for</code> 和 <code>range</code> 会遇到的一些现象和问题，我们可以带着这些现象和问题去源代码中寻找答案，这样能更高效地理解实现。</p>
<h3 id="循环永动机"><a href="#循环永动机" class="headerlink" title="循环永动机"></a>循环永动机</h3><p>如果我们在遍历数组的同时修改数组的元素，能否得到一个永远都不会停止的循环呢？你可以自己尝试运行下面的代码来得到结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		arr = <span class="built_in">append</span>(arr, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>上述代码的输出意味着循环只遍历了原始切片中的三个元素，我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。</p>
<h3 id="神奇的指针"><a href="#神奇的指针" class="headerlink" title="神奇的指针"></a>神奇的指针</h3><p>第二个例子是使用 Go 语言经常会犯的错误<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。当我们在遍历一个数组时，如果获取 <code>range</code> 返回变量的地址并保存到另一个数组或者哈希时，就会遇到令人困惑的现象：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>上述代码最终会输出三个连续的 <code>3</code>，这个问题比较常见，一些有经验的开发者不经意也会犯这种错误，正确的做法应该是使用 <code>&amp;arr[i]</code> 替代 <code>&amp;v</code>，我们会在下面分析这一现象背后的原因。</p>
<h3 id="遍历清空数组"><a href="#遍历清空数组" class="headerlink" title="遍历清空数组"></a>遍历清空数组</h3><p>当我们想要在 Go 语言中清空一个切片或者哈希表时，我们一般都会使用以下的方法将切片中的元素置零，但是依次去遍历切片和哈希表看起来是非常耗费性能的事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		arr[i] = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为数组、切片和哈希表占用的内存空间都是连续的，所以最快的方法是直接清空这片内存中的内容，当我们编译上述代码时会得到以下的汇编指令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">93</span> args=<span class="number">0x0</span> locals=<span class="number">0x30</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)	TEXT	<span class="string">""</span>.main(SB), $<span class="number">48</span><span class="number">-0</span></span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x001d</span> <span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	<span class="string">""</span>.statictmp_0(SB), AX</span><br><span class="line">	<span class="number">0x0024</span> <span class="number">00036</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	AX, <span class="string">""</span>..autotmp_3+<span class="number">16</span>(SP)</span><br><span class="line">	<span class="number">0x0029</span> <span class="number">00041</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVUPS	<span class="string">""</span>.statictmp_0+<span class="number">8</span>(SB), X0</span><br><span class="line">	<span class="number">0x0030</span> <span class="number">00048</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVUPS	X0, <span class="string">""</span>..autotmp_3+<span class="number">24</span>(SP)</span><br><span class="line">	<span class="number">0x0035</span> <span class="number">00053</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	PCDATA	$<span class="number">2</span>, $<span class="number">1</span></span><br><span class="line">	<span class="number">0x0035</span> <span class="number">00053</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	LEAQ	<span class="string">""</span>..autotmp_3+<span class="number">16</span>(SP), AX</span><br><span class="line">	<span class="number">0x003a</span> <span class="number">00058</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	PCDATA	$<span class="number">2</span>, $<span class="number">0</span></span><br><span class="line">	<span class="number">0x003a</span> <span class="number">00058</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	AX, (SP)</span><br><span class="line">	<span class="number">0x003e</span> <span class="number">00062</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	$<span class="number">24</span>, <span class="number">8</span>(SP)</span><br><span class="line">	<span class="number">0x0047</span> <span class="number">00071</span> (main.<span class="keyword">go</span>:<span class="number">5</span>)	CALL	runtime.memclrNoHeapPointers(SB)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>从生成的汇编代码我们可以看出，编译器会直接使用 <a href="https://github.com/golang/go/blob/05c02444eb2d8b8d3ecd949c4308d8e2323ae087/src/runtime/memclr_386.s#L12-L16" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.memclrNoHeapPointers</code></a> 清空切片中的数据，这也是我们在下面的小节会介绍的内容。</p>
<h3 id="随机遍历"><a href="#随机遍历" class="headerlink" title="随机遍历"></a>随机遍历</h3><p>当我们在 Go 语言中使用 <code>range</code> 遍历哈希表时，往往都会使用如下的代码结构，但是这段代码在每次运行时都会打印出不同的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">"1"</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="string">"2"</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="string">"3"</span>: <span class="number">3</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">		<span class="built_in">println</span>(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两次运行上述代码可能会得到不同的结果，第一次会打印 <code>2 3 1</code>，第二次会打印 <code>1 2 3</code>，如果我们运行的次数足够多，最后会得到几种不同的遍历顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line"></span><br><span class="line">$ go run main.go</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>这是 Go 语言故意的设计，它在运行时为哈希表的遍历引入不确定性，也是告诉所有使用 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历，我们在下面的小节会介绍在遍历的过程是如何引入不确定性的。</p>
<h2 id="5-1-2-经典循环"><a href="#5-1-2-经典循环" class="headerlink" title="5.1.2 经典循环"></a>5.1.2 经典循环</h2><p>Go 语言中的经典循环在编译器看来是一个 <code>OFOR</code> 类型的节点，这个节点由以下四个部分组成：</p>
<ol>
<li>初始化循环的 <code>Ninit</code>；</li>
<li>循环的继续条件 <code>Left</code>；</li>
<li>循环体结束时执行的 <code>Right</code>；</li>
<li>循环体 <code>NBody</code>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> Ninit; Left; Right &#123;</span><br><span class="line">    NBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生成 SSA 中间代码的阶段，<a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023-L1502" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.stmt</code></a> 方法在发现传入的节点类型是 <code>OFOR</code> 时就会执行以下的代码块，这段代码的会将循环中的代码分成不同的块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OFOR, OFORUNTIL:</span><br><span class="line">		bCond, bBody, bIncr, bEnd := ...</span><br><span class="line">		</span><br><span class="line">		b := s.endBlock()</span><br><span class="line">		b.AddEdgeTo(bCond)</span><br><span class="line">		s.startBlock(bCond)</span><br><span class="line">		s.condBranch(n.Left, bBody, bEnd, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		s.startBlock(bBody)</span><br><span class="line">		s.stmtList(n.Nbody)</span><br><span class="line"></span><br><span class="line">		b.AddEdgeTo(bIncr)</span><br><span class="line">		s.startBlock(bIncr)</span><br><span class="line">		s.stmt(n.Right)</span><br><span class="line">		b.AddEdgeTo(bCond)</span><br><span class="line">		s.startBlock(bEnd)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个常见的 for 循环代码会被 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023-L1502" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.stmt</code></a> 方法转换成下面的控制结构，该结构中包含了 4 个不同的块，这些代码块之间的连接就表示汇编语言中的跳转关系，与我们理解的 for 循环控制结构其实没有太多的差别。</p>
<p><img alt="golang-for-loop-ssa" data-src="https://img.draveness.me/2020-01-17-15792766877627-golang-for-loop-ssa.png"></p>
<p><strong>图 5-1 Go 语言循环生成的 SSA 代码</strong></p>
<p><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/" target="_blank" rel="external nofollow noopener noreferrer">机器码生成</a>阶段会将这些代码块转换成机器码，以及指定 CPU 架构上运行的机器语言，就是我们在前面编译得到的汇编指令。</p>
<h2 id="5-1-3-范围循环"><a href="#5-1-3-范围循环" class="headerlink" title="5.1.3 范围循环"></a>5.1.3 范围循环</h2><p>与简单的经典循环相比，范围循环在 Go 语言中更常见、实现也更复杂。这种循环同时使用 for 和 range 两个关键字，编译器会在编译期间将所有 for/range 循环变成的经典循环。从编译器的视角来看，就是将 <code>ORANGE</code> 类型的节点转换成 <code>OFOR</code> 节点:</p>
<p><img alt="Golang-For-Range-Loop" data-src="https://img.draveness.me/2020-01-17-15792766926441-Golang-For-Range-Loop.png"></p>
<p><strong>图 5-2 范围循环、普通循环和 SSA</strong></p>
<p>节点类型的转换过程都发生在 SSA 中间代码生成阶段，所有的 for/range 循环都会被 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L155-L456" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkrange</code></a> 函数转换成不包含复杂结构、只包含基本表达式的语句。接下来，我们按照循环遍历的元素类型依次介绍遍历数组和切片、哈希表、字符串以及管道时的过程。</p>
<h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>对于数组和切片来说，Go 语言有三种不同的遍历方式，这三种不同的遍历方式分别对应着代码中的不同条件，它们会在 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L155-L456" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkrange</code></a> 函数中转换成不同的控制逻辑，我们将该函数的相关逻辑分成几个部分进行分析：</p>
<ol>
<li>分析遍历数组和切片清空元素的情况；</li>
<li>分析使用 <code>for range a {}</code> 遍历数组和切片，不关心索引和数据的情况；</li>
<li>分析使用 <code>for i := range a {}</code> 遍历数组和切片，只关心索引的情况；</li>
<li>分析使用 <code>for i, elem := range a {}</code> 遍历数组和切片，关心索引和数据的情况；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkrange</span><span class="params">(n *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">	<span class="keyword">case</span> TARRAY, TSLICE:</span><br><span class="line">		<span class="keyword">if</span> arrayClear(n, v1, v2, a) &#123;</span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L532-L610" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.arrayClear</code></a> 是一个非常有趣的优化，这个函数会优化 Go 语言遍历数组或者切片并删除全部元素的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// original</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">	a[i] = zero</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optimized</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="number">0</span> &#123;</span><br><span class="line">	hp = &amp;a[<span class="number">0</span>]</span><br><span class="line">	hn = <span class="built_in">len</span>(a)*sizeof(elem(a))</span><br><span class="line">	memclrNoHeapPointers(hp, hn)</span><br><span class="line">	i = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于依次清除数组或者切片中的数据，Go 语言会直接使用 <a href="https://github.com/golang/go/blob/05c02444eb2d8b8d3ecd949c4308d8e2323ae087/src/runtime/memclr_386.s#L12-L16" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.memclrNoHeapPointers</code></a> 或者 <a href="https://github.com/golang/go/blob/db16de920370892b0241d3fa0617dddff2417a4d/src/runtime/mbarrier.go#L345-L348" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.memclrHasPointers</code></a> 函数直接清除目标数组对应内存空间中的数据，并在执行完成后更新用于遍历数组的索引，这也印证了我们在遍历清空数组一节中观察到的现象。</p>
<p>处理了这种特殊的情况之后，我们就可以继续回到 <code>ORANGE</code> 节点的处理过程了。这里会设置 for 循环的 <code>Left</code> 和 <code>Right</code> 字段，也就是终止条件和循环体每次执行结束后运行的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line"></span><br><span class="line">hv1 := temp(types.Types[TINT])</span><br><span class="line">hn := temp(types.Types[TINT])</span><br><span class="line"></span><br><span class="line">init = <span class="built_in">append</span>(init, nod(OAS, hv1, <span class="literal">nil</span>))</span><br><span class="line">init = <span class="built_in">append</span>(init, nod(OAS, hn, nod(OLEN, ha, <span class="literal">nil</span>)))</span><br><span class="line"></span><br><span class="line">n.Left = nod(OLT, hv1, hn)</span><br><span class="line">n.Right = nod(OAS, hv1, nod(OADD, hv1, nodintconst(<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v1 == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果原始的循环是 <code>for range a {}</code>，那么就满足 <code>v1 == nil</code> 的条件，即循环不关心数组的索引和数据，它会被编译器转换成如下所示的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1 := <span class="number">0</span></span><br><span class="line">hn := <span class="built_in">len</span>(ha)</span><br><span class="line">v1 := hv1</span><br><span class="line"><span class="keyword">for</span> ; hv1 &lt; hn; hv1++ &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 <code>ORANGE</code> 结构在编译期间被转换的最简单形式，由于原始代码不需要获取数组的索引和元素，只需要使用数组或者切片的数量执行对应次数的循环，所以会生成一个最简单的 for 循环。</p>
<p>如果我们在遍历数组时需要使用索引 <code>for i := range a {}</code>，那么编译器会继续会执行下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v2 == <span class="literal">nil</span> &#123;</span><br><span class="line">	body = []*Node&#123;nod(OAS, v1, hv1)&#125;</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>v2 == nil</code> 意味着调用方不关心数组的元素，只关心遍历数组使用的索引。它会将 <code>for i := range a {}</code> 转换成如下所示的逻辑，与第一种循环相比，这种循环在循环体中添加了 <code>v1 := hv1</code> 语句，传递遍历数组时的索引：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1 := <span class="number">0</span></span><br><span class="line">hn := <span class="built_in">len</span>(ha)</span><br><span class="line">v1 := hv1</span><br><span class="line"><span class="keyword">for</span> ; hv1 &lt; hn; hv1++ &#123;</span><br><span class="line">    v1 := hv1</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两种情况虽然也是使用 range 经常遇到的情况，但是同时去遍历索引和元素也很常见。处理这种情况会使用下面这段的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">		tmp := nod(OINDEX, ha, hv1)</span><br><span class="line">		tmp.SetBounded(<span class="literal">true</span>)</span><br><span class="line">		a := nod(OAS2, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">		a.List.Set2(v1, v2)</span><br><span class="line">		a.Rlist.Set2(hv1, tmp)</span><br><span class="line">		body = []*Node&#123;a&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n.Ninit.Append(init...)</span><br><span class="line">	n.Nbody.Prepend(body...)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码处理的就是遍历数组和切片时，同时关心索引和切片的情况。它不仅会在循环体中插入更新索引的语句，还会插入赋值操作让循环体内部的代码能够访问数组中的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1 := <span class="number">0</span></span><br><span class="line">hn := <span class="built_in">len</span>(ha)</span><br><span class="line">v1 := hv1</span><br><span class="line"><span class="keyword">for</span> ; hv1 &lt; hn; hv1++ &#123;</span><br><span class="line">    tmp := ha[hv1]</span><br><span class="line">    v1, v2 := hv1, tmp</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新的变量 <code>ha</code>，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量了。</p>
<p>而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 <code>v2</code> 变量存储切片中的元素，<strong>循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，在赋值时也发生了拷贝</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在循环中获取返回变量的地址都完全相同，所以会发生神奇的指针一节中的现象。所以如果我们想要访问数组中元素所在的地址，不应该直接获取 range 返回的变量地址 <code>&amp;v2</code>，而应该使用 <code>&amp;a[index]</code> 这种形式。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在遍历哈希表时，编译器会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L797-L844" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiterinit</code></a> 和 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L846-L970" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiternext</code></a> 两个运行时函数重写原始的 for/range 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hit := hiter(n.Type)</span><br><span class="line">th := hit.Type</span><br><span class="line">mapiterinit(typename(t), ha, &amp;hit)</span><br><span class="line"><span class="keyword">for</span> ; hit.key != <span class="literal">nil</span>; mapiternext(&amp;hit) &#123;</span><br><span class="line">    key := *hit.key</span><br><span class="line">    val := *hit.val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是 <code>for key, val := range hash {}</code> 生成的，在 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/cmd/compile/internal/gc/range.go#L155-L456" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkrange</code></a> 函数处理 <code>TMAP</code> 节点时会根据接受 range 返回值的数量在循环体中插入需要的赋值语句：</p>
<p><img alt="golang-range-map" data-src="https://img.draveness.me/2020-01-17-15792766877639-golang-range-map.png"></p>
<p><strong>图 5-3 不同方式遍历哈希插入的语句</strong></p>
<p>这三种不同的情况会分别向循环体插入不同的赋值语句。遍历哈希表时会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L797-L844" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiterinit</code></a> 函数初始化遍历开始的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">	it.t = t</span><br><span class="line">	it.h = h</span><br><span class="line">	it.B = h.B</span><br><span class="line">	it.buckets = h.buckets</span><br><span class="line"></span><br><span class="line">	r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">	it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line">	it.bucket = it.startBucket</span><br><span class="line">	mapiternext(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会初始化 <code>hiter</code> 结构体中的字段，并通过 <a href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L99-L111" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fastrand</code></a> 生成一个随机数帮助我们随机选择一个桶开始遍历。Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。</p>
<p>遍历哈希会使用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L846-L970" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiternext</code></a> 函数，我们在这里简化了很多逻辑，省去了一些边界条件以及哈希表扩容时的兼容操作，这里只需要关注处理遍历逻辑的核心代码，我们会将该函数分成桶的选择和桶内元素的遍历两部分进行分析，首先是桶的选择过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">	h := it.h</span><br><span class="line">	t := it.t</span><br><span class="line">	bucket := it.bucket</span><br><span class="line">	b := it.bptr</span><br><span class="line">	i := it.i</span><br><span class="line">	alg := t.key.alg</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">			it.key = <span class="literal">nil</span></span><br><span class="line">			it.value = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		bucket++</span><br><span class="line">		<span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">			bucket = <span class="number">0</span></span><br><span class="line">			it.wrapped = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要有两个作用：</p>
<ol>
<li>在待遍历的桶为空时选择需要遍历的新桶；</li>
<li>在不存在待遍历的桶时返回 <code>(nil, nil)</code> 键值对并中止遍历过程；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L846-L970" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapiternext</code></a> 函数中第二段代码的主要作用就是从桶中找到下一个遍历的元素，在大多数情况下都会直接操作内存获取目标键值的内存地址，不过如果哈希表处于扩容期间就会调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L511-L552" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mapaccessK</code></a> 函数获取键值对：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">		offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">		k := add(unsafe.Pointer(b), dataOffset+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">		<span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">			!(t.reflexivekey() || alg.equal(k, k)) &#123;</span><br><span class="line">			it.key = k</span><br><span class="line">			it.value = v</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rk, rv := mapaccessK(t, h, k)</span><br><span class="line">			it.key = rk</span><br><span class="line">			it.value = rv</span><br><span class="line">		&#125;</span><br><span class="line">		it.bucket = bucket</span><br><span class="line">		it.i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	b = b.overflow(t)</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上述函数已经遍历了正常桶，就会通过 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L207-L209" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.bmap.overflow</code></a> 获取溢出桶依次进行遍历。</p>
<p><img alt="golang-range-map-and-buckets" data-src="https://img.draveness.me/2020-01-17-15792766877646-golang-range-map-and-buckets.png"></p>
<p><strong>图 5-4 哈希表的遍历过程</strong></p>
<p>简单总结一下哈希表遍历的顺序，首先会选出一个绿色的正常桶开始遍历，随后遍历对应的所有黄色溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 <code>rune</code>。我们在遍历字符串时拿到的值都是 <code>rune</code> 类型的变量，<code>for i, r := range s {}</code> 的结构都会被转换成如下所示的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := s</span><br><span class="line"><span class="keyword">for</span> hv1 := <span class="number">0</span>; hv1 &lt; <span class="built_in">len</span>(ha); &#123;</span><br><span class="line">    hv1t := hv1</span><br><span class="line">    hv2 := <span class="keyword">rune</span>(ha[hv1])</span><br><span class="line">    <span class="keyword">if</span> hv2 &lt; utf8.RuneSelf &#123;</span><br><span class="line">        hv1++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hv2, hv1 = decoderune(h1, hv1)</span><br><span class="line">    &#125;</span><br><span class="line">    v1, v2 = hv1t, hv2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的字符串一节中我们曾经介绍过字符串是一个只读的字节数组切片，所以范围循环在编译期间生成的框架与切片非常类似，只是细节有一些不同。</p>
<p>使用下标访问字符串中的元素时得到的就是字节，但是这段代码会将当前的字节转换成 <code>rune</code> 类型。如果当前的 <code>rune</code> 是 ASCII 的，那么只会占用一个字节长度，每次循环体运行之后只需要将索引加一，但是如果当前 <code>rune</code> 占用了多个字节就会使用 <a href="https://github.com/golang/go/blob/c6e84263865fa418b4d4a60f077d02c10a0fff23/src/runtime/utf8.go#L60-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.decoderune</code></a> 函数解码，具体的过程就不在这里详细介绍了。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>使用 range 遍历 Channel 也是比较常见的做法，一个形如 <code>for v := range ch {}</code> 的语句最终会被转换成如下的格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1, hb := &lt;-ha</span><br><span class="line"><span class="keyword">for</span> ; hb != <span class="literal">false</span>; hv1, hb = &lt;-ha &#123;</span><br><span class="line">    v1 := hv1</span><br><span class="line">    hv1 = <span class="literal">nil</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码可能与编译器生成的稍微有一些出入，但是结构和效果是完全相同的。该循环会使用 <code>&lt;-ch</code> 从管道中取出等待处理的值，这个操作会调用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L437-L440" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv2</code></a> 并阻塞当前的协程，当 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L437-L440" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv2</code></a> 返回时会根据布尔值 <code>hb</code> 判断当前的值是否存在，如果不存在就意味着当前的管道已经被关闭了，如果存在就会为 <code>v1</code> 赋值并清除 <code>hv1</code> 变量中的数据，然后会重新陷入阻塞等待新数据。</p>
<h2 id="5-1-4-小结"><a href="#5-1-4-小结" class="headerlink" title="5.1.4 小结"></a>5.1.4 小结</h2><p>这一节介绍的两个关键字 for 和 range 都是我们在学习和使用 Go 语言中无法绕开的，通过分析和研究它们的底层原理，让我们对实现细节有了更清楚的认识，包括 Go 语言遍历数组和切片时会复用变量、哈希表的随机遍历原理以及底层的一些优化，这都能帮助我们理解和使用 Go 语言。</p>
<hr>
<ol>
<li>CommonMistakes · Go <a href="https://github.com/golang/go/wiki/CommonMistakes" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/wiki/CommonMistakes</a> <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/#fnref:1" target="_blank" rel="external nofollow noopener noreferrer">↩︎</a></li>
</ol>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Function</title>
    <url>/posts/4e214fa9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>函数是 Go 语言中的一等公民，理解和掌握函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数的传递方法两个方面分别介绍函数的执行过程。</p>
<a id="more"></a>
<h2 id="调用惯例"><a href="#调用惯例" class="headerlink" title="调用惯例"></a>调用惯例</h2><p>无论是系统级编程语言 C 和 Go，还是脚本语言 Ruby 和 Python，这些编程语言在调用函数时往往都使用相同的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">somefunction(arg0, arg1)</span><br></pre></td></tr></table></figure>
<p>虽然它们调用函数的语法很相似，但是它们的调用惯例却可能大不相同。调用惯例是调用方和被调用方对于参数和返回值传递的约定，我们将在这里为各位读者分别介绍 C 和 Go 语言的调用惯例。</p>
<h3 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h3><p>我们先来研究 C 语言的调用惯例，使用 <a href="https://gcc.gnu.org/" target="_blank" rel="external nofollow noopener noreferrer">GCC</a><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a> 和 <a href="https://clang.llvm.org/" target="_blank" rel="external nofollow noopener noreferrer">Clang</a><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a> 编译器将 C 语言编译成汇编代码是分析它调用惯例的最好方法，从汇编语言中可以一窥函数调用的具体过程。</p>
<p>GCC 和 Clang 编译相同 C 语言代码可能会生成不同的汇编指令，不过生成的代码在结构上不会有太大的区别，所以对只想理解调用惯例的人来说没有太多影响。作者在本节中选择使用 GCC 编译器来编译 C 语言：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc --version</span><br><span class="line">gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>
<p>假设我们有以下的 C 语言代码，代码中只包含两个函数，其中一个是主函数 <code>main</code>，另一个是我们定义的函数 <code>my_function</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ch04/my_function.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = my_function(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>cc -S my_function.c</code> 命令将上述文件编译成如下所示的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">	movl	$<span class="number">2</span>, %esi  <span class="comment">// 设置第二个参数</span></span><br><span class="line">	movl	$<span class="number">1</span>, %edi  <span class="comment">// 设置第一个参数</span></span><br><span class="line">	call	my_function</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">my_function:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	movl	%edi, <span class="number">-4</span>(%rbp)    <span class="comment">// 取出第一个参数，放到栈上</span></span><br><span class="line">	movl	%esi, <span class="number">-8</span>(%rbp)    <span class="comment">// 取出第二个参数，放到栈上</span></span><br><span class="line">	movl	<span class="number">-8</span>(%rbp), %eax    <span class="comment">// eax = esi = 1</span></span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %edx    <span class="comment">// edx = edi = 2</span></span><br><span class="line">	addl	%edx, %eax        <span class="comment">// eax = eax + edx = 1 + 2 = 3</span></span><br><span class="line">	popq	%rbp</span><br></pre></td></tr></table></figure>
<p>我们按照 <code>my_function</code> 函数调用前、调用时以及调用后三个部分分析上述调用过程：</p>
<ul>
<li>在 <code>my_function</code> 调用之前，调用方 <code>main</code> 函数将 <code>my_function</code> 的两个参数分别存到 edi 和 esi 寄存器中；</li>
<li>在 <code>my_function</code> 执行时，它会将寄存器 edi 和 esi 中的数据存储到 eax 和 edx 两个寄存器中，随后通过汇编指令 <code>addl</code> 计算两个入参之和；</li>
<li>在 <code>my_function</code> 调用之后，使用寄存器 eax 传递返回值，<code>main</code> 函数将 <code>my_function</code> 的返回值存储到栈上的 <code>i</code> 变量中；</li>
</ul>
<p>当 <code>my_function</code> 函数的入参增加至八个，这时重新编译当前的程序可以会得到不同的汇编语言：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$<span class="number">16</span>, %rsp     <span class="comment">// 为参数传递申请 16 字节的栈空间</span></span><br><span class="line">	movl	$<span class="number">8</span>, <span class="number">8</span>(%rsp)   <span class="comment">// 传递第 8 个参数</span></span><br><span class="line">	movl	$<span class="number">7</span>, (%rsp)    <span class="comment">// 传递第 7 个参数</span></span><br><span class="line">	movl	$<span class="number">6</span>, %r9d</span><br><span class="line">	movl	$<span class="number">5</span>, %r8d</span><br><span class="line">	movl	$<span class="number">4</span>, %ecx</span><br><span class="line">	movl	$<span class="number">3</span>, %edx</span><br><span class="line">	movl	$<span class="number">2</span>, %esi</span><br><span class="line">	movl	$<span class="number">1</span>, %edi</span><br><span class="line">	call	my_function</span><br></pre></td></tr></table></figure>
<p><code>main</code> 函数调用 <code>my_function</code> 时，前六个参数是使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递的。寄存器的使用顺序也是调用惯例的一部分，函数的第一个参数一定会使用 edi 寄存器，第二个参数使用 esi 寄存器，以此类推。</p>
<p>最后的两个参数与前面的完全不同，调用方 <code>main</code> 函数通过传递这两个参数，图 4-1 展示了 <code>main</code> 函数在调用 <code>my_function</code> 前的栈信息：</p>
<p><img alt="c-function-call-stack" data-src="https://img.draveness.me/2019-01-20-c-function-call-stack.png"></p>
<p><strong>图 4-1 C 语言 main 函数的调用栈</strong></p>
<p>上图中 rbp 寄存器的作用是存储函数调用栈的基址指针，即属于 <code>main</code> 函数的栈空间的起始位置，而另一个寄存器 rsp 存储的是 <code>main</code> 函数调用栈结束的位置，这两个寄存器共同表示了一个函数的栈空间。</p>
<p>在调用 <code>my_function</code> 之前，<code>main</code> 函数通过 <code>subq $16, %rsp</code> 指令分配了 16 个字节的栈地址，随后将第六个以上的参数按照从右到左的顺序存入栈中，即第八个和第七个，余下的六个参数会通过寄存器传递，接下来运行的 <code>call my_function</code> 指令会调用 <code>my_function</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_function:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	movl	%edi, <span class="number">-4</span>(%rbp)    <span class="comment">// rbp-4 = edi = 1</span></span><br><span class="line">	movl	%esi, <span class="number">-8</span>(%rbp)    <span class="comment">// rbp-8 = esi = 2</span></span><br><span class="line">	...</span><br><span class="line">	movl	<span class="number">-8</span>(%rbp), %eax    <span class="comment">// eax = 2</span></span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %edx    <span class="comment">// edx = 1</span></span><br><span class="line">	addl	%eax, %edx        <span class="comment">// edx = eax + edx = 3</span></span><br><span class="line">	...</span><br><span class="line">	movl	<span class="number">16</span>(%rbp), %eax    <span class="comment">// eax = 7</span></span><br><span class="line">	addl	%eax, %edx        <span class="comment">// edx = eax + edx = 28</span></span><br><span class="line">	movl	<span class="number">24</span>(%rbp), %eax    <span class="comment">// eax = 8</span></span><br><span class="line">	addl	%edx, %eax        <span class="comment">// edx = eax + edx = 36</span></span><br><span class="line">	popq	%rbp</span><br></pre></td></tr></table></figure>
<p><code>my_function</code> 会先将寄存器中的全部数据转移到栈上，然后利用 eax 寄存器计算所有入参的和并返回结果。</p>
<p>我们可以将本节的发现和分析简单总结成 —— 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p>
<ul>
<li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li>
<li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li>
</ul>
<p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p>
<h3 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h3><p>分析了 C 语言函数的调用惯例之后，我们再来剖析一下 Go 语言中函数的调用惯例。我们以下面这个非常简单的代码片段为例简要分析一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b, a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myFunction(<span class="number">66</span>, <span class="number">77</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的 <code>myFunction</code> 函数接受两个整数并返回两个整数，<code>main</code> 函数在调用 <code>myFunction</code> 时将 66 和 77 两个参数传递到当前函数中，使用 <code>go tool compile -S -N -l main.go</code> 命令编译上述代码可以得到如下所示的汇编指令：</p>
<blockquote>
<p>注：如果编译时不使用 -N -l 参数，编译器会对汇编代码进行优化，编译结果会有较大差别。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>.main STEXT size=<span class="number">68</span> args=<span class="number">0x0</span> locals=<span class="number">0x28</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	MOVQ	(TLS), CX</span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	CMPQ	SP, <span class="number">16</span>(CX)</span><br><span class="line">	<span class="number">0x000d</span> <span class="number">00013</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	JLS	<span class="number">61</span></span><br><span class="line">	<span class="number">0x000f</span> <span class="number">00015</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	SUBQ	$<span class="number">40</span>, SP      <span class="comment">// 分配 40 字节栈空间</span></span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	MOVQ	BP, <span class="number">32</span>(SP)   <span class="comment">// 将基址指针存储到栈上</span></span><br><span class="line">	<span class="number">0x0018</span> <span class="number">00024</span> (main.<span class="keyword">go</span>:<span class="number">7</span>)	LEAQ	<span class="number">32</span>(SP), BP</span><br><span class="line">	<span class="number">0x001d</span> <span class="number">00029</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	$<span class="number">66</span>, (SP)    <span class="comment">// 第一个参数</span></span><br><span class="line">	<span class="number">0x0025</span> <span class="number">00037</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	$<span class="number">77</span>, <span class="number">8</span>(SP)   <span class="comment">// 第二个参数</span></span><br><span class="line">	<span class="number">0x002e</span> <span class="number">00046</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	CALL	<span class="string">""</span>.myFunction(SB)</span><br><span class="line">	<span class="number">0x0033</span> <span class="number">00051</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)	MOVQ	<span class="number">32</span>(SP), BP</span><br><span class="line">	<span class="number">0x0038</span> <span class="number">00056</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)	ADDQ	$<span class="number">40</span>, SP</span><br><span class="line">	<span class="number">0x003c</span> <span class="number">00060</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)	RET</span><br></pre></td></tr></table></figure>
<p>根据 <code>main</code> 函数生成的汇编指令，我们可以分析出 <code>main</code> 函数调用 <code>myFunction</code> 之前的栈情况：</p>
<p><img alt="golang-function-call-stack-before-calling" data-src="https://img.draveness.me/2019-01-20-golang-function-call-stack-before-calling.png"></p>
<p><strong>图 4-2 Go 语言 main 函数的调用栈</strong></p>
<p><code>main</code> 函数通过 <code>SUBQ $40, SP</code> 指令一共在栈上分配了 40 字节的内存空间：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>空间</th>
<th>大小</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SP+32 ~ BP</td>
<td>8 字节</td>
<td><code>main</code> 函数的栈基址指针</td>
</tr>
<tr>
<td>SP+16 ~ SP+32</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个返回值</td>
</tr>
<tr>
<td>SP ~ SP+16</td>
<td>16 字节</td>
<td>函数 <code>myFunction</code> 的两个参数</td>
</tr>
</tbody>
</table>
</div>
<p><code>myFunction</code> 入参的压栈顺序和 C 语言一样，都是从右到左，即第一个参数 66 在栈顶的 SP ~ SP+8，第二个参数存储在 SP+8 ~ SP+16 的空间中。</p>
<p>当我们准备好函数的入参之后，会调用汇编指令 <code>CALL &quot;&quot;.myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并开始执行 <code>myFunction</code> 的汇编指令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>.myFunction STEXT nosplit size=<span class="number">49</span> args=<span class="number">0x20</span> locals=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)	MOVQ	$<span class="number">0</span>, <span class="string">""</span>.~r2+<span class="number">24</span>(SP) <span class="comment">// 初始化第一个返回值</span></span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">3</span>)	MOVQ	$<span class="number">0</span>, <span class="string">""</span>.~r3+<span class="number">32</span>(SP) <span class="comment">// 初始化第二个返回值</span></span><br><span class="line">	<span class="number">0x0012</span> <span class="number">00018</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	<span class="string">""</span>.a+<span class="number">8</span>(SP), AX    <span class="comment">// AX = 66</span></span><br><span class="line">	<span class="number">0x0017</span> <span class="number">00023</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	ADDQ	<span class="string">""</span>.b+<span class="number">16</span>(SP), AX   <span class="comment">// AX = AX + 77 = 143</span></span><br><span class="line">	<span class="number">0x001c</span> <span class="number">00028</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	AX, <span class="string">""</span>.~r2+<span class="number">24</span>(SP) <span class="comment">// (24)SP = AX = 143</span></span><br><span class="line">	<span class="number">0x0021</span> <span class="number">00033</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	<span class="string">""</span>.a+<span class="number">8</span>(SP), AX    <span class="comment">// AX = 66</span></span><br><span class="line">	<span class="number">0x0026</span> <span class="number">00038</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	SUBQ	<span class="string">""</span>.b+<span class="number">16</span>(SP), AX   <span class="comment">// AX = AX - 77 = -11</span></span><br><span class="line">	<span class="number">0x002b</span> <span class="number">00043</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	MOVQ	AX, <span class="string">""</span>.~r3+<span class="number">32</span>(SP) <span class="comment">// (32)SP = AX = -11</span></span><br><span class="line">	<span class="number">0x0030</span> <span class="number">00048</span> (main.<span class="keyword">go</span>:<span class="number">4</span>)	RET</span><br></pre></td></tr></table></figure>
<p>从上述的汇编代码中我们可以看出，当前函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如图 4-3 所示：</p>
<p><img alt="golang-function-call-stack-before-return" data-src="https://img.draveness.me/2019-01-20-golang-function-call-stack-before-return.png"></p>
<p><strong>图 4-3 myFunction 函数返回前的栈</strong></p>
<p>在 <code>myFunction</code> 返回之后，<code>main</code> 函数会通过以下的指令来恢复栈基址指针并销毁已经失去作用的 40 字节的栈空间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0033</span> <span class="number">00051</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)    MOVQ    <span class="number">32</span>(SP), BP</span><br><span class="line"><span class="number">0x0038</span> <span class="number">00056</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)    ADDQ    $<span class="number">40</span>, SP</span><br><span class="line"><span class="number">0x003c</span> <span class="number">00060</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)    RET</span><br></pre></td></tr></table></figure>
<p>通过分析 Go 语言编译后的汇编指令，我们发现 Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>C 语言和 Go 语言在设计函数的调用惯例时选择也不同的实现。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。我们可以对比一下这两种设计的优点和缺点：</p>
<ul>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；<ul>
<li>CPU 访问栈的开销比访问寄存器高几十倍<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
</li>
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>除了函数的调用惯例之外，Go 语言在传递参数时是传值还是传引用也是一个有趣的问题，这个问题影响的是当我们在函数中对入参进行修改时会不会影响调用方看到的数据。我们先来介绍一下传值和传引用两者的区别：</p>
<ul>
<li>传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li>
<li>传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。</li>
</ul>
<p>不同语言会选择不同的方式传递参数，Go 语言选择了传值的方式，<strong>无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong>。本节剩下的内容将会验证这个结论的正确性。</p>
<h3 id="整型和数组"><a href="#整型和数组" class="headerlink" title="整型和数组"></a>整型和数组</h3><p>我们先来分析 Go 语言是如何传递基本类型和数组的。如下所示的函数 <code>myFunction</code> 接收了两个参数，整型变量 <code>i</code> 和数组 <code>arr</code>，这个函数会将传入的两个参数的地址打印出来，在最外层的主函数也会在 <code>myFunction</code> 函数调用前后分别打印两个参数的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(i <span class="keyword">int</span>, arr [2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">30</span></span><br><span class="line">	arr := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">66</span>, <span class="number">77</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"before calling - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">	myFunction(i, arr)</span><br><span class="line">	fmt.Printf(<span class="string">"after  calling - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - i=(<span class="number">30</span>, <span class="number">0xc00009a000</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc00009a010</span>)</span><br><span class="line">in my_funciton - i=(<span class="number">30</span>, <span class="number">0xc00009a008</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc00009a020</span>)</span><br><span class="line">after  calling - i=(<span class="number">30</span>, <span class="number">0xc00009a000</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc00009a010</span>)</span><br></pre></td></tr></table></figure>
<p>当我们通过命令运行这段代码我们会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p>
<p>不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。那么如果我们在 <code>myFunction</code> 函数内部对参数进行修改是否会影响 <code>main</code> 函数中的变量呢？我们更新 <code>myFunction</code> 函数并重新执行这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(i <span class="keyword">int</span>, arr [2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	i = <span class="number">29</span></span><br><span class="line">	arr[<span class="number">1</span>] = <span class="number">88</span></span><br><span class="line">	fmt.Printf(<span class="string">"in my_funciton - i=(%d, %p) arr=(%v, %p)\n"</span>, i, &amp;i, arr, &amp;arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - i=(<span class="number">30</span>, <span class="number">0xc000072008</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc000072010</span>)</span><br><span class="line">in my_funciton - i=(<span class="number">29</span>, <span class="number">0xc000072028</span>) arr=([<span class="number">66</span> <span class="number">88</span>], <span class="number">0xc000072040</span>)</span><br><span class="line">after  calling - i=(<span class="number">30</span>, <span class="number">0xc000072008</span>) arr=([<span class="number">66</span> <span class="number">77</span>], <span class="number">0xc000072010</span>)</span><br></pre></td></tr></table></figure>
<p>你可以看到在 <code>myFunction</code> 中对参数的修改也仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数，所以我们能给出如下的结论 - <strong>Go 语言中对于整型和数组类型的参数都是值传递的</strong>，也就是在调用函数时会对内容进行拷贝，需要注意的是如果当前数组的大小非常的大，这种传值方式就会对性能造成比较大的影响。</p>
<h3 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h3><p>接下来我们继续分析 Go 语言另外两种常见类型 —— 结构体和指针。在这段代码中定义一个只包含一个成员变量的简单结构体 <code>MyStruct</code> 以及接受两个参数的 <code>myFunction</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a MyStruct, b *MyStruct)</span></span> &#123;</span><br><span class="line">	a.i = <span class="number">31</span></span><br><span class="line">	b.i = <span class="number">41</span></span><br><span class="line">	fmt.Printf(<span class="string">"in my_function - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := MyStruct&#123;i: <span class="number">30</span>&#125;</span><br><span class="line">	b := &amp;MyStruct&#123;i: <span class="number">40</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"before calling - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">	myFunction(a, b)</span><br><span class="line">	fmt.Printf(<span class="string">"after calling  - a=(%d, %p) b=(%v, %p)\n"</span>, a, &amp;a, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">before calling - a=(&#123;<span class="number">30</span>&#125;, <span class="number">0xc000018178</span>) b=(&amp;&#123;<span class="number">40</span>&#125;, <span class="number">0xc00000c028</span>)</span><br><span class="line">in my_function - a=(&#123;<span class="number">31</span>&#125;, <span class="number">0xc000018198</span>) b=(&amp;&#123;<span class="number">41</span>&#125;, <span class="number">0xc00000c038</span>)</span><br><span class="line">after calling  - a=(&#123;<span class="number">30</span>&#125;, <span class="number">0xc000018178</span>) b=(&amp;&#123;<span class="number">41</span>&#125;, <span class="number">0xc00000c028</span>)</span><br></pre></td></tr></table></figure>
<p>从运行的结果我们可以得出如下结论：</p>
<ul>
<li>传递结构体时：会对结构体中的全部内容进行拷贝；</li>
<li>传递结构体指针时：会对结构体指针进行拷贝；</li>
</ul>
<p>对结构体指针的修改是改变了指针指向的结构体，<code>b.i</code> 可以被理解成 <code>(*b).i</code>，也就是我们先获取指针 <code>b</code> 背后的结构体，再修改结构体的成员变量。我们简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="keyword">int</span></span><br><span class="line">	j <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(ms *MyStruct)</span></span> &#123;</span><br><span class="line">	ptr := unsafe.Pointer(ms)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		c := (*<span class="keyword">int</span>)(unsafe.Pointer((<span class="keyword">uintptr</span>(ptr) + <span class="keyword">uintptr</span>(<span class="number">8</span>*i))))</span><br><span class="line">		*c += i + <span class="number">1</span></span><br><span class="line">		fmt.Printf(<span class="string">"[%p] %d\n"</span>, c, *c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := &amp;MyStruct&#123;i: <span class="number">40</span>, j: <span class="number">50</span>&#125;</span><br><span class="line">	myFunction(a)</span><br><span class="line">	fmt.Printf(<span class="string">"[%p] %v\n"</span>, a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">[<span class="number">0xc000018180</span>] <span class="number">41</span></span><br><span class="line">[<span class="number">0xc000018188</span>] <span class="number">52</span></span><br><span class="line">[<span class="number">0xc000018180</span>] &amp;&#123;<span class="number">41</span> <span class="number">52</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们通过指针的方式修改结构体中的成员变量，结构体在内存中是一片连续的空间，指向结构体的指针也是指向这个结构体的首地址。将 <code>MyStruct</code> 指针修改成 <code>int</code> 类型的，那么访问新指针就会返回整型变量 <code>i</code>，将指针移动 8 个字节之后就能获取下一个成员变量 <code>j</code>。</p>
<p>如果我们将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="keyword">int</span></span><br><span class="line">	j <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(ms *MyStruct)</span> *<span class="title">MyStruct</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> tool compile -S -N -l main.<span class="keyword">go</span></span><br><span class="line"><span class="string">""</span>.myFunction STEXT nosplit size=<span class="number">20</span> args=<span class="number">0x10</span> locals=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> (main.<span class="keyword">go</span>:<span class="number">8</span>)	MOVQ	$<span class="number">0</span>, <span class="string">""</span>.~r1+<span class="number">16</span>(SP) <span class="comment">// 初始化返回值</span></span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)	MOVQ	<span class="string">""</span>.ms+<span class="number">8</span>(SP), AX   <span class="comment">// 复制引用</span></span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)	MOVQ	AX, <span class="string">""</span>.~r1+<span class="number">16</span>(SP) <span class="comment">// 返回引用</span></span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> (main.<span class="keyword">go</span>:<span class="number">9</span>)	RET</span><br></pre></td></tr></table></figure>
<p>在这段汇编语言中我们发现当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令对引用进行复制，然后将复制后的指针作为返回值传递回调用方。</p>
<p><img alt="golang-pointer-as-argument" data-src="https://img.draveness.me/2019-01-21-golang-pointer-as-argument.png"></p>
<p><strong>图 4-4 Go 语言指针参数</strong></p>
<p>所以将指针作为参数传入某一个函数时，在函数内部会对指针进行复制，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中『传指针』也是传值。</p>
<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p>当我们对 Go 语言中大多数常见的数据结构进行验证之后，其实就能够推测出 Go 语言在传递参数时其实使用的就是传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数类型来避免发生大量数据的拷贝而影响性能。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一节我们详细分析了 Go 语言的调用惯例，包括传递参数和返回值的过程和原理。Go 通过栈传递函数的参数和返回值，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预留好的栈空间上，我们可以简单总结出以下几条规则：</p>
<ol>
<li>通过堆栈传递参数，入栈的顺序是从右到左；</li>
<li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li>
<li>调用函数时都是传值，接收方会对入参进行复制再计算；</li>
</ol>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html" target="_blank" rel="external nofollow noopener noreferrer">The Function Stack</a></li>
<li><a href="https://stackoverflow.com/questions/16453314/why-do-byte-spills-occur-and-what-do-they-achieve" target="_blank" rel="external nofollow noopener noreferrer">Why do byte spills occur and what do they achieve?</a></li>
<li><a href="https://mikeash.com/pyblog/friday-qa-2011-12-16-disassembling-the-assembly-part-1.html" target="_blank" rel="external nofollow noopener noreferrer">Friday Q&amp;A 2011-12-16: Disassembling the Assembly, Part 1</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external nofollow noopener noreferrer">x86 calling conventions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="external nofollow noopener noreferrer">Call Stack</a></li>
<li><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md" target="_blank" rel="external nofollow noopener noreferrer">Chapter I: A Primer on Go Assembly</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Interface</title>
    <url>/posts/c31234d9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Go 语言中的接口就是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们更好地组织并写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的最大阻碍。</p>
<p>本节会介绍使用接口时遇到的一些常见问题以及它的设计与实现，包括接口的类型转换、类型断言以及动态派发机制，帮助各位读者更好地理解接口类型。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在计算机科学中，接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。如图 4-5，接口的本质就是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p>
<p><img alt="golang-interface" data-src="https://img.draveness.me/golang-interface.png"></p>
<p><strong>图 4-5 上下游通过接口解耦</strong></p>
<p>这种面向接口的编程方式有着非常强大的生命力，无论是在框架还是操作系统中我们都能够找到接口的身影。可移植操作系统接口（Portable Operating System Interface，POSIX)<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>就是一个典型的例子，它定义了应用程序接口和命令行等标准，为计算机软件带来了可移植性 — 只要操作系统实现了 POSIX，计算机软件就可以直接在不同操作系统上运行。</p>
<p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。《计算机程序的构造和解释》中有这么一句话：</p>
<blockquote>
<p>代码必须能够被人阅读，只是机器恰好可以执行<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a></p>
</blockquote>
<p>人能够同时处理的信息非常有限，定义良好的接口能够隔离底层的实现，让我们将重点放在当前的代码片段中。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据时，其实不需要关心底层数据库的具体实现，我们只在乎 SQL 返回的结果是否符合预期。</p>
<p><img alt="sql-and-databases" data-src="https://img.draveness.me/2020-01-12-15787970694046-sql-and-databases.png"></p>
<p><strong>图 4-6 SQL 和不同数据库</strong></p>
<p>计算机科学中的接口是一个比较抽象的概念，但是编程语言中接口的概念就更加具体。Go 语言中的接口是一种内置的类型，它定义了一组方法的签名，这一小节会先介绍 Go 语言接口的几个基本概念以及常见问题，为之后介绍实现原理做一些铺垫。</p>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>很多面向对象语言都有接口这一概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String hello = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个必须实现的方法 <code>sayHello</code> 和一个会注入到实现类的变量 <code>hello</code>。在下面的代码中，<code>MyInterfaceImpl</code> 就实现了 <code>MyInterface</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(MyInterface.hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 中的类必须通过上述方式显式地声明实现的接口，但是在 Go 语言中实现接口就不需要使用类似的方式。首先，我们简单了解一下在 Go 语言中如何定义接口。定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code    <span class="keyword">int64</span></span><br><span class="line">	Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s, code=%d"</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者可能会发现上述代码根本就没有 <code>error</code> 接口的影子，这是为什么呢？Go 语言中<strong>接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法实现了 <code>error</code> 接口。Go 语言实现接口的方式与 Java 完全不同：</p>
<ul>
<li>在 Java 中：实现接口需要显式的声明接口并实现所有方法；</li>
<li>在 Go 中：实现接口的所有方法就隐式的实现了接口；</li>
</ul>
<p>我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查，这里举几个例子来演示发生接口类型检查的时机：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rpcErr error = NewRPCError(<span class="number">400</span>, <span class="string">"unknown err"</span>) <span class="comment">// typecheck1</span></span><br><span class="line">	err := AsErr(rpcErr) <span class="comment">// typecheck2</span></span><br><span class="line">	<span class="built_in">println</span>(err) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRPCError</span><span class="params">(code <span class="keyword">int64</span>, msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RPCError&#123; <span class="comment">// typecheck3</span></span><br><span class="line">		Code:    code,</span><br><span class="line">		Message: msg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsErr</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 语言会<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="external nofollow noopener noreferrer">编译期间</a>对代码进行类型检查，上述代码总共触发了三次类型检查：</p>
<ol>
<li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li>
<li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li>
</ol>
<p>从类型检查的过程来看，编译器仅在需要时才对类型进行检查，类型实现接口时只需要实现接口中的全部方法，不需要像 Java 等编程语言中一样显式声明。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface{}</code>：</p>
<p><img alt="golang-different-interface" data-src="https://img.draveness.me/golang-different-interface.png"></p>
<p><strong>图 4-7 Go 语言中的两种接口</strong></p>
<p>Go 语言使用 <code>iface</code> 结构体表示第一种接口，使用 <code>eface</code> 结构体表示第二种空接口，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中非常常见，所以在实现时使用了特殊的类型。</p>
<p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface{}</code> 类型<strong>不是任意类型</strong>，如果我们将类型转换成了 <code>interface{}</code> 类型，这边变量在运行期间的类型也发生了变化，获取变量类型时就会得到 <code>interface{}</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Test <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	v := Test&#123;&#125;</span><br><span class="line">	Print(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数不接受任意类型的参数，只接受 <code>interface{}</code> 类型的值，在调用 <code>Print</code> 函数时会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface{}</code> 类型，我们会在本节后面介绍类型转换的过程和原理。</p>
<h3 id="指针和接口"><a href="#指针和接口" class="headerlink" title="指针和接口"></a>指针和接口</h3><p>在 Go 语言中同时使用指针和接口时会发生一些让人困惑的问题，接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到『一个类型』实现接口的两种方式：</p>
<p><img alt="golang-interface-and-pointer" data-src="https://img.draveness.me/golang-interface-and-pointer.png"></p>
<p><strong>图 4-8 结构体和指针实现接口</strong></p>
<p>这是因为结构体类型和指针类型是完全不同的，就像我们不能向一个接受指针的函数传递结构体，在实现接口时这两种类型也不能划等号。但是上图中的两种实现不可以同时存在，Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 —— <code>method redeclared</code>。</p>
<p>对 <code>Cat</code> 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c  Cat)</span> <span class="title">Quack</span></span> &#123;&#125;  <span class="comment">// 使用结构体实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span></span> &#123;&#125;  <span class="comment">// 使用结构体指针实现接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d Duck = Cat&#123;&#125;      <span class="comment">// 使用结构体初始化变量</span></span><br><span class="line"><span class="keyword">var</span> d Duck = &amp;Cat&#123;&#125;     <span class="comment">// 使用结构体指针初始化变量</span></span><br></pre></td></tr></table></figure>
<p>实现接口的类型和初始化返回的类型两个维度组成了四种情况，这四种情况并不都能通过编译器的检查：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>结构体实现接口</th>
<th>结构体指针实现接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构体初始化变量</td>
<td>通过</td>
<td>不通过</td>
</tr>
<tr>
<td>结构体指针初始化变量</td>
<td>通过</td>
<td>通过</td>
</tr>
</tbody>
</table>
</div>
<p>四种中只有『使用指针实现接口，使用结构体初始化变量』无法通过编译，其他的三种情况都可以正常执行。当实现接口的类型和初始化变量时返回的类型时相同时，代码通过编译是理所应当的：</p>
<ul>
<li>方法接受者和初始化类型都是结构体；</li>
<li>方法接受者和初始化类型都是结构体指针；</li>
</ul>
<p>而剩下的两种方式为什么一种能够通过编译，另一种无法通过编译呢？我们先来看一下能够通过编译的情况，也就是方法的接受者是结构体，而初始化的变量是结构体指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为指针的 <code>&amp;Cat{}</code> 变量能够<strong>隐式地获取</strong>到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。我们可以将这里的调用理解成 C 语言中的 <code>d-&gt;Walk()</code> 和 <code>d-&gt;Speak()</code>，它们都会先获取指向的结构体再执行对应的方法。</p>
<p>但是如果我们将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = Cat&#123;&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> build <span class="keyword">interface</span>.<span class="keyword">go</span></span><br><span class="line">./<span class="keyword">interface</span>.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">6</span>: cannot use Cat literal (<span class="keyword">type</span> Cat) as <span class="keyword">type</span> Duck in assignment:</span><br><span class="line">	Cat does not implement Duck (Quack method has pointer receiver)</span><br></pre></td></tr></table></figure>
<p>编译器会提醒我们：<code>Cat</code> 类型没有实现 <code>Duck</code> 接口，<code>Quack</code> 方法的接受者是指针。这两个报错对于刚刚接触 Go 语言的开发者比较难以理解，如果我们想要搞清楚这个问题，首先要知道 Go 语言在<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/" target="_blank" rel="external nofollow noopener noreferrer">传递参数</a>时都是传值的。</p>
<p><img alt="golang-interface-method-receive" data-src="https://img.draveness.me/golang-interface-method-receiver.png"></p>
<p><strong>图 4-9 实现接口的接受者类型</strong></p>
<p>如上图所示，无论上述代码中初始化的变量 <code>c</code> 是 <code>Cat{}</code> 还是 <code>&amp;Cat{}</code>，使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝：</p>
<ul>
<li>如图 4-9 左侧，对于 <code>&amp;Cat{}</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat{}</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；</li>
<li>如图 4-9 右侧，对于 <code>Cat{}</code> 来说，这意味着 <code>Quack</code> 方法会接受一个全新的 <code>Cat{}</code>，因为方法的参数是 <code>*Cat</code>，编译器不会无中生有创建一个新的指针；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li>
</ul>
<p>上面的分析解释了指针类型的现象，当我们使用指针实现接口时，只有指针类型的变量才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口。当然这并不意味着我们应该一律使用结构体实现接口，这个问题在实际工程中也没那么重要，在这里我们只想解释现象背后的原因。</p>
<h3 id="nil-和-non-nil"><a href="#nil-和-non-nil" class="headerlink" title="nil 和 non-nil"></a>nil 和 non-nil</h3><p>我们可以通过一个例子理解<strong>『Go 语言的接口类型不是任意类型』</strong>这一句话，下面的代码在 <code>main</code> 函数中初始化了一个 <code>*TestStruct</code> 结构体指针，由于指针的零值是 <code>nil</code>，所以变量 <code>s</code> 在初始化之后也是 <code>nil</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NilOrNot</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *TestStruct</span><br><span class="line">	fmt.Println(s == <span class="literal">nil</span>)      <span class="comment">// #=&gt; true</span></span><br><span class="line">	fmt.Println(NilOrNot(s))   <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>我们简单总结一下上述代码执行的结果：</p>
<ul>
<li>将上述变量与 <code>nil</code> 比较会返回 <code>true</code>；</li>
<li>将上述变量传入 <code>NilOrNot</code> 方法并与 <code>nil</code> 比较会返回 <code>false</code>；</li>
</ul>
<p>出现上述现象的原因是 —— 调用 <code>NilOrNot</code> 函数时发生了<strong>隐式的类型转换</strong>，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>*TestStruct</code> 类型会转换成 <code>interface{}</code> 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>相信各位读者已经对 Go 语言的接口有了一些的了解，接下来我们从源代码和汇编指令层面介绍接口的底层数据结构。</p>
<p>Go 语言根据接口类型『是否包含一组方法』对类型做了不同的处理。我们使用 <code>iface</code> 结构体表示包含方法的接口；使用 <code>eface</code> 结构体表示不包含任何方法的 <code>interface{}</code> 类型，<code>eface</code> 结构体在 Go 语言的定义是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes</span></span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>interface{}</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构我们也能推断出 — Go 语言中的任意类型都可以转换成 <code>interface{}</code> 类型。</p>
<p>另一个用于表示接口的结构体就是 <code>iface</code>，这个结构体中有指向原始数据的指针 <code>data</code>，不过更重要的是 <code>itab</code> 类型的 <code>tab</code> 字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes</span></span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们将详细分析 Go 语言接口中的这两个类型，即 <code>_type</code> 和 <code>itab</code>。</p>
<h3 id="类型结构体"><a href="#类型结构体" class="headerlink" title="类型结构体"></a>类型结构体</h3><p><code>_type</code> 是 Go 语言类型的运行时表示。下面是运行时包中的结构体，结构体包含了很多元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="keyword">uintptr</span></span><br><span class="line">	ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">	hash       <span class="keyword">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="keyword">uint8</span></span><br><span class="line">	fieldAlign <span class="keyword">uint8</span></span><br><span class="line">	kind       <span class="keyword">uint8</span></span><br><span class="line">	equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">	gcdata     *<span class="keyword">byte</span></span><br><span class="line">	str        nameOff</span><br><span class="line">	ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li>
<li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li>
<li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a>；</li>
</ul>
<p>我们只需要对 <code>_type</code> 结构体中的字段有一个大体的概念，不需要详细理解所有字段的作用和意义。</p>
<h3 id="itab-结构体"><a href="#itab-结构体" class="headerlink" title="itab 结构体"></a>itab 结构体</h3><p><code>itab</code> 结构体是接口类型的核心组成部分，每一个 <code>itab</code> 都占 32 字节的空间，我们可以将其看成接口类型和具体类型的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 32 bytes</span></span><br><span class="line">	inter *interfacetype</span><br><span class="line">	_type *_type</span><br><span class="line">	hash  <span class="keyword">uint32</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>inter</code> 和 <code>_type</code> 两个用于表示类型的字段之外，上述结构体中的另外两个字段也有自己的作用：</p>
<ul>
<li><code>hash</code> 是对 <code>_type.hash</code> 的拷贝，当我们想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>_type</code> 是否一致；</li>
<li><code>fun</code> 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code> 数组中保存的元素数量是不确定的；</li>
</ul>
<p>我们会在类型断言中介绍 <code>hash</code> 字段的使用，在动态派发一节中介绍 <code>fun</code> 数组中存储的函数指针是如何被使用的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>既然我们已经了解了接口在运行时的数据结构，接下来会通过几个例子来深入理解接口类型是如何初始化和传递的，这里会介绍在实现接口时使用指针类型和结构体类型的区别。这两种不同的接口实现方式会导致 Go 语言编译器生成不同的汇编代码，带来执行过程上的一些差异。</p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>首先我们回到这一节开头提到的 <code>Duck</code> 接口的例子，我们使用 <code>//go:noinline</code> 指令<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:5" target="_blank" rel="external nofollow noopener noreferrer">5</a>禁止 <code>Quack</code> 方法的内联编译：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(c.Name + <span class="string">" meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用编译器将上述代码编译成汇编语言，删掉其中一些对理解接口原理无用的指令并保留与赋值语句 <code>var c Duck = &amp;Cat{Name: &quot;grooming&quot;}</code> 相关的代码，我们将生成的汇编指令拆分成三部分分析：</p>
<ol>
<li>结构体 <code>Cat</code> 的初始化；</li>
<li>赋值触发的类型转换过程；</li>
<li>调用接口的方法 <code>Quack()</code>；</li>
</ol>
<p>我们先来分析结构体 <code>Cat</code> 的初始化过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LEAQ	<span class="keyword">type</span>.<span class="string">""</span>.Cat(SB), AX                ;; AX = &amp;<span class="keyword">type</span>.<span class="string">""</span>.Cat</span><br><span class="line">MOVQ	AX, (SP)                           ;; SP = &amp;<span class="keyword">type</span>.<span class="string">""</span>.Cat</span><br><span class="line">CALL	runtime.newobject(SB)              ;; SP + <span class="number">8</span> = &amp;Cat&#123;&#125;</span><br><span class="line">MOVQ	<span class="number">8</span>(SP), DI                          ;; DI = &amp;Cat&#123;&#125;</span><br><span class="line">MOVQ	$<span class="number">8</span>, <span class="number">8</span>(DI)                          ;; StringHeader(DI.Name).Len = <span class="number">8</span></span><br><span class="line">LEAQ	<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX       ;; AX = &amp;<span class="string">"grooming"</span></span><br><span class="line">MOVQ	AX, (DI)                           ;; StringHeader(DI.Name).Data = &amp;<span class="string">"grooming"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>获取 <code>Cat</code> 结构体类型指针并将其作为参数放到栈上；</li>
<li>通过 <code>CALL</code> 指定调用 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数，这个函数会以 <code>Cat</code> 结构体类型指针作为入参，分配一片新的内存空间并将指向这片内存空间的指针返回到 SP+8 上；</li>
<li>SP+8 现在存储了一个指向 <code>Cat</code> 结构体的指针，我们将栈上的指针拷贝到寄存器 <code>DI</code> 上方便操作；</li>
<li>由于 <code>Cat</code> 中只包含一个字符串类型的 <code>Name</code> 变量，所以在这里会分别将字符串地址 <code>&amp;&quot;grooming&quot;</code> 和字符串长度 <code>8</code> 设置到结构体上，最后三行汇编指令等价于 <code>cat.Name = &quot;grooming&quot;</code>；</li>
</ol>
<p>字符串在运行时的表示其实就是指针加上字符串长度，在前面的章节<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/" target="_blank" rel="external nofollow noopener noreferrer">字符串</a>已经介绍过它的底层表示和实现原理，但是我们这里要看一下初始化之后的 <code>Cat</code> 结构体在内存中的表示是什么样的：</p>
<p><img alt="golang-new-struct-pointe" data-src="https://img.draveness.me/golang-new-struct-pointer.png"></p>
<p><strong>图 4-10 Cat 结构体指针</strong></p>
<p>因为 <code>Cat</code> 结构体的定义中只包含一个字符串，而字符串在 Go 语言中总共占 16 字节，所以每一个 <code>Cat</code> 结构体的大小都是 16 字节。初始化 <code>Cat</code> 结构体之后就进入了将 <code>*Cat</code> 转换成 <code>Duck</code> 类型的过程了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LEAQ	<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), AX    ;; AX = *itab(<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck)</span><br><span class="line">MOVQ	DI, (SP)                           ;; SP = AX</span><br></pre></td></tr></table></figure>
<p>类型转换的过程比较简单，<code>Duck</code> 作为一个包含方法的接口，它在底层使用 <code>iface</code> 结构体表示。<code>iface</code> 结构体包含两个字段，其中一个是指向数据的指针，另一个是表示接口和结构体关系的 <code>tab</code> 字段，我们已经通过上一段代码 SP+8 初始化了 <code>Cat</code> 结构体指针，这段代码只是将编译期间生成的 <code>itab</code> 结构体指针复制到 SP 上：</p>
<p><img alt="golang-struct-pointer-to-iface" data-src="https://img.draveness.me/golang-struct-pointer-to-iface.png"></p>
<p><strong>图 4-11 Cat 类型转换</strong></p>
<p>到这里，我们会发现 SP ~ SP+16 共同组成了 <code>iface</code> 结构体，而栈上的这个 <code>iface</code> 结构体也是 <code>Quack</code> 方法的第一个入参。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">CALL    <span class="string">""</span>.(*Cat).Quack(SB)                ;; SP.Quack()</span><br></pre></td></tr></table></figure>
<p>上述代码会直接通过 <code>CALL</code> 指令完成方法的调用，细心的读者可能会发现一个问题 —— 为什么在代码中我们调用的是 <code>Duck.Quack</code> 但生成的汇编是 <code>*Cat.Quack</code> 呢？Go 语言的编译器会在编译期间将一些需要动态派发的方法调用改写成对目标方法的直接调用，以减少性能的额外开销。如果在这里禁用编译器优化，就会看到动态派发的过程，我们会在后面分析接口的动态派发以及性能上的额外开销。</p>
<h3 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h3><p>在这里，我们继续修改上一节中的代码，使用结构体类型实现 <code>Duck</code> 接口并初始化结构体类型的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(c.Name + <span class="string">" meow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在初始化变量时使用指针类型 <code>&amp;Cat{Name: &quot;grooming&quot;}</code> 也能够通过编译，不过生成的汇编代码和上一节中的几乎完全相同，所以这里也就不分析这个情况了。</p>
<p>编译上述的代码会得到如下所示的汇编指令，需要注意的是为了代码更容易理解和分析，这里的汇编指令依然经过了删减，不过不会影响具体的执行过程。与上一节一样，我们将汇编代码的执行过程分成以下几个部分：</p>
<ol>
<li>初始化 <code>Cat</code> 结构体；</li>
<li>完成从 <code>Cat</code> 到 <code>Duck</code> 接口的类型转换；</li>
<li>调用接口的 <code>Quack</code> 方法；</li>
</ol>
<p>我们先来看一下上述汇编代码中用于初始化 <code>Cat</code> 结构体的部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">XORPS   X0, X0                          ;; X0 = <span class="number">0</span></span><br><span class="line">MOVUPS  X0, <span class="string">""</span>..autotmp_1+<span class="number">32</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Data = <span class="number">0</span></span><br><span class="line">LEAQ    <span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX    ;; AX = &amp;<span class="string">"grooming"</span></span><br><span class="line">MOVQ    AX, <span class="string">""</span>..autotmp_1+<span class="number">32</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Data = AX</span><br><span class="line">MOVQ    $<span class="number">8</span>, <span class="string">""</span>..autotmp_1+<span class="number">40</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Len =<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>这段汇编指令会在栈上初始化 <code>Cat</code> 结构体，而上一节的代码在堆上申请了 16 字节的内存空间，栈上只有一个指向 <code>Cat</code> 的指针。</p>
<p>初始化结构体后就进入类型转换的阶段，编译器会将 <code>go.itab.&quot;&quot;.Cat,&quot;&quot;.Duck</code> 的地址和指向 <code>Cat</code> 结构体的指针作为参数一并传入 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LEAQ	<span class="keyword">go</span>.itab.<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), AX     ;; AX = &amp;(<span class="keyword">go</span>.itab.<span class="string">""</span>.Cat,<span class="string">""</span>.Duck)</span><br><span class="line">MOVQ	AX, (SP)                           ;; SP = AX</span><br><span class="line">LEAQ	<span class="string">""</span>..autotmp_1+<span class="number">32</span>(SP), AX           ;; AX = &amp;(SP+<span class="number">32</span>) = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">MOVQ	AX, <span class="number">8</span>(SP)                          ;; SP + <span class="number">8</span> = AX</span><br><span class="line">CALL	runtime.convT2I(SB)                ;; runtime.convT2I(SP, SP+<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>这个函数会获取 <code>itab</code> 中存储的类型，根据类型的大小申请一片内存空间并将 <code>elem</code> 指针中的内容拷贝到目标的内存空间中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	x := mallocgc(t.size, t, <span class="literal">true</span>)</span><br><span class="line">	typedmemmove(t, x, elem)</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 会返回一个 <code>iface</code> 结构体，其中包含 <code>itab</code> 指针和 <code>Cat</code> 变量。当前函数返回之后，<code>main</code> 函数的栈上会包含以下数据：</p>
<p><img alt="golang-struct-to-iface" data-src="https://img.draveness.me/golang-struct-to-iface.png"></p>
<p><strong>图 4-12 结构体到指针</strong></p>
<p>SP 和 SP+8 中存储的 <code>itab</code> 和 <code>Cat</code> 指针就是 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 函数的入参，这个函数的返回值位于 SP+16，是一个占 16 字节内存空间的 <code>iface</code> 结构体，SP+32 存储的就是在栈上的 <code>Cat</code> 结构体，它会在 <a href="https://github.com/golang/go/blob/0c5d545ccdd01403d6ce865fb03774a6aff6032c/src/runtime/iface.go#L398-L411" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.convT2I</code></a> 执行的过程中拷贝到堆上。</p>
<p>在最后，我们会通过以下的指令调用 <code>Cat</code> 实现的接口方法 <code>Quack()</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVQ	<span class="number">16</span>(SP), AX ;; AX = &amp;(<span class="keyword">go</span>.itab.<span class="string">""</span>.Cat,<span class="string">""</span>.Duck)</span><br><span class="line">MOVQ	<span class="number">24</span>(SP), CX ;; CX = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">MOVQ	<span class="number">24</span>(AX), AX ;; AX = AX.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ	CX, (SP)   ;; SP = CX</span><br><span class="line">CALL	AX         ;; CX.Quack()</span><br></pre></td></tr></table></figure>
<p>这几个汇编指令还是非常好理解的，<code>MOVQ 24(AX), AX</code> 是最关键的指令，它从 <code>itab</code> 结构体中取出 <code>Cat.Quack</code> 方法指针作为 <code>CALL</code> 指令调用时的参数。接口变量的第 24 字节是 <code>itab.fun</code> 数组开始的位置，由于 <code>Duck</code> 接口只包含一个方法，所以 <code>itab.fun[0]</code> 中存储的就是指向 <code>Quack</code> 方法的指针了。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>上一节介绍是如何把具体类型转换成接口类型，而这一节介绍的是如何将一个接口类型转换成具体类型。本节会根据接口中是否存在方法分两种情况介绍类型断言的执行过程。</p>
<h3 id="非空接口"><a href="#非空接口" class="headerlink" title="非空接口"></a>非空接口</h3><p>首先分析接口中包含方法的情况，<code>Duck</code> 接口一个非空的接口，我们来分析从 <code>Duck</code> 转换回 <code>Cat</code> 结构体的过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	<span class="keyword">switch</span> c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *Cat:</span><br><span class="line">		cat := c.(*Cat)</span><br><span class="line">		cat.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将编译得到的汇编指令分成两部分分析，第一部分是变量的初始化，第二部分是类型断言，第一部分的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">00000</span> TEXT	<span class="string">""</span>.main(SB), ABIInternal, $<span class="number">32</span><span class="number">-0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">00029</span> XORPS	X0, X0</span><br><span class="line"><span class="number">00032</span> MOVUPS	X0, <span class="string">""</span>..autotmp_4+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00037</span> LEAQ	<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX</span><br><span class="line"><span class="number">00044</span> MOVQ	AX, <span class="string">""</span>..autotmp_4+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00049</span> MOVQ	$<span class="number">8</span>, <span class="string">""</span>..autotmp_4+<span class="number">16</span>(SP)</span><br></pre></td></tr></table></figure>
<p>0037 ~ 0049 三个指令初始化了 <code>Duck</code> 变量，<code>Cat</code> 结构体初始化在 SP+8 ~ SP+24 上。因为 Go 语言的编译器做了一些优化，所以代码中没有<code>iface</code> 的构建过程，不过对于这一节要介绍的类型断言和转换没有太多的影响。下面进入类型转换的部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">00058</span> CMPL  <span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck+<span class="number">16</span>(SB), $<span class="number">593696792</span>  </span><br><span class="line">                                        ;; <span class="keyword">if</span> (c.tab.hash != <span class="number">593696792</span>) &#123;</span><br><span class="line"><span class="number">00068</span> JEQ   <span class="number">80</span>                          ;;      </span><br><span class="line"><span class="number">00070</span> MOVQ  <span class="number">24</span>(SP), BP                  ;;      BP = SP+<span class="number">24</span></span><br><span class="line"><span class="number">00075</span> ADDQ  $<span class="number">32</span>, SP                     ;;      SP += <span class="number">32</span></span><br><span class="line"><span class="number">00079</span> RET                               ;;      <span class="keyword">return</span></span><br><span class="line">                                        ;; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">00080</span> LEAQ  <span class="string">""</span>..autotmp_4+<span class="number">8</span>(SP), AX     ;;      AX = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line"><span class="number">00085</span> MOVQ  AX, (SP)                    ;;      SP = AX</span><br><span class="line"><span class="number">00089</span> CALL  <span class="string">""</span>.(*Cat).Quack(SB)         ;;      SP.Quack()</span><br><span class="line"><span class="number">00094</span> JMP   <span class="number">70</span>                          ;;      ...</span><br><span class="line">                                        ;;      BP = SP+<span class="number">24</span></span><br><span class="line">                                        ;;      SP += <span class="number">32</span></span><br><span class="line">                                        ;;      <span class="keyword">return</span></span><br><span class="line">                                        ;; &#125;</span><br></pre></td></tr></table></figure>
<p>switch语句生成的汇编指令会将目标类型的 <code>hash</code> 与接口变量中的 <code>itab.hash</code> 进行比较：</p>
<ul>
<li>如果两者相等意味着变量的具体类型是</li>
</ul>
  <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cat</span></span><br></pre></td></tr></table></figure>
<p>  ，我们会跳转到 0080 所在的分支完成类型转换。</p>
<ol>
<li>获取 SP+8 存储的 <code>Cat</code> 结构体指针；</li>
<li>将结构体指针拷贝到栈顶；</li>
<li>调用 <code>Quack</code> 方法；</li>
<li>恢复函数的栈并返回；</li>
</ol>
<ul>
<li>如果接口中存在的具体类型不是 <code>Cat</code>，就会直接恢复栈指针并返回到调用方；</li>
</ul>
<p><img alt="golang-interface-to-struct" data-src="https://img.draveness.me/golang-interface-to-struct.png"></p>
<p><strong>图 4-13 接口转换成结构体</strong></p>
<p>上图展示了调用 <code>Quack</code> 方法时的堆栈情况，其中 <code>Cat</code> 结构体存储在 SP+8 ~ SP+24 上，<code>Cat</code> 指针存储在栈顶并指向上述结构体。</p>
<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>当我们使用空接口类型 <code>interface{}</code> 进行类型断言时，如果不关闭 Go 语言编译器的优化选项，生成的汇编指令是差不多的。编译器会省略将 <code>Cat</code> 结构体转换成 <code>eface</code> 的过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	<span class="keyword">switch</span> c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *Cat:</span><br><span class="line">		cat := c.(*Cat)</span><br><span class="line">		cat.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果禁用编译器优化，上述代码会在类型断言时就不是直接获取变量中具体类型的 <code>_type</code>，而是从 <code>eface._type</code> 中获取，汇编指令仍然会使用目标类型的 <code>hash</code> 字段与变量的类型比较。</p>
<h2 id="动态派发"><a href="#动态派发" class="headerlink" title="动态派发"></a>动态派发</h2><p>动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是一种在面向对象语言中常见的特性<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:6" target="_blank" rel="external nofollow noopener noreferrer">6</a>。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</p>
<p>在如下所示的代码中，<code>main</code> 函数调用了两次 <code>Quack</code> 方法：</p>
<ol>
<li>第一次以 <code>Duck</code> 接口类型的身份调用，调用时需要经过运行时的动态派发；</li>
<li>第二次以 <code>*Cat</code> 具体类型的身份调用，编译期就会确定调用的函数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">	c.(*Cat).Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为编译器优化影响了我们对原始汇编指令的理解，所以需要使用编译参数 <code>-N</code> 关闭编译器优化。如果不指定这个参数，编译器会对代码进行重写，与最初生成的执行过程有一些偏差，例如：</p>
<ul>
<li>因为接口类型中的 <code>tab</code> 参数并没有被使用，所以优化从 <code>Cat</code> 转换到 <code>Duck</code> 的过程；</li>
<li>因为变量的具体类型是确定的，所以删除从 <code>Duck</code> 接口类型转换到 <code>*Cat</code> 具体类型时可能会发生 <code>panic</code> 的分支；</li>
<li>…</li>
</ul>
<p>在具体分析调用 <code>Quack</code> 方法的两种姿势之前，我们要先了解 <code>Cat</code> 结构体究竟是如何初始化的，以及初始化完成后的栈上有哪些数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LEAQ	<span class="keyword">type</span>.<span class="string">""</span>.Cat(SB), AX                </span><br><span class="line">MOVQ	AX, (SP)</span><br><span class="line">CALL	runtime.newobject(SB)              ;; SP + <span class="number">8</span> = <span class="built_in">new</span>(Cat)</span><br><span class="line">MOVQ	<span class="number">8</span>(SP), DI                          ;; DI = SP + <span class="number">8</span></span><br><span class="line">MOVQ	DI, <span class="string">""</span>..autotmp_2+<span class="number">32</span>(SP)           ;; SP + <span class="number">32</span> = DI</span><br><span class="line">MOVQ	$<span class="number">8</span>, <span class="number">8</span>(DI)                          ;; StringHeader(cat).Len = <span class="number">8</span></span><br><span class="line">LEAQ	<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"grooming"</span>(SB), AX       ;; AX = &amp;<span class="string">"grooming"</span></span><br><span class="line">MOVQ	AX, (DI)                           ;; StringHeader(cat).Data = AX</span><br><span class="line">MOVQ	<span class="string">""</span>..autotmp_2+<span class="number">32</span>(SP), AX           ;; AX = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ	AX, <span class="string">""</span>..autotmp_1+<span class="number">40</span>(SP)           ;; SP + <span class="number">40</span> = &amp;Cat&#123;...&#125;</span><br><span class="line">LEAQ	<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), CX    ;; CX = &amp;<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck</span><br><span class="line">MOVQ	CX, <span class="string">""</span>.c+<span class="number">48</span>(SP)                    ;; iface(c).tab = SP + <span class="number">48</span> = CX</span><br><span class="line">MOVQ	AX, <span class="string">""</span>.c+<span class="number">56</span>(SP)                    ;; iface(c).data = SP + <span class="number">56</span> = AX</span><br></pre></td></tr></table></figure>
<p>这段代码的初始化过程其实和上两节中的过程没有太多的差别，它先初始化了 <code>Cat</code> 结构体指针，再将 <code>Cat</code> 和 <code>tab</code> 打包成了一个 <code>iface</code> 类型的结构体，我们直接来看初始化结束后的栈情况：</p>
<p><img alt="stack-after-initialize" data-src="https://img.draveness.me/stack-after-initialize.png"></p>
<p><strong>图 4-14 接口类型初始化后的栈</strong></p>
<ul>
<li>SP 是 <code>Cat</code> 类型，它也是运行时 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 方法的参数；</li>
<li>SP+8 是 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 方法的返回值，也就是指向堆上的 <code>Cat</code> 结构体的指针；</li>
<li>SP+32、SP+40 是对 SP+8 的拷贝，这两个指针都会指向栈上的 <code>Cat</code> 结构体；</li>
<li>SP+48 ~ SP+64 是接口变量 <code>iface</code> 结构体，其中包含了 <code>tab</code> 结构体指针和 <code>*Cat</code> 指针；</li>
</ul>
<p>初始化过程结束之后，我们进入到了动态派发的过程，<code>c.Quack()</code> 语句展开的汇编指令会在运行时确定函数指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVQ	<span class="string">""</span>.c+<span class="number">48</span>(SP), AX                    ;; AX = iface(c).tab</span><br><span class="line">MOVQ	<span class="number">24</span>(AX), AX                         ;; AX = iface(c).tab.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ	<span class="string">""</span>.c+<span class="number">56</span>(SP), CX                    ;; CX = iface(c).data</span><br><span class="line">MOVQ	CX, (SP)                           ;; SP = CX = &amp;Cat&#123;...&#125;</span><br><span class="line">CALL	AX                                 ;; SP.Quack()</span><br></pre></td></tr></table></figure>
<p>这段代码的执行过程可以分成以下三个步骤：</p>
<ol>
<li>从接口变量中获取了保存 <code>Cat.Quack</code> 方法指针的 <code>tab.func[0]</code>；</li>
<li>接口变量在中的数据会被拷贝到栈顶；</li>
<li>方法指针会被拷贝到寄存器中并通过汇编指令 <code>CALL</code> 触发：</li>
</ol>
<p>另一个调用 <code>Quack</code> 方法的语句 <code>c.(*Cat).Quack()</code> 生成的汇编指令看起来会有一些复杂，但是代码前半部分都是在做类型转换，将接口类型转换成 <code>*Cat</code> 类型，只有最后两行代码才是函数调用相关的指令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVQ	<span class="string">""</span>.c+<span class="number">56</span>(SP), AX                    ;; AX = iface(c).data = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ	<span class="string">""</span>.c+<span class="number">48</span>(SP), CX                    ;; CX = iface(c).tab</span><br><span class="line">LEAQ	<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck(SB), DX    ;; DX = &amp;&amp;<span class="keyword">go</span>.itab.*<span class="string">""</span>.Cat,<span class="string">""</span>.Duck</span><br><span class="line">CMPQ	CX, DX                             ;; CMP(CX, DX)</span><br><span class="line">JEQ	<span class="number">163</span></span><br><span class="line">JMP	<span class="number">201</span></span><br><span class="line">MOVQ	AX, <span class="string">""</span>..autotmp_3+<span class="number">24</span>(SP)           ;; SP+<span class="number">24</span> = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ	AX, (SP)                           ;; SP = &amp;Cat&#123;...&#125;</span><br><span class="line">CALL	<span class="string">""</span>.(*Cat).Quack(SB)                ;; SP.Quack()</span><br></pre></td></tr></table></figure>
<p>下面的几行代码只是将 <code>Cat</code> 指针拷贝到了栈顶并调用 <code>Quack</code> 方法。这一次调用的函数指针在编译期就已经确定了，所以运行时就不需要动态查找方法的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MOVQ	<span class="string">""</span>.c+<span class="number">48</span>(SP), AX                    ;; AX = iface(c).tab</span><br><span class="line">MOVQ	<span class="number">24</span>(AX), AX                         ;; AX = iface(c).tab.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ	<span class="string">""</span>.c+<span class="number">56</span>(SP), CX                    ;; CX = iface(c).data</span><br></pre></td></tr></table></figure>
<p>两次方法调用对应的汇编指令差异就是动态派发带来的额外开销，这些额外开销在有低延时、高吞吐量需求的服务中是不能被忽视的，我们来详细分析一下产生的额外汇编指令对性能造成的影响。</p>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>下面代码中的两个方法 <code>BenchmarkDirectCall</code> 和 <code>BenchmarkDynamicDispatch</code> 分别会调用结构体方法和接口方法，在接口上调用方法时会使用动态派发机制，我们以直接调用作为基准分析动态派发带来了多少额外开销：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirectCall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := &amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	AX, "".c+24(SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	AX, (SP)</span></span><br><span class="line">		<span class="comment">// CALL	"".(*Cat).Quack(SB)</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDynamicDispatch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := Duck(&amp;Cat&#123;Name: <span class="string">"grooming"</span>&#125;)</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	"".d+56(SP), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	24(AX), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	"".d+64(SP), CX</span></span><br><span class="line">		<span class="comment">// MOVQ	CX, (SP)</span></span><br><span class="line">		<span class="comment">// CALL	AX</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接运行下面的命令，使用 1 个 CPU 运行上述代码，每一个基准测试都会被执行 3 次：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -gcflags=-N -benchmem -test.count=<span class="number">3</span> -test.cpu=<span class="number">1</span> -test.benchtime=<span class="number">1</span>s -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/golang/playground</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.11</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">2.94</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.04</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">500000000</span>	         <span class="number">3.40</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">500000000</span>	         <span class="number">3.79</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">500000000</span>	         <span class="number">3.55</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure>
<ul>
<li>调用结构体方法时，每一次调用需要 <code>~3.03ns</code>；</li>
<li>使用动态派发时，每一调用需要 <code>~3.58ns</code>；</li>
</ul>
<p>在关闭编译器优化的情况下，从上面的数据来看，动态派发生成的指令会带来 <code>~18%</code> 左右的额外性能开销。</p>
<p>这些性能开销在一个复杂的系统中不会带来太多的影响。一个项目不可能只使用动态派发，而且如果我们开启编译器优化后，动态派发的额外开销会降低至 <code>~5%</code>，这对应用性能的整体影响就更小了，所以与使用接口带来的好处相比，动态派发的额外开销往往可以忽略。</p>
<p>上面的性能测试建立在实现和调用方法的都是结构体指针上，当我们将结构体指针换成结构体又会有比较大的差异：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirectCall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := Cat&#123;Name: <span class="string">"grooming"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	AX, (SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	$8, 8(SP)</span></span><br><span class="line">		<span class="comment">// CALL	"".Cat.Quack(SB)</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDynamicDispatch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := Duck(Cat&#123;Name: <span class="string">"grooming"</span>&#125;)</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	16(SP), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	24(SP), CX</span></span><br><span class="line">		<span class="comment">// MOVQ	AX, "".d+32(SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	CX, "".d+40(SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	"".d+32(SP), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	24(AX), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	"".d+40(SP), CX</span></span><br><span class="line">		<span class="comment">// MOVQ	CX, (SP)</span></span><br><span class="line">		<span class="comment">// CALL	AX</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重新执行相同的基准测试时，会得到如下所示的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -gcflags=-N -benchmem -test.count=<span class="number">3</span> -test.cpu=<span class="number">1</span> -test.benchtime=<span class="number">1</span>s .</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/golang/playground</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.15</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.02</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.09</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">200000000</span>	         <span class="number">6.92</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">200000000</span>	         <span class="number">6.91</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">200000000</span>	         <span class="number">7.10</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure>
<p>直接调用方法需要消耗时间的平均值和使用指针实现接口时差不多，约为 <code>~3.09ns</code>，而使用动态派发调用方法却需要 <code>~6.98ns</code> 相比直接调用额外消耗了 <code>~125%</code> 的时间，从生成的汇编指令我们也能看出后者的额外开销会高很多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>直接调用</th>
<th>动态派发</th>
</tr>
</thead>
<tbody>
<tr>
<td>指针</td>
<td>~3.03ns</td>
<td>~3.58ns</td>
</tr>
<tr>
<td>结构体</td>
<td>~3.09ns</td>
<td>~6.98ns</td>
</tr>
</tbody>
</table>
</div>
<p>从上述表格我们可以看到使用结构体来实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。</p>
<p>使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>重新回顾一下本节介绍的内容，我们在开头简单介绍了使用 Go 语言接口的常见问题，例如使用不同类型实现接口带来的差异、函数调用时发生的隐式类型转换；我们还分析了接口的类型转换、类型断言以及动态派发机制。相信这一节中内容能够帮助各位读者深入理解 Go 语言的接口。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://www.tapirgames.com/blog/golang-interface-implementation" target="_blank" rel="external nofollow noopener noreferrer">How Interfaces Work in Go</a></li>
<li><a href="https://golang.org/doc/effective_go.html#interfaces_and_types" target="_blank" rel="external nofollow noopener noreferrer">Interfaces and other types · Effective Go</a></li>
<li><a href="https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go" target="_blank" rel="external nofollow noopener noreferrer">How to use interfaces in Go</a></li>
<li><a href="https://research.swtch.com/interfaces" target="_blank" rel="external nofollow noopener noreferrer">Go Data Structures: Interfaces</a></li>
<li><a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="external nofollow noopener noreferrer">Duck typing · Wikipedia</a></li>
<li><a href="http://www.robelle.com/smugbook/posix.html" target="_blank" rel="external nofollow noopener noreferrer">What is POSIX?</a></li>
<li><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="external nofollow noopener noreferrer">Chapter II: Interfaces</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Reflect</title>
    <url>/posts/bf9c845a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>反射是 Go 语言比较重要的特性。虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制实现简化代码的逻辑。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包能够弥补它在语法上的一些劣势。</p>
<a id="more"></a>
<p><a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 实现了运行时的反射能力，能够让程序操作不同类型的对象<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。反射包中有两对非常重要的函数和类型，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 能获取类型信息，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 能获取数据的运行时表示，另外两个类型是 <code>Type</code> 和 <code>Value</code>，它们与函数是一一对应的关系：</p>
<p><img alt="golang-reflection" data-src="https://img.draveness.me/golang-reflection.png"></p>
<p><strong>图 4-15 反射函数和类型</strong></p>
<p>类型 <code>Type</code> 是反射包定义的一个接口，我们可以使用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 函数获取任意变量的的类型，<code>Type</code> 接口中定义了一些有趣的方法，<code>MethodByName</code> 可以获取当前类型对应方法的引用、<code>Implements</code> 可以判断当前类型是否实现了某个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">        Align() <span class="keyword">int</span></span><br><span class="line">        FieldAlign() <span class="keyword">int</span></span><br><span class="line">        Method(<span class="keyword">int</span>) Method</span><br><span class="line">        MethodByName(<span class="keyword">string</span>) (Method, <span class="keyword">bool</span>)</span><br><span class="line">        NumMethod() <span class="keyword">int</span></span><br><span class="line">        ...</span><br><span class="line">        Implements(u Type) <span class="keyword">bool</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反射包中 <code>Value</code> 的类型与 <code>Type</code> 不同，它被声明成了结构体。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Addr</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bool</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>反射包中的所有方法基本都是围绕着 <code>Type</code> 和 <code>Value</code> 这两个类型设计的。我们通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a>、<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 可以将一个普通的变量转换成『反射』包中提供的 <code>Type</code> 和 <code>Value</code>，随后就可以使用反射包中的方法对它们进行复杂的操作。</p>
<h2 id="4-3-1-三大法则"><a href="#4-3-1-三大法则" class="headerlink" title="4.3.1 三大法则"></a>4.3.1 三大法则</h2><p>运行时反射是程序在运行期间检查其自身结构的一种方式。反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>，但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢。我们在这一节中会介绍 Go 语言反射的三大法则<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>，其中包括：</p>
<ol>
<li>从 <code>interface{}</code> 变量可以反射出反射对象；</li>
<li>从反射对象可以获取 <code>interface{}</code> 变量；</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<h3 id="第一法则"><a href="#第一法则" class="headerlink" title="第一法则"></a>第一法则</h3><p>反射的第一法则是我们能将 Go 语言的 <code>interface{}</code> 变量转换成反射对象。很多读者可能会对这以法则产生困惑 —— 为什么是从 <code>interface{}</code> 变量到反射对象？当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 <code>int</code> 对应的反射类型，但是由于 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a>、<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 两个方法的入参都是 <code>interface{}</code> 类型，所以在方法执行的过程中发生了类型转换。</p>
<p>在<a href="http://draveness.me/golang-function-call" target="_blank" rel="external nofollow noopener noreferrer">函数调用</a>一节中曾经介绍过，Go 语言的函数调用都是值传递的，变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface{}</code> 类型，这也就是为什么第一条法则是『从接口到反射对象』。</p>
<p>上面提到的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的『世界』，那么这两个函数就是连接这两个世界的桥梁。</p>
<p><img alt="golang-interface-to-reflection" data-src="https://img.draveness.me/golang-interface-to-reflection.png"></p>
<p><strong>图 4-16 接口到反射对象</strong></p>
<p>我们通过以下例子简单介绍这两个函数的作用，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 获取了变量 <code>author</code> 的类型，<a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 获取了变量的值 <code>draven</code>。如果我们知道了一个变量的类型和值，那么就意味着知道了这个变量的全部信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	author := <span class="string">"draven"</span></span><br><span class="line">	fmt.Println(<span class="string">"TypeOf author:"</span>, reflect.TypeOf(author))</span><br><span class="line">	fmt.Println(<span class="string">"ValueOf author:"</span>, reflect.ValueOf(author))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">TypeOf author: <span class="keyword">string</span></span><br><span class="line">ValueOf author: draven</span><br></pre></td></tr></table></figure>
<p>有了变量的类型之后，我们可以通过 <code>Method</code> 方法获得类型实现的方法，通过 <code>Field</code> 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p>
<ul>
<li>结构体：获取字段的数量并通过下标和字段名获取字段 <code>StructField</code>；</li>
<li>哈希表：获取哈希表的 <code>Key</code> 类型；</li>
<li>函数或方法：获取入参和返回值的类型；</li>
<li>…</li>
</ul>
<p>总而言之，使用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</p>
<h3 id="第二法则"><a href="#第二法则" class="headerlink" title="第二法则"></a>第二法则</h3><p>反射的第二法则是我们可以从反射对象可以获取 <code>interface{}</code> 变量。既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 中的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L992-L994" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Interface</code></a> 方法就能完成这项工作：</p>
<p><img alt="golang-reflection-to-interface" data-src="https://img.draveness.me/golang-reflection-to-interface.png"></p>
<p><strong>图 4-17 反射对象到接口</strong></p>
<p>不过调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L992-L994" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Interface</code></a> 方法只能获得 <code>interface{}</code> 类型的变量，如果想要将其还原成最原始的状态还需要经过如下所示的显式类型转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>从反射对象到接口值的过程就是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p>
<ul>
<li>从接口值到反射对象：<ul>
<li>从基本类型到接口类型的类型转换；</li>
<li>从接口类型到反射对象的转换；</li>
</ul>
</li>
<li>从反射对象到接口值：<ul>
<li>反射对象转换成接口类型；</li>
<li>通过显式类型转换变成原始类型；</li>
</ul>
</li>
</ul>
<p><img alt="golang-bidirectional-reflection" data-src="https://img.draveness.me/golang-bidirectional-reflection.png"></p>
<p><strong>图 4-18 接口和反射对象的双向转换</strong></p>
<p>当然不是所有的变量都需要类型转换这一过程。如果变量本身就是 <code>interface{}</code> 类型，那么它不需要类型转换，因为类型转换这一过程一般都是隐式的，所以我不太需要关心它，只有在我们需要将反射对象转换回基本类型时才需要显式的转换操作。</p>
<h3 id="第三法则"><a href="#第三法则" class="headerlink" title="第三法则"></a>第三法则</h3><p>Go 语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个 <code>reflect.Value</code>，那么它持有的值一定是可以被更新的，假设我们有以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := reflect.ValueOf(i)</span><br><span class="line">	v.SetInt(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run reflect.<span class="keyword">go</span></span><br><span class="line"><span class="built_in">panic</span>: reflect: reflect.flag.mustBeAssignable using unaddressable value</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">reflect.flag.mustBeAssignableSlow(<span class="number">0x82</span>, <span class="number">0x1014c0</span>)</span><br><span class="line">	/usr/local/<span class="keyword">go</span>/src/reflect/value.<span class="keyword">go</span>:<span class="number">247</span> +<span class="number">0x180</span></span><br><span class="line">reflect.flag.mustBeAssignable(...)</span><br><span class="line">	/usr/local/<span class="keyword">go</span>/src/reflect/value.<span class="keyword">go</span>:<span class="number">234</span></span><br><span class="line">reflect.Value.SetInt(<span class="number">0x100dc0</span>, <span class="number">0x414020</span>, <span class="number">0x82</span>, <span class="number">0x1840</span>, <span class="number">0xa</span>, <span class="number">0x0</span>)</span><br><span class="line">	/usr/local/<span class="keyword">go</span>/src/reflect/value.<span class="keyword">go</span>:<span class="number">1606</span> +<span class="number">0x40</span></span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox590309925/prog.<span class="keyword">go</span>:<span class="number">11</span> +<span class="number">0xe0</span></span><br></pre></td></tr></table></figure>
<p>运行上述代码会导致程序崩溃并报出 <code>reflect: reflect.flag.mustBeAssignable using unaddressable value</code> 错误，仔细思考一下就能够发现出错的原因，Go 语言的<a href="http://draveness.me/golang-function-call" target="_blank" rel="external nofollow noopener noreferrer">函数调用</a>都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，所以直接对它修改会导致崩溃。</p>
<p>想要修改原有的变量只能通过如下的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := reflect.ValueOf(&amp;i)</span><br><span class="line">	v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run reflect.<span class="keyword">go</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数获取变量指针；</li>
<li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L788-L821" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Elem</code></a> 方法获取指针指向的变量；</li>
<li>调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L1600-L1616" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.SetInt</code></a> 方法更新变量的值：</li>
</ol>
<p>由于 Go 语言的函数调用都是值传递的，所以我们只能先获取指针对应的 <code>reflect.Value</code>，再通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L788-L821" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Elem</code></a> 方法迂回的方式得到可以被设置的变量，我们通过如下所示的代码理解这个过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := &amp;i</span><br><span class="line">	*v = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不能直接操作 <code>i</code> 变量修改其持有的值，我们就只能获取 <code>i</code> 变量所在地址并使用 <code>*v</code> 修改所在地址中存储的整数。</p>
<h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><p>Go 语言的 <code>interface{}</code> 类型在语言内部是通过 <code>emptyInterface</code> 这个结体来表示的，其中的 <code>rtype</code> 字段用于表示变量的类型，另一个 <code>word</code> 字段指向内部封装的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于获取变量类型的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 函数将传入的变量隐式转换成 <code>emptyInterface</code> 类型并获取其中存储的类型信息 <code>rtype</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rtype</code> 就是一个实现了 <code>Type</code> 接口的结构体，我们能在 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包中找到如下所示的 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L752-L758" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtype.String</code></a> 方法帮助我们获取当前类型的名称等信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := t.nameOff(t.str).name()</span><br><span class="line">	<span class="keyword">if</span> t.tflag&amp;tflagExtraStar != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 函数的实现原理其实并不复杂，它只是将一个 <code>interface{}</code> 变量转换成了内部的 <code>emptyInterface</code> 表示，然后从中获取相应的类型信息。</p>
<p>用于获取接口值 <code>Value</code> 的函数 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 实现也非常简单，在该函数中我们先调用了 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2779-L2783" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.escapes</code></a> 函数保证当前值逃逸到堆上，然后通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L140-L152" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.unpackEface</code></a> 方法从接口中获取 <code>Value</code> 结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	escapes(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L140-L152" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.unpackEface</code></a> 函数会将传入的接口转换成 <code>emptyInterface</code> 结构体，然后将具体类型和指针包装成 <code>Value</code> 结构体并返回。</p>
<p><a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/type.go#L1365-L1368" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.TypeOf</code></a> 和 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数的实现都很简单。我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">20</span></span><br><span class="line">	_ = reflect.TypeOf(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> build -gcflags=<span class="string">"-S -N"</span> main.<span class="keyword">go</span></span><br><span class="line">...</span><br><span class="line">MOVQ	$<span class="number">20</span>, <span class="string">""</span>..autotmp_20+<span class="number">56</span>(SP) <span class="comment">// autotmp = 20</span></span><br><span class="line">LEAQ	<span class="keyword">type</span>.<span class="keyword">int</span>(SB), AX           <span class="comment">// AX = type.int(SB)</span></span><br><span class="line">MOVQ	AX, <span class="string">""</span>..autotmp_19+<span class="number">280</span>(SP) <span class="comment">// autotmp_19+280(SP) = type.int(SB)</span></span><br><span class="line">LEAQ	<span class="string">""</span>..autotmp_20+<span class="number">56</span>(SP), CX  <span class="comment">// CX = 20</span></span><br><span class="line">MOVQ	CX, <span class="string">""</span>..autotmp_19+<span class="number">288</span>(SP) <span class="comment">// autotmp_19+288(SP) = 20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从上面这段截取的汇编语言，我们发现在函数调用之前已经发生了类型转换，上述指令将 <code>int</code> 类型的变量转换成了占用 16 字节 <code>autotmp_19+280(SP) ~ autotmp_19+288(SP)</code> 的接口，两个 <code>LEAQ</code> 指令分别获取了类型的指针 <code>type.int(SB)</code> 以及变量 <code>i</code> 所在的地址。</p>
<p>当我们想要将一个变量转换成反射对象时，Go 语言会在编译期间完成类型转换的工作，将变量的类型和值转换成了 <code>interface{}</code> 并等待运行期间使用 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包获取接口中存储的信息。</p>
<h2 id="更新变量"><a href="#更新变量" class="headerlink" title="更新变量"></a>更新变量</h2><p>当我们想要更新一个 <code>reflect.Value</code>，就需要调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L1525-L1538" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Set</code></a> 方法更新反射对象，该方法会调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L232-L236" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.flag.mustBeAssignable</code></a> 和 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L214-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.flag.mustBeExported</code></a> 分别检查当前反射对象是否是可以被设置的以及字段是否是对外公开的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Set</span><span class="params">(x Value)</span></span> &#123;</span><br><span class="line">	v.mustBeAssignable()</span><br><span class="line">	x.mustBeExported()</span><br><span class="line">	<span class="keyword">var</span> target unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> v.kind() == Interface &#123;</span><br><span class="line">		target = v.ptr</span><br><span class="line">	&#125;</span><br><span class="line">	x = x.assignTo(<span class="string">"reflect.Set"</span>, v.typ, target)</span><br><span class="line">	typedmemmove(v.typ, v.ptr, x.ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L1525-L1538" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Set</code></a> 方法会调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.assignTo</code></a> 并返回一个新的反射对象，这个返回的反射对象指针就会直接覆盖原始的反射变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">assignTo</span><span class="params">(context <span class="keyword">string</span>, dst *rtype, target unsafe.Pointer)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> directlyAssignable(dst, v.typ):</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> Value&#123;dst, v.ptr, fl&#125;</span><br><span class="line">	<span class="keyword">case</span> implements(dst, v.typ):</span><br><span class="line">		<span class="keyword">if</span> v.Kind() == Interface &amp;&amp; v.IsNil() &#123;</span><br><span class="line">			<span class="keyword">return</span> Value&#123;dst, <span class="literal">nil</span>, flag(Interface)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		x := valueInterface(v, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> dst.NumMethod() == <span class="number">0</span> &#123;</span><br><span class="line">			*(*<span class="keyword">interface</span>&#123;&#125;)(target) = x</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ifaceE2I(dst, x, target)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;dst, target, flagIndir | flag(Interface)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">panic</span>(context + <span class="string">": value of type "</span> + v.typ.String() + <span class="string">" is not assignable to type "</span> + dst.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.assignTo</code></a> 会根据当前和被设置的反射对象类型创建一个新的 <code>Value</code> 结构体：</p>
<ul>
<li>如果两个反射对象的类型是可以被直接替换，就会直接将目标反射对象返回；</li>
<li>如果当前反射对象是接口并且目标对象实现了接口，就会将目标对象简单包装成接口值；</li>
</ul>
<p>在变量更新的过程中，<a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L2370-L2404" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.assignTo</code></a> 返回的 <code>reflect.Value</code> 中的指针会覆盖当前反射对象中的指针实现变量的更新。</p>
<h2 id="实现协议"><a href="#实现协议" class="headerlink" title="实现协议"></a>实现协议</h2><p><a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包还为我们提供了 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtypes.Implements</code></a> 方法可以用于判断某些类型是否遵循特定的接口。在 Go 语言中获取结构体的反射类型 <code>reflect.Type</code> 还是比较容易的，但是想要获得接口的类型就需要通过以下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reflect.TypeOf((*&lt;<span class="keyword">interface</span>&gt;)(<span class="literal">nil</span>)).Elem()</span><br></pre></td></tr></table></figure>
<p>我们通过一个例子在介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的 <code>CustomError</code> 是否实现了 Go 语言标准库中的 <code>error</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	typeOfError := reflect.TypeOf((*error)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">	customErrorPtr := reflect.TypeOf(&amp;CustomError&#123;&#125;)</span><br><span class="line">	customError := reflect.TypeOf(CustomError&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(customErrorPtr.Implements(typeOfError)) <span class="comment">// #=&gt; true</span></span><br><span class="line">	fmt.Println(customError.Implements(typeOfError)) <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的运行结果正如我们在<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/" target="_blank" rel="external nofollow noopener noreferrer">接口</a>一节中介绍的：</p>
<ul>
<li><code>CustomError</code> 类型并没有实现 <code>error</code> 接口；</li>
<li><code>*CustomError</code> 指针类型实现了 <code>error</code> 接口；</li>
</ul>
<p>抛开上述的执行结果不谈，我们来分析一下 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtypes.Implements</code></a> 方法的工作原理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">Implements</span><span class="params">(u Type)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"reflect: nil type passed to Type.Implements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> u.Kind() != Interface &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"reflect: non-interface type passed to Type.Implements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> implements(u.(*rtype), t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1430-L1438" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtypes.Implements</code></a> 方法会检查传入的类型是不是接口，如果不是接口或者是空值就会直接 panic 中止当前程序。在参数没有问题的情况下，上述方法会调用私有函数 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1461-L1543" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.implements</code></a> 判断类型之间是否有实现关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">implements</span><span class="params">(T, V *rtype)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	t := (*interfaceType)(unsafe.Pointer(T))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.methods) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	v := V.uncommon()</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	vmethods := v.methods()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="keyword">int</span>(v.mcount); j++ &#123;</span><br><span class="line">		tm := &amp;t.methods[i]</span><br><span class="line">		tmName := t.nameOff(tm.name)</span><br><span class="line">		vm := vmethods[j]</span><br><span class="line">		vmName := V.nameOff(vm.name)</span><br><span class="line">		<span class="keyword">if</span> vmName.name() == tmName.name() &amp;&amp; V.typeOff(vm.mtyp) == t.typeOff(tm.typ) &#123;</span><br><span class="line">			<span class="keyword">if</span> i++; i &gt;= <span class="built_in">len</span>(t.methods) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，这时就会直接返回 <code>true</code>。</p>
<p><img alt="golang-type-implements-interface" data-src="https://img.draveness.me/golang-type-implements-interface.png"></p>
<p><strong>图 4-19 类型实现接口</strong></p>
<p>在其他情况下，由于方法都是按照字母序存储的，<a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L1461-L1543" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.implements</code></a> 会维护两个用于遍历接口和类型方法的索引 <code>i</code> 和 <code>j</code> 判断类型是否实现了接口，因为最多只会进行 <code>n</code> 次比较（类型的方法数量），所以整个过程的时间复杂度是 <code>O(n)</code>。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>作为一门静态语言，如果我们想要通过 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包利用反射在运行期间执行方法不是一件容易的事情，下面的十几行代码就使用反射来执行 <code>Add(0, 1)</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(Add)</span><br><span class="line">	<span class="keyword">if</span> v.Kind() != reflect.Func &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t := v.Type()</span><br><span class="line">	argv := <span class="built_in">make</span>([]reflect.Value, t.NumIn())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> argv &#123;</span><br><span class="line">		<span class="keyword">if</span> t.In(i).Kind() != reflect.Int &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		argv[i] = reflect.ValueOf(i)</span><br><span class="line">	&#125;</span><br><span class="line">	result := v.Call(argv)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="number">1</span> || result[<span class="number">0</span>].Kind() != reflect.Int &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(result[<span class="number">0</span>].Int()) <span class="comment">// #=&gt; 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 获取函数 <code>Add</code> 对应的反射对象；</li>
<li>根据反射对象 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L979-L985" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.rtype.NumIn</code></a> 方法返回的参数个数创建 <code>argv</code> 数组；</li>
<li>多次调用 <a href="https://github.com/golang/go/blob/52c4488471ed52085a29e173226b3cbd2bf22b20/src/reflect/value.go#L2316-L2328" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.ValueOf</code></a> 函数逐一设置 <code>argv</code> 数组中的各个参数；</li>
<li>调用反射对象 <code>Add</code> 的 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L318-L322" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Call</code></a> 方法并传入参数列表；</li>
<li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li>
</ol>
<p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性需要付出的成本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span> []<span class="title">Value</span></span> &#123;</span><br><span class="line">	v.mustBe(Func)</span><br><span class="line">	v.mustBeExported()</span><br><span class="line">	<span class="keyword">return</span> v.call(<span class="string">"Call"</span>, in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L318-L322" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.Call</code></a> 方法是运行时调用方法的入口，它通过两个 <code>MustBe</code> 开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L339-L501" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.Value.call</code></a> 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p>
<ol>
<li>检查输入参数以及类型的合法性；</li>
<li>将传入的 <code>reflect.Value</code> 参数数组设置到栈上；</li>
<li>通过函数指针和输入参数调用函数；</li>
<li>从栈上获取函数的返回值；</li>
</ol>
<p>我们将按照上面的顺序分析使用 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 进行函数调用的几个过程。</p>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>参数检查是通过反射调用方法的第一步，在参数检查期间我们会从反射对象中取出当前的函数指针 <code>unsafe.Pointer</code>，如果该函数指针是方法，那么我们就会通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/value.go#L612-L645" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.methodReceiver</code></a> 函数获取方法的接受者和函数指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">call</span><span class="params">(op <span class="keyword">string</span>, in []Value)</span> []<span class="title">Value</span></span> &#123;</span><br><span class="line">	t := (*funcType)(unsafe.Pointer(v.typ))</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> v.flag&amp;flagMethod != <span class="number">0</span> &#123;</span><br><span class="line">		rcvr = v</span><br><span class="line">		rcvrtype, t, fn = methodReceiver(op, v, <span class="keyword">int</span>(v.flag)&gt;&gt;flagMethodShift)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	n := t.NumIn()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; n &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"reflect: Call with too few input arguments"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &gt; n &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"reflect: Call with too many input arguments"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"reflect: "</span> + op + <span class="string">" using "</span> + xt.String() + <span class="string">" as type "</span> + targ.String())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上述方法中，上述方法还会检查传入参数的个数以及参数的类型与函数签名中的类型是否可以匹配，任何参数的不匹配都会导致整个程序的崩溃中止。</p>
<h3 id="准备参数"><a href="#准备参数" class="headerlink" title="准备参数"></a>准备参数</h3><p>当我们已经对当前方法的参数完成验证之后，就会进入函数调用的下一个阶段，为函数调用准备参数，在前面的章节<a href="https://draveness.me/golang/basic/golang-function-call.html" target="_blank" rel="external nofollow noopener noreferrer">函数调用</a>中我们已经介绍过 Go 语言的函数调用惯例，函数或者方法在调用时，所有的参数都会被依次放置到栈上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nout := t.NumOut()</span><br><span class="line">frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> nout == <span class="number">0</span> &#123;</span><br><span class="line">	args = framePool.Get().(unsafe.Pointer)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	args = unsafe_New(frametype)</span><br><span class="line">&#125;</span><br><span class="line">off := <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> rcvrtype != <span class="literal">nil</span> &#123;</span><br><span class="line">	storeRcvr(rcvr, args)</span><br><span class="line">	off = ptrSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> in &#123;</span><br><span class="line">	targ := t.In(i).(*rtype)</span><br><span class="line">	a := <span class="keyword">uintptr</span>(targ.align)</span><br><span class="line">	off = (off + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">	n := targ.size</span><br><span class="line">	...</span><br><span class="line">	addr := add(args, off, <span class="string">"n &gt; 0"</span>)</span><br><span class="line">	v = v.assignTo(<span class="string">"reflect.Value.Call"</span>, targ, addr)</span><br><span class="line">	*(*unsafe.Pointer)(addr) = v.ptr</span><br><span class="line">	off += n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>通过 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L2975-L3048" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.funcLayout</code></a> 函数计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</p>
</li>
<li><p>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间 <code>args</code>；</p>
</li>
<li><p>如果当前函数是方法，需要向将方法的接受者拷贝到 <code>args</code> 内存中；</p>
</li>
<li><p>将所有函数的参数按照顺序依次拷贝到对应</p>
</li>
</ol>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">args</span></span><br></pre></td></tr></table></figure>
<p>   内存中</p>
<ol>
<li>使用 <a href="https://github.com/golang/go/blob/4e8d27068df52eb372dc2ba7e929e47850934805/src/reflect/type.go#L2975-L3048" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect.funcLayout</code></a> 返回的参数计算参数在内存中的位置；<ol>
<li>将参数拷贝到内存空间中；</li>
</ol>
</li>
</ol>
<p>准备参数的过程是计算各个参数和返回值占用的内存空间并将所有的参数都拷贝内存空间对应的位置的过程，该过程会考虑函数和方法、返回值数量以及参数类型带来的差异。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>准备好调用函数需要的全部参数之后，就会通过以下的代码执行函数指针了。我们会向该函数传入栈类型、函数指针、参数和返回值的内存空间、栈的大小以及返回值的偏移量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">call(frametype, fn, args, <span class="keyword">uint32</span>(frametype.size), <span class="keyword">uint32</span>(retOffset))</span><br></pre></td></tr></table></figure>
<p>上述函数实际上并不存在，它会在编译期间被链接到 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L489-L526" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.reflectcall</code></a> 这个用汇编实现的函数上，我们在这里不会分析该函数的具体实现，感兴趣的读者可以自行了解其实现原理。</p>
<h3 id="处理返回值"><a href="#处理返回值" class="headerlink" title="处理返回值"></a>处理返回值</h3><p>当函数调用结束之后，就会开始处理函数的返回值：</p>
<ul>
<li>如果函数没有任何返回值，会直接清空 <code>args</code> 中的全部内容来释放内存空间；</li>
<li>如果当前函数有返回值；<ol>
<li>将 <code>args</code> 中与输入参数有关的内存空间清空；</li>
<li>创建一个 <code>nout</code> 长度的切片用于保存由反射对象构成的返回值数组；</li>
<li>从函数对象中获取返回值的类型和内存大小，将 <code>args</code> 内存中的数据转换成 <code>reflect.Value</code> 类型并存储到切片中；</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> ret []Value</span><br><span class="line">	<span class="keyword">if</span> nout == <span class="number">0</span> &#123;</span><br><span class="line">		typedmemclr(frametype, args)</span><br><span class="line">		framePool.Put(args)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		typedmemclrpartial(frametype, args, <span class="number">0</span>, retOffset)</span><br><span class="line">		ret = <span class="built_in">make</span>([]Value, nout)</span><br><span class="line">		off = retOffset</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nout; i++ &#123;</span><br><span class="line">			tv := t.Out(i)</span><br><span class="line">			a := <span class="keyword">uintptr</span>(tv.Align())</span><br><span class="line">			off = (off + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> tv.Size() != <span class="number">0</span> &#123;</span><br><span class="line">				fl := flagIndir | flag(tv.Kind())</span><br><span class="line">				ret[i] = Value&#123;tv.common(), add(args, off, <span class="string">"tv.Size() != 0"</span>), fl&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ret[i] = Zero(tv)</span><br><span class="line">			&#125;</span><br><span class="line">			off += tv.Size()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 <code>reflect.Value</code> 构成的 <code>ret</code> 数组会被返回到上层，到这里为止使用反射实现函数调用的过程就结束了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Go 语言的 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external nofollow noopener noreferrer"><code>reflect</code></a> 包为我们提供的多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能，通过对反射包中方法原理的分析能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="external nofollow noopener noreferrer">The Laws of Reflection</a></li>
<li><a href="https://github.com/golang/go/commit/3d1699ea787f38be6088f9a098d6e08dafca9387" target="_blank" rel="external nofollow noopener noreferrer">runtime: new itab lookup table</a></li>
<li><a href="https://github.com/golang/go/issues/20505" target="_blank" rel="external nofollow noopener noreferrer">runtime: need a better itab table</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Defer</title>
    <url>/posts/540e2781/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很多现代的编程语言中都有 <code>defer</code> 关键字，Go 语言的 <code>defer</code> 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。在这一节中我们就会深入 Go 语言的源代码介绍 <code>defer</code> 关键字的实现原理，相信读者读完这一节会对 <code>defer</code> 的数据结构、实现以及调用过程有着更清晰的理解。</p>
<a id="more"></a>
<p>作为一个编程语言中的关键字，<code>defer</code> 的实现一定是由编译器和运行时共同完成的，不过在深入源码分析它的实现之前我们还是需要了解 <code>defer</code> 关键字的常见使用场景以及使用时的注意事项。</p>
<p>使用 <code>defer</code> 的最常见场景就是在函数调用结束后完成一些收尾工作，例如在 <code>defer</code> 中回滚数据库的事务：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPost</span><span class="params">(db *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    tx := db.Begin()</span><br><span class="line">    <span class="keyword">defer</span> tx.Rollback()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := tx.Create(&amp;Post&#123;Author: <span class="string">"Draveness"</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tx.Commit().Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用数据库事务时，我们可以使用如上所示的代码在创建事务之后就立刻调用 <code>Rollback</code> 保证事务一定会回滚。哪怕事务真的执行成功了，那么调用 <code>tx.Commit()</code> 之后再执行 <code>tx.Rollback()</code> 也不会影响已经提交的事务。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>我们在 Go 语言中使用 <code>defer</code> 时会遇到两个比较常见的问题，这里会介绍具体的场景并分析这两个现象背后的设计原理：</p>
<ul>
<li><code>defer</code> 关键字的调用时机以及多次调用 <code>defer</code> 时执行顺序是如何确定的；</li>
<li><code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>向 <code>defer</code> 关键字传入的函数会在函数返回之前运行。假设我们在 <code>for</code> 循环中多次调用 <code>defer</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>运行上述代码会倒序执行所有向 <code>defer</code> 关键字中传入的表达式，最后一次 <code>defer</code> 调用传入了 <code>fmt.Println(4)</code>，所以会这段代码会优先打印 4。我们可以通过下面这个简单例子强化对 <code>defer</code> 执行时机的理解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">"defer runs"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"block ends"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"main ends"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">block ends</span><br><span class="line">main ends</span><br><span class="line"><span class="keyword">defer</span> runs</span><br></pre></td></tr></table></figure>
<p>从上述代码的输出我们会发现，<code>defer</code> 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。</p>
<h3 id="预计算参数"><a href="#预计算参数" class="headerlink" title="预计算参数"></a>预计算参数</h3><p>Go 语言中所有的函数调用都是传值的，<code>defer</code> 虽然是关键字，但是也继承了这个特性。假设我们想要计算 <code>main</code> 函数运行的时间，可能会写出以下的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startedAt := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(time.Since(startedAt))</span><br><span class="line">	</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">0</span>s</span><br></pre></td></tr></table></figure>
<p>然而上述代码的运行结果并不符合我们的预期，这个现象背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻对函数中引用的外部参数进行拷贝，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</p>
<p>想要解决这个问题的方法非常简单，我们只需要向 <code>defer</code> 关键字传入匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startedAt := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;()</span><br><span class="line">	</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">1</span>s</span><br></pre></td></tr></table></figure>
<p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 <code>time.Since(startedAt)</code> 会在 <code>main</code> 函数返回前被调用并打印出符合预期的结果。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在介绍 <code>defer</code> 函数的执行过程与实现原理之前，我们首先来了解一下 <code>defer</code> 关键字在 Go 语言源代码中对应的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">	siz     <span class="keyword">int32</span></span><br><span class="line">	started <span class="keyword">bool</span></span><br><span class="line">	sp      <span class="keyword">uintptr</span></span><br><span class="line">	pc      <span class="keyword">uintptr</span></span><br><span class="line">	fn      *funcval</span><br><span class="line">	_panic  *_panic</span><br><span class="line">	link    *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体是延迟调用链表上的一个元素，所有的结构体都会通过 <code>link</code> 字段串联成链表。</p>
<p><img alt="golang-defer-link" data-src="https://img.draveness.me/2020-01-19-15794017184603-golang-defer-link.png"></p>
<p><strong>图 5-10 延迟调用链表</strong></p>
<p>我们简单介绍一下 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体中的几个字段：</p>
<ul>
<li><code>siz</code> 是参数和结果的内存大小；</li>
<li><code>sp</code> 和 <code>pc</code> 分别代表栈指针和调用方的程序计数器；</li>
<li><code>fn</code> 是 <code>defer</code> 关键字中传入的函数；</li>
<li><code>_panic</code> 是触发延迟调用的结构体，可能为空；</li>
</ul>
<p>除了上述的这些字段之外，<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 中还包含一些垃圾回收机制使用的字段，这里为了减少理解的成本就都省去了。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>中间代码生成阶段执行的被 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023-L1502" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.stmt</code></a> 函数会处理 <code>defer</code> 关键字。从下面截取的这段代码中，我们会发现编译器调用了 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324-L4517" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.call</code></a> 函数，这表示 <code>defer</code> 在编译器看来也是函数调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> ODEFER:</span><br><span class="line">		s.call(n.Left, callDefer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324-L4517" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.call</code></a> 函数会负责了为所有函数和方法调用生成中间代码，它的工作包括以下内容：</p>
<ol>
<li>获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方；</li>
<li>获取栈地址并将函数或者方法的参数写入栈中；</li>
<li>使用 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L764-L766" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.newValue1A</code></a> 以及相关函数生成函数调用的中间代码；</li>
<li>如果当前调用的函数是 <code>defer</code>，那么就会单独生成相关的结束代码块；</li>
<li>获取函数的返回值地址并结束当前调用；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">call</span><span class="params">(n *Node, k callKind)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> call *ssa.Value</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> k == callDefer:</span><br><span class="line">		call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, deferproc, s.mem())</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	call.AuxInt = stksize</span><br><span class="line">	s.vars[&amp;memVar] = call</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中我们能看到，<code>defer</code> 关键字在运行期间会调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数，这个函数接收了参数的大小和闭包所在的地址两个参数。</p>
<p>编译器不仅将 <code>defer</code> 关键字都转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数，它还会通过以下三个步骤为所有调用 <code>defer</code> 的函数末尾插入 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 的函数调用：</p>
<ol>
<li><a href="https://github.com/golang/go/blob/316fd8cc4a7fab2e1bb45848bc30ea8b8a0b231a/src/cmd/compile/internal/gc/walk.go#L115-L351" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkstmt</code></a> 在遇到 <code>ODEFER</code> 节点时会执行 <code>Curfn.Func.SetHasDefer(true)</code> 设置当前函数的 <code>hasdefer</code>；</li>
<li><a href="https://github.com/golang/go/blob/98d2717499575afe13d9f815d46fcd6e384efb0c/src/cmd/compile/internal/gc/ssa.go#L281-L451" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.buildssa</code></a> 会执行 <code>s.hasdefer = fn.Func.HasDefer()</code> 更新 <code>state</code> 的 <code>hasdefer</code>；</li>
<li><a href="https://github.com/golang/go/blob/98d2717499575afe13d9f815d46fcd6e384efb0c/src/cmd/compile/internal/gc/ssa.go#L1511-L1552" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.exit</code></a> 会根据 <code>state</code> 的 <code>hasdefer</code> 在函数返回之前插入 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 的函数调用；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">exit</span><span class="params">()</span> *<span class="title">ssa</span>.<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.hasdefer &#123;</span><br><span class="line">		s.rtcall(Deferreturn, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 语言的编译器不仅将 <code>defer</code> 转换成了 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 的函数调用，还在所有调用 <code>defer</code> 的函数结尾插入了 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>，接下来我们就需要了解这两个运行时方法的实现原理了。</p>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><code>defer</code> 关键字的运行时实现分成两个部分：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数负责创建新的延迟调用；</li>
<li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 函数负责在函数调用结束时执行所有的延迟调用；</li>
</ul>
<p>这两个函数是 <code>defer</code> 关键字运行时机制的入口，我们从它们开始分别介绍这两个函数的执行过程。</p>
<h3 id="创建延迟调用"><a href="#创建延迟调用" class="headerlink" title="创建延迟调用"></a>创建延迟调用</h3><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 会为 <code>defer</code> 创建一个新的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体、设置它的函数指针 <code>fn</code>、程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并将相关的参数拷贝到相邻的内存空间中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	sp := getcallersp()</span><br><span class="line">	argp := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">	callerpc := getcallerpc()</span><br><span class="line"></span><br><span class="line">	d := newdefer(siz)</span><br><span class="line">	<span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"deferproc: d.panic != nil after newdefer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	d.fn = fn</span><br><span class="line">	d.pc = callerpc</span><br><span class="line">	d.sp = sp</span><br><span class="line">	<span class="keyword">switch</span> siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(deferArgs(d), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(siz))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用的 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1320-L1322" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.return0</code></a> 函数的作用是避免无限递归调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>，它是唯一一个不会触发由延迟调用的函数了。</p>
<p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 中 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L383-L430" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newdefer</code></a> 的作用就是想尽办法获得一个 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体，办法总共有三个：</p>
<ol>
<li>从调度器的延迟调用缓存池 <code>sched.deferpool</code> 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；</li>
<li>从 Goroutine 的延迟调用缓存池 <code>pp.deferpool</code> 中取出结构体；</li>
<li>通过 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L889-L1132" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mallocgc</code></a> 创建一个新的结构体；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newdefer</span><span class="params">(siz <span class="keyword">int32</span>)</span> *_<span class="title">defer</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d *_defer</span><br><span class="line">	sc := deferclass(<span class="keyword">uintptr</span>(siz))</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> sc &lt; <span class="keyword">uintptr</span>(<span class="built_in">len</span>(p&#123;&#125;.deferpool)) &#123;</span><br><span class="line">		pp := gp.m.p.ptr()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pp.deferpool[sc]) == <span class="number">0</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="built_in">len</span>(pp.deferpool[sc]) &lt; <span class="built_in">cap</span>(pp.deferpool[sc])/<span class="number">2</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">				d := sched.deferpool[sc]</span><br><span class="line">				sched.deferpool[sc] = d.link</span><br><span class="line">				pp.deferpool[sc] = <span class="built_in">append</span>(pp.deferpool[sc], d)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n := <span class="built_in">len</span>(pp.deferpool[sc]); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			d = pp.deferpool[sc][n<span class="number">-1</span>]</span><br><span class="line">			pp.deferpool[sc][n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">			pp.deferpool[sc] = pp.deferpool[sc][:n<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		total := roundupsize(totaldefersize(<span class="keyword">uintptr</span>(siz)))</span><br><span class="line">		d = (*_defer)(mallocgc(total, deferType, <span class="literal">true</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	d.siz = siz</span><br><span class="line">	d.link = gp._defer</span><br><span class="line">	gp._defer = d</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用哪种方式获取 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a>，它都会被追加到所在的 Goroutine <code>_defer</code> 链表的最前面。</p>
<p><img alt="golang-new-defe" data-src="https://img.draveness.me/2020-01-19-15794017184614-golang-new-defer.png"></p>
<p><strong>图 5-11 追加新的延迟调用</strong></p>
<p><code>defer</code> 关键字插入时是从后向前的，而 <code>defer</code> 关键字执行是从前向后的，而这就是后调用的 <code>defer</code> 会优先执行的原因。</p>
<h3 id="执行延迟调用"><a href="#执行延迟调用" class="headerlink" title="执行延迟调用"></a>执行延迟调用</h3><p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 会从 Goroutine 的 <code>_defer</code> 链表中取出最前面的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体并调用 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L614-L624" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.jmpdefer</code></a> 函数传入需要执行的函数和参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	d := gp._defer</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	sp := getcallersp()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz))</span><br><span class="line">	&#125;</span><br><span class="line">	fn := d.fn</span><br><span class="line">	gp._defer = d.link</span><br><span class="line">	freedefer(d)</span><br><span class="line">	jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L614-L624" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.jmpdefer</code></a> 是一个用汇编语言实现的运行时函数，它的工作就是跳转 <code>defer</code> 所在的代码段并在执行结束之后跳转回 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·jmpdefer(SB), NOSPLIT, $<span class="number">0</span><span class="number">-8</span></span><br><span class="line">	MOVL	fv+<span class="number">0</span>(FP), DX	<span class="comment">// fn</span></span><br><span class="line">	MOVL	argp+<span class="number">4</span>(FP), BX	<span class="comment">// caller sp</span></span><br><span class="line">	LEAL	<span class="number">-4</span>(BX), SP	<span class="comment">// caller sp after CALL</span></span><br><span class="line">#ifdef GOBUILDMODE_shared</span><br><span class="line">	SUBL	$<span class="number">16</span>, (SP)	<span class="comment">// return to CALL again</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">	SUBL	$<span class="number">5</span>, (SP)	<span class="comment">// return to CALL again</span></span><br><span class="line">#endif</span><br><span class="line">	MOVL	<span class="number">0</span>(DX), BX</span><br><span class="line">	JMP	BX	<span class="comment">// but first run the deferred function</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 函数会多次判断当前 Goroutine 的 <code>_defer</code> 链表中是否有未执行的剩余结构，在所有的延迟函数调用都执行完成之后，该函数才会返回。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>defer</code> 关键字的实现主要依靠编译器和运行时的协作，我们总结一下本节提到的内容：</p>
<ul>
<li>编译期；<ul>
<li>将 <code>defer</code> 关键字被转换 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a>；</li>
<li>在调用 <code>defer</code> 关键字的函数返回之前插入 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>；</li>
</ul>
</li>
<li>运行时：<ul>
<li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 会将一个新的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体追加到当前 Goroutine 的链表头；</li>
<li><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 会从 Goroutine 的链表中取出 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构并依次执行；</li>
</ul>
</li>
</ul>
<p>我们在本节前面提到的两个现象在这里也可以解释清楚了：</p>
<ul>
<li><p>后调用的 <code>defer</code> 函数会先执行：</p>
<ul>
<li>后调用的 <code>defer</code> 函数会被追加到 Goroutine <code>_defer</code> 链表的最前面；</li>
</ul>
</li>
<li><p>运行 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 时是从前到后依次执行；</p>
</li>
<li><p>函数的参数会被预先计算；</p>
<ul>
<li>调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li>
</ul>
</li>
</ul>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01" target="_blank" rel="external nofollow noopener noreferrer">5 Gotchas of Defer in Go — Part I</a></li>
<li><a href="https://stackoverflow.com/questions/28893586/golang-defer-clarification" target="_blank" rel="external nofollow noopener noreferrer">Golang defer clarification</a></li>
<li><a href="http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/" target="_blank" rel="external nofollow noopener noreferrer">Dive into stack and defer/panic/recover in go</a></li>
<li><a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">Defer, Panic, and Recover</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Select</title>
    <url>/posts/3d36166e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很多 C 语言或者 Unix 开发者听到 <code>select</code> 想到的都是系统调用，而谈到 I/O 模型时最终大都会提到基于 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 等函数构建的 IO 多路复用模型。Go 语言的 <code>select</code> 与 C 语言中的 <code>select</code> 有着比较相似的功能。本节会介绍 Go 语言 <code>select</code> 常见的现象、数据结构以及四种不同情况下的实现原理。</p>
<a id="more"></a>
<p>C 语言中的 <code>select</code> 关键字可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 <code>select</code> 关键字也能够让 Goroutine 同时等待多个 Channel 的可读或者可写，在多个文件或者 Channel 发生状态改变之前，<code>select</code> 会一直阻塞当前线程或者 Goroutine。</p>
<p><img alt="Golang-Select-Channels" data-src="https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png"></p>
<p><code>select</code> 是一种与 <code>switch</code> 相似的控制结构，与 <code>switch</code> 不同的是，<code>select</code> 中虽然也有多个 <code>case</code>，但是这些 <code>case</code> 中的表达式必须都是 Channel 的收发操作。下面的代码就展示了一个包含 Channel 收发操作的 <code>select</code> 结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述控制结构会等待 <code>c &lt;- x</code> 或者 <code>&lt;-quit</code> 两个表达式中任意一个的返回。无论哪一个表达式返回都会立刻执行 <code>case</code> 中的代码，当 <code>select</code> 中的两个 <code>case</code> 同时被触发时，就会随机选择一个 <code>case</code> 执行。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>当我们在 Go 语言中使用 <code>select</code> 控制结构时，会遇到两个有趣的现象：</p>
<ol>
<li><code>select</code> 能在 Channel 上进行非阻塞的收发操作；</li>
<li><code>select</code> 在遇到多个 Channel 同时响应时会随机挑选 <code>case</code> 执行；</li>
</ol>
<p>这两个现象是学习 <code>select</code> 时经常会遇到的，我们来深入了解具体的场景并分析这两个现象背后的设计原理。</p>
<h3 id="非阻塞的收发"><a href="#非阻塞的收发" class="headerlink" title="非阻塞的收发"></a>非阻塞的收发</h3><p>在通常情况下，<code>select</code> 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 <code>select</code> 控制结构中包含 <code>default</code> 语句，那么这个 <code>select</code> 语句在执行时会遇到以下两种情况：</p>
<ol>
<li>当存在可以收发的 Channel 时，直接处理该 Channel 对应的 <code>case</code>；</li>
<li>当不存在可以收发的 Channel 是，执行 <code>default</code> 中的语句；</li>
</ol>
<p>当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 <code>default</code> 中的代码并返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"default"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">default</span></span><br></pre></td></tr></table></figure>
<p>只要我们稍微想一下，就会发现 Go 语言设计的这个现象就非常合理。<code>select</code> 的作用就是同时监听多个 <code>case</code> 是否可以执行，如果多个 Channel 都不能执行，那么运行 <code>default</code> 中的代码也是理所当然的。</p>
<p>非阻塞的 Channel 发送和接收操作还是很有必要的，在很多场景下我们不希望向 Channel 发送消息或者从 Channel 中接收消息会阻塞当前 Goroutine，我们只是想看看 Channel 的可读或者可写状态。下面就是一个常见的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="built_in">len</span>(tasks))</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(tasks))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := tasks[i].Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errCh &lt;- err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 <code>select</code> 语句就能很好地完成这个任务。然而使用 <code>select</code> 的语法不是最原始的设计，它在最初版本使用 <code>x, ok := &lt;-c</code> 的语法实现非阻塞的收发，以下是与非阻塞收发的相关提交：</p>
<ol>
<li><a href="https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546#diff-fb0a5ae9dd70f0a43038d55c0204fdff" target="_blank" rel="external nofollow noopener noreferrer">select default</a> 提交支持了 <code>select</code> 语句中的 <code>default</code> 情况<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>；</li>
<li><a href="https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16" target="_blank" rel="external nofollow noopener noreferrer">gc: special case code for single-op blocking and non-blocking selects</a> 提交引入了基于 <code>select</code> 的非阻塞收发的特性<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>。</li>
<li><a href="https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059" target="_blank" rel="external nofollow noopener noreferrer">gc: remove non-blocking send, receive syntax</a> 提交将 <code>x, ok := &lt;-c</code> 语法删除删除<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>；</li>
<li><a href="https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c" target="_blank" rel="external nofollow noopener noreferrer">gc, runtime: replace closed(c) with x, ok := &lt;-c</a> 提交使用 <code>x, ok := &lt;-c</code> 语法替代 <code>closed(c)</code> 语法判断 Channel 的关闭状态<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a>；</li>
</ol>
<p>我们可以从上面的几个提交中看到非阻塞收发从最初到现在的演变。</p>
<h3 id="随机执行"><a href="#随机执行" class="headerlink" title="随机执行"></a>随机执行</h3><p>另一个使用 <code>select</code> 遇到的情况是同时有多个 <code>case</code> 就绪时，<code>select</code> 会选择那个 <code>case</code> 执行的问题，我们通过下面的代码可以简单了解一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Second) &#123;</span><br><span class="line">			ch &lt;- <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"case1"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"case2"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">case1</span><br><span class="line">case2</span><br><span class="line">case1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从上述代码输出的结果中我们可以看到，<code>select</code> 在遇到多个 <code>&lt;-ch</code> 同时满足可读或者可写条件时会随机选择一个 <code>case</code> 执行其中的代码。</p>
<p>这个设计是在十多年前被 <a href="https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d" target="_blank" rel="external nofollow noopener noreferrer">select</a> 提交<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:5" target="_blank" rel="external nofollow noopener noreferrer">5</a>引入并一直保留到现在的，虽然中间经历过一些修改<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:6" target="_blank" rel="external nofollow noopener noreferrer">6</a>，但是语义一直都没有改变。在上面的代码中，两个 <code>case</code> 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>select</code> 在 Go 语言的源代码中不存在对应的结构体，但是 <code>select</code> 控制结构中的 <code>case</code> 却使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体来表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	c           *hchan</span><br><span class="line">	elem        unsafe.Pointer</span><br><span class="line">	kind        <span class="keyword">uint16</span></span><br><span class="line">	pc          <span class="keyword">uintptr</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为非默认的 <code>case</code> 中都与 Channel 的发送和接收有关，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体中也包含一个 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 类型的字段存储 <code>case</code> 中使用的 Channel；除此之外，<code>elem</code> 是接收或者发送数据的变量地址、<code>kind</code> 表示 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 的种类，总共包含以下四种：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	caseNil = <span class="literal">iota</span></span><br><span class="line">	caseRecv</span><br><span class="line">	caseSend</span><br><span class="line">	caseDefault</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这四种常量分别表示不同类型的 <code>case</code>，相信它们的命名已经能够充分帮助我们理解它们的作用了，所以这里也不一一介绍了。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>select</code> 语句在编译期间会被转换成 <code>OSELECT</code> 节点。每一个 <code>OSELECT</code> 节点都会持有一组 <code>OCASE</code> 节点，如果 <code>OCASE</code> 的执行条件是空，那就意味着这是一个 <code>default</code> 节点:</p>
<p><img alt="golang-oselect-and-ocases" data-src="https://img.draveness.me/2020-01-18-15793463657473-golang-oselect-and-ocases.png"></p>
<p>上图展示的就是 <code>select</code> 语句在编译期间的结构，每一个 <code>OCASE</code> 既包含执行条件也包含满足条件后执行的代码。</p>
<p>编译器在中间代码生成期间会根据 <code>select</code> 中 <code>case</code> 的不同对控制语句进行优化，这一过程都发生在 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数中，我们在这里会分四种情况介绍处理的过程和结果：</p>
<ol>
<li><code>select</code> 不存在任何的 <code>case</code>；</li>
<li><code>select</code> 只存在一个 <code>case</code>；</li>
<li><code>select</code> 存在两个 <code>case</code>，其中一个 <code>case</code> 是 <code>default</code>；</li>
<li><code>select</code> 存在多个 <code>case</code>；</li>
</ol>
<p>上述的四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两方面分析上述情况。</p>
<h3 id="直接阻塞"><a href="#直接阻塞" class="headerlink" title="直接阻塞"></a>直接阻塞</h3><p>首先介绍的是最简单的情况，也就是当 <code>select</code> 结构中不包含任何 <code>case</code> 时编译器是如何进行处理的，我们截取 <a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数的前几行代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkselectcases</span><span class="params">(cases *Nodes)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line">	n := cases.Len()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []*Node&#123;mkcall(<span class="string">"block"</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码非常简单并且容易理解，它直接将类似 <code>select {}</code> 的空语句转换成调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.block</code></a> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">block</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonSelectNoCases, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.block</code></a> 函数的实现非常简单，它会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 让出当前 Goroutine 对处理器的使用权，传入的等待原因是 <code>waitReasonSelectNoCases</code>。</p>
<p>简单总结一下，空的 <code>select</code> 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p>
<h3 id="单一管道"><a href="#单一管道" class="headerlink" title="单一管道"></a>单一管道</h3><p>如果当前的 <code>select</code> 条件只包含一个 <code>case</code>，那么就会将 <code>select</code> 改写成 <code>if</code> 条件语句。下面展示了原始的 <code>select</code> 语句和被改写、优化后的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改写前</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok &lt;-ch: <span class="comment">// case ch &lt;- v</span></span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写后</span></span><br><span class="line"><span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-ch <span class="comment">// case ch &lt;- v</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 在处理单操作 <code>select</code> 语句时，会根据 Channel 的收发情况生成不同的语句。当 <code>case</code> 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠。</p>
<h3 id="非阻塞操作"><a href="#非阻塞操作" class="headerlink" title="非阻塞操作"></a>非阻塞操作</h3><p>当 <code>select</code> 中仅包含两个 <code>case</code>，并且其中一个是 <code>default</code> 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。<a href="https://github.com/golang/go/blob/c729116332ffb66a21dd587e3ee003cb8d0b16fe/src/cmd/compile/internal/gc/select.go#L108-L370" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkselectcases</code></a> 函数会对这种情况单独处理，不过在正式优化之前，该函数会将 <code>case</code> 中的所有 Channel 都转换成指向 Channel 的地址。我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。</p>
<h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>首先是 Channel 的发送过程，当 <code>case</code> 中表达式的类型是 <code>OSEND</code> 时，编译器会使用 <code>if/else</code> 语句和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbsend</code></a> 函数改写代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> selectnbsend(ch, i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中最重要的就是 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbsend</code></a> 函数，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/" target="_blank" rel="external nofollow noopener noreferrer">Channel</a> 一节介绍了向 Channel 发送数据的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 函数包含一个 <code>block</code> 参数，该参数会决定这一次的发送是不是阻塞的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们向 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 函数传入了 <code>false</code>，所以哪怕是不存在接收方或者缓冲区空间不足都不会阻塞当前 Goroutine 而是会直接返回。</p>
<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>由于从 Channel 中接收数据可能会返回一个或者两个值，所以接受数据的情况会比发送稍显复杂，不过改写的套路是差不多的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改写前</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v &lt;- ch: <span class="comment">// case v, ok &lt;- ch:</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写后</span></span><br><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, ch) &#123; <span class="comment">// if selectnbrecv2(&amp;v, &amp;ok, ch) &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv2</code></a> 只是对 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 返回值的处理稍有不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv2</span><span class="params">(elem unsafe.Pointer, received *<span class="keyword">bool</span>, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	selected, *received = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为接收方不需要，所以 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv</code></a> 会直接忽略返回的布尔值，而 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L705-L709" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv2</code></a> 会将布尔值回传给调用方。与 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 一样，<a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 也提供了一个 <code>block</code> 参数用于控制这一次接收是否阻塞。</p>
<h3 id="常见流程"><a href="#常见流程" class="headerlink" title="常见流程"></a>常见流程</h3><p>在默认的情况下，编译器会使用如下的流程处理 <code>select</code> 语句：</p>
<ol>
<li>将所有的 <code>case</code> 转换成包含 Channel 以及类型等信息的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体；</li>
<li>调用运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 从多个准备就绪的 Channel 中选择一个可执行的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.scase</code></a> 结构体；</li>
<li>通过 <code>for</code> 循环生成一组 <code>if</code> 语句，在语句中判断自己是不是被选中的 <code>case</code></li>
</ol>
<p>一个包含三个 <code>case</code> 的正常 <code>select</code> 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">selv := [<span class="number">3</span>]scase&#123;&#125;</span><br><span class="line">order := [<span class="number">6</span>]<span class="keyword">uint16</span></span><br><span class="line"><span class="keyword">for</span> i, cas := <span class="keyword">range</span> cases &#123;</span><br><span class="line">    c := scase&#123;&#125;</span><br><span class="line">    c.kind = ...</span><br><span class="line">    c.elem = ...</span><br><span class="line">    c.c = ...</span><br><span class="line">&#125;</span><br><span class="line">chosen, revcOK := selectgo(selv, order, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> chosen == <span class="number">0</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chosen == <span class="number">1</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chosen == <span class="number">2</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展开后的代码片段中最重要的就是用于选择待执行 <code>case</code> 的运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a>，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：</p>
<ol>
<li>执行一些必要的初始化操作并确定 <code>case</code> 的处理顺序；</li>
<li>在循环中根据 <code>case</code> 的类型做出不同的处理；</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数首先会进行执行必要的初始化操作并决定处理 <code>case</code> 的两个顺序 — 轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line">	</span><br><span class="line">	scases := cas1[:ncases:ncases]</span><br><span class="line">	pollorder := order1[:ncases:ncases]</span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">		pollorder[i] = pollorder[j]</span><br><span class="line">		pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据 Channel 的地址排序确定加锁顺序</span></span><br><span class="line">	...</span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轮询顺序 <code>pollOrder</code> 和加锁顺序 <code>lockOrder</code> 分别是通过以下的方式确认的：</p>
<ul>
<li>轮询顺序：通过 <a href="https://github.com/golang/go/blob/383b447e0da5bd1fcdc2439230b5a1d3e3402117/src/runtime/stubs.go#L114-L118" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fastrandn</code></a> 函数引入随机性；</li>
<li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；</li>
</ul>
<p>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L45-L54" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sellock</code></a> 函数会按照之前生成的加锁顺序锁定 <code>select</code> 语句中包含所有的 Channel。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当我们为 <code>select</code> 语句锁定了所有 Channel 之后就会进入 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：</p>
<ol>
<li>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；</li>
<li>将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；</li>
<li>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数会根据不同情况通过 <code>goto</code> 跳转到函数内部的不同标签执行相应的逻辑，其中包括：</p>
<ul>
<li><code>bufrecv</code>：可以从缓冲区读取数据；</li>
<li><code>bufsend</code>：可以向缓冲区写入数据；</li>
<li><code>recv</code>：可以从休眠的发送方获取数据；</li>
<li><code>send</code>：可以向休眠的接收方发送数据；</li>
<li><code>rclose</code>：可以从关闭的 Channel 读取 EOF；</li>
<li><code>sclose</code>：向关闭的 Channel 发送数据；</li>
<li><code>retc</code>：结束调用并返回；</li>
</ul>
<p>我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 <code>case</code> 并找到需要被唤起的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构，在这个阶段，我们会根据 <code>case</code> 的四种类型分别处理：</p>
<ol>
<li>```<br>caseNil<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>
case<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   不包含 Channel；</span><br><span class="line"></span><br><span class="line">   - 这种 `case` 会被跳过；</span><br><span class="line"></span><br><span class="line"><span class="attribute">2.</span></span><br></pre></td></tr></table></figure>
caseRecv<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>
case<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   会从 Channel 中接收数据；</span><br><span class="line"></span><br><span class="line">   - 如果当前 Channel 的 `sendq` 上有等待的 Goroutine，就会跳到 `recv` 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；</span><br><span class="line">   - 如果当前 Channel 的缓冲区不为空，就会跳到 `bufrecv` 标签处从缓冲区获取数据；</span><br><span class="line">   - 如果当前 Channel 已经被关闭，就会跳到 `rclose` 做一些清除的收尾工作；</span><br><span class="line"></span><br><span class="line"><span class="attribute">3.</span></span><br></pre></td></tr></table></figure>
caseSend<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>
case<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   会向 Channel 发送数据；</span><br><span class="line"></span><br><span class="line">   - 如果当前 Channel 已经被关，闭就会直接跳到 `sclose` 标签，触发 `panic` 尝试中止程序；</span><br><span class="line">   - 如果当前 Channel 的 `recvq` 上有等待的 Goroutine，就会跳到 `send` 标签向 Channel 发送数据；</span><br><span class="line">   - 如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；</span><br><span class="line"></span><br><span class="line"><span class="attribute">4.</span></span><br></pre></td></tr></table></figure>
caseDefault<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">：当前</span><br></pre></td></tr></table></figure>
case<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">为</span><br></pre></td></tr></table></figure>
default<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   语句；</span><br><span class="line"></span><br><span class="line">   - 表示前面的所有 `case` 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 `select` 结构中的收发都是非阻塞的；</span><br><span class="line"></span><br><span class="line">![golang-runtime-selectgo](https://img.draveness.me/2020-01-18-15793463657488-golang-runtime-selectgo.png)</span><br><span class="line"></span><br><span class="line">**图 5-8 运行时 selectgo 函数**</span><br><span class="line"></span><br><span class="line">第一阶段的主要职责是查找所有 `case` 中 Channel 是否有可以立刻被处理的情况。无论是在包含等待的 Goroutine 还是缓冲区中存在数据，只要满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前的 Goroutine 加入到 Channel 的 `sendq` 或者 `recvq` 队列中：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) &#123;</span><br><span class="line">	...</span><br><span class="line">	gp = getg()</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">	for _, casei := range lockorder &#123;</span><br><span class="line">		casi = int(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.c = c</span><br><span class="line"></span><br><span class="line">		switch cas.kind &#123;</span><br><span class="line">		case caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line">		case caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>除了将当前 Goroutine 对应的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体加入队列之外，这些 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 函数挂起当前 Goroutine 等待调度器的唤醒。</p>
<p><img alt="Golang-Select-Waiting" data-src="https://img.draveness.me/2020-01-19-15794018429558-Golang-Select-Waiting.png"></p>
<p><strong>图 5-9 Goroutine 上等待收发的 sudog 链表</strong></p>
<p>等到 <code>select</code> 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数的第三阶段，从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体中获取数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			casi = <span class="keyword">int</span>(casei)</span><br><span class="line">			cas = k</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist)</span><br><span class="line">		sglist = sgnext</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三次遍历全部 <code>case</code> 时，我们会先获取当前 Goroutine 接收到的参数 <code>sudog</code> 结构，我们会依次对比所有 <code>case</code> 对应的 <code>sudog</code> 结构找到被唤醒的 <code>case</code>，获取该 <code>case</code> 对应的索引并返回。</p>
<p>由于当前的 <code>select</code> 结构找到了一个 <code>case</code> 执行，那么剩下 <code>case</code> 中没有被用到的 <code>sudog</code> 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 <code>sudog</code> 从 Channel 中出队。</p>
<p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 <code>goto</code> 关键字跳转到 <code>bufrecv</code> 和 <code>bufsend</code> 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bufrecv:</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure>
<p>这里在缓冲区进行的操作和直接调用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L157-L278" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chansend</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L448-L579" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.chanrecv</code></a> 函数差不多，上述两个过程在执行结束之后都会直接跳到 <code>retc</code> 字段。</p>
<p>两个直接对 Channel 收发的情况会调用 Channel 运行时函数 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L286-L317" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.send</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L594-L635" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recv</code></a>，这两个函数会直接与处于休眠状态的 Goroutine 打交道：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">recv:</span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br></pre></td></tr></table></figure>
<p>不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：</p>
<ul>
<li>从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；</li>
<li>向一个关闭的 Channel 发送数据就会直接 <code>panic</code> 造成程序崩溃：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rclose:</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br></pre></td></tr></table></figure>
<p>总体来看，<code>select</code> 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 <code>select</code> 多出了 <code>default</code> 关键字所以会支持非阻塞的收发。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们简单总结一下 <code>select</code> 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 <code>select</code> 语句进行优化，它会根据 <code>select</code> 中 <code>case</code> 的不同选择不同的优化路径：</p>
<ol>
<li><p>空的 <code>select</code> 语句会被转换成 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/select.go#L104-L106" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.block</code></a> 函数的调用，直接挂起当前 Goroutine；</p>
</li>
<li><p>如果</p>
</li>
</ol>
   <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br></pre></td></tr></table></figure>
<p>   语句中只包含一个</p>
   <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br></pre></td></tr></table></figure>
<p>   ，就会被转换成</p>
   <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">if ch == nil &#123; <span class="keyword">block </span>&#125;<span class="comment">; n;</span></span><br></pre></td></tr></table></figure>
<p>   表达式；</p>
<ul>
<li>首先判断操作的 Channel 是不是空的；</li>
<li>然后执行 <code>case</code> 结构中的内容；</li>
</ul>
<ol>
<li><p>如果 <code>select</code> 语句中只包含两个 <code>case</code> 并且其中一个是 <code>default</code>，那么会使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L683-L686" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbrecv</code></a> 和 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L662-L664" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectnbsend</code></a> 非阻塞地执行收发操作；</p>
</li>
<li><p>在默认情况下会通过 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数获取执行 <code>case</code> 的索引，并通过多个 <code>if</code> 语句执行对应 <code>case</code> 中的代码；</p>
</li>
</ol>
<p>在编译器已经对 <code>select</code> 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.selectgo</code></a> 函数，该函数会按照以下的流程执行：</p>
<ol>
<li><p>随机生成一个遍历的轮询顺序 <code>pollOrder</code> 并根据 Channel 地址生成锁定顺序 <code>lockOrder</code>；</p>
</li>
<li><p>根据</p>
</li>
</ol>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pollOrder</span></span><br></pre></td></tr></table></figure>
<p>   遍历所有的</p>
   <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br></pre></td></tr></table></figure>
<p>   查看是否有可以立刻处理的 Channel；</p>
<ol>
<li>如果存在就直接获取 <code>case</code> 对应的索引并返回；</li>
<li>如果不存在就会创建 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 <a href="https://github.com/golang/go/blob/c112289ee4141ebc31db50328c355b01278b987b/src/runtime/proc.go#L287-L305" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopark</code></a> 挂起当前 Goroutine 等待调度器的唤醒；</li>
</ol>
<ol>
<li>当调度器唤醒当前 Goroutine 时就会再次按照 <code>lockOrder</code> 遍历所有的 <code>case</code>，从中查找需要被处理的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L342-L368" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.sudog</code></a> 结构对应的索引；</li>
</ol>
<p><code>select</code> 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Make 与 New</title>
    <url>/posts/9e0b725c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — <code>make</code> 和 <code>new</code>。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>，但是它们两者能够初始化的却有较大的不同。</p>
<ul>
<li><code>make</code> 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>；</li>
<li><code>new</code> 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>；</li>
</ul>
<a id="more"></a>
<p>我们在代码中往往都会使用如下所示的语句初始化这三类基本类型，这三个语句分别返回了不同类型的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>slice</code> 是一个包含 <code>data</code>、<code>cap</code> 和 <code>len</code> 的私有结构体 <a href="https://github.com/golang/go/blob/a5026af57c7934f0856cfd4b539a7859d85a0474/src/internal/reflectlite/value.go#L389-L393" target="_blank" rel="external nofollow noopener noreferrer"><code>internal/reflectlite.sliceHeader</code></a>；</li>
<li><code>hash</code> 是一个指向 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L115-L129" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hmap</code></a> 结构体的指针；</li>
<li><code>ch</code> 是一个指向 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/chan.go#L32-L51" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.hchan</code></a> 结构体的指针；</li>
</ol>
<p>相比与复杂的 <code>make</code> 关键字，<code>new</code> 的功能就很简单了，它只能接收一个类型作为参数然后返回一个指向该类型的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">int</span></span><br><span class="line">i := &amp;v</span><br></pre></td></tr></table></figure>
<p>上述代码片段中的两种不同初始化方法是等价的，它们都会创建一个指向 <code>int</code> 零值的指针。</p>
<p><img alt="golang-make-and-ne" data-src="https://img.draveness.me/golang-make-and-new.png"></p>
<p>接下来我们将分别介绍 <code>make</code> 和 <code>new</code> 在初始化不同数据结构时的过程，我们会从编译期间和运行时两个不同阶段理解这两个关键字的原理，不过由于前面的章节已经详细地分析过 <code>make</code> 的原理，所以这里会将重点放在另一个关键字 <code>new</code> 上。</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>在前面的章节中我们已经谈到过 <code>make</code> 在创建切片、哈希表和 Channel 的具体过程，所以在这一小节，我们只是会简单提及 <code>make</code> 相关的数据结构的初始化原理。</p>
<p><img alt="golang-make-typecheck" data-src="https://img.draveness.me/golang-make-typecheck.png"></p>
<p>在编译期间的<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/" target="_blank" rel="external nofollow noopener noreferrer">类型检查</a>阶段，Go 语言就将代表 <code>make</code> 关键字的 <code>OMAKE</code> 节点根据参数类型的不同转换成了 <code>OMAKESLICE</code>、<code>OMAKEMAP</code> 和 <code>OMAKECHAN</code> 三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>编译器会在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>阶段通过以下两个函数处理该关键字：</p>
<ol>
<li><p><a href="https://github.com/golang/go/blob/316fd8cc4a7fab2e1bb45848bc30ea8b8a0b231a/src/cmd/compile/internal/gc/walk.go#L1930-L1940" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.callnew</code></a> 函数会将关键字转换成 <code>ONEWOBJ</code> 类型的节点<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>；</p>
</li>
<li><p><code>cmd/compile/internal/gc.state.expr</code></p>
</li>
</ol>
<p>   函数会根据申请空间的大小分两种情况处理：</p>
<ol>
<li>如果申请的空间为 0，就会返回一个表示空指针的 <code>zerobase</code> 变量；</li>
<li>在遇到其他情况时会将关键字转换成 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callnew</span><span class="params">(t *types.Type)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	n := nod(ONEWOBJ, typename(t), <span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> ONEWOBJ:</span><br><span class="line">		<span class="keyword">if</span> n.Type.Elem().Size() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> s.newValue1A(ssa.OpAddr, n.Type, zerobaseSym, s.sb)</span><br><span class="line">		&#125;</span><br><span class="line">		typ := s.expr(n.Left)</span><br><span class="line">		vv := s.rtcall(newobject, <span class="literal">true</span>, []*types.Type&#123;n.Type&#125;, typ)</span><br><span class="line">		<span class="keyword">return</span> vv[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，无论是直接使用 <code>new</code>，还是使用 <code>var</code> 初始化变量，它们在编译器看来就是 <code>ONEWOBJ</code> 和 <code>ODCL</code> 节点。这些节点在这一阶段都会被 <a href="https://github.com/golang/go/blob/316fd8cc4a7fab2e1bb45848bc30ea8b8a0b231a/src/cmd/compile/internal/gc/walk.go#L115-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkstmt</code></a> 转换成通过 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数在堆上申请内存：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkstmt</span><span class="params">(n *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> ODCL:</span><br><span class="line">		v := n.Left</span><br><span class="line">		<span class="keyword">if</span> v.Class() == PAUTOHEAP &#123;</span><br><span class="line">			<span class="keyword">if</span> prealloc[v] == <span class="literal">nil</span> &#123;</span><br><span class="line">				prealloc[v] = callnew(v.Type)</span><br><span class="line">			&#125;</span><br><span class="line">			nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])</span><br><span class="line">			nn.SetColas(<span class="literal">true</span>)</span><br><span class="line">			nn = typecheck(nn, ctxStmt)</span><br><span class="line">			<span class="keyword">return</span> walkstmt(nn)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> ONEW:</span><br><span class="line">		<span class="keyword">if</span> n.Esc == EscNone &#123;</span><br><span class="line">			r := temp(n.Type.Elem())</span><br><span class="line">			r = nod(OAS, r, <span class="literal">nil</span>)</span><br><span class="line">			r = typecheck(r, ctxStmt)</span><br><span class="line">			init.Append(r)</span><br><span class="line">			r = nod(OADDR, r.Left, <span class="literal">nil</span>)</span><br><span class="line">			r = typecheck(r, ctxExpr)</span><br><span class="line">			n = r</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			n = callnew(n.Type.Elem())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这也不是绝对的，如果通过 <code>var</code> 或者 <code>new</code> 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上。</p>
<p><a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L1162-L1164" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.newobject</code></a> 函数会是获取传入类型占用空间的大小，调用 <a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L889-L1132" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mallocgc</code></a> 在堆上申请一片内存空间并返回指向这片内存空间的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/5042317d6919d4c84557e04be35130430e8d1dd4/src/runtime/malloc.go#L889-L1132" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.mallocgc</code></a> 函数的实现大概有 200 多行代码，我们会在后面的章节中详细分析 Go 语言的内存管理机制。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到了最后，简单总结一下 Go 语言中 <code>make</code> 和 <code>new</code> 关键字的实现原理，<code>make</code> 关键字的作用是创建切片、哈希表和 Channel 等内置的数据结构，而 <code>new</code> 的作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>make</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Panic/Recover</title>
    <url>/posts/ecc392db/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本节将分析两个经常成对出现的关键字 <code>panic</code> 和 <code>recover</code>。这两个关键字都与 <code>defer</code> 有千丝万缕的联系，也都是 Go 语言中的内置函数，但是提供的功能却是互补的：</p>
<ul>
<li><code>panic</code> 能够改变程序的控制流，函数调用<code>panic</code> 时会立刻停止执行函数的其他代码，并在执行结束后在当前 Goroutine 中递归执行调用方的延迟函数调用 <code>defer</code>；</li>
<li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥任何作用；</li>
</ul>
<a id="more"></a>
<p><img alt="golang-panic" data-src="https://img.draveness.me/2020-01-19-15794253208982-golang-panic.png"></p>
<p>Andrew Gerrand 写过的一篇名为 <a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">Defer, Panic, and Recover</a> 的博客很好地介绍了这三个关键字的不同作用以及它们的关系<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>我们先通过几个例子了解一下使用 <code>panic</code> 和 <code>recover</code> 关键字时遇到的一些现象，部分现象也与上一节分析的 <code>defer</code> 关键字有关：</p>
<ul>
<li><code>panic</code> 只会触发当前 Goroutine 的延迟函数调用；</li>
<li><code>recover</code> 只有在 <code>defer</code> 函数中调用才会生效；</li>
<li><code>panic</code> 允许在 <code>defer</code> 中嵌套多次调用；</li>
</ul>
<h3 id="跨协程失效"><a href="#跨协程失效" class="headerlink" title="跨协程失效"></a>跨协程失效</h3><p>首先要展示的例子就是 <code>panic</code> 只会触发当前 Goroutine 的延迟函数调用。这里有一段简单的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">"in main"</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">"in goroutine"</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">""</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in goroutine</span><br><span class="line"><span class="built_in">panic</span>:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当我们运行这段代码时会发现 <code>main</code> 函数中的 <code>defer</code> 语句并没有执行，执行的只有当前 Goroutine 中的 <code>defer</code>。</p>
<p>上一节我们曾经介绍过 <code>defer</code> 关键字对应的 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 会将延迟调用函数与调用方所在 Goroutine 进行关联。所以当程序发生崩溃时只会调用当前 Goroutine 的延迟调用函数也是非常合理的。</p>
<p><img alt="golang-panic-and-defers" data-src="https://img.draveness.me/2020-01-19-15794253176199-golang-panic-and-defers.png"></p>
<p>如上图所示，多个 Goroutine 之间没有太多的关联，一个 Goroutine 在 <code>panic</code> 时也不应该执行其他 Goroutine 的延迟函数。</p>
<h3 id="失效的崩溃恢复"><a href="#失效的崩溃恢复" class="headerlink" title="失效的崩溃恢复"></a>失效的崩溃恢复</h3><p>初学 Go 语言的读者可能会写出下面的代码，在主程序中调用 <code>recover</code> 试图中止程序的崩溃，但是从运行的结果中我们也能看出，如下所示的程序依然没有正常退出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line">	<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"unknown err"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in main</span><br><span class="line"><span class="built_in">panic</span>: unknown err</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	...</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>仔细分析一下这个过程就能理解这种现象背后的原因，<code>recover</code> 只有在发生 <code>panic</code> 之后调用才会生效。然而在上面的控制流中，<code>recover</code> 是在 <code>panic</code> 之前调用的，并不满足生效的条件，所以我们需要在 <code>defer</code> 中使用 <code>recover</code> 关键字。</p>
<h3 id="嵌套崩溃"><a href="#嵌套崩溃" class="headerlink" title="嵌套崩溃"></a>嵌套崩溃</h3><p>Go 语言中的 <code>panic</code> 是可以多次嵌套调用的。一些熟悉 Go 语言的读者很可能也不知道这个知识点，如下所示的代码就展示了如何在 <code>defer</code> 函数中多次调用 <code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"panic again and again"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"panic again"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic once"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">in main</span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> once</span><br><span class="line">	<span class="built_in">panic</span>: <span class="built_in">panic</span> again</span><br><span class="line">	<span class="built_in">panic</span>: <span class="built_in">panic</span> again and again</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">...</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>从上述程序的输出，我们可以确定程序多次调用 <code>panic</code> 也不会影响 <code>defer</code> 函数的正常执行。所以使用 <code>defer</code> 进行收尾的工作一般来说都是安全的。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>panic</code> 关键字在 Go 语言的源代码是由数据结构 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 表示的。每当我们调用 <code>panic</code> 都会创建一个如下所示的数据结构存储相关信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">	argp      unsafe.Pointer</span><br><span class="line">	arg       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	link      *_panic</span><br><span class="line">	recovered <span class="keyword">bool</span></span><br><span class="line">	aborted   <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	pc        <span class="keyword">uintptr</span></span><br><span class="line">	sp        unsafe.Pointer</span><br><span class="line">	goexit    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>argp</code> 是指向 <code>defer</code> 调用时参数的指针；</li>
<li><code>arg</code> 是调用 <code>panic</code> 时传入的参数；</li>
<li><code>link</code> 指向了更早调用的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构；</li>
<li><code>recovered</code> 表示当前 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 是否被 <code>recover</code> 恢复；</li>
<li><code>aborted</code> 表示当前的 <code>panic</code> 是否被强行终止；</li>
</ol>
<p>从数据结构中的 <code>link</code> 字段我们就可以推测出以下的结论 — <code>panic</code> 函数可以被连续多次调用，它们之间通过 <code>link</code> 的关联形成一个链表。</p>
<p>结构体中的 <code>pc</code>、<code>sp</code> 和 <code>goexit</code> 三个字段都是为了修复 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L581-L656" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.Goexit</code></a> 的问题引入的<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>。该函数能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 <code>defer</code> 中的 <code>panic</code> 和 <code>recover</code> 取消<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:3" target="_blank" rel="external nofollow noopener noreferrer">3</a>，引入这三个字段的目的就是为了解决这个问题。</p>
<h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>首先了解一下 <code>panic</code> 函数是如何终止程序的。编译器会将关键字 <code>panic</code> 转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L887-L1062" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopanic</code></a>，该函数的执行过程包含以下几个步骤：</p>
<ol>
<li>创建新的 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构并添加到所在 Goroutine <code>_panic</code> 链表的最前面；</li>
<li>在循环中不断从当前 Goroutine 的 <code>_defer</code> 中链表获取 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 并调用 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L496-L526" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.reflectcall</code></a> 运行延迟调用函数；</li>
<li>调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1185-L1220" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fatalpanic</code></a> 中止整个程序；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> p _panic</span><br><span class="line">	p.arg = e</span><br><span class="line">	p.link = gp._panic</span><br><span class="line">	gp._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		d := gp._defer</span><br><span class="line">		<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		d._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">		reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line"></span><br><span class="line">		d._panic = <span class="literal">nil</span></span><br><span class="line">		d.fn = <span class="literal">nil</span></span><br><span class="line">		gp._defer = d.link</span><br><span class="line"></span><br><span class="line">		freedefer(d)</span><br><span class="line">		<span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fatalpanic(gp._panic)</span><br><span class="line">	*(*<span class="keyword">int</span>)(<span class="literal">nil</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们在上述函数中省略了三部分比较重要的代码：</p>
<ol>
<li><p>恢复程序的 <code>recover</code> 分支中的代码；</p>
</li>
<li><p>通过内联优化</p>
</li>
</ol>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">defer</span></span><br></pre></td></tr></table></figure>
<p>   调用性能的代码</p>
<p>   <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/#fn:4" target="_blank" rel="external nofollow noopener noreferrer">4</a></p>
<p>   ；</p>
<ul>
<li><a href="https://github.com/golang/go/commit/be64a19d99918c843f8555aad580221207ea35bc" target="_blank" rel="external nofollow noopener noreferrer">runtime: make defers low-cost through inline code and extra funcdata</a></li>
</ul>
<ol>
<li>修复</li>
</ol>
<p>   <code>runtime.Goexit</code></p>
<p>   异常情况的代码；</p>
<ul>
<li><a href="https://github.com/golang/go/commit/7dcd343ed641d3b70c09153d3b041ca3fe83b25e" target="_blank" rel="external nofollow noopener noreferrer">runtime: ensure that Goexit cannot be aborted by a recursive panic/recover</a></li>
</ul>
<p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1185-L1220" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.fatalpanic</code></a> 实现了无法被恢复的程序崩溃，它在中止程序之前会通过 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L679-L695" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.printpanics</code></a> 打印出全部的 <code>panic</code> 消息以及调用时传入的参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fatalpanic</span><span class="params">(msgs *_panic)</span></span> &#123;</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	sp := getcallersp()</span><br><span class="line">	gp := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> startpanic_m() &amp;&amp; msgs != <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.Xadd(&amp;runningPanicDefers, <span class="number">-1</span>)</span><br><span class="line">		printpanics(msgs)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dopanic_m(gp, pc, sp) &#123;</span><br><span class="line">		crash()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印 <code>panic</code> 消息之后会通过 <a href="https://github.com/golang/go/blob/cbaa666682386fe5350bf87d7d70171704c90fe4/src/runtime/sys_darwin.go#L231-L233" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.exit</code></a> 退出当前程序并返回错误码 2，而程序的正常退出也是通过 <a href="https://github.com/golang/go/blob/cbaa666682386fe5350bf87d7d70171704c90fe4/src/runtime/sys_darwin.go#L231-L233" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.exit</code></a> 函数实现的。</p>
<h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>到这里我们已经掌握了 <code>panic</code> 退出程序的过程，接下来将分析 <code>defer</code> 中的 <code>recover</code> 是如何中止程序崩溃的。编译器会将关键字 <code>recover</code> 转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gorecover</code></a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="keyword">uintptr</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	p := gp._panic</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.recovered &amp;&amp; argp == <span class="keyword">uintptr</span>(p.argp) &#123;</span><br><span class="line">		p.recovered = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> p.arg</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现非常简单，如果当前 Goroutine 没有调用 <code>panic</code>，那么该函数会直接返回 <code>nil</code>，这也是崩溃恢复在非 <code>defer</code> 中调用会失效的原因。</p>
<p>在正常情况下，它会修改 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构体的 <code>recovered</code> 字段，<a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gorecover</code></a> 函数本身不包含恢复程序的逻辑，程序的恢复也是由 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L887-L1062" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gopanic</code></a> 函数负责的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 执行延迟调用函数，可能会设置 p.recovered = true</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		pc := d.pc</span><br><span class="line">		sp := unsafe.Pointer(d.sp)</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">			gp._panic = p.link</span><br><span class="line">			<span class="keyword">for</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">				gp._panic = gp._panic.link</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gp._panic == <span class="literal">nil</span> &#123;</span><br><span class="line">				gp.sig = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			gp.sigcode0 = <span class="keyword">uintptr</span>(sp)</span><br><span class="line">			gp.sigcode1 = pc</span><br><span class="line">			mcall(recovery)</span><br><span class="line">			throw(<span class="string">"recovery failed"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述这段代码也省略了 <code>defer</code> 的内联优化，它从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体中取出了程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1132-L1151" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recovery</code></a> 函数触发 Goroutine 的调度，调度之前会准备好 <code>sp</code>、<code>pc</code> 以及函数的返回值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recovery</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	sp := gp.sigcode0</span><br><span class="line">	pc := gp.sigcode1</span><br><span class="line"></span><br><span class="line">	gp.sched.sp = sp</span><br><span class="line">	gp.sched.pc = pc</span><br><span class="line">	gp.sched.lr = <span class="number">0</span></span><br><span class="line">	gp.sched.ret = <span class="number">1</span></span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在调用 <code>defer</code> 关键字时，调用时的栈指针 <code>sp</code> 和程序计数器 <code>pc</code> 就已经存储到了 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._defer</code></a> 结构体中，这里的 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/asm_386.s#L301-L314" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gogo</code></a> 函数会跳回 <code>defer</code> 关键字调用的位置。</p>
<p><a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1132-L1151" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.recovery</code></a> 在调度过程中会将函数的返回值设置成 1。从 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 的注释中我们会发现，当 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferproc</code></a> 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// deferproc returns 0 normally.</span></span><br><span class="line">	<span class="comment">// a deferred func that stops a panic</span></span><br><span class="line">	<span class="comment">// makes the deferproc return 1.</span></span><br><span class="line">	<span class="comment">// the code the compiler generates always</span></span><br><span class="line">	<span class="comment">// checks the return value and jumps to the</span></span><br><span class="line">	<span class="comment">// end of the function if deferproc returns != 0.</span></span><br><span class="line">	return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳转到 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.deferreturn</code></a> 函数之后，程序就已经从 <code>panic</code> 中恢复了并执行正常的逻辑，而 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.gorecover</code></a> 函数也能从 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L891-L900" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime._panic</code></a> 结构体中取出了调用 <code>panic</code> 时传入的 <code>arg</code> 参数并返回给调用方。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析程序的崩溃和恢复过程比较棘手，代码不是特别容易理解。我们在本节的最后还是简单总结一下程序崩溃和恢复的过程：</p>
<ol>
<li><p>编译器会负责做转换关键字的工作；</p>
<ol>
<li>将 <code>panic</code> 和 <code>recover</code> 分别转换成 <code>runtime.gopanic</code> 和 <code>runtime.gorecover</code>；</li>
<li>将 <code>defer</code> 转换成 <code>deferproc</code> 函数；</li>
<li>在调用 <code>defer</code> 的函数末尾调用 <code>deferreturn</code> 函数；</li>
</ol>
</li>
<li><p>在运行过程中遇到 <code>gopanic</code> 方法时，会从 Goroutine 的链表依次取出 <code>_defer</code> 结构体并执行；</p>
</li>
<li><p>如果调用延迟执行函数时遇到了</p>
</li>
</ol>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gorecover</span></span><br></pre></td></tr></table></figure>
<p>   就会将</p>
   <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">_panic</span>.</span></span>recovered</span><br></pre></td></tr></table></figure>
<p>   标记成</p>
   <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>   并返回</p>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">panic</span></span><br></pre></td></tr></table></figure>
<p>   的参数；</p>
<ol>
<li>在这次调用结束之后，<code>gopanic</code> 会从 <code>_defer</code> 结构体中取出程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <code>recovery</code> 函数进行恢复程序；</li>
<li><code>recovery</code> 会根据传入的 <code>pc</code> 和 <code>sp</code> 跳转回 <code>deferproc</code>；</li>
<li>编译器自动生成的代码会发现 <code>deferproc</code> 的返回值不为 0，这时会跳回 <code>deferreturn</code> 并恢复到正常的执行流程；</li>
</ol>
<ol>
<li>如果没有遇到 <code>gorecover</code> 就会依次遍历所有的 <code>_defer</code> 结构，并在最后调用 <code>fatalpanic</code> 中止程序、打印 <code>panic</code> 的参数并返回错误码 <code>2</code>；</li>
</ol>
<p>分析的过程涉及了很多语言底层的知识，源代码阅读起来也比较晦涩，其中充斥着反常规的控制流程，通过程序计数器来回跳转，不过对于我们理解程序的执行流程还是很有帮助。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/" target="_blank" rel="external nofollow noopener noreferrer">Dive into stack and defer/panic/recover in go</a></li>
<li><a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">Defer, Panic, and Recover</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>panic</tag>
        <tag>recover</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Context</title>
    <url>/posts/d345cf6d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在Go语言中，控制并发有两种经典的方式，一种是WaitGroup, 另外一种就是Context。</p>
<a id="more"></a>
<h2 id="什么是WaitGroup"><a href="#什么是WaitGroup" class="headerlink" title="什么是WaitGroup"></a>什么是WaitGroup</h2><p>WaitGroup是一种控制并发的方式，通过控制多个Go Routine同时完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        fmt.Println(<span class="string">"routine 1 done"</span>)</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        fmt.Println(<span class="string">"routine 2 done"</span>)</span><br><span class="line">        wg.Done()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"all routine done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用WaitGroup的情景在于：多个goroutine协同做同一件事情，只有当所有的goroutine都完成时，这件事情才算完成。</p>
<p>但是实际的业务里面，可能还会碰到这么一种场景：需要我们主动的通知某一个goroutine结束</p>
<blockquote>
<p>举个例子，我们开启一个后台goroutine一直做一件事情，比如监控，现在不需要了，就需要通知这个监控goroutine结束，不然它会一直跑，产生泄露</p>
</blockquote>
<h2 id="chan通知"><a href="#chan通知" class="headerlink" title="chan通知"></a>chan通知</h2><p>一个goroutine启动之后，我们是无法控制它的，大部分情况下是等待自己结束。为了在通知这个goroutine结束，经常采用的方式是chan+select。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;- stop:</span><br><span class="line">                fmt.Println(<span class="string">"monitor exited..."</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">"monitoring..."</span>)</span><br><span class="line">                time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"It's time to stop monitoring"</span>)</span><br><span class="line">    stop &lt;- <span class="literal">true</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个<code>stop</code>的channel，在后台的goroutine中，我们使用select判断<code>stop</code>是否可以接收到值，如果可以接收到，就表示可以退出停止了；如果没有接收到，就会执行default里面的逻辑，继续监控。</p>
<p>这样一来，我们可以在其他的goroutine中给<code>stop</code>发送值了，比如这里是在main goroutine中发送的控制这个监控的goroutine结束。</p>
<p>这种chan+select的方式，是一种比较优雅地结束goroutine的方式。不过他也有自己的局限性，如果有很多个goroutine都需要控制结束怎么办？如果这些goroutine中又衍生了更多的goroutine怎么办呢？如果一层一层的无穷尽的goroutine呢？</p>
<p>这种场景下仅仅用channel是不够的，所以我们引入了context。</p>
<h2 id="初识Context"><a href="#初识Context" class="headerlink" title="初识Context"></a>初识Context</h2><p>上面的场景其实也很常见，比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。所以我们需要一种可以跟踪goroutine的方案，才能达到控制他们的目的，这就是Go语言的Context做的事情，称之为goroutine的上下文</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">                fmt.Println(<span class="string">"monitor exited..."</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">"monitoring..."</span>)</span><br><span class="line">                time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"It's time to stop monitor"</span>)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context控制多个goroutine"><a href="#Context控制多个goroutine" class="headerlink" title="Context控制多个goroutine"></a>Context控制多个goroutine</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> watch(ctx, <span class="string">"monitor1"</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(ctx, <span class="string">"monitor2"</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(ctx, <span class="string">"monitor3"</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"It's time to stop monitor"</span>)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            fmt.Println(name, <span class="string">"monitor exited"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(name, <span class="string">"goroutine monitoring"</span>)</span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h2><p>标准库中Context定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Context是一个interface，在Go语言里面，interface是一个使用非常广泛的结构，它可以接纳任何类型。Context定义很简单，一共有4个方法</p>
<ul>
<li>Deadline方法是获取设置的截止时间的意思，第一个返回值是截止时间，到了这个时间点，Context会自动发起取消请求。第二个返回值<code>ok == false</code>表示没有设置截止时间，如果需要取消的话，需要调用取消函数取消</li>
<li>Done方法返回一个只读的channel，类型是struct{}。在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后Err方法会返回一个错误，告知为什么Context被取消</li>
<li>Err方法返回取消的原因</li>
<li>Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。</li>
</ul>
<h2 id="Context的实现方法"><a href="#Context的实现方法" class="headerlink" title="Context的实现方法"></a>Context的实现方法</h2><p>Context虽然是一个接口，但是并不需要使用方实现。golang内置的context包，已经帮我们实现了2个方法，一般在代码中都是以这两个(Background和TODO)作为最顶层的parent context，然后在衍生出子context。这些Context对象形成一棵树：当一个Context对象被取消时，继承自它所有的Context都会被取消。</p>
<p>下面是golang的标准库中的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> background:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"context.Background"</span></span><br><span class="line">    <span class="keyword">case</span> todo:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"context.TODO"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"unknown empty Context"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background returns a non-nil, empty Context. It is never canceled, has no</span></span><br><span class="line"><span class="comment">// values, and has no deadline. It is typically used by the main function,</span></span><br><span class="line"><span class="comment">// initialization, and tests, and as the top-level Context for incoming</span></span><br><span class="line"><span class="comment">// requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO returns a non-nil, empty Context. Code should use context.TODO when</span></span><br><span class="line"><span class="comment">// it's unclear which Context to use or it is not yet available (because the</span></span><br><span class="line"><span class="comment">// surrounding function has not yet been extended to accept a Context</span></span><br><span class="line"><span class="comment">// parameter). TODO is recognized by static analysis tools that determine</span></span><br><span class="line"><span class="comment">// whether Contexts are propagated correctly in a program.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context的继承"><a href="#Context的继承" class="headerlink" title="Context的继承"></a>Context的继承</h2><p>有了以上的根Context，那么如何衍生更多的子Context呢？这就要靠context包为我们提供的With系列函数了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>
<p>通过这些函数，就创建了一棵Context，树的每个节点都可以有更多的子节点，节点层级可以有任意多个</p>
<ul>
<li><code>WithCancel</code>函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context</li>
<li><code>WithDeadline</code>函数，和WithCancel差不多，他会传递一个截至时间参数，意味着到了这个时间点，会自动取消Context。当然我们也可以不等到这个时候，可以提前通过取消函数进行取消</li>
<li><code>WithTimeout</code>和<code>WithDeadline</code>差不多，只是表示的是多长时间后取消Context</li>
<li><code>WithValue</code>函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到。这是我们实际中经常要用到的技巧，一般我们想要通过上下文传递数据时，可以通过这个方法，比如我们需要trace追踪系统调用栈的时候。</li>
</ul>
<h2 id="Context使用原则和技巧"><a href="#Context使用原则和技巧" class="headerlink" title="Context使用原则和技巧"></a>Context使用原则和技巧</h2><ul>
<li>不要把Context放在结构体中，要以参数的方式传递，parent Context一般是Background</li>
<li>应该要把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名都统一，如ctx</li>
<li>给一个函数方法传递Context的时候，不要传递nil，否则在trace追踪的时候，就会断了连接</li>
<li>Context的Value相关方法应该传递必须的数据，不要什么数据都是用这个传递</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
<li>可以把一个Context对象传递给任意个数的goroutine，对他执行取消操作时，所有的goroutine都会接收到取消信号</li>
</ul>
<h2 id="Context常用方法实例"><a href="#Context常用方法实例" class="headerlink" title="Context常用方法实例"></a>Context常用方法实例</h2><h3 id="调用Context-Done方法取消"><a href="#调用Context-Done方法取消" class="headerlink" title="调用Context Done方法取消"></a>调用Context Done方法取消</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, err := DoSomething(ctx)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        <span class="keyword">case</span> out &lt;- v:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过context-WithValue来传值"><a href="#通过context-WithValue来传值" class="headerlink" title="通过context.WithValue来传值"></a>通过context.WithValue来传值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background)</span><br><span class="line">    valueCtx := context.WithValue(ctx, key, <span class="string">"add value"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            fmt.Println(ctx.Value(key), <span class="string">"is canceled"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(ctx.Value(key), <span class="string">"int goroutine"</span>)</span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时取消context-WithTimeout"><a href="#超时取消context-WithTimeout" class="headerlink" title="超时取消context.WithTimeout"></a>超时取消context.WithTimeout</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- time.After(time.Second * <span class="number">2</span>):</span><br><span class="line">            fmt.Println(<span class="string">"Doing some work"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">"Cancel the context"</span>, i)</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background, time.Second * <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Hey, I'm going to do some work"</span>)</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> work(ctx)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Finished, I'm going home"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="截至时间取消context-WithDeadline"><a href="#截至时间取消context-WithDeadline" class="headerlink" title="截至时间取消context.WithDeadline"></a>截至时间取消context.WithDeadline</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Now().Add(time.Second * <span class="number">1</span>)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Backend(), d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even though ctx will be expired, it is good practice to call its</span></span><br><span class="line">    <span class="comment">// cancelation function in any case. Failure to do so may keep the</span></span><br><span class="line">    <span class="comment">// context and its parent alive longer than necessary.</span></span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(time.Second * <span class="number">2</span>):</span><br><span class="line">        fmt.Println(<span class="string">"OverSleep"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="external nofollow noopener noreferrer">go实战笔记|go context</a></li>
<li><a href="https://blog.golang.org/context" target="_blank" rel="external nofollow noopener noreferrer">golang context</a></li>
</ul>
<p>上下文 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 是用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系。<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 是 Go 语言在 1.7 版本中引入标准库的接口<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>，该接口定义了四个需要实现的方法，其中包括：</p>
<ol>
<li><p><code>Deadline</code> — 返回 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 被取消的时间，也就是完成工作的截止日期；</p>
</li>
<li><p><code>Done</code> — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</p>
</li>
<li><p>```<br>Err</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">— 返回</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">`context.Context`</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">结束的原因，它只会在</span><br></pre></td></tr></table></figure>
<p>Done</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   返回的 Channel 被关闭时才会返回非空的值；</span><br><span class="line"></span><br><span class="line">   1. 如果 [`context.Context`](https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154) 被取消，会返回 `Canceled` 错误；</span><br><span class="line">   2. 如果 [`context.Context`](https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154) 超时，会返回 `DeadlineExceeded` 错误；</span><br><span class="line"></span><br><span class="line">4. `Value` — 从 [`context.Context`](https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154) 中获取键对应的值，对于同一个上下文来说，多次调用 `Value` 并传入相同的 `Key` 会返回相同的结果，该方法可以用来传递请求特定的数据；</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type Context interface &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok bool)</span><br><span class="line">	Done() &lt;-chan struct&#123;&#125;</span><br><span class="line">	Err() error</span><br><span class="line">	Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://github.com/golang/go/tree/master/src/context" target="_blank" rel="external nofollow noopener noreferrer"><code>context</code></a> 包中提供的 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Background</code></a>、<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>context.TODO</code></a>、<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithDeadline</code></a> 和 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L513-L521" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithValue</code></a> 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们的工作原理。</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的最大作用。Go 服务的每一个请求的都是通过单独的 Goroutine 处理的<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:2" target="_blank" rel="external nofollow noopener noreferrer">2</a>，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。</p>
<p>如下图所示，我们可能会创建多个 Goroutine 来处理一次请求，而 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的作用就是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。</p>
<p><img alt="golang-context-usage" data-src="https://img.draveness.me/golang-context-usage.png"></p>
<p><strong>图 6-1 Context 与 Goroutine 树</strong></p>
<p>每一个 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 都会从最顶层的 Goroutine 一层一层传递到最下层。<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。</p>
<p><img alt="golang-without-context" data-src="https://img.draveness.me/golang-without-context.png"></p>
<p><strong>图 6-2 不使用 Context 同步信号</strong></p>
<p>如上图所示，当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗：</p>
<p><img alt="golang-with-context" data-src="https://img.draveness.me/golang-with-context.png"></p>
<p><strong>图 6-3 使用 Context 同步信号</strong></p>
<p>我们可以通过一个代码片段了解 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 是如何对信号进行同步的。在这段代码中，我们创建了一个过期时间为 1s 的上下文，并向上下文传入 <code>handle</code> 函数，该方法会使用 500ms 的时间处理传入的『请求』：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> handle(ctx, <span class="number">500</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">"main"</span>, ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">"handle"</span>, ctx.Err())</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">		fmt.Println(<span class="string">"process request with"</span>, duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为过期时间大于处理时间，所以我们有足够的时间处理该『请求』，运行上述代码会打印出如下所示的内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run context.<span class="keyword">go</span></span><br><span class="line">process request with <span class="number">500</span>ms</span><br><span class="line">main context deadline exceeded</span><br></pre></td></tr></table></figure>
<p><code>handle</code> 函数没有进入超时的 <code>select</code> 分支，但是 <code>main</code> 函数的 <code>select</code> 却会等待 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的超时并打印出 <code>main context deadline exceeded</code>。</p>
<p>如果我们将处理『请求』时间增加至 1500ms，整个程序都会因为上下文的过期而被中止，：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run context.<span class="keyword">go</span></span><br><span class="line">main context deadline exceeded</span><br><span class="line">handle context deadline exceeded</span><br></pre></td></tr></table></figure>
<p>相信这两个例子能够帮助各位读者理解 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的使用方法和设计原理 — 多个 Goroutine 同时订阅 <code>ctx.Done()</code> 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作。</p>
<h2 id="默认上下文"><a href="#默认上下文" class="headerlink" title="默认上下文"></a>默认上下文</h2><p><a href="https://github.com/golang/go/tree/master/src/context" target="_blank" rel="external nofollow noopener noreferrer"><code>context</code></a> 包中最常用的方法还是 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Background</code></a>、<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>context.TODO</code></a>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>，它们会在同一个 Go 程序中被复用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个私有变量都是通过 <code>new(emptyCtx)</code> 语句初始化的，它们是指向私有结构体 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L171" target="_blank" rel="external nofollow noopener noreferrer"><code>context.emptyCtx</code></a> 的指针，这是最简单、最常用的上下文类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码，我们不难发现 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L171" target="_blank" rel="external nofollow noopener noreferrer"><code>context.emptyCtx</code></a> 通过返回 <code>nil</code> 实现了 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 接口，它没有任何特殊的功能。</p>
<p><img alt="golang-context-hierarchy" data-src="https://img.draveness.me/golang-context-hierarchy.png"></p>
<p><strong>图 6-4 Context 层级关系</strong></p>
<p>从源代码来看，<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Background</code></a> 和 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>context.TODO</code></a> 函数其实也只是互为别名，没有太大的差别。它们只是在使用和语义上稍有不同：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Background</code></a> 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来；</li>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L216-L218" target="_blank" rel="external nofollow noopener noreferrer"><code>context.TODO</code></a> 应该只在不确定应该使用哪种上下文时使用；</li>
</ul>
<p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L208-L210" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Background</code></a> 作为起始的上下文向下传递。</p>
<h2 id="取消信号"><a href="#取消信号" class="headerlink" title="取消信号"></a>取消信号</h2><p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithCancel</code></a> 函数能够从 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 中衍生出一个新的子上下文并返回用于取消该上下文的函数（CancelFunc）。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p>
<p><img alt="golang-parent-cancel-context" data-src="https://img.draveness.me/2020-01-20-15795072700927-golang-parent-cancel-context.png"></p>
<p><strong>图 6-5 Context 子树的取消</strong></p>
<p>我们直接从 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithCancel</code></a> 函数的实现来看它到底做了什么：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L239-L241" target="_blank" rel="external nofollow noopener noreferrer"><code>context.newCancelCtx</code></a> 将传入的上下文包装成私有结构体 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L341-L348" target="_blank" rel="external nofollow noopener noreferrer"><code>context.cancelCtx</code></a>；</li>
<li><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L247-L283" target="_blank" rel="external nofollow noopener noreferrer"><code>context.propagateCancel</code></a> 会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 父上下文不会触发取消信号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err()) <span class="comment">// 父上下文已经被取消</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数总共与父上下文相关的三种不同的情况：</p>
<ol>
<li><p>当 <code>parent.Done() == nil</code>，也就是 <code>parent</code> 不会触发取消事件时，当前函数会直接返回；</p>
</li>
<li><p>当</p>
</li>
</ol>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">child</span></span><br></pre></td></tr></table></figure>
<p>   的继承链包含可以取消的上下文时，会判断</p>
   <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">parent</span></span><br></pre></td></tr></table></figure>
<p>   是否已经触发了取消信号；</p>
<ul>
<li>如果已经被取消，<code>child</code> 会立刻被取消；</li>
<li>如果没有被取消，<code>child</code> 会被加入 <code>parent</code> 的 <code>children</code> 列表中，等待 <code>parent</code> 释放取消信号；</li>
</ul>
<ol>
<li><p>在默认情况下</p>
<ol>
<li>运行一个新的 Goroutine 同时监听 <code>parent.Done()</code> 和 <code>child.Done()</code> 两个 Channel</li>
<li>在 <code>parent.Done()</code> 关闭时调用 <code>child.cancel</code> 取消子上下文；</li>
</ol>
</li>
</ol>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L247-L283" target="_blank" rel="external nofollow noopener noreferrer"><code>context.propagateCancel</code></a> 的作用是在 <code>parent</code> 和 <code>child</code> 之间同步取消和结束的信号，保证在 <code>parent</code> 被取消时，<code>child</code> 也会收到对应的信号，不会发生状态不一致的问题。</p>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L341-L348" target="_blank" rel="external nofollow noopener noreferrer"><code>context.cancelCtx</code></a> 实现的几个接口方法也没有太多值得分析的地方，该结构体最重要的方法是 <code>cancel</code>，这个方法会关闭上下文中的 Channel 并向所有的子上下文同步取消信号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L232-L236" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithCancel</code></a> 之外，<a href="https://github.com/golang/go/tree/master/src/context" target="_blank" rel="external nofollow noopener noreferrer"><code>context</code></a> 包中的另外两个函数 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L427-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithDeadline</code></a> 和 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L496-L498" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithTimeout</code></a> 也都能创建可以被取消的计时器上下文 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L455-L460" target="_blank" rel="external nofollow noopener noreferrer"><code>context.timerCtx</code></a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// 已经过了截止日期</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L427-L450" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithDeadline</code></a> 方法在创建 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L455-L460" target="_blank" rel="external nofollow noopener noreferrer"><code>context.timerCtx</code></a> 的过程中，判断了父上下文的截止日期与当前日期，并通过 <a href="https://github.com/golang/go/blob/001fe7f33f1d7aed9e3a047bd8e784bdc103c28c/src/time/sleep.go#L155-L165" target="_blank" rel="external nofollow noopener noreferrer"><code>time.AfterFunc</code></a> 创建定时器，当时间超过了截止日期后会调用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L472-L484" target="_blank" rel="external nofollow noopener noreferrer"><code>context.timerCtx.cancel</code></a> 方法同步取消信号。</p>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L455-L460" target="_blank" rel="external nofollow noopener noreferrer"><code>context.timerCtx</code></a> 结构体内部不仅通过嵌入了<a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L341-L348" target="_blank" rel="external nofollow noopener noreferrer"><code>context.cancelCtx</code></a> 结构体继承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消这一功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.cancelCtx.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer.Stop()</span><br><span class="line">		c.timer = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L472-L484" target="_blank" rel="external nofollow noopener noreferrer"><code>context.timerCtx.cancel</code></a> 方法不仅调用了 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L391-L416" target="_blank" rel="external nofollow noopener noreferrer"><code>context.cancelCtx.cancel</code></a>，还会停止持有的定时器减少不必要的资源浪费。</p>
<h2 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h2><p>在最后我们需要了解如何使用上下文传值，<a href="https://github.com/golang/go/tree/master/src/context" target="_blank" rel="external nofollow noopener noreferrer"><code>context</code></a> 包中的 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L513-L521" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithValue</code></a> 函数能从父上下文中创建一个子上下文，传值的子上下文使用 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L525-L528" target="_blank" rel="external nofollow noopener noreferrer"><code>context.valueCtx</code></a> 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L525-L528" target="_blank" rel="external nofollow noopener noreferrer"><code>context.valueCtx</code></a> 结构体会将除了 <code>Value</code> 之外的 <code>Err</code>、<code>Deadline</code> 等方法代理到父上下文中，它只会响应 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L549-L554" target="_blank" rel="external nofollow noopener noreferrer"><code>context.valueCtx.Value</code></a> 方法，这个方法的实现也很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L525-L528" target="_blank" rel="external nofollow noopener noreferrer"><code>context.valueCtx</code></a> 中存储的键值对与 <a href="https://github.com/golang/go/blob/df2999ef43ea49ce1578137017949c0ee660608a/src/context/context.go#L549-L554" target="_blank" rel="external nofollow noopener noreferrer"><code>context.valueCtx.Value</code></a> 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到在某个父上下文中返回 <code>nil</code> 或者查找到对应的值。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Go 语言中的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。</p>
<p>在真正使用传值的功能时我们也应该非常谨慎，使用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 进行传递参数请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://golang.org/pkg/context/" target="_blank" rel="external nofollow noopener noreferrer">Package context · Golang</a></li>
<li><a href="https://blog.golang.org/context" target="_blank" rel="external nofollow noopener noreferrer">Go Concurrency Patterns: Context</a></li>
<li><a href="https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/" target="_blank" rel="external nofollow noopener noreferrer">Using context cancellation in Go</a></li>
</ul>
<h2 id="最后的彩蛋"><a href="#最后的彩蛋" class="headerlink" title="最后的彩蛋"></a>最后的彩蛋</h2><p>其实在看这个的时候，想到这是Context的With系列函数的设计是一个特别有意思的算法题，题目描述如下：</p>
<blockquote>
<ol>
<li>我们有一个Context树，根Context可以是Backgroud的Context或者是TODO的Context</li>
<li>可以从根Context出发，每个parent Context可以有自己的child Context</li>
<li>我们想实现这个一个函数<code>WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code>，输入参数是parent，输出是子context和cancel函数</li>
<li>当调用cancel函数时，继承自它的所有Context都会被取消</li>
<li>补充的一个背景是，所有的context都有上面说的4个函数</li>
</ol>
</blockquote>
<p>那么要实现这么一个功能，我们就需要考虑其对应的数据结构和算法了。</p>
<p>具体的做法是什么呢？晚上回去好好想想</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>context</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>所谓生活</title>
    <url>/posts/47d0d3b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。</p>
<a id="more"></a>
<h2 id="所见"><a href="#所见" class="headerlink" title="所见"></a>所见</h2><p>一直说要拍拍夏天的荷花，入职一个月以来，周末却一直呆在家里，没有出门。一来是外面太热，二来一直没有把自己的时间安排好，迟迟没有出门。下周要去房山参加一个星期的封闭培训，等到回来时，北京的夏天就过去了。想到这里，立马敲定晚上出门，带着相机，坐地铁到达什刹海公园。</p>
<p>走出地铁第一感受是，外面人好多。这不是我第一次来这里了，从烟袋斜街进去，转后海一条街，已经成了我的惯常路线。然而我们想到的是，即使国内仍然被疫情阴影笼罩，什刹海这里已经摩肩接踵，除了口罩已经不太能够看出疫情的痕迹了。</p>
<p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily.png"></p>
<p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily2.png"></p>
<p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily3.png"></p>
<p>第二个让我感触比较大的是人们的生活状态。踢毽子、抽陀螺、跳舞、遛狗、打球、跑步，大家的状态都很放松，可以自在的玩自己的爱好。</p>
<p><img alt="荷花市坊抽陀螺的大爷" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_pick.png"></p>
<p><img alt="地安门两个人一起跳舞的叔叔阿姨" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dance.png"></p>
<p><img alt="走到景山后街，见证了两个导盲犬的相遇与分离" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dogs1.png"></p>
<p><img alt="他们两个明天应该还会相遇吧" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-dogs2.png"></p>
<p><img alt="狗狗主人还热情地给我看了他平时拍到的狗狗照片" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dogs3.png"></p>
<p>这与我在办公室的状态很不一样。在平常的日子里，每天除了上下班就没有其他的生活了。周末自己宅在家里，也不是这种惬意。总觉得有事情要做，总觉得有事情没有做完。这种状态，只有在找完工作之后的那半年才有吧。</p>
<h2 id="所闻"><a href="#所闻" class="headerlink" title="所闻"></a>所闻</h2><p>继续往景山走，却不想景区已经关门，只好往故宫走。</p>
<p><img alt="在角楼，一边也在拍角楼的素不相识的大哥主动提出借给我三脚架，于是才有了这张照片" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-city.png"></p>
<p>拍角楼的时候，一个大爷主动跟我说话，推荐我拍拍景山前面的灯。本以为是一个简单的搭话，没想到我们两个聊了一个多小时的庄子、道与术、中西方哲学。这可能是这段时间里我交流密度最多的一个小时了。真的很奇妙，本是互不相识的人，却可以因为一方的主动聊起来，聊完之后也拂袖而去。与之相反，在办公室中，虽然也是每天都见面，但是实际上却说不上什么话。</p>
<h2 id="所想"><a href="#所想" class="headerlink" title="所想"></a>所想</h2><p>总的来说，这次外出让我感到很开心，让我感觉到城市中人与人的连接性，让我感到了北京的可爱。这些都是实实在在存在的人，他们都有着自己的生活。就是这样，你是可以变得更加主动一些的，没准你就可以发现难得的惊喜。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>夏天</tag>
        <tag>摄影</tag>
        <tag>故宫</tag>
        <tag>什刹海</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】调度策略</title>
    <url>/posts/b130e91a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文分析了Kubernetes内置的各种调度策略。</p>
<a id="more"></a>
<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><h3 id="整体梳理"><a href="#整体梳理" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container">
<table>
<thead>
<tr>
<th>策略名称</th>
<th>策略算法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>CheckNodeUnschedulable</td>
<td>在 Node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了</td>
<td></td>
</tr>
<tr>
<td>CheckVolumeBinding</td>
<td>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验</td>
<td></td>
</tr>
<tr>
<td>GeneralPredicates</td>
<td>是 PodFitsHostPorts，PodFitsResources，HostName，MatchNodeSelector这四个的组合</td>
<td></td>
</tr>
<tr>
<td>MatchInterPodAffinity</td>
<td>亲和性检查，当Node上所有正在运行的Pod与待调度的Pod不互相排斥时，则可调度</td>
<td></td>
</tr>
<tr>
<td>MaxAzureDiskVolumeCount</td>
<td>当Node上被挂载的Azure Disk Volume超过默认限制，该Node不可调度</td>
<td></td>
</tr>
<tr>
<td>MaxCSIVolumeCountPred</td>
<td>当Node上被挂载的CSI Volume超过默认限制，该Node不可调度</td>
<td></td>
</tr>
<tr>
<td>MaxEBSVolumeCount</td>
<td>当Node上被挂载的AWS EBS Volume超过默认限制39，该Node不可调度</td>
<td></td>
</tr>
<tr>
<td>MaxGCEPDVolumeCount</td>
<td>当Node上被挂载的GCD Persistent Disk超过默认限制16，该Node不可调度</td>
<td></td>
</tr>
<tr>
<td>MaxQcloudCbsVolumeCount</td>
<td>当Node上被挂载的Qcloud CBS Volume超过默认限制，该Node不可调度</td>
<td></td>
</tr>
<tr>
<td>NoDiskConflict</td>
<td>当Node上所有Pod使用的卷和待调度Pod使用的卷存在冲突，该Node不可调度</td>
<td></td>
</tr>
<tr>
<td>NoVolumeZoneConflict</td>
<td>当Node上的zone-lable包含Pod中PV卷下的zone-label时，可以调度。当Node上没有zone-label，表示没有zone限制，也可调度</td>
<td></td>
</tr>
<tr>
<td>PodToleratesNodeTaints</td>
<td>当Pod可以容忍Node上所有的taint时，该Node才可以调度</td>
<td></td>
</tr>
<tr>
<td>PodFitsHostPorts</td>
<td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td>
<td></td>
</tr>
<tr>
<td>PodFitsResources</td>
<td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td>
<td></td>
</tr>
<tr>
<td>HostName</td>
<td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td>
<td></td>
</tr>
<tr>
<td>MatchNodeSelector</td>
<td>校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配</td>
<td></td>
</tr>
<tr>
<td>CheckNodeMemoryPressure</td>
<td>当Node剩余内存紧张时，BestEffort类型的Pod无法调度到该主机</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CheckNodeDiskPressure</td>
<td>当Node剩余磁盘空间紧张时，无法调度到该主机</td>
<td></td>
</tr>
<tr>
<td>PodFitsHostPorts</td>
<td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td>
<td></td>
</tr>
<tr>
<td>PodFitsResources</td>
<td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td>
<td></td>
</tr>
<tr>
<td>HostName</td>
<td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td>
<td></td>
</tr>
<tr>
<td>EvenPodsSpread</td>
<td>在1.18版本默认启动，符合条件的一组 Pod 在指定 TopologyKey 上的打散要求</td>
<td></td>
</tr>
<tr>
<td>CheckNodeLabelPresence</td>
<td>主要用于检查指定的Label是否在Node上存在</td>
<td></td>
</tr>
<tr>
<td>CheckServiceAffinityPred</td>
<td>根据当前POD对象所属的service已有的其他POD对象所运行的节点进行调度，其目的在于将相同service的POD 对象放置与同一个或同一类节点上以提高效率，此预选此类试图将那些在其节点选择器中带有特定标签的POD资源调度至拥有同样标签的节点上，具体的标签则取决于用户的定义。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h3><h4 id="NoVolumeZoneConflictPred"><a href="#NoVolumeZoneConflictPred" class="headerlink" title="NoVolumeZoneConflictPred"></a>NoVolumeZoneConflictPred</h4><p>当在 k8s 集群中使用 zone 时，所有的Node都会被标记上 zone label，下面四种是常见的lable的key：</p>
<figure class="highlight go"><figcaption><span>k8s.io/api/core/v1</span></figcaption><table><tr><td class="code"><pre><span class="line">LabelZoneFailureDomain       = <span class="string">"failure-domain.beta.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegion              = <span class="string">"failure-domain.beta.kubernetes.io/region"</span></span><br><span class="line">LabelZoneFailureDomainStable = <span class="string">"topology.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegionStable        = <span class="string">"topology.kubernetes.io/region"</span></span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">node.alpha.kubernetes.io/ttl:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">volumes.kubernetes.io/controller-managed-attach-detach:</span> <span class="string">"true"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2020-07-20T12:11:34Z"</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"334106446"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/nodes/10.0.1.28</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">5943d3fc-0841-43f2-b519-c32af755c1c5</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/instance-type:</span> <span class="string">QCLOUD</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">cloud.tencent.com/node-instance-id:</span> <span class="string">ins-r3gy6izp</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">    <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">qcloud:///800002/ins-r3gy6izp</span></span><br></pre></td></tr></table></figure>
<p>当一个Pod有存储卷要求时，需要检查该存储卷的zone调度约束是否与Node的zone限制存在冲突。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/volumezone/volume_zone.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> pv.ObjectMeta.Labels &#123;</span><br><span class="line">	<span class="keyword">if</span> !volumeZoneLabels.Has(k) &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	nodeV, _ := nodeConstraints[k]</span><br><span class="line">	volumeVSet, err := volumehelpers.LabelZonesToSet(v)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Warningf(<span class="string">"Failed to parse label for %q: %q. Ignoring the label. err=%v. "</span>, k, v, err)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !volumeVSet.Has(nodeV) &#123;</span><br><span class="line">		klog.V(<span class="number">10</span>).Infof(<span class="string">"Won't schedule pod %q onto node %q due to volume %q (mismatch on %q)"</span>, pod.Name, node.Name, pvName, k)</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonConflict)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过检查的条件是：属于该Pod的所有volumes都必须与Node上的zone label完全匹配。</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoVolumeZoneConflictPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, volumezone.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CheckVolumeBindingPred"><a href="#CheckVolumeBindingPred" class="headerlink" title="CheckVolumeBindingPred"></a>CheckVolumeBindingPred</h4><p>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验，里头的逻辑写的比较复杂，主要都是如何复用 pv；</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckVolumeBindingPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Reserve = appendToPluginSet(plugins.Reserve, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.PreBind = appendToPluginSet(plugins.PreBind, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="NoDiskConflictPred"><a href="#NoDiskConflictPred" class="headerlink" title="NoDiskConflictPred"></a>NoDiskConflictPred</h4><p>SCSI 存储不会被重复的 volume, 检查在此主机上是否存在卷冲突。如果这个主机已经挂载了卷，其它同样使用这个卷的Pod不能调度到这个主机上，不同的存储后端具体规则不同</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoDiskConflictPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, volumerestrictions.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="MaxCSIVolumeCountPred"><a href="#MaxCSIVolumeCountPred" class="headerlink" title="MaxCSIVolumeCountPred"></a>MaxCSIVolumeCountPred</h4><p>一个Pod请求Volumes的时候，节点上可能已经有Volumes，需要检查加上这个Pod之后的Volumes是否超过Node最大允许的Volumes限制。MaxCSIVolumeCountPred 用来校验 pvc 上指定的 Provision 在 CSI plugin 上的单机最大 pv 数限制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> volumeLimitKey, count := <span class="keyword">range</span> newVolumeCount &#123;</span><br><span class="line">	maxVolumeLimit, ok := nodeVolumeLimits[v1.ResourceName(volumeLimitKey)]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		currentVolumeCount := attachedVolumeCount[volumeLimitKey]</span><br><span class="line">		<span class="keyword">if</span> currentVolumeCount+count &gt; <span class="keyword">int</span>(maxVolumeLimit) &#123;</span><br><span class="line">			<span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCSIVolumeCountPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CSIName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="MaxNonCSIVolumeCountPred"><a href="#MaxNonCSIVolumeCountPred" class="headerlink" title="MaxNonCSIVolumeCountPred"></a>MaxNonCSIVolumeCountPred</h4><p>对于不是CSI标准的存储插件，也需要满足最大PV数限制，整体逻辑类似。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> numExistingVolumes+numNewVolumes &gt; maxAttachLimit &#123;</span><br><span class="line">	<span class="comment">// violates MaxEBSVolumeCount or MaxGCEPDVolumeCount</span></span><br><span class="line">	<span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MaxEBSVolumeCountPred"><a href="#MaxEBSVolumeCountPred" class="headerlink" title="MaxEBSVolumeCountPred"></a>MaxEBSVolumeCountPred</h5><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxEBSVolumeCountPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.EBSName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="MaxGCEPDVolumeCountPred"><a href="#MaxGCEPDVolumeCountPred" class="headerlink" title="MaxGCEPDVolumeCountPred"></a>MaxGCEPDVolumeCountPred</h5><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxGCEPDVolumeCountPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.GCEPDName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="MaxAzureDiskVolumeCountPred"><a href="#MaxAzureDiskVolumeCountPred" class="headerlink" title="MaxAzureDiskVolumeCountPred"></a>MaxAzureDiskVolumeCountPred</h5><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxAzureDiskVolumeCountPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.AzureDiskName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="MaxCinderVolumeCountPred"><a href="#MaxCinderVolumeCountPred" class="headerlink" title="MaxCinderVolumeCountPred"></a>MaxCinderVolumeCountPred</h5><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCinderVolumeCountPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">			plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CinderName, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Pod-与-Node-匹配相关"><a href="#Pod-与-Node-匹配相关" class="headerlink" title="Pod 与 Node 匹配相关"></a>Pod 与 Node 匹配相关</h3><ul>
<li>CheckNodeCondition：校验节点是否准备好被调度，校验node.condition的condition type ：Ready为true和NetworkUnavailable为false以及Node.Spec.Unschedulable为false；</li>
<li>PodFitsHostPorts：校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用；</li>
<li>MatchNodeSelector: 校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配。</li>
</ul>
<h4 id="PodFitsHostPortsPred"><a href="#PodFitsHostPortsPred" class="headerlink" title="PodFitsHostPortsPred"></a>PodFitsHostPortsPred</h4><p><code>PodFitsHostPorts</code>策略主要用于校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用。</p>
<p>在 PreFilter 阶段，获取当前 Pod 对应的所有容器的Port，并且写入cycleState。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PreFilter invoked at the prefilter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">PreFilter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	s := getContainerPorts(pod)</span><br><span class="line">	cycleState.Write(preFilterStateKey, preFilterState(s))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Filter 阶段，从Cycle拿到当前Pod请求的Port，对比当前系统中已使用的 Port，看是否会发生冲突。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	wantPorts, err := getPreFilterState(cycleState)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fits := fitsPorts(wantPorts, nodeInfo)</span><br><span class="line">	<span class="keyword">if</span> !fits &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReason)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsHostPortsPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="PodFitsResourcesPred"><a href="#PodFitsResourcesPred" class="headerlink" title="PodFitsResourcesPred"></a>PodFitsResourcesPred</h4><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsResourcesPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="PodToleratesNodeTaintsPred"><a href="#PodToleratesNodeTaintsPred" class="headerlink" title="PodToleratesNodeTaintsPred"></a>PodToleratesNodeTaintsPred</h4><p><code>PodToleratesNodeTaints</code>策略校验 Node 的 Taints 是否被 Pod Tolerates 包含。这里主要检查 <code>NoSchedule</code> 和 <code>NoExecute</code> 这两个 taint，如果不容忍，那么返回错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"invalid nodeInfo"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filterPredicate := <span class="function"><span class="keyword">func</span><span class="params">(t *v1.Taint)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="comment">// PodToleratesNodeTaints is only interested in NoSchedule and NoExecute taints.</span></span><br><span class="line">		<span class="keyword">return</span> t.Effect == v1.TaintEffectNoSchedule || t.Effect == v1.TaintEffectNoExecute</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	taint, isUntolerated := v1helper.FindMatchingUntoleratedTaint(nodeInfo.Node().Spec.Taints, pod.Spec.Tolerations, filterPredicate)</span><br><span class="line">	<span class="keyword">if</span> !isUntolerated &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	errReason := fmt.Sprintf(<span class="string">"node(s) had taint &#123;%s: %s&#125;, that the pod didn't tolerate"</span>,</span><br><span class="line">		taint.Key, taint.Value)</span><br><span class="line">	<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, errReason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodToleratesNodeTaintsPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="HostNamePred"><a href="#HostNamePred" class="headerlink" title="HostNamePred"></a>HostNamePred</h4><p><code>NodeNamePred</code>策略主要用于检查Pod Spec声明的Node Name是否与Node实际的Name匹配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Filter invoked at the filter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fits actually checks if the pod fits the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fits</span><span class="params">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(HostNamePred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="MatchNodeSelectorPred"><a href="#MatchNodeSelectorPred" class="headerlink" title="MatchNodeSelectorPred"></a>MatchNodeSelectorPred</h4><p><code>MatchNodeSelectorPred</code>策略用于校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PodMatchesNodeSelectorAndAffinityTerms</span><span class="params">(pod *v1.Pod, node *v1.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check if node.Labels match pod.Spec.NodeSelector.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeSelector) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		selector := labels.SelectorFromSet(pod.Spec.NodeSelector)</span><br><span class="line">		<span class="keyword">if</span> !selector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. nil NodeSelector matches all nodes (i.e. does not filter out any nodes)</span></span><br><span class="line">	<span class="comment">// 2. nil []NodeSelectorTerm (equivalent to non-nil empty NodeSelector) matches no nodes</span></span><br><span class="line">	<span class="comment">// 3. zero-length non-nil []NodeSelectorTerm matches no nodes also, just for simplicity</span></span><br><span class="line">	<span class="comment">// 4. nil []NodeSelectorRequirement (equivalent to non-nil empty NodeSelectorTerm) matches no nodes</span></span><br><span class="line">	<span class="comment">// 5. zero-length non-nil []NodeSelectorRequirement matches no nodes also, just for simplicity</span></span><br><span class="line">	<span class="comment">// 6. non-nil empty NodeSelectorRequirement is not allowed</span></span><br><span class="line">	nodeAffinityMatches := <span class="literal">true</span></span><br><span class="line">	affinity := pod.Spec.Affinity</span><br><span class="line">	<span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &#123;</span><br><span class="line">		nodeAffinity := affinity.NodeAffinity</span><br><span class="line">		<span class="comment">// if no required NodeAffinity requirements, will do no-op, means select all nodes.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Replace next line with subsequent commented-out line when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line">		<span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution == nil &amp;&amp; nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil &#123;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Match node selector for requiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Uncomment this block when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line">		<span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution != nil &#123;</span></span><br><span class="line">		<span class="comment">// 	nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution.NodeSelectorTerms</span></span><br><span class="line">		<span class="comment">// 	klog.V(10).Infof("Match for RequiredDuringSchedulingRequiredDuringExecution node selector terms %+v", nodeSelectorTerms)</span></span><br><span class="line">		<span class="comment">// 	nodeAffinityMatches = nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Match node selector for requiredDuringSchedulingIgnoredDuringExecution.</span></span><br><span class="line">		<span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line">			nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms</span><br><span class="line">			nodeAffinityMatches = nodeAffinityMatches &amp;&amp; nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nodeAffinityMatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个典型的Node亲和性示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	pod: &amp;v1.Pod&#123;</span><br><span class="line">		Spec: v1.PodSpec&#123;</span><br><span class="line">			Affinity: &amp;v1.Affinity&#123;</span><br><span class="line">				NodeAffinity: &amp;v1.NodeAffinity&#123;</span><br><span class="line">					RequiredDuringSchedulingIgnoredDuringExecution: &amp;v1.NodeSelector&#123;</span><br><span class="line">						NodeSelectorTerms: []v1.NodeSelectorTerm&#123;</span><br><span class="line">							&#123;</span><br><span class="line">								MatchExpressions: []v1.NodeSelectorRequirement&#123;</span><br><span class="line">									&#123;</span><br><span class="line">										Key:      <span class="string">"kernel-version"</span>,</span><br><span class="line">										Operator: v1.NodeSelectorOpGt,</span><br><span class="line">										Values:   []<span class="keyword">string</span>&#123;<span class="string">"0204"</span>&#125;,</span><br><span class="line">									&#125;,</span><br><span class="line">								&#125;,</span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="comment">// We use two digit to denote major version and two digit for minor version.</span></span><br><span class="line">		<span class="string">"kernel-version"</span>: <span class="string">"0206"</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	name: <span class="string">"Pod with matchExpressions using Gt operator that matches the existing node"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchNodeSelectorPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="GeneralPred"><a href="#GeneralPred" class="headerlink" title="GeneralPred"></a>GeneralPred</h4><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(GeneralPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		<span class="comment">// GeneralPredicate is a combination of predicates.</span></span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CheckNodeUnschedulablePred"><a href="#CheckNodeUnschedulablePred" class="headerlink" title="CheckNodeUnschedulablePred"></a>CheckNodeUnschedulablePred</h4><p><code>CheckNodeUnschedulable</code> 在 node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了，形如这种。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">node: &amp;v1.Node&#123;</span><br><span class="line">   Spec: v1.NodeSpec&#123;</span><br><span class="line">     Unschedulable: <span class="literal">true</span>,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>在 1.16 的版本里，这个 Unschedulable 已经变成了一个 Taints。也就是说需要校验一下 Pod 上打上的 Tolerates 是不是可以容忍这个 Taints。如果容忍了这个不可调度的taint，那么它也可以容忍 NodeSpec的不可调度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeUnschedulable)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnknownCondition)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If pod tolerate unschedulable taint, it's also tolerate `node.Spec.Unschedulable`.</span></span><br><span class="line">	podToleratesUnschedulable := v1helper.TolerationsTolerateTaint(pod.Spec.Tolerations, &amp;v1.Taint&#123;</span><br><span class="line">		Key:    v1.TaintNodeUnschedulable,</span><br><span class="line">		Effect: v1.TaintEffectNoSchedule,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// TODO (k82cn): deprecates `node.Spec.Unschedulable` in 1.13.</span></span><br><span class="line">	<span class="keyword">if</span> nodeInfo.Node().Spec.Unschedulable &amp;&amp; !podToleratesUnschedulable &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnschedulable)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeUnschedulablePred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodeunschedulable.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CheckNodeLabelPresencePred"><a href="#CheckNodeLabelPresencePred" class="headerlink" title="CheckNodeLabelPresencePred"></a>CheckNodeLabelPresencePred</h4><p><code>CheckNodeLablePresencePred</code>策略主要用于检查指定的Label是否在Node上存在。这里检查的是两种情况：</p>
<ul>
<li>一种检查Node上面是否有指定Label。比如有时候通过 <code>region/zone/racks</code> 这种label来划分空间，想要把Pod调度到有特定region/zone/racks的Node。</li>
<li>一种是检查Node上面是否没有指定的Label。比如有的Node被打上 <code>retiring</code> 的 label，想要制定Pod不调度到这些Node上。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	node := nodeInfo.Node()</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nodeLabels := labels.Set(node.Labels)</span><br><span class="line">	check := <span class="function"><span class="keyword">func</span><span class="params">(labels []<span class="keyword">string</span>, presence <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, label := <span class="keyword">range</span> labels &#123;</span><br><span class="line">			exists := nodeLabels.Has(label)</span><br><span class="line">			<span class="keyword">if</span> (exists &amp;&amp; !presence) || (!exists &amp;&amp; presence) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> check(pl.args.PresentLabels, <span class="literal">true</span>) &amp;&amp; check(pl.args.AbsentLabels, <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonPresenceViolated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个策略，需要在注册的时候设定策略插件的参数。</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Pod-与-Pod-匹配相关"><a href="#Pod-与-Pod-匹配相关" class="headerlink" title="Pod 与 Pod 匹配相关"></a>Pod 与 Pod 匹配相关</h3><h4 id="MatchInterPodAffinityPred"><a href="#MatchInterPodAffinityPred" class="headerlink" title="MatchInterPodAffinityPred"></a>MatchInterPodAffinityPred</h4><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchInterPodAffinityPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Pod-服务打散相关"><a href="#Pod-服务打散相关" class="headerlink" title="Pod 服务打散相关"></a>Pod 服务打散相关</h3><h4 id="EvenPodsSpread"><a href="#EvenPodsSpread" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CheckServiceAffinity"><a href="#CheckServiceAffinity" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckServiceAffinityPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h2><h3 id="整体梳理-1"><a href="#整体梳理-1" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container">
<table>
<thead>
<tr>
<th>策略名称</th>
<th>策略算法</th>
<th>权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>BalancedResourceAllocation*</td>
<td>CPU和内存利用率越接近，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>ImageLocalityPriority*</td>
<td>待调度的Pod会使用一些镜像，拥有这些镜像越多的节点，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>InterPodAffinityPriority*</td>
<td>Pod与Node上正运行的其他Pod亲和性匹配度越高，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>LeastRequestedPriority*</td>
<td>剩余资源越多，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>NodeAffinityPriority*</td>
<td>Pod与Node亲和性匹配度越高，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>NodePreferAvoidPodsPriority*</td>
<td>该Node的annotation scheduler.alpha.kubernetes.io/preferAvoidPods被设置时，说明该Node不希望被调度，得分低。</td>
<td>10000</td>
</tr>
<tr>
<td>SelectorSpreadPriority*</td>
<td>相同service/rc的Pods越分散，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>TaintTolerationPriority*</td>
<td>Pod对Node的taint容忍度越高，得分越高</td>
<td>1</td>
</tr>
<tr>
<td>ServiceSpreadingPriority</td>
<td>相同Service的Pods越分散，得分越高，被 SelectorSpreadPriority取代，保留在系统中并不使用</td>
<td>1</td>
</tr>
<tr>
<td>EqualPriority</td>
<td>所有机器得分一样</td>
<td>1</td>
</tr>
<tr>
<td>MostRequestPriority</td>
<td>Request资源越多，得分越高，与LeastRequestPriority相反</td>
<td>1</td>
</tr>
<tr>
<td>EvenPodsSpreadPriority</td>
<td>在1.18版本默认启动，用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式</td>
<td>2</td>
</tr>
<tr>
<td>RequestedToCapacityRatioName</td>
<td>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing</td>
<td></td>
</tr>
<tr>
<td>NodeLabel</td>
<td>主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</td>
<td></td>
</tr>
<tr>
<td>ServiceAffinity</td>
<td>是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>打分算法主要解决的问题就是集群的碎片、容灾、水位、亲和、反亲和等，可以分为以下四个大类。</p>
<h3 id="资源水位"><a href="#资源水位" class="headerlink" title="资源水位"></a>资源水位</h3><ul>
<li>资源水位公式的概念：Request：Node 已经分配的资源；Allocatable：Node 的可调度的资源。</li>
<li>优先打散：把 Pod 分到资源空闲率最高的节点上，而非空闲资源最大的节点，公式：资源空闲率 = (Allocatable - Request) / Allocatable，当这个值越大，表示分数越高，优先分配到高分数的节点。其中 (Allocatable - Request) 表示为 Pod 分配到这个节点之后空闲的资源数。</li>
<li>优先堆叠：把 Pod 分配到资源使用率最高的节点上，公式:资源使用率 = Request / Allocatable ，资源使用率越高，表示得分越高，会优先分配到高分数的节点。</li>
<li>碎片率：是指 Node 上的多种资源之间的资源使用率的差值，目前支持 CPU/Mem/Disk 三类资源, 假如仅考虑 CPU/Mem，那么碎片率的公式 = Abs[CPU(Request / Allocatable) - Mem(Request / Allocatable)] 。举一个例子，当 CPU 的分配率是 99%，内存的分配率是 50%，那么碎片率 = 99% - 50% = 50%，那么这个例子中剩余 1% CPU, 50% Mem，很难有这类规格的容器能用完 Mem。得分 = 1 - 碎片率，碎片率越高得分低。</li>
<li>指定比率：可以在 Scheduler 启动的时候，为每一个资源使用率设置得分，从而实现控制集群上 node 资源分配分布曲线。</li>
</ul>
<h4 id="LeastRequestedPriority"><a href="#LeastRequestedPriority" class="headerlink" title="LeastRequestedPriority"></a>LeastRequestedPriority</h4><p><code>LeastRequestedPriority</code> 策略对于那些使用率越低的Node的优先级越高。通过这种算法，可以使得各个节点的资源得到均衡利用。</p>
<p>计算公式如下：</p>
<script type="math/tex; mode=display">
(cpu((capacity-sum(requested))*MaxNodeScore/capacity) + memory((capacity-sum(requested))*MaxNodeScore/capacity))/weightSum</script><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(LeastRequestedPriority,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">			plugins.Score = appendToPluginSet(plugins.Score, noderesources.LeastAllocatedName, &amp;args.Weight)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="MostRequestedPriority"><a href="#MostRequestedPriority" class="headerlink" title="MostRequestedPriority"></a>MostRequestedPriority</h4><p><code>MostRequestedPriority</code> 策略对于那些使用率更高的Node的优先级更高。这种算法在动态伸缩集群环境比较适用，会优先调度pod到使用率最高的主机节点，这样在伸缩集群时，就会腾出空闲机器，从而进行停机处理。</p>
<p>其计算公式如下：</p>
<script type="math/tex; mode=display">
(cpu(MaxNodeScore * sum(requested) / capacity) + memory(MaxNodeScore * sum(requested) / capacity)) / weightSum</script><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(MostRequestedPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, noderesources.MostAllocatedName, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="BalancedResourceAllocation"><a href="#BalancedResourceAllocation" class="headerlink" title="BalancedResourceAllocation"></a>BalancedResourceAllocation</h4><p>BalancedResourceAllocation：尽量选择在部署Pod后各项资源更均衡的机器。BalancedResourceAllocation不能单独使用，而且必须和LeastRequestedPriority同时使用，它分别计算主机上的cpu和memory的比重，主机的分值由cpu比重和memory比重的“距离”决定。</p>
<p>计算公式如下：</p>
<script type="math/tex; mode=display">
score = (1 - variance(cpuFraction,memoryFraction,volumeFraction)) * MaxNodeScore</script><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(BalancedResourceAllocation,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, noderesources.BalancedAllocationName, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="RequestedToCapacityRatioPriority"><a href="#RequestedToCapacityRatioPriority" class="headerlink" title="RequestedToCapacityRatioPriority"></a>RequestedToCapacityRatioPriority</h4><p><code>RequestedToCapacityRatioPriority</code>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing。</p>
<p>所谓 <a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="external nofollow noopener noreferrer">Bin Packing</a> ，又称装箱问题，是运筹学中的一个经典问题。问题的背景是，现有若干个小盒子，想要把它们装进有限个给定大小的箱子中，如何既能够装的多油装的快，使得尽可能每个箱子都装满，从而减少箱子的使用数目。BinPack问题有很多变种，当限制箱子的数目为1，每个盒子给定value和weight，binpack问题就变成了背包问题。</p>
<p>Kubernetes默认开启的资源调度策略是Spread的策略，资源尽量打散，但是会导致较多的资源碎片，使得整体资源利用率下降。通过RequestedToCapacityRatioPriority配置支持CPU、内存和GPU等扩展卡的权重，在打分阶段计算对应资源的利用率，通过利用率进行排序，优先打满一个节点后再向后调度，从而实现bin packing。</p>
<p><code>RequestedToCapacityRatioResourceAllocation</code> 优先级函数的行为可以通过名为 <code>requestedToCapacityRatioArguments</code> 的配置选项进行控制。 该标志由两个参数 <code>shape</code> 和 <code>resources</code> 组成。 shape 允许用户根据 <code>utilization</code> 和 <code>score</code> 值将函数调整为最少请求（least requested）或 最多请求（most requested）计算。 resources 由 <code>name</code> 和 <code>weight</code> 组成，<code>name</code> 指定评分时要考虑的资源，<code>weight</code> 指定每种资源的权重。</p>
<p>以下是一个配置示例，该配置将 <code>requestedToCapacityRatioArguments</code> 设置为对扩展资源 <code>intel.com/foo</code> 和 <code>intel.com/bar</code> 的装箱行为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span> : <span class="string">"Policy"</span>,</span><br><span class="line">    <span class="attr">"apiVersion"</span> : <span class="string">"v1"</span>,</span><br><span class="line">    ...</span><br><span class="line">    "priorities" : [</span><br><span class="line">       ...</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"RequestedToCapacityRatioPriority"</span>,</span><br><span class="line">        <span class="attr">"weight"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"argument"</span>: &#123;</span><br><span class="line">          <span class="attr">"requestedToCapacityRatioArguments"</span>: &#123;</span><br><span class="line">            <span class="attr">"shape"</span>: [</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">0</span>, <span class="attr">"score"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">100</span>, <span class="attr">"score"</span>: <span class="number">10</span>&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"resources"</span>: [</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/foo"</span>, <span class="attr">"weight"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/bar"</span>, <span class="attr">"weight"</span>: <span class="number">5</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这里的shape参数定义的是不同utilization下对应的得分，是对 <code>LeastRequestedPriority</code> 和 <code>MostRequestedPriority</code> 的进一步抽象。</p>
<p>这种配置对应的是<code>LeastRequestedPriority</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种配置对应的是<code>MostRequestedPriority</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(noderesources.RequestedToCapacityRatioName,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, noderesources.RequestedToCapacityRatioName, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">if</span> args.RequestedToCapacityRatioArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: noderesources.RequestedToCapacityRatioName, Args: args.RequestedToCapacityRatioArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Pod-打散"><a href="#Pod-打散" class="headerlink" title="Pod 打散"></a>Pod 打散</h3><p>Pod打散目的是支持符合条件的一组 Pod 在不同 topology 上部署的 spread 需求。</p>
<h4 id="ServiceSpreadingPriority"><a href="#ServiceSpreadingPriority" class="headerlink" title="ServiceSpreadingPriority"></a>ServiceSpreadingPriority</h4><p>ServiceSpreadingPriority：官方注释上说大概率会用来替换 SelectorSpreadPriority，为什么呢？我个人理解：Service 代表一组服务，我们只要能做到服务的打散分配就足够了。</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="EvenPodsSpread-1"><a href="#EvenPodsSpread-1" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>EvenPodsSpreadPriority：用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式。因为这个使用方式可能会一直变化，我们假设这个拓扑结构是这样的：Spec 是要求在 node 上进行分布的，我们就可以按照上图中的计算公式，计算一下在这个 node 上满足 Spec 指定 labelSelector 条件的 pod 数量，然后计算一下最大的差值，接着计算一下 Node 分配的权重，如果说这个值越大，表示这个值越优先。</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(EvenPodsSpreadPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.PreScore = appendToPluginSet(plugins.PreScore, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, podtopologyspread.Name, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CheckServiceAffinity-1"><a href="#CheckServiceAffinity-1" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(serviceaffinity.Name,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		<span class="comment">// If there are n ServiceAffinity priorities in the policy, the weight for the corresponding</span></span><br><span class="line">		<span class="comment">// score plugin is n*weight (note that the validation logic verifies that all ServiceAffinity</span></span><br><span class="line">		<span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">		weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.ServiceAffinityArgs.AntiAffinityLabelsPreference))</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, serviceaffinity.Name, &amp;weight)</span><br><span class="line">		<span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="SelectorSpreadPriority"><a href="#SelectorSpreadPriority" class="headerlink" title="SelectorSpreadPriority"></a>SelectorSpreadPriority</h4><p>SelectorSpreadPriority：用于实现 Pod 所属的 Controller 下所有的 Pod 在 Node 上打散的要求。实现方式是这样的：它会依据待分配的 Pod 所属的 controller，计算该 controller 下的所有 Pod,假设总数为 T，对这些 Pod 按照所在的 Node 分组统计；假设为 N (表示为某个 Node 上的统计值)，那么对 Node上的分数统计为  (T-N)/T 的分数，值越大表示这个节点的 controller 部署的越少，分数越高，从而达到 workload 的 pod 打散需求。</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(SelectorSpreadPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, selectorspread.Name, &amp;args.Weight)</span><br><span class="line">		plugins.PreScore = appendToPluginSet(plugins.PreScore, selectorspread.Name, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Pod-亲和-反亲和"><a href="#Pod-亲和-反亲和" class="headerlink" title="Pod 亲和/反亲和"></a>Pod 亲和/反亲和</h3><h4 id="InterPodAffinityPriority"><a href="#InterPodAffinityPriority" class="headerlink" title="InterPodAffinityPriority"></a>InterPodAffinityPriority</h4><p>InterPodAffinityPriority：先介绍一下使用场景：第一个例子，比如说应用 A 提供数据，应用 B 提供服务，A 和 B 部署在一起可以走本地网络，优化网络传输；第二个例子，如果应用 A 和应用 B 之间都是 CPU 密集型应用，而且证明它们之间是会互相干扰的，那么可以通过这个规则设置尽量让它们不在一个节点上。pod亲和性选择策略，类似NodeAffinityPriority，提供两种选择器支持：requiredDuringSchedulingIgnoredDuringExecution（保证所选的主机必须满足所有Pod对主机的规则要求）、preferresDuringSchedulingIgnoredDuringExecution（调度器会尽量但不保证满足NodeSelector的所有要求），两个子策略：podAffinity和podAntiAffinity</p>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(InterPodAffinityPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.PreScore = appendToPluginSet(plugins.PreScore, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, interpodaffinity.Name, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">if</span> args.InterPodAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: interpodaffinity.Name, Args: args.InterPodAffinityArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Node-亲和-反亲和"><a href="#Node-亲和-反亲和" class="headerlink" title="Node 亲和/反亲和"></a>Node 亲和/反亲和</h3><ul>
<li>NodeAffinityPriority，这个是为了满足 Pod 和 Node 的亲和 &amp; 反亲和；</li>
<li>ServiceAntiAffinity，是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。比如：集群的节点有云上也有云下两组节点，我们要求服务在云上云下均衡去分布，假设 Node 上有某个 label，那我们就可以用这个 ServiceAntiAffinity 进行打散分布；</li>
<li>NodeLabelPrioritizer，主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配;</li>
<li>ImageLocalityPriority，节点亲和主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</li>
</ul>
<h4 id="NodePreferAvoidPodsPriority"><a href="#NodePreferAvoidPodsPriority" class="headerlink" title="NodePreferAvoidPodsPriority"></a>NodePreferAvoidPodsPriority</h4><p><code>NodePreferAvoidPodsPriority</code>策略用于实现某些 controller 尽量不分配到某些节点上的能力；通过在 node 上加 annotation 声明哪些 controller 不要分配到 Node 上，如果不满足就优先。</p>
<p>具体实现就是会在Node上加上Annotation，形如这种</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">annotations1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	v1.PreferAvoidPodsAnnotationKey: <span class="string">`</span></span><br><span class="line"><span class="string">						&#123;</span></span><br><span class="line"><span class="string">						    "preferAvoidPods": [</span></span><br><span class="line"><span class="string">						        &#123;</span></span><br><span class="line"><span class="string">						            "podSignature": &#123;</span></span><br><span class="line"><span class="string">						                "podController": &#123;</span></span><br><span class="line"><span class="string">						                    "apiVersion": "v1",</span></span><br><span class="line"><span class="string">						                    "kind": "ReplicationController",</span></span><br><span class="line"><span class="string">						                    "name": "foo",</span></span><br><span class="line"><span class="string">						                    "uid": "abcdef123456",</span></span><br><span class="line"><span class="string">						                    "controller": true</span></span><br><span class="line"><span class="string">						                &#125;</span></span><br><span class="line"><span class="string">						            &#125;,</span></span><br><span class="line"><span class="string">						            "reason": "some reason",</span></span><br><span class="line"><span class="string">						            "message": "some message"</span></span><br><span class="line"><span class="string">						        &#125;</span></span><br><span class="line"><span class="string">						    ]</span></span><br><span class="line"><span class="string">						&#125;`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在检查的时候，对于那些不被 <code>ReplicaSet</code> 和 <code>ReplicationController</code> 拥有的 Pod，直接跳过，给予最高分。如果和 <code>annotation</code> 中标记的相同，那么给予最低分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePreferAvoidPods)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">	nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node := nodeInfo.Node()</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	controllerRef := metav1.GetControllerOf(pod)</span><br><span class="line">	<span class="keyword">if</span> controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Ignore pods that are owned by other controller than ReplicationController</span></span><br><span class="line">		<span class="comment">// or ReplicaSet.</span></span><br><span class="line">		<span class="keyword">if</span> controllerRef.Kind != <span class="string">"ReplicationController"</span> &amp;&amp; controllerRef.Kind != <span class="string">"ReplicaSet"</span> &#123;</span><br><span class="line">			controllerRef = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	avoids, err := v1helper.GetAvoidPodsFromNodeAnnotations(node.Annotations)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// If we cannot get annotation, assume it's schedulable there.</span></span><br><span class="line">		<span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> avoids.PreferAvoidPods &#123;</span><br><span class="line">		avoid := &amp;avoids.PreferAvoidPods[i]</span><br><span class="line">		<span class="keyword">if</span> avoid.PodSignature.PodController.Kind == controllerRef.Kind &amp;&amp; avoid.PodSignature.PodController.UID == controllerRef.UID &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodePreferAvoidPodsPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, nodepreferavoidpods.Name, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="NodeAffinityPriority"><a href="#NodeAffinityPriority" class="headerlink" title="NodeAffinityPriority"></a>NodeAffinityPriority</h4><p><code>NodeAffinityPriority</code>策略用于满足Pod与Node之间的亲和与反亲和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="comment">// A nil element of PreferredDuringSchedulingIgnoredDuringExecution matches no objects.</span></span><br><span class="line"><span class="comment">// An element of PreferredDuringSchedulingIgnoredDuringExecution that refers to an</span></span><br><span class="line"><span class="comment">// empty PreferredSchedulingTerm matches all objects.</span></span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// Match PreferredDuringSchedulingIgnoredDuringExecution term by term.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution &#123;</span><br><span class="line">		preferredSchedulingTerm := &amp;affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i]</span><br><span class="line">		<span class="keyword">if</span> preferredSchedulingTerm.Weight == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Avoid computing it for all nodes if this becomes a performance problem.</span></span><br><span class="line">		nodeSelector, err := v1helper.NodeSelectorRequirementsAsSelector(preferredSchedulingTerm.Preference.MatchExpressions)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> nodeSelector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line">			count += <span class="keyword">int64</span>(preferredSchedulingTerm.Weight)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodeAffinityPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, nodeaffinity.Name, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="TaintTolerationPriority"><a href="#TaintTolerationPriority" class="headerlink" title="TaintTolerationPriority"></a>TaintTolerationPriority</h4><p><code>TaintTolerationPriority</code> 策略，Pod 对 Node 的 taint 容忍程度越高，优先级越大。</p>
<p>在 <code>PreScore</code> 阶段，拿到所有 <code>all Tolerations with Effect PreferNoSchedule or with no effect</code>，并将其写到cycleState。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">PreScore</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodes []*v1.Node)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	tolerationsPreferNoSchedule := getAllTolerationPreferNoSchedule(pod.Spec.Tolerations)</span><br><span class="line">	state := &amp;preScoreState&#123;</span><br><span class="line">		tolerationsPreferNoSchedule: tolerationsPreferNoSchedule,</span><br><span class="line">	&#125;</span><br><span class="line">	cycleState.Write(preScoreStateKey, state)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Score</code> 阶段，具体算法就是Pod不能容忍的taint越多，那么得分就越高（之后会在Normalize处正则化，将得分逆序），也就是其优先级越低。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">	nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">	&#125;</span><br><span class="line">	node := nodeInfo.Node()</span><br><span class="line"></span><br><span class="line">	s, err := getPreScoreState(state)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	score := <span class="keyword">int64</span>(countIntolerableTaintsPreferNoSchedule(node.Spec.Taints, s.tolerationsPreferNoSchedule))</span><br><span class="line">	<span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(TaintTolerationPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.PreScore = appendToPluginSet(plugins.PreScore, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, tainttoleration.Name, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="ImageLocalityPriority"><a href="#ImageLocalityPriority" class="headerlink" title="ImageLocalityPriority"></a>ImageLocalityPriority</h4><p><code>ImageLocalityPriority</code>策略主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumImageScores</span><span class="params">(nodeInfo *framework.NodeInfo, containers []v1.Container, totalNumNodes <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">for</span> _, container := <span class="keyword">range</span> containers &#123;</span><br><span class="line">		<span class="keyword">if</span> state, ok := nodeInfo.ImageStates[normalizedImageName(container.Image)]; ok &#123;</span><br><span class="line">			sum += scaledImageScore(state, totalNumNodes)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(ImageLocalityPriority,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, imagelocality.Name, &amp;args.Weight)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="NodeLabel"><a href="#NodeLabel" class="headerlink" title="NodeLabel"></a>NodeLabel</h4><p><code>NodeLabel</code>策略主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">	nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v, node is nil: %v"</span>, nodeName, err, nodeInfo.Node() == <span class="literal">nil</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node := nodeInfo.Node()</span><br><span class="line">	score := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.PresentLabelsPreference &#123;</span><br><span class="line">		<span class="keyword">if</span> labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">			score += framework.MaxNodeScore</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.AbsentLabelsPreference &#123;</span><br><span class="line">		<span class="keyword">if</span> !labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">			score += framework.MaxNodeScore</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Take average score for each label to ensure the score doesn't exceed MaxNodeScore.</span></span><br><span class="line">	score /= <span class="keyword">int64</span>(<span class="built_in">len</span>(pl.args.PresentLabelsPreference) + <span class="built_in">len</span>(pl.args.AbsentLabelsPreference))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法注册逻辑：</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(nodelabel.Name,</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">		<span class="comment">// If there are n LabelPreference priorities in the policy, the weight for the corresponding</span></span><br><span class="line">		<span class="comment">// score plugin is n*weight (note that the validation logic verifies that all LabelPreference</span></span><br><span class="line">		<span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">		weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.NodeLabelArgs.PresentLabelsPreference)+<span class="built_in">len</span>(args.NodeLabelArgs.AbsentLabelsPreference))</span><br><span class="line">		plugins.Score = appendToPluginSet(plugins.Score, nodelabel.Name, &amp;weight)</span><br><span class="line">		<span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">			pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">				config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>scheduler</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】ApiServer之初识API</title>
    <url>/posts/3bc1a603/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>ApiServer</code>作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。</p>
<p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：</p>
<ul>
<li>提供 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用</li>
<li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；</li>
<li>允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd</li>
<li>资源在不同版本之间的转换</li>
</ul>
<a id="more"></a>
<h2 id="API-Overview"><a href="#API-Overview" class="headerlink" title="API Overview"></a>API Overview</h2><p>ApiServer 主要通过对外提供HTTP API 的方式与其他组件进行交互。API首选的序列化方案是JSON，但是也支持Protobuf协议。API主要有下面三种类型：</p>
<ul>
<li>core group：主要在 <code>/api/v1</code> 下；</li>
<li>named groups：其 path 为 <code>/apis/$NAME/$VERSION</code>；</li>
<li>暴露系统状态的一些 API：如<code>/metrics</code> 、<code>/healthz</code> 等；</li>
</ul>
<p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-space-1.png"></p>
<h3 id="GVK-GVR"><a href="#GVK-GVR" class="headerlink" title="GVK/GVR"></a>GVK/GVR</h3><p><img alt="Terminology" data-src="https://www.openshift.com/hs-fs/hubfs/Imported_Blog_Media/API-server-gvr.png?width=400&amp;height=152&amp;name=API-server-gvr.png"></p>
<p>在Kubernetes中，要想定位一个对象，我们需要指定GVK或者GVR。比如这里声明了 apiVersion 是 <code>apps/v1</code>，其实就是隐含了 <code>Group</code> 是 apps，<code>Version</code> 是 v1，<code>Kind</code> 就是定义的 DaemonSet，而 kubectl 接收到这个声明之后，就可以根据这个声明去调用 API Server 对应的 URL 去获取信息，例如这个就是 <code>/api/apps/v1/daemonset</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br></pre></td></tr></table></figure>
<p>对应到实际的URI的请求组织形式，如下图所示：</p>
<p><img alt="GVR" data-src="http://images.liuliqiang.info/2019/11/24/02/25/56/d14b874da710/"></p>
<p>通过结构体字段可以发现，它们其实就是Group、Version、Kind、Resource的不同组合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">	Kind    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Version  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">	Resource <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Kind  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><p>Kubernetes中的每个对象都有一个字段 <code>Kind</code> 表明其类型，以Pod为例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p><code>Kubernetes</code> 中 Kind 有三种类型：</p>
<ul>
<li>系统中持久的实体对象，比如 <code>Pod</code> , <code>Namespace</code></li>
<li>一系列有某些共同特征的实体列表，比如 <code>PodLists</code>，<code>NodeLists</code></li>
<li>用于某些特定应用的一些非持久的实体，比如 <code>APIGroup</code>，<code>APIResource</code>, <code>Status</code></li>
</ul>
<p>Kind就是一个资源对象对应的种类 kind是通过<code>Kind=reflector.TypeOf(&amp;Pod{}).Elem().Name()</code>进行取值，取得的就是Pod这个结构体的名字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> PodList <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> NodeList <span class="keyword">struct</span></span><br></pre></td></tr></table></figure>
<h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p><code>API Group</code> 是一些有关系的Kinds的集合，比如所有的批处理对象，<code>Job</code> 或者 <code>ScheduledJob</code> 都在 <code>batch</code>这个API Group。</p>
<p>各个Group是相互独立的，发展速度也不同，所有每个Group都会有不同的Version，而kubernetes是通过插件的方式来使用各个Group的，可以根据需求决定使用哪个Group。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Group="core"</span></span><br><span class="line"><span class="string">Version=v1</span></span><br><span class="line"></span><br><span class="line"><span class="string">Group="apps"</span></span><br><span class="line"><span class="string">Version=v1beta1</span></span><br></pre></td></tr></table></figure>
<p><code>GroupMeta</code>主要包括Group的元信息，里面的成员RESTMapper，与APIGroupVersion一样，其实APIGroupVersion的RESTMapper直接取值于GroupMeta的RESTMapper。一个Group可能包含多个版本，存储在 GroupVersions 中，而 GroupVersion 是默认存储在etcd中的版本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// GroupVersion represents the preferred version of the group.</span></span><br><span class="line">	<span class="comment">// 该group的默认版本</span></span><br><span class="line">	GroupVersion unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GroupVersions is Group + all versions in that group.</span></span><br><span class="line">	<span class="comment">// 该Group中可能会有多个版本，该字段就包含了所有的versions</span></span><br><span class="line">	GroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Codec is the default codec for serializing output that should use</span></span><br><span class="line">	<span class="comment">// the preferred version.  Use this Codec when writing to</span></span><br><span class="line">	<span class="comment">// disk, a data store that is not dynamically versioned, or in tests.</span></span><br><span class="line">	<span class="comment">// This codec can decode any object that the schema is aware of.</span></span><br><span class="line">	<span class="comment">// 用于编解码</span></span><br><span class="line">	Codec runtime.Codec</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SelfLinker can set or get the SelfLink field of all API types.</span></span><br><span class="line">	<span class="comment">// to go through the InterfacesFor method below.</span></span><br><span class="line">	SelfLinker runtime.SelfLinker</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known</span></span><br><span class="line">	<span class="comment">// versions.</span></span><br><span class="line">	<span class="comment">// RESTMapper提供 REST路径 与 那些在api.Scheme和所有已知版本中声明的对象之间的默认映射。用于类型，对象之间的转换</span></span><br><span class="line"></span><br><span class="line">	RESTMapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line">	<span class="comment">// InterfacesFor returns the default Codec and ResourceVersioner for a given version</span></span><br><span class="line">	<span class="comment">// string, or an error if the version is not known.</span></span><br><span class="line">	<span class="comment">// function provided below once every place that populates this field has been changed.</span></span><br><span class="line">	InterfacesFor <span class="function"><span class="keyword">func</span><span class="params">(version unversioned.GroupVersion)</span> <span class="params">(*meta.VersionInterfaces, error)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InterfacesByVersion stores the per-version interfaces.</span></span><br><span class="line">	InterfacesByVersion <span class="keyword">map</span>[unversioned.GroupVersion]*meta.VersionInterfaces</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>每个 API Group 下面都能存在有多个 version 版本。为了扩展性，Kubernetes支持多版本的API路径，比如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1/</code>， 不同版本的API意味着不同程度的稳定性和支持度。比如在一个 group 群组中最早有第一个 v1alpha1 版本，后来中间发展到了 v1beta1 版本，最终发展到 v1 的稳定版本。 如果在系统创建了一个 v1beta1 版本的对象，那么它能过被 Group 任一支持的版本（ 比如v1 ）检索到， 这是由于 API server 能够支持不同版本对象之间的无损耗转换。</p>
<p><strong>type GroupVersion struct</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GroupVersion</code>中就是两个string类型，<code>Group</code>和<code>Version</code>，分别对应了api所处的分组和版本，这也是kubernetes实现多版本的基础。</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Resource 代表以 JSON 格式通过 HTTP 发送或检索的资源实体。 它既可以使一个单独的resource资源（比如…/namespaces/default，也可以是一组resource 资源（比如…/jobs）。 这里说明一下 Reource 和 Kind 的区别： 其实基本上都是一个概念，只是 Kind 表示一个种类，在实际中它是首字母大写的； Resource 表示资源，在实际中它是全部小写的，并且有单数和复数之分。我们可以把Kind和Resource的关系理解成面向对象编程中类与对象的关系，Kind 其实就是一个类，用于描述对象的；而 Resource 就是具体的 Kind，可以理解成类已经实例化成对象。</p>
<p>Resource就是指定了一个名字和kind的资源对象，不管它有没有namespace。 resource是通过<code>plural, singular := KindToResource(kind)</code>取值，singular是将Kind转换为小写字母，而plural是变为复数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// name is the name of the resource.</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line">	<span class="comment">// namespaced indicates if a resource is namespaced or not.</span></span><br><span class="line">	Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line">	<span class="comment">// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')</span></span><br><span class="line">	Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reousrce := unversioned.APIResource&#123;</span><br><span class="line">		Name:       <span class="string">"nodes"</span>, </span><br><span class="line">		Namespaced: <span class="literal">false</span>,</span><br><span class="line">		Kind:       <span class="string">"Node"</span>, </span><br><span class="line">	&#125;</span><br><span class="line">reousrce = unversioned.APIResource&#123;</span><br><span class="line">		Name:       <span class="string">"pods"</span>,</span><br><span class="line">		Namespaced: <span class="literal">true</span>,</span><br><span class="line">		Kind:       <span class="string">"Pod"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="资源外部版本与内部版本"><a href="#资源外部版本与内部版本" class="headerlink" title="资源外部版本与内部版本"></a>资源外部版本与内部版本</h4><h4 id="资源代码定义"><a href="#资源代码定义" class="headerlink" title="资源代码定义"></a>资源代码定义</h4><h4 id="将资源注册到资源注册表"><a href="#将资源注册到资源注册表" class="headerlink" title="将资源注册到资源注册表"></a>将资源注册到资源注册表</h4><h4 id="资源首选版本"><a href="#资源首选版本" class="headerlink" title="资源首选版本"></a>资源首选版本</h4><h4 id="资源操作方法"><a href="#资源操作方法" class="headerlink" title="资源操作方法"></a>资源操作方法</h4><h4 id="资源与命名空间"><a href="#资源与命名空间" class="headerlink" title="资源与命名空间"></a>资源与命名空间</h4><h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><h4 id="资源对象描述文件定义"><a href="#资源对象描述文件定义" class="headerlink" title="资源对象描述文件定义"></a>资源对象描述文件定义</h4><h3 id="Kubernetes内置资源全图"><a href="#Kubernetes内置资源全图" class="headerlink" title="Kubernetes内置资源全图"></a>Kubernetes内置资源全图</h3><h3 id="runtime-Object-类型基石"><a href="#runtime-Object-类型基石" class="headerlink" title="runtime.Object 类型基石"></a>runtime.Object 类型基石</h3><h3 id="Unstructured数据"><a href="#Unstructured数据" class="headerlink" title="Unstructured数据"></a>Unstructured数据</h3><h3 id="Scheme资源注册表"><a href="#Scheme资源注册表" class="headerlink" title="Scheme资源注册表"></a>Scheme资源注册表</h3><h4 id="Scheme资源注册表数据结构"><a href="#Scheme资源注册表数据结构" class="headerlink" title="Scheme资源注册表数据结构"></a>Scheme资源注册表数据结构</h4><h4 id="资源注册表注册方法"><a href="#资源注册表注册方法" class="headerlink" title="资源注册表注册方法"></a>资源注册表注册方法</h4><h4 id="资源注册表查询方法"><a href="#资源注册表查询方法" class="headerlink" title="资源注册表查询方法"></a>资源注册表查询方法</h4><h3 id="Codec编解码器"><a href="#Codec编解码器" class="headerlink" title="Codec编解码器"></a>Codec编解码器</h3><h4 id="Codec编解码实例化"><a href="#Codec编解码实例化" class="headerlink" title="Codec编解码实例化"></a>Codec编解码实例化</h4><h4 id="jsonSerializer-与-yamlSerializer序列化器"><a href="#jsonSerializer-与-yamlSerializer序列化器" class="headerlink" title="jsonSerializer 与 yamlSerializer序列化器"></a>jsonSerializer 与 yamlSerializer序列化器</h4><h4 id="protobufSerializer序列化器"><a href="#protobufSerializer序列化器" class="headerlink" title="protobufSerializer序列化器"></a>protobufSerializer序列化器</h4><h3 id="Converter-资源版本转换器"><a href="#Converter-资源版本转换器" class="headerlink" title="Converter 资源版本转换器"></a>Converter 资源版本转换器</h3><h4 id="Converter-转换器数据结构"><a href="#Converter-转换器数据结构" class="headerlink" title="Converter 转换器数据结构"></a>Converter 转换器数据结构</h4><h4 id="Converter注册转换函数"><a href="#Converter注册转换函数" class="headerlink" title="Converter注册转换函数"></a>Converter注册转换函数</h4><h4 id="Converter-资源版本转换原理"><a href="#Converter-资源版本转换原理" class="headerlink" title="Converter 资源版本转换原理"></a>Converter 资源版本转换原理</h4><h2 id="API-Request-Flow"><a href="#API-Request-Flow" class="headerlink" title="API Request Flow"></a>API Request Flow</h2><p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</p>
<p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-flow-2.png"></p>
<p>关于 API 的处理代码都在 <code>k8s.io/pkg/api</code> 包中，会处理来自集群内部和集群外部的API请求。</p>
<p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链。该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互。</p>
<h3 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h3><p>一个HTTP Request首先会被 <code>DefaultBuildHandlerChain</code>注册的 filter chain处理，每一个filter会传递各自的info到 <code>ctx.RequestInfo</code>上。</p>
<ul>
<li><code>WithRequestInfo()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/requestinfo.go" target="_blank" rel="external nofollow noopener noreferrer">requestinfo.go</a> attaches a <code>RequestInfo</code> to the context</li>
<li><code>WithMaxInFlightLimit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/maxinflight.go" target="_blank" rel="external nofollow noopener noreferrer">maxinflight.go</a> limits the number of in-flight requests</li>
<li><code>WithTimeoutForNonLongRunningRequests()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/timeout.go" target="_blank" rel="external nofollow noopener noreferrer">timeout.go</a> times out non-long-running requests like most <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code> requests in contrast to long-running requests like watches and proxy requests</li>
<li><code>WithPanicRecovery()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/wrap.go" target="_blank" rel="external nofollow noopener noreferrer">wrap.go</a> wraps an handler to recover and log panics</li>
<li><code>WithCORS()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/cors.go" target="_blank" rel="external nofollow noopener noreferrer">cors.go</a> provides a CORS implementation; CORS stands for Cross-Origin Resource Sharing and is a mechanism that allows JavaScript embedded in a HTML page to make XMLHttpRequests to a domain different from the one the JavaScript originated from.</li>
<li><code>WithAuthentication()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authentication.go" target="_blank" rel="external nofollow noopener noreferrer">authentication.go</a> tries to authenticate the given request as a user and stores the user info in the provided context. On success, the <code>Authorization</code> HTTP header is removed from the request.</li>
<li><code>WithAudit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/audit.go" target="_blank" rel="external nofollow noopener noreferrer">audit.go</a> decorates the handler with audit logging information for all incoming requests The audit log entries contain infos such as source IP of the request, user invoking the operation, and namespace of the request.</li>
<li><code>WithImpersonation()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/impersonation.go" target="_blank" rel="external nofollow noopener noreferrer">impersonation.go</a> handles user impersonation, by checking requests that attempt to change the user (similar to sudo).</li>
<li><code>WithAuthorization()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authorization.go" target="_blank" rel="external nofollow noopener noreferrer">authorization.go</a> passes all authorized requests on to multiplexer which dispatched the request to the right handler, and returns a forbidden error otherwise.</li>
</ul>
<ul>
<li>WithRequestInfo：</li>
<li>MaxInflightLimit</li>
<li>TimeoutForNonLongRunningRequests</li>
<li>Panic Recovery</li>
<li>CORS</li>
<li>Authentication</li>
<li>Audit</li>
<li>Impersonation</li>
<li>Authorization</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">	<span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)</span><br><span class="line">	&#125;</span><br><span class="line">	handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">	handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">	failedHandler := genericapifilters.Unauthorized(c.Serializer)</span><br><span class="line">	failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">	handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)</span><br><span class="line">	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"true"</span>)</span><br><span class="line">	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">	handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)</span><br><span class="line">	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)</span><br><span class="line">	<span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &amp;&amp; !c.SecureServing.DisableHTTP2 &amp;&amp; c.GoawayChance &gt; <span class="number">0</span> &#123;</span><br><span class="line">		handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)</span><br><span class="line">	&#125;</span><br><span class="line">	handler = genericapifilters.WithAuditAnnotations(handler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">	handler = genericapifilters.WithWarningRecorder(handler)</span><br><span class="line">	handler = genericapifilters.WithCacheControl(handler)</span><br><span class="line">	handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line">	<span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Handler-Operation"><a href="#Handler-Operation" class="headerlink" title="Handler Operation"></a>Handler Operation</h3><p>当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：</p>
<p><img alt="API-server-storage-flow-2" data-src="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png"></p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a><strong>Decoder</strong></h3><p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。</p>
<h3 id="Admission"><a href="#Admission" class="headerlink" title="Admission"></a><strong>Admission</strong></h3><p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 <code>k8s.io/kubernetes/plugin/pkg/admission</code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 <code>--enable-admission-plugins</code> 参数来开启需要使用的插件，通过 <code>ValidatingAdmissionWebhook</code> 或 <code>MutatingAdmissionWebhook</code> 添加的插件也都会在此处进行工作。</p>
<h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a><strong>Validation</strong></h3><p>主要检查 object 中字段的合法性。</p>
<p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |<span class="string">    ⇒       </span>|<span class="string">    ⇒  v1  ⇒ json/yaml ⇒ etcd</span></span><br><span class="line"><span class="string">                     admission    validation</span></span><br></pre></td></tr></table></figure>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img alt="apiserver diagram" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png"></p>
<ul>
<li>Scheme：定义了资源序列化和反序列化的方法，以及资源类型和版本的对应关系</li>
<li>Storage：是对资源的完整封装，实现了资源创建、删除、watch等操作</li>
<li>APIGroupInfo：是同一个group下所有资源的集合</li>
</ul>
<p>每个资源对应着两个版本：</p>
<ul>
<li>External Object：这个版本是对外给用户访问创建的接口对象，比如使用yaml或json创建对象时，都要使用External Object</li>
<li>Internal Object：这个版本是核心对象，实现了资源的创建和删除，对应了在ETCD中持久化的版本</li>
</ul>
<p>这两个版本的资源是需要相互转换的，而转换的函数就需要事先初始化到Scheme中， 多个external version版本之间的资源进行相互转换，都是需要通过internal version进行中转。所以在ETCD中存储的资源是带版本的，这也是kubernetes能实现多版本转换的关键。</p>
<h2 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h2><p>ApiServer 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：</p>
<ul>
<li><strong>Aggregator</strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；</li>
<li><strong>KubeAPIServer</strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；</li>
<li><strong>APIExtensionServer</strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。</li>
</ul>
<p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。</p>
<h3 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h3><p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 <code>GenericAPIServer</code> 和维护自身状态的 Controller。其中 <code>GenericAPIServer</code> 主要处理 <code>apiregistration.k8s.io</code> 组下的 APIService 资源请求。</p>
<p><strong>Aggregator 除了处理资源请求外还包含几个 controller：</strong></p>
<ul>
<li><code>apiserviceRegistrationController</code>：负责 APIServices 中资源的注册与删除；</li>
<li><code>availableConditionController</code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；</li>
<li><code>autoRegistrationController</code>：用于保持 API 中存在的一组特定的 APIServices；</li>
<li><code>crdRegistrationController</code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；</li>
<li><code>openAPIAggregationController</code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；</li>
</ul>
<p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="external nofollow noopener noreferrer">apiserver-builder</a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。</p>
<h4 id="启用-API-Aggregation"><a href="#启用-API-Aggregation" class="headerlink" title="启用 API Aggregation"></a>启用 API Aggregation</h4><p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--proxy-client-cert-file=/etc/kubernetes/certs/proxy.crt</span><br><span class="line">--proxy-client-key-file=/etc/kubernetes/certs/proxy.key</span><br><span class="line">--requestheader-client-ca-file=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line">--requestheader-allowed-names=aggregator</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra-</span><br><span class="line">--requestheader-group-headers=X-Remote-Group</span><br><span class="line">--requestheader-username-headers=X-Remote-User</span><br></pre></td></tr></table></figure>
<h3 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h3><p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。</p>
<h3 id="APIExtensionServer"><a href="#APIExtensionServer" class="headerlink" title="APIExtensionServer"></a>APIExtensionServer</h3><p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。</p>
<p>其中包含的 controller 以及功能如下所示：</p>
<ul>
<li><code>openapiController</code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 <code>/openapi/v2</code> 进行查看；</li>
<li><code>crdController</code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 <code>$ kubectl api-versions</code> 和 <code>$ kubectl api-resources</code> 查看；</li>
<li><code>namingController</code>：检查 crd obj 中是否有命名冲突，可在 crd <code>.status.conditions</code> 中查看；</li>
<li><code>establishingController</code>：检查 crd 是否处于正常状态，可在 crd <code>.status.conditions</code> 中查看；</li>
<li><code>nonStructuralSchemaController</code>：检查 crd obj 结构是否正常，可在 crd <code>.status.conditions</code> 中查看；</li>
<li><code>apiApprovalController</code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd <code>.status.conditions</code> 中查看；</li>
<li><code>finalizingController</code>：类似于 finalizes 的功能，与 CRs 的删除有关；</li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>k8s</tag>
        <tag>源码阅读</tag>
        <tag>apiserver</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】Go Module</title>
    <url>/posts/55d129f1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="依赖管理机制"><a href="#依赖管理机制" class="headerlink" title="依赖管理机制"></a>依赖管理机制</h2><p>软件包管理问题，难点，其他语言是怎么做的，Go语言怎么演进的？</p><blockquote>
<p>An explicit goal for Go from the beginning was to be able to build Go code using only the information found in the source itself, not needing to write a makefile or one of the many modern replacements for makefiles. If Go needed a configuration file to explain how to build your program, then Go would have failed.</p>
</blockquote><a id="more"></a>

<h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。</p>
<p>Go在构建设计方面深受Google内部开发实践的影响，比如go get的设计就深受<a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/pdf" target="_blank" rel="external nofollow noopener noreferrer">Google内部单一代码仓库(single monorepo)和基于主干(trunk/mainline based)的开发模型</a>的影响：只获取Trunk/mainline代码和版本无感知。</p>
<p><img alt data-src="https://tonybai.com/wp-content/uploads/google-trunk-based-and-release-branch-dev-model.png"></p>
<blockquote>
<p>Google内部基于主干的开发模型：<br>– 所有开发人员基于主干trunk/mainline开发：提交到trunk或从trunk获取最新的代码（同步到本地workspace）<br>– 版本发布时，建立Release branch，release branch实质上就是某一个时刻主干代码的快照；<br>– 必须同步到release branch上的bug fix和增强改进代码也通常是先在主干上提交(commit)，然后再cherry-pick到release branch上</p>
</blockquote>
<p>我们知道go get获取的代码会放在<code>$GOPATH/src</code>下面，而go build会在<code>$GOROOT/src</code>和 <code>$GOPATH/src</code>下面按照import path去搜索package，由于go get 获取的都是各个package repo的trunk/mainline的代码，因此，<a href="https://tonybai.com/2015/07/10/some-changes-in-go-1-5/" target="_blank" rel="external nofollow noopener noreferrer">Go 1.5</a>之前的Go compiler都是基于目标Go程序依赖包的trunk/mainline代码去编译的。这样的机制带来的问题是显而易见的，至少包括：</p>
<ul>
<li>因依赖包的trunk的变化，导致不同人获取和编译你的包/程序时得到的结果实质是不同的，即不能实现reproduceable build</li>
<li>因依赖包的trunk的变化，引入不兼容的实现，导致你的包/程序无法通过编译</li>
<li>因依赖包演进而无法通过编译，导致你的包/程序无法通过编译</li>
</ul>
<h3 id="Vendor"><a href="#Vendor" class="headerlink" title="Vendor"></a>Vendor</h3><p>为了实现reporduceable build，Go 1.5引入了<a href="https://tonybai.com/2015/07/31/understand-go15-vendor/" target="_blank" rel="external nofollow noopener noreferrer">Vendor机制</a>，Go编译器会优先在vendor下搜索依赖的第三方包，这样如果开发者将特定版本的依赖包存放在vendor下面并提交到code repo，那么所有人理论上都会得到同样的编译结果，从而实现reporduceable build。</p>
<p>在Go 1.5发布后的若干年，gopher们把注意力都集中在如何利用vendor解决包依赖问题，从手工添加依赖到vendor、手工更新依赖，到一众包依赖管理工具的诞生：比如: <a href="https://github.com/kardianos/govendor" target="_blank" rel="external nofollow noopener noreferrer">govendor</a>、<a href="https://github.com/Masterminds/glide" target="_blank" rel="external nofollow noopener noreferrer">glide</a>以及号称准官方工具的<a href="https://github.com/golang/dep" target="_blank" rel="external nofollow noopener noreferrer">dep</a>，努力地尝试着按照当今主流思路解决着诸如：<code>菱形依赖</code>等难题。</p>
<p>正当gopher认为dep将“顺理成章”地升级为go toolchain一部分的时候，vgo横空出世，并通过对<code>Semantic Import Versioning</code> 和 <code>Minimal Version Selected</code>的设定，在原 Go tools上简单快速地实现了Go原生的包依赖管理方案，vgo就是go module的前身。</p>
<h3 id="Go-Module"><a href="#Go-Module" class="headerlink" title="Go Module"></a>Go Module</h3><p>不过官方并不认同这种方式，在 v1.11 中加入了 Go Module 作为官方包管理形式，就这样 dep 无奈的结束了使命。最初的 Go Module 提案的名称叫做 vgo，下面为了介绍简称为 gomod。不过在 v1.11 和 v1.12 的 Go 版本中 gomod 是不能直接使用的。可以通过 <code>go env</code> 命令返回值的 <code>GOMOD</code> 字段是否为空来判断是否已经开启了 gomod，如果没有开启，可以通过设置环境变量 <code>export GO111MODULE=on</code> 开启。</p>
<p>目前 gomod 在 Go v1.12 功能基本稳定，到下一个版本 v1.13 将默认开启，是时候开始在项目中使用 gomod 了。</p>
<p>自从 Go 官方从去年推出 1.11 之后，增加新的依赖管理模块并且更加易于管理项目中所需要的模块。模块是存储在文件树中的 Go 包的集合，其根目录中包含 go.mod 文件。 go.mod 文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求。每个依赖性要求都被写为模块路径和特定语义版本。</p>
<p>从 Go 1.11 开始，Go 允许在 <code>$GOPATH/src</code> 外的任何目录下使用 go.mod 创建项目。在<code>$GOPATH/src</code> 中，为了兼容性，Go 命令仍然在旧的 GOPATH 模式下运行。从 Go 1.13 开始，模块模式将成为默认模式。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>你可以在 $GOPATH/src 之外的任何地方创建一个新的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /tmp/scratchpad/repo &amp;&amp; <span class="built_in">cd</span> /tmp/scratchpad/repo</span><br></pre></td></tr></table></figure>
<p>初始化一个新的模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod init github.com/SimpCosm/repo</span><br><span class="line">go: creating new go.mod: module github.com/SimpCosm/repo</span><br></pre></td></tr></table></figure>
<p>成功之后你会发现目录下会生成一个 go.mod 文件。首行为当前的模块名称，接下来是 go 的使用版本。这两行和 <code>npm package.json</code> 的 <code>name</code> 和 <code>engine</code> 字段的功能很类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module github.com/SimpCosm/repo</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure>
<p>创建一个文件 main.go 然后加入以下代码，这里直接 import 了 Go 维护者 Russ Cox 写一个简单的库，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"rsc.io/quote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并且运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build -o hello</span><br><span class="line">go: finding module <span class="keyword">for</span> package rsc.io/quote</span><br><span class="line">go: downloading rsc.io/quote v1.5.2</span><br><span class="line">go: found rsc.io/quote <span class="keyword">in</span> rsc.io/quote v1.5.2</span><br><span class="line">go: downloading rsc.io/sampler v1.3.0</span><br><span class="line">go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
<p><code>go build</code> 之后，会在 go.mod 引入所需要的依赖包。之后再来看看 go.mod 文件的情况，require 就是本项目所需要的所有依赖包 并且在每个依赖包的后面已经表明了版本号。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">module github.com/SimpCosm/repo</span><br><span class="line"></span><br><span class="line">go <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<p>与此同时，工程目录下多了一个 <code>go.sum</code>文件，有点类似于 <code>npm package-lock.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">golang.org&#x2F;x&#x2F;text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8&#x3D;</span><br><span class="line">golang.org&#x2F;x&#x2F;text v0.0.0-20170915032832-14c0d48ead0c&#x2F;go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi&#x2F;IjpwHt7yyuwOQ&#x3D;</span><br><span class="line">rsc.io&#x2F;quote v1.5.2 h1:w5fcysjrx7yqtD&#x2F;aO+QwRjYZOKnaM9Uh2b40tElTs3Y&#x3D;</span><br><span class="line">rsc.io&#x2F;quote v1.5.2&#x2F;go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0&#x3D;</span><br><span class="line">rsc.io&#x2F;sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh&#x2F;QiW4&#x3D;</span><br><span class="line">rsc.io&#x2F;sampler v1.3.0&#x2F;go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA&#x3D;</span><br></pre></td></tr></table></figure>
<p>gomod 不会在 <code>$GOPATH/src</code> 目录下保存 <code>rsc.io/quote</code> 包的源码，而是包源码和链接库保存在 <code>$GOPATH/pkg/mod</code> 目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls $GOPATH&#x2F;pkg&#x2F;mod</span><br><span class="line">cache      golang.org rsc.io</span><br></pre></td></tr></table></figure>
<p>除了 <code>go run</code> 命令以外，<code>go build</code>、<code>go test</code> 等命令也能自动下载相关依赖包。</p>
<h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>可以看到，在上面的示例中完全没有使用 <code>go get</code> 命令，日常的工作流如下：</p>
<ul>
<li>编写 <code>.go</code> 代码，根据需要添加 import statements</li>
<li><code>go build</code> 或者 <code>go test</code> 命令会自动添加下载新的依赖来满足 import 的要求，并且更新 <code>go.mod</code> 文件</li>
<li>当对依赖的版本有特殊要求的时候，可以使用 <code>go get foo@v1.2.3</code>, <code>go get foo@master</code>, <code>go get foo@e3702bed2</code> 命令，或者直接编辑 <code>go.mod</code> 文件</li>
</ul>
<p>使用较多的命令初识：</p>
<ul>
<li><code>go list -m all</code> — 查看在编译中所有直接和非直接依赖的最终版本</li>
<li><code>go list -u -m all</code> — 查看所有直接和非直接依赖可用的升级补丁</li>
<li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> (from module root directory) — 更新所有直接和非直接以来到最新版本</li>
<li><code>go build ./...</code> or <code>go test ./...</code> (from module root directory) — 编译或测试模块中所有package</li>
<li><code>go mod tidy</code> — 移除不再需要的依赖，并且添加需要的依赖</li>
<li><code>replace</code> directive or <code>gohack</code> — 使用replace 指令</li>
<li><code>go mod vendor</code> — 可选的创造 <code>vendor</code> 目录</li>
</ul>
<h2 id="New-Concept"><a href="#New-Concept" class="headerlink" title="New Concept"></a>New Concept</h2><p>本小结提供了一些 <code>High-Level</code>的概念介绍。如果想要了解更多的细节，可以看这个40分钟的 <a href="https://www.youtube.com/watch?v=F8nrpe0XWRg&amp;list=PLq2Nv-Sh8EbbIjQgDzapOFeVfv5bGOoPE&amp;index=3&amp;t=0s" target="_blank" rel="external nofollow noopener noreferrer">Russ Cox 介绍 go module背后的设计哲学</a> 视频，也可以看官方的 <a href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" target="_blank" rel="external nofollow noopener noreferrer">Proposal</a>，或者是早期更详细的 <a href="https://research.swtch.com/vgo" target="_blank" rel="external nofollow noopener noreferrer">vgo博客系列</a> 。</p>
<h3 id="Modules-定义"><a href="#Modules-定义" class="headerlink" title="Modules 定义"></a>Modules 定义</h3><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><h3 id="Minimal-Version-Selection"><a href="#Minimal-Version-Selection" class="headerlink" title="Minimal Version Selection"></a>Minimal Version Selection</h3><h3 id="Semantic-Import-Versioning"><a href="#Semantic-Import-Versioning" class="headerlink" title="Semantic Import Versioning"></a>Semantic Import Versioning</h3><h2 id="How-to-Use-Modules"><a href="#How-to-Use-Modules" class="headerlink" title="How to Use Modules"></a>How to Use Modules</h2><h2 id="包管理命令"><a href="#包管理命令" class="headerlink" title="包管理命令"></a>包管理命令</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>如果要想先下载依赖，那么可以直接像以前那样 <code>go get</code> 即可，不过 gomod 下可以跟语义化版本号，比如 <code>go get foo@v1.2.3</code>，也可以跟 git 的分支或 tag，比如<code>go get foo@master</code>，当然也可以跟 git 提交哈希，比如 <code>go get foo@e3702bed2</code>。需要特别注意的是，gomod 除了遵循语义化版本原则外，还遵循最小版本选择原则，也就是说如果当前版本是 v1.1.0，只会下载不超过这个最大版本号。如果使用 <code>go get foo@master</code>，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码，如下所示，使用包含当前最新提交哈希的虚拟版本号替代直接的 <code>master</code> 版本号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get golang.org/x/crypto/sha3@master</span><br><span class="line">go: finding golang.org/x/crypto/sha3 latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/adesight/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect</span><br><span class="line">	rsc.io/quote v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果下载所有依赖可以使用 <code>go mod download</code> 命令。</p>
<h3 id="升级依赖"><a href="#升级依赖" class="headerlink" title="升级依赖"></a>升级依赖</h3><p>查看所有以升级依赖版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -u -m all</span><br><span class="line">go: finding golang.org/x/sys latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">github.com/adesight/<span class="built_in">test</span></span><br><span class="line">golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a [v0.0.0-20190316082340-a2f829d7f35f]</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.99.99</span><br></pre></td></tr></table></figure>
<p>升级次级或补丁版本号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u rsc.io/quote</span><br></pre></td></tr></table></figure>
<p>仅升级补丁版本号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u=patch rscio/quote</span><br></pre></td></tr></table></figure>
<p>升降级版本号，可以使用比较运算符控制：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get foo@<span class="string">'&lt;v1.6.2'</span></span><br></pre></td></tr></table></figure>
<h3 id="移除依赖"><a href="#移除依赖" class="headerlink" title="移除依赖"></a>移除依赖</h3><p>当前代码中不需要了某些包，删除相关代码片段后并没有在 <code>go.mod</code> 文件中自动移出。</p>
<p>运行下面命令可以移出所有代码中不需要的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>
<p>如果仅仅修改 <code>go.mod</code> 配置文件的内容，那么可以运行 <code>go mod edit --droprequire=path</code>，比如要移出 <code>golang.org/x/crypto</code> 包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod edit --droprequire=golang.org/x/crypto</span><br></pre></td></tr></table></figure>
<h3 id="查看依赖包"><a href="#查看依赖包" class="headerlink" title="查看依赖包"></a>查看依赖包</h3><p>可以直接查看 <code>go.mod</code> 文件，或者使用命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">github.com/adesight/<span class="built_in">test</span></span><br><span class="line">golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.99.99</span><br><span class="line">$ go list -m -json all <span class="comment"># json 格式输出</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"golang.org/x/text"</span>,</span><br><span class="line">        <span class="string">"Version"</span>: <span class="string">"v0.3.0"</span>,</span><br><span class="line">        <span class="string">"Time"</span>: <span class="string">"2017-12-14T13:08:43Z"</span>,</span><br><span class="line">        <span class="string">"Indirect"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"Dir"</span>: <span class="string">"/Users/lishude/go/pkg/mod/golang.org/x/text@v0.3.0"</span>,</span><br><span class="line">        <span class="string">"GoMod"</span>: <span class="string">"/Users/lishude/go/pkg/mod/cache/download/golang.org/x/text/@v/v0.3.0.mod"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"rsc.io/quote"</span>,</span><br><span class="line">        <span class="string">"Version"</span>: <span class="string">"v1.5.2"</span>,</span><br><span class="line">        <span class="string">"Time"</span>: <span class="string">"2018-02-14T15:44:20Z"</span>,</span><br><span class="line">        <span class="string">"Dir"</span>: <span class="string">"/Users/lishude/go/pkg/mod/rsc.io/quote@v1.5.2"</span>,</span><br><span class="line">        <span class="string">"GoMod"</span>: <span class="string">"/Users/lishude/go/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块配置文本格式化"><a href="#模块配置文本格式化" class="headerlink" title="模块配置文本格式化"></a>模块配置文本格式化</h3><p>由于可手动修改 go.mod 文件，所以可能此文件并没有被格式化，使用下面命令进行文本格式化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure>
<h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><p>发布包新版本和其它包管理工具基本一致，可以直接打标签，不过打标签之前需要在 go.mod 中写入相应的版本号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod edit --module=github.com/islishude/gomodtest/v2</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/islishude/gomodtest/v2</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect</span><br><span class="line">	rsc.io/quote v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>官方推荐将上述过程在一个新分支来避免混淆，那么类如上述例子可以创建一个 v2 分支，但这个不是强制要求的。</p>
<p>还有一种方式发布新版本，那就是在主线版本种加入 v2 文件夹，相应的也需要内置 go.mod 这个文件。</p>
<p>比如上述我们引入的 <a href="https://link.zhihu.com/?target=http%3A//rsc.io/quote" rel="external nofollow noopener noreferrer" target="_blank">http://rsc.io/quote</a> 包，其中 v3 版本是用内置文件夹，而 v2 使用的是 tag。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── buggy</span><br><span class="line">│   └── buggy_test.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── quote.go</span><br><span class="line">├── quote_test.go</span><br><span class="line">└── v3</span><br><span class="line">    ├── go.mod</span><br><span class="line">    ├── go.sum</span><br><span class="line">    └── quote.go</span><br><span class="line">$ git tag -a</span><br><span class="line">bad</span><br><span class="line">v1.0.0</span><br><span class="line">v1.1.0</span><br><span class="line">v1.2.0</span><br><span class="line">v1.2.1</span><br><span class="line">v1.3.0</span><br><span class="line">v1.4.0</span><br><span class="line">v1.5.0</span><br><span class="line">v1.5.1</span><br><span class="line">v1.5.2</span><br><span class="line">v1.5.3-pre1</span><br><span class="line">v2.0.0</span><br><span class="line">v2.0.1</span><br><span class="line">v3.0.0</span><br><span class="line">v3.1.0</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<p>根据上面的说明，想必你会看到一个问题，当我们升级主版本号的时候，要更改 module 名称，也就是上面所说的加上版本号，这就存在一个问题，如果我们要更新到主版本号的依赖就没有这么简单了，因为升级的依赖包路径都需要修改，<strong>这个在其它语言包管理以及 Go 第三方包管理工具都不存在的一点</strong>。</p>
<p>如下所示，升级 <code>rsc.io/quote</code> 到 v3 版本。注意一点，作为例子这里包作者对函数也加上了版本，其实大部分人是不会加的。这个模式叫做 <code>semantic import versioning</code>，也是备受争议，大多数人认为这个没有特别大的作用，而维护者则认为这是为了 Go 下一个十年的必要条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"rsc.io/quote/v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(quote.HelloV3())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于内部开发我觉得还挺好，让大家都了解，不要随意加入破坏性更新。</p>
<p>不过由于这个不讨喜功能，不同版本可以存在同一个包了。补充一句，对于 v0 和 v1 版本并不需要加入到 import path 内。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	q1 <span class="string">"rsc.io/quote"</span></span><br><span class="line">	<span class="string">"rsc.io/quote/v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(quote.HelloV3())</span><br><span class="line">	fmt.Println(q1.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从老项目迁移"><a href="#从老项目迁移" class="headerlink" title="从老项目迁移"></a>从老项目迁移</h3><p>从很多第三方的包管理工具迁移到 gomod 特别简单，直接运行 <code>go mod init</code> 即可。</p>
<p>如果没有使用任何第三方包管理工具，除了运行 <code>go mod init</code> 初始化以外，还要使用 <code>go get ./...</code> 下载安装所有依赖包，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</p>
<p>默认情况下，<code>go get</code> 命令使用 <code>@latest</code> 版本控制符对所有依赖进行下载，如果想要更改某一个包的版本，可以使用 <code>go mod edit --require</code> 命令，比如要更新 <code>rsc.io/quote</code> 到 v3.1.0 版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod edit --require=rsc.io/quote@v3.1.0</span><br></pre></td></tr></table></figure>
<h3 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a>GOSUMDB</h3><p>它的值是一个 Go checksum database，用于使 Go 在拉取模块版本时(无论是从源站拉取还是通过 Go module proxy 拉取)保证拉取到的模块版本数据未经篡改，也可以是“off”即禁止 Go 在后续操作中校验模块版本</p>
<ul>
<li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li>
<li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li>
<li>拥有默认值：<code>sum.golang.org</code> (之所以没有按照上面的格式是因为 Go 对默认值做了特殊处理)。</li>
<li>可被 Go module proxy 代理 (详见：Proxying a Checksum Database)。</li>
<li><code>sum.golang.org</code> 在中国无法访问，故而更加建议将 GOPROXY 设置为 <code>goproxy.cn</code>，因为 <code>goproxy.cn</code> 支持代理 <code>sum.golang.org</code>。</li>
</ul>
<h3 id="Go-Checksum-Database"><a href="#Go-Checksum-Database" class="headerlink" title="Go Checksum Database"></a>Go Checksum Database</h3><p>Go checksum database 主要用于保护 Go 不会从任何源头拉到被篡改过的非法 Go 模块版本，其作用（左）和工作机制（右）如下图：</p>
<p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76259e2243468"></p>
<p>如果有兴趣的小伙伴可以看看 <a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#proxying-a-checksum-database" target="_blank" rel="external nofollow noopener noreferrer">Proposal: Secure the Public Go Module Ecosystem</a>，有详细介绍其算法机制，如果想简单一点，查看 <code>go help module-auth</code> 也是一个不错的选择。</p>
<h3 id="GONOPROXY-GONOSUMDB-GOPRIVATE"><a href="#GONOPROXY-GONOSUMDB-GOPRIVATE" class="headerlink" title="GONOPROXY/GONOSUMDB/GOPRIVATE"></a>GONOPROXY/GONOSUMDB/GOPRIVATE</h3><p>这三个环境变量都是用在当前项目依赖了私有模块，也就是依赖了由 GOPROXY 指定的 Go module proxy 或由 GOSUMDB 指定 Go checksum database 无法访问到的模块时的场景</p>
<ul>
<li>它们三个的值都是一个以英文逗号 “,” 分割的模块路径前缀，匹配规则同 path.Match。</li>
<li>其中 GOPRIVATE 较为特殊，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是只是用 GOPRIVATE。</li>
</ul>
<p>在使用上来讲，比如 <code>GOPRIVATE=*.corp.example.com</code> 表示所有模块路径以 <code>corp.example.com</code> 的下一级域名 (如 <code>team1.corp.example.com</code>) 为前缀的模块版本都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 <code>corp.example.com</code> 本身。</p>
<h3 id="Global-Caching"><a href="#Global-Caching" class="headerlink" title="Global Caching"></a>Global Caching</h3><p>这个主要是针对 Go modules 的全局缓存数据说明，如下：</p>
<ul>
<li>同一个模块版本的数据只缓存一份，所有其他模块共享使用。</li>
<li>目前所有模块版本数据均缓存在 <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sum</code> 下，未来或将移至 <code>$GOCACHE/mod</code>和<code>$GOCACHE/sum</code> 下( 可能会在当 <code>$GOPATH</code> 被淘汰后)。</li>
<li>可以使用 <code>go clean -modcache</code> 清理所有已缓存的模块版本数据。</li>
</ul>
<p>另外在 Go1.11 之后 GOCACHE 已经不允许设置为 off 了，我想着这也是为了模块数据缓存移动位置做准备，因此大家应该尽快做好适配。</p>
<h2 id="快速迁移项目至-Go-Modules"><a href="#快速迁移项目至-Go-Modules" class="headerlink" title="快速迁移项目至 Go Modules"></a>快速迁移项目至 Go Modules</h2><ul>
<li>第一步: 升级到 Go 1.13。</li>
<li>第二步: 让 GOPATH 从你的脑海中完全消失，早一步踏入未来。<ul>
<li>修改 GOBIN 路径（可选）：<code>go env -w GOBIN=$HOME/bin</code>。</li>
<li>打开 Go modules：<code>go env -w GO111MODULE=on</code>。</li>
<li>设置 GOPROXY：<code>go env -w GOPROXY=https://goproxy.cn,direct</code> # 在中国是必须的，因为它的默认值被墙了。</li>
</ul>
</li>
<li>第三步(可选): 按照你喜欢的目录结构重新组织你的所有项目。</li>
<li>第四步: 在你项目的根目录下执行 <code>go mod init &lt;OPTIONAL_MODULE_PATH&gt;</code> 以生成 go.mod 文件。</li>
<li>第五步: 想办法说服你身边所有的人都去走一下前四步。</li>
</ul>
<h2 id="迁移后-go-get-行为的改变"><a href="#迁移后-go-get-行为的改变" class="headerlink" title="迁移后 go get 行为的改变"></a>迁移后 go get 行为的改变</h2><ul>
<li><p>用 <code>go help module-get</code> 和 <code>go help gopath-get</code>分别去了解 Go modules 启用和未启用两种状态下的 go get 的行为</p>
</li>
<li><p>用 <code>go get</code> 拉取新的依赖</p>
<ul>
<li>拉取最新的版本(优先择取 tag)：<code>go get golang.org/x/text@latest</code></li>
<li>拉取 <code>master</code> 分支的最新 commit：<code>go get golang.org/x/text@master</code></li>
<li>拉取 tag 为 v0.3.2 的 commit：<code>go get golang.org/x/text@v0.3.2</code></li>
</ul>
</li>
<li>拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：<code>go get golang.org/x/text@342b2e</code><ul>
<li>用 <code>go get -u</code> 更新现有的依赖</li>
</ul>
</li>
<li><p>用 <code>go mod download</code> 下载 go.mod 文件中指明的所有依赖</p>
<ul>
<li>用 <code>go mod tidy</code> 整理现有的依赖</li>
<li>用 <code>go mod graph</code> 查看现有的依赖结构</li>
<li>用 <code>go mod init</code> 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)</li>
</ul>
</li>
<li><p>用 <code>go mod edit</code> 编辑 go.mod 文件</p>
</li>
<li><p>用 <code>go mod vendor</code> 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)</p>
</li>
<li><p>用 <code>go mod verify</code> 校验一个模块是否被篡改过</p>
</li>
</ul>
<p>这里我们注意到有两点比较特别，分别是：</p>
<ul>
<li>第一点：为什么 “拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2” 呢。这是因为虽然我们设置了拉取 @342b2e commit，但是因为 Go modules 会与 tag 进行对比，若发现对应的 commit 与 tag 有关联，则进行转换。</li>
<li>第二点：为什么不建议使用 <code>go mod vendor</code>，因为 Go modules 正在淡化 Vendor 的概念，很有可能 Go2 就去掉了。</li>
</ul>
<h2 id="使用-Go-Modules-时常遇见的坑"><a href="#使用-Go-Modules-时常遇见的坑" class="headerlink" title="使用 Go Modules 时常遇见的坑"></a>使用 Go Modules 时常遇见的坑</h2><h3 id="判断项目是否启用了-Go-Modules"><a href="#判断项目是否启用了-Go-Modules" class="headerlink" title="判断项目是否启用了 Go Modules"></a>判断项目是否启用了 Go Modules</h3><ul>
<li><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76259e244d232"></p>
</li>
</ul>
<h3 id="坑-2-管理-Go-的环境变量"><a href="#坑-2-管理-Go-的环境变量" class="headerlink" title="坑 2: 管理 Go 的环境变量"></a>坑 2: 管理 Go 的环境变量</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76260c9b62f20"></p>
<p>这里主要是提到 Go1.13 新增了 <code>go env -w</code> 用于写入环境变量，而写入的地方是 <code>os.UserConfigDir</code> 所返回的路径，需要注意的是 <code>go env -w</code> 不会覆写。</p>
<h3 id="坑-3-从-dep、glide-等迁移至-Go-Modules"><a href="#坑-3-从-dep、glide-等迁移至-Go-Modules" class="headerlink" title="坑 3: 从 dep、glide 等迁移至 Go Modules"></a>坑 3: 从 dep、glide 等迁移至 Go Modules</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7626035b57218?imageView2"></p>
<p>这里主要是指从旧有的依赖包管理工具（dep/glide 等）进行迁移时，因为 BUG 的原因会导致不经过 GOPROXY 的代理，解决方法有如下两个：</p>
<ul>
<li>手动创建一个 go.mod 文件，再执行 go mod tidy 进行补充。</li>
<li>上代理，相当于不使用 GOPROXY 了。</li>
</ul>
<h3 id="坑-4-拉取私有模块"><a href="#坑-4-拉取私有模块" class="headerlink" title="坑 4:拉取私有模块"></a>坑 4:拉取私有模块</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625ca879e03a"></p>
<p>这里主要想涉及两块知识点，如下：</p>
<ul>
<li>GOPROXY 是无权访问到任何人的私有模块的，所以你放心，安全性没问题。</li>
<li>GOPROXY 除了设置模块代理的地址以外，还需要增加 “direct” 特殊标识才可以成功拉取私有库。</li>
</ul>
<h3 id="坑-5-更新现有的模块"><a href="#坑-5-更新现有的模块" class="headerlink" title="坑 5:更新现有的模块"></a>坑 5:更新现有的模块</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76270adc1426d"></p>
<h3 id="坑-6-主版本号"><a href="#坑-6-主版本号" class="headerlink" title="坑 6:主版本号"></a>坑 6:主版本号</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625ce242f466"></p>
<h2 id="Go-Module-Proxy"><a href="#Go-Module-Proxy" class="headerlink" title="Go Module Proxy"></a>Go Module Proxy</h2><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625db94698c1"></p>
<p>在这里再次强调了 Go Module Proxy 的作用（图左），以及其对应的协议交互流程（图右），有兴趣的小伙伴可以认真看一下。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q：如何解决 Go 1.13 在从 GitLab 拉取模块版本时遇到的，Go 错误地按照非期望值的路径寻找目标模块版本结果致使最终目标模块拉取失败的问题？</strong></p>
<p><strong>A：</strong>GitLab 中配合 goget 而设置的 <code>&lt;meta&gt;</code> 存在些许问题，导致 Go 1.13 错误地识别了模块的具体路径，这是个 Bug，据说在 GitLab 的新版本中已经被修复了，详细内容可以看 <a href="https://github.com/golang/go/issues/34094" target="_blank" rel="external nofollow noopener noreferrer">github.com/golang/go/i…</a> 这个 Issue。然后目前的解决办法的话除了升级 GitLab 的版本外，还可以参考 <a href="https://github.com/developer-learning/night-reading-go/issues/468#issuecomment-535850154" target="_blank" rel="external nofollow noopener noreferrer">github.com/developer-l…</a> 这条回复。</p>
<p><strong>Q：使用 Go modules 时可以同时依赖同一个模块的不同的两个或者多个小版本（修订版本号不同）吗？</strong></p>
<p><strong>A：</strong>不可以的，Go modules 只可以同时依赖一个模块的不同的两个或者多个大版本（主版本号不同）。比如可以同时依赖 <code>example.com/foobar@v1.2.3</code> 和 <code>example.com/foobar/v2@v2.3.4</code>，因为他们的模块路径（module path）不同，Go modules 规定主版本号不是 v0 或者 v1 时，那么主版本号必须显式地出现在模块路径的尾部。但是，同时依赖两个或者多个小版本是不支持的。比如如果模块 A 同时直接依赖了模块 B 和模块 C，且模块 A 直接依赖的是模块 C 的 v1.0.0 版本，然后模块 B 直接依赖的是模块 C 的 v1.0.1 版本，那么最终 Go modules 会为模块 A 选用模块 C 的 v1.0.1 版本而不是模块 A 的 go.mod 文件中指明的 v1.0.0 版本。</p>
<p>这是因为 Go modules 认为只要主版本号不变，那么剩下的都可以直接升级采用最新的。但是如果采用了最新的结果导致项目 Break 掉了，那么 Go modules 就会 Fallback 到上一个老的版本，比如在前面的例子中就会 Fallback 到 v1.0.0 版本。</p>
<p><strong>Q：在 go.sum 文件中的一个模块版本的 Hash 校验数据什么情况下会成对出现，什么情况下只会存在一行？</strong></p>
<p><strong>A：</strong>通常情况下，在 go.sum 文件中的一个模块版本的 Hash 校验数据会有两行，前一行是该模块的 ZIP 文件的 Hash 校验数据，后一行是该模块的 go.mod 文件的 Hash 校验数据。但是也有些情况下只会出现一行该模块的 go.mod 文件的 Hash 校验数据，而不包含该模块的 ZIP 文件本身的 Hash 校验数据，这个情况发生在 Go modules 判定为你当前这个项目完全用不到该模块，根本也不会下载该模块的 ZIP 文件，所以就没必要对其作出 Hash 校验保证，只需要对该模块的 go.mod 文件作出 Hash 校验保证即可，因为 go.mod 文件是用得着的，在深入挖取项目依赖的时候要用。</p>
<p><strong>Q：能不能更详细地讲解一下 go.mod 文件中的 replace 动词的行为以及用法？</strong></p>
<p><strong>A：</strong>这个 replace 动词的作用是把一个“模块版本”替换为另外一个“模块版本”，这是“模块版本”和“模块版本（module path）”之间的替换，“=&gt;”标识符前面的内容是待替换的“模块版本”的“模块路径”，后面的内容是要替换的目标“模块版本”的所在地，即路径，这个路径可以是一个本地磁盘的相对路径，也可以是一个本地磁盘的绝对路径，还可以是一个网络路径，但是这个目标路径并不会在今后你的项目代码中作为你“导入路径（import path）”出现，代码里的“导入路径”还是得以你替换成的这个目标“模块版本”的“模块路径”作为前缀。</p>
<p>另外需要注意，Go modules 是不支持在 “导入路径” 里写相对路径的。举个例子，如果项目 A 依赖了模块 B，比如模块 B 的“模块路径”是 <code>example.com/b</code>，然后它在的磁盘路径是 <code>~/b</code>，在项目 A 里的 go.mod 文件中你有一行 <code>replace example.com/b=&gt;~/b</code>，然后在项目 A 里的代码中的“导入路基”就是 <code>import&quot;example.com/b&quot;</code>，而不是 <code>import&quot;~/b&quot;</code>，剩下的工作是 Go modules 帮你自动完成了的。</p>
<p>然后就是我在分享中也提到了， exclude 和 replace 这两个动词只作用于当前主模块，也就是当前项目，它所依赖的那些其他模块版本中如果出现了你待替换的那个模块版本的话，Go modules 还是会为你依赖的那个模块版本去拉取你的这个待替换的模块版本。</p>
<p>举个例子，比如项目 A 直接依赖了模块 B 和模块 C，然后模块 B 也直接依赖了模块 C，那么你在项目 A 中的 go.mod 文件里的 <code>replace c=&gt;~/some/path/c</code> 是只会影响项目 A 里写的代码中，而模块 B 所用到的还是你 replace 之前的那个 c，并不是你替换成的 <code>~/some/path/c</code> 这个。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.youtube.com/watch?v=F8nrpe0XWRg&amp;list=PLq2Nv-Sh8EbbIjQgDzapOFeVfv5bGOoPE&amp;index=3&amp;t=0s" target="_blank" rel="external nofollow noopener noreferrer">Russ Cox 介绍 go module背后的设计哲学</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" target="_blank" rel="external nofollow noopener noreferrer">Go Module Proposal</a></li>
<li><a href="https://research.swtch.com/vgo" target="_blank" rel="external nofollow noopener noreferrer">vgo博客系列</a> </li>
<li><a href="https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/" target="_blank" rel="external nofollow noopener noreferrer">https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Dependency Management</tag>
        <tag>Package Management</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】Pod</title>
    <url>/posts/b88b921f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Pod</code> 是 Kubernetes 集群中能够被创建、调度和管理的最小部署单元，是一组容器的集合，是 k8s 中最简单的对象，也是 k8s 中最为基础的概念。同一个 Pod 中的容器可以共享同一个网络命名空间，IP地址和端口空间。从生命周期上来讲，Pod是短暂而不是长久的应用。Pod被调度到节点，保持在这个节点直到被摧毁。</p>
<p>本文将分两个部分对 Pod 解读，第一个部分介绍 Pod 的基本概念和常见特性，第二部分会从源码层面介绍 Pod 从创建到删除的整个生命周期的实现。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为 Kubernetes 集群中的基本单元，Pod 就是最小并且最简单的 Kubernetes 对象，这个简单的对象其实就能够独立启动一个后端进程并在集群的内部为调用方提供服务。在上一篇文章 <a href="https://draveness.me/kubernetes-object-intro" target="_blank" rel="external nofollow noopener noreferrer">从 Kubernetes 中的对象谈起</a> 中，我们曾经介绍过简单的 Kubernetes Pod 是如何使用 YAML 进行描述的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3600"</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure>
<p>这个 YAML 文件描述了一个 Pod 启动时运行的容器和命令以及它的重启策略，在当前 Pod 出现错误或者执行结束后是否应该被 Kubernetes 的控制器拉起来，除了这些比较显眼的配置之外，元数据 <code>metadata</code> 的配置也非常重要，<code>name</code> 是当前对象在 Kubernetes 集群中的唯一标识符，而标签 <code>labels</code> 可以帮助我们快速选择对象。</p>
<p>在同一个 Pod 中，有几个概念特别值得关注，首先就是容器，在 Pod 中其实可以同时运行一个或者多个容器，这些容器能够共享网络、存储以及 CPU、内存等资源。在这一小节中我们将关注 Pod 中的容器、卷和网络三大概念。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>每一个 Kubernetes 的 Pod 其实都具有两种不同的容器，两种不同容器的职责其实十分清晰，一种是 <code>InitContainer</code>，这种容器会在 Pod 启动时运行，主要用于初始化一些配置，另一种是 Pod 在 Running 状态时内部存活的 <code>Container</code>，它们的主要作用是对外提供服务或者作为工作节点处理异步任务等等。</p>
<p><img alt="kubernetes-pod-init-and-regular-containers" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-init-and-regular-containers.png"></p>
<p>通过对不同容器类型的命名我们也可以看出，<code>InitContainer</code> 会比 <code>Container</code> 优先启动，在 <code>kubeGenericRuntimeManager.SyncPod</code> 方法中会先后启动两种容器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">	<span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line">	<span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line">	<span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: start the init container.</span></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">		container := &amp;pod.Spec.Containers[idx]</span><br><span class="line">		</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过分析私有方法 <code>startContainer</code> 的实现我们得出：容器的类型最终只会影响在 Debug 时创建的标签，所以对于 Kubernetes 来说两种容器的启动和执行也就只有顺序先后的不同。</p>
<h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>每一个 Pod 中的容器是可以通过 <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="external nofollow noopener noreferrer">卷（Volume）</a> 的方式共享文件目录的，这些 Volume 能够存储持久化的数据；在当前 Pod 出现故障或者滚动更新时，对应 Volume 中的数据并不会被清除，而是会在 Pod 重启后重新挂载到期望的文件目录中：</p>
<p><img alt="kubernetes-containers-share-volumes" data-src="https://img.draveness.me/2018-12-25-kubernetes-containers-share-volumes.png"></p>
<p>kubelet.go 文件中的私有方法 <code>syncPod</code> 会调用 <code>WaitForAttachAndMount</code> 方法为等待当前 Pod 启动需要的挂载文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *volumeManager)</span> <span class="title">WaitForAttachAndMount</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	expectedVolumes := getExpectedVolumes(pod)</span><br><span class="line">	uniquePodName := util.GetUniquePodName(pod)</span><br><span class="line"></span><br><span class="line">	vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)</span><br><span class="line"></span><br><span class="line">	wait.PollImmediate(</span><br><span class="line">		podAttachAndMountRetryInterval,</span><br><span class="line">		podAttachAndMountTimeout,</span><br><span class="line">		vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会在 <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="external nofollow noopener noreferrer">后面的章节</a> 详细地介绍 Kubernetes 中卷的创建、挂载是如何进行的，在这里我们需要知道的是卷的挂载是 Pod 启动之前必须要完成的工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncPod</span><span class="params">(o syncPodOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !kl.podIsTerminated(pod) &#123;</span><br><span class="line">		kl.volumeManager.WaitForAttachAndMount(pod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line">	result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">	kl.reasonCache.Update(pod.UID, result)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前 Pod 的卷创建完成之后，就会调用上一节中提到的 <code>SyncPod</code> 公有方法继续进行同步 Pod 信息和创建、启动容器的工作。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>同一个 Pod 中的多个容器会被共同分配到同一个 Host 上并且共享网络栈，也就是说这些 Pod 能够通过 localhost 互相访问到彼此的端口和服务，如果使用了相同的端口也会发生冲突，同一个 Pod 上的所有容器会连接到同一个网络设备上，这个网络设备就是由 Pod Sandbox 中的沙箱容器在 <code>RunPodSandbox</code> 方法中启动时创建的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span> <span class="title">RunPodSandbox</span><span class="params">(ctx context.Context, r *runtimeapi.RunPodSandboxRequest)</span> <span class="params">(*runtimeapi.RunPodSandboxResponse, error)</span></span> &#123;</span><br><span class="line">	config := r.GetConfig()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Pull the image for the sandbox.</span></span><br><span class="line">	image := defaultSandboxImage</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Create the sandbox container.</span></span><br><span class="line">	createConfig, _ := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">	createResp, _ := ds.client.CreateContainer(*createConfig)</span><br><span class="line"></span><br><span class="line">	resp := &amp;runtimeapi.RunPodSandboxResponse&#123;PodSandboxId: createResp.ID&#125;</span><br><span class="line"></span><br><span class="line">	ds.setNetworkReady(createResp.ID, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Create Sandbox Checkpoint.</span></span><br><span class="line">	ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">	ds.client.StartContainer(createResp.ID)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: Setup networking for the sandbox.</span></span><br><span class="line">	cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)</span><br><span class="line">	networkOptions := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>沙箱容器其实就是 <code>pause</code> 容器，上述方法引用的 <code>defaultSandboxImage</code> 其实就是官方提供的 <code>k8s.gcr.io/pause:3.1</code> 镜像，这里会创建沙箱镜像和检查点并启动容器。</p>
<p><img alt="kubernetes-pod-network" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-network.png"></p>
<p>每一个节点上都会由 Kubernetes 的网络插件 Kubenet 创建一个基本的 <code>cbr0</code> 网桥并为每一个 Pod 创建 <code>veth</code> 虚拟网络设备，同一个 Pod 中的所有容器就会通过这个网络设备共享网络，也就是能够通过 localhost 互相访问彼此暴露的端口和服务。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Kubernetes 中的每一个 Pod 都包含多个容器，这些容器在通过 Kubernetes 创建之后就能共享网络和存储，这其实是 Pod 非常重要的特性，我们能通过这个特性构建比较复杂的服务拓扑和依赖关系。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>想要深入理解 Pod 的实现原理，最好最快的办法就是从 Pod 的生命周期入手，通过理解 Pod 创建、重启和删除的原理我们最终就能够系统地掌握 Pod 的生命周期与核心原理。</p>
<p><img alt="kubernetes-pod-lifecycle" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-lifecycle.png"></p>
<p>当 Pod 被创建之后，就会进入健康检查状态，当 Kubernetes 确定当前 Pod 已经能够接受外部的请求时，才会将流量打到新的 Pod 上并继续对外提供服务，在这期间如果发生了错误就可能会触发重启机制，在 Pod 被删除之前都会触发一个 <code>PreStop</code> 的钩子，其中的方法完成之后 Pod 才会被删除，接下来我们就会按照这里的顺序依次介绍 Pod 『从生到死』的过程。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Pod 的创建都是通过 <code>SyncPod</code> 来实现的，创建的过程大体上可以分为六个步骤：</p>
<ol>
<li>计算 Pod 中沙盒和容器的变更；</li>
<li>强制停止 Pod 对应的沙盒；</li>
<li>强制停止所有不应该运行的容器；</li>
<li>为 Pod 创建新的沙盒；</li>
<li>创建 Pod 规格中指定的初始化容器；</li>
<li>依次创建 Pod 规格中指定的常规容器；</li>
</ol>
<p>我们可以看到 Pod 的创建过程其实是比较简单的，首先计算 Pod 规格和沙箱的变更，然后停止可能影响这一次创建或者更新的容器，最后依次创建沙盒、初始化容器和常规容器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">	podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		ref, _ := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			m.purgeInitContainers(pod, podStatus)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>)			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		podSandboxID, _, _ = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">	&#125;</span><br><span class="line">	podSandboxConfig, _ := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">		container := &amp;pod.Spec.Containers[idx]</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化后的 <code>SyncPod</code> 方法的脉络非常清晰，可以很好地理解整个创建 Pod 的工作流程；而初始化容器和常规容器被调用 <code>startContainer</code> 来启动：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">startContainer</span><span class="params">(podSandboxID <span class="keyword">string</span>, podSandboxConfig *runtimeapi.PodSandboxConfig, container *v1.Container, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, podIP <span class="keyword">string</span>, containerType kubecontainer.ContainerType)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	imageRef, _, _ := m.imagePuller.EnsureImageExists(pod, container, pullSecrets)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	containerID, _ := m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)</span><br><span class="line"></span><br><span class="line">	m.internalLifecycle.PreStartContainer(pod, container, containerID)</span><br><span class="line"></span><br><span class="line">	m.runtimeService.StartContainer(containerID)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> container.Lifecycle != <span class="literal">nil</span> &amp;&amp; container.Lifecycle.PostStart != <span class="literal">nil</span> &#123;</span><br><span class="line">		kubeContainerID := kubecontainer.ContainerID&#123;</span><br><span class="line">			Type: m.runtimeName,</span><br><span class="line">			ID:   containerID,</span><br><span class="line">		&#125;</span><br><span class="line">		msg, _ := m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动每一个容器的过程中也都按照相同的步骤进行操作：</p>
<ol>
<li>通过镜像拉取器获得当前容器中使用镜像的引用；</li>
<li>调用远程的 <code>runtimeService</code> 创建容器；</li>
<li>调用内部的生命周期方法 <code>PreStartContainer</code> 为当前的容器设置分配的 CPU 等资源；</li>
<li>调用远程的 <code>runtimeService</code> 开始运行镜像；</li>
<li>如果当前的容器包含 <code>PostStart</code> 钩子就会执行该回调；</li>
</ol>
<p>每次 <code>SyncPod</code> 被调用时不一定是创建新的 Pod 对象，它还会承担更新、删除和同步 Pod 规格的职能，根据输入的新规格执行相应的操作。</p>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>如果我们遵循 Pod 的最佳实践，其实应该尽可能地为每一个 Pod 添加 <code>livenessProbe</code> 和 <code>readinessProbe</code> 的健康检查，这两者能够为 Kubernetes 提供额外的存活信息，如果我们配置了合适的健康检查方法和规则，那么就不会出现服务未启动就被打入流量或者长时间未响应依然没有重启等问题。</p>
<p>在 Pod 被创建或者被移除时，会被加入到当前节点上的 <code>ProbeManager</code> 中，<code>ProbeManager</code> 会负责这些 Pod 的健康检查：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	start := kl.clock.Now()</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		kl.podManager.AddPod(pod)</span><br><span class="line">		kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">		kl.probeManager.AddPod(pod)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodRemoves</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	start := kl.clock.Now()</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		kl.podManager.DeletePod(pod)</span><br><span class="line">		kl.deletePod(pod)</span><br><span class="line">		kl.probeManager.RemovePod(pod)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化后的 <code>HandlePodAdditions</code> 和 <code>HandlePodRemoves</code> 方法非常直白，我们可以直接来看 <code>ProbeManager</code> 如何处理不同节点的健康检查。</p>
<p><img alt="kubernetes-probe-manager" data-src="https://img.draveness.me/2018-12-25-kubernetes-probe-manager.png"></p>
<p>每一个新的 Pod 都会被调用 <code>ProbeManager</code> 的<code>AddPod</code> 函数，这个方法会初始化一个新的 Goroutine 并在其中运行对当前 Pod 进行健康检查：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">		key.containerName = c.Name</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> c.ReadinessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">			key.probeType = readiness</span><br><span class="line">			w := newWorker(m, readiness, pod, c)</span><br><span class="line">			m.workers[key] = w</span><br><span class="line">			<span class="keyword">go</span> w.run()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> c.LivenessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">			key.probeType = liveness</span><br><span class="line">			w := newWorker(m, liveness, pod, c)</span><br><span class="line">			m.workers[key] = w</span><br><span class="line">			<span class="keyword">go</span> w.run()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行健康检查的过程中，Worker 只是负责根据当前 Pod 的状态定期触发一次 <code>Probe</code>，它会根据 Pod 的配置分别选择调用 <code>Exec</code>、<code>HTTPGet</code> 或 <code>TCPSocket</code> 三种不同的 <code>Probe</code> 方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbe</span><span class="params">(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	timeout := time.Duration(p.TimeoutSeconds) * time.Second</span><br><span class="line">	<span class="keyword">if</span> p.Exec != <span class="literal">nil</span> &#123;</span><br><span class="line">		command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)</span><br><span class="line">		<span class="keyword">return</span> pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.HTTPGet != <span class="literal">nil</span> &#123;</span><br><span class="line">		scheme := strings.ToLower(<span class="keyword">string</span>(p.HTTPGet.Scheme))</span><br><span class="line">		host := p.HTTPGet.Host</span><br><span class="line">		port, _ := extractPort(p.HTTPGet.Port, container)</span><br><span class="line">		path := p.HTTPGet.Path</span><br><span class="line">		url := formatURL(scheme, host, port, path)</span><br><span class="line">		headers := buildHeader(p.HTTPGet.HTTPHeaders)</span><br><span class="line">		<span class="keyword">if</span> probeType == liveness &#123;</span><br><span class="line">			<span class="keyword">return</span> pb.livenessHttp.Probe(url, headers, timeout)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// readiness</span></span><br><span class="line">			<span class="keyword">return</span> pb.readinessHttp.Probe(url, headers, timeout)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.TCPSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		port, _ := extractPort(p.TCPSocket.Port, container)</span><br><span class="line">		host := p.TCPSocket.Host</span><br><span class="line">		<span class="keyword">return</span> pb.tcp.Probe(host, port, timeout)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, fmt.Errorf(<span class="string">"Missing probe handler for %s:%s"</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kubernetes 在 Pod 启动后的 <code>InitialDelaySeconds</code> 时间内会等待 Pod 的启动和初始化，在这之后会开始健康检查，默认的健康检查重试次数是三次，如果健康检查正常运行返回了一个确定的结果，那么 Worker 就是记录这次的结果，在连续失败 <code>FailureThreshold</code> 次或者成功 <code>SuccessThreshold</code> 次，那么就会改变当前 Pod 的状态，这也是为了避免由于服务不稳定带来的抖动。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当 Kubelet 在 <code>HandlePodRemoves</code> 方法中接收到来自客户端的删除请求时，就会通过一个名为 <code>deletePod</code> 的私有方法中的 Channel 将这一事件传递给 PodKiller 进行处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">deletePod</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	kl.podWorkers.ForgetWorker(pod.UID)</span><br><span class="line"></span><br><span class="line">	runningPods, _ := kl.runtimeCache.GetPods()</span><br><span class="line">	runningPod := kubecontainer.Pods(runningPods).FindPod(<span class="string">""</span>, pod.UID)</span><br><span class="line">	podPair := kubecontainer.PodPair&#123;APIPod: pod, RunningPod: &amp;runningPod&#125;</span><br><span class="line"></span><br><span class="line">	kl.podKillingCh &lt;- &amp;podPair</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kubelet 除了将事件通知给 PodKiller 之外，还需要将当前 Pod 对应的 Worker 从持有的 <code>podWorkers</code> 中删除；PodKiller 其实就是 Kubelet 持有的一个 Goroutine，它会在后台持续运行并监听来自 <code>podKillingCh</code> 的事件：</p>
<p><img alt="kubernetes-pod-killer" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-killer.png"></p>
<p>经过一系列的方法调用之后，最终调用容器运行时的 <code>killContainersWithSyncResult</code> 方法，这个方法会同步地杀掉当前 Pod 中全部的容器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainersWithSyncResult</span><span class="params">(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="params">(syncResults []*kubecontainer.SyncResult)</span></span> &#123;</span><br><span class="line">	containerResults := <span class="built_in">make</span>(<span class="keyword">chan</span> *kubecontainer.SyncResult, <span class="built_in">len</span>(runningPod.Containers))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, container := <span class="keyword">range</span> runningPod.Containers &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(container *kubecontainer.Container)</span></span> &#123;</span><br><span class="line">			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, container.Name)</span><br><span class="line">			m.killContainer(pod, container.ID, container.Name, <span class="string">"Need to kill Pod"</span>, gracePeriodOverride)</span><br><span class="line">			containerResults &lt;- killContainerResult</span><br><span class="line">		&#125;(container)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(containerResults)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> containerResult := <span class="keyword">range</span> containerResults &#123;</span><br><span class="line">		syncResults = <span class="built_in">append</span>(syncResults, containerResult)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一个容器来说，它们在被停止之前都会先调用 <code>PreStop</code> 的钩子方法，让容器中的应用程序能够有时间完成一些未处理的操作，随后调用远程的服务停止运行的容器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainer</span><span class="params">(pod *v1.Pod, containerID kubecontainer.ContainerID, containerName <span class="keyword">string</span>, reason <span class="keyword">string</span>, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	containerSpec := kubecontainer.GetContainerSpec(pod, containerName);</span><br><span class="line"></span><br><span class="line">	gracePeriod := <span class="keyword">int64</span>(minimumGracePeriodInSeconds)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> pod.DeletionGracePeriodSeconds != <span class="literal">nil</span>:</span><br><span class="line">		gracePeriod = *pod.DeletionGracePeriodSeconds</span><br><span class="line">	<span class="keyword">case</span> pod.Spec.TerminationGracePeriodSeconds != <span class="literal">nil</span>:</span><br><span class="line">		gracePeriod = *pod.Spec.TerminationGracePeriodSeconds</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	m.executePreStopHook(pod, containerID, containerSpec, gracePeriod)</span><br><span class="line">	m.internalLifecycle.PreStopContainer(containerID.ID)</span><br><span class="line">	m.runtimeService.StopContainer(containerID.ID, gracePeriod)</span><br><span class="line">	m.containerRefManager.ClearRef(containerID)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个简化版本的 <code>killContainer</code> 方法中，我们可以大致看出停止运行容器的大致逻辑，先从 Pod 的规格中计算出当前停止所需要的时间，然后运行钩子方法和内部的生命周期方法，最后将容器停止并清除引用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们已经介绍了 Pod 中的几个重要概念 — 容器、卷和网络以及从创建到删除整个过程是如何实现的。</p>
<p>Kubernetes 中 Pod 的运行和管理总是与 kubelet 以及它的组件密不可分，后面的文章中也会介绍 kubelet 究竟是什么，它在整个 Kubernetes 中扮演什么样的角色。</p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>源码阅读</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】Controller Manager</title>
    <url>/posts/76a404e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Controller Manager</code>作为集群的管理控制中心，维护集群中的所有控制器，对维持集群的稳定和自我修复，实现高可用，副本控制等起关键作用。</p>
<a id="more"></a>
<h2 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h2><p><img alt="12039474-1e134c69dc68c410.png" data-src="https://www.pianshen.com/images/715/6480752a76065ff8de202236459f36bb.png"></p>
<h2 id="关键性调用链"><a href="#关键性调用链" class="headerlink" title="关键性调用链"></a>关键性调用链</h2><p><img alt="12039474-6d0b6a2aabc46a28.png" data-src="https://www.pianshen.com/images/592/394742076228162f618ca01a59ee1170.png"></p>
<h2 id="源码分析过程"><a href="#源码分析过程" class="headerlink" title="源码分析过程"></a>源码分析过程</h2><h3 id="组件启动的入口"><a href="#组件启动的入口" class="headerlink" title="组件启动的入口"></a>组件启动的入口</h3><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/controller-manager.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	command := app.NewControllerManagerCommand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取配置文件，进行配置读取和初始化默认配置"><a href="#读取配置文件，进行配置读取和初始化默认配置" class="headerlink" title="读取配置文件，进行配置读取和初始化默认配置"></a>读取配置文件，进行配置读取和初始化默认配置</h3><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go -&gt;NewControllerManagerCommand</p>
<ul>
<li>初始化Controller-manager的配置选项结构:<strong>NewKubeControllerManagerOptions()</strong></li>
<li>创建执行命令结构包括Use,Long,和Run:<strong>cmd := &amp;cobra.Command{</strong></li>
<li>解析配置文件: <strong>s.AddFlags</strong><br>1.KnownControllers()获取所有controller<br>2.将配置文件中的配置选项注入到配置对象中<br>3.同时将controller需要的参数写入.</li>
</ul>
<figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/app/controllermanager.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewControllerManagerCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerManagerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	s, err := options.NewKubeControllerManagerOptions()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"unable to initialize command options: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use: <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">		Long: <span class="string">`The Kubernetes controller manager is a daemon that embeds</span></span><br><span class="line"><span class="string">the core control loops shipped with Kubernetes. In applications of robotics and</span></span><br><span class="line"><span class="string">automation, a control loop is a non-terminating loop that regulates the state of</span></span><br><span class="line"><span class="string">the system. In Kubernetes, a controller is a control loop that watches the shared</span></span><br><span class="line"><span class="string">state of the cluster through the apiserver and makes changes attempting to move the</span></span><br><span class="line"><span class="string">current state towards the desired state. Examples of controllers that ship with</span></span><br><span class="line"><span class="string">Kubernetes today are the replication controller, endpoints controller, namespace</span></span><br><span class="line"><span class="string">controller, and serviceaccounts controller.`</span>,</span><br><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			verflag.PrintAndExitIfRequested()</span><br><span class="line">			utilflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">			c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fs := cmd.Flags()</span><br><span class="line">	namedFlagSets := s.Flags(KnownControllers(), ControllersDisabledByDefault.List())</span><br><span class="line">	verflag.AddFlags(namedFlagSets.FlagSet(<span class="string">"global"</span>))</span><br><span class="line">	globalflag.AddGlobalFlags(namedFlagSets.FlagSet(<span class="string">"global"</span>), cmd.Name())</span><br><span class="line">	registerLegacyGlobalFlags(namedFlagSets)</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> namedFlagSets.FlagSets &#123;</span><br><span class="line">		fs.AddFlagSet(f)</span><br><span class="line">	&#125;</span><br><span class="line">	usageFmt := <span class="string">"Usage:\n  %s\n"</span></span><br><span class="line">	cols, _, _ := term.TerminalSize(cmd.OutOrStdout())</span><br><span class="line">	cmd.SetUsageFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(cmd.OutOrStderr(), usageFmt, cmd.UseLine())</span><br><span class="line">		cliflag.PrintSections(cmd.OutOrStderr(), namedFlagSets, cols)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	cmd.SetHelpFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(cmd.OutOrStdout(), <span class="string">"%s\n\n"</span>+usageFmt, cmd.Long, cmd.UseLine())</span><br><span class="line">		cliflag.PrintSections(cmd.OutOrStdout(), namedFlagSets, cols)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件启动执行"><a href="#组件启动执行" class="headerlink" title="组件启动执行"></a>组件启动执行</h3><p>从main中的command.Execute()到4.2中构造的Run<br><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>//加载所有控制器，并将对应参数注入到控制器中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())</span><br></pre></td></tr></table></figure>
<p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>KnownControllers()中的NewControllerInitializers初始化所有的控制器</p>
<figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/app/controllermanager.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">	controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">	controllers[<span class="string">"endpoint"</span>] = startEndpointController</span><br><span class="line">	controllers[<span class="string">"endpointslice"</span>] = startEndpointSliceController</span><br><span class="line">	controllers[<span class="string">"replicationcontroller"</span>] = startReplicationController</span><br><span class="line">	controllers[<span class="string">"podgc"</span>] = startPodGCController</span><br><span class="line">	controllers[<span class="string">"resourcequota"</span>] = startResourceQuotaController</span><br><span class="line">	controllers[<span class="string">"namespace"</span>] = startNamespaceController</span><br><span class="line">	controllers[<span class="string">"serviceaccount"</span>] = startServiceAccountController</span><br><span class="line">	controllers[<span class="string">"garbagecollector"</span>] = startGarbageCollectorController</span><br><span class="line">	controllers[<span class="string">"daemonset"</span>] = startDaemonSetController</span><br><span class="line">	controllers[<span class="string">"job"</span>] = startJobController</span><br><span class="line">	controllers[<span class="string">"deployment"</span>] = startDeploymentController</span><br><span class="line">	controllers[<span class="string">"replicaset"</span>] = startReplicaSetController</span><br><span class="line">	controllers[<span class="string">"horizontalpodautoscaling"</span>] = startHPAController</span><br><span class="line">	controllers[<span class="string">"disruption"</span>] = startDisruptionController</span><br><span class="line">	controllers[<span class="string">"statefulset"</span>] = startStatefulSetController</span><br><span class="line">	controllers[<span class="string">"cronjob"</span>] = startCronJobController</span><br><span class="line">	controllers[<span class="string">"csrsigning"</span>] = startCSRSigningController</span><br><span class="line">	controllers[<span class="string">"csrapproving"</span>] = startCSRApprovingController</span><br><span class="line">	controllers[<span class="string">"csrcleaner"</span>] = startCSRCleanerController</span><br><span class="line">	controllers[<span class="string">"ttl"</span>] = startTTLController</span><br><span class="line">	controllers[<span class="string">"bootstrapsigner"</span>] = startBootstrapSignerController</span><br><span class="line">	controllers[<span class="string">"tokencleaner"</span>] = startTokenCleanerController</span><br><span class="line">	controllers[<span class="string">"nodeipam"</span>] = startNodeIpamController</span><br><span class="line">	controllers[<span class="string">"nodelifecycle"</span>] = startNodeLifecycleController</span><br><span class="line">	<span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">		controllers[<span class="string">"service"</span>] = startServiceController</span><br><span class="line">		controllers[<span class="string">"route"</span>] = startRouteController</span><br><span class="line">		controllers[<span class="string">"cloud-node-lifecycle"</span>] = startCloudNodeLifecycleController</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">	&#125;</span><br><span class="line">	controllers[<span class="string">"persistentvolume-binder"</span>] = startPersistentVolumeBinderController</span><br><span class="line">	controllers[<span class="string">"attachdetach"</span>] = startAttachDetachController</span><br><span class="line">	controllers[<span class="string">"persistentvolume-expander"</span>] = startVolumeExpandController</span><br><span class="line">	controllers[<span class="string">"clusterrole-aggregation"</span>] = startClusterRoleAggregrationController</span><br><span class="line">	controllers[<span class="string">"pvc-protection"</span>] = startPVCProtectionController</span><br><span class="line">	controllers[<span class="string">"pv-protection"</span>] = startPVProtectionController</span><br><span class="line">	controllers[<span class="string">"ttl-after-finished"</span>] = startTTLAfterFinishedController</span><br><span class="line">	controllers[<span class="string">"root-ca-cert-publisher"</span>] = startRootCACertPublisher</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>真正进入执行</p>
<ul>
<li>启动controller-manager的http服务和对应处理器，包括安全和非安全：<strong>BuildHandlerChain</strong></li>
<li>构造run的执行体</li>
<li>需要选主的情况，选主完执行run;不需要选主的直接执行run，然后panic</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(<span class="built_in">c</span> *config.CompletedConfig)</span></span> error &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// To help debugging, immediately log version</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glog.<span class="type">Infof</span>(<span class="string">"Version: %+v"</span>, version.<span class="type">Get</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cfgz, err := configz.<span class="type">New</span>(<span class="string">"componentconfig"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cfgz.<span class="type">Set</span>(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        glog.<span class="type">Errorf</span>(<span class="string">"unable to register configz: %c"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the controller manager HTTP server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stopCh := make(chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">SecureServing</span> != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler := genericcontrollermanager.<span class="type">NewBaseHandler</span>(&amp;<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">Debugging</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler = genericcontrollermanager.<span class="type">BuildHandlerChain</span>(handler, &amp;<span class="built_in">c</span>.<span class="type">Authorization</span>, &amp;<span class="built_in">c</span>.<span class="type">Authentication</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">c</span>.<span class="type">SecureServing</span>.<span class="type">Serve</span>(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">InsecureServing</span> != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler := genericcontrollermanager.<span class="type">NewBaseHandler</span>(&amp;<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">Debugging</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler = genericcontrollermanager.<span class="type">BuildHandlerChain</span>(handler, &amp;<span class="built_in">c</span>.<span class="type">Authorization</span>, &amp;<span class="built_in">c</span>.<span class="type">Authentication</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">c</span>.<span class="type">InsecureServing</span>.<span class="type">Serve</span>(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-chan <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rootClientBuilder := controller.<span class="type">SimpleControllerClientBuilder</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">ClientConfig</span>: <span class="built_in">c</span>.<span class="type">Kubeconfig</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> clientBuilder controller.<span class="type">ControllerClientBuilder</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">KubeCloudShared</span>.<span class="type">UseServiceAccountCredentials</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">SAController</span>.<span class="type">ServiceAccountKeyFile</span>) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// It'c possible another controller process is creating the tokens for us.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If one isn't, we'll timeout and exit when our client builder is unable to create the tokens.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                glog.<span class="type">Warningf</span>(<span class="string">"--use-service-account-credentials was specified without providing a --service-account-private-key-file"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            clientBuilder = controller.<span class="type">SAControllerClientBuilder</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">ClientConfig</span>:         restclient.<span class="type">AnonymousClientConfig</span>(<span class="built_in">c</span>.<span class="type">Kubeconfig</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">CoreClient</span>:           <span class="built_in">c</span>.<span class="type">Client</span>.<span class="type">CoreV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">AuthenticationClient</span>: <span class="built_in">c</span>.<span class="type">Client</span>.<span class="type">AuthenticationV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">Namespace</span>:            <span class="string">"kube-system"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            clientBuilder = rootClientBuilder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx, err := <span class="type">CreateControllerContext</span>(<span class="built_in">c</span>, rootClientBuilder, clientBuilder, stop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            glog.<span class="type">Fatalf</span>(<span class="string">"error building controller context: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动控制器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="type">StartControllers</span>(ctx, saTokenControllerInitFunc, <span class="type">NewControllerInitializers</span>(ctx.<span class="type">LoopMode</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            glog.<span class="type">Fatalf</span>(<span class="string">"error starting controllers: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx.<span class="type">InformerFactory</span>.<span class="type">Start</span>(ctx.<span class="type">Stop</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        close(ctx.<span class="type">InformersStarted</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        select &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//note 如果未启用选主（只是单节点），直接启动，并且panic，不在往下走，因为run内部有select挂起</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">LeaderElect</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        run(wait.<span class="type">NeverStop</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panic(<span class="string">"unreachable"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id, err := os.<span class="type">Hostname</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a uniquifier so that two processes on the same host don't accidentally both become active</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成唯一ID,相当于进程锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id = id + <span class="string">"_"</span> + string(uuid.<span class="type">NewUUID</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rl, err := resourcelock.<span class="type">New</span>(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">ResourceLock</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">"kube-system"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">"kube-controller-manager"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">c</span>.<span class="type">LeaderElectionClient</span>.<span class="type">CoreV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        resourcelock.<span class="type">ResourceLockConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Identity</span>:      id,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">EventRecorder</span>: <span class="built_in">c</span>.<span class="type">EventRecorder</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        glog.<span class="type">Fatalf</span>(<span class="string">"error creating lock: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行选主，并在选为主节点后执行run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    leaderelection.<span class="type">RunOrDie</span>(leaderelection.<span class="type">LeaderElectionConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Lock</span>:          rl,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">LeaseDuration</span>: <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">LeaseDuration</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">RenewDeadline</span>: <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">RenewDeadline</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">RetryPeriod</span>:   <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">RetryPeriod</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Callbacks</span>: leaderelection.<span class="type">LeaderCallbacks</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选主完成后执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">OnStartedLeading</span>: run,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">OnStoppedLeading</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                glog.<span class="type">Fatalf</span>(<span class="string">"leaderelection lost"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    panic(<span class="string">"unreachable"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>转到run内部核心的三个动作</strong> ：CreateControllerContext 、 StartControllers和ctx.InformerFactory.Start</p>
<h4 id="CreateControllerContext"><a href="#CreateControllerContext" class="headerlink" title="CreateControllerContext"></a>CreateControllerContext</h4><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go</p>
<ul>
<li>拿到对kube-APIserver中资源的操作句柄</li>
<li>确认Kube-APIServer的健康（最多等待10s），然后拿获取连接</li>
<li>创建控制器上下文</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateControllerContext creates a context struct containing references to resources needed by the</span></span><br><span class="line"><span class="comment">// controllers such as the cloud provider and clientBuilder. rootClientBuilder is only used for</span></span><br><span class="line"><span class="comment">// the shared-informers client and token controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateControllerContext</span><span class="params">(s *config.CompletedConfig, rootClientBuilder, clientBuilder controller.ControllerClientBuilder, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(ControllerContext, error)</span></span> &#123;</span><br><span class="line">	versionedClient := rootClientBuilder.ClientOrDie(<span class="string">"shared-informers"</span>)</span><br><span class="line">	sharedInformers := informers.NewSharedInformerFactory(versionedClient, ResyncPeriod(s)())</span><br><span class="line"></span><br><span class="line">	metadataClient := metadata.NewForConfigOrDie(rootClientBuilder.ConfigOrDie(<span class="string">"metadata-informers"</span>))</span><br><span class="line">	metadataInformers := metadatainformer.NewSharedInformerFactory(metadataClient, ResyncPeriod(s)())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If apiserver is not running we should wait for some time and fail only then. This is particularly</span></span><br><span class="line">	<span class="comment">// important when we start apiserver and controller manager at the same time.</span></span><br><span class="line">	<span class="keyword">if</span> err := genericcontrollermanager.WaitForAPIServer(versionedClient, <span class="number">10</span>*time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ControllerContext&#123;&#125;, fmt.Errorf(<span class="string">"failed to wait for apiserver being healthy: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use a discovery client capable of being refreshed.</span></span><br><span class="line">	discoveryClient := rootClientBuilder.ClientOrDie(<span class="string">"controller-discovery"</span>)</span><br><span class="line">	cachedClient := cacheddiscovery.NewMemCacheClient(discoveryClient.Discovery())</span><br><span class="line">	restMapper := restmapper.NewDeferredDiscoveryRESTMapper(cachedClient)</span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		restMapper.Reset()</span><br><span class="line">	&#125;, <span class="number">30</span>*time.Second, stop)</span><br><span class="line"></span><br><span class="line">	availableResources, err := GetAvailableResources(rootClientBuilder)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ControllerContext&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cloud, loopMode, err := createCloudProvider(s.ComponentConfig.KubeCloudShared.CloudProvider.Name, s.ComponentConfig.KubeCloudShared.ExternalCloudVolumePlugin,</span><br><span class="line">		s.ComponentConfig.KubeCloudShared.CloudProvider.CloudConfigFile, s.ComponentConfig.KubeCloudShared.AllowUntaggedCloud, sharedInformers)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ControllerContext&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := ControllerContext&#123;</span><br><span class="line">		ClientBuilder:                   clientBuilder,</span><br><span class="line">		InformerFactory:                 sharedInformers,</span><br><span class="line">		ObjectOrMetadataInformerFactory: controller.NewInformerFactory(sharedInformers, metadataInformers),</span><br><span class="line">		ComponentConfig:                 s.ComponentConfig,</span><br><span class="line">		RESTMapper:                      restMapper,</span><br><span class="line">		AvailableResources:              availableResources,</span><br><span class="line">		Cloud:                           cloud,</span><br><span class="line">		LoopMode:                        loopMode,</span><br><span class="line">		Stop:                            stop,</span><br><span class="line">		InformersStarted:                <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		ResyncPeriod:                    ResyncPeriod(s),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StartControllers"><a href="#StartControllers" class="headerlink" title="StartControllers"></a>StartControllers</h4><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>启动初始化的所有控制器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Always start the SA token controller first using a full-power client, since it needs to mint tokens for the rest</span></span><br><span class="line">	<span class="comment">// If this fails, just return here and fail since other controllers won't be able to get credentials.</span></span><br><span class="line">	<span class="keyword">if</span> _, _, err := startSATokenController(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the cloud provider with a reference to the clientBuilder only after token controller</span></span><br><span class="line">	<span class="comment">// has started in case the cloud provider uses the client builder.</span></span><br><span class="line">	<span class="keyword">if</span> ctx.Cloud != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.Cloud.Initialize(ctx.ClientBuilder, ctx.Stop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line">		<span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"%q is disabled"</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">1</span>).Infof(<span class="string">"Starting %q"</span>, controllerName)</span><br><span class="line">		debugHandler, started, err := initFn(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"Error starting %q"</span>, controllerName)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !started &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"Skipping %q"</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">			basePath := <span class="string">"/debug/controllers/"</span> + controllerName</span><br><span class="line">			unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">			unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">"/"</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Infof(<span class="string">"Started %q"</span>, controllerName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ctx-InformerFactory-Start"><a href="#ctx-InformerFactory-Start" class="headerlink" title="ctx.InformerFactory.Start"></a>ctx.InformerFactory.Start</h4><p>controller-manager中的informer开始启动监听资源的事件，将事件放到自己的队列中（具有限流特性）。处理进程从队列总获取事件开始进行任务处理。</p>
<blockquote>
<p>将新建的ReplicaSet，放入队列</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj could be an *apps.ReplicaSet, or a DeletionFinalStateUnknown marker item.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">enqueueReplicaSet</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    key, err := controller.KeyFunc(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't get key for object %+v: %v"</span>, obj, err))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rsc.queue.Add(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从队列中获取对象进行处理（具体过程见下方）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    key, quit := rsc.queue.Get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err := rsc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rsc.queue.Forget(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"Sync %q failed with %v"</span>, key, err))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rsc.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="以startReplicaSetController为例"><a href="#以startReplicaSetController为例" class="headerlink" title="以startReplicaSetController为例"></a>以startReplicaSetController为例</h2><p>在StartControllers中initFn方法是NewControllerInitializers中初始化Controller是定义，以下主要看下startReplicaSetController。<br><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/apps.go<br>其中NewReplicaSetController主要是初始化ReplicaSetController的结构，包括apiserver的客户端，informer的回调函数等等。NewReplicaSetController-&gt;NewBaseController</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReplicaSetController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class="string">"apps"</span>, Version: <span class="string">"v1"</span>, Resource: <span class="string">"replicasets"</span>&#125;] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> replicaset.NewReplicaSetController(</span><br><span class="line">		ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">		ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">		ctx.ClientBuilder.ClientOrDie(<span class="string">"replicaset-controller"</span>),</span><br><span class="line">		replicaset.BurstReplicas,</span><br><span class="line">	).Run(<span class="keyword">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键函数run：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go<br>run中执行rsc.worker。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run begins watching and syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> rsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	controllerName := strings.ToLower(rsc.Kind)</span><br><span class="line">	klog.Infof(<span class="string">"Starting %v controller"</span>, controllerName)</span><br><span class="line">	<span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down %v controller"</span>, controllerName)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rsc.worker即为rsc.syncHandler，而syncHandler在创建时来源于rsc.syncReplicaSet（见NewBaseController方法）<br><strong>那么我们转到syncReplicaSet</strong><br><strong>位置：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go<br><strong>updateReplicaSetStatus：</strong>在pod死亡或者新建时更新</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syncReplicaSet will sync the ReplicaSet with the given key if it has had its expectations fulfilled,</span></span><br><span class="line"><span class="comment">// meaning it did not expect to see any more of its pods created or deleted. This function is not meant to be</span></span><br><span class="line"><span class="comment">// invoked concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing %v %q (%v)"</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"%v %v has been deleted"</span>, rsc.Kind, key)</span><br><span class="line">		rsc.expectations.DeleteExpectations(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">	selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting pod selector to selector: %v"</span>, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// list all pods to include the pods that don't match the rs`s selector</span></span><br><span class="line">	<span class="comment">// anymore but has the stale controller ref.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Do the List and Filter in a single pass, or use an index.</span></span><br><span class="line">	allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Ignore inactive pods.</span></span><br><span class="line">	filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> filteredPods are pointing to objects from cache - if you need to</span></span><br><span class="line">	<span class="comment">// modify them, you need to copy it first.</span></span><br><span class="line">	filteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manageReplicasErr error</span><br><span class="line">	<span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">		manageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class="line">	&#125;</span><br><span class="line">	rs = rs.DeepCopy()</span><br><span class="line">	newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Always updates status as pods come up or die.</span></span><br><span class="line">	updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Multiple things could lead to this update failing. Requeuing the replica set ensures</span></span><br><span class="line">		<span class="comment">// Returning an error causes a requeue without forcing a hotloop</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Resync the ReplicaSet after MinReadySeconds as a last line of defense to guard against clock-skew.</span></span><br><span class="line">	<span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">		updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">		rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>转到updateReplicaSetStatus：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set_utils.go<br>调用UpdateStatus，通过apiserver更新</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// updateReplicaSetStatus attempts to update the Status.Replicas of the given ReplicaSet, with a single GET/PUT retry.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateReplicaSetStatus</span><span class="params">(c appsclient.ReplicaSetInterface, rs *apps.ReplicaSet, newStatus apps.ReplicaSetStatus)</span> <span class="params">(*apps.ReplicaSet, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// This is the steady state. It happens when the ReplicaSet doesn't have any expectations, since</span></span><br><span class="line">	<span class="comment">// we do a periodic relist every 30s. If the generations differ but the replicas are</span></span><br><span class="line">	<span class="comment">// the same, a caller might've resized to the same replica count.</span></span><br><span class="line">	<span class="keyword">if</span> rs.Status.Replicas == newStatus.Replicas &amp;&amp;</span><br><span class="line">		rs.Status.FullyLabeledReplicas == newStatus.FullyLabeledReplicas &amp;&amp;</span><br><span class="line">		rs.Status.ReadyReplicas == newStatus.ReadyReplicas &amp;&amp;</span><br><span class="line">		rs.Status.AvailableReplicas == newStatus.AvailableReplicas &amp;&amp;</span><br><span class="line">		rs.Generation == rs.Status.ObservedGeneration &amp;&amp;</span><br><span class="line">		reflect.DeepEqual(rs.Status.Conditions, newStatus.Conditions) &#123;</span><br><span class="line">		<span class="keyword">return</span> rs, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the generation number we acted on, otherwise we might wrongfully indicate</span></span><br><span class="line">	<span class="comment">// that we've seen a spec update when we retry.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> This can clobber an update if we allow multiple agents to write to the</span></span><br><span class="line">	<span class="comment">// same status.</span></span><br><span class="line">	newStatus.ObservedGeneration = rs.Generation</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> getErr, updateErr error</span><br><span class="line">	<span class="keyword">var</span> updatedRS *apps.ReplicaSet</span><br><span class="line">	<span class="keyword">for</span> i, rs := <span class="number">0</span>, rs; ; i++ &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(fmt.Sprintf(<span class="string">"Updating status for %v: %s/%s, "</span>, rs.Kind, rs.Namespace, rs.Name) +</span><br><span class="line">			fmt.Sprintf(<span class="string">"replicas %d-&gt;%d (need %d), "</span>, rs.Status.Replicas, newStatus.Replicas, *(rs.Spec.Replicas)) +</span><br><span class="line">			fmt.Sprintf(<span class="string">"fullyLabeledReplicas %d-&gt;%d, "</span>, rs.Status.FullyLabeledReplicas, newStatus.FullyLabeledReplicas) +</span><br><span class="line">			fmt.Sprintf(<span class="string">"readyReplicas %d-&gt;%d, "</span>, rs.Status.ReadyReplicas, newStatus.ReadyReplicas) +</span><br><span class="line">			fmt.Sprintf(<span class="string">"availableReplicas %d-&gt;%d, "</span>, rs.Status.AvailableReplicas, newStatus.AvailableReplicas) +</span><br><span class="line">			fmt.Sprintf(<span class="string">"sequence No: %v-&gt;%v"</span>, rs.Status.ObservedGeneration, newStatus.ObservedGeneration))</span><br><span class="line"></span><br><span class="line">		rs.Status = newStatus</span><br><span class="line">		updatedRS, updateErr = c.UpdateStatus(context.TODO(), rs, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> updateErr == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> updatedRS, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Stop retrying if we exceed statusUpdateRetries - the replicaSet will be requeued with a rate limit.</span></span><br><span class="line">		<span class="keyword">if</span> i &gt;= statusUpdateRetries &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Update the ReplicaSet with the latest resource version for the next poll</span></span><br><span class="line">		<span class="keyword">if</span> rs, getErr = c.Get(context.TODO(), rs.Name, metav1.GetOptions&#123;&#125;); getErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// If the GET fails we can't trust status.Replicas anymore. This error</span></span><br><span class="line">			<span class="comment">// is bound to be more interesting than the update failure.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, getErr</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, updateErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PodGCController"><a href="#PodGCController" class="headerlink" title="PodGCController"></a>PodGCController</h2><blockquote>
<p>1.gc掉超过阈值限制的pod，按时间排序gc</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcTerminated</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	terminatedPods := []*v1.Pod&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> isPodTerminated(pod) &#123;</span><br><span class="line">			terminatedPods = <span class="built_in">append</span>(terminatedPods, pod)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	terminatedPodCount := <span class="built_in">len</span>(terminatedPods)</span><br><span class="line">	deleteCount := terminatedPodCount - gcc.terminatedPodThreshold</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> deleteCount &gt; terminatedPodCount &#123;</span><br><span class="line">		deleteCount = terminatedPodCount</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> deleteCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.Infof(<span class="string">"garbage collecting %v pods"</span>, deleteCount)</span><br><span class="line">	<span class="comment">// sort only when necessary</span></span><br><span class="line">	sort.Sort(byCreationTimestamp(terminatedPods))</span><br><span class="line">	<span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deleteCount; i++ &#123;</span><br><span class="line">		wait.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(namespace <span class="keyword">string</span>, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wait.Done()</span><br><span class="line">			<span class="keyword">if</span> err := gcc.deletePod(namespace, name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// ignore not founds</span></span><br><span class="line">				<span class="keyword">defer</span> utilruntime.HandleError(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(terminatedPods[i].Namespace, terminatedPods[i].Name)</span><br><span class="line">	&#125;</span><br><span class="line">	wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.gc掉孤儿pod：pod上的node信息不在当前可调度的节点上，即没有和有效node绑定</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcOrphaned deletes pods that are bound to nodes that don't exist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcOrphaned</span><span class="params">(pods []*v1.Pod, nodes []*v1.Node)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing orphaned"</span>)</span><br><span class="line">	existingNodeNames := sets.NewString()</span><br><span class="line">	<span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">		existingNodeNames.Insert(node.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Add newly found unknown nodes to quarantine</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> pod.Spec.NodeName != <span class="string">""</span> &amp;&amp; !existingNodeNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line">			gcc.nodeQueue.AddAfter(pod.Spec.NodeName, quarantineTime)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check if nodes are still missing after quarantine period</span></span><br><span class="line">	deletedNodesNames, quit := gcc.discoverDeletedNodes(existingNodeNames)</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Delete orphaned pods</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> !deletedNodesNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"Found orphaned Pod %v/%v assigned to the Node %v. Deleting."</span>, pod.Namespace, pod.Name, pod.Spec.NodeName)</span><br><span class="line">		<span class="keyword">if</span> err := gcc.deletePod(pod.Namespace, pod.Name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">0</span>).Infof(<span class="string">"Forced deletion of orphaned Pod %v/%v succeeded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.gc掉没有调度成功的pod：表现在pod的NodeName为空,主要由于资源等条件不满足</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcUnscheduledTerminating deletes pods that are terminating and haven't been scheduled to a particular node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcUnscheduledTerminating</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing unscheduled pods which are terminating."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> pod.DeletionTimestamp == <span class="literal">nil</span> || <span class="built_in">len</span>(pod.Spec.NodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"Found unscheduled terminating Pod %v/%v not assigned to any Node. Deleting."</span>, pod.Namespace, pod.Name)</span><br><span class="line">		<span class="keyword">if</span> err := gcc.deletePod(pod.Namespace, pod.Name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">0</span>).Infof(<span class="string">"Forced deletion of unscheduled terminating Pod %v/%v succeeded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// byCreationTimestamp sorts a list by creation timestamp, using their names as a tie breaker.</span></span><br><span class="line"><span class="keyword">type</span> byCreationTimestamp []*v1.Pod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(o) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; o[i], o[j] = o[j], o[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o[i].CreationTimestamp.Equal(&amp;o[j].CreationTimestamp) &#123;</span><br><span class="line">		<span class="keyword">return</span> o[i].Name &lt; o[j].Name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o[i].CreationTimestamp.Before(&amp;o[j].CreationTimestamp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://km.oa.com/group/18974/articles/show/439387?kmref=dailymail_todayposts&amp;jumpfrom=daily_mail" target="_blank" rel="external nofollow noopener noreferrer">http://km.oa.com/group/18974/articles/show/439387?kmref=dailymail_todayposts&amp;jumpfrom=daily_mail</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>k8s</tag>
        <tag>源码阅读</tag>
        <tag>controller</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】Kubelet</title>
    <url>/posts/fb705539/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000021603262" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000021603262</a></li>
</ul>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】Service</title>
    <url>/posts/cfed77f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes 中的 Service 将一组 Pod 以统一的形式对外暴露成一个服务，它利用运行在内核空间的 iptables 或者 ipvs 高效地转发来自节点内部和外部的流量。作为非常重要的 Kubernetes 对象，Service 不仅在逻辑上提供了微服务的概念，还引入 LoadBalancer 类型的 Service 无缝对接云服务商提供的复杂资源。</p>
<a id="more"></a>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>我们知道，Kubernetes 中的每一个 Pod 都可以通过 <code>podIP</code> 被直接访问，但是 Pod 是有生命周期的对象，它们可以被创建，而且销毁之后不会再启动。如果 <code>Deployment</code>、<code>ReplicaSet</code> 等对象管理 Pod，则它们可以动态地创建和销毁 Pod。在这种情况下，<code>Deployment</code>当前时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。</p>
<p>这就造成了一个问题，如果一组backend Pod 为集群中的另一组frontend Pod 提供服务时，由于每一个 Pod 都有自己的IP地址，并且这组Pod是会动态变化的，那么Frontend如何做服务发现以及会话保持，从而可以使用 Backend Pod 的服务？</p>
<p>为了解决这个问题，Kubernetes提出了 Service 这个概念：Service 是一组 Pod的逻辑集合和访问方式的抽象。举个例子，考虑一个图片处理后端，它运行了 3 个副本。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。 Service 定义的抽象能够解耦这种关联。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>下面是一个 Service 的典型定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>这里注意几个Port的定义区分：</p>
<ul>
<li>port：service暴露在cluster ip上的端口，<code>&lt;cluster ip&gt;:port</code> 是提供给集群内部客户访问service的入口</li>
<li>targetPort：Pod监听的端口，service会把流量转发到对应的Pod，Pod中的容器也需要监听这个端口</li>
<li>nodePort：对应于NodePort类型的Service时指定的节点上的Port，详见 <a href="#NodePort">NodePort</a></li>
</ul>
<p>在命令行中可以看到集群为Service创建了一个 <code>ClusterIP</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-1-28-centos nginx]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nginx         ClusterIP   172.18.255.55    &lt;none&gt;        8080/TCP   5s</span><br></pre></td></tr></table></figure>
<p>创建 Nginx 实际对应的 Deployment：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>对应于实际服务请求的路径如下图所示：</p>
<p><img alt="Kubernetes Service" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-kube-proxy.png"></p>
<h2 id="Publish-Services"><a href="#Publish-Services" class="headerlink" title="Publish Services"></a>Publish Services</h2><p>Kubernetes 中支持四种服务暴露的方式： ClusterIP、NodePort、LoadBalancer、ExternelName</p>
<h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><p>ClusterIP 类型的 service 是 kubernetes 集群默认的服务暴露方式，它只能用于集群内部通信，可以被各 pod 访问，其访问方式为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">pod ---&gt; ClusterIP:ServicePort --&gt; (iptables)DNAT --&gt; PodIP:containePort</span><br></pre></td></tr></table></figure>
<p>ClusterIP Service 类型的结构如下图所示:</p>
<p><img alt="Cluster IP" data-src="https://upload-images.jianshu.io/upload_images/1262158-875870767bdb199d.png"></p>
<h4 id="Headless-service"><a href="#Headless-service" class="headerlink" title="Headless service"></a>Headless service</h4><p>当不需要负载均衡以及单独的 ClusterIP 时，可以通过指定 <code>spec.clusterIP</code> 的值为 <code>None</code> 来创建 Headless service，它会给一个集群内部的每个成员提供一个唯一的 DNS 域名来作为每个成员的网络标识，集群内部成员之间使用域名通信。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>如果想要在集群外访问集群内部的服务，可以使用这种类型的 service，NodePort 类型的 service 会在集群内部署了 kube-proxy 的每个节点打开一个指定的端口，之后所有的流量直接发送到这个端口，然后会被转发到 service 后端真实的服务进行访问。Nodeport 构建在 ClusterIP 上，其访问链路如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">client ---&gt; NodeIP:NodePort ---&gt; ClusterIP:ServicePort ---&gt; (iptables)DNAT ---&gt; PodIP:containePort</span><br></pre></td></tr></table></figure>
<p>其对应具体的 iptables 规则会在后文进行讲解。</p>
<p>NodePort service 类型的结构如下图所示:</p>
<p><img alt="Node Port" data-src="https://upload-images.jianshu.io/upload_images/1262158-0873f8f59cb83a8c.png"></p>
<p>修改 service 定义如下，其中 <code>nodeport</code> 字段表示通过 nodeport 方式访问的端口，<code>port</code> 表示通过 service 方式访问的端口，<code>targetPort</code> 表示 pod port。如果这里的 <code>nodePort</code> 字段不指定，Kubernetes会自动申请一个Node Port。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="comment"># By default and for convenience, the `targetPort` is set to the same value as the `port` field.</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="comment"># Optional field</span></span><br><span class="line">    <span class="comment"># By default and for convenience, the Kubernetes control plane will allocate a port from a range (default: 30000-32767)</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>kubectl get service</code> 可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx         NodePort    172.18.252.115   &lt;none&gt;        80:30080/TCP   20s</span><br></pre></td></tr></table></figure>
<p>这时候，在浏览器中选择集群中任意一节点的IP作为 <code>nodeIP</code>，通过浏览器 <code>http://&lt;nodeIP&gt;:&lt;nodePort&gt;</code> 可以看到 Nginx 的欢迎界面。</p>
<h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>LoadBalancer 类型的 service 通常和云厂商的 LB 结合一起使用，用于将集群内部的服务暴露到外网，云厂商的 LoadBalancer 会给用户分配一个 IP，之后通过该 IP 的流量会转发到你的 service 上。</p>
<p>LoadBalancer service 类型的结构如下图所示:</p>
<p><img alt="Load Balancer" data-src="https://upload-images.jianshu.io/upload_images/1262158-6f8d3d4c58adeeca.png"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.171</span><span class="number">.239</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span> <span class="number">78.11</span><span class="number">.24</span><span class="number">.19</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">146.148</span><span class="number">.47</span><span class="number">.155</span></span><br></pre></td></tr></table></figure>
<h3 id="ExternelName"><a href="#ExternelName" class="headerlink" title="ExternelName"></a>ExternelName</h3><p>类型为 ExternalName 的服务将服务映射到 DNS 名称，而不是典型的选择器，例如 <code>my-service</code> 或者 <code>cassandra</code>。 您可以使用 <code>spec.externalName</code> 参数指定这些服务。</p>
<p>例如，以下 Service 定义将 <code>prod</code> 名称空间中的 <code>my-service</code> 服务映射到 <code>my.database.example.com</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure>
<p>当查找主机 <code>my-service.prod.svc.cluster.local</code> 时，集群 DNS 服务返回 <code>CNAME</code> 记录， 其值为 <code>my.database.example.com</code>。 访问 <code>my-service</code> 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。 如果以后您决定将数据库移到群集中，则可以启动其 Pod，添加适当的选择器或端点以及更改服务的 <code>type</code>。</p>
<h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>Service 是一组具有相同 label pod 集合的抽象，集群内外的各个服务可以通过 service 进行互相通信。在 Kubernetes 中创建一个新的 Service 对象需要两大模块同时协作:</p>
<ul>
<li>Controller：在每次创建新的 Service 对象时，会同时创建一个 Endpoint 对象。Endpoint 是用于<strong>容器发现</strong>，Service 只是将多个 Pod 进行关联。Endpoints Controller 是负责生成和维护所有 Endpoints 对象的控制器，监听 Service 和对应 Pod 的变化，更新对应 Service 的 Endpoints 对象。当 Pod 处于 running 且准备就绪时，Endpoints Controller 会将 Pod IP 记录到 Endpoints 对象中。</li>
<li>kube-proxy：它运行在 Kubernetes 集群中的每一个节点上，会根据 Service 和 Endpoint 的变动改变节点上 iptables 或者 ipvs 中保存的规则。</li>
</ul>
<p><img alt="Kubernetes Service" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-service.png"></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>每当有服务被创建或者销毁时，Informer 都会通知 <code>ServiceController</code>，它会将这些任务投入工作队列中并由其本身启动的 Worker 协程消费：</p>
<pre class="mermaid">sequenceDiagram
    participant I as Informer
    participant SC as ServiceController
    participant Q as WorkQueue
    participant B as Balancer
    I->>+SC: Add/Update/DeleteService
    SC->>Q: Add
    Q-->>SC: return
    deactivate SC
    loop Worker
        SC->>+Q: Get
        Q-->>-SC: key
        SC->>SC: syncService
        SC->>+B: EnsureLoadBalancer
        B-->>-SC: LoadBalancerStatus
    end</pre>

<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>我们在使用 Kubernetes 时虽然很少会直接与 Endpoint 资源打交道，但是它却是 Kubernetes 中非常重要的组成部分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoints is a collection of endpoints that implement the actual service.  Example:</span></span><br><span class="line"><span class="comment">//   Name: "mysvc",</span></span><br><span class="line"><span class="comment">//   Subsets: [</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       Addresses: [&#123;"ip": "10.10.1.1"&#125;, &#123;"ip": "10.10.2.2"&#125;],</span></span><br><span class="line"><span class="comment">//       Ports: [&#123;"name": "a", "port": 8675&#125;, &#123;"name": "b", "port": 309&#125;]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       Addresses: [&#123;"ip": "10.10.3.3"&#125;],</span></span><br><span class="line"><span class="comment">//       Ports: [&#123;"name": "a", "port": 93&#125;, &#123;"name": "b", "port": 76&#125;]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"><span class="keyword">type</span> Endpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The set of all endpoints is the union of all subsets.</span></span><br><span class="line">	Subsets []EndpointSubset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndpointSubset is a group of addresses with a common set of ports.  The</span></span><br><span class="line"><span class="comment">// expanded set of endpoints is the Cartesian product of Addresses x Ports.</span></span><br><span class="line"><span class="comment">// For example, given:</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     Addresses: [&#123;"ip": "10.10.1.1"&#125;, &#123;"ip": "10.10.2.2"&#125;],</span></span><br><span class="line"><span class="comment">//     Ports:     [&#123;"name": "a", "port": 8675&#125;, &#123;"name": "b", "port": 309&#125;]</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// The resulting set of endpoints can be viewed as:</span></span><br><span class="line"><span class="comment">//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],</span></span><br><span class="line"><span class="comment">//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]</span></span><br><span class="line"><span class="keyword">type</span> EndpointSubset <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addresses         []EndpointAddress</span><br><span class="line">	NotReadyAddresses []EndpointAddress</span><br><span class="line">	Ports             []EndpointPort</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>While you’re correct that in the <a href="https://kubernetes.io/docs/reference/glossary" target="_blank" rel="external nofollow noopener noreferrer">glossary</a> there’s indeed no entry for endpoint, it is a well defined Kubernetes network concept or abstraction. Since it’s of secondary nature, you’d usually not directly manipulate it. There’s a core resource <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#endpoints-v1-core" target="_blank" rel="external nofollow noopener noreferrer">Endpoint</a> defined and it’s also supported on the command line:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="keyword">get</span> ep</span><br><span class="line">NAME         ENDPOINTS            AGE</span><br><span class="line">kubernetes   <span class="number">192.168</span><span class="number">.64</span><span class="number">.13</span>:<span class="number">8443</span>   <span class="number">10</span>d</span><br></pre></td></tr></table></figure>
<p>And there you see what it effectively is: an IP address and a port. Usually, you’d let a service manage endpoints (one EP per pod the service routes traffic to) but you can also <a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="external nofollow noopener noreferrer">manually manage</a> them if you have a use case that requires it.</p>
<p>  服务和pod不是直接连接，而是通过<strong>Endpoint资源</strong>进行连通。endpoint资源是暴露<strong>一个服务的ip地址和port的列表。</strong>  选择器用于构建ip和port列表，然后存储在endpoint资源中。当客户端连接到服务时，服务代理选择这些列表中的ip和port对中的一个，并将传入连接重定向到在该位置监听的服务器。  endpoint是一个单独的资源并不是服务的属性，<strong>endpoint的名称必须和服务的名称相匹配</strong>。</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>  为没有选择器的服务创建endpoint资源： <code>$ kubectl create -f endpoint.yml</code>  endpoint对象需要与服务相同的名称，并包含该服务的目标ip和port列表，服务和endpoint资源都发布到服务器后，这样服务就可以像具有pod选择器那样的服务正常使用。</p>
<p><img alt="endpoint yml 模板" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/1"></p>
</blockquote>
<p><code>EndpointController</code> 本身并没有通过 <code>Informer</code> 监听 Endpoint 资源的变动，但是它却同时订阅了 Service 和 Pod 资源的增删事件，对于 Service 资源来讲，<code>EndpointController</code> 会通过以下的方式进行处理：</p>
<pre class="mermaid">sequenceDiagram
    participant I as Informer
    participant EC as EndpointController
    participant Q as WorkQueue
    participant PL as PodLister
    participant C as Client
    I->>+EC: Add/Update/DeleteService
    EC->>Q: Add
    Q-->>EC: return
    loop Worker
        EC->>+Q: Get
        Q-->>-EC: key
        EC->>+EC: syncService
        EC->>+PL: ListPod(service.Spec.Selector)
        PL-->>-EC: Pods
        loop Every Pod
            EC->>EC: addEndpointSubset
        end
        EC->>C: Create/UpdateEndpoint
        C-->>-EC: result
    end</pre>

<p><code>EndpointController</code> 中的 <code>syncService</code> 方法是用于创建和删除 Endpoint 资源最重要的方法，在这个方法中我们会根据 Service 对象规格中的选择器 Selector 获取集群中存在的所有 Pod，并将 Service 和 Pod 上的端口进行映射生成一个 <code>EndpointPort</code> 结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">syncService</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	namespace, name, _ := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	service, _ := e.serviceLister.Services(namespace).Get(name)</span><br><span class="line">	pods, _ := e.podLister.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelectorPreValidated())</span><br><span class="line"></span><br><span class="line">	subsets := []v1.EndpointSubset&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		epa := *podToEndpointAddress(pod)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">			servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line"></span><br><span class="line">			portName := servicePort.Name</span><br><span class="line">			portProto := servicePort.Protocol</span><br><span class="line">			portNum, _ := podutil.FindPort(pod, servicePort)</span><br><span class="line"></span><br><span class="line">			epp := &amp;v1.EndpointPort&#123;Name: portName, Port: <span class="keyword">int32</span>(portNum), Protocol: portProto&#125;</span><br><span class="line">			subsets, _, _ = addEndpointSubset(subsets, pod, epa, epp, tolerateUnreadyEndpoints)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	subsets = endpoints.RepackSubsets(subsets)</span><br><span class="line"></span><br><span class="line">	currentEndpoints = &amp;v1.Endpoints&#123;</span><br><span class="line">		ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">			Name:   service.Name,</span><br><span class="line">			Labels: service.Labels,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newEndpoints := currentEndpoints.DeepCopy()</span><br><span class="line">	newEndpoints.Subsets = subsets</span><br><span class="line">	newEndpoints.Labels = service.Labels</span><br><span class="line">	e.client.CoreV1().Endpoints(service.Namespace).Create(newEndpoints)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一个 Pod 都会生成一个新的 <code>EndpointSubset</code>，其中包含了 Pod 的 IP 地址和端口和 Service 的规格中指定的输入端口和目标端口，在最后 <code>EndpointSubset</code> 的数据会被重新打包并通过客户端创建一个新的 Endpoint 资源。</p>
<p>在上面我们已经提到过，除了 Service 的变动会触发 Endpoint 的改变之外，Pod 对象的增删也会触发 <code>EndpointController</code> 中的回调函数。</p>
<pre class="mermaid">sequenceDiagram
    participant I as Informer
    participant EC as EndpointController
    participant Q as WorkQueue
    participant SL as ServiceLister
    I->>+EC: Add/Update/DeletePod
    EC->>+SL: GetPodServices
    SL-->>-EC: []Service
    EC->>Q: Add
    Q-->>EC: return
    deactivate EC</pre>

<p><code>getPodServiceMemberships</code> 会获取跟当前 Pod 有关的 Service 对象并将所有的 Service 对象都转换成 <code>&lt;namespace&gt;/&lt;name&gt;</code> 的字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">getPodServiceMemberships</span><span class="params">(pod *v1.Pod)</span> <span class="params">(sets.String, error)</span></span> &#123;</span><br><span class="line">	set := sets.String&#123;&#125;</span><br><span class="line">	services, _ := e.serviceLister.GetPodServices(pod)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> services &#123;</span><br><span class="line">		key, _ := controller.KeyFunc(services[i])</span><br><span class="line">		set.Insert(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> set, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些服务最后会被加入 <code>EndpointController</code> 的队列中，等待它持有的几个 Worker 对 Service 进行同步。</p>
<p>这些其实就是 <code>EndpointController</code> 的作用，订阅 Pod 和 Service 对象的变更，并根据当前集群中的对象生成 Endpoint 对象将两者进行关联。</p>
<h2 id="Proxy-Mode"><a href="#Proxy-Mode" class="headerlink" title="Proxy Mode"></a>Proxy Mode</h2><p>在 Kubernetes 集群中的每一个节点都运行着一个 kube-proxy 进程，这个进程会负责监听 Kubernetes 主节点中 Service 的增加和删除事件并修改运行代理的配置，为节点内的客户端提供流量的转发和负载均衡等功能。在整个集群中另一个订阅 Service 对象变动的组件就是 kube-proxy 了，每当 kube-proxy 在新的节点上启动时都会初始化一个 <code>ServiceConfig</code> 对象，就像介绍 iptables 代理模式时提到的，这个对象会接受 Service 的变更事件：</p>
<pre class="mermaid">sequenceDiagram
    participant SCT as ServiceChangeTracker
    participant SC as ServiceConfig
    participant P as Proxier
    participant EC as EndpointConfig
    participant ECT as EndpointChangeTracker
    participant SR as SyncRunner
    SC->>+P: OnServiceAdd/Update/Delete/Synced
    P->>SCT: Update
    SCT-->>P: Return ServiceMap
    deactivate P
    EC->>+P: OnEndpointsAdd/Update/Delete/Synced
    ECT-->>P: Return EndpointMap
    P->>ECT: Update
    deactivate P
    loop Every minSyncPeriod ~ syncPeriod
        SR->>P: syncProxyRules
    end</pre>

<p>这些变更事件都会被订阅了集群中对象变动的 <code>ServiceConfig</code> 和 <code>EndpointConfig</code> 对象推送给启动的 <code>Proxier</code> 实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceConfig)</span> <span class="title">handleAddService</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	service, ok := obj.(*v1.Service)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">		c.eventHandlers[i].OnServiceAdd(service)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到事件变动的 <code>Proxier</code> 实例随后会根据启动时的配置更新 iptables 或者 ipvs 中的规则，这些应用最终会负责对进出的流量进行转发并完成一些负载均衡相关的任务。</p>
<h3 id="Userspace"><a href="#Userspace" class="headerlink" title="Userspace"></a>Userspace</h3><p>作为运行在用户空间的代理，对于每一个 Service 都会在当前的节点上开启一个端口，所有连接到当前代理端口的请求都会被转发到 Service 背后的一组 Pod 上，它其实会在节点上添加 iptables 规则，通过 iptables 将流量转发给 kube-proxy 处理。</p>
<p>如果当前节点上的 kube-proxy 在启动时选择了 userspace 模式，那么每当有新的 Service 被创建时，kube-proxy 就会增加一条 iptables 记录并启动一个 Goroutine，前者用于将节点中服务对外发出的流量转发给 kube-proxy，再由后者持有的一系列 Goroutine 将流量转发到目标的 Pod 上。</p>
<p>在 userspace 模式下，访问服务的请求到达节点后首先进入内核 iptables，然后回到用户空间，由 kube-proxy 转发到后端的 pod，这样流量从用户空间进出内核带来的性能损耗是不可接受的，所以也就有了 iptables 模式。</p>
<p>为什么 userspace 模式要建立 iptables 规则，因为 kube-proxy 监听的端口在用户空间，这个端口不是服务的访问端口也不是服务的 nodePort，因此需要一层 iptables 把访问服务的连接重定向给 kube-proxy 服务。</p>
<p><img alt="Service Userspace Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-userspace.svg"></p>
<p>这一系列的工作大都是在 <code>OnServiceAdd</code> 被触发时中完成的，正如上面所说的，该方法会调用 <code>mergeService</code> 将传入服务 Service 的端口变成一条 iptables 的配置命令为当前节点增加一条规则，同时在 <code>addServiceOnPort</code> 方法中启动一个 TCP 或 UDP 的 Socket：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">mergeService</span><span class="params">(service *v1.Service)</span> <span class="title">sets</span>.<span class="title">String</span></span> &#123;</span><br><span class="line">	svcName := types.NamespacedName&#123;Namespace: service.Namespace, Name: service.Name&#125;</span><br><span class="line">	existingPorts := sets.NewString()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">		servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line">		serviceName := proxy.ServicePortName&#123;NamespacedName: svcName, Port: servicePort.Name&#125;</span><br><span class="line">		existingPorts.Insert(servicePort.Name)</span><br><span class="line">		info, exists := proxier.getServiceInfo(serviceName)</span><br><span class="line">		<span class="keyword">if</span> exists &#123;</span><br><span class="line">			proxier.closePortal(serviceName, info)</span><br><span class="line">			proxier.stopProxy(serviceName, info)</span><br><span class="line">		&#125;</span><br><span class="line">		proxyPort,  := proxier.proxyPorts.AllocateNext()</span><br><span class="line"></span><br><span class="line">		serviceIP := net.ParseIP(service.Spec.ClusterIP)</span><br><span class="line">		info, _ = proxier.addServiceOnPort(serviceName, servicePort.Protocol, proxyPort, proxier.udpIdleTimeout)</span><br><span class="line">		info.portal.ip = serviceIP</span><br><span class="line">		info.portal.port = <span class="keyword">int</span>(servicePort.Port)</span><br><span class="line">		info.externalIPs = service.Spec.ExternalIPs</span><br><span class="line">		info.loadBalancerStatus = *service.Status.LoadBalancer.DeepCopy()</span><br><span class="line">		info.nodePort = <span class="keyword">int</span>(servicePort.NodePort)</span><br><span class="line">		info.sessionAffinityType = service.Spec.SessionAffinity</span><br><span class="line"></span><br><span class="line">		proxier.openPortal(serviceName, info)</span><br><span class="line">		proxier.loadBalancer.NewService(serviceName, info.sessionAffinityType, info.stickyMaxAgeSeconds)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> existingPorts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个启动的进程会监听同一个节点上，转发自所有进程的 TCP 和 UDP 请求并将这些数据包发送给目标的 Pod 对象。</p>
<p>在用户空间模式中，如果一个连接被目标服务拒绝，我们的代理服务能够重新尝试连接其他的服务，除此之外用户空间模式并没有太多的优势。</p>
<h3 id="IPTables"><a href="#IPTables" class="headerlink" title="IPTables"></a>IPTables</h3><p>另一种常见的代理模式就是直接使用 iptables 转发当前节点上的全部流量，这种脱离了用户空间在内核空间中实现转发的方式能够极大地提高 proxy 的效率，增加 kube-proxy 的吞吐量。</p>
<p>iptables 模式是目前默认的代理方式，基于 netfilter 实现。当客户端请求 service 的 ClusterIP 时，根据 iptables 规则路由到各 pod 上，iptables 使用 DNAT 来完成转发，其采用了随机数实现负载均衡。</p>
<p>iptables 模式与 userspace 模式最大的区别在于，iptables 模块使用 DNAT 模块实现了 service 入口地址到 pod 实际地址的转换，免去了一次内核态到用户态的切换，另一个与 userspace 代理模式不同的是，如果 iptables 代理最初选择的那个 pod 没有响应，它不会自动重试其他 pod。</p>
<p>iptables 模式最主要的问题是在 service 数量大的时候会产生太多的 iptables 规则，使用非增量式更新会引入一定的时延，大规模情况下有明显的性能问题。</p>
<p><img alt="Service Iptables Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-iptables.svg"></p>
<p>iptables 作为一种代理模式，它同样实现了 <code>OnServiceUpdate</code>、<code>OnEndpointsUpdate</code> 等方法，这两个方法会分别调用相应的变更追踪对象。</p>
<pre class="mermaid">sequenceDiagram
    participant SC as ServiceConfig
    participant P as Proxier
    participant SCT as ServiceChangeTracker
    participant SR as SyncRunner
    participant I as iptable
    SC->>+P: OnServiceAdd
    P->>P: OnServiceUpdate
    P->>SCT: Update
    SCT-->>P: Return ServiceMap
    deactivate P
    loop Every minSyncPeriod ~ syncPeriod
        SR->>+P: syncProxyRules
        P->>I: UpdateChain
        P->>P: writeLine x N
        P->>I: RestoreAll
        deactivate P
    end</pre>

<p>变更追踪对象会根据 <code>Service</code> 或 <code>Endpoint</code> 对象的前后变化改变 <code>ServiceChangeTracker</code> 本身的状态，这些变更会每隔一段时间通过一个 700 行的巨大方法 <code>syncProxyRules</code> 同步，在这里就不介绍这个方法的具体实现了，它的主要功能就是根据 <code>Service</code> 和 <code>Endpoint</code> 对象的变更生成一条一条的 iptables 规则，比较感兴趣的读者，可以点击 <a href="https://sourcegraph.com/github.com/kubernetes/kubernetes@master/-/blob/pkg/proxy/iptables/proxier.go#L640-1379" target="_blank" rel="external nofollow noopener noreferrer">proxier.go#L640-1379</a> 查看代码。</p>
<p>当我们使用 iptables 的方式启动节点上的代理时，所有的流量都会先经过 <code>PREROUTING</code> 或者 <code>OUTPUT</code> 链，随后进入 Kubernetes 自定义的链入口 KUBE-SERVICES、单个 Service 对应的链 <code>KUBE-SVC-XXXX</code> 以及每个 Pod 对应的链 <code>KUBE-SEP-XXXX</code>，经过这些链的处理，最终才能够访问当一个服务的真实 IP 地址。</p>
<p>虽然相比于用户空间来说，直接运行在内核态的 iptables 能够增加代理的吞吐量，但是当集群中的节点数量非常多时，iptables 并不能达到生产级别的可用性要求，每次对规则进行匹配时都会遍历 iptables 中的所有 Service 链。</p>
<p>规则的更新也不是增量式的，当集群中的 Service 达到 5,000 个，每增加一条规则都需要耗时 11min，当集群中的 Service 达到 20,000 个时，每增加一条规则都需要消耗 5h 的时间，这也就是告诉我们在大规模集群中使用 iptables 作为代理模式是完全不可用的。</p>
<h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>ipvs 就是用于解决在大量 Service 时，iptables 规则同步变得不可用的性能问题。与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，这也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能。</p>
<p><img alt="Service IPVS Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-ipvs.svg"></p>
<p>在处理 Service 的变化时，ipvs 包和 iptables 其实就有非常相似了，它们都同样使用 <code>ServiceChangeTracker</code> 对象来追踪变更，只是两者对于同步变更的方法 <code>syncProxyRules</code> 实现上有一些不同。</p>
<pre class="mermaid">sequenceDiagram
    participant P as Proxier
    participant SR as SyncRunner
    participant IP as ipvs
    participant I as iptable
    loop Every minSyncPeriod ~ syncPeriod
        SR->>+P: syncProxyRules
        P->>P: writeLine(iptable)
        P->>IP: Add/UpdateVirtualServer(syncService)
        IP-->>P: result
        P->>IP: AddRealServer(syncEndpoint)
        IP-->>P: result
        P->>I: RestoreAll
        deactivate P
    end</pre>

<p>我们从 ipvs 的源代码和上述的时序图中可以看到，Kubernetes ipvs 的实现其实是依赖于 iptables 的，后者能够辅助它完成一些功能，使用 ipvs 相比 iptables 能够减少节点上的 iptables 规则数量，这也是因为 ipvs 接管了原来存储在 iptables 中的规则。</p>
<p>除了能够提升性能之外，ipvs 也提供了多种类型的负载均衡算法，除了最常见的 Round-Robin 之外，还支持最小连接、目标哈希、最小延迟等算法，能够很好地提升负载均衡的效率。</p>
<p>当集群规模比较大时，iptables 规则刷新会非常慢，难以支持大规模集群，因其底层路由表的实现是链表，对路由规则的增删改查都要涉及遍历一次链表，ipvs 的问世正是解决此问题的，ipvs 是 LVS 的负载均衡模块，与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能，几乎允许无限的规模扩张。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://xigang.github.io/2019/07/21/kubernetes-service/" target="_blank" rel="external nofollow noopener noreferrer">https://xigang.github.io/2019/07/21/kubernetes-service/</a></li>
<li><a href="https://www.cnblogs.com/passzhang/p/12544597.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/passzhang/p/12544597.html</a></li>
<li><a href="https://draveness.me/kubernetes-service/" target="_blank" rel="external nofollow noopener noreferrer">https://draveness.me/kubernetes-service/</a></li>
<li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>k8s</tag>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>【Service Mesh】Istio 入门</title>
    <url>/posts/22cae0b8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p>
<a id="more"></a>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>微服务应用最大的痛点就是处理服务间的通信，而这一问题的核心其实就是流量管理。首先我们来看看传统的微服务应用在没有 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#service-mesh" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh</a> 介入的情况下，是如何完成诸如金丝雀发布这样的路由功能的。我们假设不借助任何现成的第三方框架，一个最简单的实现方法，就是在服务间添加一个负载均衡（比如 Nginx）做代理，通过修改配置的权重来分配流量。这种方式使得对流量的管理和基础设施绑定在了一起，难以维护。</p>
<p>而使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 就可以轻松的实现各种维度的流量控制。下图是典型的金丝雀发布策略：根据权重把 5% 的流量路由给新版本，如果服务正常，再逐渐转移更多的流量到新版本。</p>
<p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的流量控制功能主要分为三个方面：</p>
<ul>
<li>请求路由和流量转移</li>
<li>弹性功能，包括熔断、超时、重试</li>
<li>调试能力，包括故障注入和流量镜像</li>
</ul>
<p>关于流量控制的更多内容，参考 <a href="../151719f0">Istio流量控制</a></p>
<h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>安全对于微服务这样的分布式系统来说至关重要。与单体应用在进程内进行通信不同，网络成为了服务间通信的纽带，这使得它对安全有了更迫切的需求。比如为了抵御外来攻击，我们需要对流量进行加密；为保证服务间通信的可靠性，需要使用mTLS的方式进行交互；为控制不同身份的访问，需要设置不同粒度的授权策略。作为一个服务网格，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 提供了一整套完整的安全解决方案。它可以以透明的方式，为我们的微服务应用添加安全策略。</p>
<p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的安全架构是由多个组件协同完成的。Citadel 是负责安全的主要组件，用于密钥和证书的管理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 会将安全策略配置分发给 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 代理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 执行安全策略来实现访问控制。下图展示了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的安全架构和运作流程。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-secure-arch.svg"></p>
<p>关于安全管理的更多内容，参考 <a href="../">Istio安全管理</a></p>
<h3 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h3><p>面对复杂的应用环境和不断扩展的业务需求，即使再完备的测试也难以覆盖所有场景，无法保证服务不会出现故障。正因为如此，才需要“可观察性”来对服务的运行时状态进行监控、上报、分析，以提高服务可靠性。具有可观察性的系统，可以在服务出现故障时大大降低问题定位的难度，甚至可以在出现问题之前及时发现问题以降低风险。具体来说，可观察性可以：</p>
<ul>
<li>及时反馈异常或者风险使得开发人员可以及时关注、修复和解决问题（告警）；</li>
<li>出现问题时，能够帮助快速定位问题根源并解决问题，以减少服务损失（减损）；</li>
<li>收集并分析数据，以帮助开发人员不断调整和改善服务（持续优化）。</li>
</ul>
<p>而在微服务治理之中，随着服务数量大大增加，服务拓扑不断复杂化，可观察性更是至关重要。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 自然也不可能缺少对可观察性的支持。它会为所有的服务间通信生成详细的遥测数据，使得网格中每个服务请求都可以被观察和跟踪。开发人员可以凭此定位故障，维护和优化相关服务。而且，这一特性的引入无需侵入被观察的服务。</p>
<p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 一共提供了三种不同类型的数据从不同的角度支撑起其可观察性：</p>
<ul>
<li>指标（Metrics）</li>
<li>日志（Access Logs）</li>
<li>分布式追踪（Distributed Traces）</li>
</ul>
<p>关于可观测行的更多内容，参考 <a href="../">Istio可观测性</a></p>
<h2 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h2><p>Istio的架构由<strong>控制平面</strong>和<strong>数据平面</strong>两个部分组成。</p>
<ul>
<li>数据平面：由整个网格内的sidecar代理组成，每个sidecar代理会接管流入和流出服务的流量，并配合控制平面完成流量控制等方面的内容。</li>
<li>控制平面：负责控制和管理数据平面的sidecar代理，完成配置的分发、服务发现和授权鉴权等功能。</li>
</ul>
<p>控制平面是 Istio 在原有服务网格产品上，首次提出的架构，实现了对于数据平面的统一管理。</p>
<p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p>
<h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><h4 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h4><p><code>Pilot</code> 组件的主要功能是将路由规则等配置信息转换为 sidecar 可以识别的信息，并下发给数据平面。可以把它简单的理解为是一个<strong>配置分发器</strong>（dispatcher），并辅助 sidecar 完成流量控制相关的功能。它管理sidecar代理之间的路由流量规则，并配置故障恢复功能，如超时、重试和熔断。</p>
<p><img alt="Istio Pilot Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot-arch.svg"></p>
<p>上图显示了Pilot的基本架构，它主要由以下几个部分组成：</p>
<h5 id="Abstract-Model"><a href="#Abstract-Model" class="headerlink" title="Abstract Model"></a>Abstract Model</h5><p>为了实现对不同服务注册中心 （Kubernetes、consul） 的支持，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 需要对不同的输入来源的数据有一个统一的存储格式，也就是抽象模型。抽象模型中定义的关键成员包括 HostName（Service名称）、Ports（Service端口）、Address（Service ClusterIP）、Resolution （负载均衡策略） 等。</p>
<h5 id="Platform-Adapters"><a href="#Platform-Adapters" class="headerlink" title="Platform Adapters"></a>Platform Adapters</h5><p>借助平台适配器 Pilot 可以实现服务注册中心数据到抽象模型之间的数据转换。例如 Pilot 中的 Kubernetes 适配器通过 Kubernetes API 服务器得到 Kubernetes 中 Service 和 Pod 的相关信息，然后翻译为抽象模型提供给 Pilot 使用。通过平台适配器模式，Pilot 还可以从 Consul 等平台中获取服务信息，还可以开发适配器将其他提供服务发现的组件集成到 Pilot 中。</p>
<h5 id="xDS-API"><a href="#xDS-API" class="headerlink" title="xDS API"></a>xDS API</h5><p>Pilot 使用了一套起源于 Envoy 项目的标准数据面 API 来将服务信息和流量规则下发到数据面的 sidecar 中。这套标准数据面 API，也叫 xDS。Sidecar 通过 xDS API 可以动态获取 Listener （监听器）、Route （路由）、<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#cluster" target="_blank" rel="external nofollow noopener noreferrer">Cluster</a> （集群）及 Endpoint （集群成员）配置：</p>
<ul>
<li>LDS，Listener 发现服务：Listener 监听器控制 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 启动端口监听（目前只支持 TCP 协议），并配置 L3/L4 层过滤器，当网络连接达到后，配置好的网络过滤器堆栈开始处理后续事件。</li>
<li>RDS，Router 发现服务：用于 HTTP 连接管理过滤器动态获取路由配置，路由配置包含 HTTP 头部修改（增加、删除 HTTP 头部键值），virtual hosts （虚拟主机），以及 virtual hosts 定义的各个路由条目。</li>
<li>CDS，Cluster发现服务：用于动态获取 Cluster 信息。</li>
<li>EDS，Endpoint 发现服务：用于动态维护端点信息，端点信息中还包括负载均衡权重、金丝雀状态等，基于这些信息，Sidecar 可以做出智能的负载均衡决策。</li>
</ul>
<h5 id="User-API"><a href="#User-API" class="headerlink" title="User API"></a>User API</h5><p>Pilot 还定义了一套用户 API， 用户 API 提供了面向业务的高层抽象，可以被运维人员理解和使用。</p>
<p>运维人员使用该 API 定义流量规则并下发到 Pilot，这些规则被 Pilot 翻译成数据面的配置，再通过标准数据面 API 分发到 sidecar 实例，可以在运行期对微服务的流量进行控制和调整。</p>
<p>通过运用不同的流量规则，可以对网格中微服务进行精细化的流量控制，如按版本分流、断路器、故障注入、灰度发布等。</p>
<p>关于 Pilot 的具体实现，可以参考 <a href="../">Istio Pilot 模块分析</a></p>
<h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><p><code>Citadel</code> 是 Istio 中专门负责安全的组件，内置有身份和证书管理功能，可以实现较为强大的授权和认证等操作，在1.5 版本之后取消了独立进程，作为一个模块被整合在 istiod 中。</p>
<p>总体来说，Istio 在安全架构方面主要包括以下内容：</p>
<ul>
<li>证书签发机构（CA）负责密钥和证书管理</li>
<li>API 服务器将安全配置分发给数据平面</li>
<li>客户端、服务端通过代理安全通信</li>
<li>Envoy 代理管理遥测和审计</li>
</ul>
<p>Istio 的身份标识模型使用一级服务标识来确定请求的来源，它可以灵活的标识终端用户、工作负载等。在平台层面，Istio 可以使用类似于服务名称来标识身份，或直接使用平台提供的服务标识。比如 Kubernetes 的 ServiceAccount，AWS IAM 用户、角色账户等。</p>
<p>在身份和证书管理方面，Istio 使用 X.509 证书，并支持密钥和证书的自动轮换。从 1.1 版本开始，Istio 开始支持安全发现服务器（SDS），随着不断的完善和增强，1.5 版本 SDS 已经成为默认开启的组件。Citadel 以前有两个功能：将证书以 Secret 的方式挂载到命名空间里；通过 SDS gRPC 接口与 nodeagent（已废弃）通信。目前 Citadel 只需要完成与 SDS 相关的工作，其他功能被移动到了 istiod 中。</p>
<p>关于Citadel的更多内容，参考 <a href="../">Istio安全管理</a></p>
<h4 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h4><p><code>Galley</code> 是 Istio 1.1 版本中新增加的组件，其目的是将 <code>Pilot</code> 和底层平台（如 Kubernetes）进行解耦。它分担了原本 <code>Pilot</code> 的一部分功能，主要负责配置的验证、提取和处理等功能。</p>
<h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><p>Istio 数据平面核心是以 sidecar 模式运行的智能代理。Sidecar 模式将数据平面核心组件部署到单独的流程或容器中，以提供隔离和封装。Sidecar 应用与父应用程序共享相同的生命周期，与父应用程序一起创建和退出。Sidecar 应用附加到父应用程序，并为应用程序提供额外的特性支持。</p>
<p>如下图所示，数据平面的 sidecar 代理可以调节和控制微服务之间所有的网络通信，每个服务 Pod 启动时会伴随启动 <code>istio-init</code> 和 proxy 容器。 </p>
<ul>
<li><code>istio-init</code> 容器主要功能是初始化 Pod 网络和对 Pod设置 iptable 规则，设置完成后自动结束。</li>
<li>Proxy 容器会启动两个服务：<code>istio-agent</code> 以及网络代理组件<ul>
<li><code>istio-agent</code>  的作用是同步管理数据，启动并管理网络代理服务进程，上报遥测数据</li>
<li>网络代理组件则根据管理策略完成流量管控、生成遥测数据。</li>
</ul>
</li>
</ul>
<p>数据平面真正触及到对网络数据包的相关操作，是上层控制平面策略的具体执行者。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-data-plane-arch.png"></p>
<p>Envoy 是 Istio 中默认的数据平面 Sidecar 代理，关于 Sidecar 是如何实现自动注入和流量劫持，以及Sidecar的流量路由机制如何实现，更多可参考 <a href="../">Envoy系列文章</a> 。</p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>这里介绍在 Kubernetes 环境下安装 Istio，在开始之前，你需要有一个 Kubernetes 运行环境。</p>
<p>从 Istio v1.7 版本开始，Istio官方推荐使用 istioctl 安装。下面是安装步骤：</p>
<ul>
<li>在 <a href="https://github.com/istio/istio/releases" target="_blank" rel="external nofollow noopener noreferrer">Istio release</a> 页面下载与操作系统匹配的安装包，并将其解压。这里可以直接用Istio提供的脚本：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/istio/istio/release-1.7/release/downloadIstioCandidate.sh | sh -</span><br><span class="line">$  [root@VM-1-28-centos istio]<span class="comment"># ls </span></span><br><span class="line">istio-1.7.0  istio-1.7.0-linux-amd64.tar.gz</span><br><span class="line">$ [root@VM-1-28-centos istio]<span class="built_in">cd</span> istio-1.7.0</span><br><span class="line">$ [root@VM-1-28-centos istio-1.7.0]<span class="comment"># tree -L 2</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── istioctl</span><br><span class="line">├── LICENSE</span><br><span class="line">├── manifests</span><br><span class="line">│   ├── charts</span><br><span class="line">│   ├── deploy</span><br><span class="line">│   ├── examples</span><br><span class="line">│   └── profiles</span><br><span class="line">├── manifest.yaml</span><br><span class="line">├── README.md</span><br><span class="line">├── samples</span><br><span class="line">│   ├── addons</span><br><span class="line">│   ├── bookinfo</span><br><span class="line">│   ├── certs</span><br><span class="line">│   ├── cross-network-gateway</span><br><span class="line">│   ├── custom-bootstrap</span><br><span class="line">│   ├── external</span><br><span class="line">│   ├── fortio</span><br><span class="line">│   ├── health-check</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   ├── httpbin</span><br><span class="line">│   ├── https</span><br><span class="line">│   ├── kubernetes-blog</span><br><span class="line">│   ├── operator</span><br><span class="line">│   ├── rawvm</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── security</span><br><span class="line">│   ├── sleep</span><br><span class="line">│   ├── tcp-echo</span><br><span class="line">│   └── websockets</span><br><span class="line">└── tools</span><br><span class="line">    ├── certs</span><br><span class="line">    ├── convert_RbacConfig_to_ClusterRbacConfig.sh</span><br><span class="line">    ├── dump_kubernetes.sh</span><br><span class="line">    ├── _istioctl</span><br><span class="line">    └── istioctl.bash</span><br><span class="line"></span><br><span class="line">27 directories, 9 files</span><br></pre></td></tr></table></figure>
<p>安装目录内容： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>包含内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bin</code></td>
<td>包含 istioctl 的客户端文件</td>
</tr>
<tr>
<td><code>manifests</code></td>
<td>包含 各种部署的 manifests</td>
</tr>
<tr>
<td><code>samples</code></td>
<td>包含示例应用程序</td>
</tr>
<tr>
<td><code>tools</code></td>
<td>包含用于性能测试和在本地机器上进行测试的脚本</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>将<code>istioctl</code>客户端路径加入 <code>$PATH</code> 中，从而可以使用 istioctl 命令行工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(<span class="built_in">pwd</span>)/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 <code>demo</code> 配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo</span><br><span class="line">✔ Istio core installed</span><br><span class="line">✔ Istiod installed</span><br><span class="line">✔ Egress gateways installed</span><br><span class="line">✔ Ingress gateways installed</span><br><span class="line">✔ Installation complete</span><br></pre></td></tr></table></figure>
<ul>
<li>添加一个Namespace Label，使得之后在部署你的应用的时候，istio会自动注入Envoy sidecar 代理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl label namespace default istio-injection=enabled</span><br></pre></td></tr></table></figure>
<h3 id="部署-Bookinfo"><a href="#部署-Bookinfo" class="headerlink" title="部署 Bookinfo"></a>部署 Bookinfo</h3><p>Bookinfo 是 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 社区官方推荐的示例应用之一。它可以用来演示多种 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的特性，并且它是一个异构的微服务应用。该应用由四个单独的微服务构成。 这个应用模仿了在线书店，可以展示书店中书籍的信息。例如页面上会显示一本书的描述，书籍的细节（ ISBN、页数等），以及关于这本书的一些评论。</p>
<p>Bookinfo 应用分为四个单独的微服务， 这些服务对 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个不同语言编写的服务构成，并且其中有一个应用会包含多个版本。</p>
<ul>
<li><code>productpage</code> 会调用 <code>details</code> 和 <code>reviews</code> 两个微服务，用来生成页面。</li>
<li><code>details</code> 中包含了书籍的信息。</li>
<li><code>reviews</code> 中包含了书籍相关的评论。它还会调用 <code>ratings</code> 微服务。</li>
<li><code>ratings</code> 中包含了由书籍评价组成的评级信息。</li>
</ul>
<p><code>reviews</code> 微服务有 3 个版本，可用来展示各服务之间的不同的调用链路：</p>
<ul>
<li>v1 版本不会调用 <code>ratings</code> 服务。</li>
<li>v2 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li>
<li>v3 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li>
</ul>
<p>下图展示了这个应用的端到端架构：</p>
<p><img alt="Bookinfo Application without Istio" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo-noistio.svg"></p>
<ul>
<li>部署示例应用程序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details unchanged</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings unchanged</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews unchanged</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage unchanged</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure>
<ul>
<li>之后应用起来，当每个Pod状态变为Ready的时候，sidecar也部署成功。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   172.18.252.45    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">kubernetes    ClusterIP   172.18.252.1     &lt;none&gt;        443/TCP    51d</span><br><span class="line">productpage   ClusterIP   172.18.253.238   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">ratings       ClusterIP   172.18.254.131   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">reviews       ClusterIP   172.18.255.63    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5974b67c8-z67st        2/2     Running   0          2m8s</span><br><span class="line">productpage-v1-797898bc54-frzdz   2/2     Running   0          2m8s</span><br><span class="line">ratings-v1-c6cdf8d98-xmhz8        2/2     Running   0          2m8s</span><br><span class="line">reviews-v1-8bdc65f7b-mjktx        2/2     Running   0          2m8s</span><br><span class="line">reviews-v2-868d77d678-4dzmn       2/2     Running   0          2m8s</span><br><span class="line">reviews-v3-6c9b646cb4-5tp9q       2/2     Running   0          2m8s</span><br></pre></td></tr></table></figure>
<ul>
<li>查看应用是否成功运行，通过给productpage发送请求，查看其返回</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> <span class="string">"<span class="variable">$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')</span>"</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">"&lt;title&gt;.*&lt;/title&gt;"</span></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure>
<h3 id="集群外部访问应用"><a href="#集群外部访问应用" class="headerlink" title="集群外部访问应用"></a>集群外部访问应用</h3><p>到现在，Bookinfo 应用已经成功部署，我们在集群内部也已经可以访问，但是在集群外部还不能够访问。为了使得外部能够访问应用程序，我们需要创建一个<a href="https://istio.io/latest/docs/concepts/traffic-management/#gateways" target="_blank" rel="external nofollow noopener noreferrer">Istio Ingress Gateway</a>。</p>
<ul>
<li>将应用于istio gateway关联</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure>
<ul>
<li>确保配置上没有问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl analyze</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure>
<ul>
<li>确定Ingress的IP和Ports</li>
</ul>
<p>通过下面的命令来设置 <code>INGRESS_HOST</code> 和 <code>INGRESS_PORT</code>环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   172.18.252.12   49.233.242.233   15021:32663/TCP,80:31968/TCP,443:31588/TCP,31400:32002/TCP,15443:30652/TCP   18m</span><br></pre></td></tr></table></figure>
<p>这里显示 <code>EXTERNAL_IP</code> 已经变设置，表明当前环境下有一个可以使用的外部负载均衡器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="http2")].port&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="https")].port&#125;'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>设定GATEWAY_URL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GATEWAY_URL</span></span><br><span class="line">49.233.242.233:80</span><br></pre></td></tr></table></figure>
<ul>
<li>确认外部访问是否成功：在浏览器直接访问 <code>http://&lt;GATE_WAYURL&gt;/productpage</code> 来访问Bookinfo应用</li>
</ul>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-external-access.png"></p>
<h3 id="查看Dashboard"><a href="#查看Dashboard" class="headerlink" title="查看Dashboard"></a>查看Dashboard</h3><p>Istio集成了 <a href="https://istio.io/latest/docs/ops/integrations/" target="_blank" rel="external nofollow noopener noreferrer">一些</a> 遥测应用，他们可以帮助你对你的服务网格有直观的认识、展示网格的拓扑、分析网格的健康状态</p>
<ul>
<li>安装Kiali </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f samples/addons</span><br><span class="line">$ <span class="keyword">while</span> ! kubectl <span class="built_in">wait</span> --<span class="keyword">for</span>=condition=available --timeout=600s deployment/kiali -n istio-system; <span class="keyword">do</span> sleep 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li>访问Kiali</li>
</ul>
<p>官方教程指示使用 <code>istioctl dashboard kiali</code> 命令来打开浏览器访问 Kiali服务，但是我的 Kubernetes 集群在服务器上，这样显然不行，不要将 Kiali 服务暴露给外部。因为之前集群已经安装了 Traefik ，所以可以使用 Ingress来暴露。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kiali</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/kiali</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kiali</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">20001</span></span><br></pre></td></tr></table></figure>
<p>在命令行创建Ingress，打开浏览器访问 <code>http://&lt;NodeIP&gt;:&lt;TraefikWebNodePort&gt;/kiali</code> 即可访问Kiali</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-kiali.png"></p>
<p>在左侧导航栏点击Graph，选择default的命名空间，可以看到 <code>Bookinfo</code> 应用中各个服务间的关系：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-kiali.png"></p>
<p>到此为止，你的Istio和相关的服务已经在集群中完好的部署，关于其具体功能演示，参照 <a href="../151719f0">Istio流量控制</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://istio.io/latest/docs/setup/getting-started" target="_blank" rel="external nofollow noopener noreferrer">https://istio.io/latest/docs/setup/getting-started</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>istio</tag>
        <tag>service mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>【Service Mesh】开篇</title>
    <url>/posts/ac3e3d15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>Service Mesh 是一个<strong>基础设施层</strong>，用于处理<strong>服务到服务间</strong>的网络通信。<strong>云原生应用</strong>有着复杂的服务拓扑，Service Mesh负责在这些<strong>网络拓扑中实现请求的可靠传递</strong>。在实践中，Service Mesh通常实现为一组轻量级的<strong>网络代理</strong>，它们与应用程序部署在一起，但是<strong>对应用保持透明</strong>。</p>
</blockquote>
<p>本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。</p>
<a id="more"></a>
<h2 id="历史演进"><a href="#历史演进" class="headerlink" title="历史演进"></a>历史演进</h2><p>随着行业需求的推动，互联网服务从最早的仅有少数几台的大型服务器演变到成百上千的小型服务，服务架构也从最早期的单体式（Monolithic）到分布式（Distributed），再到微服务（Microservices）、容器化（Containerization）、容器编排（Container Orchestration），最后到服务网格（Service Mesh）、无服务器（Serverless）。</p>
<p>总结分布式系统的演进过程，我们可以看到一种通用的发展规律：</p>
<ul>
<li>首先是对每种情况提出临时解决方案</li>
<li>然后是更复杂的解决方案，类似于 library 以实现统一复用</li>
<li>随着对问题有更多的了解，开始将这些解决方案落实到 platform</li>
</ul>
<p>接下来我们会回顾从早期TCP/IP协议栈的广泛应用，到微服务时代从容器编排到服务网格的演进过程，并再次体会上述规律。</p>
<h3 id="计算机网络系统的演进"><a href="#计算机网络系统的演进" class="headerlink" title="计算机网络系统的演进"></a>计算机网络系统的演进</h3><p>从多台计算机开始通信以来，服务间通信是应用最为广泛的模式。以下图为例，ServiceA 和 ServiceB 可以是我们提供应用的服务端与客户端。在开发者开发这些服务的时候，需要借助底层的网络硬件和协议进行通信。这张图只是一个简化的师徒，省略了在代码操作的数据和通过线路发送接收的电信号之间转换的很多层。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc.png"></p>
<p>更加具体一点，把底层的网络协议栈加入，我们会看到下图：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc-stack.png"></p>
<p>从上世纪50年代起，上述的模型就一直在使用。最开始，由于计算机系统规模相对较小，每个节点之间的链路协议都是经过专门设计和维护的。随着计算机规模的迅速扩大，很多个小的网络系统开始连接起来。在这个过程中，不同主机间如何找到彼此，跨网络间如何路由转发，如何实现流量控制等问题，成了摆在网络系统设计人员面前亟需解决的难题。</p>
<p>为了实现各个网络节点的路由转发，屏蔽链路层协议，人们发明了IP网络协议。然而，IP网络协议还不能够解决流量控制的问题。这里的流量控制，值得是防止一台服务器发送过多的数据包，超出下游服务器的处理能力。在最开始，编写网络服务和应用程序的开发者来负责处理上述流量控制的问题。这就意味着在编写应用程序过程中，网络处理的逻辑和应用自身的业务逻辑被耦合在一起，如下图所示。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-flow-control.png"></p>
<p>然而，这种每个开发人员都要去考虑流量处理等传输层的问题太过复杂，程序开发的成本太高。随着技术的快速发展，流量处理和其他网络问题相关的解决方案被整合到网络协议栈，TCP/IP席卷了世界，成为互联网事实上的协议标准。流量控制等网络问题的代码仍在，但是你不再需要自己去开发与维护这段代码，而是直接调用系统提供的网络协议栈。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-tcp.png"></p>
<h3 id="微服务架构的演进"><a href="#微服务架构的演进" class="headerlink" title="微服务架构的演进"></a>微服务架构的演进</h3><p>确定于上世界80年代的TCP/IP网络协议栈和通用的网络模型对于互联网的发展发挥了巨大的作用，极大了促进了互联网应用的繁荣。网络应用的功能逐渐复杂起来，人们把所有的组件都集中在一个应用当中，这即是<code>单体应用 Monolithic</code>。单体应用基于相同技术栈开发、访问共享的数据库、共同部署运维和扩容。同时，组件之间的通信也趋于频繁和耦合，所有的交互都是以函数调用的形式来实现。</p>
<p>然而，随着互联网的迅猛发展，网络应用中需要添加越来越多的功能，应用的复杂度不断提升，参与软件开发的协作人数也越来越多，单体应用开始爆发出其固有局限性。在这种背景下，微服务的思潮降临，让软件开发重新变得小而美：</p>
<ul>
<li>单⼀职责：拆分后的单个微服务，通常只负责单个高内聚自闭环功能，因此很易于开发、理解和维护。</li>
<li>架构灵活：不同微服务应用之间在技术选型层面几乎是独立的，可以⾃由选择最适合的技术栈。</li>
<li>部署隔离：相比巨无霸单体应用，单个微服务应用的代码和产物体积大大减少，更容易持续集成和快速部署；同时，通过进程级别的隔离，也不再像单体应用一样只能同生共死，故障隔离效果显著提升。</li>
<li>独⽴扩展：单体应用时代，某个模块如果存在资源瓶颈（e.g. CPU/内存），只能跟随整个应用一起扩容，白白浪费很多资源。微服务化后，扩展的粒度细化到了微服务级别，可以更精确地按需独立扩展。</li>
</ul>
<p>然而，微服务也不是银弹，在微服务落地的过程中，也产生了很多的问题，其中主要的问题就是服务间通信：</p>
<ul>
<li><p><strong>如何找到服务的提供⽅？</strong></p>
<p>微服务通讯必须走远程过程调用（HTTP/REST本质上也属于RPC），当其中一个应用需要消费另一个应用的服务时，无法再像单体应用一样通过简单的进程内机制（e.g. Spring的依赖注入）就能获取到服务实例；你甚至都不知道有没有这个服务方。</p>
</li>
<li><p><strong>如何保证远程调⽤的可靠性?</strong></p>
<p>既然是RPC，那必然要走IP网络，而我们都知道网络（相比计算和存储）是软件世界里最不可靠的东西。虽然有TCP这种可靠传输协议，但频繁丢包、交换机故障甚至电缆被挖断也常有发生；即使网络是好的，如果对方机器宕机了，或者进程负载过高不响应呢？</p>
</li>
<li><p><strong>如何降低服务调⽤的延迟？</strong></p>
<p>网络不只是不可靠，还有延迟的问题。虽然相同系统内的微服务应用通常都部署在一起，同机房内调用延迟很小；但对于较复杂的业务链路，很可能一次业务访问就会包括数十次RPC调用，累积起来的延迟就很可观了。</p>
</li>
<li><p><strong>如何保证服务调⽤的安全性？</strong></p>
<p>网络不只是不可靠和有延迟，还是不安全的。互联网时代，你永远不知道屏幕对面坐的是人还是狗；同样，微服务间通讯时，如果直接走裸的通讯协议，你也永远不知道对端是否真的就是自己人，或者传输的机密信息是否有被中间人偷听。</p>
</li>
</ul>
<h4 id="服务通信：耦合业务逻辑"><a href="#服务通信：耦合业务逻辑" class="headerlink" title="服务通信：耦合业务逻辑"></a>服务通信：耦合业务逻辑</h4><p>就像历史总是会重演，为了解决上述微服务引入的问题，最早需要工程师独立去完成对应的服务，在业务逻辑中实现下列逻辑：</p>
<ul>
<li>服务发现（Service Discovery）：解决“我想调用你，如何找到你”的问题。</li>
<li>服务熔断（Circuit Breaker）：缓解服务之间依赖的不可靠问题。</li>
<li>负载均衡（Load Balancing）：通过均匀分配流量，让请求处理更加及时。</li>
<li>安全通讯：包括协议加密（TLS）、身份认证（证书/签名）、访问鉴权（RBAC）等</li>
</ul>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service.png"></p>
<p>然而，随着分布式程度的增加，这些服务的复杂度也越来越高，一些问题不得不考虑：</p>
<ul>
<li>重复造轮子：需要编写和维护⼤量非功能性代码，如何集中精力专注业务创新?</li>
<li>与业务耦合：服务通讯逻辑与业务代码逻辑混在一起，动不动还会遇到点匪夷所思的分布式bug。</li>
</ul>
<h4 id="服务通信：独立Library"><a href="#服务通信：独立Library" class="headerlink" title="服务通信：独立Library"></a>服务通信：独立Library</h4><p>为了解决重复造轮子的问题，集成了服务通信中各种问题的Library开始变得十分流行，包括 Apache Dubbo（手动置顶）、Spring Cloud、Netflix OSS、gRPC 等等。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service-lib.png"></p>
<p>这些可复用的类库和框架，确确实实带来了质量和效率上的大幅提升，但是也存在着下列问题：</p>
<ul>
<li>并非完全透明：程序员们仍然需要正确理解和使⽤这些库，上手成本和出错概率依然很高。</li>
<li>限制技术选择：使用这些技术后，应用很容易就会被对应的语⾔和框架强绑定（vendor-lock）。</li>
<li>维护成本高：库版本升级，需要牵连应⽤一起重新构建和部署；麻烦不说，还要祈祷别出故障。</li>
</ul>
<h4 id="服务通信：Sidecar"><a href="#服务通信：Sidecar" class="headerlink" title="服务通信：Sidecar"></a>服务通信：Sidecar</h4><p>像网络协议栈发展的过程一样，将大规模分布式服务所需要的功能剥离出来集成到底层平台是一个众望所归的选择。人们通过应用层的协议(例如HTTP)写出了很多复杂的应用程序和服务，甚至不用考虑TCP是如何控制数据包在网络上传输的。这就是我们微服务所需要的，从事服务开发的工程师们可以专注于业务逻辑的开发，避免浪费时间去编写服务基础设施代码或者管理这些库和框架。</p>
<p>在这个想法下，我们可以得到类似于如下的图：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-protocol.png"></p>
<p>不幸的是，更改协议栈来增加微服务的功能不是一个可行的方案，许多开发者是通过一组代理来实现此功能。这里的设计思想是<strong>服务不需要和下游服务直连，所有的流量都通过该代理透明的来实现对应的功能</strong>。这里的透明代理，通过一种叫做 <code>Sidecar</code> 的模式来运行，Sidecar将上述类库和框架要干的事情从应用中彻底剥离了出来，并统一下沉到了基础设施层，这其中的典型代表就是 Linkerd 和 Envoy。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-sidecar.png"></p>
<h4 id="服务通信：Service-Mesh"><a href="#服务通信：Service-Mesh" class="headerlink" title="服务通信：Service Mesh"></a>服务通信：Service Mesh</h4><p>在这种模型中，每个服务都会有一个配套的代理SideCar。考虑到服务之间的通信仅仅通过SideCar代理，我们最终得到如下的部署图：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data.png"></p>
<p>Buoyant的CEO William Morgan ，发现了各个SideCar代理之间互联组成了一个网状网络，<strong>2017初，William为这个网状的平台起了一个<a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/" target="_blank" rel="external nofollow noopener noreferrer">“Service Mesh”的定义</a></strong>。</p>
<blockquote>
<p>Service Mesh是一个用于服务和服务之间通信的专用基础设施层。它负责服务请求能够在复杂的服务拓扑(组成了云原生应用)中可靠的进行投递。在实践中，Serivce Mesh的典型实现是作为轻量级网络代理阵列，部署在应用程序旁边，不需要业务进程感知到。</p>
</blockquote>
<p>William关于Service Mesh的定义中，最有说服力的一点是，他不再将SideCar代理视为一个独立组件，而是承认了<strong>它们组成的网络像它们自身一样是有价值的</strong></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data2.png"></p>
<p>随着很多公司将它们的微服务部署到更复杂的系统运行环境中，例如Kubernetes和Mesos，人们开始使用这些平台提供的工具来实现合适的Serivce Mesh的想法。它们将独立的SideCar代理从独立的工作环境中转移到一个适当的，有集中的控制面。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control.png"></p>
<p>看下我们的鸟瞰图，服务之间的流量仍然是通过SideCar代理来进行转发，但是控制平面知道每个SideCar实例。控制平面能够让代理实现例如访问控制，指标收集等需要协作完成的事情。Istio是这个模型的典型实现。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control2.png"> </p>
<h2 id="主流实现"><a href="#主流实现" class="headerlink" title="主流实现"></a>主流实现</h2><p>Service Mesh 的主流实现包括：</p>
<ul>
<li>Linkerd：背后公司是Buoyant，开发语⾔使用Scala，2016年1⽉15日初次发布，2017年1⽉23日加入CNCF。</li>
<li>Envoy：背后公司是Lyft，开发语言使用C++ 11，2016年9月13日初次发布，2017年9⽉14日加⼊CNCF。</li>
<li>Istio：背后公司是Google和IBM，开发语言使用Go，2017年5⽉月10日初次发布。</li>
<li>Conduit：背后公司也是Buoyant，开发语言使用Rust和Go，2017年12月5日初次发布，现在已经加入了 <code>Linkerd</code> 项目。</li>
</ul>
<h3 id="Linkerd"><a href="#Linkerd" class="headerlink" title="Linkerd"></a>Linkerd</h3><p>现在（2020.09.08） <code>Linkerd</code> 已经发展到 2.8 版本，由控制面和数据面组成，详情可以参考 <a href="https://linkerd.io/2/reference/architecture/" target="_blank" rel="external nofollow noopener noreferrer">这里</a></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_linkerd-control-plane.png"></p>
<h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p>Envoy是一个高性能的Service Mesh软件，现在主要被用于数据面作为 Sidecar 代理，详情可以参考 <a href="../7beb34d2/">这里</a></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p>
<h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Istio是第二代 Service Mesh，第一次提出控制面的概念，详情可以参考 <a href="../22cae0b8/">这里</a></p>
<p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p>
<h3 id="NginMesh"><a href="#NginMesh" class="headerlink" title="NginMesh"></a>NginMesh</h3><p>Service Mesh 最基础的功能毕竟是 sidecar proxy. 提到 proxy 怎么能够少了 nginx? 我想nginx自己也是这么想的吧 毫不意外，nginx也推出了其 service mesh 的开源实现：nginMesh.</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_nginx-sidecar.png"></p>
<p>不过，与 William Morgan 的死磕策略不同，nginMesh 从一开始就没有想过要做一套完整的第二代Service Mesh 开源方案，而是直接宣布兼容Istio, 作为Istio的 sidecar proxy. 由于 nginx 在反向代理方面广泛的使用，以及运维技术的相对成熟，nginMesh在sidecar proxy领域应该会有一席之地。</p>
<h2 id="对比Kubernetes原生架构"><a href="#对比Kubernetes原生架构" class="headerlink" title="对比Kubernetes原生架构"></a>对比Kubernetes原生架构</h2><h3 id="Kube-proxy-vs-Sidecar"><a href="#Kube-proxy-vs-Sidecar" class="headerlink" title="Kube-proxy vs Sidecar"></a>Kube-proxy vs Sidecar</h3><p>下图展示的是 Kubernetes 与 Service Mesh 中的的服务访问关系：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_k8s-vs-service-mesh.png"></p>
<ul>
<li>Kubernetes 集群的每个节点都部署了一个 <code>kube-proxy</code> 组件，该组件会与 Kubernetes API Server 通信，获取集群中的 <code>Service</code> 信息，然后设置 iptables 规则，直接将对某个 <code>Service</code> 的请求发送到对应的 Endpoint（属于同一组 <code>Service</code> 的 <code>Pod</code>）上。</li>
<li>Kube-proxy 实现了流量在 Kubernetes <code>Service</code> 多个 <code>Pod</code> 实例间的负载均衡，但是如何对这些 <code>Service</code> 间的流量做细粒度的控制，比如按照百分比划分流量到不同的应用版本（这些应用都属于同一个 <code>Service</code>，但位于不同的 deployment 上），做金丝雀发布（灰度发布）和蓝绿发布？Kubernetes 社区给出了 <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="external nofollow noopener noreferrer">使用 Deployment 做金丝雀发布的方法</a>，该方法本质上就是通过修改 <code>Pod</code> 的 label 来将不同的 <code>Pod</code> 划归到 Deployment 的 <code>Service</code> 上。</li>
</ul>
<p><code>kube-proxy</code> 的设置都是全局生效的，无法对每个服务做细粒度的控制，而 <code>Service Mesh</code> 通过 <code>Sidecar</code> proxy 的方式将 Kubernetes 中对流量的控制从 <code>Service</code> 一层抽离出来，可以做更多的扩展。</p>
<h3 id="Ingress-vs-Gateway"><a href="#Ingress-vs-Gateway" class="headerlink" title="Ingress vs Gateway"></a>Ingress vs Gateway</h3><p> <code>kube-proxy</code> 只能路由 Kubernetes 集群内部的流量，而我们知道 Kubernetes 集群的 <code>Pod</code> 位于 CNI 创建的外网络中，集群外部是无法直接与其通信的，因此 Kubernetes 中创建了 Ingress 这个资源对象，它由位于 Kubernetes 边缘节点（这样的节点可以是很多个也可以是一组）的 Ingress controller 驱动，负责管理 <strong>南北向流量</strong>，Ingress 必须对接各种 Ingress Controller 才能使用，比如 <a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>、<a href="https://traefik.io/" target="_blank" rel="external nofollow noopener noreferrer">traefik</a>。</p>
<ul>
<li>Ingress 只适用于 HTTP 流量，使用方式也很简单，只能对 <code>Service</code>、port、HTTP 路径等有限字段匹配来路由流量，这导致它无法路由如 MySQL、Redis 和各种私有 RPC 等 TCP 流量。</li>
<li>要想直接路由南北向的流量，只能使用 <code>Service</code> 的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要进行额外的端口管理。</li>
<li>有些 Ingress controller 支持暴露 TCP 和 UDP 服务，但是只能使用 <code>Service</code> 来暴露，Ingress 本身是不支持的，例如 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>，服务暴露的端口是通过创建 ConfigMap 的方式来配置的。</li>
</ul>
<p><code>Istio</code> Gateway 的功能与 Kubernetes Ingress 类似，都是负责集群的南北向流量。<code>Istio</code> <code>Gateway</code> 描述的负载均衡器用于承载进出网格边缘的连接。该规范中描述了一系列开放端口和这些端口所使用的协议、负载均衡的 SNI 配置等内容。Gateway 是一种 CRD 扩展，它同时复用了 <code>Sidecar</code> proxy 的能力，详细配置请参考 <a href="https://istio.io/docs/reference/config/networking/gateway/" target="_blank" rel="external nofollow noopener noreferrer">Istio 官网</a>。</p>
<h2 id="落地问题"><a href="#落地问题" class="headerlink" title="落地问题"></a>落地问题</h2><p>服务网格的出现带来的变革：</p>
<p>第一，<strong>微服务治理与业务逻辑的解耦</strong>。服务网格把 SDK 中的<strong>大部分</strong>能力从应用中剥离出来，拆解为独立进程，以 Sidecar 的模式进行部署。服务网格通过将服务通信及相关管控功能从业务程序中分离并下沉到基础设施层，使其和业务系统完全解耦，使开发人员更加专注于业务本身。</p>
<blockquote>
<p>注意，这里提到了一个词“大部分”，SDK 中往往还需要保留<strong>协议编解码</strong>的逻辑，甚至在某些场景下还需要一个轻量级的 SDK 来实现细粒度的治理与监控策略。例如，要想实现方法级别的调用链追踪，服务网格则需要业务应用实现 trace ID 的传递，而这部分实现逻辑也可以通过轻量级的 SDK 实现。因此，从代码层面来讲，服务网格并非是零侵入的。</p>
</blockquote>
<p>第二，<strong>异构系统的统一治理</strong>。随着新技术的发展和人员更替，在同一家公司中往往会出现不同语言、不同框架的应用和服务，为了能够统一管控这些服务，以往的做法是为每种语言、每种框架都开发一套完整的 SDK，维护成本非常之高，而且给公司的中间件团队带来了很大的挑战。有了服务网格之后，通过将主体的服务治理能力下沉到基础设施，多语言的支持就轻松很多了。只需要提供一个非常轻量级的 SDK，甚至很多情况下都不需要一个单独的 SDK，就可以方便地实现多语言、多协议的统一流量管控、监控等需求。</p>
<p>此外，服务网格相对于传统微服务框架，还拥有三大技术优势：</p>
<ul>
<li>可观察性。因为服务网格是一个专用的基础设施层，所有的服务间通信都要通过它，所以它在技术堆栈中处于独特的位置，以便在服务调用级别上提供统一的遥测指标。这意味着，所有服务都被监控为“黑盒”。服务网格捕获诸如来源、目的地、协议、URL、状态码、延迟、持续时间等线路数据。这本质上等同于 web 服务器日志可以提供的数据，但是服务网格可以为所有服务捕获这些数据，而不仅仅是单个服务的 web 层。需要指出的是，收集数据仅仅是解决微服务应用程序中可观察性问题的一部分。存储与分析这些数据则需要额外能力的机制的补充，然后作用于警报或实例自动伸缩等。</li>
<li>流量控制。通过 <code>Service Mesh</code>，可以为服务提供智能路由（蓝绿部署、金丝雀发布、A/B test）、超时重试、熔断、故障注入、流量镜像等各种控制能力。而以上这些往往是传统微服务框架不具备，但是对系统来说至关重要的功能。例如，服务网格承载了微服务之间的通信流量，因此可以在网格中通过规则进行故障注入，模拟部分微服务出现故障的情况，对整个应用的健壮性进行测试。由于服务网格的设计目的是有效地将来源请求调用连接到其最优目标服务实例，所以这些流量控制特性是“面向目的地的”。这正是服务网格流量控制能力的一大特点。</li>
<li>安全。在某种程度上，单体架构应用受其单地址空间的保护。然而，一旦单体架构应用被分解为多个微服务，网络就会成为一个重要的攻击面。更多的服务意味着更多的网络流量，这对黑客来说意味着更多的机会来攻击信息流。而服务网格恰恰提供了保护网络调用的能力和基础设施。服务网格的安全相关的好处主要体现在以下三个核心领域：服务的认证、服务间通讯的加密、安全相关策略的强制执行。</li>
</ul>
<p>服务网格带来了巨大变革并且拥有其强大的技术优势，被称为第二代“微服务架构”。然而就像之前说的软件开发没有银弹，传统微服务架构有许多痛点，而服务网格也不例外，也有它的局限性。</p>
<ul>
<li>增加了复杂度。服务网格将 <code>Sidecar</code> 代理和其它组件引入到已经很复杂的分布式环境中，会极大地增加整体链路和操作运维的复杂性。</li>
<li>运维人员需要更专业。在容器编排器（如 Kubernetes）上添加 <code>Istio</code> 之类的服务网格，通常需要运维人员成为这两种技术的专家，以便充分使用二者的功能以及定位环境中遇到的问题。</li>
<li>延迟。从链路层面来讲，服务网格是一种侵入性的、复杂的技术，可以为系统调用增加显著的延迟。这个延迟是毫秒级别的，但是在特殊业务场景下，这个延迟可能也是难以容忍的。</li>
<li>平台的适配。服务网格的侵入性迫使开发人员和运维人员适应高度自治的平台并遵守平台的规则。</li>
</ul>
<h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>展望未来，Kubernetes 正在爆炸式发展，它已经成为企业绿地应用的容器编排的首选。如果说 Kubernetes 已经彻底赢得了市场，并且基于 Kubernetes 的应用程序的规模和复杂性持续增加，那么就会有一个临界点，而服务网格则将是有效管理这些应用程序所必需的。随着服务网格技术的持续发展，其实现产品（如 <code>Istio</code>）的架构与功能的不断优化，服务网格将完全取代传统微服务架构，成为大小企业微服务化和上云改造的首选架构。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="external nofollow noopener noreferrer">https://philcalcado.com/2017/08/03/pattern_service_mesh.html</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>service</tag>
        <tag>service mesh</tag>
        <tag>sidecar</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes解读】Ingress</title>
    <url>/posts/8dfd4de5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Ingress 是 Kubernetes 的一种 API 对象，将集群内部的 Service 通过 HTTP/HTTPS 方式暴露到集群外部，并通过规则定义 HTTP/HTTPS 的路由。Ingress 具备如下特性：集群外部可访问的 URL、负载均衡、SSL Termination、按域名路由。</p>
<a id="more"></a>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Kubernetes 暴露服务的有三种方式：分别为 LoadBlancer Service、NodePort Service、Ingress。</p>
<p>LoadBlancer Service 是 Kubernetes 结合云平台的组件，如国外 GCE、AWS、国内阿里云等等，使用它向使用的底层云平台申请创建负载均衡器来实现，有局限性，对于使用云平台的集群比较方便，但是和云平台强绑定。</p>
<p>NodePort Service 是通过在节点上暴露端口，然后通过将端口映射到具体某个服务上来实现服务暴露，比较直观方便，但是对于集群来说，随着 Service 的不断增加，需要的端口越来越多，很容易出现端口冲突，而且不容易管理。此外，打开节点的端口，也会面临安全上的风险，生产环境并不推荐使用。</p>
<p>Ingress 作为 Kubernetes 基本API对象，是外部请求访问集群的入口，负责为进入集群的请求提供路由规则集合和转发，将外部的请求转发到集群内部Service上。相对于上述两种暴露方式，有以下特点：</p>
<ul>
<li>动态配置服务：增加新的服务时，不再需要在流量入口新增反向代理指向新的服务，只需配置好Ingress即可</li>
<li>减少不必要端口暴露：只需要将Ingress服务映射出去，即可代理所有后端服务，更加安全，便于管理端口</li>
</ul>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><h3 id="组成模块"><a href="#组成模块" class="headerlink" title="组成模块"></a>组成模块</h3><p>Ingress 通过反向代理负载均衡服务器实现对外暴露服务目的，一般有三个组件组成：</p>
<ul>
<li>反向代理负载均衡服务器<strong>：拦截外部请求，通常以 <code>Deployment</code> 或者 <code>DaemonSet</code> 的方式部署到集群中，常见的有 <code>Nginx</code>、<code>Apache</code>、<code>Traefik</code>等。</strong></li>
<li><strong>Ingress</strong>：定义路由规则，将路由配置抽象成一个 Ingress 对象。</li>
<li><strong>Ingress Controller</strong>：实时监控集群，获取 <code>Service</code> 、<code>Pod</code>和 <code>Ingress</code>等的变化，将 Ingress 的规则动态更新到反向代理负载均衡服务器上，刷新其路由配置信息，实现 <strong>服务发现</strong>。</li>
</ul>
<p><img alt="Kubernetes Ingress" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-31_k8s-ingress.png"></p>
<h3 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h3><p>下面是一个Ingress资源示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/testpath</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"foo.bar.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/bar"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"*.foo.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/foo"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>与所有其他 Kubernetes 资源一样，Ingress 需要使用 <code>apiVersion</code>、<code>kind</code> 和 <code>metadata</code> 字段。 Ingress 对象的命名必须是合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank" rel="external nofollow noopener noreferrer">DNS 子域名名称</a>。  Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器， 不同的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="external nofollow noopener noreferrer">Ingress 控制器</a> 支持不同的注解。</p>
<p>Ingress <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" target="_blank" rel="external nofollow noopener noreferrer">规约</a> 提供了配置负载均衡器或者代理服务器所需的所有信息。 最重要的是，其中包含与所有传入请求匹配的规则列表。 <strong>Ingress 资源仅支持用于转发 HTTP 流量的规则。</strong></p>
<h4 id="Ingress-Rules"><a href="#Ingress-Rules" class="headerlink" title="Ingress Rules"></a>Ingress Rules</h4><p>每个 HTTP 规则都包含以下信息：</p>
<ul>
<li>可选主机。在此示例第一个规则中，未指定主机，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了主机（例如 foo.bar.com），则规则适用于该主机。</li>
<li>路径列表（例如，<code>/testpath</code>）,每个路径都有一个由 <code>serviceName</code> 和 <code>servicePort</code> 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。</li>
<li>后端是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service 文档</a>中所述的服务和端口名称的组合。 与规则的主机和路径匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到列出的后端。</li>
</ul>
<p>通常在 Ingress 控制器中会配置默认后端，以服务任何不符合规范中路径的请求。</p>
<h4 id="DefaultBackend"><a href="#DefaultBackend" class="headerlink" title="DefaultBackend"></a>DefaultBackend</h4><p>没有规则的 Ingress 将所有流量发送到同一个默认后端。 默认后端通常是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="external nofollow noopener noreferrer">Ingress 控制器</a> 的配置选项，并且未在 Ingress 资源中指定。</p>
<p>如果主机或路径都没有与 Ingress 对象中的 HTTP 请求匹配，则流量将路由到默认后端。</p>
<h3 id="Path-Types"><a href="#Path-Types" class="headerlink" title="Path Types"></a>Path Types</h3><p>Ingress 中的每个路径都有对应的路径类型。当前支持的路径类型有三种：</p>
<ul>
<li><em><code>ImplementationSpecific</code></em> （默认）：对于这种类型，匹配取决于 IngressClass。 具体实现可以将其作为单独的 <code>pathType</code> 处理或者与 <code>Prefix</code> 或 <code>Exact</code> 类型作相同处理。</li>
<li><em><code>Exact</code></em>：精确匹配 URL 路径，且对大小写敏感。</li>
<li><em><code>Prefix</code></em>：基于以 <code>/</code> 分隔的 URL 路径前缀匹配。匹配对大小写敏感，并且对路径中的元素逐个完成。 路径元素指的是由 <code>/</code> 分隔符分隔的路径中的标签列表。 如果每个 <em>p</em> 都是请求路径 <em>p</em> 的元素前缀，则请求与路径 <em>p</em> 匹配。</li>
</ul>
<h2 id="Traefik实战"><a href="#Traefik实战" class="headerlink" title="Traefik实战"></a>Traefik实战</h2><p><code>Traefik</code>是一个用Go语言开发的轻量级的Http反向代理和<a href="https://cloud.tencent.com/product/clb?from=10680" target="_blank" rel="external nofollow noopener noreferrer">负载均衡</a>器，能够监听后端的变化并自动更新服务配置。它的特点如下：</p>
<ul>
<li>天然拥抱<code>kubernetes</code>，直接与集群k8s的<code>Api Server</code>通信，反应非常迅速，实时感知集群中<code>Ingress</code>定义的路由规则集合和后端<code>Service</code>、<code>Pod</code>的变化，自动<strong>热更新</strong><code>Traefik</code>后端配置，根本不用创建<code>Ingress controller</code>对象</li>
<li>提供了友好的控制面板和监控界面，不仅可以方便地查看<code>Traefik</code>根据<code>Ingress</code>生成的路由配置信息，还可以查看统计的一些性能指标数据</li>
<li>支持丰富的<code>annotations</code>配置，可配置众多出色的特性，例如：<strong>自动熔断</strong>、<strong>负载均衡策略</strong>、<strong>黑名单</strong>、<strong>白名单</strong></li>
<li>支持许多后端存储，如：zookeeper、eureka、consul、rancher、docker等，它会自动感知这些统一配置中心的变化，热更新自己的路由配置</li>
</ul>
<p><a href="https://www.infoq.cn/article/2glSpfgdiwG0UYz3V4tM" target="_blank" rel="external nofollow noopener noreferrer">如何在 K8S 集群中部署 Traefik Ingress Controller</a> 详细介绍了如何在 k8s 集群部署 Traefik Ingress Controller 的详细过程，本文在此复现其操作。</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在本文的后半部分，我将演示如何在一个 Kubernetes 集群部署 Traefik 作为 Ingress Controller，同时使用 Ingress 实现按域名路由和流量分配。在此之前，你需要一个已经部署成功的 Kubernetes 集群和一个能够与集群通信的kubectl 工具。</p>
<blockquote>
<p>软文时间：你可以在MiniKube创建运行 Kubernetes 集群，也欢迎使用腾讯云的TKE容器服务，快速实现1分钟内自动创建好 Kubernetes 集群。</p>
</blockquote>
<h3 id="启用RBAC"><a href="#启用RBAC" class="headerlink" title="启用RBAC"></a>启用RBAC</h3><p>为了能够使 Traefik 能够访问集群中运行的 Pod、Endpoint、Ingress和 Service等资源，需要向 Traefik 授予一些权限。这里我们创建了一个具有一组权限的ClusterRole，授予其管理和监视集群中所有命名空间的资源。同时，我们创建一个新的ServiceAccount，为Traefik 提供集群中的身份。最后，通过 ClusterRoleBinding 将二者绑定在一起。</p>
<figure class="highlight yaml"><figcaption><span>rbac.yam</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>
<p>在命令行执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f rbac.yaml</span></span><br><span class="line">serviceaccount/traefik-ingress created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/traefik-ingress created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/traefik-ingress created</span><br></pre></td></tr></table></figure>
<h3 id="部署Traefik"><a href="#部署Traefik" class="headerlink" title="部署Traefik"></a>部署Traefik</h3><p>官方 Traefik 文档支持三种类型的部署：使用 Deployment 对象、使用 DaemonSet 对象或使用 Helm Chart。这里我们使用 Deployment manifest。</p>
<figure class="highlight yaml"><figcaption><span>deployment.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">traefik-ingress</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">traefik:v1.7.16</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--api</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubernetes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--logLevel=INFO</span></span><br></pre></td></tr></table></figure>
<p>在命令行执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f deployment.yaml</span></span><br><span class="line">deployment.extensions/traefik-ingress created</span><br><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl get pods -n kube-system</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">traefik-ingress-56f459f5cb-psrhr    1/1     Running   0          16s</span><br></pre></td></tr></table></figure>
<h3 id="为外部访问创建NodePorts"><a href="#为外部访问创建NodePorts" class="headerlink" title="为外部访问创建NodePorts"></a>为外部访问创建NodePorts</h3><p>接下来创建一个服务来从集群外部访问 Traefik，这里我们只暴露Traefik给外部，其他的内部服务都可以通过定义Ingress规则来通过 Traefik 暴露出来，极大避免了 NodePort的冲突。在实际生产环境中，这里的 NodePort 可以替换成云服务商提供的LB。</p>
<figure class="highlight yaml"><figcaption><span>service.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
<p>在命令行执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl create -f service.yaml</span></span><br><span class="line">service/traefik-ingress-service created</span><br><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl get svc -n kube-system</span></span><br><span class="line">NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                       AGE</span><br><span class="line">hpa-metrics-service       ClusterIP   172.18.254.168   &lt;none&gt;        443/TCP                       51d</span><br><span class="line">kube-dns                  ClusterIP   172.18.253.26    &lt;none&gt;        53/TCP,53/UDP                 51d</span><br><span class="line">traefik-ingress-service   NodePort    172.18.253.6     &lt;none&gt;        80:30993/TCP,8080:31846/TCP   2s</span><br></pre></td></tr></table></figure>
<p>这个时候，已经可以在浏览器访问 Traefik 服务了，在浏览器输入 <code>http://&lt;NodeIP&gt;:&lt;AdminNodePort&gt;</code> 就可以看到 Traefik 的 WebUI了。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-access.png"></p>
<p>这个时候WebUI还没有管理任何Ingress，接下来我们创建Ingress。</p>
<h3 id="实现按域名的路由"><a href="#实现按域名的路由" class="headerlink" title="实现按域名的路由"></a>实现按域名的路由</h3><figure class="highlight yaml"><figcaption><span>animals-ingress.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">animals</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">hare.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">hare</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bear.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">bear</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">moose.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">moose</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure>
<p>在命令行执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl create -f animals-ingress.yaml</span></span><br><span class="line">ingress.extensions/animals created</span><br></pre></td></tr></table></figure>
<p>这个时候只创建了 Ingress，还没有创建 Frontend 的 Service 和后端服务的 EndPoint，查看Traefik看到</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-ingress.png"></p>
<p>创建对应的 Service：</p>
<figure class="highlight yaml"><figcaption><span>animals-service.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">traefik.backend.circuitbreaker:</span> <span class="string">"NetworkErrorRatio() &gt; 0.5"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">hare</span></span><br></pre></td></tr></table></figure>
<p>在命令行执行命令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[root@VM-1-28-centos</span> <span class="string">traefik]#</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">animals-service.yaml</span></span><br><span class="line"><span class="string">service/bear</span> <span class="string">created</span></span><br><span class="line"><span class="string">service/moose</span> <span class="string">created</span></span><br><span class="line"><span class="string">service/hare</span> <span class="string">created</span></span><br></pre></td></tr></table></figure>
<p>这个时候 Ingress 中 Frontend 对应的 Service已经正常工作，但是 Backend 的EndPoint还没有就绪：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-service.png"></p>
<p>修改本机Host，添加记录如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">NodeIP</span>&gt; <span class="selector-tag">hare</span><span class="selector-class">.houmin</span> <span class="selector-tag">moose</span><span class="selector-class">.houmin</span> <span class="selector-tag">bear</span><span class="selector-class">.houmin</span></span><br></pre></td></tr></table></figure>
<p>这个时候在浏览器访问 <code>http://hare.houmin:&lt;WebNodePort&gt;</code>，在这里 <code>WebNodePort</code> 也就对应于 30993，显示 <code>Service Unavailable</code>。符合预期，因为Backend的Endpoint还没有起来。</p>
<p>创建对应的 Deployment：</p>
<figure class="highlight yaml"><figcaption><span>animals-deployment.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">bear</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:bear</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">moose</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:moose</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">hare</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">hare</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:hare</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>在命令行中执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f animals-deployment.yaml</span></span><br><span class="line">deployment.extensions/bear created</span><br><span class="line">deployment.extensions/moose created</span><br><span class="line">deployment.extensions/hare created</span><br></pre></td></tr></table></figure>
<p><img alt="查看WebUI，显示后端EndPoint服务已就绪" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-endpoint.png"></p>
<p>这个是否分别访问Bear、Hare和Moose服务：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-bear.png"></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-hare.png"></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-moose.png"></p>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>k8s</tag>
        <tag>service</tag>
        <tag>ingress</tag>
      </tags>
  </entry>
  <entry>
    <title>【Service Mesh】Envoy 入门</title>
    <url>/posts/7beb34d2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Envoy</code> 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 <code>Envoy</code>没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，<code>Envoy</code>也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。</p>
<a id="more"></a>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img alt="Envoy Architecture" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p>
<p>首先介绍Envoy中的一些基本概念：</p>
<ul>
<li>Downstream：下游主机，指连接到Envoy的主机，这些主机用来发送请求并接受响应。</li>
<li>Upstream：上游主机，指接收来自Envoy连接和请求的主机，并返回响应。</li>
<li>Listener：服务或程序的监听器， Envoy暴露一个或多个监听器监听下游主机的请求，当监听到请求时，通过Filter Chain把对请求的处理全部抽象为Filter， 例如ReadFilter、WriteFilter、HttpFilter等。</li>
<li>Cluster：服务提供集群，指Envoy连接的一组逻辑相同的上游主机。Envoy通过服务发现功能来发现集群内的成员，通过负载均衡功能将流量路由到集群的各个成员。</li>
<li>xDS：xDS中的x是一个代词，类似云计算里的XaaS可以指代IaaS、PaaS、SaaS等。DS为Discovery Service，即发现服务的意思。xDS包括CDS（cluster discovery service）、RDS（route discovery service）、EDS（endpoint discovery service）、ADS（aggregated discovery service），其中ADS称为聚合的发现服务，是对CDS、RDS、LDS、EDS服务的统一封装，解决CDS、RDS、LDS、EDS信息更新顺序依赖的问题，从而保证以一定的顺序同步各类配置信息。以上Endpoint、Cluster、Route的概念介绍如下：<ul>
<li>Endpoint：一个具体的“应用实例”，类似于Kubernetes中的一个Pod；</li>
<li>Cluster：可以理解“应用集群”，对应提供相同服务的一个或多个Endpoint， 类似Kubernetes中Service概念，即一个Service提供多个相同服务的Pod；</li>
<li>Route：当我们做金丝雀发布部署时，同一个服务会有多个版本，这时需要Route规则规定请求如何路由到其中的某个版本上。</li>
</ul>
</li>
</ul>
<p>xDS模块的功能是通过Envoy API V1（基于HTTP）或V2（基于gRPC）实现一个服务端将配置信息暴露给上游主机，等待上游主机的拉取。</p>
<p>Envoy正常的工作流程为Host A（下游主机）发送请求至上游主机（Host B、Host C、Host D等），Envoy通过Listener监听到有下游主机的请求，收到请求后的Envoy将所有请求流量劫持至Envoy内部，并将请求内容抽象为Filter Chains路由至某个上游主机中从而实现路由转发及负载均衡能力。</p>
<p>Envoy为了实现流量代理能力通常需要一个统一的配置文件来记录信息以便启动时加载，在Envoy中启动配置文件有静态配置和动态配置两种方式。静态配置是将配置信息写入文件中，启动时直接加载，动态配置通过xDS实现一个Envoy的服务端（可以理解为以API接口对外实现服务发现能力）。</p>
<h3 id="Network-Topology"><a href="#Network-Topology" class="headerlink" title="Network Topology"></a>Network Topology</h3><p>Envoy作为Service Mesh中的 sidecar 代理，请求可以通过 ingress 或者 egress listener 到达 envoy。</p>
<ul>
<li>Ingress Listener 负责从服务网格中其他节点接受请求，并将请求转发到本地应用。本地应用的响应之后通过 Envoy 转发到 downstream。</li>
<li>Egress Listener 负责从本地应用接受请求，并将请求转发到服务网格中的其他节点。</li>
</ul>
<p><img alt="Service Mesh" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-service-mesh.svg"></p>
<p>除了服务网格外，Envoy还可以用作很多其他的请求，比如作为内部的负载均衡器：</p>
<p><img alt="Internal Load Balancer" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-ilb.svg"></p>
<p>或者作为网络边缘的 <code>ingress/egress</code> 代理：</p>
<p><img alt="Ingress/Egress Proxy on Network Edge" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-edge.svg"></p>
<p>在实际应用中，Envoy一般会发挥上述多种功能，一个网络请求路径中可能会通过多个Envoy：</p>
<p><img alt="Hybrid Envoy" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-hybrid.svg"></p>
<p>为了可靠性和可扩充性，Envoy可能会被配置成多层拓扑的形式：</p>
<p><img alt="Envoy Tiered" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-tiered.svg"></p>
<h3 id="High-Level-Architecture"><a href="#High-Level-Architecture" class="headerlink" title="High Level Architecture"></a>High Level Architecture</h3><p>Envoy中服务请求处理过程可以大致分为两个部分：</p>
<ul>
<li>Listener 子系统：处理来自 downstream 的请求。</li>
<li>Cluster 子系统：负责选择和配置 upstream 连接。</li>
</ul>
<p><img alt="High Level Architecture" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-architecture.svg"></p>
<p>Envoy采用了基于事件的线程模型：</p>
<ul>
<li>一个主线程负责server的生命周期，配置处理，统计等</li>
<li>多个worker线程负责处理请求。</li>
</ul>
<p>所有的线程都运行在一个基于 <a href="https://libevent.org/" target="_blank" rel="external nofollow noopener noreferrer">libevent</a> 的事件循环中，任何 downstream 的 TCP连接都会被分配一个 work 线程来处理</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Envoy 进程中运行着一系列 <code>Inbound/Outbound</code> 监听器（Listener），<code>Inbound</code> 代理入站流量，<code>Outbound</code> 代理出站流量。Listener 的核心就是过滤器链（FilterChain），链中每个过滤器都能够控制流量的处理流程。过滤器链中的过滤器分为两个类别：</p>
<ul>
<li><strong>网络过滤器</strong>（Network Filters）: 工作在 <code>L3/L4</code>，是 Envoy 网络连接处理的核心，处理的是原始字节，分为 <code>Read</code>、<code>Write</code> 和 <code>Read/Write</code> 三类。</li>
<li><strong>HTTP 过滤器</strong>（HTTP Filters）: 工作在 <code>L7</code>，由特殊的网络过滤器 <code>HTTP connection manager</code> 管理，专门处理 <code>HTTP1/HTTP2/gRPC</code> 请求。它将原始字节转换成 <code>HTTP</code> 格式，从而可以对 <code>HTTP</code> 协议进行精确控制。</li>
</ul>
<p>除了 <code>HTTP connection manager</code> 之外，还有一种特别的网络过滤器叫 <code>Thrift Proxy</code>。<code>Thrift</code> 是一套包含序列化功能和支持服务通信的 RPC 框架，详情参考<a href="https://zh.wikipedia.org/wiki/Thrift" target="_blank" rel="external nofollow noopener noreferrer">维基百科</a>。Thrift Proxy 管理了两个 Filter：<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/router_filter" target="_blank" rel="external nofollow noopener noreferrer">Router</a> 和 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/rate_limit_filter" target="_blank" rel="external nofollow noopener noreferrer">Rate Limit</a>。</p>
<p>除了过滤器链之外，还有一种过滤器叫<strong>监听器过滤器</strong>（Listener Filters），它会在过滤器链之前执行，用于操纵连接的<strong>元数据</strong>。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 <code>UDP</code> 时，就可以指定 UDP 监听器过滤器。根据上面的分类，Envoy 过滤器的架构如下图所示：</p>
<p><img alt="img" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504224710.png"></p>
<h2 id="Request-Flow"><a href="#Request-Flow" class="headerlink" title="Request Flow"></a>Request Flow</h2><h3 id="Listener-TCP-Accept"><a href="#Listener-TCP-Accept" class="headerlink" title="Listener TCP Accept"></a>Listener TCP Accept</h3><p><img alt="Listener TCP Accept" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listeners.svg"></p>
<h3 id="Listener-filter-chains-and-network-filter-chain-matching"><a href="#Listener-filter-chains-and-network-filter-chain-matching" class="headerlink" title="Listener filter chains and network filter chain matching"></a>Listener filter chains and network filter chain matching</h3><p><img alt="Listener Filter Chains" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listener-filters.svg"></p>
<p><img alt="../_images/lor-filter-chain-match.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-filter-chain-match.svg"></p>
<h3 id="TLS-transport-socket-decryption"><a href="#TLS-transport-socket-decryption" class="headerlink" title="TLS transport socket decryption"></a>TLS transport socket decryption</h3><p><img alt="../_images/lor-transport-socket.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-transport-socket.svg"></p>
<h3 id="Network-filter-chain-processing"><a href="#Network-filter-chain-processing" class="headerlink" title="Network filter chain processing"></a>Network filter chain processing</h3><p><img alt="../_images/lor-network-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-filters.svg"></p>
<p><img alt="../_images/lor-network-read.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-read.svg"></p>
<p><img alt="../_images/lor-network-write.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-write.svg"></p>
<h3 id="HTTP-2-codec-encoding"><a href="#HTTP-2-codec-encoding" class="headerlink" title="HTTP/2 codec encoding"></a>HTTP/2 codec encoding</h3><h3 id="TLS-transport-socket-encryption"><a href="#TLS-transport-socket-encryption" class="headerlink" title="TLS transport socket encryption"></a>TLS transport socket encryption</h3><p><img alt="../_images/lor-http-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-filters.svg"></p>
<p><img alt="../_images/lor-http.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http.svg"></p>
<p><img alt="../_images/lor-http-decode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-decode.svg"></p>
<p><img alt="../_images/lor-http-encode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-encode.svg"></p>
<p><img alt="../_images/lor-route-config.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-route-config.svg"></p>
<h3 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h3><p><img alt="../_images/lor-lb.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-lb.svg"></p>
<h3 id="Response-path-and-HTTP-lifecycle"><a href="#Response-path-and-HTTP-lifecycle" class="headerlink" title="Response path and HTTP lifecycle"></a>Response path and HTTP lifecycle</h3><p><img alt="../_images/lor-client.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-client.svg"></p>
<h3 id="Post-request-processing"><a href="#Post-request-processing" class="headerlink" title="Post-request processing"></a>Post-request processing</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.aliyun.com/article/606655" target="_blank" rel="external nofollow noopener noreferrer">https://developer.aliyun.com/article/606655</a></li>
<li><a href="https://www.cnblogs.com/popsuper1982/p/9841978.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/popsuper1982/p/9841978.html</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>envoy</tag>
      </tags>
  </entry>
  <entry>
    <title>【Service Mesh】Istio 流量控制</title>
    <url>/posts/151719f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 <a href="../22cae0b8">Istio 入门</a> 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。</p>
<a id="more"></a>
<p><img alt="Istio Architecture" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p>
<h2 id="路由和流量转移"><a href="#路由和流量转移" class="headerlink" title="路由和流量转移"></a>路由和流量转移</h2><p>Istio 为了控制服务请求，引入了服务版本（version）的概念，可以通过版本这一标签将服务进行区分。版本的设置是非常灵活的，以下是几种典型的设置方式：</p>
<ul>
<li>根据服务的迭代编号进行定义（如 v1、v2 版本）</li>
<li>根据部署环境进行定义（比如 dev、staging、production）</li>
<li>自定义的任何用于区分服务的某种标记</li>
</ul>
<p>通过版本标签，Istio 就可以定义灵活的路由规则来控制流量，上面提到的金丝雀发布这类应用场景就很容易实现了。</p>
<p>下图展示了使用服务版本实现路由分配的例子。服务版本定义了版本号（v1.5、v2.0-alpha）和环境（us-prod、us-staging）两种信息。服务 B 包含了 4 个 Pod，其中 3 个是部署在生产环境的 v1.5 版本，而 Pod4 是部署在预生产环境的 v2.0-alpha 版本。运维人员可以根据服务版本来指定路由规则，使 99% 的流量流向 v1.5 版本，而 1% 的流量进入 v2.0-alpha 版本。</p>
<p><img alt="路由" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/concept-feature-routing.png"></p>
<p>除了上面介绍的服务间流量控制外，还能控制与网格边界交互的流量。可以在系统的入口和出口处部署 Sidecar 代理，让所有流入和流出的流量都由代理进行转发。负责入和出的代理就叫做入口网关和出口网关，它们把守着进入和流出网格的流量。下图展示了 Ingress 和 Egress 在请求流中的位置，有了他们俩，也就可以控制出入网格的流量了。</p>
<p><img alt="入口和出口网关" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/concept-feature-gateway.png"></p>
<p>Istio 还能设置流量策略。比如可以对连接池相关的属性进行设置，通过修改最大连接等参数，实现对请求负载的控制。还可以对负载均衡策略进行设置，在轮询、随机、最少访问等方式之间进行切换。还能设置异常探测策略，将满足异常条件的实例从负载均衡池中摘除，以保证服务的稳定性。</p>
<hr>
<p>Istio 的流量路由规则可以让您很容易的控制服务之间的流量和 API 调用。Istio 在服务层面提供了断路器，超时，重试等功能，通过这些功能可以简单地实现 A/B 测试，金丝雀发布，基于百分比的流量分割等，此外还提供了开箱即用的故障恢复功能，用于增加应用的健壮性，以应对服务故障或网络故障。这些功能都可以通过 Istio 的流量管理 API 添加流量配置来实现。</p>
<p>跟其他 Istio 配置一样，流量管理 API 也使用 CRD 指定。本小节主要介绍下面几个典型的流量管理 API 资源，以及这些 API 的功能和使用示例。</p>
<h3 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h3><p>VirtualService 由一组 <strong>路由规则</strong> 组成，描述了 <strong>用户请求的目标地址</strong> 到 <strong>服务网格中实际工作负载</strong> 之间的映射。在这个映射中，VirtualService提供了丰富的配置方式，可以为发送到这些 Workloads 的流量指定不同的路由规则。对应于具体的配置，用户请求的目标地址用 <code>hosts</code> 字段来表示，网格内的实际负载由每个 <code>route</code> 配置项中的 <code>destination</code> 字段指定。</p>
<pre class="mermaid">graph LR
subgraph VirtualService
ClientRequests -- DifferentTrafficRoutingRules --> DestinationWorkloads
Hosts -- DifferentTrafficRoutingRules --> RouteDestination
end</pre>

<p>VirtualService 通过解耦 <strong>用户请求的目标地址</strong> 和 <strong>真实响应请求的目标工作负载</strong>，为服务提供了合适的统一抽象层，而由此演化设计的配置模型为管理这方面提供了一致的环境。对于原生 Kubernetes 而言，只有在 Ingress 处有这种路由规则的定义，对于集群内部不同Service的不同版本之间，并没有类似 VirtualService 的定义。</p>
<p>使用 VirtualService，可以为一个或多个主机名指定流量行为。在 VirtualService 中使用路由规则，告诉 Envoy如何发送 VirtualService 的流量到适当的目标。路由目标可以是相同服务的不同版本，或者是完全不同的服务。</p>
<p>一个典型的应用场景是将流量发送到被指定为服务子集的服务的不同版本。客户端将 VirtualService 视为一个单一实体，将请求发送至 VirtualService 主机，然后 Envoy 根据 VirtualService 规则把流量路由到不同的版本中。</p>
<p>这种方式可以方便地创建一种金丝雀的发布策略实现新版本流量的平滑比重升级。流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。相比之下，类似 Kubernetes 的容器调度平台仅支持基于部署中实例扩缩容比重的流量分发，那样会日趋复杂化。关于使用VirtualService实现金丝雀部署，可以参考 <a href="https://istio.io/latest/blog/2017/0.1-canary/" target="_blank" rel="external nofollow noopener noreferrer">Canary</a> 。</p>
<p>VirtualService 也提供了如下功能。</p>
<ul>
<li>通过单个 VirtualService 处理多个应用程序服务。例如，如果您的服务网格使用是 Kubernetes，您可以配置一个 VirtualService 来处理一个特定命名空间的所有服务。将单一的 VirtualService 映射为多个“真实”的服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。您的路由规则可以指定“请求到 <code>monolith.com</code> 的 URLs 跳转至 <code>microservice A</code> 中”。</li>
<li>和 Gateway  一起配置流量规则来控制入口和出口流量。</li>
</ul>
<p>在一些应用场景中，由于指定服务子集，需要配置 DestinationRule 来使用这些功能。在不同的对象中指定服务子集以及其他特定的目标策略可以帮助您在不同的 VirtualService 中清晰地复用这些功能。</p>
<p>下面的 VirtualService 根据是否来自于特定用户路由请求到不同的服务版本中（如果请求来自用户 <code>jason</code> ，则访问 <code>v2</code> 版本的 <code>reviews</code>，否则访问 <code>v3</code> 版本）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure>
<p>下面对这些字段依次解释：</p>
<h4 id="Hosts"><a href="#Hosts" class="headerlink" title="Hosts"></a>Hosts</h4><p>用来配置 Downstream 访问的可寻址地址，也就是用户请求的目标地址。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">reviews</span></span><br></pre></td></tr></table></figure>
<ul>
<li>VirtualService 主机名可以是 IP 地址、 DNS 域名、完全限定域名（FQDN)</li>
<li>也可以是 依赖于平台的一个简称（例如 Kubernetes 服务的短名称）</li>
<li>也可以使用通配符 <code>*</code>前缀，创建一组匹配所有服务的路由规则</li>
<li>VirtualService 的 <code>hosts</code> 实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址。这可以为没有路由到网格内部的虚拟主机建模。</li>
</ul>
<h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><p><code>http</code> 字段用来配置路由规则，通常情况下配置一组路由规则，当请求到来时，自上而下依次进行匹配，直到匹配成功后跳出匹配。它可以对请求的 uri、method、authority、headers、port、queryParams 以及是否对 uri 大小写敏感等进行配置。</p>
<blockquote>
<p>除了HTTP协议，也可以使用 <code>tcp</code> 和 <code>tls</code> 片段为 <a href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#TCPRoute" target="_blank" rel="external nofollow noopener noreferrer">TCP</a> 和未终止的 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#TLSRoute" target="_blank" rel="external nofollow noopener noreferrer">TLS</a> 流量设置路由规则</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">end-user:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure>
<p>我们推荐在每个 VirtualService 中配置一条默认「无条件的」或者基于权重的规则以确保 VirtualService 至少有一条匹配的路由。</p>
<h5 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h5><p>路由片段的 <code>destination</code> 字段指定符合匹配条件的流量目标地址。这里不像 VirtualService 的 <code>hosts</code>，Destination 的 <code>host</code> 必须是存在于 Istio 服务注册中心的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。这个目标地址可以是代理的网格服务或者作为服务入口加入的非网格服务。下面的场景中我们运行在 Kubernetes 平台上，主机名是 Kubernetes 的服务名。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">subset:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">*Note for Kubernetes users*: When short names are used (e.g. "reviews" instead of "reviews.default.svc.cluster.local"), Istio will interpret the short name based on the namespace of the rule, not the service. A rule in the "default" namespace containing a host "reviews will be interpreted as "reviews.default.svc.cluster.local", irrespective of the actual namespace associated with the reviews service. To avoid potential misconfiguration, it is recommended to always use fully qualified domain names over short names.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>路由规则是将特定流量子集路由到特定目标地址的强大工具。可以在流量端口、<code>header</code> 字段、 URL 等内容上设置匹配条件。例如，下面的VirtualService 使用户发送流量到两个独立的服务，ratings and reviews， 就好像它们是 <code>http://bookinfo.com/</code> 这个更大的 VirtualService 的一部分。VirtualService 规则根据请求的 URL 和指向适当服务的请求匹配流量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bookinfo.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/ratings</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br></pre></td></tr></table></figure>
<p>对于匹配条件，您可以使用确定的值，一条前缀、或者一条正则表达式。</p>
<p>您可以使用 <code>AND</code> 向同一个 <code>match</code> 块添加多个匹配条件， 或者使用 <code>OR</code> 向同一个规则添加多个 <code>match</code> 块。对于任意给定的 VirtualService ，您可以配置多条路由规则。这可以使您的路由条件在一个单独的 VirtualService 中基于业务场景的复杂度来进行相应的配置。可以在 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPMatchRequest" target="_blank" rel="external nofollow noopener noreferrer">HTTPMatchRequest 参考</a>中查看匹配条件字段和他们可能的值。</p>
<p>再者进一步使用匹配条件，您可以使用基于“权重”百分比分发流量。这在 A/B 测试和金丝雀部署中非常有用。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">75</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>您也可以使用路由规则在流量上执行一些操作，例如</p>
<ul>
<li>扩展或者删除 <code>headers</code></li>
<li>重写 URL</li>
<li>为调用这个目标地址设置重试策略</li>
</ul>
<h3 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h3><p><code>DestinationRule</code> 是 Istio 流量路由功能的重要组成部分。一个 <code>VirtualService</code> 可以看作是如何将流量分发到给定的目标地址，然后调用 <code>DestinationRule</code> 来配置分发到该目标地址的流量。<code>DestinationRule</code> 在 <code>VirtualService</code> 的路由规则之后起作用(即在 <code>VirtualService</code> 的 <code>match</code> -&gt; <code>route</code> -&gt; <code>destination</code> 之后起作用，此时流量已经分发到真实的 <code>Service</code> 上)，应用于真实的目标地址。</p>
<p>特别地，可以使用 <code>DestinationRule</code> 来指定命名的服务子集，例如根据版本对服务的实例进行分组，然后通过 <code>VirtualService</code> 的路由规则中的服务子集将控制流量分发到不同服务的实例中。</p>
<p><code>DestinationRule</code> 允许在调用完整的目标服务或特定的服务子集(如倾向使用的负载均衡模型，TLS 安全模型或断路器)时自定义 Envoy流量策略。Istio 默认会使用轮询策略，此外 Istio 也支持如下负载均衡模型，可以在 <code>DestinationRule</code> 中使用这些模型，将请求分发到特定的服务或服务子集。</p>
<ul>
<li>Random：将请求转发到一个随机的实例上</li>
<li>Weighted：按照指定的百分比将请求转发到实例上</li>
<li>Least requests：将请求转发到具有最少请求数目的实例上</li>
</ul>
<p>下面的 <code>DestinationRule</code> 使用不同的负载均衡策略为 my-svc 目的服务配置了3个不同的 Subset</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-destination-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">my-svc</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span>     <span class="comment">#默认的负载均衡策略模型为随机</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">RANDOM</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  <span class="comment">#subset1，将流量转发到具有标签 version:v1 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  <span class="comment">#subset2，将流量转发到具有标签 version:v2 的 deployment 对应的服务上,指定负载均衡为轮询</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span>   <span class="comment">#subset3，将流量转发到具有标签 version:v3 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure>
<p>每个子集由一个或多个 <code>labels</code> 定义，对应 Kubernetes 中的对象(如 <code>Pod</code> )的 key/value 对。这些标签定义在 Kubernetes 服务的 deployment 的 metadata 中，用于标识不同的版本。</p>
<p>除了定义子集外，<code>DestinationRule</code> 还定义了该目的地中所有子集的默认流量策略，以及仅覆盖该子集的特定策略。默认的策略定义在 <code>subset</code> 字段之上，为 <code>v1</code> 和 <code>v3</code> 子集设置了随机负载均衡策略，在 <code>v2</code> 策略中使用了轮询负载均衡。</p>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Gateway 用于管理进出网格的流量，指定可以进入或离开网格的流量。Gateway 配置应用于网格边缘的独立的 Envoy代理上，而不是服务负载的 Envoy 代理上。</p>
<p>与其他控制进入系统的流量的机制(如 Kubernetes Ingress API)不同，Istio gateway 允许利用 Istio 的流量路由的强大功能和灵活性。Istio 的 gateway 资源仅允许配置 4-6 层的负载属性，如暴露的端口，TLS 配置等等，但结合 Istio 的 <code>VirtualService</code>，就可以像管理 Istio 网格中的其他数据面流量一样管理 Gateway 的流量。</p>
<p>Gateway 主要用于管理 Ingress 流量，但也可以配置 Egress Gateway。通过 Egress Gateway 可以配置流量离开网格的特定节点，限制哪些服务可以访问外部网络，或通过 Egress 安全控制来提高网格的安全性。Gateway 可以用于配置为一个纯粹的内部代理。</p>
<p>Istio (通过 <code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code> 参数)提供了一些预配置的 Gateway 代理，<code>default</code> profile 下仅会部署 Ingress Gateway。Gateway 可以通过部署文件进行部署，也可以单独部署。</p>
<p>下面是 <code>default</code> profile 默认安装的 Ingress</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get gw</span><br><span class="line">NAME               AGE</span><br><span class="line">bookinfo-gateway   28h</span><br></pre></td></tr></table></figure>
<p>可以看到该 ingress 就是一个普通的 <code>Pod</code>，该 <code>Pod</code> 仅包含一个 Istio-proxy 容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod -n istio-system |grep ingress</span><br><span class="line">istio-ingressgateway-64f6f9d5c6-qrnw2 1/1 Running 0 4d20h</span><br></pre></td></tr></table></figure>
<p>下面是一个 Gateway 的例子，用于配置外部 HTTPS 的 ingress 流量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-host-gwy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>              <span class="comment">#指定 gateway 配置下发的代理，如具有标签 app: my-gateway-controller 的 pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-gateway-controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span>                <span class="comment">#gateway pod 暴露的端口信息</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span>                <span class="comment">#外部流量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/tmp/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/tmp/tls.key</span></span><br></pre></td></tr></table></figure>
<p>上述 Gateway 配置允许来自 <code>ext-host.example.com</code> 流量进入网格的 443 端口，但没有指定该流量的路由。(此时流量只能进入网格，但没有指定处理该流量的服务，因此需要与 <code>VirtualService</code> 进行绑定)</p>
<p>为了为 Gateway 指定路由，需要通过 <code>VirtualService</code> 的 <code>Gateway</code> 字段，将 <code>Gateway</code> 绑定到一个 <code>VirtualService</code> 上，将来自 <code>ext-host.example.com</code> 流量引入一个 <code>VirtualService</code>，<code>hosts</code> 可以是通配符，表示引入匹配到的流量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">virtual-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">  <span class="attr">gateways:</span>        <span class="comment">#将 gateway "ext-host-gwy" 绑定到 virtual service "virtual-svc"上</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host-gwy</span></span><br></pre></td></tr></table></figure>
<p>Egress Gateway 提供了对网格的出口流量进行统一管控的功能，在安装 Istio 时默认是不开启的。可以使用以下命令查看是否开启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod -l istio=egressgateway -n istio-system</span></span><br></pre></td></tr></table></figure>
<p>若没有开启，使用以下命令添加。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ istioctl manifest apply --<span class="built_in">set</span> values.global.istioNamespace=istio-system \</span><br><span class="line">    --<span class="built_in">set</span> values.gateways.istio-egressgateway.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Egress Gateway 的一个简单示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-egressgateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">egressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">edition.cnn.com</span></span><br></pre></td></tr></table></figure>
<p>可以看出，与 Ingress Gateway 不同，Egress Gateway 使用有 <code>istio: egressgateway</code> 标签的 Pod 来代理流量，实际上这也是一个 Envoy 代理。当网格内部需要访问 <code>edition.cnn.com</code> 这个地址时，流量将会统一先转发到 Egress Gateway 上，再由 Egress Gateway 将流量转发到 <code>edition.cnn.com</code> 上。</p>
<h3 id="ServiceEntry"><a href="#ServiceEntry" class="headerlink" title="ServiceEntry"></a>ServiceEntry</h3><p>Istio 支持对接 Kubernetes、Consul 等多种不同的注册中心，控制平面<code>Pilot</code>启动时，会从指定的注册中心获取 <code>Service Mesh</code> 集群的服务信息和实例列表，并将这些信息进行处理和转换，然后通过 xDS 下发给对应的数据平面，保证服务之间可以互相发现并正常访问。</p>
<p>同时，由于这些服务和实例信息都来源于服务网格内部，Istio 无法从注册中心直接获取网格外的服务，导致不利于网格内部与外部服务之间的通信和流量管理。为此，Istio 引入 ServiceEntry 实现对外通信和管理。</p>
<p>使用 ServiceEntry 可以将外部的服务条目添加到 Istio 内部的服务注册表中，以便让网格中的服务能够访问并路由到这些手动指定的服务。ServiceEntry 描述了服务的属性（DNS 名称、VIP、端口、协议、端点）。这些服务可能是位于网格外部（如，web APIs），也可能是处于网格内部但不属于平台服务注册表中的条目（如，需要和 Kubernetes 服务交互的一组虚拟机服务）。</p>
<h4 id="ServiceEntry-示例和属性介绍"><a href="#ServiceEntry-示例和属性介绍" class="headerlink" title="ServiceEntry 示例和属性介绍"></a>ServiceEntry 示例和属性介绍</h4><p>对于网格外部的服务，下面的 ServiceEntry 示例表示网格内部的应用通过 https 访问外部的 API。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.google.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure>
<p>对于在网格内部但不属于平台服务注册表的服务，使用下面的示例可以将一组在非托管 VM 上运行的 MongoDB 实例添加到 Istio 的注册中心，以便可以将这些服务视为网格中的任何其他服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-svc-mongocluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mymongodb.somedomain</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.192</span><span class="number">.192</span><span class="number">.192</span><span class="string">/24</span> <span class="comment"># VIPs</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">27018</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">MONGO</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_INTERNAL</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">STATIC</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>结合上面给出的示例，这里对 ServiceEntry 涉及的关键属性解释如下：</p>
<ul>
<li><code>hosts</code>: 表示与该 ServiceEntry 相关的主机名，可以是带有通配符前缀的 DNS 名称。</li>
<li><code>address</code>: 与服务相关的虚拟 IP 地址，可以是 CIDR 前缀的形式。</li>
<li><code>ports</code>: 和外部服务相关的端口，如果外部服务的 endpoints 是 Unix socket 地址，这里必须只有一个端口。</li>
<li><code>location</code>: 用于指定该服务属于网格内部（MESH_INTERNAL）还是外部（MESH_EXTERNAL）。</li>
<li><code>resolution</code>: 主机的服务发现模式，可以是 NONE、STATIC、DNS。</li>
<li><code>endpoints</code>: 与服务相关的一个或多个端点。</li>
<li><code>exportTo</code>: 用于控制 ServiceEntry 跨命名空间的可见性，这样就可以控制在一个命名空间下定义的资源对象是否可以被其他命名空间下的 <code>Sidecar</code>、Gateway 和 VirtualService 使用。目前支持两种选项，”.” 表示仅应用到当前命名空间，”*” 表示应用到所有命名空间。</li>
</ul>
<h4 id="使用-ServiceEntry-访问外部服务"><a href="#使用-ServiceEntry-访问外部服务" class="headerlink" title="使用 ServiceEntry 访问外部服务"></a>使用 ServiceEntry 访问外部服务</h4><p>Istio 提供了三种访问外部服务的方法：</p>
<ol>
<li>允许 <code>Sidecar</code> 将请求传递到未在网格内配置过的任何外部服务。使用这种方法时，无法监控对外部服务的访问，也不能利用 Istio 的流量控制功能。</li>
<li>配置 ServiceEntry 以提供对外部服务的受控访问。这是 Istio 官方推荐使用的方法。</li>
<li>对于特定范围的 IP，完全绕过 <code>Sidecar</code>。仅当出于性能或其他原因无法使用 <code>Sidecar</code> 配置外部访问时，才建议使用该配置方法。</li>
</ol>
<p>这里，我们重点讨论第 2 种方式，也就是使用 ServiceEntry 完成对网格外部服务的受控访问。</p>
<p>对于 <code>Sidecar</code> 对外部服务的处理方式，Istio 提供了两种选项:</p>
<ul>
<li><code>ALLOW_ANY</code>：默认值，表示 Istio 代理允许调用未知的外部服务。上面的第一种方法就使用了该配置项。</li>
<li><code>REGISTRY_ONLY</code>：Istio 代理会阻止任何没有在网格中定义的 HTTP 服务或 ServiceEntry 的主机。</li>
</ul>
<p>可以使用下面的命令查看当前所使用的模式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | grep -o <span class="string">"mode: ALLOW_ANY"</span></span><br><span class="line">mode: ALLOW_ANY</span><br></pre></td></tr></table></figure>
<p>如果当前使用的是 <code>ALLOW_ANY</code> 模式，可以使用下面的命令切换为 <code>REGISTRY_ONLY</code> 模式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | sed <span class="string">'s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g'</span> | kubectl replace -n istio-system -f -</span><br><span class="line">configmap <span class="string">"istio"</span> replaced</span><br></pre></td></tr></table></figure>
<p>在 <code>REGISTRY_ONLY</code> 模式下，需要使用 ServiceEntry 才能完成对外部服务的访问。当创建如下的 ServiceEntry 时，服务网格内部的应用就可以正常访问 httpbin.org 服务了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure>
<h4 id="管理外部流量"><a href="#管理外部流量" class="headerlink" title="管理外部流量"></a>管理外部流量</h4><p>使用 ServiceEntry 可以使网格内部服务发现并访问外部服务，除此之外，还可以对这些到外部服务的流量进行管理。结合 VirtualService 为对应的 ServiceEntry 配置外部服务访问规则，如请求超时、故障注入等，实现对指定服务的受控访问。</p>
<p>下面的示例就是为外部服务 httpbin.org 设置了超时时间，当请求时间超过 3s 时，请求就会直接中断，避免因外部服务访问时延过高而影响内部服务的正常运行。由于外部服务的稳定性通常无法管控和监测，这种超时机制对内部服务的正常运行具有重要意义。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以为 ServiceEntry 设置故障注入规则，为系统测试提供基础。下面的示例表示为所有访问 <code>httpbin.org</code> 服务的请求注入一个403错误。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">httpbin-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line"> <span class="attr">http:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">       <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">   <span class="attr">fault:</span></span><br><span class="line">     <span class="attr">abort:</span></span><br><span class="line">       <span class="attr">percent:</span> <span class="number">100</span></span><br><span class="line">       <span class="attr">httpStatus:</span> <span class="number">403</span></span><br></pre></td></tr></table></figure>
<h3 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h3><p>在默认的情况下，Istio 中所有 Pod 中的 Envoy 代理都是可以被寻址的。然而在某些场景下，我们为了做资源隔离，希望只访问某些 Namespace 下的资源。这个时候，我们就可以使用 Sidecar配置来实现。下面是一个简单的示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sidecar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"./*"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"istio-system/*"</span></span><br></pre></td></tr></table></figure>
<p>该示例就规定了在命名空间为 bookinfo 下的所有服务仅可以访问本命名空间下的服务以及 <code>istio-system</code> 命名空间下的服务。</p>
<h2 id="弹性功能"><a href="#弹性功能" class="headerlink" title="弹性功能"></a>弹性功能</h2><p>除了最核心的路由和流量转移功能外，Istio 还提供了一定的弹性功能，目前支持超时、重试和熔断。</p>
<h3 id="Request-Timeouts"><a href="#Request-Timeouts" class="headerlink" title="Request Timeouts"></a>Request Timeouts</h3><p>如果程序请求长时间无法返回结果，则需要设置超时机制，超过设置的时间则返回错误信息。这样做既可以节约等待时消耗的资源，也可以避免由于级联错误引起的一系列问题。</p>
<p>设置超时的方式也有很多种，比如通过修改代码在应用程序侧设置请求超时时间，但是这样很不灵活，也容易出现遗漏的现象，而 Istio 则可以在基础设施层解决这一问题。在 Istio 里添加超时非常简单，只需要在路由配置里添加 <code>timeout</code> 这个关键字就可以实现。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure>
<h3 id="Retries"><a href="#Retries" class="headerlink" title="Retries"></a>Retries</h3><p>在网络环境不稳定的情况下，会出现暂时的网络不可达现象，这时需要重试机制，通过多次尝试来获取正确的返回信息。重试逻辑可以写业务代码中，比如 Bookinfo 应用中的<code>productpage</code>服务就存在硬编码重试，而 Istio 可以通过简单的配置来实现重试功能，让开发人员无需关注重试部分的代码实现，专心实现业务代码。在 Istio 里添加超时和重试都非常简单，只需要在路由配置里添 <code>retry</code> 这个关键字就可以实现。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">2s</span></span><br></pre></td></tr></table></figure>
<h3 id="Circuit-Breaking"><a href="#Circuit-Breaking" class="headerlink" title="Circuit Breaking"></a>Circuit Breaking</h3><p>熔断是一种非常有用的过载保护手段，可以避免服务的级联失败。在熔断器中，设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。熔断适用于在负载均衡池中的“真实”网格目标地址，可以在 DestinationRule 中配置熔断器阈值，让配置适用于服务中的每个主机。</p>
<p>Istio 里面的熔断需要在自定义资源 <code>DestinationRule</code> 的 <code>TrafficPolicy</code> 里进行设置。下面的示例将 v1 子集的<code>reviews</code>服务工作负载的并发连接数限制为 100：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">connectionPool:</span></span><br><span class="line">        <span class="attr">tcp:</span></span><br><span class="line">          <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Istio 还提供了对流量进行调试的能力，包括故障注入和流量镜像。对流量进行调试可以让系统具有更好的容错能力，也方便我们在问题排查时通过调试来快速定位原因所在。</p>
<h3 id="Fault-Injection"><a href="#Fault-Injection" class="headerlink" title="Fault Injection"></a>Fault Injection</h3><p>在一个微服务架构的系统中，为了让系统达到较高的健壮性要求，通常需要对系统做定向错误测试。比如电商中的订单系统、支付系统等若出现故障那将是非常严重的生产事故，因此必须在系统设计前期就需要考虑多样性的异常故障并对每一种异常设计完善的恢复策略或优雅的回退策略，尽全力规避类似事故的发生，使得当系统发生故障时依然可以正常运作。而在这个过程中，服务故障模拟一直以来是一个非常繁杂的工作，于是在这样的背景下就衍生出了故障注入技术手段，故障注入是用来模拟上游服务请求响应异常行为的一种手段。通过人为模拟上游服务请求的一些故障信息来检测下游服务的故障策略是否能够承受这些故障并进行自我恢复。</p>
<p>Istio 提供了一种无侵入式的故障注入机制，让开发测试人员在不用调整服务程序的前提下，通过配置即可完成对服务的异常模拟。Istio 1.5 仅支持网络层的故障模拟，即支持模拟上游服务的处理时长、服务异常状态、自定义响应状态码等故障信息，暂不支持对于服务主机内存、CPU 等信息故障的模拟。他们都是通过配置上游主机的 VirtualService 来实现的。当我们在 VirtualService 中配置了故障注入时，上游服务的 Envoy代理在拦截到请求之后就会做出相应的响应。</p>
<p>目前，Istio 提供两种类型的故障注入，abort 类型与 delay 类型。</p>
<ul>
<li><strong>abort</strong>：非必配项，配置一个 Abort 类型的对象。用来注入请求异常类故障。简单的说，就是用来模拟上游服务对请求返回指定异常码时，当前的服务是否具备处理能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-faultabort" target="_blank" rel="external nofollow noopener noreferrer">config.filter.http.fault.v2.FaultAbort</a> 配置项，当 VirtualService 资源应用时，Envoy将会该配置加载到过滤器中并处理接收到的流量。</li>
<li><strong>delay</strong>：非必配项，配置一个 Delay 类型的对象。用来注入延时类故障。通俗一点讲，就是人为模拟上游服务的响应时间，测试在高延迟的情况下，当前的服务是否具备容错容灾的能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/fault/v2/fault.proto#envoy-api-msg-config-filter-fault-v2-faultdelay" target="_blank" rel="external nofollow noopener noreferrer">config.filter.fault.v2.FaultDelay</a> 配置型，同样也是在应用 Istio 的 VirtualService 资源时，Envoy将该配置加入到过滤器中。</li>
</ul>
<p>实际上，Istio 的故障注入正是基于 Envoy的 config.filter.http.fault.v2.HTTPFault 过滤器实现的，它的局限性也来自于 Envoy故障注入机制的局限性。对于 Envoy的 HttpFault 的详细介绍请参考 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-httpfault" target="_blank" rel="external nofollow noopener noreferrer">Envoy 文档</a>。对比 Istio 故障注入的配置项与 Envoy故障注入的配置项，不难发现，Istio 简化了对于故障控制的手段，去掉了 Envoy中通过 HTTP header 控制故障注入的配置。</p>
<h4 id="HTTPFaultInjection-Abort"><a href="#HTTPFaultInjection-Abort" class="headerlink" title="HTTPFaultInjection.Abort"></a>HTTPFaultInjection.Abort</h4><ul>
<li><strong>httpStatus</strong>：必配项，是一个整型的值。表示注入 HTTP 请求的故障状态码。</li>
<li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li>
<li><strong>percent</strong>：已经废弃的一个配置，与 percentage 配置功能一样，已经被 percentage 代替。</li>
</ul>
<p>如下的配置表示对 <code>v1</code> 版本的 <code>ratings.prod.svc.cluster.local</code> 服务访问的时候进行故障注入，<code>0.1</code>表示有千分之一的请求被注入故障， <code>400</code> 表示故障为该请求的 HTTP 响应码为 <code>400</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">abort:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">httpStatus:</span> <span class="number">400</span></span><br></pre></td></tr></table></figure>
<h4 id="HTTPFaultInjection-Delay"><a href="#HTTPFaultInjection-Delay" class="headerlink" title="HTTPFaultInjection.Delay"></a>HTTPFaultInjection.Delay</h4><ul>
<li><strong>fixedDelay</strong>：必配项，表示请求响应的模拟处理时间。格式为：<code>1h/1m/1s/1ms</code>， 不能小于 <code>1ms</code>。</li>
<li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li>
<li><strong>percent</strong>：已经废弃的一个配置，与 <code>percentage</code> 配置功能一样，已经被 <code>percentage</code> 代替。</li>
</ul>
<p>如下的配置表示对 <code>v1</code> 版本的 <code>reviews.prod.svc.cluster.local</code> 服务访问的时候进行延时故障注入，<code>0.1</code> 表示有千分之一的请求被注入故障，<code>5s</code> 表示<code>reviews.prod.svc.cluster.local</code> 延时 <code>5s</code>返回。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure>
<h3 id="Mirroring"><a href="#Mirroring" class="headerlink" title="Mirroring"></a>Mirroring</h3><p>流量镜像（Mirroring / traffic-shadow），也叫作影子流量，就是通过复制一份请求并把它发送到镜像服务，从而实现流量的复制功能。流量镜像的主要应用场景有以下几种：最主要的就是进行<strong>线上问题排查</strong>。</p>
<p>一般情况下，因为系统环境，特别是数据环境、用户使用习惯等问题，我们很难在开发环境中模拟出真实的生产环境中出现的棘手问题，同时生产环境也不能记录太过详细的日志，因此很难定位到问题。有了流量镜像，我们就可以把真实的请求发送到镜像服务，再打开 debug 日志来查看详细的信息。除此以外，还可以通过它来观察生产环境的请求处理能力，比如在镜像服务进行压力测试。也可以将复制的请求信息用于数据分析。流量镜像在 Istio 里实现起来也非常简单，只需要在路由配置中通添加<code>mirror</code>关键字即可。</p>
<h4 id="流量镜像能够为我们带来什么"><a href="#流量镜像能够为我们带来什么" class="headerlink" title="流量镜像能够为我们带来什么"></a>流量镜像能够为我们带来什么</h4><p>很多情况下，当我们对服务做了重构，或者我们对项目做了重大优化时，怎么样保证服务是健壮的呢？在传统的服务里，我们只能通过大量的测试，模拟在各种情况下服务的响应情况。虽然也有手工测试、自动化测试、压力测试等一系列手段去检测它，但是测试本身就是一个样本化的行为，即使测试人员再完善它的测试样例，无法全面的表现出线上服务的一个真实流量形态。往往当项目发布之后，总会出现一些意外，比如你服务里收到客户使用的某些数据库不认识的特殊符号，再比如用户在本该输入日期的输入框中输入了 “—” 字样的字符，又比如用户使用乱码替换你的 token 值批量恶意攻击服务等等，这样的情况屡见不鲜。数据的多样性，复杂性决定了开发人员在开发阶段根本是无法考虑周全的。</p>
<p>而流量镜像的设计，让这类问题得到了最大限度的解决。流量镜像讲究的不再是使用少量样本去评估一个服务的健壮性，而是在不影响线上坏境的前提下将线上流量持续的镜像到我们的预发布坏境中去，让重构后的服务在上线之前就结结实实地接受一波真实流量的冲击与考验，让所有的风险全部暴露在上线前夕，通过不断的暴露问题，解决问题让服务在上线前夕就拥有跟线上服务一样的健壮性。由于测试坏境使用的是真实流量，所以不管从流量的多样性，真实性，还是复杂性上都将能够得以展现，同时预发布服务也将表现出其最真实的处理能力和对异常的处理能力。运用这种模式，一方面，我们将不会再跟以前一样在发布服务前夕内心始终忐忑不安，只能祈祷上线之后不会出现问题。另一方面，当大量的流量流入重构服务之后，开发过程中难以评估的性能问题也将完完整整的暴露出来，此时开发人员将会考虑它服务的性能，测试人员将会更加完善他们的测试样例。通过暴露问题，解决问题，再暴露问题，再解决问题的方式循序渐进地完善预发布服务来增加我们上线的成功率。同时也变相的促进我们开发测试人员技能水平的提高。</p>
<p>当然，流量镜像的作用不仅仅只是解决上面这样的场景问题，我们可以根据它的特性，解决更多的问题。比如，假如我们在上线后突然发现一个线上问题，而这个问题在测试坏境中始终不能复现。那么这个时候我们就能利用它将异常流量镜像到一个分支服务中去，然后我们可以随意在这个分支服务上进行分析调试，这里所说的分支服务，可以是原服务的只用于问题分析而不处理正式业务的副本服务，也可以是一个只收集镜像流量的组件类服务。又比如突然需要收集某个时间段某些流量的特征数据做分析，像这种临时性的需求，使用流量镜像来处理非常合适，既不影响线上服务的正常运转，也达到了收集分析的目的。</p>
<h4 id="流量镜像的实现原理"><a href="#流量镜像的实现原理" class="headerlink" title="流量镜像的实现原理"></a>流量镜像的实现原理</h4><p>实际上在 Istio 中，服务间的通讯都是被 Envoy代理拦截并处理的， Istio 流量镜像的设计也是基于 Envoy特性实现的。它的流量转发如下图所示。可以看到，当流量进入到<code>Service A</code>时，因为在<code>Service A</code>的 Envoy代理上配置了流量镜像规则，那么它首先会将原始流量转发到<code>v1</code>版本的 <code>Service B</code>服务子集中去 。同时也会将相同的流量复制一份，异步地发送给<code>v2</code>版本的<code>Service B</code> 服务子集中去，可以明显的看到，<code>Service A</code> 发送完镜像流量之后并不关心它的响应情况。</p>
<p>在很多情况下，我们需要将真实的流量数据与镜像流量数据进行收集并分析，那么当我们收集完成后应该怎样区分哪些是真实流量，哪些是镜像流量呢？ 实际上，Envoy团队早就考虑到了这样的场景，他们为了区分镜像流量与真实流量，在镜像流量中修改了请求标头中 <code>host</code> 值来标识，它的修改规则是：在原始流量请求标头中的 <code>host</code> 属性值拼接上<code>“-shadow”</code> 字样作为镜像流量的 <code>host</code> 请求标头。</p>
<p>为了能够更清晰的对比出原始流量与镜像流量的区别，我们使用以下的一个示例来说明：</p>
<p>如下图所示，我们发起一个<code>http://istio.gateway.xxxx.tech/serviceB/request/info</code>的请求，请求首先进入了<code>istio-ingressgateway</code> ，它是一个 Istio 的 Gateway 资源类型的服务，它本身就是一个 Envoy代理。在这个例子里，就是它对流量进行了镜像处理。可以看到，它将流量转发给<code>v1</code>版本<code>Service B</code>服务子集的同时也复制了一份流量发送到了<code>v2</code>版本的<code>Service B</code>服务子集中去。</p>
<p><img alt="concepts-traffic-shadow-request" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-request.png"></p>
<p>在上面的请求链中，请求标头数据有什么变化呢？下图收集了它们请求标头中的所有信息，可以明显的对比出正式流量与镜像流量请求标头中<code>host</code>属性的区别（部分相同的属性值过长，这里只截取了前半段）。从图中我们可以看出，首先就是host属性值的不同，而区别就是多了一个<code>“-shadow”</code>的后缀。再者发现<code>x-forwarded-for</code>属性也不相同，<code>x-forwarded-for</code>协议头的格式是：<code>x-forwarded-for: client1, proxy1, proxy2</code>， 当流量经过 Envoy代理时这个协议头将会把代理服务的 IP 添加进去。实例中<code>10.10.2.151</code>是我们云主机的 IP，而<code>10.10.2.121</code>是<code>isito-ingressgateway</code>所对应<code>Pod</code>的 IP 。从这里也能看到，镜像流量是由<code>istio-ingressgatway</code>发起的。除了这两个请求标头的不同，其他配置项是完全一样的。</p>
<p><img alt="concepts-traffic-shadow-header" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-header.png"></p>
<h4 id="流量镜像的配置"><a href="#流量镜像的配置" class="headerlink" title="流量镜像的配置"></a>流量镜像的配置</h4><p>上面我们介绍了流量镜像的原理及使用场景，接下来我们再介绍下流量的镜像如何配置才能生效。在 Istio 架构里，镜像流量是借助于 VirtualService 这个资源中的 <code>HTTPRoute</code> 配置项的<code>mirror</code>与<code>mirrorPercent</code>这两项子配置项来实现的，这两个配置项的定义也是非常的简单。</p>
<ul>
<li><strong>mirror</strong>：配置一个 Destination 类型的对象，这里就是我们镜像流量转发的服务地址。具体的 <strong>VirtualService</strong> 配置与<strong>DestinationRule</strong> 对象配置属性请参考相关介绍页。</li>
<li><strong>mirrorPercent</strong>：配置一个数值，这个配置项用来指定有多少的原始流量将被转发到镜像流量服务中去，它的有效值为<code>0~100</code>，如果配置成<code>0</code>则表示不发送镜像流量。</li>
</ul>
<p>下面的例子就是我们在示例中使用到的<code>Service B</code>的镜像流量配置，其中，<code>mirror.host</code>配置项是配置一个域名或者在Istio 注册表中注册过的服务名称，可以看到，该配置指定了镜像流量需要发送的目标服务地址为<code>serviceB</code>。<code>mirror.subset</code>配置项配置一个<code>Service B</code>服务的服务子集名称 ，指定了要将镜像流量镜像到<code>v2</code>版本的<code>Service B</code>服务子集中去。<code>mirror_percent</code>配置将<code>100%</code>的真实流量进行镜像发送。所以下面的配置整体表示当流量到来时，将请求转发到<code>v1</code>版本的<code>service B</code>服务子集中，再以镜像的方式发送到<code>v2</code>版本的<code>service B</code>服务上一份，并将真实流量全部镜像。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio.gateway.xxxx.tech</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingressgateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/serviceB</span></span><br><span class="line">    <span class="attr">rewrite:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">mirror:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">mirror_percent:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><code>service B</code> 服务对应的 DestinationRule 配置如下 ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>istio</tag>
        <tag>service mesh</tag>
        <tag>envoy</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes解读】CRD</title>
    <url>/posts/c57d800c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在 <a href="https://houmin.cc/tags/controller">Controller Manager 的系列文章</a> 中我们看到，Kubernetes 内置的各种 Controller 通过ApiServer监控 <a href="https://houmin.cc">Deployment</a>、<a href="https://houmin.cc">DaemonSet</a>、<a href="https://houmin.cc">StatefulSet </a>等内部资源对象，在一个控制循环中通过各种操作将系统维持在我们期望的一个状态中，这即是其经典的 <code>声明式API设计</code>。然而，内置的API资源大多仅代表相对底层和通用概念的对象，已经不能够满足越来越复杂的业务场景需求。随着Kubernetes生态系统的持续发展，我们将需要更多高层次的面向专门的场景的对象。在声明式API的原则下，设计自定义资源API，开发者将不需要逐一进行 Deployment、Service、ConfigMap 等步骤，而是创建并关联一些用于表述整个应用程序或者软件服务的对象。在当前，CoreOS推出的各种 <a href="https://coreos.com/operators/" target="_blank" rel="external nofollow noopener noreferrer">Operator</a> 即是这一思想的广泛利用。为了实现 Operator，你需要了解 <code>CRD（CustomResourceDefinitions）</code>。本文所有实现的代码，可以参考我的 <a href="https://github.com/SimpCosm/crddemo" target="_blank" rel="external nofollow noopener noreferrer">Github</a>。</p>
<a id="more"></a>
<h2 id="CRD使用方法"><a href="#CRD使用方法" class="headerlink" title="CRD使用方法"></a>CRD使用方法</h2><p>在 <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="external nofollow noopener noreferrer">Extend the Kubernetes API with CustomResourceDefinitions</a> 中介绍了使用CRD扩展Kubernetes API的详细用法，简单来说可以分为两步：</p>
<ul>
<li>利用CRD API声明自定义的资源API</li>
<li>根据刚才声明的资源API，创建自定义的资源对象</li>
</ul>
<h3 id="Create-CustomResourceDefinition"><a href="#Create-CustomResourceDefinition" class="headerlink" title="Create CustomResourceDefinition"></a>Create CustomResourceDefinition</h3><p>首先我们可以使用 <code>CustomResourceDefinition</code> 声明自定义的资源API，这里也可以将我们自定义的资源API理解为  <code>CustomResourceDefinition</code> 这个API的对象，我们可以指定它的 <code>metadata.name</code>。这里没有 <code>metadata.namespace</code>字段，是因为<code>CustomResourceDefinition</code> 适用于所有命名空间。</p>
<p>CRD定义中的关键字段如下：</p>
<ul>
<li>group：设置API所属的组，将其映射为API URL中的 “/apis/” 下一级目录。它是逻辑上相关的Kinds集合</li>
<li>scope：该API的生效范围，可选项为Namespaced和Cluster。</li>
<li>version：每个 Group 可以存在多个版本。例如，v1alpha1，然后升为 v1beta1，最后稳定为 v1 版本。</li>
<li>names：CRD的名称，包括单数、复数、kind、所属组等名称定义</li>
</ul>
<p><img alt="api url" data-src="https://lihaoquan.me/media/2020/202003081.png"></p>
<p>在下面的示例中，我们定义资源的Group是<code>example.houmin.cc</code>，version是v1，kind是Foo。这里的version是一个list，可以指定多个服务的版本，这里只是简单声明了v1这个版本，具体可以参考 <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="external nofollow noopener noreferrer">Extend the Kubernetes API with CustomResourceDefinitions</a> 和 <a href="https://github.com/kubernetes/apiextensions-apiserver/blob/cec7d1c927364a42e97ab2b400d5f15a953ab84d/pkg/apis/apiextensions/v1/types.go#L59" target="_blank" rel="external nofollow noopener noreferrer">源代码</a>。</p>
<figure class="highlight yaml"><figcaption><span>crd.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foos.example.houmin.cc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">example.houmin.cc</span></span><br><span class="line">  <span class="comment"># list of versions supported by this CustomResourceDefinition</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="comment"># kind is normally the CamelCased singular type. Your resource manifests use this.</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line">    <span class="comment"># plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span></span><br><span class="line">    <span class="attr">plural:</span> <span class="string">foos</span></span><br><span class="line">    <span class="comment"># singular name to be used as an alias on the CLI and for display</span></span><br><span class="line">    <span class="attr">singular:</span> <span class="string">foo</span></span><br><span class="line">    <span class="comment"># shortNames allow shorter string to match your resource on the CLI</span></span><br><span class="line">    <span class="attr">shortNames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">fo</span></span><br><span class="line">  <span class="comment"># either Namespaced or Cluster</span></span><br><span class="line">  <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br></pre></td></tr></table></figure>
<p>根据上面的manifest文件，即可创建CRD。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl create -f crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/foos.example.houmin.cc created</span><br></pre></td></tr></table></figure>
<h3 id="Create-custom-objects"><a href="#Create-custom-objects" class="headerlink" title="Create custom objects"></a>Create custom objects</h3><p>在声明了自定义资源后，就可以编辑下面这样的manifest文件，创建用户自定义资源的对象，就像 <code>Pod</code>等原生资源一样。</p>
<figure class="highlight yaml"><figcaption><span>example-foo.yaml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.houmin.cc/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">deploymentName:</span> <span class="string">example-foo</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>deploymentName</code> 和 <code>replicas</code> 都是我们自定义资源API的字段，在后面会详细介绍。使用kubectl创建资源后，我们发现CRD的使用和原生API资源毫无区别。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f example-foo.yaml</span></span><br><span class="line"><span class="string">foo.example.houmin.cc/example-foo</span> <span class="string">created</span></span><br><span class="line"><span class="comment"># kubectl get foo</span></span><br><span class="line"><span class="string">NAME</span>          <span class="string">AGE</span></span><br><span class="line"><span class="string">example-foo</span>   <span class="string">8s</span></span><br><span class="line"><span class="comment"># kubectl get foo -o yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">example.houmin.cc/v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">creationTimestamp:</span> <span class="string">"2020-10-27T13:32:15Z"</span></span><br><span class="line">    <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">example-foo</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">"294744500"</span></span><br><span class="line">    <span class="attr">selfLink:</span> <span class="string">/apis/example.houmin.cc/v1/namespaces/default/foos/example-foo</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">ece2daac-5510-4de1-b924-c8b1a5e178fd</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">deploymentName:</span> <span class="string">example-foo</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">List</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>经过上面的两步操作，我们已经能够自定义资源API并且使用它了。但是，在第一步和第二步之间还需要做一些工作，不然直接创建自定义资源对象是不会成功的。为什么呢？想一想，对于原生的资源API，比如Deployment，我们都有对应的Controller在 ApiServer 监听每一个Deployment 资源的创建，并随之创建对应的Pod和维护其状态。对于我们创建的CRD资源，我们也需要有对应的Controller做类似的工作。</p>
<p>另外，刚才提到我们创建的 <code>Foo</code>资源具有两个字段 <code>deploymentName</code> 和 <code>replicas</code>，这个都是我们自定义的，你也可以根据你的需要定义你自己的字段。每次创建 <code>Foo</code> 对象后，我们实现的 Controller 就会根据自己的逻辑去做自己的事情，比如这里就是维护 <code>replicas</code> 个 <code>deployment</code>，具体的工作流程如下图所示。</p>
<p><img alt="crd arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p>
<p>CRD控制器的工作流，可分为监听、同步、触发三个步骤：</p>
<ul>
<li>Controller 首先会通过 Informer 从 API Server中获取它所关心的对象，这里就是上面的Foo对象。<ul>
<li>值得注意的是Informer在构建之前，会使用我们生成的client（下面编码阶段会提到）,再透过Reflector的ListAndWatch机制跟API Server建立连接，不断地监听 Foo 对象实例的变化。</li>
<li>在 ListAndWatch 机制下，一旦 APIServer 端有新的 Foo 实例被创建、删除或者更新，Reflector 都会收到 <strong>事件通知</strong>。</li>
<li>该事件及它对应的 API 对象会被放进一个 Delta FIFO Queue中。</li>
</ul>
</li>
<li>Local Store 此时完成同步缓存操作</li>
<li>Informer 根据这些事件的类型，触发我们编写并注册好的ResourceEventHandler，完成业务动作的触发。</li>
</ul>
<p>上面图中的 Control Loop 实际上可以通过code-generator生成，下面也会提到。总之Control Loop中我们只关心如何拿到 <strong>Current State</strong>，并与 <strong>Desired State</strong> 对比，从而具体的差异处理逻辑，只需要开发者自行编写即可。</p>
<h2 id="定义CRD资源"><a href="#定义CRD资源" class="headerlink" title="定义CRD资源"></a>定义CRD资源</h2><p>首先，kubernetes涉及的代码生成对项目目录结构是有要求的，所以我们先创建一个结构如下的项目，可见关键在于pkg目录就是API组的URL结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── artifacts</span><br><span class="line">│   └── examples</span><br><span class="line">│       ├── crd.yaml</span><br><span class="line">│       └── example-foo.yaml</span><br><span class="line">├── controller.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">├── main.go</span><br><span class="line">└── pkg</span><br><span class="line">    └── apis</span><br><span class="line">        └── example</span><br><span class="line">            ├── register.go</span><br><span class="line">            └── v1</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── register.go</span><br><span class="line">                └── types.go</span><br></pre></td></tr></table></figure>
<ol>
<li>我们首先开看 <code>pkg/apis/example/register.go</code>，这个文件主要用来存放全局变量，如下：</li>
</ol>
<figure class="highlight go"><figcaption><span>pkg/apis/example/register.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	GroupName = <span class="string">"example.houmin.cc"</span></span><br><span class="line">	Version   = <span class="string">"v1"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>pkg/apis/example/v1/doc.go</code>  主要是 <code>global tags</code>，起到的是全局的代码生成控制的作用，详见代码生成解释。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"><span class="comment">// +groupName=example.houmin.cc</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure>
<ol>
<li><code>pkg/apis/example/v1/types</code> 的作用就是定义一个 Foo 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：</li>
</ol>
<figure class="highlight go"><figcaption><span>pkg/apis/example/v1/types</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	Spec   FooSpec   <span class="string">`json:"spec"`</span></span><br><span class="line">	Status FooStatus <span class="string">`json:"status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooSpec is the spec for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	DeploymentName <span class="keyword">string</span> <span class="string">`json:"deploymentName"`</span></span><br><span class="line">	Replicas       *<span class="keyword">int32</span> <span class="string">`json:"replicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooStatus is the status for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	AvailableReplicas <span class="keyword">int32</span> <span class="string">`json:"availableReplicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	metav1.ListMeta <span class="string">`json:"metadata"`</span></span><br><span class="line"></span><br><span class="line">	Items []Foo <span class="string">`json:"items"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，可以看到我们的<code>Foo</code>定义方法跟k8s对象一样，都包含了 <code>TypeMeta</code> 和 <code>ObjectMeta</code>字段，而其中比较重要的是 <code>Spec</code> 字段和 <code>Status</code> 字段，这个可以根据用户需要自定义。</p>
<p>此外，除了定义 <code>Foo</code> 类型，你还需要定义一个 <code>FooList</code> 类型，用来描述一组 <code>Foo</code> 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有某对象的 List() 方法，返回值都是List 类型，而不是某类型的数组。所以代码上一定要做区分</p>
<p>除此之外，还有几个作为 <code>local tags</code> 存在的注释，主要用于控制代码生成，详见下一小节。</p>
<ol>
<li><code>pkg/apis/example/register.go</code> 作用就是注册一个类型（Type）给 APIServer。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/SimpCosm/crddemo/pkg/apis/example"</span></span><br><span class="line"></span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/runtime"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/runtime/schema"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;</span><br><span class="line">	Group:   example.GroupName,</span><br><span class="line">	Version: example.Version,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">	AddToScheme   = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupResource</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Kind</span><span class="params">(kind <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupKind</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	scheme.AddKnownTypes(</span><br><span class="line">		SchemeGroupVersion,</span><br><span class="line">		&amp;Foo&#123;&#125;,</span><br><span class="line">		&amp;FooList&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register the type in the scheme</span></span><br><span class="line">	metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 <code>addKnownTypes</code> 这个方法，Kubernetes 就能够在后面生成客户端的时候，知道 <code>Foo</code> 以及<code>FooList</code> 类型的定义了。</p>
<p>好了，到这里为止，我们有关定义的代码已经写好了，正如controller原理图所示，接下来我们需要通过kubernetes提供的代码生成工具，为上面的<code>Foo</code>资源类型生成clientset、informer 和 lister。</p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>kubernetes社区有一个<a href="https://github.com/kubernetes/code-generator" target="_blank" rel="external nofollow noopener noreferrer">k8s.io/code-generator</a> 仓库，在里面提供了一系列代码生成工具：</p>
<ul>
<li><code>deepcopy-gen</code>：为每个类型T创建了 <code>func (t *T) DeepCopy() *T</code>方法</li>
<li><code>client-gen</code>：为CustomeResource APIGroups 创建 typed clientsets</li>
<li><code>informer-gen</code>：为CustomResource创建informers，能够监听到服务端CustomResource发生变化的事件</li>
<li><code>lister-gen</code>：为CustomResource创建listers，能够为GET/LIST请求提供一个read only的Caching Layer</li>
</ul>
<p>其中生成的 informer 和 lister 是创建Controller的基础，通过这四个generator就可以创建一个 <code>full-featured, producation-ready</code>的controller。除此之外，<code>code-generator</code>还提供了其他的生成工具，比如 <code>conversion-gen</code> 提供了API内部版本和外部版本的转换函数，<code>defaulter-gen</code>提供了产生默认的字段的工具。</p>
<p>所有的这些code-generator都是基于<a href="https://github.com/kubernetes/gengo" target="_blank" rel="external nofollow noopener noreferrer">k8s.io/gengo</a>实现的，他们有一些共同的命令行参数，比如 <code>--input-dirs</code> 获得input package，<code>--output-package</code> 指定生成的package的目录。但是我们不需要去一个一个指定各个命令行参数， <a href="https://github.com/kubernetes/code-generator" target="_blank" rel="external nofollow noopener noreferrer">k8s.io/code-generator</a> 提供了一个Shell脚本 <a href="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh" target="_blank" rel="external nofollow noopener noreferrer">generator-group.sh</a> 来便于在CRD开发过程中的代码生成。只需一行代码，通常在 <code>hack/update-codegen.sh</code>中即可调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vendor/k8s.io/code-generator/generate-groups.sh all \ <span class="comment"># GENS="$1"</span></span><br><span class="line">github.com/SimpCosm/crddemo/pkg/client \ <span class="comment"># OUTPUT_PKG="$2"</span></span><br><span class="line">github.com/SimpCosm/crddemo/pkg/apis \   <span class="comment"># APIS_PKG="$3"</span></span><br><span class="line">example.houmin.cc:v1 <span class="comment"># GROUPS_WITH_VERSIONS="$4"</span></span><br></pre></td></tr></table></figure>
<p>执行命令后，可以看到 <code>pkg</code> 下代码生成如下，在 <code>pkg/apis</code>目录下，除了原有的代码，生成了 <code>zz_generated_deepcopy.go</code> 的代码， <code>pkg/client</code> 目录则是完全生成的，包括 <code>clientset</code>、<code>informers</code>、<code>listers</code>等代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg</span><br><span class="line">├── apis</span><br><span class="line">│   └── example</span><br><span class="line">│       ├── register.go</span><br><span class="line">│       └── v1</span><br><span class="line">│           ├── doc.go</span><br><span class="line">│           ├── register.go</span><br><span class="line">│           ├── types.go</span><br><span class="line">│           └── zz_generated.deepcopy.go</span><br><span class="line">└── client</span><br><span class="line">    ├── clientset</span><br><span class="line">    │   └── versioned</span><br><span class="line">    │       ├── clientset.go</span><br><span class="line">    │       ├── doc.go</span><br><span class="line">    │       ├── fake</span><br><span class="line">    │       ├── scheme</span><br><span class="line">    │       └── typed</span><br><span class="line">    ├── informers</span><br><span class="line">    │   └── externalversions</span><br><span class="line">    │       ├── example</span><br><span class="line">    │       ├── factory.go</span><br><span class="line">    │       ├── generic.go</span><br><span class="line">    │       └── internalinterfaces</span><br><span class="line">    └── listers</span><br><span class="line">        └── example</span><br><span class="line">            └── v1</span><br></pre></td></tr></table></figure>
<p>这些生成的代码都是不允许手动修改的，一般你需要修改 <code>pkg/apis</code>下面的源码后，再去通过执行 <code>hack/update-codegen.sh</code> 来生成新的代码。</p>
<p>我们可以通过 <code>code-generator</code> 来控制代码生成的一些参数，但是代码生成更多的属性是通过Go代码中的Tags来控制。这里有两种类型的Tag：</p>
<ul>
<li>Global Tags：全局Tags，在 <code>doc.go</code> 中位于 <code>package</code>之上</li>
<li>Local Tags：局部Tags</li>
</ul>
<p>Tags一般的形式是 <code>// +tag-name</code> 或者 <code>// +tag-name=value</code>，以注释的形式存在。一般来说，Tags存在的位置很重要，有些tag必须直接在type之上，有些tag必须和type间隔一行，具体可以参见pull request <a href="https://github.com/kubernetes/kubernetes/pull/53579" target="_blank" rel="external nofollow noopener noreferrer">#53579</a> and issue <a href="https://github.com/kubernetes/kubernetes/issues/53893" target="_blank" rel="external nofollow noopener noreferrer">#53893</a>。</p>
<h3 id="Global-Tags"><a href="#Global-Tags" class="headerlink" title="Global Tags"></a>Global Tags</h3><p> <code>Global Tags</code> 是定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，具体如下所示，在这个文件中，你会看到 <code>+k8s:deepcopy-gen=package</code> 和 <code>+groupName=crddemo.k8s.io</code>，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。</p>
<figure class="highlight go"><figcaption><span>pkg/apis/crddemo/v1/doc.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"><span class="comment">// +groupName=example.houmin.cc</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>+k8s:deepcopy-gen=package</code> 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；</li>
<li><code>+groupName=example.houmin.cc</code>，则定义了这个包对应的crddemo API 组的名字，注意这个注释必须就在package之上 (see <a href="https://github.com/kubernetes/kubernetes/issues/53893" target="_blank" rel="external nofollow noopener noreferrer">Issue #53893</a>).</li>
</ul>
<p>如果你有一些Type不需要 <code>deepcopy</code>，那么你可以通过一个 Local Tag <code>// +k8s:deepcopy-gen=false</code> 来为这个 Typo 不生成 <code>deep copy</code>。如果没有打开package全局生成 <code>deepcopy</code>的开关，你可以对每个你想要的Type使用Local Tag <code>// +k8s:deepcopy-gen=true</code> 为它生成 <code>deepcopy</code>。</p>
<h3 id="Local-Tags"><a href="#Local-Tags" class="headerlink" title="Local Tags"></a>Local Tags</h3><p>Local Tags 是直接写在 API Types 之上的注释，下面是一个例子。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	Spec   FooSpec   <span class="string">`json:"spec"`</span></span><br><span class="line">	Status FooStatus <span class="string">`json:"status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooSpec is the spec for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	DeploymentName <span class="keyword">string</span> <span class="string">`json:"deploymentName"`</span></span><br><span class="line">	Replicas       *<span class="keyword">int32</span> <span class="string">`json:"replicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooStatus is the status for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	AvailableReplicas <span class="keyword">int32</span> <span class="string">`json:"availableReplicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	metav1.ListMeta <span class="string">`json:"metadata"`</span></span><br><span class="line"></span><br><span class="line">	Items []Foo <span class="string">`json:"items"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个 <code>deepcopy</code> tag解释如下：</p>
<ul>
<li><code>+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code> 的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。</li>
</ul>
<p>在上面的示例中，有部分tag用于控制 <code>client-gen</code>，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>+genclient</code> 这段注解的意思是：请为下面资源类型生成对应的 Client 代码。因为Foo才是主类型，所以 +genclient 要写在Mydemo之上，不用写在 <code>FooList</code> 之上，这是要细心注意的。</li>
<li><code>+genclient:noStatus</code> 的意思是：这个 API 资源类型定义里，没有 Status 字段，这个tag告诉 <code>client-gen</code> 不要生成 <code>UpdateStatus</code>方法，一般用于使用子资源分离的例如/status分离的，用来避免更新到status资源(当然代码的struct中也没有status)</li>
</ul>
<p>对于 <code>cluster-wide</code>的资源，你需要使用下面的tag</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +genclient:nonNamespaced</span></span><br></pre></td></tr></table></figure>
<p>有时候你想控制client提供的HTTP方法，你可以使用类似于下面的tag</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +genclient:noVerbs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient:onlyVerbs=create,delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient:skipVerbs=get,list,create,update,patch,delete,deleteCollection,watch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient:method=Create,verb=create,result=k8s.io/apimachinery/pkg/apis/meta/v1.Status</span></span><br></pre></td></tr></table></figure>
<p>前三个很好理解，指定了client可以使用的verb。对于第四个tag，这里对应的Type只能是 create-only，并且不会返回 API Type本身，而是返回了 <code>metav1.Status</code>。</p>
<h2 id="Controller开发"><a href="#Controller开发" class="headerlink" title="Controller开发"></a>Controller开发</h2><p>在代码生成 <code>informers</code>、<code>clients</code>、<code>listers</code>等代码后，我们就可以用这些API编写Controller的代码了。</p>
<h3 id="主函数实现"><a href="#主函数实现" class="headerlink" title="主函数实现"></a>主函数实现</h3><p>我们可以像使用原生 kubernetes client一样，使用我们生成的client，如下所示：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	kubeinformers <span class="string">"k8s.io/client-go/informers"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/tools/clientcmd"</span></span><br><span class="line">	<span class="string">"k8s.io/klog/v2"</span></span><br><span class="line"></span><br><span class="line">	clientset <span class="string">"github.com/SimpCosm/crddemo/pkg/client/clientset/versioned"</span></span><br><span class="line">	informers <span class="string">"github.com/SimpCosm/crddemo/pkg/client/informers/externalversions"</span></span><br><span class="line">	<span class="string">"github.com/SimpCosm/crddemo/pkg/signals"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	masterURL  <span class="keyword">string</span></span><br><span class="line">	kubeconfig <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up signals so we handle the first shutdown signal gracefully</span></span><br><span class="line">	stopCh := signals.SetupSignalHandler()</span><br><span class="line"></span><br><span class="line">	cfg, err := clientcmd.BuildConfigFromFlags(masterURL, kubeconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Error building kubeconfig: %s"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kubeClient, err := kubernetes.NewForConfig(cfg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Error building kubernetes clientset: %s"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	exampleClient, err := clientset.NewForConfig(cfg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Error building example clientset: %s"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Second*<span class="number">30</span>)</span><br><span class="line">	exampleInformerFactory := informers.NewSharedInformerFactory(exampleClient, time.Second*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">	controller := NewController(kubeClient, exampleClient,</span><br><span class="line">		kubeInformerFactory.Apps().V1().Deployments(),</span><br><span class="line">		exampleInformerFactory.Example().V1().Foos())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// notice that there is no need to run Start methods in a separate goroutine. (i.e. go kubeInformerFactory.Start(stopCh)</span></span><br><span class="line">	<span class="comment">// Start method is non-blocking and runs all registered informers in a dedicated goroutine.</span></span><br><span class="line">	kubeInformerFactory.Start(stopCh)</span><br><span class="line">	exampleInformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err = controller.Run(<span class="number">2</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Error running controller: %s"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;kubeconfig, <span class="string">"kubeconfig"</span>, <span class="string">""</span>, <span class="string">"Path to a kubeconfig. Only required if out-of-cluster."</span>)</span><br><span class="line">	flag.StringVar(&amp;masterURL, <span class="string">"master"</span>, <span class="string">""</span>, <span class="string">"The address of the Kubernetes API server. Overrides any value in kubeconfig. Only required if out-of-cluster."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller定义"><a href="#Controller定义" class="headerlink" title="Controller定义"></a>Controller定义</h3><p>这里我们定义了自己的Controller：</p>
<ul>
<li>分别有原生的kubernetes clientset和自定义API group的clientset。</li>
<li>因为我们会监听原生的 <code>Deployment</code>和自己的 <code>Foo</code>，所以分别加上了各自的lister。</li>
<li>每次资源发生改变时，会将其放入到workqueue等待处理在Control Loop中处理。</li>
</ul>
<figure class="highlight go"><figcaption><span>controller.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Controller is the controller implementation for Foo resources</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// kubeclientset is a standard kubernetes clientset</span></span><br><span class="line">	kubeclientset kubernetes.Interface</span><br><span class="line">	<span class="comment">// sampleclientset is a clientset for our own API group</span></span><br><span class="line">	sampleclientset clientset.Interface</span><br><span class="line"></span><br><span class="line">	deploymentsLister appslisters.DeploymentLister</span><br><span class="line">	deploymentsSynced cache.InformerSynced</span><br><span class="line">	foosLister        listers.FooLister</span><br><span class="line">	foosSynced        cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// workqueue is a rate limited work queue. This is used to queue work to be</span></span><br><span class="line">	<span class="comment">// processed instead of performing it as soon as a change happens. This</span></span><br><span class="line">	<span class="comment">// means we can ensure we only process a fixed amount of resources at a</span></span><br><span class="line">	<span class="comment">// time, and makes it easy to ensure we are never processing the same item</span></span><br><span class="line">	<span class="comment">// simultaneously in two different workers.</span></span><br><span class="line">	workqueue workqueue.RateLimitingInterface</span><br><span class="line">	<span class="comment">// recorder is an event recorder for recording Event resources to the</span></span><br><span class="line">	<span class="comment">// Kubernetes API.</span></span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller创建"><a href="#Controller创建" class="headerlink" title="Controller创建"></a>Controller创建</h3><p>接下来，我们来看跟业务最紧密的控制器Controller的编写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewController returns a new sample controller</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeclientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	sampleclientset clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	deploymentInformer appsinformers.DeploymentInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	fooInformer informers.FooInformer)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create event broadcaster</span></span><br><span class="line">	<span class="comment">// Add example types to the default Kubernetes Scheme so Events can be</span></span><br><span class="line">	<span class="comment">// logged for example types.</span></span><br><span class="line">	utilruntime.Must(samplescheme.AddToScheme(scheme.Scheme))</span><br><span class="line">	klog.V(<span class="number">4</span>).Info(<span class="string">"Creating event broadcaster"</span>)</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl&#123;Interface: kubeclientset.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: controllerAgentName&#125;)</span><br><span class="line"></span><br><span class="line">	controller := &amp;Controller&#123;</span><br><span class="line">		kubeclientset:     kubeclientset,</span><br><span class="line">		sampleclientset:   sampleclientset,</span><br><span class="line">		deploymentsLister: deploymentInformer.Lister(),</span><br><span class="line">		deploymentsSynced: deploymentInformer.Informer().HasSynced,</span><br><span class="line">		foosLister:        fooInformer.Lister(),</span><br><span class="line">		foosSynced:        fooInformer.Informer().HasSynced,</span><br><span class="line">		workqueue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"Foos"</span>),</span><br><span class="line">		recorder:          recorder,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.Info(<span class="string">"Setting up event handlers"</span>)</span><br><span class="line">	<span class="comment">// Set up an event handler for when Foo resources change</span></span><br><span class="line">	fooInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: controller.enqueueFoo,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			controller.enqueueFoo(<span class="built_in">new</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: controller.handleObject,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			newDepl := <span class="built_in">new</span>.(*appsv1.Deployment)</span><br><span class="line">			oldDepl := old.(*appsv1.Deployment)</span><br><span class="line">			<span class="keyword">if</span> newDepl.ResourceVersion == oldDepl.ResourceVersion &#123;</span><br><span class="line">				<span class="comment">// Periodic resync will send update events for all known Deployments.</span></span><br><span class="line">				<span class="comment">// Two different versions of the same Deployment will always have different RVs.</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			controller.handleObject(<span class="built_in">new</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: controller.handleObject,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面Controller的代码实现，我们基本实现了控制器ListAndWatch的事件注册逻辑：通过 APIServer 的 LIST API获取所有最新版本的 API 对象；然后，再通过 WATCH-API 来监听所有这些API对象的变化。通过监听到的事件变化，Informer 就可以实时地更新本地缓存，并且调用这些事件对应的 EventHandler了。</p>
<h3 id="Control-Loop"><a href="#Control-Loop" class="headerlink" title="Control Loop"></a>Control Loop</h3><p>下面，我们再来看原理图中的Control Loop的部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(threadiness <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> c.workqueue.ShutDown()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the informer factories to begin populating the informer caches</span></span><br><span class="line">	klog.Info(<span class="string">"Starting Foo controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for the caches to be synced before starting workers</span></span><br><span class="line">	klog.Info(<span class="string">"Waiting for informer caches to sync"</span>)</span><br><span class="line">	<span class="keyword">if</span> ok := cache.WaitForCacheSync(stopCh, c.deploymentsSynced, c.foosSynced); !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to wait for caches to sync"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.Info(<span class="string">"Starting workers"</span>)</span><br><span class="line">	<span class="comment">// Launch two workers to process Foo resources</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threadiness; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.Info(<span class="string">"Started workers"</span>)</span><br><span class="line">	&lt;-stopCh</span><br><span class="line">	klog.Info(<span class="string">"Shutting down workers"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，启动控制循环的逻辑非常简单，就是同步+循环监听任务。而这个循环监听任务就是我们真正的业务实现部分了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runWorker is a long-running function that will continually call the</span></span><br><span class="line"><span class="comment">// processNextWorkItem function in order to read and process a message on the</span></span><br><span class="line"><span class="comment">// workqueue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> c.processNextWorkItem() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processNextWorkItem will read a single work item off the workqueue and</span></span><br><span class="line"><span class="comment">// attempt to process it, by calling the syncHandler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	obj, shutdown := c.workqueue.Get()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> shutdown &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We wrap this block in a func so we can defer c.workqueue.Done.</span></span><br><span class="line">	err := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// We call Done here so the workqueue knows we have finished</span></span><br><span class="line">		<span class="comment">// processing this item. We also must remember to call Forget if we</span></span><br><span class="line">		<span class="comment">// do not want this work item being re-queued. For example, we do</span></span><br><span class="line">		<span class="comment">// not call Forget if a transient error occurs, instead the item is</span></span><br><span class="line">		<span class="comment">// put back on the workqueue and attempted again after a back-off</span></span><br><span class="line">		<span class="comment">// period.</span></span><br><span class="line">		<span class="keyword">defer</span> c.workqueue.Done(obj)</span><br><span class="line">		<span class="keyword">var</span> key <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">		<span class="comment">// We expect strings to come off the workqueue. These are of the</span></span><br><span class="line">		<span class="comment">// form namespace/name. We do this as the delayed nature of the</span></span><br><span class="line">		<span class="comment">// workqueue means the items in the informer cache may actually be</span></span><br><span class="line">		<span class="comment">// more up to date that when the item was initially put onto the</span></span><br><span class="line">		<span class="comment">// workqueue.</span></span><br><span class="line">		<span class="keyword">if</span> key, ok = obj.(<span class="keyword">string</span>); !ok &#123;</span><br><span class="line">			<span class="comment">// As the item in the workqueue is actually invalid, we call</span></span><br><span class="line">			<span class="comment">// Forget here else we'd go into a loop of attempting to</span></span><br><span class="line">			<span class="comment">// process a work item that is invalid.</span></span><br><span class="line">			c.workqueue.Forget(obj)</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"expected string in workqueue but got %#v"</span>, obj))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Run the syncHandler, passing it the namespace/name string of the</span></span><br><span class="line">		<span class="comment">// Foo resource to be synced.</span></span><br><span class="line">		<span class="keyword">if</span> err := c.syncHandler(key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Put the item back on the workqueue to handle any transient errors.</span></span><br><span class="line">			c.workqueue.AddRateLimited(key)</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error syncing '%s': %s, requeuing"</span>, key, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Finally, if no error occurs we Forget this item so it does not</span></span><br><span class="line">		<span class="comment">// get queued again until another change happens.</span></span><br><span class="line">		c.workqueue.Forget(obj)</span><br><span class="line">		klog.Infof(<span class="string">"Successfully synced '%s'"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;(obj)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的 <code>fooInformer</code>，从namespace中通过key获取 <code>Foo</code> 对象这个操作，其实就是在访问本地缓存的索引，实际上，在 Kubernetes 的源码中，你会经常看到控制器从各种 Lister 里获取对象，比如：podLister、nodeLister 等等，它们使用的都是 Informer 和缓存机制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syncHandler compares the actual state with the desired, and attempts to</span></span><br><span class="line"><span class="comment">// converge the two. It then updates the Status block of the Foo resource</span></span><br><span class="line"><span class="comment">// with the current status of the resource.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">syncHandler</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Convert the namespace/name string into a distinct namespace and name</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"invalid resource key: %s"</span>, key))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the Foo resource with this namespace/name</span></span><br><span class="line">	foo, err := c.foosLister.Foos(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// The Foo resource may no longer exist, in which case we stop</span></span><br><span class="line">		<span class="comment">// processing.</span></span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"foo '%s' in work queue no longer exists"</span>, key))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deploymentName := foo.Spec.DeploymentName</span><br><span class="line">	<span class="keyword">if</span> deploymentName == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// We choose to absorb the error here as the worker would requeue the</span></span><br><span class="line">		<span class="comment">// resource otherwise. Instead, the next time the resource is updated</span></span><br><span class="line">		<span class="comment">// the resource will be queued again.</span></span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: deployment name must be specified"</span>, key))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the deployment with the name specified in Foo.spec</span></span><br><span class="line">	deployment, err := c.deploymentsLister.Deployments(foo.Namespace).Get(deploymentName)</span><br><span class="line">	<span class="comment">// If the resource doesn't exist, we'll create it</span></span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		deployment, err = c.kubeclientset.AppsV1().Deployments(foo.Namespace).Create(context.TODO(), newDeployment(foo), metav1.CreateOptions&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If an error occurs during Get/Create, we'll requeue the item so we can</span></span><br><span class="line">	<span class="comment">// attempt processing again later. This could have been caused by a</span></span><br><span class="line">	<span class="comment">// temporary network failure, or any other transient reason.</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the Deployment is not controlled by this Foo resource, we should log</span></span><br><span class="line">	<span class="comment">// a warning to the event recorder and return error msg.</span></span><br><span class="line">	<span class="keyword">if</span> !metav1.IsControlledBy(deployment, foo) &#123;</span><br><span class="line">		msg := fmt.Sprintf(MessageResourceExists, deployment.Name)</span><br><span class="line">		c.recorder.Event(foo, corev1.EventTypeWarning, ErrResourceExists, msg)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(msg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this number of the replicas on the Foo resource is specified, and the</span></span><br><span class="line">	<span class="comment">// number does not equal the current desired replicas on the Deployment, we</span></span><br><span class="line">	<span class="comment">// should update the Deployment resource.</span></span><br><span class="line">	<span class="keyword">if</span> foo.Spec.Replicas != <span class="literal">nil</span> &amp;&amp; *foo.Spec.Replicas != *deployment.Spec.Replicas &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Foo %s replicas: %d, deployment replicas: %d"</span>, name, *foo.Spec.Replicas, *deployment.Spec.Replicas)</span><br><span class="line">		deployment, err = c.kubeclientset.AppsV1().Deployments(foo.Namespace).Update(context.TODO(), newDeployment(foo), metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If an error occurs during Update, we'll requeue the item so we can</span></span><br><span class="line">	<span class="comment">// attempt processing again later. This could have been caused by a</span></span><br><span class="line">	<span class="comment">// temporary network failure, or any other transient reason.</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, we update the status block of the Foo resource to reflect the</span></span><br><span class="line">	<span class="comment">// current state of the world</span></span><br><span class="line">	err = c.updateFooStatus(foo, deployment)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.recorder.Event(foo, corev1.EventTypeNormal, SuccessSynced, MessageResourceSynced)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果控制循环从缓存中拿不到这个对象（<code>fooInformer</code> 返回了 IsNotFound 错误），那就意味着这个 <code>Foo</code>  对象的 Key 是通过前面的“删除”事件添加进工作队列的。所以，尽管队列里有这个 Key，但是对应的 <code>Foo</code>  对象已经被删除了。而如果能够获取到对应的 <code>Foo</code>  对象，就可以执行控制器模式里的对比 <code>Desired State</code> 和 <code>CurrentState</code> 的功能逻辑了。</p>
<p>至此，一个完整的自定义 API 对象和它所对应的自定义控制器，就编写完毕了。</p>
<h2 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h2><p>编译完成后，会生成 <em>crddemo</em> 的二进制文件，我们要做把crddemo放到kubernetes集群中，或者本地也行，只要能访问到 <code>apiserver</code> 和具备<code>kubeconfig</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./crddemo --kubeconfig=.kube/config</span></span><br><span class="line">I1106 10:47:59.055510   11946 controller.go:115] Setting up event handlers</span><br><span class="line">I1106 10:47:59.055608   11946 controller.go:156] Starting Foo controller</span><br><span class="line">I1106 10:47:59.055620   11946 controller.go:159] Waiting <span class="keyword">for</span> informer caches to sync</span><br><span class="line">E1106 10:47:59.079342   11946 reflector.go:138] pkg/client/informers/externalversions/factory.go:116: Failed to watch *v1.Foo: failed to list *v1.Foo: the server could not find the requested resource (get foos.example.houmin.cc)</span><br><span class="line">E1106 10:48:00.369747   11946 reflector.go:138] pkg/client/informers/externalversions/factory.go:116: Failed to watch *v1.Foo: failed to list *v1.Foo: the server could not find the requested resource (get foos.example.houmin.cc)</span><br><span class="line">E1106 10:48:03.038137   11946 reflector.go:138] pkg/client/informers/externalversions/factory.go:116: Failed to watch *v1.Foo: failed to list *v1.Foo: the server could not find the requested resource (get foos.example.houmin.cc)</span><br></pre></td></tr></table></figure>
<p>可以看到，程序运行的时候，一开始会报错。这是因为，此时 Mydemo 对象的 CRD 还没有被创建出来，所以 Informer 去 APIServer 里获取 Mydemos 对象时，并不能找到 Mydemo 这个 API 资源类型的定义</p>
<p>接下来，我们执行我们自定义资源的定义文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  kubectl apply -f artifacts/examples/crd.yaml </span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/foos.example.houmin.cc created</span><br></pre></td></tr></table></figure>
<p>此时，观察crddemo的日志输出，可以看到Controller的日志恢复了正常，控制循环启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I0308 12:30:29.956263   28282 controller.go:113] Starting workers</span><br><span class="line">I0308 12:30:29.956307   28282 controller.go:118] Started workers</span><br></pre></td></tr></table></figure>
<p>然后，我们可以对我们的Mydemo对象进行增删改查操作了。</p>
<p>提交我们的自定义资源对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f artifacts/examples/example-foo.yaml </span></span><br><span class="line">foo.example.houmin.cc/example-foo created</span><br></pre></td></tr></table></figure>
<p>创建成功够，看k8s集群是否成功存储起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get foo</span></span><br><span class="line">NAME          AGE</span><br><span class="line">example-foo   8s</span><br></pre></td></tr></table></figure>
<p>这时候，查看一下控制器的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./crddemo --kubeconfig=.kube/config</span></span><br><span class="line">I1106 10:50:36.627136   12768 controller.go:115] Setting up event handlers</span><br><span class="line">I1106 10:50:36.627225   12768 controller.go:156] Starting Foo controller</span><br><span class="line">I1106 10:50:36.627235   12768 controller.go:159] Waiting <span class="keyword">for</span> informer caches to sync</span><br><span class="line">I1106 10:50:36.727340   12768 controller.go:164] Starting workers</span><br><span class="line">I1106 10:50:36.727364   12768 controller.go:170] Started workers</span><br><span class="line">I1106 10:51:27.596870   12768 controller.go:228] Successfully synced <span class="string">'default/example-foo'</span></span><br><span class="line">I1106 10:51:27.597113   12768 event.go:291] <span class="string">"Event occurred"</span> object=<span class="string">"default/example-foo"</span> kind=<span class="string">"Foo"</span> apiVersion=<span class="string">"example.houmin.cc/v1"</span> <span class="built_in">type</span>=<span class="string">"Normal"</span> reason=<span class="string">"Synced"</span> message=<span class="string">"Foo synced successfully"</span></span><br><span class="line">I1106 10:51:27.612272   12768 controller.go:228] Successfully synced <span class="string">'default/example-foo'</span></span><br><span class="line">I1106 10:51:27.612393   12768 event.go:291] <span class="string">"Event occurred"</span> object=<span class="string">"default/example-foo"</span> kind=<span class="string">"Foo"</span> apiVersion=<span class="string">"example.houmin.cc/v1"</span> <span class="built_in">type</span>=<span class="string">"Normal"</span> reason=<span class="string">"Synced"</span> message=<span class="string">"Foo synced successfully"</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们上面创建 example-mydemo.yaml 的操作，触发了 EventHandler 的添加事件，从而被放进了工作队列。紧接着，控制循环就从队列里拿到了这个对象，并且打印出了正在处理这个 Foo 对象的日志。</p>
<p>同时我们可以看到，与Foo相关的Deployment也同时被创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get deployment</span></span><br><span class="line">NAME          READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">example-foo   1/1     1            1           76s</span><br></pre></td></tr></table></figure>
<p>我们这时候，尝试修改资源，对对应的replicas属性进行修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.houmin.cc/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">deploymentName:</span> <span class="string">example-foo</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>手动执行修改:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f artifacts/examples/example-foo.yaml</span></span><br></pre></td></tr></table></figure>
<p>同时我们可以看到，与Foo相关的Deployment的副本数也同时增加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get deployment</span></span><br><span class="line">NAME          READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">example-foo   3/3     3            3           2m34s</span><br></pre></td></tr></table></figure>
<p>我们这时候，尝试修改资源，对对应的replicas属性进行修改</p>
<p>可以看到，这一次，Informer 注册的更新事件被触发，更新后的 Foo 对象的 Key 被添加到了工作队列之中。</p>
<p>所以，接下来控制循环从工作队列里拿到的 Foo 对象，与前一个对象是不同的：它的<code>ResourceVersion</code>的值发生了改变；而 Spec 里的Replicas 字段，则变成了3。最后，我再把这个对象删除掉：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  kubectl delete -f artifacts/examples/example-foo.yaml </span><br><span class="line">foo.example.houmin.cc <span class="string">"example-foo"</span> deleted</span><br></pre></td></tr></table></figure>
<p>然后，k8s集群的资源也被清除了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  kubectl get foo                    </span><br><span class="line">No resources found <span class="keyword">in</span> default namespace.</span><br></pre></td></tr></table></figure>
<p>以上就是使用自定义控制器的基本开发流程</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://lihaoquan.me/2020/3/8/k8s-crd-develop.html" target="_blank" rel="external nofollow noopener noreferrer">https://lihaoquan.me/2020/3/8/k8s-crd-develop.html</a></li>
<li><a href="https://blog.openshift.com/kubernetes-deep-dive-code-generation-customresources/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes Deep Dive: Code Generation for CustomResources</a></li>
<li><a href="https://github.com/kubernetes/code-generator" target="_blank" rel="external nofollow noopener noreferrer">code-generator</a></li>
<li><a href="https://github.com/kubernetes/sample-controller" target="_blank" rel="external nofollow noopener noreferrer">sample controller</a></li>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">API Conventions</a></li>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/customresources-versioning.md" target="_blank" rel="external nofollow noopener noreferrer">CustomReourcesVersioning</a></li>
<li><a href="https://github.com/kubernetes/community/blob/8cafef897a22026d42f5e5bb3f104febe7e29830/contributors/devel/controllers.md" target="_blank" rel="external nofollow noopener noreferrer">Writing Controllers</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>controller</tag>
        <tag>crd</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统监控】kube-state-metrics</title>
    <url>/posts/9bd76ed5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>已经有了cadvisor、heapster、metric-server，几乎容器运行的所有指标都能拿到，但是下面这种情况却无能为力：</p>
<ul>
<li>我调度了多少个replicas？现在可用的有几个？</li>
<li>多少个Pod是running/stopped/terminated状态？</li>
<li>Pod重启了多少次？</li>
<li>我有多少job在运行中</li>
</ul>
<p>而这些则是kube-state-metrics提供的内容，它基于client-go开发，轮询Kubernetes API，并将Kubernetes的结构化信息转换为metrics。</p>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>kube-state-metrics提供的指标，按照阶段分为三种类别：</p>
<ul>
<li>1.实验性质的：k8s api中alpha阶段的或者spec的字段。</li>
<li>2.稳定版本的：k8s中不向后兼容的主要版本的更新</li>
<li>3.被废弃的：已经不在维护的。</li>
</ul>
<p>指标类别包括：</p>
<ul>
<li>CronJob Metrics</li>
<li>DaemonSet Metrics</li>
<li>Deployment Metrics</li>
<li>Job Metrics</li>
<li>LimitRange Metrics</li>
<li>Node Metrics</li>
<li>PersistentVolume Metrics</li>
<li>PersistentVolumeClaim Metrics</li>
<li>Pod Metrics</li>
<li>Pod Disruption Budget Metrics</li>
<li>ReplicaSet Metrics</li>
<li>ReplicationController Metrics</li>
<li>ResourceQuota Metrics</li>
<li>Service Metrics</li>
<li>StatefulSet Metrics</li>
<li>Namespace Metrics</li>
<li>Horizontal Pod Autoscaler Metrics</li>
<li>Endpoint Metrics</li>
<li>Secret Metrics</li>
<li>ConfigMap Metrics</li>
</ul>
<p>以pod为例：</p>
<ul>
<li>kube_pod_info</li>
<li>kube_pod_owner</li>
<li>kube_pod_status_phase</li>
<li>kube_pod_status_ready</li>
<li>kube_pod_status_scheduled</li>
<li>kube_pod_container_status_waiting</li>
<li>kube_pod_container_status_terminated_reason</li>
<li>…</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://github.com/kubernetes/kube-state-metrics/tree/master/examples/standard" target="_blank" rel="external nofollow noopener noreferrer">部署清单</a>：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">kube-<span class="section">state</span>-metrics/</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-cluster-role-binding.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-cluster-role.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-deployment.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-role-binding.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-role.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-service-account.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-service.yaml</span><br></pre></td></tr></table></figure>
<p>主要镜像有： image: quay.io/coreos/kube-state-metrics:v1.5.0 image: k8s.gcr.io/addon-resizer:1.8.3（参考metric-server文章，用于扩缩容）</p>
<p>对于pod的资源限制，一般情况下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span>MiB memory <span class="number">0.1</span> cores</span><br></pre></td></tr></table></figure>
<p>超过100节点的集群：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="number">2M</span>iB memory per <span class="keyword">node</span> <span class="title">0</span>.<span class="number">001</span> cores per <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>
<p>kube-state-metrics做过一次性能优化，具体内容参考下文</p>
<p>部署成功后，prometheus的target会出现如下标志</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/d3c663e527607ecc3eab922ca13a8f44.png"></p>
<p>因为kube-state-metrics-service.yaml中有<code>prometheus.io/scrape: &#39;true&#39;</code>标识，因此会将metric暴露给prometheus，而Prometheus会在kubernetes-service-endpoints这个job下自动发现kube-state-metrics，并开始拉取metrics，无需其他配置。</p>
<p>使用kube-state-metrics后的常用场景有：</p>
<ul>
<li>存在执行失败的Job: kube_job_status_failed{job=”kubernetes-service-endpoints”,k8s_app=”kube-state-metrics”}==1</li>
<li>集群节点状态错误: kube_node_status_condition{condition=”Ready”,status!=”true”}==1</li>
<li>集群中存在启动失败的Pod：kube_pod_status_phase{phase=~”Failed|Unknown”}==1</li>
<li>最近30分钟内有Pod容器重启: changes(kube_pod_container_status_restarts[30m])&gt;0</li>
</ul>
<p>配合报警可以更好地监控集群的运行</p>
<h2 id="与metric-server的对比"><a href="#与metric-server的对比" class="headerlink" title="与metric-server的对比"></a>与metric-server的对比</h2><ul>
<li>metric-server（或heapster）是从api-server中获取cpu、内存使用率这种监控指标，并把他们发送给存储后端，如influxdb或云厂商，他当前的核心作用是：为HPA等组件提供决策指标支持。</li>
<li>kube-state-metrics关注于获取k8s各种资源的最新状态，如deployment或者daemonset，之所以没有把kube-state-metrics纳入到metric-server的能力中，是因为他们的关注点本质上是不一样的。metric-server仅仅是获取、格式化现有数据，写入特定的存储，实质上是一个监控系统。而kube-state-metrics是将k8s的运行状况在内存中做了个快照，并且获取新的指标，但他没有能力导出这些指标</li>
<li>换个角度讲，kube-state-metrics本身是metric-server的一种数据来源，虽然现在没有这么做。</li>
<li>另外，像Prometheus这种监控系统，并不会去用metric-server中的数据，他都是自己做指标收集、集成的（Prometheus包含了metric-server的能力），但Prometheus可以监控metric-server本身组件的监控状态并适时报警，这里的监控就可以通过kube-state-metrics来实现，如metric-serverpod的运行状态。</li>
</ul>
<h2 id="深入解析"><a href="#深入解析" class="headerlink" title="深入解析"></a>深入解析</h2><p>kube-state-metrics本质上是不断轮询api-server，代码结构也很简单 主要代码目录</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── collectors</span><br><span class="line">│   ├── builder.<span class="keyword">go</span></span><br><span class="line">│   ├── collectors.<span class="keyword">go</span></span><br><span class="line">│   ├── configmap.<span class="keyword">go</span></span><br><span class="line">│   ......</span><br><span class="line">│   ├── testutils.<span class="keyword">go</span></span><br><span class="line">│   ├── testutils_test.<span class="keyword">go</span></span><br><span class="line">│   └── utils.<span class="keyword">go</span></span><br><span class="line">├── constant</span><br><span class="line">│   └── resource_unit.<span class="keyword">go</span></span><br><span class="line">├── metrics</span><br><span class="line">│   ├── metrics.<span class="keyword">go</span></span><br><span class="line">│   └── metrics_test.<span class="keyword">go</span></span><br><span class="line">├── metrics_store</span><br><span class="line">│   ├── metrics_store.<span class="keyword">go</span></span><br><span class="line">│   └── metrics_store_test.<span class="keyword">go</span></span><br><span class="line">├── <span class="keyword">options</span></span><br><span class="line">│   ├── collector.<span class="keyword">go</span></span><br><span class="line">│   ├── <span class="keyword">options</span>.<span class="keyword">go</span></span><br><span class="line">│   ├── options_test.<span class="keyword">go</span></span><br><span class="line">│   ├── types.<span class="keyword">go</span></span><br><span class="line">│   └── types_test.<span class="keyword">go</span></span><br><span class="line">├── <span class="keyword">version</span></span><br><span class="line">│   └── <span class="keyword">version</span>.<span class="keyword">go</span></span><br><span class="line">└── whiteblacklist</span><br><span class="line">    ├── whiteblacklist.<span class="keyword">go</span></span><br><span class="line">    └── whiteblacklist_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>所有类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    DefaultNamespaces = NamespaceList&#123;metav1.NamespaceAll&#125;</span><br><span class="line">    DefaultCollectors = CollectorSet&#123;</span><br><span class="line">        <span class="string">"daemonsets"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"deployments"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"limitranges"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"nodes"</span>:                    <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"pods"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"poddisruptionbudgets"</span>:     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"replicasets"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"replicationcontrollers"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"resourcequotas"</span>:           <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"services"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"jobs"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"cronjobs"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"statefulsets"</span>:             <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"persistentvolumes"</span>:        <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"persistentvolumeclaims"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"namespaces"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"horizontalpodautoscalers"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"endpoints"</span>:                <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"secrets"</span>:                  <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"configmaps"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>构建对应的收集器</p>
<p>Family即一个类型的资源集合，如job下的kube_job_info、kube_job_created，都是一个FamilyGenerator实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">metrics.FamilyGenerator&#123;</span><br><span class="line">            Name: <span class="string">"kube_job_info"</span>,</span><br><span class="line">            Type: metrics.MetricTypeGauge,</span><br><span class="line">            Help: <span class="string">"Information about job."</span>,</span><br><span class="line">            GenerateFunc: wrapJobFunc(<span class="function"><span class="keyword">func</span><span class="params">(j *v1batch.Job)</span> <span class="title">metrics</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">                <span class="keyword">return</span> metrics.Family&#123;&amp;metrics.Metric&#123;</span><br><span class="line">                    Name:  <span class="string">"kube_job_info"</span>,</span><br><span class="line">                    Value: <span class="number">1</span>,</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">buildCronJobCollector</span><span class="params">()</span> *<span class="title">Collector</span></span> &#123;</span><br><span class="line">   <span class="comment">// 过滤传入的白名单</span></span><br><span class="line">    filteredMetricFamilies := filterMetricFamilies(b.whiteBlackList, cronJobMetricFamilies)</span><br><span class="line">    composedMetricGenFuncs := composeMetricGenFuncs(filteredMetricFamilies)</span><br><span class="line">  <span class="comment">// 将参数写到header中</span></span><br><span class="line">    familyHeaders := extractMetricFamilyHeaders(filteredMetricFamilies)</span><br><span class="line">  <span class="comment">// NewMetricsStore实现了client-go的cache.Store接口，实现本地缓存。</span></span><br><span class="line">    store := metricsstore.NewMetricsStore(</span><br><span class="line">        familyHeaders,</span><br><span class="line">        composedMetricGenFuncs,</span><br><span class="line">    )</span><br><span class="line">  <span class="comment">// 按namespace构建Reflector，监听变化</span></span><br><span class="line">    reflectorPerNamespace(b.ctx, b.kubeClient, &amp;batchv1beta1.CronJob&#123;&#125;, store, b.namespaces, createCronJobListWatch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewCollector(store)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能优化：</p>
<p>kube-state-metrics在之前的版本中暴露出两个问题：</p>
<ul>
<li><ol>
<li>/metrics接口响应慢(10-20s)</li>
</ol>
</li>
<li><ol>
<li>内存消耗太大，导致超出limit被杀掉</li>
</ol>
</li>
</ul>
<p>问题一的方案就是基于client-go的cache tool实现本地缓存，具体结构为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var cache = map[<span class="string">uuid</span>][<span class="symbol"></span>]byte&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>问题二的的方案是：对于时间序列的字符串，是存在很多重复字符的（如namespace等前缀筛选），可以用指针或者结构化这些重复字符。</p>
<h2 id="优化点和问题"><a href="#优化点和问题" class="headerlink" title="优化点和问题"></a>优化点和问题</h2><ul>
<li>因为kube-state-metrics是监听资源的add、delete、update事件，那么在kube-state-metrics部署之前已经运行的资源，岂不是拿不到数据？kube-state-metric利用client-go可以初始化所有已经存在的资源对象，确保没有任何遗漏</li>
<li>kube-state-metrics当前不会输出metadata信息(如help和description）</li>
<li>缓存实现是基于golang的map，解决并发读问题当期是用了一个简单的互斥锁，应该可以解决问题，后续会考虑golang的sync.Map安全map。</li>
<li>kube-state-metrics通过比较resource version来保证event的顺序</li>
<li>kube-state-metrics并不保证包含所有资源</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/kubernetes/kube-state-metrics" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kube-state-metrics</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>monitoring</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统监控】cAdvisor</title>
    <url>/posts/703a5727/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>cAdvisor</code>即 <code>container advisor</code>，是Google为了对Node机器上的资源及容器进行实时监控和性能数据采集提出的开源解决方还提供基础查询界面和http接口，方便其他组件如Prometheus进行数据抓取，或者cadvisor + influxdb + grafna搭配使用。cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。cAdvisor使用Go语言开发，利用Linux的cgroups获取容器的资源使用信息，在 kubernetes 中集成在 kubelet 里作为默认启动项。</p>
<a id="more"></a>
<h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cadvisor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">google/cadvisor:v0.33.0</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rootfs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/rootfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/sys</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--housekeeping_interval=10s</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--disable_metrics=disk</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rootfs</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var-run</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/sys</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker</span></span><br></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cadvisor.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">cadvisor</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">cadvisor</span></span><br></pre></td></tr></table></figure>
<p>在本地设置好 hosts 之后，访问 <code>http://cadvisor.houmin:&lt;TraefikNode&gt;/</code> 即可看到 <code>cAdvisor</code> 的界面。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_cadvisor.png"></p>
<h3 id="与-Prometheus-集成"><a href="#与-Prometheus-集成" class="headerlink" title="与 Prometheus 集成"></a>与 Prometheus 集成</h3><p>Step1: 修改 Prometheus 配置信息，添加 cadvisor 访问地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prometheus.yml</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['node-exporter:9100']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'container'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['cadvisor:8080']</span>  <span class="comment"># 本地 cadvisor 访问地址</span></span><br></pre></td></tr></table></figure>
<p>重新加载 Prometheus 配置，访问 <code>http://prometheus.houmin:30869/targets</code> 可以看到新加的 cAdvisor 已经生效。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor.png"></p>
<p>此时访问 Prometheus 的 graph 页面 <code>http://prometheus.houmin:30869/graph</code>，搜索 <code>container</code> 你将看到容器相关数据。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-graph.png"></p>
<p>在 Prometheus 中查看集群内存使用量：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sum by (name)(container_memory_usage_bytes&#123;image!=""&#125;)</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-memory.png"></p>
<h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cpu</td>
<td>cpu_usage_total</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cpu_usage_system</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cpu_usage_user</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cpu_usage_per_cpu</td>
<td></td>
</tr>
<tr>
<td></td>
<td>load_average</td>
<td>Smoothed average of number of runnable threads x 1000</td>
</tr>
<tr>
<td>memory</td>
<td>memory_usage</td>
<td>Memory Usage</td>
</tr>
<tr>
<td></td>
<td>memory_working_set</td>
<td>Working set size</td>
</tr>
<tr>
<td>network</td>
<td>rx_bytes</td>
<td>Cumulative count of bytes received</td>
</tr>
<tr>
<td></td>
<td>rx_errors</td>
<td>Cumulative count of receive errors encountered</td>
</tr>
<tr>
<td></td>
<td>tx_bytes</td>
<td>Cumulative count of bytes transmitted</td>
</tr>
<tr>
<td></td>
<td>tx_errors</td>
<td>Cumulative count of transmit errors encountered</td>
</tr>
<tr>
<td>filesystem</td>
<td>fs_device</td>
<td>Filesystem device</td>
</tr>
<tr>
<td></td>
<td>fs_limit</td>
<td>Filesystem limit</td>
</tr>
<tr>
<td></td>
<td>fs_usage</td>
<td>Filesystem usage</td>
</tr>
</tbody>
</table>
</div>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/5a577e4d0a5da14b7b634b5c62264f72.png"></p>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> glog.Flush()</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> *versionFlag &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"cAdvisor version %s (%s)/n"</span>, version.Info[<span class="string">"version"</span>], version.Info[<span class="string">"revision"</span>])</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    setMaxProcs()</span><br><span class="line">    memoryStorage, err := NewMemoryStorage()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to initialize storage driver: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    sysFs, err := sysfs.NewRealSysFs()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to create a system interface: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)</span><br><span class="line">    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to create a Container Manager: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    <span class="keyword">if</span> *enableProfiling &#123;</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register all HTTP handlers.</span></span><br><span class="line">    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to register HTTP handlers: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// Start the manager.</span></span><br><span class="line">    <span class="keyword">if</span> err := containerManager.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to start container manager: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Install signal handler.</span></span><br><span class="line">    installSignalHandler(containerManager)</span><br><span class="line">    glog.Infof(<span class="string">"Starting cAdvisor version: %s-%s on port %d"</span>, version.Info[<span class="string">"version"</span>], version.Info[<span class="string">"revision"</span>], *argPort)</span><br><span class="line">    addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, *argIp, *argPort)</span><br><span class="line">    glog.Fatal(http.ListenAndServe(addr, mux))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过new出来的memoryStorage以及sysfs实例，创建一个manager实例，manager的interface中定义了许多用于获取容器和machine信息的函数。核心代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">memoryStorage, err := NewMemoryStorage()</span><br><span class="line">sysFs, err := sysfs.NewRealSysFs()</span><br><span class="line">#创建containerManager</span><br><span class="line">containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</span><br><span class="line">#启动containerManager</span><br><span class="line">err := containerManager.Start()</span><br></pre></td></tr></table></figure>
<p>核心函数：</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/9c27a63d31346f4e6dc592e71977d568.png"></p>
<p>生成manager实例的时候，还需要传递两个额外的参数，分别是</p>
<ul>
<li>maxHousekeepingInterval：存在内存的时间，默认60s</li>
<li>allowDynamicHousekeeping：是否允许动态配置housekeeping，也就是下一次开始搜集容器信息的时间，默认true</li>
</ul>
<p>因为需要暴露服务，所以在handler文件中，将上面生成的containerManager注册进去（cadvisor/http/handler.go)，之后就是启动manager，运行其Start方法，开始搜集信息，存储信息的循环操作。</p>
<p>以memory采集为例：</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/197e5adaba371a4000ef9fd087dbf987.png"></p>
<p>具体的信息还是通过runc/libcontainer获得，libcontainer是对cgroup的封装。在/sys/fs/cgroup/memory中包含大量的了memory相关的信息（参考docker原生监控文章）</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/8d1b0d821546002af20648d131858457.png"></p>
<p>Prometheus的收集器（cadvisor/metrics/prometheus.go）</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/10f40e80b299ff5df8a99acca63c2644.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优缺点：</p>
<ul>
<li>优点：谷歌开源产品，监控指标齐全，部署方便，而且有官方的docker镜像。</li>
<li>缺点：是集成度不高，默认只在本地保存1分钟数据，但可以集成InfluxDB等存储</li>
</ul>
<p>备注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">爱奇艺参照cadvisor开发的dadvisor，数据写入graphite，</span><br><span class="line">等同于cadvisor+influxdb，但dadvisor并没有开源</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://luoji.live/categories/cadvisor/" target="_blank" rel="external nofollow noopener noreferrer">https://luoji.live/categories/cadvisor/</a></li>
<li><a href="https://github.com/google/cadvisor" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/google/cadvisor</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>monitoring</tag>
        <tag>cadvisor</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统监控】Metrics Server</title>
    <url>/posts/913a8837/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>从 v1.8 开始，资源使用情况的监控可以通过 Metrics API的形式获取，具体的组件为Metrics Server，用来替换之前的 heapster，heapster从1.11开始逐渐被废弃。</p>
<p>Metrics-Server是集群核心监控数据的聚合器，从 Kubernetes1.8 开始，它作为一个 Deployment对象默认部署在由kube-up.sh脚本创建的集群中，如果是其他部署方式需要单独安装，或者咨询对应的云厂商。</p>
<a id="more"></a>
<h2 id="Metrics-API"><a href="#Metrics-API" class="headerlink" title="Metrics API"></a>Metrics API</h2><p>介绍Metrics-Server之前，必须要提一下Metrics API的概念</p>
<p>Metrics API相比于之前的监控采集方式(hepaster)是一种新的思路，官方希望核心指标的监控应该是稳定的，版本可控的，且可以直接被用户访问(例如通过使用 kubectl top 命令)，或由集群中的控制器使用(如HPA)，和其他的Kubernetes APIs一样。</p>
<p>官方废弃heapster项目，就是为了将核心资源监控作为一等公民对待，即像pod、service那样直接通过api-server或者client直接访问，不再是安装一个hepater来汇聚且由heapster单独管理。</p>
<p>假设每个pod和node我们收集10个指标，从k8s的1.6开始，支持5000节点，每个节点30个pod，假设采集粒度为1分钟一次，则：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span>x <span class="number">5000</span> x <span class="number">30</span> / <span class="number">60</span> = <span class="number">25000</span> 平均每分钟<span class="number">2</span>万多个采集指标</span><br></pre></td></tr></table></figure>
<p>因为k8s的api-server将所有的数据持久化到了etcd中，显然k8s本身不能处理这种频率的采集，而且这种监控数据变化快且都是临时数据，因此需要有一个组件单独处理他们，k8s版本只存放部分在内存中，于是metric-server的概念诞生了。</p>
<p>其实hepaster已经有暴露了api，但是用户和Kubernetes的其他组件必须通过master proxy的方式才能访问到，且heapster的接口不像api-server一样，有完整的鉴权以及client集成。这个api现在还在alpha阶段（18年8月），希望能到GA阶段。类api-server风格的写法：<a href="https://github.com/kubernetes/apiserver" target="_blank" rel="external nofollow noopener noreferrer">generic apiserver</a></p>
<p>有了Metrics Server组件，也采集到了该有的数据，也暴露了api，但因为api要统一，如何将请求到api-server的<code>/apis/metrics</code>请求转发给Metrics Server呢，解决方案就是：<a href="https://github.com/kubernetes/kube-aggregator" target="_blank" rel="external nofollow noopener noreferrer">kube-aggregator</a>,在k8s的1.7中已经完成，之前Metrics Server一直没有面世，就是耽误在了kube-aggregator这一步。</p>
<p>kube-aggregator（聚合api）主要提供：</p>
<ul>
<li>Provide an API for registering API servers.</li>
<li>Summarize discovery information from all the servers.</li>
<li>Proxy client requests to individual servers.</li>
</ul>
<p>详细设计文档：<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p>
<p>metric api的使用：</p>
<ul>
<li>Metrics API 只可以查询当前的度量数据，并不保存历史数据</li>
<li>Metrics API URI 为 /apis/metrics.k8s.io/，在 k8s.io/metrics 维护</li>
<li>必须部署 metrics-server 才能使用该 API，metrics-server 通过调用 Kubelet Summary API 获取数据</li>
</ul>
<p>如：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/nodes</span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/nodes/&lt;node-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/namespace/&lt;namespace-name&gt;<span class="regexp">/pods/</span>&lt;pod-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics-Server"></a>Metrics-Server</h2><p>Metrics server定时从Kubelet的Summary API(类似/ap1/v1/nodes/nodename/stats/summary)采集指标信息，这些聚合过的数据将存储在内存中，且以metric-api的形式暴露出去。</p>
<p>Metrics server复用了api-server的库来实现自己的功能，比如鉴权、版本等，为了实现将数据存放在内存中吗，去掉了默认的etcd存储，引入了内存存储（即实现<a href="https://github.com/kubernetes/apiserver/blob/master/pkg/registry/rest/rest.go" target="_blank" rel="external nofollow noopener noreferrer">Storage interface</a>)。因为存放在内存中，因此监控数据是没有持久化的，可以通过第三方存储来拓展，这个和heapster是一致的。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png"></p>
<p>Metrics server出现后，新的Kubernetes 监控架构将变成上图的样子</p>
<ul>
<li>核心流程（黑色部分）：这是 Kubernetes正常工作所需要的核心度量，从 Kubelet、cAdvisor 等获取度量数据，再由metrics-server提供给 Dashboard、HPA 控制器等使用。</li>
<li>监控流程（蓝色部分）：基于核心度量构建的监控流程，比如 Prometheus 可以从 metrics-server 获取核心度量，从其他数据源（如 Node Exporter 等）获取非核心度量，再基于它们构建监控告警系统。</li>
</ul>
<p>官方地址：<a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/metrics-server</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如上文提到的，metric-server是扩展的apiserver，依赖于kube-aggregator，因此需要在apiserver中开启相关参数。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">--requestheader-client-ca-file</span>=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line"><span class="attr">--proxy-client-cert-file</span>=/etc/kubernetes/certs/proxy.crt</span><br><span class="line"><span class="attr">--proxy-client-key-file</span>=/etc/kubernetes/certs/proxy.key</span><br><span class="line"><span class="attr">--requestheader-allowed-names</span>=aggregator</span><br><span class="line"><span class="attr">--requestheader-extra-headers-prefix</span>=X-Remote-Extra-</span><br><span class="line"><span class="attr">--requestheader-group-headers</span>=X-Remote-Group</span><br><span class="line"><span class="attr">--requestheader-username-headers</span>=X-Remote-User</span><br></pre></td></tr></table></figure>
<p>安装文件下载地址：<a href="https://github.com/kubernetes-incubator/metrics-server/tree/master/deploy/1.8%2B" target="_blank" rel="external nofollow noopener noreferrer">1.8+</a>，注意更换镜像地址为国内镜像</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> -f metric-<span class="keyword">server</span>/</span><br></pre></td></tr></table></figure>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/15473067971765.jpg"></p>
<p>安装成功后，访问地址api地址为：</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/15473069387068.jpg"></p>
<p>Metrics Server的资源占用量会随着集群中的Pod数量的不断增长而不断上升，因此需要 addon-resizer垂直扩缩这个容器。addon-resizer依据集群中节点的数量线性地扩展Metrics Server，以保证其能够有能力提供完整的metrics API服务。具体参考：<a href="https://github.com/kubernetes/autoscaler/tree/master/addon-resizer" target="_blank" rel="external nofollow noopener noreferrer">链接</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>基于Metrics Server的HPA：<a href="http://blog.51cto.com/ylw6006/2115087" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p>
<p>kubernetes的新监控体系中，metrics-server属于Core metrics(核心指标)，提供API metrics.k8s.io，仅提供Node和Pod的CPU和内存使用情况。而其他Custom Metrics(自定义指标)由Prometheus等组件来完成，后续文章将对自定义指标进行解析。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/metrics-server</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>monitoring</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统监控】Prometheus</title>
    <url>/posts/18c039ab/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Prometheus是一套开源的监控、报警、时间序列数据库的组合，起始是由SoundCloud公司开发的。从2016年加入CNCF，2016年6月正式发布1.0版本，2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合，到2018年8月毕业，现在已经成为Kubernetes的官方监控方案，社区活跃，第三方集成非常丰富。</p>
<a id="more"></a>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Prometheus是一个开源的完整监控解决方案，其对传统监控系统的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统Prometheus具有以下优点：</p>
<ul>
<li><strong>易于管理</strong>：只有一个单独的二进制文件，不存在任何的第三方依赖，采用Pull的方式拉取数据</li>
<li><strong>强大的数据模型</strong>：每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识</li>
<li><strong>强大的查询语言PromQL</strong>：内置了一个强大的数据查询语言PromQL，可以实现多种查询、聚合</li>
<li><strong>高性能</strong>：单实例可以处理数以百万的监控指标、每秒处理数十万的数据点</li>
<li><strong>易扩展</strong>：支持sharding和联邦集群，实现多数据中心</li>
<li><strong>易集成</strong>：支持多种语言的SDK进行应用程序数据埋点，社区有丰富插件</li>
<li><strong>可视化</strong>：自带Prometheus UI，可以进行查询与展示，Grafana也完整支持Prometheus。</li>
<li><strong>开放性</strong>：使用sdk采集的数据可以被其他监控系统使用，不一定非要用Prometheus</li>
</ul>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>Prometheus从exporter拉取数据，或者间接地通过网关gateway拉取数据（如果在k8s内部署，可以使用服务发现的方式），它默认本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中，采集到的数据有两个去向，一个是报警，另一个是可视化。PromQL和其他API可视化地展示收集的数据，并通过Alertmanager提供报警能力。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-architecture.png"></p>
<h3 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h3><ul>
<li><p>Prometheus Server 负责从 Exporter 拉取和存储监控数据,并提供一套灵活的查询语言（PromQL）</p>
<ul>
<li>Retrieval: 采样模块</li>
<li>TSDB: 存储模块默认本地存储为tsdb</li>
<li>HTTP Server: 提供http接口查询和面板，默认端口为9090</li>
</ul>
</li>
<li><p>Exporters/Jobs 负责收集目标对象（host, container…）的性能数据，并通过 HTTP 接口供 Prometheus Server 获取。支持数据库、硬件、消息中间件、存储系统、http服务器、jmx等。只要符合接口格式，就可以被采集。</p>
</li>
<li><p>Short-lived jobs 瞬时任务的场景，无法通过pull方式拉取，需要使用push方式，与PushGateway搭配使用</p>
</li>
<li><p>PushGateway 可选组件，主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。</p>
</li>
<li><p>客户端sdk 官方提供的客户端类库有go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持nodejs、php、erlang等</p>
</li>
<li><p>Alertmanager 从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。</p>
</li>
<li><p>Service Discovery</p>
<p>服务发现，Prometheus支持多种服务发现机制：文件，DNS，Consul,Kubernetes,OpenStack,EC2等等。基于服务发现的过程并不复杂，通过第三方提供的接口，Prometheus查询到需要监控的Target列表，然后轮训这些Target获取监控数据。</p>
</li>
</ul>
<p>其大概的工作流程是：</p>
<ul>
<li>Prometheus server 定期从配置好的 jobs 或者 exporters 中拉 metrics，或者从 Pushgateway 拉取 metrics，或者从其他的 Prometheus server 中拉 metrics。</li>
<li>Prometheus server 在本地存储收集到的 metrics，并运行已定义好的 alert.rules，记录新的时间序列或者向 Alertmanager 推送警报。</li>
<li>Alertmanager 根据配置文件，对接收到的警报进行处理，发出告警。</li>
<li>在图形界面中，可视化采集数据。</li>
</ul>
<h3 id="Push与Pull"><a href="#Push与Pull" class="headerlink" title="Push与Pull"></a>Push与Pull</h3><p>Prometheus采集数据是用的pull也就是拉模型,通过HTTP协议去采集指标，只要应用系统能够提供HTTP接口就可以接入监控系统，相比于私有协议或二进制协议来说开发、简单。优点主要是：</p>
<ul>
<li>开发任何新功能，你甚至可以在电脑上查看你的监控</li>
<li>如果目标实例挂掉，你可以很快知道</li>
<li>你可以手动指定目标实例，并且在浏览器中查看他的健康状态</li>
</ul>
<p>总体来说，Pull模式比Push模式更好一些，在监控系统中这也不是一个很重要的点。 如果要使用push的方式，可以使用<a href="https://prometheus.io/docs/instrumenting/pushing/" target="_blank" rel="external nofollow noopener noreferrer">Pushgateway</a>的方式，如定时任务的采集。</p>
<p>对于定时任务这种短周期的指标采集，如果采用pull模式，可能造成任务结束了，Prometheus还没有来得及采集，这个时候可以使用加一个中转层，客户端推数据到Push Gateway缓存一下，由Prometheus从push gateway pull指标过来。(需要额外搭建Push Gateway，同时需要新增job去从gateway采数据)</p>
<p>推的代表有 ElasticSearch，InfluxDB，OpenTSDB 等，需要你从程序中将指标使用 TCP，UDP 等方式推送至相关监控应用，只是使用 TCP 的话，一旦监控应用挂掉或存在瓶颈，容易对应用本身产生影响，而使用 UDP 的话，虽然不用担心监控应用，但是容易丢数据。</p>
<p>拉的代表，主要代表就是 Prometheus，让我们不用担心监控应用本身的状态。而且，可以利用 DNS-SRV 或者 Consul 等服务发现功能就可以自动添加监控。</p>
<p>当然，InfluxDB 加上 collector，或者 ES 加上 metricbeat 也可以变为 『拉』，而 Prometheus 加上 Push Gateway 也可以变为 『推』。</p>
<p>更多区别可以参考下图：</p>
<p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/03/15502975113235.jpg"></p>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>Prometheus有着非常高效的时间序列数据存储方法，每个采样数据仅仅占用3.5byte左右空间，上百万条时间序列，30秒间隔，保留60天，大概花了200多G（引用官方PPT）。</p>
<p>Prometheus内部主要分为三大块，Retrieval是负责定时去暴露的目标页面上去抓取采样指标数据，Storage是负责将采样数据写磁盘，PromQL是Prometheus提供的查询语言模块。</p>
<p>Prometheus内置了一个基于本地存储的时间序列数据库。在Prometheus设计上，使用本地存储可以降低Prometheus部署和管理的复杂度同时减少高可用（HA）带来的复杂性。 在默认情况下，用户只需要部署多套Prometheus，采集相同的Targets即可实现基本的HA。同时由于Promethus高效的数据处理能力，单个Prometheus Server基本上能够应对大部分用户监控规模的需求。</p>
<p>同时为了适应数据持久化的问题，Prometheus提供了remote_write和remote_read的特性，支持将数据存储到远端和从远端读取数据。通过将监控与数据分离，Prometheus能够更好地进行弹性扩展。</p>
<h2 id="部署使用"><a href="#部署使用" class="headerlink" title="部署使用"></a>部署使用</h2><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>当使用Deployment管理和部署应用程序时，用户可以方便了对应用进行扩容或者缩容，从而产生多个Pod实例。为了能够统一管理这些Pod的配置信息，在Kubernetes中可以使用ConfigMaps资源定义和管理这些配置，并且通过环境变量或者文件系统挂载的方式让容器使用这些配置。</p>
<p>这里将使用ConfigMaps管理Prometheus的配置文件，创建prometheus-config.yml文件，并写入以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span> </span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>当ConfigMap资源创建成功后，我们就可以通过Volume挂载的方式，将Prometheus的配置文件挂载到容器中。 这里我们通过Deployment部署Prometheus Server实例，创建prometheus-deployment.yml文件，并写入以下内容:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">prom/prometheus:v2.19.0</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/prometheus</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--config.file=/etc/config/prometheus.yml</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br></pre></td></tr></table></figure>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9090</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure>
<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>由于之前配置了 <code>Traefik</code>，所以这里的 Prometheus 服务不使用 <code>NodePort</code> 方式暴露，在本地设置好 <code>prometheus.houmin</code> 的 host之后，在浏览器中访问：<code>http://prometheus.houmin:&lt;TraefikPort&gt;/</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">prometheus.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">prometheus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure>
<h2 id="PromQL查询"><a href="#PromQL查询" class="headerlink" title="PromQL查询"></a>PromQL查询</h2><p>Prometheus除了存储数据外，还提供了一种强大的功能表达式语言 PromQL，允许用户实时选择和汇聚时间序列数据。</p>
<p>表达式的结果可以在浏览器中显示为图形，也可以显示为表格数据，或者由外部系统通过 HTTP API 调用。通过PromQL用户可以非常方便地查询监控数据，或者利用表达式进行告警配置。比如集群中网络使用：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">sum by (<span class="name">name</span>) (<span class="name">rate</span>(<span class="name">container_network_receive_bytes_total</span>&#123;image!=<span class="string">""</span>&#125;[<span class="number">1</span>m]))</span><br></pre></td></tr></table></figure>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-network.png"></p>
<h3 id="Metric类型"><a href="#Metric类型" class="headerlink" title="Metric类型"></a>Metric类型</h3><p>关于时间序列存储，可以参考：<a href="https://www.infoq.cn/article/database-timestamp-01" target="_blank" rel="external nofollow noopener noreferrer">https://www.infoq.cn/article/database-timestamp-01</a></p>
<p>Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库TSDB中，并且定时保存到硬盘上。time-series是按照时间戳和值的序列顺序存放的，我们称之为向量(vector)。每条time-series通过指标名称(metrics name)和一组标签集(labelset)命名。</p>
<p>在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：</p>
<ul>
<li>指标(metric)：metric name和描述当前样本特征的labelsets;</li>
<li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li>
<li>样本值(value)： 一个folat64的浮点型数据表示当前样本的值。</li>
</ul>
<p>如某一时刻的node_cpu指标为459.71</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">node_cpu&#123;app=<span class="string">"node-exporter"</span>,cpu=<span class="string">"cpu0"</span>,<span class="keyword">instance</span>=<span class="string">"192.168.0.4:9100"</span>,job=<span class="string">"kubernetes-service-endpoints"</span>,kubernetes_name=<span class="string">"node-exporter"</span>,kubernetes_namespace=<span class="string">"kube-system"</span>,mode=<span class="string">"guest"</span>&#125;     <span class="number">459.71</span></span><br></pre></td></tr></table></figure>
<p>Prometheus定义了4中不同的指标类型(metric type):</p>
<ul>
<li>Counter 计数器</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">计数器，只增不减，如http_requests_total请求总数</span><br><span class="line"></span><br><span class="line">例如，通过rate()函数获取HTTP请求量的增长率：</span><br><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total[<span class="number">5</span>m])</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Gauge 仪表盘</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">当前状态，可增可减。如kube_pod_status_ready当前pod可用数</span><br><span class="line">可以获取样本在一段时间返回内的变化情况,如：</span><br><span class="line"><span class="function"><span class="title">delta</span><span class="params">(kube_pod_status_ready[<span class="number">2</span>h])</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Histogram 直方图</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Histogram 由 &lt;basename&gt;_bucket&#123;<span class="attribute">le</span>=<span class="string">"&lt;upper inclusive bound&gt;"</span>&#125;，&lt;basename&gt;_bucket&#123;<span class="attribute">le</span>=<span class="string">"+Inf"</span>&#125;, &lt;basename&gt;_sum，&lt;basename&gt;_count 组成，主要用于表示一段时间范围内对数据进行采样（通常是请求持续时间或响应大小），并能够对其指定区间以及总数进行统计，通常它采集的数据展示为直方图。</span><br><span class="line"></span><br><span class="line">例如 Prometheus<span class="built_in"> server </span>中 prometheus_local_storage_series_chunks_persisted, 表示 Prometheus 中每个时序需要存储的 chunks 数量，我们可以用它计算待持久化的数据的分位数。</span><br></pre></td></tr></table></figure>
<ul>
<li>Summary 摘要</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Summary 和 Histogram 类似，由 &lt;basename&gt;&#123;<span class="attribute">quantile</span>=<span class="string">"&lt;φ&gt;"</span>&#125;，&lt;basename&gt;_sum，&lt;basename&gt;_count 组成，主要用于表示一段时间内数据采样结果（通常是请求持续时间或响应大小），它直接存储了 quantile 数据，而不是根据统计区间计算出来的。</span><br><span class="line"></span><br><span class="line">例如 Prometheus<span class="built_in"> server </span>中 prometheus_target_interval_length_seconds。</span><br><span class="line"></span><br><span class="line">Histogram 需要通过 &lt;basename&gt;_bucket 计算 quantile, 而 Summary 直接存储了 quantile 的值。</span><br></pre></td></tr></table></figure>
<h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>PromQL是Prometheus内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。如http_requests_total指标，你可以通过附加一组标签，并用{}括起来，来进一步筛选这些时间序列。下面这个例子只选择有http_requests_total名称的、有prometheus工作标签的、有canary组标签的时间序列：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">"prometheus"</span>,<span class="keyword">group</span>=<span class="string">"canary"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果条件为空，可以写为：http_requests_total{}</p>
<p>另外，也可以也可以将标签值反向匹配，或者对正则表达式匹配标签值。如操作符：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">=：选择正好相等的字符串标签</span><br><span class="line">!=：选择不相等的字符串标签</span><br><span class="line">=~：选择匹配正则表达式的标签（或子标签）</span><br><span class="line">!=：选择不匹配正则表达式的标签（或子标签）</span><br></pre></td></tr></table></figure>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>类似<code>http_requests_total{job=&quot;prometheus&quot;,group=&quot;canary&quot;}</code>的方式，得到的是瞬时值，如果想得到一定范围内的值，可以使用范围查询。</p>
<p>时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据，如：http_request_total{}[5m]。除了分钟，支持的单位有：</p>
<ul>
<li>s - 秒</li>
<li>m - 分钟</li>
<li>h - 小时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<h3 id="偏移查询"><a href="#偏移查询" class="headerlink" title="偏移查询"></a>偏移查询</h3><p>如：查询http_requests_total在当前时刻的一周的速率：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total&#123;&#125; offset <span class="number">1</span>w)</span></span></span><br></pre></td></tr></table></figure>
<p>偏移修饰符允许更改查询中单个即时向量和范围向量的时间偏移量，例如，以下表达式返回相对于当前查询时间5分钟前的http_requests_total值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http_requests_total offset <span class="number">5</span>m</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;<span class="keyword">job</span>=<span class="string">"prometheus"</span>&#125;[<span class="number">5</span>m]</span><br></pre></td></tr></table></figure>
<p>请注意，偏移量修饰符始终需要跟随选择器，即以下是正确的：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=<span class="string">"<span class="keyword">GET</span>"</span>&#125; offset 5m) // GOOD.</span><br></pre></td></tr></table></figure>
<p>下面是错误的:</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=<span class="string">"<span class="keyword">GET</span>"</span>&#125;) offset 5m // INVALID.</span><br></pre></td></tr></table></figure>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Prometheus 的查询语言支持基本的逻辑运算和算术运算</p>
<h4 id="二元算术运算："><a href="#二元算术运算：" class="headerlink" title="二元算术运算："></a>二元算术运算：</h4><ul>
<li>+加法</li>
<li>-减法</li>
<li>*乘法</li>
<li>/ 除法</li>
<li>% 模</li>
<li>^ 幂等</li>
</ul>
<p>运算中用到的基础数据类型：</p>
<ul>
<li>瞬时向量（Instant vector） - 一组时间序列，每个时间序列包含单个样本，它们共享相同的时间戳。也就是说，表达式的返回值中只会包含该时间序列中的最新的一个样本值。而相应的这样的表达式称之为瞬时向量表达式。</li>
<li>区间向量（Range vector） - 一组时间序列，每个时间序列包含一段时间范围内的样本数据。</li>
<li>标量（Scalar） - 一个浮点型的数据值。</li>
<li>字符串（String） - 一个简单的字符串值。</li>
</ul>
<p>二元运算操作符支持 scalar/scalar(标量/标量)、vector/scalar(向量/标量)、和 vector/vector(向量/向量) 之间的操作。</p>
<p>在两个标量之间进行数学运算，得到的结果也是标量。</p>
<p>例如，如果我们想根据 node_disk_bytes_written 和 node_disk_bytes_read 获取主机磁盘IO的总量，可以使用如下表达式：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">node_disk_bytes_written</span> + node_disk_bytes_read</span><br></pre></td></tr></table></figure>
<p>或者node的内存数GB</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">node_memory_free_bytes_total / (<span class="number">1024</span> * <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>
<h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><ul>
<li>== (相等)</li>
<li>!= (不相等)</li>
<li><code>&gt;</code> (大于)</li>
<li>&lt; (小于)</li>
<li><code>&gt;=</code>  (大于等于)</li>
<li>&lt;=  (小于等于)</li>
</ul>
<p>如：获取http_requests_total请求总数是否超过10000，返回0和1，1则报警</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http_requests_total &gt; <span class="number">10000</span> # 结果为 <span class="literal">true</span> 或 <span class="literal">false</span></span><br><span class="line">http_requests_total &gt; <span class="built_in">bool</span> <span class="number">10000</span> # 结果为 <span class="number">1</span> 或 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ul>
<li>and (并且)</li>
<li>or (或者)</li>
<li>unless (排除)</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>四则运算有优先级，promql的复杂运算也有优先级</p>
<p>例如，查询主机的CPU使用率，可以使用表达式：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">100 </span>* (<span class="number">1</span> - avg (irate(node_cpu&#123;mode=<span class="comment">'idle'&#125;[5m])) by(job) )</span></span><br></pre></td></tr></table></figure>
<p>其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率 在PromQL操作符中优先级由高到低依次为：</p>
<ol>
<li>^</li>
<li>*, /, %</li>
<li>+, -</li>
<li>==, !=, &lt;=, &lt;, &gt;=, &gt;</li>
<li>and, unless</li>
<li>or</li>
</ol>
<h4 id="匹配模式（联合查询）"><a href="#匹配模式（联合查询）" class="headerlink" title="匹配模式（联合查询）"></a>匹配模式（联合查询）</h4><p>与数据库中的join类似，promsql有两种典型的匹配查询：</p>
<ul>
<li>一对一（one-to-one）</li>
<li>多对一（many-to-one）或一对多（one-to-many）</li>
</ul>
<p>例如当存在样本：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"500"</span>&#125;  <span class="number">24</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"404"</span>&#125;  <span class="number">30</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"put"</span>, code=<span class="string">"501"</span>&#125;  <span class="number">3</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"500"</span>&#125; <span class="number">6</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"404"</span>&#125; <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>&#125;  <span class="number">600</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"del"</span>&#125;  <span class="number">34</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>&#125; <span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>使用 PromQL 表达式：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">method_code:http_errors:rate5m<span class="comment">&#123;code="500"&#125;</span> / ignoring(code) <span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m</span><br></pre></td></tr></table></figure>
<p>该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p>
<p>因此结果如下：</p>
<p>{method=”get”} 0.04 // 24 / 600 {method=”post”} 0.05 // 6 / 120</p>
<p>同时由于 method 为 put 和 del 的样本找不到匹配项，因此不会出现在结果当中。</p>
<p><strong>多对一模式</strong></p>
<p>例如，使用表达式：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left <span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m</span><br></pre></td></tr></table></figure>
<p>该表达式中，左向量 method_code:http_errors:rate5m 包含两个标签 method 和 code。而右向量 method:http_requests:rate5m 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 code。</p>
<p>在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group 修饰符 group_left 指定左向量具有更好的基数。</p>
<p>最终的运算结果如下：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"500"</span>&#125; <span class="number">0.04</span> // <span class="number">24</span> / <span class="number">600</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"404"</span>&#125; <span class="number">0.05</span> // <span class="number">30</span> / <span class="number">600</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"500"</span>&#125; <span class="number">0.05</span> // <span class="number">6</span> / <span class="number">120</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"404"</span>&#125; <span class="number">0.175</span> // <span class="number">21</span> / <span class="number">120</span></span><br></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">提醒：<span class="keyword">group</span> <span class="title">修饰符只能在比较和数学运算符中使用。在逻辑运算 and</span>，unless 和 <span class="keyword">or</span> 操作中默认与右向量中的所有元素进行匹配。</span><br></pre></td></tr></table></figure>
<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个具有较少样本值的新的时间序列。</p>
<ul>
<li>sum (求和)</li>
<li>min (最小值)</li>
<li>max (最大值)</li>
<li>avg (平均值)</li>
<li>stddev (标准差)</li>
<li>stdvar (标准差异)</li>
<li>count (计数)</li>
<li>count_values (对 value 进行计数)</li>
<li>bottomk (样本值最小的 k 个元素)</li>
<li>topk (样本值最大的k个元素)</li>
<li>quantile (分布统计)</li>
</ul>
<p>这些操作符被用于聚合所有标签维度，或者通过 without 或者 by 子语句来保留不同的维度。</p>
<ul>
<li>without 用于从计算结果中移除列举的标签，而保留其它标签。</li>
<li>by 则正好相反，结果向量中只保留列出的标签，其余标签则移除。</li>
</ul>
<p>通过 without 和 by 可以按照样本的问题对数据进行聚合。</p>
<p>例如：如果指标 http_requests_total 的时间序列的标签集为 application, instance, 和 group，我们可以通过以下方式计算所有 instance 中每个 application 和 group 的请求总量：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">sum(<span class="name">http_requests_total</span>) without (<span class="name">instance</span>)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">sum(<span class="name">http_requests_total</span>) by (<span class="name">application</span>, group)</span><br></pre></td></tr></table></figure>
<p>如果只需要计算整个应用的 HTTP 请求总量，可以直接使用表达式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">sum</span><span class="params">(http_requests_total)</span></span></span><br></pre></td></tr></table></figure>
<p>count_values 用于时间序列中每一个样本值出现的次数。count_values 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p>
<p>这个标签的名字由聚合参数指定，同时这个标签值是唯一的样本值。</p>
<p>例如要计算运行每个构建版本的二进制文件的数量：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">count_values(<span class="string">"version"</span>, <span class="keyword">build_version)</span></span><br><span class="line"><span class="keyword">返回结果如下：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">&#123;count="641"&#125; </span>  <span class="number">1</span></span><br><span class="line">&#123;<span class="built_in">count</span>=<span class="string">"3226"</span>&#125;  <span class="number">2</span></span><br><span class="line">&#123;<span class="built_in">count</span>=<span class="string">"644"</span>&#125;   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>topk 和 bottomk</strong> </p>
<p>则用于对样本值进行排序，返回当前样本值前 n 位，或者后 n 位的时间序列。</p>
<p>获取 HTTP 请求数前 5 位的时序样本数据，可以使用表达式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">topk</span><span class="params">(<span class="number">5</span>, http_requests_total)</span></span></span><br></pre></td></tr></table></figure>
<p>quantile 用于计算当前样本数据值的分布情况 quantile(φ, express) ，其中 0 ≤ φ ≤ 1</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">例如，当 φ 为 <span class="number">0.5</span> 时，即表示找到当前样本数据中的中位数：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">quantile(<span class="number">0.5</span>, http_requests_total)</span><br><span class="line">返回结果如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#125;   <span class="number">656</span></span><br></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。如上文提到的irate</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">100 </span>* (<span class="number">1</span> - avg (irate(node_cpu&#123;mode=<span class="comment">'idle'&#125;[5m])) by(job) )</span></span><br></pre></td></tr></table></figure>
<p>常用的有：</p>
<p>两分钟内的平均CPU使用率：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">rate</span><span class="params">(node_cpu[<span class="number">2</span>m])</span></span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">irate</span><span class="params">(node_cpu[<span class="number">2</span>m])</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，</span><br><span class="line">其无法反应在时间窗口内样本数据的突发变化。</span><br><span class="line">例如，对于主机而言在<span class="number">2</span>分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用<span class="number">100</span>%的情况，</span><br><span class="line">但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</span><br><span class="line"></span><br><span class="line">为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-<span class="type">vector</span>)。</span><br><span class="line"></span><br><span class="line">irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。</span><br><span class="line"></span><br><span class="line">irate函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率。</span><br><span class="line">这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</span><br></pre></td></tr></table></figure>
<p>irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。</p>
<p>因此在长期趋势分析或者告警中更推荐使用rate函数。</p>
<p>完整的函数列表为：</p>
<ul>
<li>abs()</li>
<li>absent()</li>
<li>ceil()</li>
<li>changes()</li>
<li>clamp_max()</li>
<li>clamp_min()</li>
<li>day_of_month()</li>
<li>day_of_week()</li>
<li>days_in_month()</li>
<li>delta()</li>
<li>deriv()</li>
<li>exp()</li>
<li>floor()</li>
<li>histogram_quantile()</li>
<li>holt_winters()</li>
<li>hour()</li>
<li>idelta()</li>
<li>increase()</li>
<li>irate()</li>
<li>label_join()</li>
<li>label_replace()</li>
<li>ln()</li>
<li>log2()</li>
<li>log10()</li>
<li>minute()</li>
<li>month()</li>
<li>predict_linear()</li>
<li>rate()</li>
<li>resets()</li>
<li>round()</li>
<li>scalar()</li>
<li>sort()</li>
<li>sort_desc()</li>
<li>sqrt()</li>
<li>time()</li>
<li>timestamp()</li>
<li>vector()</li>
<li>year()</li>
<li>_over_time()</li>
</ul>
<h3 id="API访问"><a href="#API访问" class="headerlink" title="API访问"></a>API访问</h3><p>Prometheus当前稳定的HTTP API可以通过/api/v1访问</p>
<p>错误状态码：</p>
<ul>
<li>404 Bad Request：当参数错误或者缺失时。</li>
<li>422 Unprocessable Entity 当表达式无法执行时。</li>
<li>503 Service Unavailiable 当请求超时或者被中断时。</li>
</ul>
<p>所有的API请求均使用以下的JSON格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"success"</span> | <span class="string">"error"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &lt;data&gt;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为error时，有如下报错信息</span></span><br><span class="line">  <span class="attr">"errorType"</span>: <span class="string">"&lt;string&gt;"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"&lt;string&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过HTTP API我们可以分别通过/api/v1/query和/api/v1/query_range查询PromQL表达式当前或者一定时间范围内的计算结果。</p>
<h4 id="瞬时数据查询"><a href="#瞬时数据查询" class="headerlink" title="瞬时数据查询"></a>瞬时数据查询</h4><p>URL请求参数：</p>
<ul>
<li>query=：PromQL表达式。</li>
<li>time=：用于指定用于计算PromQL的时间戳。可选参数，默认情况下使用当前系统时间。</li>
<li>timeout=：超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$ curl 'http://localhost:<span class="number">9090</span>/api/v1/query?query=up&amp;time=<span class="number">2015-07-01</span>T20:10:51.781Z'</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line">   <span class="attr">"data"</span> : &#123;</span><br><span class="line">      <span class="attr">"resultType"</span> : <span class="string">"vector"</span>,</span><br><span class="line">      <span class="attr">"result"</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"prometheus"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9090"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"value"</span>: [ <span class="number">1435781451.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"node"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9100"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"value"</span> : [ <span class="number">1435781451.781</span>, <span class="string">"0"</span> ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>URL请求参数：</p>
<ul>
<li>query=: PromQL表达式。</li>
<li>start=: 起始时间。</li>
<li>end=: 结束时间。</li>
<li>step=: 查询步长。</li>
<li>timeout=: 超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">$ curl 'http://localhost:<span class="number">9090</span>/api/v1/query_range?query=up&amp;start=<span class="number">2015-07-01</span>T20:10:30.781Z&amp;end=<span class="number">2015-07-01</span>T20:11:00.781Z&amp;step=15s'</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line">   <span class="attr">"data"</span> : &#123;</span><br><span class="line">      <span class="attr">"resultType"</span> : <span class="string">"matrix"</span>,</span><br><span class="line">      <span class="attr">"result"</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"prometheus"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9090"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"values"</span> : [</span><br><span class="line">               [ <span class="number">1435781430.781</span>, <span class="string">"1"</span> ],</span><br><span class="line">               [ <span class="number">1435781445.781</span>, <span class="string">"1"</span> ],</span><br><span class="line">               [ <span class="number">1435781460.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"node"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9091"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"values"</span> : [</span><br><span class="line">               [ <span class="number">1435781430.781</span>, <span class="string">"0"</span> ],</span><br><span class="line">               [ <span class="number">1435781445.781</span>, <span class="string">"0"</span> ],</span><br><span class="line">               [ <span class="number">1435781460.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prometheus配置"><a href="#Prometheus配置" class="headerlink" title="Prometheus配置"></a>Prometheus配置</h2><p>Prometheus可以通过命令行参数和配置文件来配置，其中命令行参数主要用于配置一些不可变的系统参数（比如存储位置、需要保存在内存和磁盘数据的数量），配置文件用于配置所有和 <a href="https://prometheus.io/docs/concepts/jobs_instances/" target="_blank" rel="external nofollow noopener noreferrer">scrape jobs and instances</a> 相关的参数。本小节讲的Prometheus配置，是指的命令行配置的 <code>--config.file=/etc/config/prometheus.yml</code>内容，这是所有配置的入口，更多内容可以参考 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a></p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>Prometheus 配置文件主要分为以下几个部分，下面将依次介绍。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># How frequently to scrape targets by default.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># How long until a scrape request times out.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">10s</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># How frequently to evaluate rules.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">evaluation_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The labels to add to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># File to which PromQL queries are logged.</span></span><br><span class="line">  <span class="comment"># Reloading the configuration will reopen the file.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">query_log_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rule files specifies a list of globs. Rules and alerts are read from</span></span><br><span class="line"><span class="comment"># all matching files.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A list of scrape configurations.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;scrape_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alerting specifies settings related to the Alertmanager.</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;alertmanager_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote write feature.</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_write&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote read feature.</span></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_read&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><h3 id="rule-files"><a href="#rule-files" class="headerlink" title="rule_files"></a>rule_files</h3><h3 id="scrape-config"><a href="#scrape-config" class="headerlink" title="scrape_config"></a>scrape_config</h3><p><code>scrape_config</code> 部分指定了一系列需要抓取的Target和参数，一般来说，一个scrape配置指定了一个Job，这部分多个<code>scrape_config</code> 以一个列表的形式呈现。Target可以通过 <code>static_configs</code> 来静态配置，也可以通过Prometheus支持的各种服务发现机制来动态配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The job name assigned to scraped metrics by default.</span></span><br><span class="line"><span class="attr">job_name:</span> <span class="string">&lt;job_name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How frequently to scrape targets from this job.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">&lt;global_config.scrape_interval&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-scrape timeout when scraping this job.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scrape_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">&lt;global_config.scrape_timeout&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The HTTP resource path on which to fetch metrics from targets.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">metrics_path:</span> <span class="string">&lt;path&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">/metrics</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># honor_labels controls how Prometheus handles conflicts between labels that are</span></span><br><span class="line"><span class="comment"># already present in scraped data and labels that Prometheus would attach</span></span><br><span class="line"><span class="comment"># server-side ("job" and "instance" labels, manually configured target</span></span><br><span class="line"><span class="comment"># labels, and labels generated by service discovery implementations).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_labels is set to "true", label conflicts are resolved by keeping label</span></span><br><span class="line"><span class="comment"># values from the scraped data and ignoring the conflicting server-side labels.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_labels is set to "false", label conflicts are resolved by renaming</span></span><br><span class="line"><span class="comment"># conflicting labels in the scraped data to "exported_&lt;original-label&gt;" (for</span></span><br><span class="line"><span class="comment"># example "exported_instance", "exported_job") and then attaching server-side</span></span><br><span class="line"><span class="comment"># labels.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting honor_labels to "true" is useful for use cases such as federation and</span></span><br><span class="line"><span class="comment"># scraping the Pushgateway, where all labels specified in the target should be</span></span><br><span class="line"><span class="comment"># preserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that any globally configured "external_labels" are unaffected by this</span></span><br><span class="line"><span class="comment"># setting. In communication with external systems, they are always applied only</span></span><br><span class="line"><span class="comment"># when a time series does not have a given label yet and are ignored otherwise.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">honor_labels:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="literal">false</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># honor_timestamps controls whether Prometheus respects the timestamps present</span></span><br><span class="line"><span class="comment"># in scraped data.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_timestamps is set to "true", the timestamps of the metrics exposed</span></span><br><span class="line"><span class="comment"># by the target will be used.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_timestamps is set to "false", the timestamps of the metrics exposed</span></span><br><span class="line"><span class="comment"># by the target will be ignored.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">honor_timestamps:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="literal">true</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configures the protocol scheme used for requests.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scheme:</span> <span class="string">&lt;scheme&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">http</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional HTTP URL parameters.</span></span><br><span class="line"><span class="attr">params:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;string&gt;:</span> <span class="string">[&lt;string&gt;,</span> <span class="string">...]</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the `Authorization` header on every scrape request with the</span></span><br><span class="line"><span class="comment"># configured username and password.</span></span><br><span class="line"><span class="comment"># password and password_file are mutually exclusive.</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the `Authorization` header on every scrape request with</span></span><br><span class="line"><span class="comment"># the configured bearer token. It is mutually exclusive with `bearer_token_file`.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the `Authorization` header on every scrape request with the bearer token</span></span><br><span class="line"><span class="comment"># read from the configured file. It is mutually exclusive with `bearer_token`.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configures the scrape request's TLS settings.</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional proxy URL.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Azure service discovery configurations.</span></span><br><span class="line"><span class="attr">azure_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;azure_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Consul service discovery configurations.</span></span><br><span class="line"><span class="attr">consul_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;consul_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of DigitalOcean service discovery configurations.</span></span><br><span class="line"><span class="attr">digitalocean_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;digitalocean_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Docker Swarm service discovery configurations.</span></span><br><span class="line"><span class="attr">dockerswarm_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;dockerswarm_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of DNS service discovery configurations.</span></span><br><span class="line"><span class="attr">dns_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;dns_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of EC2 service discovery configurations.</span></span><br><span class="line"><span class="attr">ec2_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;ec2_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Eureka service discovery configurations.</span></span><br><span class="line"><span class="attr">eureka_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;eureka_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of file service discovery configurations.</span></span><br><span class="line"><span class="attr">file_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;file_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of GCE service discovery configurations.</span></span><br><span class="line"><span class="attr">gce_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;gce_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Hetzner service discovery configurations.</span></span><br><span class="line"><span class="attr">hetzner_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;hetzner_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Kubernetes service discovery configurations.</span></span><br><span class="line"><span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;kubernetes_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Marathon service discovery configurations.</span></span><br><span class="line"><span class="attr">marathon_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;marathon_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of AirBnB's Nerve service discovery configurations.</span></span><br><span class="line"><span class="attr">nerve_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;nerve_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of OpenStack service discovery configurations.</span></span><br><span class="line"><span class="attr">openstack_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;openstack_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Zookeeper Serverset service discovery configurations.</span></span><br><span class="line"><span class="attr">serverset_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;serverset_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Triton service discovery configurations.</span></span><br><span class="line"><span class="attr">triton_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;triton_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of labeled statically configured targets for this job.</span></span><br><span class="line"><span class="attr">static_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;static_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of target relabel configurations.</span></span><br><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of metric relabel configurations.</span></span><br><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-scrape limit on number of scraped samples that will be accepted.</span></span><br><span class="line"><span class="comment"># If more than this number of samples are present after metric relabeling</span></span><br><span class="line"><span class="comment"># the entire scrape will be treated as failed. 0 means no limit.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">sample_limit:</span> <span class="string">&lt;int&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="number">0</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-scrape config limit on number of unique targets that will be</span></span><br><span class="line"><span class="comment"># accepted. If more than this number of targets are present after target</span></span><br><span class="line"><span class="comment"># relabeling, Prometheus will mark the targets as failed without scraping them.</span></span><br><span class="line"><span class="comment"># 0 means no limit. This is an experimental feature, this behaviour could</span></span><br><span class="line"><span class="comment"># change in the future.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">target_limit:</span> <span class="string">&lt;int&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="number">0</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<h4 id="static-config"><a href="#static-config" class="headerlink" title="static_config"></a>static_config</h4><h4 id="kubernetes-sd-config"><a href="#kubernetes-sd-config" class="headerlink" title="kubernetes_sd_config"></a>kubernetes_sd_config</h4><p><code>Kubernetes SD configurations</code> 允许从 Kubernetes 的 REST API 来抓取目标，并且保持与集群状态同步。</p>
<p>Role 的类型可以被配置为以下几种：</p>
<h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><h5 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h5><h5 id="endpoints"><a href="#endpoints" class="headerlink" title="endpoints"></a>endpoints</h5><h5 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The information to access the Kubernetes API.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The API server addresses. If left empty, Prometheus is assumed to run inside</span></span><br><span class="line"><span class="comment"># of the cluster and will discover API servers automatically and use the pod's</span></span><br><span class="line"><span class="comment"># CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">api_server:</span> <span class="string">&lt;host&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Kubernetes role of entities that should be discovered.</span></span><br><span class="line"><span class="comment"># One of endpoints, service, pod, node, or ingress.</span></span><br><span class="line"><span class="attr">role:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional authentication information used to authenticate to the API server.</span></span><br><span class="line"><span class="comment"># Note that `basic_auth`, `bearer_token` and `bearer_token_file` options are</span></span><br><span class="line"><span class="comment"># mutually exclusive.</span></span><br><span class="line"><span class="comment"># password and password_file are mutually exclusive.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional HTTP basic authentication information.</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional bearer token authentication information.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional bearer token file authentication information.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional proxy URL.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TLS configuration.</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional namespace discovery. If omitted, all namespaces are used.</span></span><br><span class="line"><span class="attr">namespaces:</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional label and field selectors to limit the discovery process to a subset of available resources. </span></span><br><span class="line"><span class="comment"># See https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/</span></span><br><span class="line"><span class="comment"># and https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ to learn more about the possible </span></span><br><span class="line"><span class="comment"># filters that can be used. Endpoints role supports pod, service and endpoints selectors, other roles</span></span><br><span class="line"><span class="comment"># only support selectors matching the role itself (e.g. node role can only contain node selectors).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> When making decision about using field/label selector make sure that this </span></span><br><span class="line"><span class="comment"># is the best approach - it will prevent Prometheus from reusing single list/watch</span></span><br><span class="line"><span class="comment"># for all scrape configs. This might result in a bigger load on the Kubernetes API,</span></span><br><span class="line"><span class="comment"># because per each selector combination there will be additional LIST/WATCH. On the other hand,</span></span><br><span class="line"><span class="comment"># if you just want to monitor small subset of pods in large cluster it's recommended to use selectors.</span></span><br><span class="line"><span class="comment"># Decision, if selectors should be used or not depends on the particular situation.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">selectors:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="string">[</span> <span class="attr">label:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">    <span class="string">[</span> <span class="attr">field:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span> <span class="string">]]</span></span><br></pre></td></tr></table></figure>
<h4 id="relabel-config"><a href="#relabel-config" class="headerlink" title="relabel_config"></a>relabel_config</h4><p><code>Relabeling</code> 是一个可以在数据被抓取之前动态重写target里面label的强大工具。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The source labels select values from existing labels. Their content is concatenated</span></span><br><span class="line"><span class="comment"># using the configured separator and matched against the configured regular expression</span></span><br><span class="line"><span class="comment"># for the replace, keep, and drop actions.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">source_labels:</span> <span class="string">'['</span> <span class="string">&lt;labelname&gt;</span> <span class="string">[,</span> <span class="string">...]</span> <span class="string">']'</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Separator placed between concatenated source label values.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">separator:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Label to which the resulting value is written in a replace action.</span></span><br><span class="line"><span class="comment"># It is mandatory for replace actions. Regex capture groups are available.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">target_label:</span> <span class="string">&lt;labelname&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Regular expression against which the extracted value is matched.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">regex:</span> <span class="string">&lt;regex&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">(.*)</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modulus to take of the hash of the source label values.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">modulus:</span> <span class="string">&lt;int&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replacement value against which a regex replace is performed if the</span></span><br><span class="line"><span class="comment"># regular expression matches. Regex capture groups are available.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">replacement:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">$1</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Action to perform based on regex matching.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">action:</span> <span class="string">&lt;relabel_action&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">replace</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;relabel_action&gt;</code> 决定了relabel时候采取的动作：</p>
<ul>
<li><code>replace</code>: Match <code>regex</code> against the concatenated <code>source_labels</code>. Then, set <code>target_label</code> to <code>replacement</code>, with match group references (<code>${1}</code>, <code>${2}</code>, …) in <code>replacement</code> substituted by their value. If <code>regex</code> does not match, no replacement takes place.</li>
<li><code>keep</code>: Drop targets for which <code>regex</code> does not match the concatenated <code>source_labels</code>.</li>
<li><code>drop</code>: Drop targets for which <code>regex</code> matches the concatenated <code>source_labels</code>.</li>
<li><code>hashmod</code>: Set <code>target_label</code> to the <code>modulus</code> of a hash of the concatenated <code>source_labels</code>.</li>
<li><code>labelmap</code>: Match <code>regex</code> against all label names. Then copy the values of the matching labels to label names given by <code>replacement</code> with match group references (<code>${1}</code>, <code>${2}</code>, …) in <code>replacement</code> substituted by their value.</li>
<li><code>labeldrop</code>: Match <code>regex</code> against all label names. Any label that matches will be removed from the set of labels.</li>
<li><code>labelkeep</code>: Match <code>regex</code> against all label names. Any label that does not match will be removed from the set of labels.</li>
</ul>
<h3 id="alerting"><a href="#alerting" class="headerlink" title="alerting"></a>alerting</h3><h3 id="remote-write"><a href="#remote-write" class="headerlink" title="remote_write"></a>remote_write</h3><h3 id="remote-read"><a href="#remote-read" class="headerlink" title="remote_read"></a>remote_read</h3><h2 id="Alert-Rules"><a href="#Alert-Rules" class="headerlink" title="Alert Rules"></a>Alert Rules</h2><p>Prometheus中的告警规则允许你基于PromQL表达式定义告警触发条件，Prometheus后端对这些触发规则进行周期性计算，当满足触发条件后则会触发告警通知。默认情况下，用户可以通过Prometheus的Web界面查看这些告警规则以及告警的触发状态。当Promthues与Alertmanager关联之后，可以将告警发送到外部服务如Alertmanager中并通过Alertmanager可以对这些告警进行进一步的处理。</p>
<h3 id="定义告警规则"><a href="#定义告警规则" class="headerlink" title="定义告警规则"></a>定义告警规则</h3><p>一条典型的告警规则如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">HighErrorRate</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">job:request_latency_seconds:mean5m&#123;job="myjob"&#125;</span> <span class="string">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">High</span> <span class="string">request</span> <span class="string">latency</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">description</span> <span class="string">info</span></span><br></pre></td></tr></table></figure>
<p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：</p>
<ul>
<li>alert：告警规则的名称。</li>
<li>expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。</li>
<li>for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。</li>
<li>labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。</li>
<li>annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。</li>
</ul>
<p>为了能够让Prometheus能够启用定义的告警规则，我们需要在Prometheus全局配置文件中通过<strong>rule_files</strong>指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p>默认情况下Prometheus会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过<code>evaluation_interval</code>来覆盖默认的计算周期：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">evaluation_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<h3 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h3><p>一般来说，在告警规则文件的annotations中使用<code>summary</code>描述告警的概要信息，<code>description</code>用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations的中标签的值。</p>
<p>通过<code>$labels.&lt;labelname&gt;</code>变量可以访问当前告警实例中指定标签的值。$value则可以获取当前PromQL表达式计算的样本值。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># To insert a firing element's label values:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$labels.&lt;labelname&gt;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="comment"># To insert the numeric expression value of the firing element:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$value</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>例如，可以通过模板化优化summary以及description的内容的可读性：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes."</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that has a median request latency &gt;1s.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">APIHighRequestLatency</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">api_http_request_latencies_second&#123;quantile="0.5"&#125;</span> <span class="string">&gt;</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"High request latency on <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> has a median request latency above 1s (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>s)"</span></span><br></pre></td></tr></table></figure>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>配置 Alert Rules，修改 Prometheus 配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span></span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">rule_files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/recording_rules.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/alerting_rules.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/rules</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/alerts</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['node-exporter:9100']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'container'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['cadvisor:8080']</span></span><br><span class="line">  <span class="attr">alerting_rules.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hostStatsAlert</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">hostMemUsageAlert</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">(sum(node_memory_MemTotal_bytes)</span> <span class="bullet">-</span> <span class="string">sum(node_memory_MemFree_bytes</span> <span class="string">+</span> <span class="string">node_memory_Buffers_bytes+node_memory_Cached_bytes))</span> <span class="string">/</span> <span class="string">sum(node_memory_MemTotal_bytes)</span> <span class="string">&gt;</span> <span class="number">0.55</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">        <span class="attr">annotations:</span></span><br><span class="line">            <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usgae high"</span></span><br><span class="line">            <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usage above 85% (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>)"</span></span><br><span class="line">  <span class="attr">alerts:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">recording_rules.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">rules:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>重启Prometheus后访问Prometheus UI 可以查看当前以加载的规则文件：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-rules.png"></p>
<p>切换到Alerts标签可以查看当前告警的活动状态。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-alerts.png"></p>
<p>现在只是在 Prometheus Web 页面查看警告，通过配置 <code>Alert Manager</code> 可以实现连接钉钉/Slack等平台报警。</p>
<h2 id="Recording-Rules"><a href="#Recording-Rules" class="headerlink" title="Recording Rules"></a>Recording Rules</h2><p>通过PromQL可以实时对Prometheus中采集到的样本数据进行查询，聚合以及其它各种运算操作。而在某些PromQL较为复杂且计算量较大时，直接使用PromQL可能会导致Prometheus响应超时的情况。这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。Prometheus通过Recoding Rule规则支持这种后台计算的方式，可以实现对复杂查询的性能优化，提高查询效率。</p>
<p>在Prometheus配置文件中，通过rule_files定义recoding rule规则文件的访问路径。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p>每一个规则文件通过以下格式进行定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule_group&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p>一个简单的规则文件可能是这个样子的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">record:</span> <span class="string">job:http_inprogress_requests:sum</span></span><br><span class="line">      <span class="attr">expr:</span> <span class="string">sum(http_inprogress_requests)</span> <span class="string">by</span> <span class="string">(job)</span></span><br></pre></td></tr></table></figure>
<p>rule_group的具体配置项如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The name of the group. Must be unique within a file.</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often rules in the group are evaluated.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.evaluation_interval</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p>与告警规则一致，一个group下可以包含多条规则rule。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The name of the time series to output to. Must be a valid metric name.</span></span><br><span class="line"><span class="attr">record:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The PromQL expression to evaluate. Every evaluation cycle this is</span></span><br><span class="line"><span class="comment"># evaluated at the current time, and the result recorded as a new set of</span></span><br><span class="line"><span class="comment"># time series with the metric name as given by 'record'.</span></span><br><span class="line"><span class="attr">expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Labels to add or overwrite before storing the result.</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p>根据规则中的定义，Prometheus会在后台完成expr中定义的PromQL表达式计算，并且将计算结果保存到新的时间序列record中。同时还可以通过labels为这些样本添加额外的标签。</p>
<p>这些规则文件的计算频率与告警规则计算频率一致，都通过global.evaluation_interval定义:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  [ evaluation_interval: &lt;duration&gt; |<span class="built_in"> default </span>= 1m ]</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/vovlie/p/7709312.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/vovlie/p/7709312.html</a></li>
<li><a href="https://www.infoq.cn/article/Prometheus-theory-source-code" target="_blank" rel="external nofollow noopener noreferrer">https://www.infoq.cn/article/Prometheus-theory-source-code</a></li>
<li><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="external nofollow noopener noreferrer">https://yunlzheng.gitbook.io/prometheus-book/</a></li>
<li><a href="https://yasongxu.gitbook.io/container-monitor/" target="_blank" rel="external nofollow noopener noreferrer">https://yasongxu.gitbook.io/container-monitor/</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>monitoring</tag>
        <tag>prometheus</tag>
        <tag>可观测性</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】监控的可观测性</title>
    <url>/posts/58272b06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>监控是大型分布式系统的重要基础设施，可以帮助开发者查看系统的运行状态。</p>
<a id="more"></a>
<h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><h3 id="监控类型"><a href="#监控类型" class="headerlink" title="监控类型"></a>监控类型</h3><ul>
<li>资源监控：监控CPU、内存、网络等资源的指标</li>
<li>性能监控：APM（Application Performance Monitoring）监控</li>
<li>安全监控：对越权管理、安全漏洞扫描等监控</li>
<li>事件监控：对k8s中的事件监控</li>
</ul>
<h3 id="资源指标"><a href="#资源指标" class="headerlink" title="资源指标"></a>资源指标</h3><p>对于kubernetes集群进行监控，主要可以分为两类：</p>
<ul>
<li>监控集群本身</li>
<li>监控Pod对象</li>
</ul>
<p>对于集群本身的监控主要包括：</p>
<ul>
<li>节点资源状态：主要包括网络带宽、磁盘空间、CPU和内存使用率</li>
<li>节点的数量：即时性了解集群的可用节点数量可以为用户计算服务器使用的费用支出提供参考</li>
<li>运行的Pod对象：正在运行的Pod对象数量可以评估可用节点数量是否足够，以及节点故障时是否能平衡负载。</li>
</ul>
<p>对于Pod资源的监控主要分为以下三类：</p>
<ul>
<li>Kubernetes指标：监测特定应用相关的Pod对象的部署过程、副本数量、状态信息、健康状态、网络使用等</li>
<li>容器级指标：容器的Resource Request、Resource Limit、CPU、内存、磁盘空间、网络带宽的实际占用情况</li>
<li>应用级指标：应用自身的内建指标，和业务规则相关</li>
</ul>
<h2 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h2><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="Docker-Stats"><a href="#Docker-Stats" class="headerlink" title="Docker Stats"></a>Docker Stats</h3><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_cadvisor.png"></p>
<h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><h3 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png"></p>
<h3 id="Kube-State-Metrics"><a href="#Kube-State-Metrics" class="headerlink" title="Kube-State-Metrics"></a>Kube-State-Metrics</h3><h3 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node-Exporter"></a>Node-Exporter</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p>
<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p><img alt="Prometheus" data-src="https://cdn.nlark.com/lark/0/2018/png/25353/1537426329901-660f59fd-12eb-441c-a637-28467b6447ff.png"></p>
<h2 id="展示与报警"><a href="#展示与报警" class="headerlink" title="展示与报警"></a>展示与报警</h2><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><h3 id="Zabbix-Dashboard"><a href="#Zabbix-Dashboard" class="headerlink" title="Zabbix Dashboard"></a>Zabbix Dashboard</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/monitoring_architecture.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes monitoring architecture</a></li>
<li><a href="https://yasongxu.gitbook.io/container-monitor" target="_blank" rel="external nofollow noopener noreferrer">https://yasongxu.gitbook.io/container-monitor</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>container</tag>
        <tag>k8s</tag>
        <tag>cAdvisor</tag>
        <tag>Prometheus</tag>
        <tag>metrics</tag>
        <tag>observability</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana 入门</title>
    <url>/posts/588dbd28/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Grafana是一个开源的度量分析与可视化套件。经常被用作基础设施的时间序列数据和应用程序分析的可视化，它在其他领域也被广泛的使用包括工业传感器、家庭自动化、天气和过程控制等。</p>
<a id="more"></a>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">grafana/grafana:7.0.5</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_USER</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">admin321</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">472</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">472</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里设置了环境变量<code>GF_SECURITY_ADMIN_USER</code>和<code>GF_SECURITY_ADMIN_PASSWORD</code>，用来配置 grafana 的管理员用户和密码的。由于 grafana 将 dashboard、插件这些数据保存在<code>/var/lib/grafana</code>这个目录下面的，所以我们这里如果需要做数据持久化的话，就需要针对这个目录进行 volume 挂载声明。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br></pre></td></tr></table></figure>
<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">grafana.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">grafana</span></span><br></pre></td></tr></table></figure>
<p>创建 <code>Deployment</code> 和 <code>Service</code> 之后，即可在浏览器访问 Grafana 对应的服务。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_grafana.png"></p>
<h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>Grafana默认支持的数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch。Grafana支持同时绑定多套数据源，根据自己需求管理即可，下面以 Prometheus 数据源为基准作为示例。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-23_grafana-data-source.png"></p>
<p>这里需要配置的主要参数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置项</th>
<th>配置解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>数据源名称，建议以数据源类型+用途命名</td>
</tr>
<tr>
<td>Type</td>
<td>数据源类型，选择对应的InfluxDB、Prometheus等即可</td>
</tr>
<tr>
<td>URL</td>
<td>填写Prometheus对应的API地址即可，如果Grafana跟Prometheus在同一个Namespace，可以直接ServiceName：<code>http://prometheus:9090</code></td>
</tr>
<tr>
<td>Access</td>
<td>API访问方式，一共有 Server 和 Browser 两个选项，建议选择 Server</td>
</tr>
<tr>
<td>Access-Browser</td>
<td>浏览器直连数据源API，然后由Grafana解析返回的数据</td>
</tr>
<tr>
<td>Access-Server</td>
<td>Grafana后端通过API访问数据源，然后返回给浏览器展示</td>
</tr>
</tbody>
</table>
</div>
<p>数据源添加/更新成功后会有如下提示：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-23_grafana-data-source2.png"></p>
<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>仪表盘（Dashboard），顾名思义，就是管理各种图表的地方，主要由行（Row）+图表面板（Panel）组成。你可以根据自己的需求手动新建一个Dashboard，也可以从 Grafana 的官方网站导入。</p>
<h3 id="导入-Dashboard"><a href="#导入-Dashboard" class="headerlink" title="导入 Dashboard"></a>导入 Dashboard</h3><p>这里从选择倒入<a href="https://grafana.com/grafana/dashboards/8919" target="_blank" rel="external nofollow noopener noreferrer"><em>Node Exporter for Prometheus Dashboard CN</em></a>：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-23_grafana-import.png"></p>
<p>导入之后，显示统计数据如下所示：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p>
<h3 id="添加-Dashboard"><a href="#添加-Dashboard" class="headerlink" title="添加 Dashboard"></a>添加 Dashboard</h3><p>我们也可以完全手动创建 Dashboard，添加面板（Panel）</p>
<p>Panel主要支持：Graph，Singlestat，Dashlist，Table和Text。这里我们以曲线图（Graph）为例</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-22_grafana-add-panel.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.qikqiak.com/post/grafana-usage-in-k8s" target="_blank" rel="external nofollow noopener noreferrer">https://www.qikqiak.com/post/grafana-usage-in-k8s</a></li>
<li><a href="https://ken.io/note/grafana-quickstart-influxdb-datasource-graph" target="_blank" rel="external nofollow noopener noreferrer">https://ken.io/note/grafana-quickstart-influxdb-datasource-graph</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>可观测性</tag>
        <tag>监控</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>The Social Dilemma</title>
    <url>/posts/b86144be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Back on track，本周继续「朝花夕拾」的定期发布，这里是今年的第二十四期「The Social Dilemma」，标题来自最新 Netflix 推出的一个剧情式纪录片。本期会简单聊聊社交困境，除了纪录片所涵盖的内容，还包括自己从字面上对其的漫无边际的延伸思考。</p>

    <div id="aplayer-NPuFTSyB" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="446874778" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>这周末出去和高中同学KM一起吃了顿饭，跟进了同学间的动态，最大的感慨就是，班上有几个同学自从高中毕业之后就如同人间蒸发了一半，再也没有消息。北京有雾霾了，没有太出去拍照，自己在家做饭看剧。嗯，我越来越喜欢吃意大利面了，真香。</p>
<p>继续看数据，首先是Rescue Time：</p>
<ul>
<li>工作日的ScreenTime依旧是9个小时左右，其中周三因为公司消防演练降低了很多，周五因为一些事情走的比较早，此处不表</li>
<li>具体到实际每个应用，可以看到企业微信是软件开发以外占据时间最多的，这个感觉可以具体到某个时间来处理，避免每次进入到状态的时候被打断</li>
<li>周末的时间就很分散，现在对于周末的一个感觉就是时间太短，本来很多想做的事情都没有做完（比如这次的朝花夕拾）</li>
</ul>
<p><img alt="Rescue Time" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-15_rescue-time.png"></p>
<p>还是希望自己的时间使用能够更专注更有效，不喜欢那种漫无目的的刷，下周继续观察。</p>
<p>时间方面谷歌日历已经可以做到每天具体的时间分配在什么事项上，但是每天的总结还是欠缺，下周开始补上。接下来是Forest专注时间观察，</p>
<p><img alt="Forest - Nov 8 ~ Nov 14, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_forest.jpg"></p>
<p>这周加入一个新的观察纬度，那就是健身数据，目前我的健身行为比较单一，就暂且以跑步的数字作为衡量。是的，在年初的时候，我给自己定下的目标是700公里，今年实际完成度很低。以年为单位总是会让人松懈，本周开始加入每周的跑步数据观察：</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Running Records" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_year-running.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Running - Nov 8 ~ Nov 14, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_running.jpg"></div></div></div></div>
<p>这里还希望加入的一个观察数据是睡眠时间，前一周看每天的上班时间，经常性的9点才出门，早上不想起来，晚上也睡的很晚。为了改善这个方面，继续立Flag。</p>
<h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h4 id="反垄断法"><a href="#反垄断法" class="headerlink" title="反垄断法"></a>反垄断法</h4><p>背景：11月10日上午，国家市场监管总局发布《关于平台经济领域的反垄断指南（征求意见稿）》公开征求意见，目的是为预防和制止平台经济领域垄断行为，加强和改进平台经济领域反垄断监管，保护市场公平竞争，维护消费者利益和社会公共利益。指南发布后，阿里、美团、腾讯、京东等企业股价大跌。</p>
<p>分析：中国互联网野蛮生长了二十年，终于发展到现在足以影响到每一个人的体量。互联网企业作为平台型企业，做大之后开始从各个环节抽佣。另一方面，电商平台的二选一，社交平台的链接封杀，都引起了众多争议。这一次的反垄断指南，从某个方面反映了政府监管部门对于大平台问题的重视。但是，毕竟是平台型企业，反垄断指南能够执行到何种程度仍然值得观望，股价该回来还是会回来的。</p>
<h4 id="荣耀拆分出售"><a href="#荣耀拆分出售" class="headerlink" title="荣耀拆分出售"></a>荣耀拆分出售</h4><p>背景：荣耀拆分出售从最早的传闻到现越来越像真的了。本次传闻：根据去年荣耀60亿元利润，16倍PE来定，约为1000亿人民币，<strong>收购方包括神州数码、三家国资机构，以及TCL等公司组成的小股东阵营</strong>。拆分的缘由还是美国封杀，若华为分拆或出售荣耀手机，荣耀手机的采购零部件不受美国的华为禁令限制，将有助荣耀手机业务与供货商增长，这对荣耀品牌、供货商以及大陆电子业都是多赢局面。</p>
<p>分析：拜登当选，美国封杀令是否仍会继续？如果不再继续，华为是否能够凤凰涅槃，继续关注。</p>
<h4 id="Mac换芯"><a href="#Mac换芯" class="headerlink" title="Mac换芯"></a>Mac换芯</h4><p>背景：苹果发布M1芯片，宣布笔记本等产品线将从Intel芯片切换到基于ARM自研的M1芯片。</p>
<p>分析：从最早的PowerPC，到现在的M1，苹果软硬件一体的初心依然不变。这当然得益于其开创的软硬件生态，也是因为牙膏厂最年来牙膏越来越难挤了。关于M1具体细节尚未研究，不过毕竟是新体系下的第一款芯片，仍然需要时间打磨，现在的主要卖点应该还是功耗。</p>
<h4 id="辉瑞疫苗"><a href="#辉瑞疫苗" class="headerlink" title="辉瑞疫苗"></a>辉瑞疫苗</h4><p>背景：美国辉瑞制药和德国BioNTech在美股盘前宣布了其合作新冠疫苗的三期临床实验的首批结果，显示其有效性超过90%。受这一消息影响，欧美股市突然暴涨，道指期货涨逾5%，欧洲三大股指全线拉升，与此同时，随着全球风险偏好回升，美元、黄金等避险资产大幅下挫。</p>
<p>分析：疫苗才是真正的群体免疫。但是疫苗是否能够应对新冠病毒变异，是否最后真正有效，还需要继续观察，至少这个冬天应该还用不了。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>本期主题是「The Social Dilemma」，主题就是讲述了互联网公司通过获取用户数据，通过社交媒体来影响用户的事情。</p>
<p>这并不是一个新话题，早在年初的时候我就在 <a href="../3e030bdb/">Carpe Diem</a> 里面简单讨论过这个话题。正如那句话，羊毛出在猪身上，互联网用户享受的免费便捷的互联网产品是由广告厂商们为之付费的。互联网用户并不是大厂们的客户，广告商才是。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>反垄断</tag>
        <tag>surveillance capitalism</tag>
        <tag>平台</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统监控】Node Exporter</title>
    <url>/posts/dd1e183c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Exporter 是Prometheus的一类数据采集组件的总称，负责从目标处搜集数据，并将其转化为Prometheus支持的格式。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取，默认的抓取地址为 <code>http://current_ip:9100/metrics</code>。Node Exporter 用于采集服务器层面的运行指标，包括机器的 loadavg、filesystem、meminfo等基础监控，类似于传统主机监控维度的zabbix-agent。<code>Node Export</code> 由prometheus官方提供、维护，不会捆绑安装，但基本上是必备的exporter。</p>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>node-exporter用于提供*NIX内核的硬件以及系统指标。</p>
<ul>
<li>如果是windows系统，可以使用<a href="https://github.com/martinlindhe/wmi_exporter" target="_blank" rel="external nofollow noopener noreferrer">WMI exporter</a></li>
<li>如果是采集NVIDIA的GPU指标，可以使用<a href="https://github.com/NVIDIA/gpu-monitoring-tools/tree/master/exporters/prometheus-dcgm" target="_blank" rel="external nofollow noopener noreferrer">prometheus-dcgm </a></li>
</ul>
<p>根据不同的*NIX操作系统，node-exporter采集指标的支持也是不一样的，如：</p>
<ul>
<li>diskstats 支持    Darwin, Linux</li>
<li>cpu 支持Darwin, Dragonfly, FreeBSD, Linux, Solaris等，</li>
</ul>
<p>详细信息参考：<a href="https://github.com/prometheus/node_exporter" target="_blank" rel="external nofollow noopener noreferrer">node_exporter</a></p>
<p>我们可以使用 —collectors.enabled参数指定node_exporter收集的功能模块,或者用—no-collector指定不需要的模块，如果不指定，将使用默认配置。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">'true'</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scrape</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9100</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>
<h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/node-exporter:v1.0.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">scrape</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>得到一个daemonset和一个service对象，部署后，为了能够让Prometheus能够从当前node exporter获取到监控数据，这里需要修改Prometheus配置文件。编辑 <code>prometheus.yml</code> 并在scrape_configs节点下添加以下内容:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrape_configs</span>:</span><br><span class="line">  # 采集node exporter监控数据</span><br><span class="line">  - <span class="attribute">job_name</span>: <span class="string">'node'</span></span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'localhost:9100'</span>]</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>prometheus.io/scrape: &#39;true&#39;</code>标识来自动获取service的metric接口</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>source<span class="emphasis">_labels: [_</span><span class="emphasis">_meta_</span>kubernetes<span class="emphasis">_service_</span>annotation<span class="emphasis">_prometheus_</span>io<span class="emphasis">_scrape]</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，重启prometheus就能看到对应的指标</p>
<p><strong>直接查看：</strong></p>
<p>如果是二进制或者docker部署，部署成功后可以访问：<a href="http:///${IP}:9100/metrics">http://${IP}:9100/metrics</a></p>
<p>会输出下面格式的内容，包含了node-exporter暴露的所有指标：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0"</span>&#125; 6.1872e-05</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.25"</span>&#125; 0.000119463</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.5"</span>&#125; 0.000151156</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.75"</span>&#125; 0.000198764</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"1"</span>&#125; 0.009889647</span><br><span class="line">go_gc_duration_seconds_sum 0.257232201</span><br><span class="line">go_gc_duration_seconds_count 1187</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HELP node_cpu Seconds the cpus spent in each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu counter</span></span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="guest"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="guest_nice"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="idle"&#125; 68859.19</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="iowait"&#125; 167.22</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="irq"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="nice"&#125; 19.92</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="softirq"&#125; 17.05</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="steal"&#125; 28.1</span><br></pre></td></tr></table></figure>
<p><strong>Prometheus查看：</strong></p>
<p>类似go_gc_duration_seconds和node_cpu就是metric的名称，如果使用了Prometheus,则可以在<code>http://${IP}:9090/</code> 页面的指标中搜索到以上的指标：</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_node-exporter-metrics.png"></p>
<p>常用指标类型有：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">node_cpu：系统CPU使用量</span><br><span class="line">node_disk*：磁盘IO</span><br><span class="line">node_filesystem*：文件系统用量</span><br><span class="line">node_load1：系统负载</span><br><span class="line">node_memeory*：内存使用量</span><br><span class="line">node_network*：网络带宽</span><br><span class="line">node_time：当前系统时间</span><br><span class="line">go_*：<span class="keyword">node</span> <span class="title">exporter</span>中go相关指标</span><br><span class="line">process_*：<span class="keyword">node</span> <span class="title">exporter</span>自身进程相关运行指标</span><br></pre></td></tr></table></figure>
<p><strong>Grafana查看：</strong></p>
<p>Prometheus虽然自带了web页面，但一般会和更专业的Grafana配套做指标的可视化，Grafana有很多模板，用于更友好地展示出指标的情况，如<a href="https://grafana.com/dashboards/8919" target="_blank" rel="external nofollow noopener noreferrer">Node Exporter for Prometheus</a></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p>
<p>在grafana中配置好变量、导入模板就会有上图的效果。</p>
<h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><p>node-exporter是Prometheus官方推荐的exporter，类似的还有</p>
<ul>
<li><a href="https://github.com/prometheus/haproxy_exporter" target="_blank" rel="external nofollow noopener noreferrer">HAProxy exporter</a></li>
<li><a href="https://github.com/prometheus/collectd_exporter" target="_blank" rel="external nofollow noopener noreferrer">Collectd exporter</a></li>
<li><a href="https://github.com/prometheus/snmp_exporter" target="_blank" rel="external nofollow noopener noreferrer">SNMP exporter</a></li>
<li><a href="https://github.com/prometheus/mysqld_exporter" target="_blank" rel="external nofollow noopener noreferrer">MySQL server exporter</a></li>
<li>….</li>
</ul>
<p>官方推荐的都会在<a href="https://github.com/prometheus下，在[exporter推荐页](https://prometheus.io/docs/instrumenting/exporters/)，也会有很多第三方的exporter，由个人或者组织开发上传，如果有自定义的采集需求，可以自己编写[exporter](https://prometheus.io/docs/instrumenting/writing_exporters/)。" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/prometheus下，在[exporter推荐页](https://prometheus.io/docs/instrumenting/exporters/)，也会有很多第三方的exporter，由个人或者组织开发上传，如果有自定义的采集需求，可以自己编写[exporter](https://prometheus.io/docs/instrumenting/writing_exporters/)。</a></p>
<h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p>node-exporter的主函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package collector includes all individual collectors to gather and export system metrics.</span></span><br><span class="line"><span class="keyword">package</span> collector</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/common/log"</span></span><br><span class="line">    <span class="string">"gopkg.in/alecthomas/kingpin.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Namespace defines the common namespace to be used by all metrics.</span></span><br><span class="line"><span class="keyword">const</span> namespace = <span class="string">"node"</span></span><br></pre></td></tr></table></figure>
<p>可以看到exporter的实现需要引入github.com/prometheus/client_golang/prometheus库，client_golang是prometheus的官方go库，既可以用于集成现有应用，也可以作为连接Prometheus HTTP API的基础库。</p>
<p>比如定义了基础的数据类型以及对应的方法：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">Counter：收集事件次数等单调递增的数据</span><br><span class="line">Gauge：收集当前的状态，比如数据库连接数</span><br><span class="line"><span class="keyword">Histogram</span>：收集随机正态分布数据，比如响应延迟</span><br><span class="line">Summary：收集随机正态分布数据，和 <span class="keyword">Histogram</span> 是类似的</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>monitoring</tag>
        <tag>可观测性</tag>
      </tags>
  </entry>
  <entry>
    <title>时序数据库 InfluxDB</title>
    <url>/posts/c57001b4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>InfluxDB 是使用 Go 编写的基于时间序列的数据库，用于存储大量带有时间戳的数据，报错 DevOps 监控，日志数据，应用程序的指标、数据分析数据等等。通过 InfluxDB 自动保存数据，你不需要删除和清理，只需要定义一段时间 DB 会帮你自动清理。</p>
<a id="more"></a>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>InfluxDB 和传统数据库（如：MySQL）的一些区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">InfluxDB</th>
<th style="text-align:center">传统数据库中的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">database</td>
<td style="text-align:center">数据库</td>
</tr>
<tr>
<td style="text-align:center">measurement</td>
<td style="text-align:center">数据库中的表</td>
</tr>
<tr>
<td style="text-align:center">points</td>
<td style="text-align:center">表里面的一行数据</td>
</tr>
</tbody>
</table>
</div>
<h3 id="特有概念"><a href="#特有概念" class="headerlink" title="特有概念"></a>特有概念</h3><ol>
<li><p>tag–标签，在 InfluxDB 中，tag 是一个非常重要的部分，表名+tag 一起作为数据库的索引，是“key-value”的形式</p>
</li>
<li><p>field–数据，field 主要是用来存放数据的部分，也是“key-value”的形式</p>
</li>
<li><p>timestamp–时间戳，作为时序型数据库，时间戳是 InfluxDB 中最重要的部分，在插入数据时可以自己指定也可留空让系统指定</p>
<p><strong>说明</strong>：<em>在插入新数据时，tag、field 和 timestamp 之间用空格分隔</em></p>
</li>
<li><p>series–序列，所有在数据库中的数据，都需要通过图表来展示，而这个 series 表示这个表里面的数据，可以在图表上画成几条线。具体可以通过 <code>SHOW SERIES FROM &quot;表名&quot;</code> 进行查询</p>
</li>
<li><p>Retention policy–数据保留策略，可以定义数据保留的时长，每个数据库可以有多个数据保留策略，但只能有一个默认策略</p>
</li>
<li><p>Point–点，表示每个表里某个时刻的某个条件下的一个 field 的数据，因为体现在图表上就是一个点，于是将其称为 point。Point 由时间戳（time）、数据（field）、标签（tags）组成</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Point 属性</th>
<th style="text-align:center">传统数据库中的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">time</td>
<td style="text-align:center">每个数据记录时间，是数据库中的主索引 (会自动生成)</td>
</tr>
<tr>
<td style="text-align:center">fields</td>
<td style="text-align:center">表中的列（没有索引的属性）也就是记录的值：温度， 湿度</td>
</tr>
<tr>
<td style="text-align:center">tags</td>
<td style="text-align:center">表中的索引：地区，海拔</td>
</tr>
</tbody>
</table>
</div>
<h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><ul>
<li>8083：Web admin 管理服务的端口, <a href="http://localhost:8083/" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:8083</a></li>
<li>8086：HTTP API 的端口</li>
<li>8088：集群端口 (目前还不是很清楚, 配置在全局的 bind-address，默认不配置就是开启的)</li>
</ul>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">influxdb:1.7.4</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30004</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br></pre></td></tr></table></figure>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f influx.yaml</span><br><span class="line">$ kubectl get pod -n monitoring</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">influxdb-685854ccf7-mlr4g   1/1     Running   0          11m</span><br><span class="line">$ kubectl get svc -n monitoring</span><br><span class="line">NAME       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">influxdb   NodePort   172.18.253.93   &lt;none&gt;        8086:30004/TCP   11m</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it influxdb-685854ccf7-mlr4g bash -n monitoring</span><br><span class="line">root@influxdb-685854ccf7-mlr4g:/<span class="comment"># influx</span></span><br><span class="line">Connected to http://localhost:8086 version 1.7.4</span><br><span class="line">InfluxDB shell version: 1.7.4</span><br><span class="line">Enter an InfluxQL query</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="客户端命令操作"><a href="#客户端命令操作" class="headerlink" title="客户端命令操作"></a>客户端命令操作</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>CREATE DATABASE {NAME};</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; create database houmin</span><br><span class="line">&gt; show databases</span><br><span class="line">name: databases</span><br><span class="line">name</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">_internal</span><br><span class="line">houmin</span><br></pre></td></tr></table></figure>
<ul>
<li>这时候我们发现数据库有一个表“_internal”，其实这个表是 influxdb 数据库的一些指标存储库。有点类似 mysql 数据库的 mysql 库。</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>DROP DATABASE {NAME};</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; drop database houmin</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>USE {DB}</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; use houmin</span><br><span class="line">Using database houmin</span><br></pre></td></tr></table></figure>
<h3 id="数据表和数据操作"><a href="#数据表和数据操作" class="headerlink" title="数据表和数据操作"></a>数据表和数据操作</h3><p>建库的操作可以发现非常类似于 MySQL 下的操作。而在 InfluxDB 下没有细分的表的概念，InfluxDB 下的表在插入数据库的时候自动会创建。可以通过 <code>show measurements</code> 命令查看所有的表，这个类似于 MySQL 下的<code>show tables</code></p>
<h4 id="显示所有表"><a href="#显示所有表" class="headerlink" title="显示所有表"></a>显示所有表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; show measurements</span><br><span class="line">name: measurements</span><br><span class="line">name</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">cpu</span><br><span class="line">temperature</span><br></pre></td></tr></table></figure>
<h4 id="新建表（写数据）"><a href="#新建表（写数据）" class="headerlink" title="新建表（写数据）"></a>新建表（写数据）</h4><p>标准格式，注意在写数据的时候如果不添加时间戳，系统会默认添加一个时间。InfluxDB 中没有显式的新建表的语句，只能通过 insert 数据的方式来建立新表。</p>
<ul>
<li>语法格式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> &lt;measurement&gt;[,&lt;tag-<span class="keyword">key</span>&gt;=&lt;tag-<span class="keyword">value</span>&gt;...] &lt;<span class="keyword">field</span>-<span class="keyword">key</span>&gt;=&lt;<span class="keyword">field</span>-<span class="keyword">value</span>&gt;[,&lt;field2-<span class="keyword">key</span>&gt;=&lt;field2-<span class="keyword">value</span>&gt;...] [unix-nano-<span class="built_in">timestamp</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; INSERT cpu,host=serverA,region=us_west value=0.64</span><br><span class="line"></span><br><span class="line">&gt; INSERT temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000</span><br></pre></td></tr></table></figure>
<h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; drop measurement disk_free</span><br><span class="line">&gt; show measurements</span><br><span class="line">name: measurements</span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line">name</span><br><span class="line">weather</span><br></pre></td></tr></table></figure>
<h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>查询语句与 SQL 一样，不用过多的学习</p>
<ul>
<li>查询数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT "host", "region", "value" FROM "cpu"</span><br><span class="line">name: cpu</span><br><span class="line">time                host    region  value</span><br><span class="line"><span class="comment">----                ----    ------  -----</span></span><br><span class="line">1600221790602821979 serverA us_west 0.64</span><br></pre></td></tr></table></figure>
<ul>
<li>每个表输出一行（支持 Go 语言的正则表达式、支持类似于 MySQL 中的 limit 语句）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT * FROM /.*/ LIMIT 1</span><br><span class="line">name: cpu</span><br><span class="line">time                external host    internal machine region  type value</span><br><span class="line"><span class="comment">----                -------- ----    -------- ------- ------  ---- -----</span></span><br><span class="line">1563895618490964877          serverA                  us_west      0.64</span><br><span class="line"></span><br><span class="line">name: temperature</span><br><span class="line">time                external host internal machine region type     value</span><br><span class="line"><span class="comment">----                -------- ---- -------- ------- ------ ----     -----</span></span><br><span class="line">1434067467000000000 25            37       unit42         assembly</span><br></pre></td></tr></table></figure>
<h4 id="修改和删除数据"><a href="#修改和删除数据" class="headerlink" title="修改和删除数据"></a>修改和删除数据</h4><p>InfluxDB 属于时序数据库，没有提供修改和删除数据的方法。</p>
<p>但是删除可以通过 InfluxDB 的数据保存策略（Retention Policies）来实现</p>
<p>update 更新语句没有，不过有 alter 命令，在 influxdb 中，删除操作用和更新基本不用到 。在针对数据保存策略方面，有一个特殊的删除方式，这个后面再提。</p>
<h3 id="series-操作"><a href="#series-操作" class="headerlink" title="series 操作"></a>series 操作</h3><p>series 表示这个表里面的数据，可以在图表上画成几条线，series 主要通过 tags 排列组合算出来。</p>
<p>我们可以查询表的 series，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; show series from cpu</span><br><span class="line">key</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">cpu,host=serverA,region=us_east</span><br><span class="line">cpu,host=serverA,region=us_west</span><br><span class="line">cpu,host=serverX,region=us_east</span><br><span class="line">cpu,host=serverX,region=us_west</span><br></pre></td></tr></table></figure>
<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示用户</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">USERS</span></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">"username"</span> <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'password'</span></span><br><span class="line"><span class="comment"># 创建管理员权限的用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">"username"</span> <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'password'</span> <span class="keyword">WITH</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">"username"</span></span><br></pre></td></tr></table></figure>
<p>influxdb 的权限设置比较简单，只有读、写、ALL 几种。</p>
<h2 id="HTTP-API-操作"><a href="#HTTP-API-操作" class="headerlink" title="HTTP API 操作"></a>HTTP API 操作</h2><h3 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h3><div class="table-container">
<table>
<thead>
<tr>
<th>接口路径</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/debug/pprof</td>
<td>debug 排查问题使用</td>
</tr>
<tr>
<td>/debug/requests</td>
<td>使用这个请求监听最近是否有请求</td>
</tr>
<tr>
<td>/debug/vars</td>
<td>查询 influxdb 收集到静态信息</td>
</tr>
<tr>
<td>/ping</td>
<td>检测 influxdb 状态</td>
</tr>
<tr>
<td>/query</td>
<td>查询数据接口（同时可以创建库）</td>
</tr>
<tr>
<td>/write</td>
<td>写入数据接口（一个已存在数据库）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li>2xx：服务请求正常</li>
<li>4xx：代表请求语法有问题</li>
<li>5xx：服务端出问题，导致超时等故障</li>
</ul>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -i -XPOST http://localhost:8086/query --data-urlencode <span class="string">"q=CREATE DATABASE mydb"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 5edd88a8-ef90-11e8-83cd-a0999b0f94e3</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.0~n201811230800</span><br><span class="line">X-Request-Id: 5edd88a8-ef90-11e8-83cd-a0999b0f94e3</span><br><span class="line">Date: Sat, 24 Nov 2018 02:26:38 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">&#123;<span class="string">"results"</span>:[&#123;<span class="string">"statement_id"</span>:0&#125;]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -i  -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary <span class="string">'cpu_load_short,host=server01,region=us-west value=0.65 1434055564000000000'</span></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 1ae386c4-ef91-11e8-83d8-a0999b0f94e3</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.0~n201811230800</span><br><span class="line">X-Request-Id: 1ae386c4-ef91-11e8-83d8-a0999b0f94e3</span><br><span class="line">Date: Sat, 24 Nov 2018 02:31:53 GMT</span><br></pre></td></tr></table></figure>
<h3 id="写入多个数据点"><a href="#写入多个数据点" class="headerlink" title="写入多个数据点"></a>写入多个数据点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -i -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary <span class="string">'cpu_load_short,host=server02 value=0.67</span></span><br><span class="line"><span class="string">HTTP/1.1 204 No Content</span></span><br><span class="line"><span class="string">Content-Type: application/json</span></span><br><span class="line"><span class="string">Request-Id: 086bd107-f7c3-11ea-803c-3a3192636d64</span></span><br><span class="line"><span class="string">X-Influxdb-Build: OSS</span></span><br><span class="line"><span class="string">X-Influxdb-Version: 1.7.4</span></span><br><span class="line"><span class="string">X-Request-Id: 086bd107-f7c3-11ea-803c-3a3192636d64</span></span><br><span class="line"><span class="string">Date: Wed, 16 Sep 2020 02:19:22 GMT</span></span><br></pre></td></tr></table></figure>
<h3 id="从文件导入数据库"><a href="#从文件导入数据库" class="headerlink" title="从文件导入数据库"></a>从文件导入数据库</h3><p>从文件导入时候建议不要超过 5000 条，如果超过请对文件进行切割，因为 http api 的接口 5s 会超时，请求数据过多会导致数据无法确认是否成功。<br>文件 cpu_data.txt 内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat cpu_data.txt</span><br><span class="line">cpu_load_short,host=server02 value=111</span><br><span class="line">cpu_load_short,host=server02,region=us-west value=0.222 1543027130702900257</span><br><span class="line">cpu_load_short,direction=<span class="keyword">in</span>,host=server01,region=us-west value=111.222 1543027129702900257</span><br><span class="line">$ curl -i -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary @cpu_data.txt</span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 40022e79-f7c3-11ea-803d-3a3192636d64</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.4</span><br><span class="line">X-Request-Id: 40022e79-f7c3-11ea-803d-3a3192636d64</span><br><span class="line">Date: Wed, 16 Sep 2020 02:20:55 GMT</span><br></pre></td></tr></table></figure>
<h2 id="数据保存策略（Retention-Policies）"><a href="#数据保存策略（Retention-Policies）" class="headerlink" title="数据保存策略（Retention Policies）"></a>数据保存策略（Retention Policies）</h2><p>InfluxDB 每秒可以处理成千上万条数据，要将这些数据全部保存下来会占用大量的存储空间，有时我们可能并不需要将所有历史数据进行存储。InfluxDB 没有提供直接删除 Points 的方法，但是它提供了 Retention Policies，用来让我们自定义数据的保留时间。</p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">RETENTION</span> POLICIES <span class="keyword">ON</span> <span class="string">"testDB"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">show</span> <span class="keyword">retention</span> policies <span class="keyword">on</span> <span class="string">"mydb"</span></span><br><span class="line"><span class="keyword">name</span>    <span class="keyword">duration</span> shardGroupDuration replicaN <span class="keyword">default</span></span><br><span class="line"><span class="comment">----    -------- ------------------ -------- -------</span></span><br><span class="line">autogen <span class="number">0</span>s       <span class="number">168</span>h0m0s           <span class="number">1</span>        <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RETENTION</span> <span class="keyword">POLICY</span> <span class="string">"rp_name"</span> <span class="keyword">ON</span> <span class="string">"db_name"</span> <span class="keyword">DURATION</span> <span class="number">30</span>d <span class="keyword">REPLICATION</span> <span class="number">1</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>rp_name：策略名</li>
<li>db_name：具体的数据库名</li>
<li>30d：保存 30 天，30 天之前的数据将被删除<br>它具有各种时间参数，比如：h（小时），w（星期）</li>
<li>REPLICATION 1：副本个数，这里填 1 就可以了</li>
<li>DEFAULT 设为默认的策略</li>
</ol>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ALTER RETENTION<span class="built_in"> POLICY </span><span class="string">"rp_name"</span> ON db_name<span class="string">" DURATION 3w DEFAULT</span></span><br></pre></td></tr></table></figure>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">DROP RETENTION<span class="built_in"> POLICY </span><span class="string">"rp_name"</span> ON <span class="string">"db_name"</span></span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>InfluxDB 提供了很多的有用的函数，这里列举了常用的三个维度函数，Use InfluxQL functions to aggregate, select, and transform data.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Aggregations</th>
<th>Selectors</th>
<th>Transformations</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#count" target="_blank" rel="external nofollow noopener noreferrer">COUNT()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#bottom" target="_blank" rel="external nofollow noopener noreferrer">BOTTOM()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#ceiling" target="_blank" rel="external nofollow noopener noreferrer">CEILING()</a></td>
</tr>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#distinct" target="_blank" rel="external nofollow noopener noreferrer">DISTINCT()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#first" target="_blank" rel="external nofollow noopener noreferrer">FIRST()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="external nofollow noopener noreferrer">DERIVATIVE()</a></td>
</tr>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#integral" target="_blank" rel="external nofollow noopener noreferrer">INTEGRAL()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#last" target="_blank" rel="external nofollow noopener noreferrer">LAST()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#difference" target="_blank" rel="external nofollow noopener noreferrer">DIFFERENCE()</a></td>
</tr>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#mean" target="_blank" rel="external nofollow noopener noreferrer">MEAN()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#max" target="_blank" rel="external nofollow noopener noreferrer">MAX()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#elapsed" target="_blank" rel="external nofollow noopener noreferrer">ELAPSED()</a></td>
</tr>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#median" target="_blank" rel="external nofollow noopener noreferrer">MEDIAN()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#min" target="_blank" rel="external nofollow noopener noreferrer">MIN()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#floor" target="_blank" rel="external nofollow noopener noreferrer">FLOOR()</a></td>
</tr>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#spread" target="_blank" rel="external nofollow noopener noreferrer">SPREAD()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#percentile" target="_blank" rel="external nofollow noopener noreferrer">PERCENTILE()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#histogram" target="_blank" rel="external nofollow noopener noreferrer">HISTOGRAM()</a></td>
</tr>
<tr>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#sum" target="_blank" rel="external nofollow noopener noreferrer">SUM()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#top" target="_blank" rel="external nofollow noopener noreferrer">TOP()</a></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#moving-average" target="_blank" rel="external nofollow noopener noreferrer">MOVING_AVERAGE()</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#non-negative-derivative" target="_blank" rel="external nofollow noopener noreferrer">NON_NEGATIVE_DERIVATIVE()</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#stddev" target="_blank" rel="external nofollow noopener noreferrer">STDDEV()</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="聚合类函数"><a href="#聚合类函数" class="headerlink" title="聚合类函数"></a>聚合类函数</h3><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT() 函数"></a>COUNT() 函数</h4><p>返回一个（field）字段中的非空值的数量。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&gt; SELECT COUNT(water<span class="emphasis">_level) FROM h2o_</span>feet</span><br><span class="line">name: h2o<span class="emphasis">_feet</span></span><br><span class="line"><span class="emphasis">--------------</span></span><br><span class="line"><span class="emphasis">time                           count</span></span><br><span class="line"><span class="emphasis">1970-01-01T00:00:00Z     15258</span></span><br></pre></td></tr></table></figure>
<p>说明 water_level 这个字段在 h2o_feet 表中共有 15258 条数据。</p>
<p>注意：InfluxDB 中的函数如果没有指定时间的话，会默认以 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间。</p>
<p>可以在 where 中加入时间条件，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT COUNT(water_level) FROM h2o_feet WHERE time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-09-18T17:00:00Z' GROUP BY time(4d)</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           count</span><br><span class="line">2015-08-17T00:00:00Z     1440</span><br><span class="line">2015-08-21T00:00:00Z     1920</span><br><span class="line">2015-08-25T00:00:00Z     1920</span><br><span class="line">2015-08-29T00:00:00Z     1920</span><br><span class="line">2015-09-02T00:00:00Z     1915</span><br><span class="line">2015-09-06T00:00:00Z     1920</span><br><span class="line">2015-09-10T00:00:00Z     1920</span><br><span class="line">2015-09-14T00:00:00Z     1920</span><br><span class="line">2015-09-18T00:00:00Z     335</span><br></pre></td></tr></table></figure>
<h4 id="DISTINCT-函数"><a href="#DISTINCT-函数" class="headerlink" title="DISTINCT() 函数"></a>DISTINCT() 函数</h4><p>返回一个字段（field）的唯一值。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT DISTINCT("level description") FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           distinct</span><br><span class="line">1970-01-01T00:00:00Z     between 6 and 9 feet</span><br><span class="line">1970-01-01T00:00:00Z     below 3 feet</span><br><span class="line">1970-01-01T00:00:00Z     between 3 and 6 feet</span><br><span class="line">1970-01-01T00:00:00Z     at or greater than 9 feet</span><br></pre></td></tr></table></figure>
<p>这个例子显示 level description 这个字段共有四个值，然后将其显示了出来，时间为默认时间。</p>
<h4 id="MEAN-函数"><a href="#MEAN-函数" class="headerlink" title="MEAN() 函数"></a>MEAN() 函数</h4><p>返回一个字段（field）中的值的算术平均值（平均值）。字段类型必须是长整型或 float64。</p>
<p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MEAN(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT MEAN(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           mean</span><br><span class="line">1970-01-01T00:00:00Z     4.286791371454075</span><br></pre></td></tr></table></figure>
<p>说明 water_level 字段的平均值为<code>4.286791371454075</code>，时间为默认时间，当然，你也可以加入 where 条件。</p>
<h4 id="MEDIAN-函数"><a href="#MEDIAN-函数" class="headerlink" title="MEDIAN() 函数"></a>MEDIAN() 函数</h4><p>从单个字段（field）中的排序值返回中间值（中位数）。字段值的类型必须是长整型或 float64 格式。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MEDIAN</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT MEDIAN(water_level) from h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           median</span><br><span class="line">1970-01-01T00:00:00Z     4.124</span><br></pre></td></tr></table></figure>
<p>说明表中 water_level 字段的中位数是 4.124</p>
<h4 id="SPREAD-函数"><a href="#SPREAD-函数" class="headerlink" title="SPREAD() 函数"></a>SPREAD() 函数</h4><p>返回字段的最小值和最大值之间的差值。数据的类型必须是长整型或 float64。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SPREAD(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT SPREAD(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            spread</span><br><span class="line">1970-01-01T00:00:00Z      10.574</span><br></pre></td></tr></table></figure>
<h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM() 函数"></a>SUM() 函数</h4><p>返回一个字段中的所有值的和。字段的类型必须是长整型或 float64。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT SUM(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           sum</span><br><span class="line">1970-01-01T00:00:00Z     67777.66900000002</span><br></pre></td></tr></table></figure>
<p>此语句计算出了 h2o_feet 表中 所有 water_level 字段的和。</p>
<h3 id="选择类函数"><a href="#选择类函数" class="headerlink" title="选择类函数"></a>选择类函数</h3><h4 id="TOP-函数"><a href="#TOP-函数" class="headerlink" title="TOP() 函数"></a>TOP() 函数</h4><p>作用：返回一个字段中最大的 N 个值，字段类型必须是长整型或 float64 类型。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT TOP("water_level",3) FROM "h2o_feet"</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">time                   top</span><br><span class="line"><span class="comment">----                   ---</span></span><br><span class="line">2015-08-29T07:18:00Z   9.957</span><br><span class="line">2015-08-29T07:24:00Z   9.964</span><br><span class="line">2015-08-29T07:30:00Z   9.954</span><br></pre></td></tr></table></figure>
<p>这个例子返回表中 water_level 字段中最大的三个值。</p>
<h4 id="BOTTOM-函数"><a href="#BOTTOM-函数" class="headerlink" title="BOTTOM() 函数"></a>BOTTOM() 函数</h4><p>作用：返回一个字段中最小的 N 个值。字段类型必须是长整型或 float64 类型。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BOTTOM(&lt;field_key&gt;[,&lt;tag_keys&gt;],&lt;N&gt;)[,&lt;tag_keys&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           bottom</span><br><span class="line">2015-08-29T14:30:00Z     -0.61</span><br><span class="line">2015-08-29T14:36:00Z     -0.591</span><br><span class="line">2015-08-30T15:18:00Z     -0.594</span><br></pre></td></tr></table></figure>
<p>这个例子返回表中 water_level 字段中最小的三个值。</p>
<p>也可将关联 tag 放在一起查询，但如果 tag 值少于 N 的值，则返回的值的个数只会取 tag 中字段值少的那个。</p>
<p>如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,location,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           bottom     location</span><br><span class="line">2015-08-29T10:36:00Z     -0.243     santa_monica</span><br><span class="line">2015-08-29T14:30:00Z     -0.61      coyote_creek</span><br></pre></td></tr></table></figure>
<p>语句取最小的三个值，然而结果只返回了 2 个值，因为 location 这个 tag 只有 两个取值。</p>
<h4 id="FIRST-函数"><a href="#FIRST-函数" class="headerlink" title="FIRST() 函数"></a>FIRST() 函数</h4><p>作用：返回一个字段中最老的取值。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT FIRST(water_level) FROM h2o_feet WHERE location = 'santa_monica'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           first</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br></pre></td></tr></table></figure>
<p>这个语句返回了 在 location 为 santa_monica 条件下，最旧的那个 water_level 字段的取值和时间。</p>
<h4 id="LAST-函数"><a href="#LAST-函数" class="headerlink" title="LAST() 函数"></a>LAST() 函数</h4><p>作用：返回一个字段中最新的取值。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT LAST(water_level),location FROM h2o_feet WHERE time &gt;= '2015-08-18T00:42:00Z' and time &lt;= '2015-08-18T00:54:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           last      location</span><br><span class="line">2015-08-18T00:54:00Z     6.982     coyote_creek</span><br></pre></td></tr></table></figure>
<h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX() 函数"></a>MAX() 函数</h4><p>作用：返回一个字段中的最大值。该字段类型必须是长整型，float64，或布尔类型。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT MAX(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           max       location</span><br><span class="line">2015-08-29T07:24:00Z     9.964     coyote_creek</span><br></pre></td></tr></table></figure>
<h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN() 函数"></a>MIN() 函数</h4><p>作用：返回一个字段中的最小值。该字段类型必须是长整型，float64，或布尔类型。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT MIN(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                          min       location</span><br><span class="line">2015-08-29T14:30:00Z    -0.61     coyote_creek</span><br></pre></td></tr></table></figure>
<h4 id="PERCENTILE-函数"><a href="#PERCENTILE-函数" class="headerlink" title="PERCENTILE() 函数"></a>PERCENTILE() 函数</h4><p>作用：返回排序值排位为 N 的百分值。字段的类型必须是长整型或 float64。</p>
<p>百分值是介于 100 到 0 之间的整数或浮点数，包括 100。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT PERCENTILE(water_level,5),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                      percentile     location</span><br><span class="line">2015-08-28T12:06:00Z      1.122             santa_monica</span><br></pre></td></tr></table></figure>
<p>就是将 water_level 字段按照不同的 location 求百分比，然后取第五位数据。</p>
<h3 id="变换类函数"><a href="#变换类函数" class="headerlink" title="变换类函数"></a>变换类函数</h3><h4 id="DERIVATIVE-函数"><a href="#DERIVATIVE-函数" class="headerlink" title="DERIVATIVE() 函数"></a>DERIVATIVE() 函数</h4><p>作用：返回一个字段在一个 series 中的变化率。</p>
<p>InfluxDB 会计算按照时间进行排序的字段值之间的差异，并将这些结果转化为单位变化率。其中，单位可以指定，默认为 1s。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>其中，<code>unit</code>取值可以为以下几种：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">u <span class="comment">--microseconds</span></span><br><span class="line">s <span class="comment">--seconds</span></span><br><span class="line">m <span class="comment">--minutes</span></span><br><span class="line">h <span class="comment">--hours</span></span><br><span class="line">d <span class="comment">--days</span></span><br><span class="line">w <span class="comment">--weeks</span></span><br></pre></td></tr></table></figure>
<p>DERIVATIVE() 函数还可以在 GROUP BY time() 的条件下与聚合函数嵌套使用，格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>假设 location = santa_monica 条件下数据有以下几条：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           water_level</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br><span class="line">2015-08-18T00:06:00Z     2.116</span><br><span class="line">2015-08-18T00:12:00Z     2.028</span><br><span class="line">2015-08-18T00:18:00Z     2.126</span><br><span class="line">2015-08-18T00:24:00Z     2.041</span><br><span class="line">2015-08-18T00:30:00Z     2.051</span><br></pre></td></tr></table></figure>
<p>计算每一秒的变化率：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.00014444444444444457</span><br><span class="line">2015-08-18T00:12:00Z     -0.00024444444444444465</span><br><span class="line">2015-08-18T00:18:00Z     0.0002722222222222218</span><br><span class="line">2015-08-18T00:24:00Z     -0.000236111111111111</span><br><span class="line">2015-08-18T00:30:00Z     2.777777777777842e-05</span><br></pre></td></tr></table></figure>
<p>第一行数据的计算公式为<code>(2.116 - 2.064) / (360s / 1s)</code></p>
<p>计算每六分钟的变化率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,6m) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z     -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z     0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z     -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z     0.010000000000000231</span><br></pre></td></tr></table></figure>
<p>第一行数据的计算过程如下：<code>(2.116 - 2.064) / (6m / 6m)</code></p>
<p>计算每 12 分钟的变化率：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,12m) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.10400000000000009</span><br><span class="line">2015-08-18T00:12:00Z     -0.17600000000000016</span><br><span class="line">2015-08-18T00:18:00Z     0.19599999999999973</span><br><span class="line">2015-08-18T00:24:00Z     -0.16999999999999993</span><br><span class="line">2015-08-18T00:30:00Z     0.020000000000000462</span><br></pre></td></tr></table></figure>
<p>第一行数据计算过程为：<code>(2.116 - 2.064 / (6m / 12m)</code></p>
<p>计算每 12 分钟最大值的变化率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(MAX(water_level)) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-08-18T00:36:00Z' GROUP BY time(12m)</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:12:00Z     0.009999999999999787</span><br><span class="line">2015-08-18T00:24:00Z     -0.07499999999999973</span><br></pre></td></tr></table></figure>
<p>这个函数功能非常多，也非常复杂，更多对于此功能的详细解释请看官网：<a href="https://www.linuxdaxue.com/wp-content/themes/template/inc/go.php?url=https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="external nofollow noopener noreferrer">https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative</a></p>
<h4 id="DIFFERENCE-函数"><a href="#DIFFERENCE-函数" class="headerlink" title="DIFFERENCE() 函数"></a>DIFFERENCE() 函数</h4><p>作用：返回一个字段中连续的时间值之间的差异。字段类型必须是长整型或 float64。</p>
<p>最基本的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DIFFERENCE</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>与 GROUP BY time() 以及其他嵌套函数一起使用的语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DIFFERENCE</span>(&lt;<span class="keyword">function</span>&gt;(&lt;field_key&gt;)) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure>
<p>其中，函数可以包含以下几个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">COUNT(), MEAN(), MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), 和 PERCENTILE()</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<p>例子中使用的源数据如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location='santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure>
<p>计算<code>water_level</code>间的差异：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT DIFFERENCE(water_level) FROM h2o_feet WHERE location='santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            difference</span><br><span class="line">2015-08-18T00:06:00Z      0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z      -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z      0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z      -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z      0.010000000000000231</span><br><span class="line">2015-08-18T00:36:00Z      0.016000000000000014</span><br></pre></td></tr></table></figure>
<p>数据类型都为 float 类型。</p>
<h4 id="ELAPSED-函数"><a href="#ELAPSED-函数" class="headerlink" title="ELAPSED() 函数"></a>ELAPSED() 函数</h4><p>作用：返回一个字段在连续的时间间隔间的差异，间隔单位可选，默认为 1 纳秒。</p>
<p>单位可选项如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Units</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>ns</td>
<td>nanoseconds (1 billionth of a second)</td>
</tr>
<tr>
<td>u or µ</td>
<td>microseconds (1 millionth of a second)</td>
</tr>
<tr>
<td>ms</td>
<td>milliseconds (1 thousandth of a second)</td>
</tr>
<tr>
<td>s</td>
<td>second</td>
</tr>
<tr>
<td>m</td>
<td>minute</td>
</tr>
<tr>
<td>h</td>
<td>hour</td>
</tr>
<tr>
<td>d</td>
<td>day</td>
</tr>
<tr>
<td>w</td>
<td>week</td>
</tr>
</tbody>
</table>
</div>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ELAPSED(&lt;field_key&gt;, &lt;unit&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>计算 h2o_feet 字段在纳秒间隔下的差异。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      360000000000</span><br><span class="line">2015-08-18T00:12:00Z      360000000000</span><br><span class="line">2015-08-18T00:18:00Z      360000000000</span><br><span class="line">2015-08-18T00:24:00Z      360000000000</span><br></pre></td></tr></table></figure>
<p>在一分钟间隔下的差异率：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1m) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      6</span><br><span class="line">2015-08-18T00:12:00Z      6</span><br><span class="line">2015-08-18T00:18:00Z      6</span><br><span class="line">2015-08-18T00:24:00Z      6</span><br></pre></td></tr></table></figure>
<p>注意：如果设置的时间间隔比字段数据间的时间间隔更大时，则函数会返回 0，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1h) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      0</span><br><span class="line">2015-08-18T00:12:00Z      0</span><br><span class="line">2015-08-18T00:18:00Z      0</span><br><span class="line">2015-08-18T00:24:00Z      0</span><br></pre></td></tr></table></figure>
<h4 id="MOVING-AVERAGE-函数"><a href="#MOVING-AVERAGE-函数" class="headerlink" title="MOVING_AVERAGE() 函数"></a>MOVING_AVERAGE() 函数</h4><p>作用：返回一个连续字段值的移动平均值，字段类型必须是长整形或者 float64 类型。</p>
<p>语法：</p>
<p>基本语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOVING_AVERAGE(&lt;field_key&gt;,&lt;<span class="keyword">window</span>&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>与其他函数和 GROUP BY time() 语句一起使用时的语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOVING_AVERAGE(&lt;<span class="keyword">function</span>&gt;(&lt;field_key&gt;),&lt;<span class="keyword">window</span>&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure>
<p>此函数可以和以下函数一起使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">COUNT(), MEAN(),MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), and PERCENTILE().</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure>
<h4 id="NON-NEGATIVE-DERIVATIVE-函数"><a href="#NON-NEGATIVE-DERIVATIVE-函数" class="headerlink" title="NON_NEGATIVE_DERIVATIVE() 函数"></a>NON_NEGATIVE_DERIVATIVE() 函数</h4><p>作用：返回在一个 series 中的一个字段中值的变化的非负速率。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NON_NEGATIVE_DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>其中 unit 取值可以为以下几个：</p>
<p>Valid time specifications for <code>unit</code> are:</p>
<ul>
<li><code>u</code> microseconds</li>
<li><code>s</code> seconds</li>
<li><code>m</code> minutes</li>
<li><code>h</code> hours</li>
<li><code>d</code> days</li>
<li><code>w</code> weeks</li>
</ul>
<p>与聚合类函数放在一起使用时的语法如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NON_NEGATIVE_DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure>
<p>此函数示例请参阅：<a href="https://www.linuxdaxue.com/influxdb-study-influxdb-transformations-funcitons.html#title-0" target="_blank" rel="external nofollow noopener noreferrer">DERIVATIVE()</a>``函数</p>
<h4 id="STDDEV-函数"><a href="#STDDEV-函数" class="headerlink" title="STDDEV() 函数"></a>STDDEV() 函数</h4><p>作用：返回一个字段中的值的标准偏差。值的类型必须是长整型或 float64 类型。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STDDEV</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           stddev</span><br><span class="line">1970-01-01T00:00:00Z     2.279144584196145</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet WHERE time &gt;= '2015-08-18T00:00:00Z' and time &lt; '2015-09-18T12:06:00Z' GROUP BY time(1w), location</span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = coyote_creek</span><br><span class="line">time                           stddev</span><br><span class="line"><span class="comment">----                           ------</span></span><br><span class="line">2015-08-13T00:00:00Z     2.2437263080193985</span><br><span class="line">2015-08-20T00:00:00Z     2.121276150144719</span><br><span class="line">2015-08-27T00:00:00Z     3.0416122170786215</span><br><span class="line">2015-09-03T00:00:00Z     2.5348065025435207</span><br><span class="line">2015-09-10T00:00:00Z     2.584003954882673</span><br><span class="line">2015-09-17T00:00:00Z     2.2587514836274414</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = santa_monica</span><br><span class="line">time                           stddev</span><br><span class="line"><span class="comment">----                           ------</span></span><br><span class="line">2015-08-13T00:00:00Z     1.11156344587553</span><br><span class="line">2015-08-20T00:00:00Z     1.0909849279082366</span><br><span class="line">2015-08-27T00:00:00Z     1.9870116180096962</span><br><span class="line">2015-09-03T00:00:00Z     1.3516778450902067</span><br><span class="line">2015-09-10T00:00:00Z     1.4960573811500588</span><br><span class="line">2015-09-17T00:00:00Z     1.075701669442093</span><br></pre></td></tr></table></figure>
<h2 id="连续查询"><a href="#连续查询" class="headerlink" title="连续查询"></a>连续查询</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>InfluxDB 的连续查询是在数据库中自动定时启动的一组语句，语句中必须包含 <code>SELECT</code>关键词和<code>GROUP BY time()</code>关键词。</p>
<p>InfluxDB 会将查询结果放在指定的数据表中。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>使用连续查询是最优的降低采样率的方式，连续查询和存储策略搭配使用将会大大降低 InfluxDB 的系统占用量。</p>
<p>而且使用连续查询后，数据会存放到指定的数据表中，这样就为以后统计不同精度的数据提供了方便。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>只有管理员用户可以操作连续查询。</p>
<p>1）新建连续查询</p>
<p>新建连续查询的语法如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt; </span><br><span class="line">[RESAMPLE [EVERY &lt;<span class="built_in">interval</span>&gt;] [<span class="keyword">FOR</span> &lt;<span class="built_in">interval</span>&gt;]] </span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)] <span class="keyword">INTO</span> &lt;different_measurement&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;current_measurement&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;<span class="built_in">interval</span>&gt;)[,&lt;<span class="keyword">stuff</span>&gt;] </span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>查询部分被 CREATE CONTINUOUS QUERY […] BEGIN 和 END 所包含，主要的逻辑代码也是在这一部分。</p>
<p>使用示例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">CREATE</span> CONTINUOUS QUERY cq_30m <span class="keyword">ON</span> telegraf <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> mean(used) <span class="keyword">INTO</span> mem_used_30m <span class="keyword">FROM</span> mem <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br><span class="line">&gt; <span class="keyword">SHOW</span> CONTINUOUS QUERIES</span><br><span class="line"><span class="type">name</span>: telegraf</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="type">name</span>    query</span><br><span class="line">cq_30m    <span class="keyword">CREATE</span> CONTINUOUS QUERY cq_30m <span class="keyword">ON</span> telegraf <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> mean(used) <span class="keyword">INTO</span> telegraf."default".mem_used_30m <span class="keyword">FROM</span> telegraf."default".mem </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">name</span>: _internal</span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"><span class="type">name</span>    query</span><br></pre></td></tr></table></figure>
<p>示例在 telegraf 库中新建了一个名为 cq_30m 的连续查询，每三十分钟取一个 used 字段的平均值，加入 mem_used_30m 表中。使用的数据保留策略都是 default。</p>
<p>2）显示所有已存在的连续查询</p>
<p>查询所有连续查询可以使用如下语句：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">&gt; SHOW CONTINUOUS QUERIES</span><br><span class="line">name: telegraf</span><br><span class="line">--------------</span><br><span class="line">name    query</span><br><span class="line">cq<span class="emphasis">_30m    CREATE CONTINUOUS QUERY cq_</span>30m ON telegraf </span><br><span class="line">BEGIN SELECT mean(used) INTO telegraf."default".mem<span class="emphasis">_used_</span>30m FROM telegraf."default".mem </span><br><span class="line">GROUP BY time(30m) END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name: <span class="emphasis">_internal</span></span><br><span class="line"><span class="emphasis">---------------</span></span><br><span class="line"><span class="emphasis">name    query</span></span><br></pre></td></tr></table></figure>
<p>可以看到其连续查询的名称以及 语句等信息。</p>
<p>3）删除 Continuous Queries</p>
<p>删除连续查询的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>在 InfluxDB 中，将连续查询与数据存储策略一起使用会达到最好的效果。</p>
<p>比如，将精度高的表的存储策略定为一个周，然后将精度底的表存储策略定的时间久一点，这要就可以实现高低搭配，以满足不同的工作需要。</p>
<h2 id="再谈连续查询"><a href="#再谈连续查询" class="headerlink" title="再谈连续查询"></a>再谈连续查询</h2><h3 id="连续查询语法"><a href="#连续查询语法" class="headerlink" title="连续查询语法"></a>连续查询语法</h3><p>连续查询的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt; [RESAMPLE [EVERY &lt;<span class="built_in">interval</span>&gt;] [<span class="keyword">FOR</span> &lt;<span class="built_in">interval</span>&gt;]] <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)] <span class="keyword">INTO</span> &lt;different_measurement&gt; <span class="keyword">FROM</span> &lt;current_measurement&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;<span class="built_in">interval</span>&gt;)[,&lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h3 id="指定连续查询的时间范围"><a href="#指定连续查询的时间范围" class="headerlink" title="指定连续查询的时间范围"></a>指定连续查询的时间范围</h3><p>可以使用 <code>RESAMPLE FOR</code> 关键词来指定连续查询的时间范围，比如，每次执行都对 1 小时内的数据进行连续查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires_1 <span class="keyword">ON</span> transylvania RESAMPLE <span class="keyword">FOR</span> <span class="number">60</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations_1 <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>这个语句每次会将 1 小时的数据执行连续查询，也就是说，每次执行时，会将 now() 到 now()-30m 和 now()-30m 到 now()-60m 分别做连续查询，这样我们就可以手动指定连续查询的时间范围了。</p>
<h3 id="指定连续查询的执行频次"><a href="#指定连续查询的执行频次" class="headerlink" title="指定连续查询的执行频次"></a>指定连续查询的执行频次</h3><p>可以使用 <code>RESAMPLE EVERY</code> 关键词来指定连续查询的执行频次，比如，指定连续查询的执行频次为每 15m 执行一次：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires <span class="keyword">ON</span> transylvania RESAMPLE EVERY <span class="number">15</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>这样，连续查询会每隔 15m 执行一次。</p>
<h3 id="同时指定连续查询的范围和频次"><a href="#同时指定连续查询的范围和频次" class="headerlink" title="同时指定连续查询的范围和频次"></a>同时指定连续查询的范围和频次</h3><p>将 RESAMPLE FOR 和 EVERY 关键词同时使用，可以同时指定连续查询的范围和频次，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires_2 <span class="keyword">ON</span> transylvania RESAMPLE EVERY <span class="number">15</span>m <span class="keyword">FOR</span> <span class="number">60</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations_2 <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>这个语句指定连续查询每 15m 执行一次，每次执行的范围为 60m。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>基础教程文档：<a href="https://www.linuxdaxue.com/series/influxdb-series/" target="_blank" rel="external nofollow noopener noreferrer">InfluxDB 系列教程 | Linux 大学</a></li>
<li><a href="https://blog.51cto.com/nginxs/2321857" target="_blank" rel="external nofollow noopener noreferrer">00-InfluxDB 入门介绍-我的运维历程-51CTO 博客</a></li>
<li><a href="http://www.361way.com/influxdb-user/5291.html" target="_blank" rel="external nofollow noopener noreferrer">influxdb 的简单使用 - 运维之路</a></li>
<li><a href="https://segmentfault.com/a/1190000012385313" target="_blank" rel="external nofollow noopener noreferrer">influxdb 语法 - 个人文章 - SegmentFault 思否</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>influxdb</tag>
      </tags>
  </entry>
  <entry>
    <title>26：一个人的北京</title>
    <url>/posts/2561fdfd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>像是配上了加速马达，生活的时针走的越来越快。就感觉我还是两个月前写下的 <a href="../fa1a82ad/">25岁生日快乐</a>，今天我又开始这一年一度的仪式。</p>

    <div id="aplayer-aeiUjTVH" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="26427662" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<h2 id="密度曲线"><a href="#密度曲线" class="headerlink" title="密度曲线"></a>密度曲线</h2><p>不知道是因为2020年这个特殊的年份，还是因为我的年龄越来越大，会觉得我的25岁走的特别的快。如果以在博客上发布个人动态的频率作为我生活密度的衡量指标的话（这里的生活动态不包括各种专业内容的笔记），将会得到下面这样的一个时间曲线：</p>
<p><img alt="25岁的生活密度曲线" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_life-density.png"></p>
<p>是的，在去年的这个时候，我刚刚秋招结束，整体上还算顺利，也拿到了一些还可以的Offer。之后就开始了浪浪浪的生活节奏，也正是在那个时候，我重新把这个站捡起来，开始想要在这个站点上记录自己的生活。那是一段异常放松自由的时光，刚经历了秋招的繁忙生活，就像一个紧绷的弹簧一下子放松了下来。我和很好的朋友们一起去了云南，一起恢复了在学校的健身，时不时出去喝酒闲聊，时不时出去采风摄影。到年底的时候，我还规划了下一年的旅行，制定了下一年的目标。</p>
<p>然而，就在寒假回到武汉家中的第二天，一场突如其来的新冠疫情就整个地改变了2020年。那段时间的我失去了自己的生活节奏，每天的时间除了关注疫情动态，就是进入了一个在家好吃懒做的状态，完全不务正业，看各种经济金融相关杂七杂八的内容。等疫情稍微好转些，就自己出去拍照，记录下生活的时光。</p>
<p>后来，我去了杭州，更加专心的做毕设。忙完毕设之后，没太停歇就回到了北京，第一次租房，然后正式入职。在那之后，我原来许诺的每周更新的「朝花夕拾」开始不定期发布。工作的生活日渐繁忙，博客上开始发布了大量的涉及到工作相关的学习笔记，生活动态的比重越来越少。</p>
<p>但是曾经的Flag就在那里，不声不响的扇着我的耳光。周更没能坚持，年更怎可断绝，尽管当我在写这篇博客的时候距离生日已经过去4天，在这个公司午休的时间，我用曲线画下了过去的一岁，用文字记录过去的生活。</p>
<h2 id="朝花夕拾"><a href="#朝花夕拾" class="headerlink" title="朝花夕拾"></a>朝花夕拾</h2><p>翻了一下，上一期<a href="../47d0d3b/">「朝花夕拾」</a>还是在两个月多个月前，那个周末我难得出门转了一圈，从日常单调的上班生活暂时脱离，感受到了人间生活。如果不出门的话，我会在家里自己做饭，为了给提高自己的厨艺，还特地在手机上创建了一个「下厨房」的目录，到现在也算在厨艺上有一些的积累：</p>
<p><img alt="我的下厨房相册" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_cooking.jpg"></p>
<p>不过说起来，我的这套厨艺本质上还是继承自老妈的手法，秉承着「什么都可以炒」的理念，找些荤素搭配起来就可以完成一道炒菜。本心而论，也就是这套方法论摸的很熟，但是 <em>烹炒煎炸煮</em> 等其他手法我目前基本毫无涉猎，也许在以后的生活里可以继续摸索。尽管厨艺粗糙，我自己却还是吃的挺开心的，每次都吃的特别的饱。</p>
<p><img alt="每一顿自己都吃的很饱" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_cooking-beef.jpg"></p>
<p>毕竟是一人食，每次对于分量的把控都很艰难。好不容易做好了一顿饭，吃完之后还要自己刷锅刷碗，如果只做一点总觉得不甘心，而一旦做多了就会让自己吃的非常饱。每次这个时候，都会觉得如果有个女朋友一起该多好，那个时候就可以多做一点大家一起分享。</p>
<p>除了下厨，在家的另一项活动就是拍窗外的夕阳🌇。因为住的楼层比较高，可以直接看到远处的西山，真的好看。</p>
<p><img alt="最开始用Sony的套头拍，细节还是不够" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-05_sunset.png"></p>
<p><img alt="套头拍摄的蓝调时刻，直接让我决定升级镜头" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-18_sunset.png"></p>
<p><img alt="入手了腾龙70-180，感觉画质细腻了好多" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-02_sunset.png"></p>
<p>除了周末拍夕阳，也会在每天拍楼下的海淀黄庄，我在豆瓣相册上给自己创建了一个相册<a href="https://www.douban.com/photos/album/1877579563/" target="_blank" rel="external nofollow noopener noreferrer">「知春里知春里」</a> 。因为第一次租房并不能算的很满意，所以计划在一年后换一个地方。尽管房间不算很满意，十六楼的风景让我很开心，就在人大附对面，宇宙教育中心海淀黄庄。随着四季更替，看楼下车辆来来往往，看人大附高中生们进进出出，看路边银杏黄了又落，也算是一段不错的体验吧。因为国庆外出，暂定了三周的拍摄，叶儿黄了，继续开始吧！</p>
<p><img alt="知春里拍摄" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_gallery.png"></p>
<p>毕业之后，本来预计的活动安排里，除了四处拍照外，应该还有的活动回学校打羽毛球。然而，因为北京的疫情，学校迟迟不开放，自己也还没有找到球友，所以这项活动暂时停歇。羽毛球停了，卡林巴琴练习也停了，摄影在生活中占据的时间越来越多。</p>
<p><img alt="我记得香八拉路上的山景，记得鬼笑石上看到的北京城" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-19_mountain.png"></p>
<p><img alt="我记得早上5点爬起来，只为在木樨地拍到秋分时的长安街悬日，可惜今年起晚了，只能明年春分再战了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-26_sunrise.png"></p>
<p><img alt="我记得中秋和国庆节那天晚上长安街的车流与执勤工作人员" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-01_forbidden-city.png"></p>
<p><img alt="我记得那天明朗的月" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-01_moon.png"></p>
<p><img alt="我记得那天城内车流的显著减少，拍下的光晕里好多酸柠檬" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-01_color.png"></p>
<p>我还记得Ansel Adam的那句话：</p>
<blockquote>
<p>我们不只是用相机拍照，我们带到摄影中去的是所有我们读过的书、看过的电影、听过的音乐、走过的路、爱过的人。</p>
</blockquote>
<p>我用相机记录生活，用生活记录自己，愿自己能够永远不给自己设限，愿自己永远敢于探索，愿自己永远在路上，愿自己找到爱的人。</p>
<h2 id="行万里路"><a href="#行万里路" class="headerlink" title="行万里路"></a>行万里路</h2><p>年初的我给自己规划了两场旅行，到最后都未能如愿。令人开心的是，随着国内疫情防控稳定下来，政府也大幅放开了国内旅行限制。于是在这个难得的双节里，我和姐姐还有表弟他们一起自驾走了趟青甘大环线，这里有表弟编辑的Vlog（我的视频还没剪出来，或许会有吧，啥时候我来把这段经历补充道「行万里路」的专栏里：）</p>
<iframe src="//player.bilibili.com/player.html?aid=669952705&bvid=BV1ta4y1L73r&cid=246085415&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>虽然没有视频，但是一路上的风景真的美不胜收，走过山川与沙漠，走过草原与戈壁，最美的风景永远在路上。</p>
<p><img alt="在青海湖的那个晚上，跑出来第一次拍星空，虽然冻得发抖，但是美丽的银河值了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_sky.png"></p>
<p><img alt="除了星星外，还拍到了气晕" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_halo.png"></p>
<p><img alt="除青海湖真的是海" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-10_seagull.png"></p>
<p><img alt="在门源没有看到油菜花，在青海湖旁边突然看到近处满眼的黄，配合远处海一般的蓝 ，真的美极了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-10_rape-flower.png"></p>
<p><img alt="同一段路上，草已泛黄，油菜花正艳" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_yellow-grass.png"></p>
<p><img alt="穿过高山与草原，我们在路上" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_on-the-way.png"></p>
<p><img alt="本来想再鸣沙山拍日落，可惜等我爬上去的时候太阳已经下山，后来才知道鸣沙山的票可以玩三天，其实可以第二天去拍日出的" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_sand.png"></p>
<p><img alt="路上的飞烟与戈壁" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_cold-flame.png"></p>
<p><img alt="不过令人开心的是，我在茶卡盐湖拍到了日落，真的美，还拍了延时，虽然还没剪出来：）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_sunset.png"></p>
<p><img alt="当然如果你想要看天空之境的话，相比茶卡盐湖，我还是推荐翡翠湖，我也拍了日出延时（还没剪出来），（目前）不收门票而且比茶卡盐湖更美）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_green-lake.png"></p>
<p><img alt="在穿越祁连山山脉的时候，我们看到山上还有在收割辛劳的人们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-03_moutain-farmers.png"></p>
<p><img alt="山与草原，分外的层次感" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-03_mountain.png"></p>
<p><img alt="最令人惊喜的，莫过于在赶往大柴旦镇路上偶遇的小柴旦湖，它有另一个名字，叫做神秘之湖" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-07_lake.png"></p>
<p><img alt="我们看见湖的时候正好是日落的时候，阳光直接打在湖对面的山上，蓝色的湖水，黄色的草，整个车上的人都震惊了，不能下车，我只能在车上抓拍了几张" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-07_lake2.png"></p>
<p><img alt="除了这些自然景观外，还去了塔尔寺、莫高窟、榆林窟等文化景观，自是另一种体验" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_temple.png"></p>
<p>写到这里，感觉「行万里路」专栏也不用写了，到时候把两个延时视频补起来叭！</p>
<h2 id="生日快乐"><a href="#生日快乐" class="headerlink" title="生日快乐"></a>生日快乐</h2><p>上一次生日，是和实验室的几个很好的朋友一起过的，这一次也是。本来，PT已经远走广州，平时想要再见一面已经不易。终于，一直说的回北京喝酒的愿望得以在这个周末实现，真的开心。</p>
<p>在晚上和PT见面之前，我和PT先回学校走了一圈。当然，学校现在是不让进的，但是翻墙可以：）本来两个人也没有很确定，毕竟翻墙可不算什么光彩事，但是两个人互相鼓动，居然一气呵成翻进了学校。总的来说，翻墙的技术难度并不大，重要的是突破心理障碍。最后我们一致总结到，这次翻墙很值，很刺激。</p>
<p>进学校之后，感觉到了属于学校满满的活力，听说Y老师在球场和师弟们打球，赶紧过去蹭了两个小时的场。好久没打了，真的开心：）<br><img alt="邱德拔打球的老师和师弟们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_badminton.png"></p>
<p><img alt="继续在学校闲逛，看到了疫情期间专供的快餐车" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-17_back-school.png"></p>
<p>到了晚上，一行四人去了聚点，喝酒叙旧，很自在，上次这样四个人还是去年秋招完后。可惜在聚点忘了拍张合照，四个人一起走在中关村的大街上，继续拍照，直接跨过了凌晨。可惜这次时间太短，如果还能更久一点该多好。</p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street1.png"></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street2.jpg"></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street.jpg"></p>
<p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street3.jpg"></p>
<h2 id="一个人"><a href="#一个人" class="headerlink" title="一个人"></a>一个人</h2><p>二十六啦，我毕业了，一个人在北京。</p>
<p>来北京已经七年啦，未来还会在这个城市呆三年，希望不再是一个人。</p>
<p>生日快乐！</p>
]]></content>
      <categories>
        <category>生日快乐</category>
      </categories>
      <tags>
        <tag>birthday</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>生活不止五险一金</title>
    <url>/posts/c39a52c0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>又逢周末，上期的 <a href>「生日快乐」</a> 告诉自己要恢复「朝花夕拾」的更新，隔了一周，从今天开始。本期「朝花夕拾」的题目来自于前两天听「贤者时间」的一期播客，本文内容与播客内容基本无关，仅仅作为飘飞思绪的引子。恰逢立冬，白昼渐短，宵寒渐长，开始切身的感受到了节气的变化。凛冬将至，蛰伏开始。</p>
<blockquote>
<p>秋风吹尽旧庭柯，黄叶丹枫客里过。 </p>
<p>一点禅灯半轮月，今宵寒较昨宵多。</p>
</blockquote>

    <div id="aplayer-TfciqtwD" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1331892086" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<a id="more"></a>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="秋天"><a href="#秋天" class="headerlink" title="秋天"></a>秋天</h3><p>上个星期又回了一次学校，和实验室的老师同学们打了一下午羽毛球，一起吃了顿饭。午饭间隙简单到未名湖转了一圈，补上了未名湖美丽的秋景。</p>
<p><img alt="同样的角度，今年年初冬天和夏天都拍过一次，这次补上了秋天的美丽" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-31_lake.png"></p>
<p><img alt="年初的时候，还记得这里有同学在打冰球" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-31_lake_1.png"></p>
<h3 id="立冬"><a href="#立冬" class="headerlink" title="立冬"></a>立冬</h3><p>豆瓣上 <a href="https://www.douban.com/people/zhoujie221/" target="_blank" rel="external nofollow noopener noreferrer">青简</a> 有一个 <a href="https://www.douban.com/photos/album/61629667/" target="_blank" rel="external nofollow noopener noreferrer">二十四节气</a>，记录了一年二十四节气中的各个美丽瞬间，正是这个相册让我有了拍出自己的一套二十四节气的想法。在以前，我基本上每年冬天都会走一趟颐和园，或者自己一个人，或者和ZY、和PT他们走过。今天立冬，在节气上冬天的开始，适逢 Feng 来北京，完成了今年的颐和园之行。想起来，自从初中毕业就很少见面，这次在北京两个人一起胡乱的聊起了身边的种种变化，忽的有一种中年人的感觉，此处略去不表。</p>
<p>尽管是立冬，北京的这个时候还是美丽的深秋，截取了这一天的美丽瞬间，算是我 「二十四节气」相册的开始：</p>
<p><img alt="下午时分，金色的阳光打在棕黄的芦苇身上，分外美丽" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-07_winter-bulrush.png"></p>
<p><img alt="这天的风很大，湖畔的柳带飘飞，对面的长堤已经染成了金色，远处的玉峰塔烟雾迷蒙" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-07_beginning-of-winter.png"></p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>关于数据记录的意义我曾经在 <a href="../3e030bdb/">Carpe Diem</a> 这期专门讨论过这个问题，当时列出来几个工具用于记录自己的生活。因为种种原因（或者是因为你懒，或者是因为你没有时间，或者是因为你把宝贵的时间耗在了别处），数据记录的很多部分已经不再启用。没有做到这一步，也是因为定期总结的缺失。随着工作后生活走入固定节奏，我在这里再次重启（希望没有下一次重启），分析数据并修正自己的行为模式。</p>
<p>Resue Time记录一周的时间消耗，可以看到在工作日，每天的ScreenTime大概是9到10个小时，基本约等于自己的工作时间，这很合理（每天在班时间早上9点到晚上9点，减去中间休息的3个小时，剩下来的时间基本上都在看屏幕）。具体到每天的时间，除了软件开发使用 iTerm2 和 Goland，另外的时间就是企业微信。</p>
<p><img alt="Rescue Time" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-08_rescue-time.png"></p>
<p>总的来说，感觉自己每天工作的时候还是不够专注。日常会被企业微信的各种消息打扰，最近一个月以来积累的技术笔记也渐渐减少，更多的时间在做业务相关的实现，这很不好。一方面可以提高自己工作写码调试的效率，另一方面可以集中时间处理一些琐碎的事情，这是一个可以持续改进的问题。为了改进自己的工作状态，继续用Forest使用番茄工作法记录专注时间。另外一个令人开心的结果是，我现在已经形成了用日历来记录每天时间的习惯，虽然固定的每日总结有时候会鸽掉，至少现在在往好的方向走。</p>
<p><img alt="Forest - Nov 1 ~ Nov 7, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-08_forest.png"></p>
<h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><p>「世界」是我在「朝花夕拾」中新开的栏目，用于关注我周围的世界正在发生的事情，想法来自于 <a href="https://github.com/ruanyf/weekly" target="_blank" rel="external nofollow noopener noreferrer">阮一峰的科技爱好者周刊</a>。与之前简单的通过刷微博来获取新闻信息源并吃瓜关注的效果不同，我希望这里会对过去一周发生的那些大事件进行深度阅读，理出自己的思绪，给出自己的分析与预测。此外，还会积极关注科技和商业领域那些新出现的有意思的东西，保持对新鲜事物的好奇心和敏感度。</p>
<h3 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h3><h4 id="美国大选"><a href="#美国大选" class="headerlink" title="美国大选"></a>美国大选</h4><ul>
<li>背景：大选前期民调显示拜登领先川普，然而在出票过程中经过了几轮反转，在最开始拜登领先的情况下，川普拿下了佛州，其他几个摇摆州的选票也逐渐开始反超，像极了2016年。然而随着邮寄选票的逐步计票，拜登开始抢回宾州、威斯康辛州等的选票，并最终获得超过270张选票。</li>
<li>现状：美国各大媒体已经宣布拜登胜选，欧洲英法德等国也积极向拜登表示祝贺。然而到现在(2020.11.09)川普仍然没有承认败选，反而鼓吹民主党选举舞弊，黑天鹅仍然存在。</li>
<li>分析：选举前的想法是，2020年全球疫情的背景下，川普在美国的疫情管理一塌糊涂（当然欧洲也是难兄难弟），种族矛盾爆发（BLM运动如火如荼），如此混乱的情况下，我们对于大选的预期大致是这么混乱满嘴胡话的川普应该是不太可能连任吧。然而，虽然最终却是是拜登胜选，但是选情能够胶着到这种情况着实是没有预料到的。这证明了川普在美国民众是有一大票民众真心支持他的，即使在这种情况下他们也仍然会选择川普。他们是些什么人？在全球化背景下，美国实体产业流失，原有的大批工人失业，从中产阶级坠落，生活状况急剧降低，与之相反，跨国公司的资本家在全球化的浪潮中获得了巨大收益。巨大的反差是特朗普各种操作下仍能够获得众多支持的重要原因，而且这种支持是长久的支持。</li>
<li>不论最后拜登是否能够顺利就任，美国社会的撕裂是仍将继续存在的。对于中国，应该做的仍然是做好自己的事情。拜登就任，也许将不再采用川普这种粗暴的贸易战做法，而是像之前一直以来的做法一样（典型的例子是操作系统、芯片等构建自己的生态，凭借高额的利润，以恰到好处的产品价格让你没有动力去研发自己系统下的市场产品），这才是最难受的，这也是我们大部分企业会放弃研发无法进阶高端产业的原因。</li>
<li>未来四年（2020-2024），全球化仍将继续，我们的实力会继续增长。前面还有很多困难，我们内部也还有很多问题，我们要继续努力，稳扎稳打，未来终将属于中国。</li>
</ul>
<h4 id="蚂蚁风波"><a href="#蚂蚁风波" class="headerlink" title="蚂蚁风波"></a>蚂蚁风波</h4><ul>
<li>背景<ul>
<li>10月24日，马云在上海外滩金融峰会抨击中国金融没有系统，监管太严、巴塞尔协议是老年俱乐部引发争议</li>
<li>11月2日，中国人民银行、中国银保监会、中国证监会、国家外汇管理局对蚂蚁集团实际控制人马云、董事长井贤栋、总裁胡晓明进行了监管约谈</li>
<li>11月2日，中国银保监会和中国人民银行对关于《网络小额贷款业务管理暂行办法（征求意见稿）》公开征求意见</li>
<li>11月3日，上海证券交易所致函蚂蚁科技集团股份有限公司《关于暂缓蚂蚁科技集团股份有限公司科创板上市的决定》</li>
<li>11月5日，蚂蚁集团原定于上海和香港同步挂牌上市，暂缓上市</li>
<li>11月6日，蚂蚁集团启动退款程序，投资人认购股份将注销</li>
</ul>
</li>
<li>分析<ul>
<li>什么是巴塞尔协议？巴塞尔协议是银行业为了维持资本市场稳定、降低银行系统信用风险和市场风险提出的资本充足率的要求。</li>
<li>我国银行给出的标准是10%左右，也就是说银行顶多只能有10倍杠杆，银行有1块钱，顶多只能借出去10块。</li>
<li>蚂蚁金服在重庆的两家小额贷款公司花呗和借呗，注册资金30亿，以1：2杠杆从银行借来60亿，凑足90亿资本金。</li>
<li>之后利用这90资本金开始放贷，获得大批的贷款合同，然后将这些贷款合同打包成资产卖给别人收回本金。这里的打包成资产，金融里称作ABS(Assets Backed Securities，资产抵押债券)。对没错，这就是在2008年次贷危机中发生巨大作用的金融产品。收回本金后，蚂蚁继续放贷，反复循环四十多次，形成3000亿多的贷款规模。本金只有30亿，杠杆率超过100。</li>
<li>按照蚂蚁集团的上市财报，其放贷规模目前已经达到了1.8万亿，但本金仅360亿，本金率约2%。换句话说，杠杆率高达50倍。自己只有1块钱，蚂蚁集团可以借出去50块钱，其他的49块钱银行出。这49块钱，银行收取5~6%的融资利息，但花呗和借呗放出去的利率，高达14~18%，中间的息差达到8~9%，全部归蚂蚁集团所有。要注意，你的利润是49块钱的8~9%，但你的本金只有1块钱。</li>
<li>11月2日中国银保监会和中国人民银行提出的网络小贷监管意见主要包括：<ul>
<li>放出去的贷款中，小贷公司自己的出资比例不得低于30%。</li>
<li>小贷公司通过银行借款、股东借款等非标融资形式，融入资金不得超过其净资产的1倍。</li>
<li>通过发行债券，资产证券化（ABS）等形式融资的金额，不得超过净资产的4倍。</li>
</ul>
</li>
<li>对比蚂蚁集团的上市招股书，可以看到网络小贷监管对于蚂蚁集团义务影响巨大。按照监管要求，蚂蚁的杠杆率将由50压缩到16倍以内，这对其市盈率将是巨大的打击。这也是为什么蚂蚁一直号称自己是科技公司，而不是金融公司。金融公司由于监管政策的限制，银行业的市盈率一般在10左右。蚂蚁原定上市计划中市值2万亿，大约3000亿美金，动态市盈率是47倍，显然大幅超过了一般的金融公司。</li>
<li>自己的观点，支持银行监管，毕竟有次贷危机的前车之鉴。但是蚂蚁作为新型公司，在大数据和互联网科技上肯定是有积淀的，肯定也可以在监管下发挥自己的作用，毕竟他们做的还是金融。这玩意儿不能松，不然出问题就是大问题。</li>
</ul>
</li>
</ul>
<h3 id="新东西"><a href="#新东西" class="headerlink" title="新东西"></a>新东西</h3><p>本期「朝花夕拾」对新东西、新概念的积累较浅，这次仅仅提一提最近在各个地方看到的DeFi（DecentralizedFinance），DeFi是区块链领域最近很火的一个概念，具体相关的内容以后要写一期来专门扫盲。</p>
<p>之前一直说要保持对于新科技、新创造的追踪，要做到这个，首先需要有一个各个行业的Overview扫盲贴，后续才能够持续的追踪。其实按照二八原则成本并不算太大，需要自己一点一点的积累。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>本期的主题是「生活不止五险一金」，最开始写这个题目是想借这个机会好好了解下五险一金与我具体相关的事情。是的，这些规则细碎而繁琐，但是你作为活在当前中国社会不得不接触的东西，从这里你可以了解到影响上亿人生活的规则。这些东西，确定了中国社会的最最基本的形态。</p>
<h2 id="附录：五险一金"><a href="#附录：五险一金" class="headerlink" title="附录：五险一金"></a>附录：五险一金</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>五险一金，就是指<strong>“养老保险、医疗保险、生育保险、工伤保险、失业保险和住房公积金”</strong></p>
<h4 id="覆盖人群"><a href="#覆盖人群" class="headerlink" title="覆盖人群"></a>覆盖人群</h4><ul>
<li>五险一金是有工作的人交的，因此上班族、自由职业者都可以参与。自由职业者可以自己选择缴费基数，但公司纳的一部分也要承担。</li>
<li>没有工作的人，比如家庭主妇，儿童及学生只能参加养老保险和医疗保险。<ul>
<li>其中，没有进城务工的农民参加的是<strong>新农保</strong>（新型农村养老保险）、<strong>城乡医保</strong>（城乡居民医疗保险）。</li>
<li>其他城镇居民则参加<strong>城居保</strong>（城镇居民养老保险）、<strong>城乡医保，</strong>大学生参加就读当地的城乡医保。</li>
</ul>
</li>
</ul>
<h4 id="缴费规则"><a href="#缴费规则" class="headerlink" title="缴费规则"></a>缴费规则</h4><p>五险一金分为公司缴费和个人缴费，公司缴费进入统筹账户，个人缴费进入个人账户（社保卡/医保卡）。</p>
<p>五险一金交多少取决于两个因素：<strong>缴费基数和缴费比率</strong></p>
<p><strong>缴费基数</strong>是你<strong>上个年度月均工资</strong>，但不能超过当地平均工资的<strong>三倍</strong>，也不会低于当地平均工资的<strong>60%</strong>。</p>
<p><strong>缴费比率</strong>全国各统筹地规定不同，但一般如下：</p>
<p><img alt="五险一金缴费比例" data-src="https://pic1.zhimg.com/80/v2-9774cb8f17777a3702d4827a13669a00_720w.jpg"></p>
<p>五险一金费用交下来，<strong>个人缴费</strong>占到你工资的<strong>11%</strong>左右，<strong>公司缴费</strong>占到你工资的<strong>25%</strong>左右。</p>
<h4 id="好处概述"><a href="#好处概述" class="headerlink" title="好处概述"></a>好处概述</h4><p><strong>总的来说：五险一金让我们能在大城市安家落户</strong></p>
<p><strong>分开来说：五险一金能在我们养老和生病，生孩子买房子这些事情上带给我们保障。</strong></p>
<h3 id="分述"><a href="#分述" class="headerlink" title="分述"></a>分述</h3><h4 id="医疗保险"><a href="#医疗保险" class="headerlink" title="医疗保险"></a>医疗保险</h4><h5 id="报销规则"><a href="#报销规则" class="headerlink" title="报销规则"></a>报销规则</h5><p>医保报销限定在“<strong>两定点，三目录</strong>”内——<strong>定点医院</strong>、<strong>定点药费</strong>和国家规定的医保可以报销的<strong>药品目录、诊疗项目目录、服务设施目录。</strong></p>
<p>在“两定点、三目录”内，还设置了<strong>起付线和封顶线</strong>，在两线之间，不同等级的医院，不同的人群，报销比率不一样：</p>
<p>医保报销分为门急诊报销和住院报销，</p>
<p><img alt="img" data-src="https://pic2.zhimg.com/80/v2-a4540ce83307f8482722dd9cee78d189_720w.jpg"></p>
<p>门急诊报销少，住院报销多；医院等级越低报销越多，反之报销越少；在职人员报销少，退休人员报销多。</p>
<p>至于具体的报销比率，各统筹地有自己的规定，</p>
<p>拿上海举例：</p>
<p>上海在职人员走医保门急诊，刷完医保卡当年计入账户部分后，自掏1500元便可开始报销，几万块的门诊费用医保能报销50%-65%。</p>
<p><img alt="img" data-src="https://pic4.zhimg.com/80/v2-cb9646eb2f3219736b98746343cd0b77_720w.jpg">（上海在职人员门急诊医保报销）</p>
<p>如果是住院报销，先用医保卡刷掉1500元以后，在53万元以下的住院费用都可以报销85%，超过53万元的附加基金再报销80%。</p>
<p><img alt="img" data-src="https://pic4.zhimg.com/80/v2-299c5c19d8528b004b44350e69ffc7bf_720w.jpg"></p>
<p><strong>我举个门急诊报销的例子：</strong></p>
<p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-a75aeefd82d4a41b29dce0e8c9313b24_720w.jpg"></p>
<p><strong>5万块的支付顺序是：</strong></p>
<p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-d77fad0b4a3c2ad66aabf62aaa24a660_720w.jpg"></p>
<p><strong>于是这次生病，</strong></p>
<p><strong>5万元的支付结构为：</strong></p>
<p><img alt="img" data-src="https://pic2.zhimg.com/80/v2-9188ee739dad6985ff39bd1dd830ca49_720w.jpg"></p>
<p>生病花了5万，自己只掏了13250元，算下来医保报销了73.5%！</p>
<p>为患者减轻了很大的负担。</p>
<p>但现实中一些人的医保卡额度积攒得并不多，再加上报销上限只有两万块，</p>
<p>一旦遭遇大点的疾病或手术，一下子花个十几二十万，</p>
<p>还有很多能极大提高治愈率的技术不在报销范围内，比如癌症的质子重离子技术。</p>
<p>医保的作用就只能算是铺底了，真正能扛住大病风险的还是百万医疗险和重疾险。</p>
<h5 id="享受标准"><a href="#享受标准" class="headerlink" title="享受标准"></a>享受标准</h5><p>一般来说，医保今天交，<strong>次月</strong>就可以用<strong>统筹账户</strong>报销，<strong>半年</strong>或<strong>一年后</strong>可以用<strong>个人账户</strong>刷卡报销。</p>
<p>在退休前<strong>男性交满25-30年</strong>，<strong>女性退休前交满20-25年</strong>，退休后可以免费享受。</p>
<p>如果退休时缴费年限不够，可以一次性补缴剩余费用，然后才可以免费享受。</p>
<p>此外，也有不能享受的标准，主要为以下四方面：</p>
<ul>
<li><strong>应该由工伤保险基金支付的，比如尘肺病；</strong></li>
<li><strong>境外就医的；</strong></li>
<li><strong>应该由第三人（单位和个人）负担的，比如车祸；</strong></li>
<li><strong>应该由公共卫生负担的，比如新冠肺炎。</strong></li>
</ul>
<h5 id="异地就医"><a href="#异地就医" class="headerlink" title="异地就医"></a>异地就医</h5><p>医保不是全国通，是各省各地统筹，各统筹地的政策不一样，如果跨统筹地就医，就涉及到异地就医医保如何报销的问题。</p>
<p>在进行异地医保报销前，可以到先到<strong><a href="https://link.zhihu.com/?target=http%3A//si.12333.gov.cn/120692.jhtml" rel="external nofollow noopener noreferrer" target="_blank">国家社会保险公共服务平台</a></strong>查询<strong>支持异地医保直接结算</strong>的医保定点医院，再去就诊。</p>
<p><img alt="img" data-src="https://pic4.zhimg.com/80/v2-00db9805efaa55c20380076736eeb9db_720w.jpg"></p>
<p>异地就医，分三种情况：</p>
<ul>
<li><strong>长期异地就诊</strong>——如在上海参保，但却在北京长期居住，居住期间生病就医；</li>
<li><strong>临时异地转院</strong>——如在上海参保，但上海治不了转到北京去医治；</li>
<li><strong>临时异地就诊</strong>——如在上海参保，但去北京旅游，出差，见亲人等生病就医。</li>
</ul>
<p><strong>三种情况处理方式不同</strong>，具体参见下图：</p>
<p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-1e14254c44d7d3d18b3ea92a8c98fec4_720w.jpg"></p>
<p><strong>异地医保报销需要特别注意的三点：</strong></p>
<ol>
<li><p>医保卡异地<strong>报销只限住院，门急诊部分城市才有。</strong></p>
</li>
<li><p>医保卡异地报销能<strong>报销的范围取决于就诊地医保政策</strong>，但能<strong>报销多少钱取决于你的参保地政策</strong>；</p>
</li>
<li><p>如果你办理了异地就医备案，回到原参保地之后，医保报销资格可能被取消，也可能还能用，也有可能取消备案之后才能用，这需要你咨询参保地医保局。</p>
</li>
</ol>
<p>所以，有什么问题一定不要忘记拨打<strong>12333</strong>的电话问清楚，因为各地的规定都不相同。</p>
<p>关于更详细的医保报销操作细节，也可以参考我这篇按照就医看病过程写的医保报销指南：</p>
<h4 id="养老保险"><a href="#养老保险" class="headerlink" title="养老保险"></a>养老保险</h4><p>养老保险简单理解就像我们每个月往银行存一笔钱一样，退休之后每个月往外取钱用。不同的地方是这钱存到了养老保险基金那里，由国家指派的专家组进行运作保值增值。</p>
<h5 id="养老金计算"><a href="#养老金计算" class="headerlink" title="养老金计算"></a>养老金计算</h5><p>养老金能拿到多少跟个人<strong>累计缴费年限、缴费工资、当地职工平均工资、个人账户金额、城镇人口平均预期寿命</strong>等因素有关，但一定是<strong>“长缴多得，多缴多得”。</strong></p>
<p><strong>公司交的钱进入基础账户，个人交的钱进入个人账户</strong>，退休后，两个账户都可以拿钱。</p>
<p>个人账户简单，就是每个月你存起来的钱，按照8%左右的年利增长（当年缴入按单利，历年累计按复利）。最后假设你60岁退休就将累积的这笔钱分成139个月发给你。</p>
<p>基础账户能拿到的钱由一个复杂的公式确定，计算比较复杂，，但可以肯定的是，你退休前的工资越高，当地工资越高，交的年限越久，你能从统筹账户拿到的退休工资就越多。</p>
<p>举个例子：王华，23岁，上海工作，2020年工资8600，从今年交社保交37年后60岁在上海退休，未来他的工资假设如下：</p>
<p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-ed6f8aba8f8ebc1f05c948c5affc3184_720w.jpg"></p>
<h5 id="领取资格"><a href="#领取资格" class="headerlink" title="领取资格"></a>领取资格</h5><p>领取养老金要满足三个条件：</p>
<ul>
<li><strong>至少缴满15年；</strong></li>
<li><strong>第二必须到退休年龄；</strong></li>
<li><strong>办理完退休证明。</strong></li>
</ul>
<p>退休时还没有交满15年的<strong>必须补满15年才能领，</strong></p>
<p>但按照上面的公式，如果我们只交15年养老金就不交的话，<strong>最后只能拿到社会平均工资的15%</strong>，这是非常少的。</p>
<p>如果是工伤导致退休，这笔钱由企业补满，自然退休则是自己补满。</p>
<p>退休年龄为国家规定的退休年龄，如下表：</p>
<p>其他关于养老金断缴，领取地以及是否能拿回来的问题，参见后面<strong>番外篇详述部分</strong>。</p>
<h4 id="生育保险"><a href="#生育保险" class="headerlink" title="生育保险"></a>生育保险</h4><h4 id="工伤保险"><a href="#工伤保险" class="headerlink" title="工伤保险"></a>工伤保险</h4><h4 id="失业保险"><a href="#失业保险" class="headerlink" title="失业保险"></a>失业保险</h4><h4 id="住房公积金"><a href="#住房公积金" class="headerlink" title="住房公积金"></a>住房公积金</h4><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="北漂一族养老金领取问题"><a href="#北漂一族养老金领取问题" class="headerlink" title="北漂一族养老金领取问题"></a>北漂一族养老金领取问题</h4><h4 id="离职后社保的处理"><a href="#离职后社保的处理" class="headerlink" title="离职后社保的处理"></a>离职后社保的处理</h4>]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>生活</tag>
        <tag>保险</tag>
        <tag>立冬</tag>
        <tag>五险一金</tag>
        <tag>二十四节气</tag>
      </tags>
  </entry>
  <entry>
    <title>图解 Git</title>
    <url>/posts/5bd9b965/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Git是目前世界上最先进的分布式版本控制系统，本文是对 git 的原理与用法的总结笔记。</p>
<a id="more"></a>
<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。通过版本控制系统，你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态；你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子，但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 <a href="https://www.gnu.org/software/rcs/" target="_blank" rel="external nofollow noopener noreferrer">RCS</a> 的工作原理是在硬盘上保存补丁集；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
<p><img alt="Local version control diagram" data-src="https://git-scm.com/book/en/v2/images/local.png"></p>
<h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、SVN 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p>
<p><img alt="Centralized version control diagram" data-src="https://git-scm.com/book/en/v2/images/centralized.png"></p>
<p>但这种模式有一个致命的缺点，就是中心的单点，如果服务器恰好坏了，那代码全部丢失，所以大公司一般都有很好的容灾机制。</p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>随着开源运动的爆发，中心仓库模式很难适应全球多人写作的模式，于是乎分布式版本控制诞生了</p>
<p>DVCS结合了LVCS和CVCS两者的优点，本地仓库让一切都在本地，同时分布式的设计又让每一个节点都能成为远端</p>
<p>DVCS的缺点也是不容忽视的，本地仓库会导致首次clone变慢，其学习曲线优点陡峭（相对而言）</p>
<p><img alt="Distributed version control diagram" data-src="https://git-scm.com/book/en/v2/images/distributed.png"></p>
<h2 id="Git-工作模型"><a href="#Git-工作模型" class="headerlink" title="Git 工作模型"></a>Git 工作模型</h2><p><img alt="Git 工作模型" data-src="https://segmentfault.com/img/bVKndm"></p>
<h3 id="Snapshots-Not-Differents"><a href="#Snapshots-Not-Differents" class="headerlink" title="Snapshots, Not Differents"></a>Snapshots, Not Differents</h3><p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容：</p>
<blockquote>
<p>Conceptually, most other systems <strong>store information as a list of file-based changes</strong>.</p>
</blockquote>
<p><img alt="Storing data as changes to a base version of each file." data-src="https://git-scm.com/book/en/v2/images/deltas.png"></p>
<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就如下图所示：</p>
<blockquote>
<p>Git thinks about its data more like a <strong>stream of snapshots</strong>.</p>
</blockquote>
<p><img alt="Git stores data as snapshots of the project over time." data-src="https://git-scm.com/book/en/v2/images/snapshots.png"></p>
<blockquote>
<p>This makes Git <strong>more like a mini filesystem</strong> with some incredibly powerful tools built on top of it, rather than simply a VCS.</p>
</blockquote>
<h3 id="The-Three-States"><a href="#The-Three-States" class="headerlink" title="The Three States"></a>The Three States</h3><p><img alt="Working tree, staging area, and Git directory." data-src="https://git-scm.com/book/en/v2/images/areas.png"></p>
<p>对任何一个文件，在Git内都有三种状态：</p>
<ul>
<li>已提交(committed)：表示该文件已经被安全的保存在本地数据库中了</li>
<li>已修改(modified)：表示修改了某个文件，但还没有提交保存</li>
<li>已暂存(staged/index)：表示把已修改的文件放在下次提交时要保存的清单中</li>
</ul>
<h2 id="Git-命令图解"><a href="#Git-命令图解" class="headerlink" title="Git 命令图解"></a>Git 命令图解</h2><p><img alt="Visualize Convention" data-src="https://marklodato.github.io/visual-git-guide/conventions.svg"></p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p><code>git diff</code>显示两次提交之间的变动。</p>
<p><img alt="git diff" data-src="https://marklodato.github.io/visual-git-guide/diff.svg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示暂存区和工作区的代码差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br></pre></td></tr></table></figure>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><h4 id="命令图解"><a href="#命令图解" class="headerlink" title="命令图解"></a>命令图解</h4><p>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。</p>
<p><img alt="git commit" data-src="https://marklodato.github.io/visual-git-guide/commit-master.svg"></p>
<p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。</p>
<p><img alt="git commit" data-src="https://marklodato.github.io/visual-git-guide/commit-maint.svg"></p>
<h4 id="更改最近的commit"><a href="#更改最近的commit" class="headerlink" title="更改最近的commit"></a>更改最近的commit</h4><p>如果想更改一次提交，使用 <code>git commit --amend</code>。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p>
<p><img alt="git commit --amend" data-src="https://marklodato.github.io/visual-git-guide/commit-amend.svg"></p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p>
<p>当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，<code>git checkout HEAD~ foo.c</code>会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的<code>foo.c</code>复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-files.svg"></p>
<p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-branch.svg"></p>
<p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像<em>master~3</em>类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行<code>git checkout v1.6.6.1</code>（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说<code>git checkout master</code>。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#detached" target="_blank" rel="external nofollow noopener noreferrer">下面</a>。</p>
<p><img alt="git checkout master~3" data-src="https://marklodato.github.io/visual-git-guide/checkout-detached.svg"></p>
<h3 id="HEAD标识处于分离状态时的提交操作"><a href="#HEAD标识处于分离状态时的提交操作" class="headerlink" title="HEAD标识处于分离状态时的提交操作"></a>HEAD标识处于分离状态时的提交操作</h3><p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/commit-detached.svg"></p>
<p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-after-detached.svg"></p>
<p>但是，如果你想保存这个状态，可以用命令<code>git checkout -b *name*</code>来创建一个新的分支。</p>
<p><img alt="img" data-src="https://marklodato.github.io/visual-git-guide/checkout-b-detached.svg"></p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>reset命令把HEAD指针指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p>
<h4 id="Soft-Reset"><a href="#Soft-Reset" class="headerlink" title="Soft Reset"></a>Soft Reset</h4><p><code>soft reset</code> 会移动当前 HEAD 指针到某个特定的commit，与此同时当前工作目录的文件不变。</p>
<p>举个例子，我们在<code>035cc</code> commit 新增了一个 <code>index.js</code> 文件，在 <code>9e78i</code> commit 新增了一个 <code>styles.css</code>文件，这个时候我们像撤销commit，不再要<code>index.js</code>文件，但是想保留 <code>styles.css</code>文件，这个时候我们执行 <code>git reset --soft HEAD~2</code>，HEAD指针前移到<code>ec5be</code>，但是在commit <code>ec5be</code>之后添加的文件仍然保留 commit  <code>9e78i</code> 的状态。</p>
<p><img alt="Soft Reset" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s---GveiZe---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/je5240aqa5uw9d8j3ibb.gif"></p>
<h4 id="Hard-Reset"><a href="#Hard-Reset" class="headerlink" title="Hard Reset"></a>Hard Reset</h4><p><code>hard reset</code> 不仅仅会移动当前 HEAD 指针到某个特定的commit，与此同时在该commit之后提交的所有文件修改都撤销。</p>
<p><img alt="Hard Reset" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--GqjwnYkF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/hlh0kowt3hov1xhcku38.gif"></p>
<h4 id="撤销-add"><a href="#撤销-add" class="headerlink" title="撤销 add"></a>撤销 add</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD <span class="comment"># 撤销add的所有文件</span></span><br><span class="line">$ git reset HEAD &lt;fileA&gt; <span class="comment"># 撤销add的fileA</span></span><br></pre></td></tr></table></figure>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><img alt="git revert" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--eckmvr2M--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/3kkd2ahn41zixs12xgpf.gif"></p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img alt="git merge" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--cT4TSe48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/894znjv4oo9agqiz4dql.gif"></p>
<h4 id="命令图解-1"><a href="#命令图解-1" class="headerlink" title="命令图解"></a>命令图解</h4><p>Merge操作会从目标 commit 和当前 commit （即 HEAD 所指向的 commit）分叉的位置起，把目标 commit 的路径上的所有 commit 的内容一并应用到当前 commit，然后自动生成一个新的 commit。</p>
<p>如下图所示，master 分支当前提交为ed489，other 分支提交为33104，他们的共同祖父节点为b325c，在master 分支执行 <code>git merge other</code>会进行一次<a href="http://en.wikipedia.org/wiki/Three-way_merge" target="_blank" rel="external nofollow noopener noreferrer">三方合并</a>。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。具体来说，执行<code>git merge other</code>的过程中，会对比other分支的两次commit，相对于当前master分支的最新commit，得到改变的内容，合并成一次新的commit提交到master分支。</p>
<p><img alt="git merge other" data-src="https://marklodato.github.io/visual-git-guide/merge.svg"></p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果两个分支修改了相同的内容，merge 的时候就会发生冲突，git 不知道应该以哪个为准，会告诉你 merge 失败的原因，需要你来手动解决掉冲突，并重新 add、commit（改动不同文件或同一文件的不同行都不会产生冲突）；或者使用<code>git merge --abort</code>放弃解决冲突，取消merge。</p>
<p><img alt="git merge conflict" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--7lBksXwA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bcd5ajtoc0g5dxzmpfbq.gif"></p>
<h4 id="Fast-Forward"><a href="#Fast-Forward" class="headerlink" title="Fast Forward"></a>Fast Forward</h4><p><code>Fast Forward</code>是git在合并分支时候为了提高性能的默认方式。当待合并的分支有当前分支的所有commit的时候，不会创建新的commit，而是直接移动HEAD指针。</p>
<p><img alt="git merge fast forward" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--cT4TSe48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/894znjv4oo9agqiz4dql.gif"></p>
<p><code>Fast Forward</code> 会丢失在dev分支上的提交信息，为了保持原有dev分支上提交链的完成性，最佳实践是采用 <code>no-fast-forward</code>模式来执行merge操作。</p>
<p><img alt="git merge no-fast-forward" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--zRZ0x2Vc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/rf1o2b6eduboqwkigg3w.gif"></p>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p><img alt="git cherry-pick" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--9vWP_K4S--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/2dkjx4yeaal10xyvj29v.gif"></p>
<h4 id="命令图解-2"><a href="#命令图解-2" class="headerlink" title="命令图解"></a>命令图解</h4><p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
<p><img alt="git cherry-pick 2c33a" data-src="https://marklodato.github.io/visual-git-guide/cherry-pick.svg"></p>
<p>以上图为例，分别有<code>master</code> 和 <code>topic</code> 两个分支，在 <code>master</code> 分支的 <code>ed489</code> commit 之后执行 <code>git cherry-pick 2c33a</code>，可以直接将<code>topic</code> 分支上<code>2c33a</code>的commit的内容应用到master分支上，同时创建了新的commit <code>f142b</code>。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在target branch 上应用来自 source branch 的对应 commit 的内容</span></span><br><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br><span class="line"><span class="comment"># 一次转移多个commit</span></span><br><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br><span class="line"><span class="comment"># 一次转移commit A到commit B间的所有commit内容</span></span><br><span class="line"><span class="comment"># 要求：commit A 必须早于 commit B</span></span><br><span class="line"><span class="comment"># 注意：下面这个命令中 commit A 不会被包含在 cherry-pick 中</span></span><br><span class="line"><span class="comment"># 如果想要包含commit A，需执行 `git cherry-pick A^..B`</span></span><br><span class="line">$ git cherry-pick A..B</span><br></pre></td></tr></table></figure>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><code>git cherry-pick</code>命令的常用配置项如下。</p>
<p><strong>（1）<code>-e</code>，<code>--edit</code></strong></p>
<p>打开外部编辑器，编辑提交信息。</p>
<p><strong>（2）<code>-n</code>，<code>--no-commit</code></strong></p>
<p>只更新工作区和暂存区，不产生新的提交。</p>
<p><strong>（3）<code>-x</code></strong></p>
<p>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</p>
<p><strong>（4）<code>-s</code>，<code>--signoff</code></strong></p>
<p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p>
<p><strong>（5）<code>-m parent-number</code>，<code>--mainline parent-number</code></strong></p>
<p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p>
<p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从<code>1</code>开始的整数，代表原始提交的父分支编号。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令表示，Cherry pick 采用提交<code>commitHash</code>来自编号1的父分支的变动。</p>
<p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p>
<h4 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p>
<p><strong>（1）<code>--continue</code></strong></p>
<p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）<code>--abort</code></strong></p>
<p>发生代码冲突后，放弃合并，回到操作前的样子。</p>
<p><strong>（3）<code>--quit</code></strong></p>
<p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子</p>
<h4 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h4><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add target git://gitUrl</span><br></pre></td></tr></table></figure>
<p>上面命令添加了一个远程仓库<code>target</code>。</p>
<p>然后，将远程代码抓取到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch target</span><br></pre></td></tr></table></figure>
<p>上面命令将远程代码仓库抓取到本地。</p>
<p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> target/master</span><br></pre></td></tr></table></figure>
<p>最后，使用<code>git cherry-pick</code>命令转移提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><img alt="git rebase" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--EIY4OOcE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/dwyukhq8yj2xliq4i50e.gif"></p>
<h4 id="命令图解-3"><a href="#命令图解-3" class="headerlink" title="命令图解"></a>命令图解</h4><p>Rebase 是合并命令的另一种选择。<strong>git merge把两个父分支合并后进行一次提交，提交历史不是线性的</strong>。Rebase在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的cherry-pick。</p>
<p><img alt="git rebase master" data-src="https://marklodato.github.io/visual-git-guide/rebase.svg"></p>
<p><strong>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支</strong>，将topic分支的基准先设置为master的最新commit，然后重演自己的提交，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。具体来说，你从 <code>a47c3</code> 处从master分支创建了你自己的 <code>topic</code>来开发，提交了两次之后到了<code>2c33a</code>。在这个期间，<code>master</code>分支已经合并了来自于多个开发者的提交，进行到了<code>da985</code>这个commit。这个时候，你在自己的<code>topic</code>分支上执行 <code>git rebase master</code>，重新设置了自己的基线。topic分支的基线改为<code>da985</code>，然后重演<code>169a6</code>和<code>2c33a</code>两个提交，形成新的commit。</p>
<p>要限制回滚范围，使用<code>--onto</code>选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p>
<p><img alt="git rebase --onto master 169a6" data-src="https://marklodato.github.io/visual-git-guide/rebase-onto.svg"></p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>rebase过程中，也许会出现冲突（conflict）</p>
<ul>
<li>git会停止rebase，需要解决冲突</li>
<li>解决完，使用<code>git add</code>添加冲突的文件，更新暂存区</li>
<li><code>git rebase --continue</code>继续剩下的rebase</li>
<li><code>git rebase --abort</code>终止rebase行为，并且feature会回到rebase开始之前的状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git rebase develop</span><br><span class="line">CONFLICT (content): Rebase conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic rebase failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git rebase --continue"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>查看readme.md 内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Git tracks changes <span class="keyword">of</span> files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br></pre></td></tr></table></figure>
<p>选择保留<code>HEAD</code>或者<code>feature</code>的版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Git tracks changes <span class="keyword">of</span> files.</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick AND simple.</span><br></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.md</span><br><span class="line">$ git rebase --contine</span><br></pre></td></tr></table></figure>
<p>同样有<code>git rebase --interactive</code>让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。交互式的rebase有六个可以执行的操作。</p>
<ul>
<li><code>reword</code>: Change the commit message</li>
<li><code>edit</code>: Amend this commit</li>
<li><code>squash</code>: Meld commit into the previous commit</li>
<li><code>fixup</code>: Meld commit into the previous commit, without keeping the commit’s log message</li>
<li><code>exec</code>: Run a command on each commit we want to rebase</li>
<li><code>drop</code>: Remove the commit</li>
</ul>
<h4 id="压缩commit"><a href="#压缩commit" class="headerlink" title="压缩commit"></a>压缩commit</h4><p><img alt="git interactive rebase squash" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--VSQt4g1V--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bc1r460xx1i0blu0lnnm.gif"></p>
<h4 id="丢弃commit"><a href="#丢弃commit" class="headerlink" title="丢弃commit"></a>丢弃commit</h4><p><img alt="git rebase drop commit" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--P6jr7igd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/msofpv7k6rcmpaaefscm.gif"></p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class="line">origin  git@github.com:jquery/jquery.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:SimpCosm/kubernetes.git</span><br><span class="line">  Push  URL: git@github.com:SimpCosm/kubernetes.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                       tracked</span><br><span class="line">    release-0.10                 tracked</span><br><span class="line">    release-0.12                 tracked</span><br><span class="line">   ...</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span><br><span class="line">    release-1.16 merges with remote release-1.16</span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span><br><span class="line">    release-1.18                 pushes to release-1.18                 (up to date)</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程仓库名</span></span><br><span class="line">$ git remote rm &lt;主机名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给远程主机改名</span></span><br><span class="line">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机的版本库有了更新，需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<p><img alt="git fetch" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--38PuARw2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/bulx1voegfji4vwgndh4.gif"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般用法</span></span><br><span class="line">$ git fetch  [&lt;repository&gt; [&lt;refspec&gt;...]</span><br><span class="line"></span><br><span class="line">$ git fetch origin <span class="comment"># 拉回origin仓库的所有分支</span></span><br><span class="line">$ git fetch origin release-1.19 <span class="comment"># 拉回origin仓库的release-1.19分支</span></span><br><span class="line">$ git checkout -b release-1.19 origin/release-1.19 <span class="comment"># 基于远程1.19分支创建本地分支</span></span><br></pre></td></tr></table></figure>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。可以认为git pull是git fetch和git merge两个步骤的结合。</p>
<p><img alt="git pull" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s---X5AXldj--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/zifpnl1h6a4tk4qdc9sy.gif"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="comment"># 取回origin主机的next分支，与本地的master分支合并</span></span><br><span class="line">$ git pull origin next:master</span><br><span class="line"><span class="comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span></span><br><span class="line"><span class="comment"># 下面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</span></span><br><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p>
<p>Git也允许手动建立追踪关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream master origin/next</span><br></pre></td></tr></table></figure>
<p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>
<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ git push origin --delete master</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p>
<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --force origin</span><br></pre></td></tr></table></figure>
<p>上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动</span></span><br><span class="line">$ git <span class="built_in">log</span> (tag-name||commit-SHA) HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow file</span><br><span class="line">$ git whatchanged file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br></pre></td></tr></table></figure>
<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p><img alt="git reflog" data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--A1UMM2AH--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/9z9rhtbw7mrigp0miijz.gif"></p>
<h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show commit-SHA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only commit-SHA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show commit-SHA:filename</span><br></pre></td></tr></table></figure>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p><code>git stash</code>会把所有未提交的修改（包括暂存和未暂存的）都保存起来，用于日后恢复当前工作目录</p>
<ul>
<li>保存一个不必要但日后又想查看的提交</li>
<li>切换分支前先暂存，处理分支的其他事情</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch develop</span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> file:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line"></span><br><span class="line">modified:   index.html</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: <span class="number">5002</span>d47 ...</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<blockquote>
<p>stage是本地的，不会上传到git server</p>
</blockquote>
<p>实际应用中，推荐给每个stash加一个message，使用<code>git stash save</code> 取代 <code>git stash</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git stash save <span class="string">"test stash"</span></span><br><span class="line">Saved working directory and index state On autoswitch: test stash</span><br><span class="line">HEAD 现在位于 <span class="number">296e8</span>d4 remove unnecessary postion reset <span class="keyword">in</span> onResume <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"><span class="title">$</span> <span class="title">git</span> <span class="title">stash</span> <span class="title">list</span></span></span><br><span class="line"><span class="function"><span class="title">stash</span>@</span>&#123;<span class="number">0</span>&#125;: On autoswitch: test stash</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用<code>git stash list</code>命令，查看stash列表</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">049</span>d078 stash_0</span><br><span class="line">stash@&#123;<span class="number">1</span>&#125;: WIP on master: c264051 stash_1</span><br><span class="line">stash@&#123;<span class="number">2</span>&#125;: WIP on master: <span class="number">21</span>d80a5 stash_2</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>git stash apply</code>命令可以通过名字指定那个stash，默认指定最近的（stash@{0}）</li>
<li>使用<code>git stash pop</code>将stash中第一个stash删除，并将对应修改应用到当前的工作目录中</li>
<li>使用<code>git stash drop</code>，后面加上stash名，可以移除相应的stash；或者使用<code>git stash clear</code>清空所有stash</li>
</ul>
<p>默认情况下，<code>git stash</code>会缓存：</p>
<ul>
<li>添加到暂存区的修改（staged changes ）</li>
<li>Git跟踪但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>此时，使用<code>-u</code>或者<code>--include-untracked</code>可以stash untracked 文件；使用<code>-a</code>或者<code>--all</code>可以stash当前目录下的所有修改（<strong>慎用</strong>）</p>
<h2 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h2><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p>Git Flow工作流的特点是项目会长期存在两个分支：</p>
<ul>
<li>主分支master：对外发布版本；</li>
<li>开发分支develop：日常开发版本；</li>
</ul>
<p>除了以上两个长期分支外，还会存在三种短期分支，开发完即合入master or develop，然后删除：</p>
<ul>
<li>功能分支（feature branch）</li>
<li>补丁分支（hotfix branch）</li>
<li>预发分支（release branch）</li>
</ul>
<p><img alt="Git Flow" data-src="http://walkerdu.com/2019/11/25/git_basic/git_flow_model.png"></p>
<p>Git flow的优点是清晰可控，缺点是需要同时维护两个长期分支。且该模式<strong>适合于”版本发布”的工作模式，即周期新的产出一个版本</strong>，即有特定的发布窗口。但对于<strong>“持续发布”，每次代码在master提交都需要进行部署发布的项目就没有意义</strong>，因为master和develop分支差别不大，还要维护两个长期版本。</p>
<h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p>顾名思义，这是GitHub推荐的一种工作流模式。<strong>长期只有一个master分支</strong>，根据需求从master拉取新分支，开发完成后向master发起一个Pull Request(PR)，PR是一个通知，大家一起进行代码的评审和讨论，此过程中也可以不断提交修改，最后PR被接受，合入master，然后进行部署，删除分支，整个流程就结束了。如下图：</p>
<p><a href="http://walkerdu.com/2019/11/25/git_basic/github_flow.png" target="_blank" rel="external nofollow noopener noreferrer"><img alt="Github Flow" data-src="http://walkerdu.com/2019/11/25/git_basic/github_flow.png"></a></p>
<p>和Git Flow相比，正好相反，GitHub Flow适合于<strong>“持续发布”，每次代码在master提交都需要进行部署发布的项目</strong>。而对于<strong>“版本发布”的项目并不合适</strong>。</p>
<h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p>顾名思义，这是GitLab推荐的工作流。它其实是一个Git Flow和GitHub Flow的一个结合。它<strong>上游只有一个master分支</strong>，且其作为<strong>上游分支，根据不同的环境建立不同的分支，所有的修改必须由”上游”向”下游”进行</strong>。</p>
<ul>
<li>针对”持续发布”的项目，每个不同的环境建立不同的分支，例如：开发环境：master，预发布：pre_release，真实环境：online等等。</li>
<li>针对”版本发布”的项目，除了master分支外，针对稳定版本拉取一个分支，例如proj_stable_1.1。</li>
</ul>
<p><img alt="img" data-src="http://walkerdu.com/2019/11/25/git_basic/gitlab_flow.jpg"></p>
<p>所有的修改都必须先在上游master进行修复，然后合入对应的分支。这样GitLab Flow就可以很好的支持Git Flow和GitHub Flow。</p>
<h2 id="Git-工具"><a href="#Git-工具" class="headerlink" title="Git 工具"></a>Git 工具</h2><h3 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a><a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="external nofollow noopener noreferrer">Rewriting History</a></h3><h3 id="Signing-Your-Work"><a href="#Signing-Your-Work" class="headerlink" title="Signing Your Work"></a><a href="https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work" target="_blank" rel="external nofollow noopener noreferrer">Signing Your Work</a></h3><h3 id="Submodules"><a href="#Submodules" class="headerlink" title="Submodules"></a><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="external nofollow noopener noreferrer">Submodules</a></h3><p>Git Submodule 实质上是 Git 的包管理器，它允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<h4 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h4><p>我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。</p>
<p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 <code>git submodule add</code> 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">Cloning into <span class="string">'DbConnector'</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
<p>如果这时运行 <code>git status</code>，你会注意到几件事。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules</span><br><span class="line">	new file:   DbConnector</span><br></pre></td></tr></table></figure>
<p>首先应当注意到新的 <code>.gitmodules</code> 文件。 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[submodule "DbConnector"]</span></span><br><span class="line">	path = DbConnector</span><br><span class="line">	url = https://github.com/chaconinc/DbConnector</span><br></pre></td></tr></table></figure>
<p>如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 <code>.gitignore</code> 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。</p>
<div class="note info">
            <p>由于 <code>.gitmodules</code> 文件中的 URL 是人们首先尝试克隆/拉取的地方，因此请尽可能确保你使用的 URL 大家都能访问。 例如，若你要使用的推送 URL 与他人的拉取 URL 不同，那么请使用他人能访问到的 URL。 你也可以根据自己的需要，通过在本地执行 <code>git config submodule.DbConnector.url &lt;私有URL&gt;</code> 来覆盖这个选项的值。 如果可行的话，一个相对路径会很有帮助。</p>
          </div>
<p>在 <code>git status</code> 输出中列出的另一个是项目文件夹记录。 如果你运行 <code>git diff</code>，会看到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff --cached DbConnector</span><br><span class="line">diff --git a/DbConnector b/DbConnector</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..c3f01dc</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</span><br></pre></td></tr></table></figure>
<p>虽然 <code>DbConnector</code> 是工作目录中的一个子目录，但 Git 还是会将它视作一个子模块。当你不在那个目录中时，Git 并不会跟踪它的内容， 而是将它看作子模块仓库中的某个具体的提交。</p>
<p>如果你想看到更漂亮的差异输出，可以给 <code>git diff</code> 传递 <code>--submodule</code> 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff --cached --submodule</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..71fc376</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+[submodule <span class="string">"DbConnector"</span>]</span><br><span class="line">+       path = DbConnector</span><br><span class="line">+       url = https://github.com/chaconinc/DbConnector</span><br><span class="line">Submodule DbConnector 0000000...c3f01dc (new submodule)</span><br></pre></td></tr></table></figure>
<p>当你提交时，会看到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -am <span class="string">'added DbConnector module'</span></span><br><span class="line">[master fb9093c] added DbConnector module</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 DbConnector</span><br></pre></td></tr></table></figure>
<p>注意 <code>DbConnector</code> 记录的 <code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p>
<p>最后，推送这些更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h4 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h4><p>接下来我们将会克隆一个含有子模块的项目。 当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into <span class="string">'MainProject'</span>...</span><br><span class="line">remote: Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> MainProject</span><br><span class="line">$ ls -la</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .</span><br><span class="line">drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..</span><br><span class="line">drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git</span><br><span class="line">-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules</span><br><span class="line">drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector</span><br><span class="line">-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile</span><br><span class="line">drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts</span><br><span class="line">drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src</span><br><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ ls</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>其中有 <code>DbConnector</code> 目录，不过是空的。 你必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule init</span><br><span class="line">Submodule <span class="string">'DbConnector'</span> (https://github.com/chaconinc/DbConnector) registered <span class="keyword">for</span> path <span class="string">'DbConnector'</span></span><br><span class="line">$ git submodule update</span><br><span class="line">Cloning into <span class="string">'DbConnector'</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'c3f01dc8862123d317dd46284b05b6892c7b29bc'</span></span><br></pre></td></tr></table></figure>
<p>现在 <code>DbConnector</code> 子目录是处在和之前提交时相同的状态了。</p>
<p>不过还有更简单一点的方式。 如果给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recurse-submodules https://github.com/chaconinc/MainProject</span><br><span class="line">Cloning into <span class="string">'MainProject'</span>...</span><br><span class="line">remote: Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 14 (delta 1), reused 13 (delta 0)</span><br><span class="line">Unpacking objects: 100% (14/14), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Submodule <span class="string">'DbConnector'</span> (https://github.com/chaconinc/DbConnector) registered <span class="keyword">for</span> path <span class="string">'DbConnector'</span></span><br><span class="line">Cloning into <span class="string">'DbConnector'</span>...</span><br><span class="line">remote: Counting objects: 11, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'c3f01dc8862123d317dd46284b05b6892c7b29bc'</span></span><br></pre></td></tr></table></figure>
<p>如果你已经克隆了项目但忘记了 <code>--recurse-submodules</code>，那么可以运行 <code>git submodule update --init</code> 将 <code>git submodule init</code> 和 <code>git submodule update</code> 合并成一步。如果还要初始化、抓取并检出任何嵌套的子模块， 请使用简明的 <code>git submodule update --init --recursive</code>。</p>
<h4 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h4><p>现在我们有一份包含子模块的项目副本，我们将会同时在主项目和子模块项目上与队员协作。</p>
<h5 id="从子模块的远端拉取上游修改"><a href="#从子模块的远端拉取上游修改" class="headerlink" title="从子模块的远端拉取上游修改"></a>从子模块的远端拉取上游修改</h5><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。 我们来看一个简单的例子。</p>
<p>如果想要在子模块中查看新工作，可以进入到目录中运行 <code>git fetch</code> 与 <code>git merge</code>，合并上游分支来更新本地代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c3f01dc..d0354fc  master     -&gt; origin/master</span><br><span class="line">$ git merge origin/master</span><br><span class="line">Updating c3f01dc..d0354fc</span><br><span class="line">Fast-forward</span><br><span class="line"> scripts/connect.sh | 1 +</span><br><span class="line"> src/db.c           | 1 +</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<p>如果你现在返回到主项目并运行 <code>git diff --submodule</code>，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。 如果你不想每次运行 <code>git diff</code> 时都输入 <code>--submodle</code>，那么可以将 <code>diff.submodule</code> 设置为 “log” 来将其作为默认行为。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global diff.submodule <span class="built_in">log</span></span><br><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c3f01dc..d0354fc:</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>
<p>如果在此时提交，那么你会将子模块锁定为其他人更新时的新代码。</p>
<p>如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 <code>git submodule update --remote</code>，Git 将会进入子模块然后抓取并更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule update --remote DbConnector</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   3f19983..d0354fc  master     -&gt; origin/master</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'d0354fc054692d3906c85c3af05ddce39a1c0644'</span></span><br></pre></td></tr></table></figure>
<p>此命令默认会假定你想要更新并检出子模块仓库的 <code>master</code> 分支。 不过你也可以设置为想要的其他分支。 例如，你想要 DbConnector 子模块跟踪仓库的 “stable” 分支，那么既可以在 <code>.gitmodules</code> 文件中设置 （这样其他人也可以跟踪它），也可以只在本地的 <code>.git/config</code> 文件中设置。 让我们在 <code>.gitmodules</code> 文件中设置它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config -f .gitmodules submodule.DbConnector.branch stable</span><br><span class="line"></span><br><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   27cf5d3..c87d55d  stable -&gt; origin/stable</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'</span></span><br></pre></td></tr></table></figure>
<p>如果不用 <code>-f .gitmodules</code> 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。</p>
<p>这时我们运行 <code>git status</code>，Git 会显示子模块中有“新提交”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">  modified:   .gitmodules</span><br><span class="line">  modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>如果你设置了配置选项 <code>status.submodulesummary</code>，Git 也会显示你的子模块的更改摘要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config status.submodulesummary 1</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   .gitmodules</span><br><span class="line">	modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">Submodules changed but not updated:</span><br><span class="line"></span><br><span class="line">* DbConnector c3f01dc...c87d55d (4):</span><br><span class="line">  &gt; catch non-null terminated lines</span><br></pre></td></tr></table></figure>
<p>这时如果运行 <code>git diff</code>，可以看到我们修改了 .gitmodules 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule <span class="string">"DbConnector"</span>]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line"> Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>
<p>这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 <code>git log -p</code> 查看这个信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p --submodule</span><br><span class="line">commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Sep 17 16:37:02 2014 +0200</span><br><span class="line"></span><br><span class="line">    updating DbConnector <span class="keyword">for</span> bug fixes</span><br><span class="line"></span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 6fc0b3d..fd1cc29 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> [submodule <span class="string">"DbConnector"</span>]</span><br><span class="line">        path = DbConnector</span><br><span class="line">        url = https://github.com/chaconinc/DbConnector</span><br><span class="line">+       branch = stable</span><br><span class="line">Submodule DbConnector c3f01dc..c87d55d:</span><br><span class="line">  &gt; catch non-null terminated lines</span><br><span class="line">  &gt; more robust error handling</span><br><span class="line">  &gt; more efficient db routine</span><br><span class="line">  &gt; better connection routine</span><br></pre></td></tr></table></figure>
<p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新 <strong>所有</strong> 子模块， 所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。</p>
<h5 id="从项目远端拉取上游更改"><a href="#从项目远端拉取上游更改" class="headerlink" title="从项目远端拉取上游更改"></a>从项目远端拉取上游更改</h5><p>现在，让我们站在协作者的视角，他有自己的 <code>MainProject</code> 仓库的本地克隆， 只是执行 <code>git pull</code> 获取你新提交的更改还不够：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">From https://github.com/chaconinc/MainProject</span><br><span class="line">   fb9093c..0a24cfc  master     -&gt; origin/master</span><br><span class="line">Fetching submodule DbConnector</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c3f01dc..c87d55d  stable     -&gt; origin/stable</span><br><span class="line">Updating fb9093c..0a24cfc</span><br><span class="line">Fast-forward</span><br><span class="line"> .gitmodules         | 2 +-</span><br><span class="line"> DbConnector         | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"> On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   DbConnector (new commits)</span><br><span class="line"></span><br><span class="line">Submodules changed but not updated:</span><br><span class="line"></span><br><span class="line">* DbConnector c87d55d...c3f01dc (4):</span><br><span class="line">  &lt; catch non-null terminated lines</span><br><span class="line">  &lt; more robust error handling</span><br><span class="line">  &lt; more efficient db routine</span><br><span class="line">  &lt; better connection routine</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>git pull</code> 命令会递归地抓取子模块的更改，如上面第一个命令的输出所示。 然而，它不会 <strong>更新</strong> 子模块。这点可通过 <code>git status</code> 命令看到，它会显示子模块“已修改”，且“有新的提交”。 此外，左边的尖括号（&lt;）指出了新的提交，表示这些提交已在 MainProject 中记录，但尚未在本地的 <code>DbConnector</code> 中检出。 为了完成更新，你需要运行 <code>git submodule update</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br><span class="line">Submodule path <span class="string">'vendor/plugins/demo'</span>: checked out <span class="string">'48679c6302815f6c76f1fe30625d795d9e55fc56'</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"> On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>请注意，为安全起见，如果 MainProject 提交了你刚拉取的新子模块，那么应该在 <code>git submodule update</code> 后面添加 <code>--init</code> 选项，如果子模块有嵌套的子模块，则应使用 <code>--recursive</code> 选项。</p>
<p>如果你想自动化此过程，那么可以为 <code>git pull</code> 命令添加 <code>--recurse-submodules</code> 选项（从 Git 2.14 开始）。 这会让 Git 在拉取后运行 <code>git submodule update</code>，将子模块置为正确的状态。 此外，如果你想让 Git 总是以 <code>--recurse-submodules</code> 拉取，可以将配置选项 <code>submodule.recurse</code> 设置为 <code>true</code> （从 Git 2.15 开始可用于 <code>git pull</code>）。此选项会让 Git 为所有支持 <code>--recurse-submodules</code> 的命令使用该选项（除 <code>clone</code> 以外）。</p>
<p>在为父级项目拉取更新时，还会出现一种特殊的情况：在你拉取的提交中， 可能 <code>.gitmodules</code> 文件中记录的子模块的 URL 发生了改变。 比如，若子模块项目改变了它的托管平台，就会发生这种情况。 此时，若父级项目引用的子模块提交不在仓库中本地配置的子模块远端上，那么执行 <code>git pull --recurse-submodules</code> 或 <code>git submodule update</code> 就会失败。 为了补救，<code>git submodule sync</code> 命令需要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将新的 URL 复制到本地配置中</span></span><br><span class="line">$ git submodule sync --recursive</span><br><span class="line"><span class="comment"># 从新 URL 更新子模块</span></span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<h5 id="在子模块上工作"><a href="#在子模块上工作" class="headerlink" title="在子模块上工作"></a>在子模块上工作</h5><p>你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。</p>
<p>现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。</p>
<p>到目前为止，当我们运行 <code>git submodule update</code> 从子模块仓库中抓取修改时， Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作“游离的 HEAD”的状态。 这意味着没有本地工作分支（例如 “master” ）跟踪改动。 如果没有工作分支跟踪更改，也就意味着即便你将更改提交到了子模块，这些更改也很可能会在下次运行 <code>git submodule update</code> 时丢失。如果你想要在子模块中跟踪这些修改，还需要一些额外的步骤。</p>
<p>为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 <code>git submodule update --remote</code> 来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。</p>
<p>首先，让我们进入子模块目录然后检出一个分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ git checkout stable</span><br><span class="line">Switched to branch <span class="string">'stable'</span></span><br></pre></td></tr></table></figure>
<p>然后尝试用 “merge” 选项来更新子模块。 为了手动指定它，我们只需给 <code>update</code> 添加 <code>--merge</code> 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ git submodule update --remote --merge</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 2), reused 4 (delta 2)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   c87d55d..92c7337  stable     -&gt; origin/stable</span><br><span class="line">Updating c87d55d..92c7337</span><br><span class="line">Fast-forward</span><br><span class="line"> src/main.c | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: merged <span class="keyword">in</span> <span class="string">'92c7337b30ef9e0893e758dac2459d07362ab5ea'</span></span><br></pre></td></tr></table></figure>
<p>如果我们进入 DbConnector 目录，可以发现新的改动已经合并入本地 <code>stable</code> 分支。 现在让我们看看当我们对库做一些本地的改动而同时其他人推送另外一个修改到上游时会发生什么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ vim src/db.c</span><br><span class="line">$ git commit -am <span class="string">'unicode support'</span></span><br><span class="line">[stable f906e16] unicode support</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ git submodule update --remote --rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: unicode support</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: rebased into <span class="string">'5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</span></span><br></pre></td></tr></table></figure>
<p>如果你忘记 <code>--rebase</code> 或 <code>--merge</code>，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">Submodule path <span class="string">'DbConnector'</span>: checked out <span class="string">'5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</span></span><br></pre></td></tr></table></figure>
<p>即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 <code>origin/stable</code>（或任何一个你想要的远程分支）就行了。</p>
<p>如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule update --remote</span><br><span class="line">remote: Counting objects: 4, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 4 (delta 0), reused 4 (delta 0)</span><br><span class="line">Unpacking objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/DbConnector</span><br><span class="line">   5d60ef9..c75e92a  stable     -&gt; origin/stable</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">	scripts/setup.sh</span><br><span class="line">Please, commit your changes or stash them before you can switch branches.</span><br><span class="line">Aborting</span><br><span class="line">Unable to checkout <span class="string">'c75e92a2b3855c9e5b66f915308390d9db204aca'</span> <span class="keyword">in</span> submodule path <span class="string">'DbConnector'</span></span><br></pre></td></tr></table></figure>
<p>如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule update --remote --merge</span><br><span class="line">Auto-merging scripts/setup.sh</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> scripts/setup.sh</span><br><span class="line">Recorded preimage <span class="keyword">for</span> <span class="string">'scripts/setup.sh'</span></span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line">Unable to merge <span class="string">'c75e92a2b3855c9e5b66f915308390d9db204aca'</span> <span class="keyword">in</span> submodule path <span class="string">'DbConnector'</span></span><br></pre></td></tr></table></figure>
<p>你可以进入子模块目录中然后就像平时那样修复冲突。</p>
<h5 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h5><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">Submodule DbConnector c87d55d..82d2ad3:</span><br><span class="line">  &gt; Merge from origin/stable</span><br><span class="line">  &gt; updated setup script</span><br><span class="line">  &gt; unicode support</span><br><span class="line">  &gt; remove unnecessary method</span><br><span class="line">  &gt; add new option <span class="keyword">for</span> conn pooling</span><br></pre></td></tr></table></figure>
<p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦， 因为他们无法得到依赖的子模块改动。那些改动只存在于我们本地的拷贝中。</p>
<p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 <code>git push</code> 命令接受可以设置为 “check” 或 “on-demand” 的 <code>--recurse-submodules</code> 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 <code>push</code> 操作失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --recurse-submodules=check</span><br><span class="line">The following submodule paths contain changes that can</span><br><span class="line">not be found on any remote:</span><br><span class="line">  DbConnector</span><br><span class="line"></span><br><span class="line">Please try</span><br><span class="line"></span><br><span class="line">	git push --recurse-submodules=on-demand</span><br><span class="line"></span><br><span class="line">or <span class="built_in">cd</span> to the path and use</span><br><span class="line"></span><br><span class="line">	git push</span><br><span class="line"></span><br><span class="line">to push them to a remote.</span><br></pre></td></tr></table></figure>
<p>如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。 如果你想要对所有推送都执行检查，那么可以通过设置 <code>git config push.recurseSubmodules check</code> 让它成为默认行为。</p>
<p>另一个选项是使用 “on-demand” 值，它会尝试为你这样做。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --recurse-submodules=on-demand</span><br><span class="line">Pushing submodule <span class="string">'DbConnector'</span></span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 3), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/DbConnector</span><br><span class="line">   c75e92a..82d2ad3  stable -&gt; stable</span><br><span class="line">Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class="line">To https://github.com/chaconinc/MainProject</span><br><span class="line">   3d6d338..9a377d1  master -&gt; master</span><br></pre></td></tr></table></figure>
<p>如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。 如果那个子模块因为某些原因推送失败，主项目也会推送失败。 你也可以通过设置 <code>git config push.recurseSubmodules on-demand</code> 让它成为默认行为。</p>
<h5 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h5><p>如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。</p>
<p>如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。</p>
<p>不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 2, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1)</span><br><span class="line">Unpacking objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/chaconinc/MainProject</span><br><span class="line">   9a377d1..eb974f8  master     -&gt; origin/master</span><br><span class="line">Fetching submodule DbConnector</span><br><span class="line">warning: Failed to merge submodule DbConnector (merge following commits not found)</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict <span class="keyword">in</span> DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found” （未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。</p>
<p>为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 <code>git diff</code>，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br></pre></td></tr></table></figure>
<p>所以，在本例中，<code>eb41d76</code> 是我们的子模块中<strong>大家共有</strong>的提交，而 <code>c771610</code> 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 <code>eb41d76</code> 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。</p>
<p>来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。</p>
<p>所以，我们将会进入子模块目录，基于 <code>git diff</code> 的第二个 SHA-1 创建一个分支然后手动合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector</span><br><span class="line"></span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"></span><br><span class="line">$ git branch try-merge c771610</span><br><span class="line">(DbConnector) $ git merge try-merge</span><br><span class="line">Auto-merging src/main.c</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> src/main.c</span><br><span class="line">Recorded preimage <span class="keyword">for</span> <span class="string">'src/main.c'</span></span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>我们在这儿得到了一个真正的合并冲突，所以如果想要解决并提交它，那么只需简单地通过结果来更新主项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim src/main.c (1)</span><br><span class="line">$ git add src/main.c</span><br><span class="line">$ git commit -am <span class="string">'merged our changes'</span></span><br><span class="line">Recorded resolution <span class="keyword">for</span> <span class="string">'src/main.c'</span>.</span><br><span class="line">[master 9fd905e] merged our changes</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> .. (2)</span><br><span class="line">$ git diff (3)</span><br><span class="line">diff --cc DbConnector</span><br><span class="line">index eb41d76,c771610..0000000</span><br><span class="line">--- a/DbConnector</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@@ -1,1 -1,1 +1,1 @@@</span><br><span class="line">- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135</span><br><span class="line"> -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d</span><br><span class="line">++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a</span><br><span class="line">$ git add DbConnector (4)</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"Merge Tom's Changes"</span> (5)</span><br><span class="line">[master 10d2c60] Merge Tom<span class="string">'s Changes</span></span><br></pre></td></tr></table></figure>
<ol>
<li>首先解决冲突</li>
<li>然后返回到主项目目录中</li>
<li>再次检查 SHA-1 值</li>
<li>解决冲突的子模块记录</li>
<li>提交我们的合并</li>
</ol>
<p>这可能会让你有点儿困惑，但它确实不难。</p>
<p>有趣的是，Git 还能处理另一种情况。 如果子模块目录中存在着这样一个合并提交，它的历史中包含了的<strong>两边</strong>的提交，那么 Git 会建议你将它作为一个可行的解决方案。 它看到有人在子模块项目的某一点上合并了包含这两次提交的分支，所以你可能想要那个。</p>
<p>这就是为什么前面的错误信息是 “merge following commits not found”，因为它不能 <strong>这样</strong> 做。 它让人困惑是因为<strong>谁能想到它会尝试这样做？</strong></p>
<p>如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">warning: Failed to merge submodule DbConnector (not fast-forward)</span><br><span class="line">Found a possible merge resolution <span class="keyword">for</span> the submodule:</span><br><span class="line"> 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes</span><br><span class="line">If this is correct simply add it to the index <span class="keyword">for</span> example</span><br><span class="line">by using:</span><br><span class="line"></span><br><span class="line">  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a <span class="string">"DbConnector"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> will accept this suggestion.</span><br><span class="line">Auto-merging DbConnector</span><br><span class="line">CONFLICT (submodule): Merge conflict <span class="keyword">in</span> DbConnector</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>Git 建议的命令是更新索引，就像你运行了 <code>git add</code> 那样，这样会清除冲突然后提交。 不过你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> DbConnector/</span><br><span class="line">$ git merge 9fd905e</span><br><span class="line">Updating eb41d76..9fd905e</span><br><span class="line">Fast-forward</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ git add DbConnector</span><br><span class="line">$ git commit -am <span class="string">'Fast forwarded to a common submodule child'</span></span><br></pre></td></tr></table></figure>
<p>这些命令完成了同一件事，但是通过这种方式你至少可以验证工作是否有效，以及当你在完成时可以确保子模块目录中有你的代码。</p>
<h4 id="子模的块技巧"><a href="#子模的块技巧" class="headerlink" title="子模的块技巧"></a>子模的块技巧</h4><p>你可以做几件事情来让用子模块工作轻松一点儿。</p>
<h5 id="子模块遍历"><a href="#子模块遍历" class="headerlink" title="子模块遍历"></a>子模块遍历</h5><p>有一个 <code>foreach</code> 子模块命令，它能在每一个子模块中运行任意命令。 如果项目中包含了大量子模块，这会非常有用。</p>
<p>例如，假设我们想要开始开发一项新功能或者修复一些错误，并且需要在几个子模块内工作。 我们可以轻松地保存所有子模块的工作进度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule foreach <span class="string">'git stash'</span></span><br><span class="line">Entering <span class="string">'CryptoLibrary'</span></span><br><span class="line">No <span class="built_in">local</span> changes to save</span><br><span class="line">Entering <span class="string">'DbConnector'</span></span><br><span class="line">Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable</span><br><span class="line">HEAD is now at 82d2ad3 Merge from origin/stable</span><br></pre></td></tr></table></figure>
<p>然后我们可以创建一个新分支，并将所有子模块都切换过去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git submodule foreach <span class="string">'git checkout -b featureA'</span></span><br><span class="line">Entering <span class="string">'CryptoLibrary'</span></span><br><span class="line">Switched to a new branch <span class="string">'featureA'</span></span><br><span class="line">Entering <span class="string">'DbConnector'</span></span><br><span class="line">Switched to a new branch <span class="string">'featureA'</span></span><br></pre></td></tr></table></figure>
<p>你应该明白。 能够生成一个主项目与所有子项目的改动的统一差异是非常有用的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff; git submodule foreach <span class="string">'git diff'</span></span><br><span class="line">Submodule DbConnector contains modified content</span><br><span class="line">diff --git a/src/main.c b/src/main.c</span><br><span class="line">index 210f1ae..1f0acdc 100644</span><br><span class="line">--- a/src/main.c</span><br><span class="line">+++ b/src/main.c</span><br><span class="line">@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)</span><br><span class="line"></span><br><span class="line">      commit_pager_choice();</span><br><span class="line"></span><br><span class="line">+     url = url_decode(url_orig);</span><br><span class="line">+</span><br><span class="line">      /* build alias_argv */</span><br><span class="line">      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));</span><br><span class="line">      alias_argv[0] = alias_string + 1;</span><br><span class="line">Entering <span class="string">'DbConnector'</span></span><br><span class="line">diff --git a/src/db.c b/src/db.c</span><br><span class="line">index 1aaefb6..5297645 100644</span><br><span class="line">--- a/src/db.c</span><br><span class="line">+++ b/src/db.c</span><br><span class="line">@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)</span><br><span class="line">        <span class="built_in">return</span> url_decode_internal(&amp;url, len, NULL, &amp;out, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+char *url_decode(const char *url)</span><br><span class="line">+&#123;</span><br><span class="line">+       <span class="built_in">return</span> url_decode_mem(url, strlen(url));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> char *url_decode_parameter_name(const char **query)</span><br><span class="line"> &#123;</span><br><span class="line">        struct strbuf out = STRBUF_INIT;</span><br></pre></td></tr></table></figure>
<p>在这里，我们看到子模块中定义了一个函数并在主项目中调用了它。 这明显是个简化了的例子，但是希望它能让你明白这种方法的用处。</p>
<h5 id="有用的别名"><a href="#有用的别名" class="headerlink" title="有用的别名"></a>有用的别名</h5><p>你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 <a href="https://git-scm.com/book/zh/v2/ch00/_git_aliases" target="_blank" rel="external nofollow noopener noreferrer">Git 别名</a> 介绍了设置 Git 别名， 但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config alias.sdiff <span class="string">'!'</span><span class="string">"git diff &amp;&amp; git submodule foreach 'git diff'"</span></span><br><span class="line">$ git config alias.spush <span class="string">'push --recurse-submodules=on-demand'</span></span><br><span class="line">$ git config alias.supdate <span class="string">'submodule update --remote --merge'</span></span><br></pre></td></tr></table></figure>
<p>这样当你想要更新子模块时可以简单地运行 <code>git supdate</code>，或 <code>git spush</code> 检查子模块依赖后推送。</p>
<h4 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h4><p>然而使用子模块还是有一些小问题。</p>
<h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><p>例如，使用 Git 2.13 以前的版本时，在有子模块的项目中切换分支可能会造成麻烦。 如果你创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，你仍然会有一个还未跟踪的子模块目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.12.2</span><br><span class="line"></span><br><span class="line">$ git checkout -b add-crypto</span><br><span class="line">Switched to a new branch <span class="string">'add-crypto'</span></span><br><span class="line"></span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into <span class="string">'CryptoLibrary'</span>...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">'adding crypto library'</span></span><br><span class="line">[add-crypto 4445836] adding crypto library</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 160000 CryptoLibrary</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	CryptoLibrary/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure>
<p>移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。 如果你移除它然后切换回有那个子模块的分支，需要运行 <code>submodule update --init</code> 来重新建立和填充。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git clean -fdx</span><br><span class="line">Removing CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git checkout add-crypto</span><br><span class="line">Switched to branch <span class="string">'add-crypto'</span></span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line"></span><br><span class="line">$ git submodule update --init</span><br><span class="line">Submodule path <span class="string">'CryptoLibrary'</span>: checked out <span class="string">'b8dda6aa182ea4464f3f3264b11e0268545172af'</span></span><br><span class="line"></span><br><span class="line">$ ls CryptoLibrary/</span><br><span class="line">Makefile	includes	scripts		src</span><br></pre></td></tr></table></figure>
<p>再说一遍，这真的不难，只是会让人有点儿困惑。</p>
<p>新版的 Git（&gt;= 2.13）通过为 <code>git checkout</code> 命令添加 <code>--recurse-submodules</code> 选项简化了所有这些步骤， 它能为了我们要切换到的分支让子模块处于的正确状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.13.3</span><br><span class="line"></span><br><span class="line">$ git checkout -b add-crypto</span><br><span class="line">Switched to a new branch <span class="string">'add-crypto'</span></span><br><span class="line"></span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line">Cloning into <span class="string">'CryptoLibrary'</span>...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">'adding crypto library'</span></span><br><span class="line">[add-crypto 4445836] adding crypto library</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 160000 CryptoLibrary</span><br><span class="line"></span><br><span class="line">$ git checkout --recurse-submodules master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>当你在父级项目的几个分支上工作时，对 <code>git checkout</code> 使用 <code>--recurse-submodules</code> 选项也很有用， 它能让你的子模块处于不同的提交上。确实，如果你在记录了子模块的不同提交的分支上切换， 那么在执行 <code>git status</code> 后子模块会显示为“已修改”并指出“新的提交”。 这是因为子模块的状态默认不会在切换分支时保留。</p>
<p>这点非常让人困惑，因此当你的项目中拥有子模块时，可以总是使用 <code>git checkout --recurse-submodules</code>。 （对于没有 <code>--recurse-submodules</code> 选项的旧版 Git，在检出之后可使用 <code>git submodule update --init --recursive</code> 来让子模块处于正确的状态）。</p>
<p>幸运的是，你可以通过 <code>git config submodule.recurse true</code> 设置 <code>submodule.recurse</code> 选项， 告诉 Git（&gt;=2.14）总是使用 <code>--recurse-submodules</code>。 如上所述，这也会让 Git 为每个拥有 <code>--recurse-submodules</code> 选项的命令（除了 <code>git clone</code>） 总是递归地在子模块中执行。</p>
<h5 id="从子目录切换到子模块"><a href="#从子目录切换到子模块" class="headerlink" title="从子目录切换到子模块"></a>从子目录切换到子模块</h5><p>另一个主要的告诫是许多人遇到了将子目录转换为子模块的问题。 如果你在项目中已经跟踪了一些文件，然后想要将它们移动到一个子模块中，那么请务必小心，否则 Git 会对你发脾气。 假设项目内有一些文件在子目录中，你想要将其转换为一个子模块。 如果删除子目录然后运行 <code>submodule add</code>，Git 会朝你大喊：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -Rf CryptoLibrary/</span><br><span class="line">$ git submodule add https://github.com/chaconinc/CryptoLibrary</span><br><span class="line"><span class="string">'CryptoLibrary'</span> already exists <span class="keyword">in</span> the index</span><br></pre></td></tr></table></figure>
<p>你必须要先取消暂存 <code>CryptoLibrary</code> 目录。 然后才可以添加子模块：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm -r CryptoLibrary</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule add https://github.com/chaconinc/CryptoLibrary</span></span><br><span class="line">Cloning into 'CryptoLibrary'...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (10/10), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 11 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure>
<p>现在假设你在一个分支下做了这样的工作。 如果尝试切换回的分支中那些文件还在子目录而非子模块中时——你会得到这个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">  CryptoLibrary/Makefile</span><br><span class="line">  CryptoLibrary/includes/crypto.h</span><br><span class="line">  ...</span><br><span class="line">Please move or remove them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>checkout -f</code> 来强制切换，但是要小心，如果其中还有未保存的修改，这个命令会把它们覆盖掉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -f master</span><br><span class="line">warning: unable to rmdir CryptoLibrary: Directory not empty</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>当你切换回来之后，因为某些原因你得到了一个空的 <code>CryptoLibrary</code> 目录，并且 <code>git submodule update</code> 也无法修复它。 你需要进入到子模块目录中运行 <code>git checkout .</code> 来找回所有的文件。 你也可以通过 <code>submodule foreach</code> 脚本来为多个子模块运行它。</p>
<p>要特别注意的是，近来子模块会将它们的所有 Git 数据保存在顶级项目的 <code>.git</code> 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失任何提交或分支。</p>
<p>拥有了这些工具，使用子模块会成为可以在几个相关但却分离的项目上同时开发的相当简单有效的方法。</p>
<h3 id="Git-Configuration"><a href="#Git-Configuration" class="headerlink" title="Git Configuration"></a><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration" target="_blank" rel="external nofollow noopener noreferrer">Git Configuration</a></h3><h3 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="external nofollow noopener noreferrer">Git Hooks</a></h3><h2 id="Git-Internal"><a href="#Git-Internal" class="headerlink" title="Git Internal"></a>Git Internal</h2><p>Git常用命令共有30多个，可运行<code>git help</code>查看；但Git总共有130多个命令，可以通过<code>git help -a</code>查看，这些命令可以分为高层命令和底层命令，底层命令被设计成unix风格，不常用</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/464.png"></p>
<p>Git仓库下有一个.git目录，里面存储了git全部的秘密，一般包括下面的内容：</p>
<ul>
<li>config</li>
<li>index</li>
<li>HEAD</li>
<li>hooks/</li>
<li>logs/</li>
<li>refs/</li>
<li>objects/</li>
</ul>
<p>下面会详细介绍没个部分都是什么</p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在配置文件里有表现； fetch操作的行为也是在这里配置的</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="keyword">false</span></span><br><span class="line">    bare = <span class="keyword">false</span></span><br><span class="line">    logallrefupdates = <span class="keyword">true</span></span><br><span class="line">    symlinks = <span class="keyword">false</span></span><br><span class="line">    ignorecase = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git<span class="variable">@github</span>.<span class="symbol">com:</span>yanhaijing/zepto.fullpage.git</span><br><span class="line">    fetch = +refs/heads/*<span class="symbol">:refs/remotes/origin/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[branch <span class="string">"dev"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/dev</span><br></pre></td></tr></table></figure>
<h3 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h3><p>git通过一种算法可以得到任意文件的指纹(40位16进制数字)，然后通过文件指纹存取数据，存取的数据都位于objects目录</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/465.png"></p>
<ul>
<li><p>Git常用命令共有30多个，可运行<code>git help</code>查看；但Git总共有130多个命令，可以通过<code>git help -a</code>查看，这些命令可以分为高层命令和底层命令，底层命令被设计成unix风格，不常用</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/464.png"></p>
<p>Git仓库下有一个.git目录，里面存储了git全部的秘密，一般包括下面的内容：</p>
<ul>
<li>config</li>
<li>index</li>
<li>HEAD</li>
<li>hooks/</li>
<li>logs/</li>
<li>refs/</li>
<li>objects/</li>
</ul>
<p>下面会详细介绍没个部分都是什么</p>
<h2 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h2><p>config是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在配置文件里有表现； fetch操作的行为也是在这里配置的</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="keyword">false</span></span><br><span class="line">    bare = <span class="keyword">false</span></span><br><span class="line">    logallrefupdates = <span class="keyword">true</span></span><br><span class="line">    symlinks = <span class="keyword">false</span></span><br><span class="line">    ignorecase = <span class="keyword">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git<span class="variable">@github</span>.<span class="symbol">com:</span>yanhaijing/zepto.fullpage.git</span><br><span class="line">    fetch = +refs/heads/*<span class="symbol">:refs/remotes/origin/*</span></span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[branch <span class="string">"dev"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/dev</span><br></pre></td></tr></table></figure>
<h2 id="objects-1"><a href="#objects-1" class="headerlink" title="objects"></a>objects</h2><p>git通过一种算法可以得到任意文件的指纹(40位16进制数字)，然后通过文件指纹存取数据，存取的数据都位于objects目录</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/465.png"></p>
<p>Git 从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。Git存储的索引内容包含三种对象：</p>
<ul>
<li><strong>commit对象</strong>：<strong>每次提交都会至少产生一个commit对象</strong>，它的内容包括：指向parent commit对象，根tree对象。</li>
<li><strong>tree对象</strong>：类似于目录，tree对象中包含多条记录，每条记录保存了本次快照的所有tree对象和blob对象。</li>
<li><strong>blob对象</strong>：类似于文件，保存具体的文件内容。</li>
</ul>
<p>objects目录下有3种类型的数据：</p>
<ul>
<li>Blob</li>
<li>Tree</li>
<li>Commit</li>
</ul>
<p>文件都被存储为blob类型的文件，可以通过内部命令<code>hash-object</code>写入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>
<p>然后通过<code>cat-file</code>取出数据</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="keyword">test </span>content</span><br></pre></td></tr></table></figure>
<p>文件夹被存储为tree类型的文件，文件内容如下所示</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">git cat-file -p <span class="number">99</span>f<span class="number">1</span>a<span class="number">6</span>d<span class="number">12</span>cb<span class="number">4</span>b<span class="number">6</span>f<span class="number">19</span><span class="keyword">c</span><span class="number">8655</span>fca<span class="number">46</span><span class="keyword">c</span><span class="number">3</span>ecf<span class="number">317074e0</span></span><br><span class="line"><span class="number">100644</span> blob <span class="number">47</span><span class="keyword">c</span><span class="number">6340</span>d<span class="number">6459e05787</span>f<span class="number">644</span><span class="keyword">c</span><span class="number">2447</span>d<span class="number">2595</span>f<span class="number">5</span>d<span class="number">3</span>a<span class="number">54</span>b      simplegit.rb</span><br></pre></td></tr></table></figure>
<p>一般我们系统中的目录，在git中会像下面这样存储</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/466.png"></p>
<p>创建的提交节点被存储为commit类型数据，commit文件的内容如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line">committer Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure>
<p>有三个提交的Git仓库可简化为下图所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/467.png"></p>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>refs目录存储都是引用文件，如本地分支，远端分支，标签等</p>
<ul>
<li>refs/heads/xxx 本地分支</li>
<li>refs/remotes/origin/xxx 远端分支</li>
<li>refs/tags/xxx 本地tag</li>
</ul>
<p>引用文件的内容都是40位commit</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/470.png"></p>
<p>上面只有提交的图补上分支后，如下所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/468.png"></p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD文件存储的是当前所在的位置，其内容可以使分支名字，40位commit ID</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat HEAD</span><br><span class="line"><span class="built_in">ref</span>s/heads/master</span><br></pre></td></tr></table></figure>
<p>上面的图补上HEAD后，如下所示：</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/469.png"></p>
</li>
</ul>
<p>文件都被存储为blob类型的文件，可以通过内部命令<code>hash-object</code>写入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'test content'</span> | git <span class="built_in">hash</span>-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>
<p>然后通过<code>cat-file</code>取出数据</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"><span class="keyword">test </span>content</span><br></pre></td></tr></table></figure>
<p>文件夹被存储为tree类型的文件，文件内容如下所示</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">git cat-file -p <span class="number">99</span>f<span class="number">1</span>a<span class="number">6</span>d<span class="number">12</span>cb<span class="number">4</span>b<span class="number">6</span>f<span class="number">19</span><span class="keyword">c</span><span class="number">8655</span>fca<span class="number">46</span><span class="keyword">c</span><span class="number">3</span>ecf<span class="number">317074e0</span></span><br><span class="line"><span class="number">100644</span> blob <span class="number">47</span><span class="keyword">c</span><span class="number">6340</span>d<span class="number">6459e05787</span>f<span class="number">644</span><span class="keyword">c</span><span class="number">2447</span>d<span class="number">2595</span>f<span class="number">5</span>d<span class="number">3</span>a<span class="number">54</span>b      simplegit.rb</span><br></pre></td></tr></table></figure>
<p>一般我们系统中的目录，在git中会像下面这样存储</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/466.png"></p>
<p>创建的提交节点被存储为commit类型数据，commit文件的内容如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line">committer Scott Chacon &lt;<span class="symbol">schacon@</span>gmail.com&gt; <span class="number">1243040974</span> <span class="number">-0700</span></span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure>
<p>有三个提交的Git仓库可简化为下图所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/467.png"></p>
<h3 id="refs-1"><a href="#refs-1" class="headerlink" title="refs"></a>refs</h3><p>refs目录存储都是引用文件，如本地分支，远端分支，标签等</p>
<ul>
<li>refs/heads/xxx 本地分支</li>
<li>refs/remotes/origin/xxx 远端分支</li>
<li>refs/tags/xxx 本地tag</li>
</ul>
<p>引用文件的内容都是40位commit</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/470.png"></p>
<p>上面只有提交的图补上分支后，如下所示</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/468.png"></p>
<h3 id="HEAD-1"><a href="#HEAD-1" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD文件存储的是当前所在的位置，其内容可以使分支名字，40位commit ID</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ cat HEAD</span><br><span class="line"><span class="built_in">ref</span>s/heads/master</span><br></pre></td></tr></table></figure>
<p>上面的图补上HEAD后，如下所示：</p>
<p><img alt="img" data-src="https://yanhaijing.com/blog/469.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/git-school/visualizing-git" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/git-school/visualizing-git</a></li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external nofollow noopener noreferrer">https://marklodato.github.io/visual-git-guide/index-zh-cn.html</a></li>
<li><a href="https://www.cnblogs.com/qcloud1001/p/10006556.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/qcloud1001/p/10006556.html</a></li>
<li><a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1" target="_blank" rel="external nofollow noopener noreferrer">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1</a></li>
<li><a href="https://juejin.im/post/5c714d18f265da2d98090503" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.im/post/5c714d18f265da2d98090503</a></li>
<li><a href="https://yanhaijing.com/git/2017/02/08/deep-git-3/" target="_blank" rel="external nofollow noopener noreferrer">https://yanhaijing.com/git/2017/02/08/deep-git-3/</a></li>
<li><a href="http://walkerdu.com/2019/11/25/git_basic/" target="_blank" rel="external nofollow noopener noreferrer">http://walkerdu.com/2019/11/25/git_basic/</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>workflow</tag>
        <tag>visualized</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】List/Watch机制和Informer模块详解</title>
    <url>/posts/1f0eb2ff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。</p>
<a id="more"></a>
<h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>Kubernetes中的组件，如果要访问Kubernetes中的Object，绝大部分情况下会使用Informer中的Lister()方法，而非直接请求Kubernetes API。</p>
<h1 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h1><p><img alt="img" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png"></p>
<p><img alt="Client-go Controller Interaction" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p>
<h2 id="client-go组件"><a href="#client-go组件" class="headerlink" title="client-go组件"></a>client-go组件</h2><ul>
<li><code>Reflector</code>：reflector用来watch特定的k8s API资源。具体的实现是通过<code>ListAndWatch</code>的方法，watch可以是k8s内建的资源或者是自定义的资源。当reflector通过watch API接收到有关新资源实例存在的通知时，它使用相应的列表API获取新创建的对象，并将其放入watchHandler函数内的Delta Fifo队列中。</li>
<li><code>Informer</code>：informer从Delta Fifo队列中弹出对象。执行此操作的功能是processLoop。base controller的作用是保存对象以供以后检索，并调用我们的控制器将对象传递给它。</li>
<li><code>Indexer</code>：索引器提供对象的索引功能。典型的索引用例是基于对象标签创建索引。 Indexer可以根据多个索引函数维护索引。Indexer使用线程安全的数据存储来存储对象及其键。 在Store中定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数生成对象的键作为该对象的<code>&lt;namespace&gt; / &lt;name&gt;</code>组合。</li>
</ul>
<h2 id="自定义controller组件"><a href="#自定义controller组件" class="headerlink" title="自定义controller组件"></a>自定义controller组件</h2><ul>
<li><code>Informer reference</code>：指的是Informer实例的引用，定义如何使用自定义资源对象。 自定义控制器代码需要创建对应的Informer。</li>
<li><code>Indexer reference</code>: 自定义控制器对Indexer实例的引用。自定义控制器需要创建对应的Indexser。</li>
</ul>
<blockquote>
<p>client-go中提供<code>NewIndexerInformer</code>函数可以创建Informer 和 Indexer。</p>
</blockquote>
<ul>
<li><code>Resource Event Handlers</code>：资源事件回调函数，当它想要将对象传递给控制器时，它将被调用。 编写这些函数的典型模式是获取调度对象的key，并将该key排入工作队列以进行进一步处理。</li>
<li><code>Workqueue</code>：任务队列。 编写资源事件处理程序函数以提取传递的对象的key并将其添加到任务队列。</li>
<li><code>Process Item</code>：处理任务队列中对象的函数， 这些函数通常使用Indexer引用或Listing包装器来重试与该key对应的对象。</li>
</ul>
<h1 id="关键设计"><a href="#关键设计" class="headerlink" title="关键设计"></a>关键设计</h1><p>Informer依赖Kubernetes的List/Watch API。 通过Lister()对象来List/Get对象时，Informer不会去请求Kubernetes API，而是直接查询本地缓存，减少对Kubernetes API的直接调用。</p>
<p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p>
<p>Informer组件：</p>
<ul>
<li>Controller</li>
<li>Reflector：通过Kubernetes Watch API监听resource下的所有事件</li>
<li>Lister：用来被调用List/Get方法</li>
<li>Processor：记录并触发回调函数</li>
<li>DeltaFIFO</li>
<li>LocalStore</li>
</ul>
<p>DeltaFIFO和LocalStore是Informer的两级缓存。 DeltaFIFO：用来存储Watch API返回的各种事件。 LocalStore：Lister的List/Get方法访问。</p>
<p>我们以 Pod 为例，详细说明一下 Informer 的关键逻辑：</p>
<ol>
<li>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</li>
<li>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</li>
<li>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</li>
<li>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</li>
<li>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</li>
<li>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</li>
<li>DeltaFIFO 再 Pop 这个事件到 Controller 中</li>
<li>Controller 收到这个事件，会触发 Processor 的回调函数</li>
</ol>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737350162-8e7c6121-2b0a-49fa-8ad8-a7b714de3445.png"></p>
<p>之前说到kubernetes里面的apiserver的只负责数据的CRUD接口实现，并不负责业务逻辑的处理，所以k8s中就通过外挂controller通过对应资源的控制器来负责事件的处理，controller如何感知事件呢？答案就是informer</p>
<h2 id="基于chunk的消息通知"><a href="#基于chunk的消息通知" class="headerlink" title="基于chunk的消息通知"></a>基于chunk的消息通知</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737386982-feae09ae-ac6d-4090-8ca2-d2f3f5120d61.png"></p>
<p>watcher的设计在之前的文章中已经介绍，服务端是如何将watcher感知到的事件发送给informer呢？我们提到过apiserver本质上就是一个http的rest接口实现，watch机制则也是基于http协议，不过不同于一般的get其通过chunk机制，来实现消息的通知</p>
<h2 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737435884-518fce5a-0118-4935-be61-0716e2c3ba0c.png"></p>
<p>服务端通过chunk进行数据的发送，在客户端同样的需要根据对应的chunk来进行数据的解包，同时还要维护这个长链接</p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737496494-8a3052e1-7837-46d9-9513-8d3a64ffe8ba.png"></p>
<p>通过listwatch接口主要分为两部分，list接口我们可以获取到对应资源当前版本的全量资源，watch接口可以获取到后续变更的资源，通过全量加增量的数据，就构成了在client端一份完整的数据(基于当前版本的)，那后续如果要获取对应的数据，就直接可以通过本地的缓存来进行获取，为此informer抽象了cache这个组件，并且实现了store接口，如果后续要获取资源，则就可以通过本地的缓存来进行获取</p>
<h2 id="本地索引"><a href="#本地索引" class="headerlink" title="本地索引"></a>本地索引</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737549651-a3636652-fc91-49e1-a91e-9f5e18b05672.png"></p>
<p>上面将资源缓存在本地的内存中，那如果我们要进行数据查询，快速检索数据，这个时候就需要用到informer里面的indexer, 我们可以注册不同的索引函数，在添加对象的时候，会通过indexer为其建立对应的索引，这样后续我们就可以通过key来检索获取元数据</p>
<h2 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737669393-995cf89c-87f6-4749-9086-b9febee3a692.png"></p>
<p>为了协调数据生产与消费的不一致状态，在cleint-go中通过实现了一个无界队列来进行数据的缓冲，当reflector获取到数据之后，只需要将数据写入到无界队列中，则就可以继续watch后续事件，从而减少阻塞时间， 下面的事件去重也是在该队列中实现的</p>
<h2 id="事件去重"><a href="#事件去重" class="headerlink" title="事件去重"></a>事件去重</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737745807-e10d9521-5633-4cf7-9a0f-90ce2a3dee46.png"></p>
<p>事件去重是指的，在上面的无界队列中，如果针对某个资源的事件重复被触发，则就只会保留相同事件最后一个事件作为后续处理</p>
<p>到此对于事件接收和数据缓存相关优化就结束了，接下就是处理层的优化</p>
<h2 id="复用连接"><a href="#复用连接" class="headerlink" title="复用连接"></a>复用连接</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737835151-715cdc2b-b53a-4208-85d8-2383fdef8b8f.png"></p>
<p>在k8s中一些控制器可能会关注多种资源，比如Deployment可能会关注Pod和replicaset，replicaSet可能还会关注Pod，为了避免每个控制器都独立的去与apiserver建立链接，k8s中抽象了sharedInformer的概念，即共享的informer, 针对同一资源只建立一个链接</p>
<h2 id="基于观察者模式的注册"><a href="#基于观察者模式的注册" class="headerlink" title="基于观察者模式的注册"></a>基于观察者模式的注册</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738078512-ade28ada-2824-46d3-af63-45873a8a37a4.png"></p>
<p>因为彼此共用informer,但是每个组件的处理逻辑可能各部相同，在informer中通过观察者模式，各个组件可以注册一个EventHandler来实现业务逻辑的注入</p>
<h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738429252-bd646701-8543-47cd-a638-552ac419f5c9.png"></p>
<h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>该部分的代码主要位于<code>client-go</code>这个第三方包中。</p>
<p>此部分的逻辑主要位于<code>/vendor/k8s.io/client-go/tools/cache</code>包中，代码目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cache</span><br><span class="line">├── controller.go  <span class="comment"># 包含：Config、Run、processLoop、NewInformer、NewIndexerInformer</span></span><br><span class="line">├── delta_fifo.go  <span class="comment"># 包含：NewDeltaFIFO、DeltaFIFO、AddIfNotPresent</span></span><br><span class="line">├── expiration_cache.go</span><br><span class="line">├── expiration_cache_fakes.go</span><br><span class="line">├── fake_custom_store.go</span><br><span class="line">├── fifo.go   <span class="comment"># 包含：Queue、FIFO、NewFIFO</span></span><br><span class="line">├── heap.go</span><br><span class="line">├── index.go    <span class="comment"># 包含：Indexer、MetaNamespaceIndexFunc</span></span><br><span class="line">├── listers.go</span><br><span class="line">├── listwatch.go   <span class="comment"># 包含：ListerWatcher、ListWatch、List、Watch</span></span><br><span class="line">├── mutation_cache.go</span><br><span class="line">├── mutation_detector.go</span><br><span class="line">├── reflector.go   <span class="comment"># 包含：Reflector、NewReflector、Run、ListAndWatch</span></span><br><span class="line">├── reflector_metrics.go</span><br><span class="line">├── shared_informer.go  <span class="comment"># 包含：NewSharedInformer、WaitForCacheSync、Run、HasSynced</span></span><br><span class="line">├── store.go  <span class="comment"># 包含：Store、MetaNamespaceKeyFunc、SplitMetaNamespaceKey</span></span><br><span class="line">├── testing</span><br><span class="line">│   ├── fake_controller_source.go</span><br><span class="line">├── thread_safe_store.go  <span class="comment"># 包含：ThreadSafeStore、threadSafeMap</span></span><br><span class="line">├── undelta_store.go</span><br></pre></td></tr></table></figure>
<h2 id="sharedInformerFactory-Start"><a href="#sharedInformerFactory-Start" class="headerlink" title="sharedInformerFactory.Start"></a>sharedInformerFactory.Start</h2><p>在controller-manager的Run函数部分调用了InformerFactory.Start的方法。</p>
<blockquote>
<p>此部分代码位于/cmd/kube-controller-manager/app/controllermanager.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">        <span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InformerFactory是一个<code>SharedInformerFactory</code>的接口，接口定义如下：</p>
<blockquote>
<p>此部分代码位于vendor/k8s.io/client-go/informers/internalinterfaces/factory_interfaces.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SharedInformerFactory a small interface to allow for adding an informer without an import cycle</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    InformerFor(obj runtime.Object, newFunc NewInformerFunc) cache.SharedIndexInformer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。其中，通过<code>startdInformers</code>这个map用来追踪有哪些Informer已经启动，从而可以让Start方法被多次调用。</p>
<blockquote>
<p>此部分代码位于vendor/k8s.io/client-go/informers/factory.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">        <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">            <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">            f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sharedIndexInformer-Run"><a href="#sharedIndexInformer-Run" class="headerlink" title="sharedIndexInformer.Run"></a>sharedIndexInformer.Run</h2><blockquote>
<p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/shared_informer.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ListerWatcher:    s.listerWatcher,</span><br><span class="line">        ObjectType:       s.objectType,</span><br><span class="line">        FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">        RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">        Process: s.HandleDeltas,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">        s.controller = New(cfg)</span><br><span class="line">        s.controller.(*controller).clock = s.clock</span><br><span class="line">        s.started = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">    processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">        s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">    &#125;()</span><br><span class="line">    s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewDeltaFIFO"><a href="#NewDeltaFIFO" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><p>DeltaFIFO是一个对象变化的存储队列，依据先进先出的原则，process的函数接收该队列的Pop方法的输出对象来处理相关功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br></pre></td></tr></table></figure>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>构造controller的配置文件，构造process，即HandleDeltas，该函数为后面使用到的process函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>调用New(cfg)，构建sharedIndexInformer的controller。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">    s.controller = New(cfg)</span><br><span class="line">    s.controller.(*controller).clock = s.clock</span><br><span class="line">    s.started = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="cacheMutationDetector-Run"><a href="#cacheMutationDetector-Run" class="headerlink" title="cacheMutationDetector.Run"></a>cacheMutationDetector.Run</h3><p>调用s.cacheMutationDetector.Run，检查缓存对象是否变化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br></pre></td></tr></table></figure>
<p><strong>defaultCacheMutationDetector.Run</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we DON'T want protection from panics.  If we're running this code, we want to die</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d.CompareObjects()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(d.period):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CompareObjects</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">CompareObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> d.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    altered := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, obj := <span class="keyword">range</span> d.cachedObjs &#123;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(obj.cached, obj.copied) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"CACHE %s[%d] ALTERED!\n%v\n"</span>, d.name, i, diff.ObjectDiff(obj.cached, obj.copied))</span><br><span class="line">            altered = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> altered &#123;</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"cache %s modified"</span>, d.name)</span><br><span class="line">        <span class="keyword">if</span> d.failureFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">            d.failureFunc(msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processor-run"><a href="#processor-run" class="headerlink" title="processor.run"></a>processor.run</h3><p>调用s.processor.run，将调用sharedProcessor.run，会调用Listener.run和Listener.pop,执行处理queue的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.processor.run)</span><br></pre></td></tr></table></figure>
<p><strong>sharedProcessor.Run</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.listenersLock.RLock()</span><br><span class="line">        <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            p.wg.Start(listener.run)</span><br><span class="line">            p.wg.Start(listener.pop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">        <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该部分逻辑待后面分析。</p>
<h3 id="controller-Run"><a href="#controller-Run" class="headerlink" title="controller.Run"></a>controller.Run</h3><p>调用s.controller.Run，构建Reflector，进行对etcd的缓存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">    s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">&#125;()</span><br><span class="line">s.controller.Run(stopCh)</span><br></pre></td></tr></table></figure>
<p>controller.Run</p>
<blockquote>
<p>此部分代码位于/vendor/k8s.io/client-go/tools/cache/controller.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run begins processing items, and will continue until a value is sent down stopCh.</span></span><br><span class="line"><span class="comment">// It's an error to call Run more than once.</span></span><br><span class="line"><span class="comment">// Run blocks; call via go.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        c.config.Queue.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    r.ShouldResync = c.config.ShouldResync</span><br><span class="line">    r.clock = c.clock</span><br><span class="line"></span><br><span class="line">    c.reflectorMutex.Lock()</span><br><span class="line">    c.reflector = r</span><br><span class="line">    c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line"></span><br><span class="line">    wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建Reflector</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">    c.config.ListerWatcher,</span><br><span class="line">    c.config.ObjectType,</span><br><span class="line">    c.config.Queue,</span><br><span class="line">    c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 运行Reflector</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"><span class="comment">// 执行processLoop</span></span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br></pre></td></tr></table></figure>
<h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><h3 id="Reflector-1"><a href="#Reflector-1" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p>
<p>常用属性说明：</p>
<ul>
<li>expectedType：期望放入缓存store的资源类型。</li>
<li>store：watch的资源对应的本地缓存。</li>
<li>listerWatcher：list和watch的接口。</li>
<li>period：watch的周期，默认为1秒。</li>
<li>resyncPeriod：resync的周期，当非零的时候，会按该周期执行list。</li>
<li>lastSyncResourceVersion：最新一次看到的资源的版本号，主要在watch时候使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reflector watches a specified resource and causes all changes to be reflected in the given store.</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">    metrics *reflectorMetrics</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The type of object we expect to place in the store.</span></span><br><span class="line">    expectedType reflect.Type</span><br><span class="line">    <span class="comment">// The destination to sync up with the watch source</span></span><br><span class="line">    store Store</span><br><span class="line">    <span class="comment">// listerWatcher is used to perform lists and watches.</span></span><br><span class="line">    listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// period controls timing between one watch ending and</span></span><br><span class="line">    <span class="comment">// the beginning of the next one.</span></span><br><span class="line">    period       time.Duration</span><br><span class="line">    resyncPeriod time.Duration</span><br><span class="line">    ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// lastSyncResourceVersion is the resource version token last</span></span><br><span class="line">    <span class="comment">// observed when doing a sync with the underlying store</span></span><br><span class="line">    <span class="comment">// it is thread safe, but not synchronized with the underlying store</span></span><br><span class="line">    lastSyncResourceVersion <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">    lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewReflector"><a href="#NewReflector" class="headerlink" title="NewReflector"></a>NewReflector</h3><p>NewReflector主要用来构建Reflector的结构体。</p>
<blockquote>
<p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/reflector.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewReflector creates a new Reflector object which will keep the given store up to</span></span><br><span class="line"><span class="comment">// date with the server's contents for the given resource. Reflector promises to</span></span><br><span class="line"><span class="comment">// only put things in the store that have the type of expectedType, unless expectedType</span></span><br><span class="line"><span class="comment">// is nil. If resyncPeriod is non-zero, then lists will be executed after every</span></span><br><span class="line"><span class="comment">// resyncPeriod, so that you can use reflectors to periodically process everything as</span></span><br><span class="line"><span class="comment">// well as incrementally processing the things that change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflectorDisambiguator is used to disambiguate started reflectors.</span></span><br><span class="line"><span class="comment">// initialized to an unstable value to ensure meaning isn't attributed to the suffix.</span></span><br><span class="line"><span class="keyword">var</span> reflectorDisambiguator = <span class="keyword">int64</span>(time.Now().UnixNano() % <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reflector-Run"><a href="#Reflector-Run" class="headerlink" title="Reflector.Run"></a>Reflector.Run</h3><p>Reflector.Run主要执行了<code>ListAndWatch</code>的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span></span><br><span class="line"><span class="comment">// Run will exit when stopCh is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</span><br><span class="line">    wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            utilruntime.HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListAndWatch first lists all items and get the resource version at the moment of call,</span></span><br><span class="line"><span class="comment">// and then use the resource version to watch.</span></span><br><span class="line"><span class="comment">// It returns error if ListAndWatch didn't even try to initialize watch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line">    <span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line">    <span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line">    <span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line">    options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">    r.metrics.numberOfLists.Inc()</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    list, err := r.listerWatcher.List(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.listDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">    items, err := meta.ExtractList(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.numberOfItemsInList.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(items)))</span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将资源的版本号设置为0，然后调用<code>listerWatcher.List(options)</code>，列出所有list的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本号设置为0</span></span><br><span class="line">options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line"><span class="comment">// list接口</span></span><br><span class="line">list, err := r.listerWatcher.List(options)</span><br></pre></td></tr></table></figure>
<p>获取资源版本号，并将list的内容提取成对象列表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line">resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line"><span class="comment">// 将list的内容提取成对象列表</span></span><br><span class="line">items, err := meta.ExtractList(list)</span><br></pre></td></tr></table></figure>
<p>将list中对象列表的内容和版本号存储到本地的缓存store中，并全量替换已有的store的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := r.syncWith(items, resourceVersion)</span><br></pre></td></tr></table></figure>
<p>syncWith调用了store的Replace的方法来替换原来store中的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// syncWith replaces the store's items with the given list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        found = <span class="built_in">append</span>(found, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Store.Replace方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后设置最新的资源版本号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.setLastSyncResourceVersion(resourceVersion)</span><br></pre></td></tr></table></figure>
<p>setLastSyncResourceVersion:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">setLastSyncResourceVersion</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    r.lastSyncResourceVersionMutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.lastSyncResourceVersionMutex.Unlock()</span><br><span class="line">    r.lastSyncResourceVersion = v</span><br><span class="line"></span><br><span class="line">    rv, err := strconv.Atoi(v)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.metrics.lastResourceVersion.Set(<span class="keyword">float64</span>(rv))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="store-Resync"><a href="#store-Resync" class="headerlink" title="store.Resync"></a>store.Resync</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resyncCh, cleanup := r.resyncChan()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cleanup() <span class="comment">// Call the last one written into cleanup</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.ShouldResync == <span class="literal">nil</span> || r.ShouldResync() &#123;</span><br><span class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line">            <span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                resyncerrc &lt;- err</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanup()</span><br><span class="line">        resyncCh, cleanup = r.resyncChan()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := r.store.Resync()</span><br></pre></td></tr></table></figure>
<p>store的具体对象为<code>DeltaFIFO</code>，即调用DeltaFIFO.Resync</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Resync will send a sync event for each item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keys := f.knownObjects.ListKeys()</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">    options = metav1.ListOptions&#123;</span><br><span class="line">        ResourceVersion: resourceVersion,</span><br><span class="line">        <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">        <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">        TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.metrics.numberOfWatches.Inc()</span><br><span class="line">    w, err := r.listerWatcher.Watch(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">        <span class="keyword">case</span> io.EOF:</span><br><span class="line">            <span class="comment">// watch closed normally</span></span><br><span class="line">        <span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">            glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line">        <span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line">        <span class="comment">// watch where we ended.</span></span><br><span class="line">        <span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line">        <span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置watch的超时时间，默认为5分钟。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">options = metav1.ListOptions&#123;</span><br><span class="line">    ResourceVersion: resourceVersion,</span><br><span class="line">    <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">    <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">    TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行listerWatcher.Watch(options)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w, err := r.listerWatcher.Watch(options)</span><br></pre></td></tr></table></figure>
<p>执行watchHandler。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh)</span><br></pre></td></tr></table></figure>
<h4 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h4><p>watchHandler主要是通过watch的方式保证当前的资源版本是最新的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    eventCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stopping the watcher should be idempotent and if we return from this function there's no way</span></span><br><span class="line">    <span class="comment">// we're coming back in with the same watch interface.</span></span><br><span class="line">    <span class="keyword">defer</span> w.Stop()</span><br><span class="line">    <span class="comment">// update metrics</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r.metrics.numberOfItemsInWatch.Observe(<span class="keyword">float64</span>(eventCount))</span><br><span class="line">        r.metrics.watchDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span> errorStopRequested</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> event.Type == watch.Error &#123;</span><br><span class="line">                <span class="keyword">return</span> apierrs.FromObject(event.Object)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            meta, err := meta.Accessor(event.Object)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">            <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">            <span class="keyword">case</span> watch.Added:</span><br><span class="line">                err := r.store.Add(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Modified:</span><br><span class="line">                err := r.store.Update(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Deleted:</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">                <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">                <span class="comment">// to change this.</span></span><br><span class="line">                err := r.store.Delete(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">            &#125;</span><br><span class="line">            *resourceVersion = newResourceVersion</span><br><span class="line">            r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">            eventCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchDuration := r.clock.Now().Sub(start)</span><br><span class="line">    <span class="keyword">if</span> watchDuration &lt; <span class="number">1</span>*time.Second &amp;&amp; eventCount == <span class="number">0</span> &#123;</span><br><span class="line">        r.metrics.numberOfShortWatches.Inc()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received"</span>, r.name)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: Watch close - %v total %v items received"</span>, r.name, r.expectedType, eventCount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取watch接口中的事件的channel，来获取事件的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当获得添加、更新、删除的事件时，将对应的对象更新到本地缓存store中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line"><span class="keyword">case</span> watch.Added:</span><br><span class="line">    err := r.store.Add(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Modified:</span><br><span class="line">    err := r.store.Update(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Deleted:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">    <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">    <span class="comment">// to change this.</span></span><br><span class="line">    err := r.store.Delete(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新当前的最新版本号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">*resourceVersion = newResourceVersion</span><br><span class="line">r.setLastSyncResourceVersion(newResourceVersion)</span><br></pre></td></tr></table></figure>
<p>通过对Reflector模块的分析，可以看到多次使用到本地缓存store模块，而store的数据由DeltaFIFO赋值而来，以下针对DeltaFIFO和store做分析。</p>
<h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO由NewDeltaFIFO初始化，并赋值给config.Queue。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewDeltaFIFO-1"><a href="#NewDeltaFIFO-1" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewDeltaFIFO returns a Store which can be used process changes to items.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// keyFunc is used to figure out what key an object should have. (It's</span></span><br><span class="line"><span class="comment">// exposed in the returned DeltaFIFO's KeyOf() method, with bonus features.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'compressor' may compress as many or as few items as it wants</span></span><br><span class="line"><span class="comment">// (including returning an empty slice), but it should do what it</span></span><br><span class="line"><span class="comment">// does quickly since it is called while the queue is locked.</span></span><br><span class="line"><span class="comment">// 'compressor' may be nil if you don't want any delta compression.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'keyLister' is expected to return a list of keys that the consumer of</span></span><br><span class="line"><span class="comment">// this queue "knows about". It is used to decide which items are missing</span></span><br><span class="line"><span class="comment">// when Replace() is called; 'Deleted' deltas are produced for these items.</span></span><br><span class="line"><span class="comment">// It may be nil if you don't need to detect all deletions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider merging keyLister with this object, tracking a list of</span></span><br><span class="line"><span class="comment">//       "known" keys when Pop() is called. Have to think about how that</span></span><br><span class="line"><span class="comment">//       affects error retrying.</span></span><br><span class="line"><span class="comment">// TODO(lavalamp): I believe there is a possible race only when using an</span></span><br><span class="line"><span class="comment">//                 external known object source that the above TODO would</span></span><br><span class="line"><span class="comment">//                 fix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Also see the comment on DeltaFIFO. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeltaFIFO</span><span class="params">(keyFunc KeyFunc, compressor DeltaCompressor, knownObjects KeyListerGetter)</span> *<span class="title">DeltaFIFO</span></span> &#123;</span><br><span class="line">    f := &amp;DeltaFIFO&#123;</span><br><span class="line">        items:           <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas&#123;&#125;,</span><br><span class="line">        queue:           []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">        keyFunc:         keyFunc,</span><br><span class="line">        deltaCompressor: compressor,</span><br><span class="line">        knownObjects:    knownObjects,</span><br><span class="line">    &#125;</span><br><span class="line">    f.cond.L = &amp;f.lock</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller.Run的部分调用了NewReflector。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewReflector构造函数，将c.config.Queue赋值给Reflector.store的属性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DeltaFIFO-1"><a href="#DeltaFIFO-1" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p>
<p>DeltaFIFO主要用在以下场景：</p>
<ul>
<li>希望对象变更最多处理一次</li>
<li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li>
<li>要处理对象的删除</li>
<li>希望定期重新处理对象</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DeltaFIFO is like FIFO, but allows you to process deletes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO is a producer-consumer queue, where a Reflector is</span></span><br><span class="line"><span class="comment">// intended to be the producer, and the consumer is whatever calls</span></span><br><span class="line"><span class="comment">// the Pop() method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO solves this use case:</span></span><br><span class="line"><span class="comment">//  * You want to process every object change (delta) at most once.</span></span><br><span class="line"><span class="comment">//  * When you process an object, you want to see everything</span></span><br><span class="line"><span class="comment">//    that's happened to it since you last processed it.</span></span><br><span class="line"><span class="comment">//  * You want to process the deletion of objects.</span></span><br><span class="line"><span class="comment">//  * You might want to periodically reprocess objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO's Pop(), Get(), and GetByKey() methods return</span></span><br><span class="line"><span class="comment">// interface&#123;&#125; to satisfy the Store/Queue interfaces, but it</span></span><br><span class="line"><span class="comment">// will always return an object of type Deltas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on threading: If you call Pop() in parallel from multiple</span></span><br><span class="line"><span class="comment">// threads, you could end up with multiple threads processing slightly</span></span><br><span class="line"><span class="comment">// different versions of the same object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on the KeyLister used by the DeltaFIFO: It's main purpose is</span></span><br><span class="line"><span class="comment">// to list keys that are "known", for the purpose of figuring out which</span></span><br><span class="line"><span class="comment">// items have been deleted when Replace() or Delete() are called. The deleted</span></span><br><span class="line"><span class="comment">// object will be included in the DeleteFinalStateUnknown markers. These objects</span></span><br><span class="line"><span class="comment">// could be stale.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may provide a function to compress deltas (e.g., represent a</span></span><br><span class="line"><span class="comment">// series of Updates as a single Update).</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// lock/cond protects access to 'items' and 'queue'.</span></span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    cond sync.Cond</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We depend on the property that items in the set are in</span></span><br><span class="line">    <span class="comment">// the queue and vice versa, and that all Deltas in this</span></span><br><span class="line">    <span class="comment">// map have at least one Delta.</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></span><br><span class="line">    populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">    initialPopulationCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keyFunc is used to make the key used for queued item</span></span><br><span class="line">    <span class="comment">// insertion and retrieval, and should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deltaCompressor tells us how to combine two or more</span></span><br><span class="line">    <span class="comment">// deltas. It may be nil.</span></span><br><span class="line">    deltaCompressor DeltaCompressor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// knownObjects list keys that are "known", for the</span></span><br><span class="line">    <span class="comment">// purpose of figuring out which items have been deleted</span></span><br><span class="line">    <span class="comment">// when Replace() or Delete() is called.</span></span><br><span class="line">    knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indication the queue is closed.</span></span><br><span class="line">    <span class="comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span></span><br><span class="line">    <span class="comment">// Currently, not used to gate any of CRED operations.</span></span><br><span class="line">    closed     <span class="keyword">bool</span></span><br><span class="line">    closedLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queue-amp-Store"><a href="#Queue-amp-Store" class="headerlink" title="Queue &amp; Store"></a>Queue &amp; Store</h3><p>DeltaFIFO的类型是Queue接口，Reflector.store是Store接口，Queue接口是一个存储队列，Process的方法执行Queue.Pop出来的数据对象，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Queue is exactly like a Store, but has a Pop() method too.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">    Store</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pop blocks until it has something to process.</span></span><br><span class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></span><br><span class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></span><br><span class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></span><br><span class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></span><br><span class="line">    <span class="comment">// returned by Pop back into the queue as long</span></span><br><span class="line">    <span class="comment">// as nothing else (presumably more recent)</span></span><br><span class="line">    <span class="comment">// has since been added.</span></span><br><span class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></span><br><span class="line">    HasSynced() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close queue</span></span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p>
<p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store is a generic object storage interface. Reflector knows how to watch a server</span></span><br><span class="line"><span class="comment">// and update a store. A generic store is provided, which allows Reflector to be used</span></span><br><span class="line"><span class="comment">// as a local caching system, and an LRU store, which allows Reflector to work like a</span></span><br><span class="line"><span class="comment">// queue of items yet to be processed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Store makes no assumptions about stored object identity; it is the responsibility</span></span><br><span class="line"><span class="comment">// of a Store implementation to provide a mechanism to correctly key objects and to</span></span><br><span class="line"><span class="comment">// define the contract for obtaining objects by some arbitrary key type.</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">    GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Replace</code>方法会删除原来store中的内容，并将新增的list的内容存入store中，即完全替换数据。</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache实现了store的接口，而cache的具体实现又是调用<code>ThreadSafeStore</code>接口来实现功能的。</p>
<p>cache的功能主要有以下两点：</p>
<ul>
<li>通过keyFunc计算对象的key</li>
<li>调用ThreadSafeStorage接口的方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cache responsibilities are limited to:</span></span><br><span class="line"><span class="comment">//  1. Computing keys for objects via keyFunc</span></span><br><span class="line"><span class="comment">//  2. Invoking methods of a ThreadSafeStorage interface</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">    <span class="comment">// should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ListAndWatch主要用到以下的方法：</p>
<p><strong>cache.Replace</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replace will delete the contents of 'c', using instead the given list.</span></span><br><span class="line"><span class="comment">// 'c' takes ownership of the list, you should not reference the list again</span></span><br><span class="line"><span class="comment">// after calling this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Replace</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">        key, err := c.keyFunc(item)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[key] = item</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Replace(items, resourceVersion)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cache.Add</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add inserts an item into the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Add(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cache.Update</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update sets an item in the cache to its updated state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Update</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Update(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cache.Delete</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete removes an item from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Delete</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Delete(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p>cache的具体是调用<code>ThreadSafeStore</code>来实现的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadSafeStore is an interface that allows concurrent access to a storage backend.</span></span><br><span class="line"><span class="comment">// TL;DR caveats: you must not modify anything returned by Get or List as it will break</span></span><br><span class="line"><span class="comment">// the indexing feature in addition to not being thread safe.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The guarantees of thread safety provided by List/Get are only valid if the caller</span></span><br><span class="line"><span class="comment">// treats returned items as read-only. For example, a pointer inserted in the store</span></span><br><span class="line"><span class="comment">// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`</span></span><br><span class="line"><span class="comment">// on the same key and modify the pointer in a non-thread-safe way. Also note that</span></span><br><span class="line"><span class="comment">// modifying objects stored by the indexers (if any) will *not* automatically lead</span></span><br><span class="line"><span class="comment">// to a re-index. So it's not a good idea to directly modify the objects returned by</span></span><br><span class="line"><span class="comment">// Get/List, in general.</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Update(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">    Get(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Replace(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>)</span><br><span class="line">    Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">    ListIndexFuncValues(name <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>threadSafeMap</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  sync.RWMutex</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">    indexers Indexers</span><br><span class="line">    <span class="comment">// indices maps a name to an Index</span></span><br><span class="line">    indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop"></a>processLoop</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在controller.Run方法中会调用processLoop，以下分析<code>processLoop</code>的处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// processLoop drains the work queue.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span></span><br><span class="line"><span class="comment">// to make sure that we don't end up processing the same object multiple times</span></span><br><span class="line"><span class="comment">// concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span></span><br><span class="line"><span class="comment">// actually exit when the controller is stopped. Or just give up on this stuff</span></span><br><span class="line"><span class="comment">// ever being stoppable. Converting this whole package to use Context would</span></span><br><span class="line"><span class="comment">// also be helpful.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">                <span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">                c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processLoop主要处理任务队列中的任务，其中处理逻辑是调用具体的<code>ProcessFunc</code>函数来实现，核心代码为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br></pre></td></tr></table></figure>
<h3 id="DeltaFIFO-Pop"><a href="#DeltaFIFO-Pop" class="headerlink" title="DeltaFIFO.Pop"></a>DeltaFIFO.Pop</h3><p>Pop会阻塞住直到队列里面添加了新的对象，如果有多个对象，按照先进先出的原则处理，如果某个对象没有处理成功会重新被加入该队列中。</p>
<p>Pop中会调用具体的process函数来处理对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pop blocks until an item is added to the queue, and then returns it.  If</span></span><br><span class="line"><span class="comment">// multiple items are ready, they are returned in the order in which they were</span></span><br><span class="line"><span class="comment">// added/updated. The item is removed from the queue (and the store) before it</span></span><br><span class="line"><span class="comment">// is returned, so if you don't successfully process it, you need to add it back</span></span><br><span class="line"><span class="comment">// with AddIfNotPresent().</span></span><br><span class="line"><span class="comment">// process function is called under lock, so it is safe update data structures</span></span><br><span class="line"><span class="comment">// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc</span></span><br><span class="line"><span class="comment">// may return an instance of ErrRequeue with a nested error to indicate the current</span></span><br><span class="line"><span class="comment">// item should be requeued (equivalent to calling AddIfNotPresent under the lock).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Pop returns a 'Deltas', which has a complete list of all the things</span></span><br><span class="line"><span class="comment">// that happened to the object (deltas) while it was sitting in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">            <span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">            <span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">            <span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        id := f.queue[<span class="number">0</span>]</span><br><span class="line">        f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">        item, ok := f.items[id]</span><br><span class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            f.initialPopulationCount--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        err := process(item)</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">            f.addIfNotPresent(id, item)</span><br><span class="line">            err = e.Err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">        <span class="comment">// ownership to the caller.</span></span><br><span class="line">        <span class="keyword">return</span> item, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    item, ok := f.items[id]</span><br><span class="line">    ...</span><br><span class="line">    err := process(item)</span><br><span class="line">    <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">        f.addIfNotPresent(id, item)</span><br><span class="line">        err = e.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">    <span class="comment">// ownership to the caller.</span></span><br><span class="line">    <span class="keyword">return</span> item, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas"></a>HandleDeltas</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中process函数就是在sharedIndexInformer.Run方法中，给config.Process赋值的<code>HandleDeltas</code>函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.blockDeltas.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from oldest to newest</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">        <span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">            isSync := d.Type == Sync</span><br><span class="line">            s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">            <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Deleted:</span><br><span class="line">            <span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> d.Type &#123;</span><br><span class="line"><span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">    ...</span><br><span class="line">    s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的类型，调用<code>processor.distribute</code>方法，该方法将对象加入<code>processorListener</code>的channel中。</p>
<h3 id="sharedProcessor-distribute"><a href="#sharedProcessor-distribute" class="headerlink" title="sharedProcessor.distribute"></a>sharedProcessor.distribute</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sync &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processorListener.add:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综合以上的分析，可以看出processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。以下分析processorListener.Run的部分。</p>
<h2 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h2><p>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p>
<p>流程：</p>
<ol>
<li>listenser的add函数负责将notify装进pendingNotifications。</li>
<li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li>
<li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sharedProcessor-Run"><a href="#sharedProcessor-Run" class="headerlink" title="sharedProcessor.Run"></a>sharedProcessor.Run</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      p.listenersLock.RLock()</span><br><span class="line">      <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">      <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">         p.wg.Start(listener.run)</span><br><span class="line">         p.wg.Start(listener.pop)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   &lt;-stopCh</span><br><span class="line">   p.listenersLock.RLock()</span><br><span class="line">   <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">   <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">      <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="listener-pop"><a href="#listener-pop" class="headerlink" title="listener.pop"></a>listener.pop</h4><p>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextCh <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">            <span class="comment">// Notification dispatched</span></span><br><span class="line">            <span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">            notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">                nextCh = <span class="literal">nil</span> <span class="comment">// Disable this select case</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> notificationToAdd, ok := &lt;-p.addCh:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> notification == <span class="literal">nil</span> &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">                <span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">                notification = notificationToAdd</span><br><span class="line">                nextCh = p.nextCh</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">                p.pendingNotifications.WriteOne(notificationToAdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="listener-run"><a href="#listener-run" class="headerlink" title="listener.run"></a>listener.run</h4><p>listener.run部分根据不同的更新类型调用不同的处理函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">        <span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> updateNotification:</span><br><span class="line">            p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> addNotification:</span><br><span class="line">            p.handler.OnAdd(notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> deleteNotification:</span><br><span class="line">            p.handler.OnDelete(notification.oldObj)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中具体的实现函数handler是在NewDeploymentController（其他不同类型的controller类似）中赋值的，而该handler是一个接口，具体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ResourceEventHandler can handle notifications for events that happen to a</span></span><br><span class="line"><span class="comment">// resource. The events are informational only, so you can't return an</span></span><br><span class="line"><span class="comment">// error.</span></span><br><span class="line"><span class="comment">//  * OnAdd is called when an object is added.</span></span><br><span class="line"><span class="comment">//  * OnUpdate is called when an object is modified. Note that oldObj is the</span></span><br><span class="line"><span class="comment">//      last known state of the object-- it is possible that several changes</span></span><br><span class="line"><span class="comment">//      were combined together, so you can't use this to see every single</span></span><br><span class="line"><span class="comment">//      change. OnUpdate is also called when a re-list happens, and it will</span></span><br><span class="line"><span class="comment">//      get called even if nothing changed. This is useful for periodically</span></span><br><span class="line"><span class="comment">//      evaluating or syncing something.</span></span><br><span class="line"><span class="comment">//  * OnDelete will get the final state of the item if it is known, otherwise</span></span><br><span class="line"><span class="comment">//      it will get an object of type DeletedFinalStateUnknown. This can</span></span><br><span class="line"><span class="comment">//      happen if the watch is closed and misses the delete event and we don't</span></span><br><span class="line"><span class="comment">//      notice the deletion until the subsequent re-list.</span></span><br><span class="line"><span class="keyword">type</span> ResourceEventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnAdd(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnUpdate(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnDelete(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResourceEventHandler"><a href="#ResourceEventHandler" class="headerlink" title="ResourceEventHandler"></a>ResourceEventHandler</h3><p>以下以DeploymentController的处理逻辑为例。</p>
<p>在<code>NewDeploymentController</code>部分会注册deployment的事件函数，以下注册了三种类型的事件函数，其中包括：dInformer、rsInformer和podInformer。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewDeploymentController creates a new DeploymentController.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer extensionsinformers.DeploymentInformer, rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addDeployment,</span><br><span class="line">        UpdateFunc: dc.updateDeployment,</span><br><span class="line">        <span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">        DeleteFunc: dc.deleteDeployment,</span><br><span class="line">    &#125;)</span><br><span class="line">    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addReplicaSet,</span><br><span class="line">        UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">        DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">    &#125;)</span><br><span class="line">    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        DeleteFunc: dc.deletePod,</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addDeployment"><a href="#addDeployment" class="headerlink" title="addDeployment"></a>addDeployment</h4><p>以下以<code>addDeployment</code>为例，addDeployment主要是将对象加入到enqueueDeployment的队列中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">addDeployment</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    d := obj.(*extensions.Deployment)</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"Adding deployment %s"</span>, d.Name)</span><br><span class="line">    dc.enqueueDeployment(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueueDeployment的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enqueueDeployment <span class="function"><span class="keyword">func</span><span class="params">(deployment *extensions.Deployment)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将dc.enqueue赋值给dc.enqueueDeployment</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dc.enqueueDeployment = dc.enqueue</span><br></pre></td></tr></table></figure>
<p>dc.enqueue调用了dc.queue.Add(key)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">enqueue</span><span class="params">(deployment *extensions.Deployment)</span></span> &#123;</span><br><span class="line">    key, err := controller.KeyFunc(deployment)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %#v: %v"</span>, deployment, err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dc.queue主要记录了需要被同步的deployment的对象，供syncDeployment使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dc := &amp;DeploymentController&#123;</span><br><span class="line">    ...</span><br><span class="line">    queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NewNamedRateLimitingQueue</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedRateLimitingQueue</span><span class="params">(rateLimiter RateLimiter, name <span class="keyword">string</span>)</span> <span class="title">RateLimitingInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;rateLimitingType&#123;</span><br><span class="line">        DelayingInterface: NewNamedDelayingQueue(name),</span><br><span class="line">        rateLimiter:       rateLimiter,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上分析，可以看出processor记录了不同类似的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析的部分主要是k8s的<code>informer</code>机制，即<code>List-Watch</code>机制。</p>
<h3 id="Reflector-2"><a href="#Reflector-2" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p>
<h3 id="ListAndWatch-1"><a href="#ListAndWatch-1" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p><code>ListAndWatch</code>第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p>
<h3 id="DeltaFIFO-2"><a href="#DeltaFIFO-2" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p><code>DeltaFIFO</code>是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p>
<p>DeltaFIFO主要用在以下场景：</p>
<ul>
<li>希望对象变更最多处理一次</li>
<li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li>
<li>要处理对象的删除</li>
<li>希望定期重新处理对象</li>
</ul>
<h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p>
<p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p>
<h3 id="processor-1"><a href="#processor-1" class="headerlink" title="processor"></a>processor</h3><p><code>processor</code>的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p>
<p>流程：</p>
<ol>
<li>listenser的add函数负责将notify装进pendingNotifications。</li>
<li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li>
<li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li>
</ol>
<p><code>processor</code>记录了不同类似的事件函数，其中事件函数在<code>NewXxxController</code>构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似<code>syncDeployment</code>的同步函数来维持期望状态的同步逻辑。</p>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol>
<li>在controller-manager的Run函数部分调用了InformerFactory.Start的方法，Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。</li>
<li>informer.Run的部分先生成一个DeltaFIFO的队列来存储对象变化的数据。然后调用processor.Run和controller.Run函数。</li>
<li>controller.Run函数会生成一个Reflector，<code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</li>
<li>Reflector接着执行ListAndWatch函数，ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</li>
<li>controller.Run函数还会调用processLoop函数，processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。</li>
<li>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。processor记录了不同类型的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="Informer-二级缓存中的同步问题"><a href="#Informer-二级缓存中的同步问题" class="headerlink" title="Informer 二级缓存中的同步问题"></a>Informer 二级缓存中的同步问题</h2><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存 DeltaIFIFO 和 LocalStore 之间会存在 resync 机制，k8s 中 kube-controller-manager 的 StatefulSetController 中使用了两级缓存的 resync 机制（如下图所示），我们在生产环境中发现 sts 创建后过了很久 pod 才会创建，主要是由于 StatefulSetController 的两级缓存之间 30s 会同步一次，由于 StatefulSetController watch 到变化后就会把对应的 sts 放入 DeltaIFIFO 中，且每隔 30s 会把 LocalStore 中全部的 sts 重新入一遍 DeltaIFIFO，入队时会做一些处理，过滤掉一些不需要重复入队列的 sts，若间隔的 30s 内没有处理完队列中所有的 sts，则待处理队列中始终存在未处理完的 sts，并且在同步过程中产生的 sts 会加的队列的尾部，新加入队尾的 sts 只能等到前面的 sts 处理完成（也就是 resync 完成）才会被处理，所以导致的现象就是 sts 创建后过了很久 pod 才会创建。</p>
<p>优化的方法就是去掉二级缓存的同步策略（将 setInformer.Informer().AddEventHandlerWithResyncPeriod() 改为 informer.AddEventHandler()）或者调大同步周期，但是在研究 kube-controller-manager 其他 controller 时发现并不是所有的 controller 都有同步策略，社区也有相关的 issue 反馈了这一问题，Remove resync period for sset controller，社区也会在以后的版本中去掉两级缓存之间的 resync 策略。</p>
<p>k8s.io/kubernetes/pkg/controller/statefulset/stateful_set.go</p>
<p><img alt="Kubernetes 中 informer 的使用" data-src="https://static001.geekbang.org/wechat/images/a1/a1a5745f0c0309c9d05c484905887fb8.jpeg">kube-controller-manager sts controller</p>
<h2 id="使用-Informer-如何监听所有资源对象？"><a href="#使用-Informer-如何监听所有资源对象？" class="headerlink" title="使用 Informer 如何监听所有资源对象？"></a>使用 Informer 如何监听所有资源对象？</h2><p>一个 Informer 实例只能监听一种 resource，每个 resource 需要创建对应的 Informer 实例。</p>
<h2 id="为什么不是使用-workqueue？"><a href="#为什么不是使用-workqueue？" class="headerlink" title="为什么不是使用 workqueue？"></a>为什么不是使用 workqueue？</h2><p>建议使用 RateLimitingQueue，它相比普通的 workqueue 多了以下的功能:</p>
<ul>
<li><strong>限流：</strong>可以限制一个 item 被 reenqueued 的次数。</li>
<li><strong>防止 hot loop：</strong>它保证了一个 item 被 reenqueued 后，不会马上被处理。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://github.com/kubernetes/client-go/tree/master/tools/cache" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/tree/master/tools/cache</a></li>
<li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></li>
<li><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>informer</tag>
        <tag>watch</tag>
        <tag>消息机制</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>【Kubernetes】Scheduler</title>
    <url>/posts/d3e0e7a2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>调度器（Scheduler）是 Kubernetes 的核心组件，它的主要功能是为待运行的工作负载 Pod 绑定运行的节点 Node。从最早基于谓词和优先级（Predicates and Priorities）的调度器，到 V1.15基于调度框架（Scheduling Framework）的调度器，Kubernetes的调度器正在快速演进，以满足不同场景对于资源调度的需求。</p>
<p>本文是「Kubernetes解读」的第二篇，本篇将首先介绍Kubernetes Scheduler的背景和它的演进过程，然后会通过 Kubernetes 1.16 版本分析基于谓词与优先级的调度器原理。在「Kubernetes解读」的第三篇 <a href="../83a17de0/">Scheduling Framework</a> 中，我将通过 Kubernetes 1.18 版本分析基于Framwork的调度器原理。</p>
<a id="more"></a>
<h2 id="Scheduler-概述"><a href="#Scheduler-概述" class="headerlink" title="Scheduler 概述"></a>Scheduler 概述</h2><h3 id="关于任务资源调度"><a href="#关于任务资源调度" class="headerlink" title="关于任务资源调度"></a>关于任务资源调度</h3><blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computing" target="_blank" rel="external nofollow noopener noreferrer">computing</a>, <strong>scheduling</strong> is the method by which work is assigned to resources that complete the work.</p>
</blockquote>
<p>在计算机中，调度指的是为任务（Work）分配它所需要的资源（Resource），从而使得完成任务的方法。这里的任务可能是计算的线程，进程或者是数据流，与此同时，对应的资源可能是CPU、网络、内存或者是扩展卡等硬件资源。在计算机中，调度系统无处不在，不论是操作系统级别的调度器，还是编程语言级别的调度器，或者是CDN的资源调度，打车平台订单的调度等等。</p>
<p><strong>调度的核心就是对有限资源的合理分配，以达到我们期待实现的调度目标，本质上是解决资源的需求与供给不平衡的问题。</strong></p>
<p>一个调度系统可能会有多种调度目标，比如：</p>
<ul>
<li>最大化吞吐量</li>
<li>最小化等待时间</li>
<li>最小化延时或者响应时间</li>
<li>最大化公平</li>
</ul>
<p>在实践中，这些指标往往是互相矛盾的，因此调度器的设计往往是根据实际需求的权衡利弊的折中方案。在操作系统的进程调度器中，待调度的任务就是线程，而需要给任务分配的资源就是CPU时间。对于Kubernetes来说，它调度的基本单位是Pod，这些Pod会被调度到不同的Node上执行。不同的节点上资源类型不同，包括CPU、GPU和内存等资源。这些资源可以被拆分，但是都属于当前节点。</p>
<h3 id="任务资源调度设计的挑战"><a href="#任务资源调度设计的挑战" class="headerlink" title="任务资源调度设计的挑战"></a>任务资源调度设计的挑战</h3><ul>
<li>调度：任务最少等待时间与优先级</li>
<li>调度： 任务的本地性：尽可能将任务分配到包含任务执行资源的节点上</li>
<li>集群：高可用性</li>
<li>系统：可扩展性：系统如何如何应对业务需求的变化，提供的一种可扩展机制，在集群默认调度策略不满足业务需求时，通过扩展接口，来进行系统的扩展满足业务需求</li>
</ul>
<h3 id="Pod调度场景的挑战"><a href="#Pod调度场景的挑战" class="headerlink" title="Pod调度场景的挑战"></a>Pod调度场景的挑战</h3><h4 id="亲和性与反亲和性"><a href="#亲和性与反亲和性" class="headerlink" title="亲和性与反亲和性"></a>亲和性与反亲和性</h4><p>在kubernetes中的亲和性主要是指Pod和Node两种资源</p>
<ul>
<li>亲和性：<ul>
<li>Pod和Pod之间的亲和性</li>
<li>Pod和Node之间的亲和性</li>
</ul>
</li>
<li>反亲和性<ul>
<li>Pod和Pod之间的反亲和性</li>
<li>Pod和Node之间的反亲和性</li>
</ul>
</li>
</ul>
<p>举个例子：</p>
<ul>
<li>Pod之间的反亲和: 为了保证高可用我们通常会将同一业务的多个节点分散在不通的数据中心和机架</li>
<li>Pod与Node亲和性: 比如某些需要磁盘IO操作的Pod，我们可以调度到具有SSD的机器上，提高IO性能</li>
</ul>
<h4 id="多租户与容量规划"><a href="#多租户与容量规划" class="headerlink" title="多租户与容量规划"></a>多租户与容量规划</h4><p>多租户通常是为了进行集群资源的隔离，在业务系统中，通常会按照业务线来进行资源的隔离，同时会给业务设定对应的容量，从而避免单个业务线资源的过度使用影响整个公司的所有业务</p>
<h4 id="Zone和Node的选择"><a href="#Zone和Node的选择" class="headerlink" title="Zone和Node的选择"></a>Zone和Node的选择</h4><p>zone通常是在业务容灾中常见的概念，通过将服务分散在多个数据中心，避免因为单个数据中心故障导致业务完全不可用</p>
<p>因为之前亲和性的问题，如何在多个zone中的所有node中选择出一个合适的节点，则是一个比较大的挑战</p>
<h4 id="多样化资源的扩展"><a href="#多样化资源的扩展" class="headerlink" title="多样化资源的扩展"></a>多样化资源的扩展</h4><p>系统资源除了cpu、内存还包括网络、磁盘io、gpu等等，针对其余资源的分配调度，kubernetes还需要提供额外的扩展机制来进行调度扩展的支持</p>
<h4 id="资源混部"><a href="#资源混部" class="headerlink" title="资源混部"></a>资源混部</h4><p>kubernetes初期是针对pod调度场景而生，主要其实是在线web业务，这类任务的特点大部分都是无状态的，那如何针对离线场景的去支持离线的批处理计算等任务</p>
<h3 id="Kubernetes-Pod-LifeCycle"><a href="#Kubernetes-Pod-LifeCycle" class="headerlink" title="Kubernetes Pod LifeCycle"></a>Kubernetes Pod LifeCycle</h3><p>下图展示了一个Pod在Kubernetes集群中从创建到运行的过程：</p>
<ul>
<li>用户通过REST API 向ApiServer 创建 Deployment/DaemonSet/Job等任务</li>
<li>ApiServer收到用户请求后，存储相关数据到Etcd</li>
<li>Scheduler通过监听ApiServer，获取未调度的 Pod 列表</li>
<li>Scheduler通过调度算法算出分配给Pod的Node，并将Node信息和Pod进行绑定，结果存储在Etcd</li>
<li>Node上的Kubelet感知到调度结果，拉取镜像并运行Pod</li>
</ul>
<p><img alt="Kubernetes Pod LifeCycle" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-27_k8s-scheduler.png"></p>
<p>可以看到，Scheduler作为Kubernetes集群中核心模块，可以被视作一个黑盒：</p>
<ul>
<li>黑盒的输入为待调度的 Pod 和全部计算节点（Node）的信息</li>
<li>黑盒的输出为经过内部调度算法和策略处理算出的最优节点</li>
</ul>
<h3 id="Scheduler-基本职责"><a href="#Scheduler-基本职责" class="headerlink" title="Scheduler 基本职责"></a>Scheduler 基本职责</h3><p><code>kube-scheduler</code> 是作为单独的进程启动的，可以总结 <code>kube-scheduler</code> 的职责有以下这些：</p>
<ol>
<li><strong>Schduler高可用</strong>：基于Etcd实现分布式锁的竞争，实现高可用</li>
<li><strong>调度资源监听</strong>：基于List/Watch机制监听ApiServer上资源的变化，这里的资源主要指的是 Pod 和 Node ；</li>
<li><strong>调度节点分配</strong>：通过内部算法算出最优节点，并将结果写入Etcd</li>
</ol>
<h3 id="Scheduler-演进"><a href="#Scheduler-演进" class="headerlink" title="Scheduler 演进"></a>Scheduler 演进</h3><p>从Kubernetes v1.0发布开始，Scheduler就采用了基于谓词和优先级的算法进行调度，在完全切换到Scheduling Framework之前，分别在</p>
<ul>
<li>v1.2 引入了Scheduler Extender，支持外部扩展</li>
<li>v1.5 为调度器的优先级算法引入Map/Reduce的计算模式</li>
<li>v1.15 提出了基于Scheduling Framework的方式，实现Scheduler的轻量化、接口化与组件化</li>
<li>v1.18 将所有策略全部组件化，默认调度流程切换为Scheduling Framework</li>
<li>v1.19 将抢占过程也组件化，同时支持multi scheduling profile</li>
</ul>
<p><img alt="Scheduler Evolution Timeline" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-30_scheduler-timeline.png"></p>
<p>随着容器化技术普及，Kubernetes已经成为容器管理领域的事实标准，除了传统的互联网场景的应用，像AI、大数据、边缘计算等场景也开始迁移到 k8s 平台。与此同时，不同场景对于k8s调度器提出的要求也越来越高，k8s调度器正在快速演进中。</p>
<p>在本篇后续的分析中，将基于Kubernetes 1.16版本对其设计实现的原理和思路进行分析。</p>
<h2 id="Scheduler-初始化"><a href="#Scheduler-初始化" class="headerlink" title="Scheduler 初始化"></a>Scheduler 初始化</h2><h3 id="调度器结构体初识"><a href="#调度器结构体初识" class="headerlink" title="调度器结构体初识"></a>调度器结构体初识</h3><p>首先看一下调度器这个结构体的实现，其中比较关键的成员是 <code>SchedulerCache</code>、    <code>SchedulingQueue</code> 和 <code>Algorithm</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">  SchedulerCache internalcache.Cache</span><br><span class="line">  Algorithm core.ScheduleAlgorithm</span><br><span class="line">  GetBinder <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span> <span class="title">factory</span>.<span class="title">Binder</span></span></span><br><span class="line">  PodConditionUpdater factory.PodConditionUpdater</span><br><span class="line">  PodPreemptor factory.PodPreemptor</span><br><span class="line">  Framework framework.Framework</span><br><span class="line">  NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span></span><br><span class="line">  WaitForCacheSync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">  Error <span class="function"><span class="keyword">func</span><span class="params">(*v1.Pod, error)</span></span></span><br><span class="line">  Recorder events.EventRecorder</span><br><span class="line">  StopEverything &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  VolumeBinder *volumebinder.VolumeBinder</span><br><span class="line">  DisablePreemption <span class="keyword">bool</span></span><br><span class="line">  SchedulingQueue internalqueue.SchedulingQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了几个标准动作的函数</p>
<ul>
<li>NextPod()：当有下一个可用的Pod的时候，返回对应Pod，否则阻塞。</li>
<li>WaitForCache()：用于等待Cache同步。</li>
<li>Error()：当调度出现错误的时候，会调用Error函数，其参数是错误的Pod和错误。</li>
</ul>
<figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">	SchedulerCache:      c.schedulerCache,</span><br><span class="line">	Algorithm:           algo,</span><br><span class="line">	GetBinder:           getBinderFunc(c.client, extenders),</span><br><span class="line">	PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">	PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">	Framework:           c.framework,</span><br><span class="line">	WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">	&#125;,</span><br><span class="line">	NextPod:         internalqueue.MakeNextPodFunc(c.podQueue),</span><br><span class="line">	Error:           MakeDefaultErrorFunc(c.client, c.podQueue, c.schedulerCache, c.StopEverything),</span><br><span class="line">	StopEverything:  c.StopEverything,</span><br><span class="line">	VolumeBinder:    c.volumeBinder,</span><br><span class="line">	SchedulingQueue: c.podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>在创建 scheduler Config的时候，会依次对这几个函数定义</p>
<ul>
<li>NextPod()：调用SchedulingQueue的<code>MakeNextPodFunc</code>来获取下一个可调用Pod，本质上是调用Queue的Pop方法。</li>
<li>WaitForCache()：调用SchedulerCache的<code>WaitForCacheSync</code>来等待Cache同步</li>
<li>Error()：调用 <code>MakeDefaultErrorFunc</code>函数注入一个失败处理函数，主要讲失败的Pod放入到合适的队列重新再调度</li>
</ul>
<p>除了这几个主要函数外，还为<code>Scheduler</code>结构定义了几个动作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">schedule</span><span class="params">(pod *v1.Pod, pluginContext *framework.PluginContext)</span> <span class="params">(core.ScheduleResult, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">preempt</span><span class="params">(pluginContext *framework.PluginContext, fwk framework.Framework, preemptor *v1.Pod, scheduleErr error)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assumeVolumes</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="params">(allBound <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bindVolumes</span><span class="params">(assumed *v1.Pod)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(assumed *v1.Pod, targetNode <span class="keyword">string</span>, pluginContext *framework.PluginContext)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">recordSchedulingFailure</span><span class="params">(pod *v1.Pod, err error, reason <span class="keyword">string</span>, message <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>schedule()：输入是Pod，输出是调度结果，执行调度主要逻辑，通过 <code>genericScheduler</code>实现</li>
<li>preempt()：抢占调度，通过genericScheduler实现，并且更新 <code>Nominated</code></li>
<li>assumeVolumes()：根据选择的binding来更新Volume Cache</li>
<li>bindVolumes()：绑定PV</li>
<li>assume()：将Pod状态调整到Cache中，变为assumed</li>
<li>Bind()：执行绑定操作</li>
</ul>
<h3 id="调度器参数初始化"><a href="#调度器参数初始化" class="headerlink" title="调度器参数初始化"></a>调度器参数初始化</h3><p>我们在创建Scheduler结构体的时候会制定很多的参数：</p>
<figure class="highlight go"><figcaption><span>cmd/kube-scheduler/server.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the scheduler.</span></span><br><span class="line">sched, err := scheduler.New(cc.Client,</span><br><span class="line">	cc.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">	cc.PodInformer,</span><br><span class="line">	cc.InformerFactory.Core().V1().PersistentVolumes(),</span><br><span class="line">	cc.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">	cc.InformerFactory.Core().V1().ReplicationControllers(),</span><br><span class="line">	cc.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">	cc.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">	cc.InformerFactory.Core().V1().Services(),</span><br><span class="line">	cc.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span><br><span class="line">	cc.InformerFactory.Storage().V1().StorageClasses(),</span><br><span class="line">	cc.InformerFactory.Storage().V1beta1().CSINodes(),</span><br><span class="line">	cc.Recorder,</span><br><span class="line">	cc.ComponentConfig.AlgorithmSource,</span><br><span class="line">	stopCh,</span><br><span class="line">	registry,</span><br><span class="line">	cc.ComponentConfig.Plugins,</span><br><span class="line">	cc.ComponentConfig.PluginConfig,</span><br><span class="line">	scheduler.WithName(cc.ComponentConfig.SchedulerName),</span><br><span class="line">	scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),</span><br><span class="line">	scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),</span><br><span class="line">	scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">	scheduler.WithBindTimeoutSeconds(*cc.ComponentConfig.BindTimeoutSeconds))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>New</code>传递来自于cmd的参数，并且创建一个 <code>Configurator</code></p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// New returns a Scheduler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(client clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	replicationControllerInformer coreinformers.ReplicationControllerInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	replicaSetInformer appsinformers.ReplicaSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	statefulSetInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	pdbInformer policyinformers.PodDisruptionBudgetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	storageClassInformer storageinformersv1.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	csiNodeInformer storageinformersv1beta1.CSINodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	recorder events.EventRecorder,</span></span></span><br><span class="line"><span class="function"><span class="params">	schedulerAlgorithmSource kubeschedulerconfig.SchedulerAlgorithmSource,</span></span></span><br><span class="line"><span class="function"><span class="params">	stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	registry framework.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	plugins *kubeschedulerconfig.Plugins,</span></span></span><br><span class="line"><span class="function"><span class="params">	pluginConfig []kubeschedulerconfig.PluginConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">         opts ...<span class="keyword">func</span>(o *schedulerOptions)</span>) <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// Set up the configurator which can create schedulers from configs.</span></span><br><span class="line">	configurator := factory.NewConfigFactory(&amp;factory.ConfigFactoryArgs&#123;</span><br><span class="line">		Client:                         client,</span><br><span class="line">		NodeInformer:                   nodeInformer,</span><br><span class="line">		PodInformer:                    podInformer,</span><br><span class="line">		PvInformer:                     pvInformer,</span><br><span class="line">		PvcInformer:                    pvcInformer,</span><br><span class="line">		ReplicationControllerInformer:  replicationControllerInformer,</span><br><span class="line">		ReplicaSetInformer:             replicaSetInformer,</span><br><span class="line">		StatefulSetInformer:            statefulSetInformer,</span><br><span class="line">		ServiceInformer:                serviceInformer,</span><br><span class="line">		PdbInformer:                    pdbInformer,</span><br><span class="line">		StorageClassInformer:           storageClassInformer,</span><br><span class="line">		CSINodeInformer:                csiNodeInformer,</span><br><span class="line">		HardPodAffinitySymmetricWeight: options.hardPodAffinitySymmetricWeight,</span><br><span class="line">		DisablePreemption:              options.disablePreemption,</span><br><span class="line">		PercentageOfNodesToScore:       options.percentageOfNodesToScore,</span><br><span class="line">		BindTimeoutSeconds:             options.bindTimeoutSeconds,</span><br><span class="line">		Registry:                       registry,</span><br><span class="line">		Plugins:                        plugins,</span><br><span class="line">		PluginConfig:                   pluginConfig,</span><br><span class="line">	&#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> config *factory.Config</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据不同的schedulerAlgorithmSource创建不同的config</span></span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">    config = configurator.CreateFromProvider(*source.Provider)</span><br><span class="line">	<span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">    config = configurator.CreateFromConfig(*policy)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Create the scheduler.</span></span><br><span class="line">	sched := NewFromConfig(config)</span><br><span class="line">  </span><br><span class="line">  AddAllEventHandlers(sched, options.schedulerName, nodeInformer, podInformer, pvInformer, pvcInformer, serviceInformer, storageClassInformer, csiNodeInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigFactoryArgs是哪里来的？来自于命令行参数解析出来的。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConfigFactoryArgs is a set arguments passed to NewConfigFactory.</span></span><br><span class="line"><span class="keyword">type</span> ConfigFactoryArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	Client                         clientset.Interface</span><br><span class="line">	NodeInformer                   coreinformers.NodeInformer</span><br><span class="line">	PodInformer                    coreinformers.PodInformer</span><br><span class="line">	PvInformer                     coreinformers.PersistentVolumeInformer</span><br><span class="line">	PvcInformer                    coreinformers.PersistentVolumeClaimInformer</span><br><span class="line">	ReplicationControllerInformer  coreinformers.ReplicationControllerInformer</span><br><span class="line">	ReplicaSetInformer             appsinformers.ReplicaSetInformer</span><br><span class="line">	StatefulSetInformer            appsinformers.StatefulSetInformer</span><br><span class="line">	ServiceInformer                coreinformers.ServiceInformer</span><br><span class="line">	PdbInformer                    policyinformers.PodDisruptionBudgetInformer</span><br><span class="line">	StorageClassInformer           storageinformersv1.StorageClassInformer</span><br><span class="line">	CSINodeInformer                storageinformersv1beta1.CSINodeInformer</span><br><span class="line">	HardPodAffinitySymmetricWeight <span class="keyword">int32</span></span><br><span class="line">	DisablePreemption              <span class="keyword">bool</span></span><br><span class="line">	PercentageOfNodesToScore       <span class="keyword">int32</span></span><br><span class="line">	BindTimeoutSeconds             <span class="keyword">int64</span></span><br><span class="line">	StopCh                         &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	Registry                       framework.Registry</span><br><span class="line">	Plugins                        *config.Plugins</span><br><span class="line">	PluginConfig                   []config.PluginConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 ConfigFactoryArgs 构建 Configurator对象，在这个 <code>NewConfigFactory</code>函数里</p>
<ul>
<li>创建新的framework对象</li>
<li>创建新的SchedulingQueue：podQueue</li>
<li>创建新的SchedulerCache对象</li>
<li>创建新的VolumeBinder</li>
<li>…</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewConfigFactory initializes the default implementation of a Configurator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfigFactory</span><span class="params">(args *ConfigFactoryArgs)</span> *<span class="title">Configurator</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当收到StopEverything的信号时，关闭podQueue。</p>
<p><code>CreateFromConfig</code> 用于注册Predicate函数、注册Prioritize函数、生成Extender列表</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateFromConfig creates a scheduler from the configuration file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">CreateFromConfig</span><span class="params">(policy schedulerapi.Policy)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler from configuration: %v"</span>, policy)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate the policy configuration</span></span><br><span class="line">	<span class="keyword">if</span> err := validation.ValidatePolicy(policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	predicateKeys := sets.NewString()</span><br><span class="line">	<span class="keyword">if</span> policy.Predicates == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"Using predicates from algorithm provider '%v'"</span>, DefaultProvider)</span><br><span class="line">		provider, err := GetAlgorithmProvider(DefaultProvider)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		predicateKeys = provider.FitPredicateKeys</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, predicate := <span class="keyword">range</span> policy.Predicates &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering predicate: %s"</span>, predicate.Name)</span><br><span class="line">			predicateKeys.Insert(RegisterCustomFitPredicate(predicate))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priorityKeys := sets.NewString()</span><br><span class="line">	<span class="keyword">if</span> policy.Priorities == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"Using priorities from algorithm provider '%v'"</span>, DefaultProvider)</span><br><span class="line">		provider, err := GetAlgorithmProvider(DefaultProvider)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		priorityKeys = provider.PriorityFunctionKeys</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, priority := <span class="keyword">range</span> policy.Priorities &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering priority: %s"</span>, priority.Name)</span><br><span class="line">			priorityKeys.Insert(RegisterCustomPriorityFunction(priority))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> extenders []algorithm.SchedulerExtender</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(policy.ExtenderConfigs) != <span class="number">0</span> &#123;</span><br><span class="line">		ignoredExtendedResources := sets.NewString()</span><br><span class="line">		<span class="keyword">var</span> ignorableExtenders []algorithm.SchedulerExtender</span><br><span class="line">		<span class="keyword">for</span> ii := <span class="keyword">range</span> policy.ExtenderConfigs &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating extender with config %+v"</span>, policy.ExtenderConfigs[ii])</span><br><span class="line">			extender, err := core.NewHTTPExtender(&amp;policy.ExtenderConfigs[ii])</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !extender.IsIgnorable() &#123;</span><br><span class="line">				extenders = <span class="built_in">append</span>(extenders, extender)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ignorableExtenders = <span class="built_in">append</span>(ignorableExtenders, extender)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, r := <span class="keyword">range</span> policy.ExtenderConfigs[ii].ManagedResources &#123;</span><br><span class="line">				<span class="keyword">if</span> r.IgnoredByScheduler &#123;</span><br><span class="line">					ignoredExtendedResources.Insert(<span class="keyword">string</span>(r.Name))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// place ignorable extenders to the tail of extenders</span></span><br><span class="line">		extenders = <span class="built_in">append</span>(extenders, ignorableExtenders...)</span><br><span class="line">		predicates.RegisterPredicateMetadataProducerWithExtendedResourceOptions(ignoredExtendedResources)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Providing HardPodAffinitySymmetricWeight in the policy config is the new and preferred way of providing the value.</span></span><br><span class="line">	<span class="comment">// Give it higher precedence than scheduler CLI configuration when it is provided.</span></span><br><span class="line">	<span class="keyword">if</span> policy.HardPodAffinitySymmetricWeight != <span class="number">0</span> &#123;</span><br><span class="line">		c.hardPodAffinitySymmetricWeight = policy.HardPodAffinitySymmetricWeight</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// When AlwaysCheckAllPredicates is set to true, scheduler checks all the configured</span></span><br><span class="line">	<span class="comment">// predicates even after one or more of them fails.</span></span><br><span class="line">	<span class="keyword">if</span> policy.AlwaysCheckAllPredicates &#123;</span><br><span class="line">		c.alwaysCheckAllPredicates = policy.AlwaysCheckAllPredicates</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.CreateFromKeys(predicateKeys, priorityKeys, extenders)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CreateFromKeys</code> 基于刚才生成的<code>predicateKeys, priorityKeys, extenders</code> 得到PredicateFunc、PriorityFuncs，同时创建NewGenericScheduler，最后返回Config结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateFromKeys creates a scheduler from a set of registered fit predicate keys and priority keys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">CreateFromKeys</span><span class="params">(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler with fit predicates '%v' and priority functions '%v'"</span>, predicateKeys, priorityKeys)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.GetHardPodAffinitySymmetricWeight() &lt; <span class="number">1</span> || c.GetHardPodAffinitySymmetricWeight() &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid hardPodAffinitySymmetricWeight: %d, must be in the range 1-100"</span>, c.GetHardPodAffinitySymmetricWeight())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	predicateFuncs, err := c.GetPredicates(predicateKeys)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priorityConfigs, err := c.getPriorityFunctionConfigs(priorityKeys)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priorityMetaProducer, err := c.getPriorityMetadataProducer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	predicateMetaProducer, err := c.GetPredicateMetadataProducer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	algo := core.NewGenericScheduler(</span><br><span class="line">		c.schedulerCache,</span><br><span class="line">		c.podQueue,</span><br><span class="line">		predicateFuncs,</span><br><span class="line">		predicateMetaProducer,</span><br><span class="line">		priorityConfigs,</span><br><span class="line">		priorityMetaProducer,</span><br><span class="line">		c.framework,</span><br><span class="line">		extenders,</span><br><span class="line">		c.volumeBinder,</span><br><span class="line">		c.pVCLister,</span><br><span class="line">		c.pdbLister,</span><br><span class="line">		c.alwaysCheckAllPredicates,</span><br><span class="line">		c.disablePreemption,</span><br><span class="line">		c.percentageOfNodesToScore,</span><br><span class="line">		c.enableNonPreempting,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">		SchedulerCache:      c.schedulerCache,</span><br><span class="line">		Algorithm:           algo,</span><br><span class="line">		GetBinder:           getBinderFunc(c.client, extenders),</span><br><span class="line">		PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">		PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">		Framework:           c.framework,</span><br><span class="line">		WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">		&#125;,</span><br><span class="line">		NextPod:         internalqueue.MakeNextPodFunc(c.podQueue),</span><br><span class="line">		Error:           MakeDefaultErrorFunc(c.client, c.podQueue, c.schedulerCache, c.StopEverything),</span><br><span class="line">		StopEverything:  c.StopEverything,</span><br><span class="line">		VolumeBinder:    c.volumeBinder,</span><br><span class="line">		SchedulingQueue: c.podQueue,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件Informer回调handler绑定"><a href="#事件Informer回调handler绑定" class="headerlink" title="事件Informer回调handler绑定"></a>事件Informer回调handler绑定</h3><p>在 <code>pkg/scheduler/eventhandler.go</code>中，会将 informer 监听到的资源变更事件与对应的 handler绑定，绑定事件回调主要是通过AddAllEventHandlers主要是将各种资源数据通过SchedulerCache放入本地缓存中，同时针对未调度的pod(!assignedPod即没有绑定Node的pod)加入到调度队列中。主要的事件包括</p>
<ul>
<li>Scheduled Pod Cache<ul>
<li>增加：addPodToCache</li>
<li>更新：updatePodInCache</li>
<li>删除：deletePodFromCache</li>
</ul>
</li>
<li>Unscheduled Pod Queue<ul>
<li>增加：addPodToSchedulingQueue</li>
<li>更新：updatePodInSchedulingQueue</li>
<li>删除：deletePodFromSchedulingQueue</li>
</ul>
</li>
<li>Node资源变更：<ul>
<li>增加：addNodeToCache</li>
<li>更新：updateNodeInCache</li>
<li>删除：deleteNodeInCache</li>
</ul>
</li>
<li>PV资源变更<ul>
<li>增加：onPvAdd</li>
<li>更新：onPvUpdate</li>
</ul>
</li>
<li>PVC资源变更<ul>
<li>增加：onPvcAdd</li>
<li>更新：onPvcUpdate</li>
</ul>
</li>
<li>Service资源变更：这个主要是会影响 <code>ServiceAffinity</code><ul>
<li>增加：onServiceAdd</li>
<li>更新：onServiceUpdate</li>
<li>删除：onServiceDelete</li>
</ul>
</li>
<li>StorageClass资源变更<ul>
<li>增加：onStorageClassAdd</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AddAllEventHandlers is a helper function used in tests and in Scheduler</span></span><br><span class="line"><span class="comment">// to add event handlers for various informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">	schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	storageClassInformer storageinformersv1.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	csiNodeInformer storageinformersv1beta1.CSINodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当集群资源发生变动时，比如service、volume等就会对unschedulableQ中的之前调度失败的pod进行重试，选择将其转移到activeQ或者backoffQ中，这时候会调用<code>MoveAllToActiveQueue</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// There is a chance of errors when adding pods to other queues,</span></span><br><span class="line">	<span class="comment">// we make a temporary slice to store the pods,</span></span><br><span class="line">	<span class="comment">// since the probability is low, we set its len to 0</span></span><br><span class="line">	addErrorPods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">		pod := pInfo.Pod</span><br><span class="line">		<span class="keyword">if</span> p.isPodBackingOff(pod) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">				addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Error adding pod %v to the scheduling queue: %v"</span>, pod.Name, err)</span><br><span class="line">				addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.unschedulableQ.clear()</span><br><span class="line">	<span class="comment">// Adding pods that we could not move to Active queue or Backoff queue back to the Unschedulable queue</span></span><br><span class="line">	<span class="keyword">for</span> _, podInfo := <span class="keyword">range</span> addErrorPods &#123;</span><br><span class="line">		p.unschedulableQ.addOrUpdate(podInfo)</span><br><span class="line">	&#125;</span><br><span class="line">	p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">	p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h3><p>那么整个Scheduler是如何跑起来的呢？它的入口是Run函数，一直运行<code>scheduleOne</code>函数，进入一个 <code>control loop</code>，直到收到了StopEverything的信号。</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !sched.WaitForCacheSync() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.StopEverything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SchedulingQueue-三级调度队列"><a href="#SchedulingQueue-三级调度队列" class="headerlink" title="SchedulingQueue 三级调度队列"></a>SchedulingQueue 三级调度队列</h2><p><code>SchedulingQueue</code> 是一个Interface，它提供了以下的方法实现对于Pod的入队出队操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SchedulingQueue <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(pod *v1.Pod) error</span><br><span class="line">	AddIfNotPresent(pod *v1.Pod) error</span><br><span class="line">	AddUnschedulableIfNotPresent(pod *v1.Pod, podSchedulingCycle <span class="keyword">int64</span>) error</span><br><span class="line">	SchedulingCycle() <span class="keyword">int64</span></span><br><span class="line">	Pop() (*v1.Pod, error)</span><br><span class="line">	Update(oldPod, newPod *v1.Pod) error</span><br><span class="line">	Delete(pod *v1.Pod) error</span><br><span class="line">	MoveAllToActiveQueue()</span><br><span class="line">	AssignedPodAdded(pod *v1.Pod)</span><br><span class="line">	AssignedPodUpdated(pod *v1.Pod)</span><br><span class="line">	NominatedPodsForNode(nodeName <span class="keyword">string</span>) []*v1.Pod</span><br><span class="line">	PendingPods() []*v1.Pod</span><br><span class="line">	Close()</span><br><span class="line">	UpdateNominatedPodForNode(pod *v1.Pod, nodeName <span class="keyword">string</span>)</span><br><span class="line">	DeleteNominatedPodIfExists(pod *v1.Pod)</span><br><span class="line">	NumUnschedulablePods() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是通过 <code>PriorityQueue</code> 来实现这个queue的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	stop  &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	clock util.Clock</span><br><span class="line">	podBackoff *PodBackoffMap</span><br><span class="line"></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">	cond sync.Cond</span><br><span class="line"></span><br><span class="line">  activeQ *util.Heap</span><br><span class="line">	podBackoffQ *util.Heap</span><br><span class="line">	unschedulableQ *UnschedulablePodsMap</span><br><span class="line">	nominatedPods *nominatedPodMap</span><br><span class="line">	schedulingCycle <span class="keyword">int64</span></span><br><span class="line">	moveRequestCycle <span class="keyword">int64</span></span><br><span class="line">	closed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的优先级队列是一个三级调度队列，其主要包括：</p>
<ul>
<li>活动队列 activeQ：activeQ中存储当前系统中所有正在等待调度的Pod</li>
<li>不可调度队列 unschedulableQ：当Pod的资源在当前集群中不能被满足时，则会被加入到一个不可调度队列中，然后等待稍后再进行尝试</li>
<li>backoffQ 队列：backoff机制是并发编程中常见的一种机制，即如果任务反复执行依旧失败，则会按次增长等待调度时间，降低重试效率，从而避免反复失败浪费调度资源。针对调度失败的pod会优先存储在backoff队列中，等待后续重试。</li>
</ul>
<p>对于 <code>backoffQ</code> 和 <code>unschedulableQ</code>队列，我们需要定期从其中拿出Pod，放入到activeQ队列。</p>
<ul>
<li>每隔1秒执行 <code>flushBackoffQCompleted</code>，去找到backoffQ中等待到期的Pod，将其放入到activeQ中</li>
<li>每隔30秒执行 <code>flushUnschedulableQLeftover</code>，如果当前时间-pod的最后调度时间大于60s,就重新调度，转移到podBackoffQ或者activeQ中</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(p.flushBackoffQCompleted, <span class="number">1.0</span>*time.Second, p.stop)</span><br><span class="line">    <span class="keyword">go</span> wait.Until(p.flushUnschedulableQLeftover, <span class="number">30</span>*time.Second, p.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img alt="三级调度队列" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1578882056126-49b2a324-86dd-455e-b97b-bb9ba54fff5c.png"></p>
<h3 id="ActiveQ-队列"><a href="#ActiveQ-队列" class="headerlink" title="ActiveQ 队列"></a>ActiveQ 队列</h3><h4 id="当集群有新的Pod的时候"><a href="#当集群有新的Pod的时候" class="headerlink" title="当集群有新的Pod的时候"></a>当集群有新的Pod的时候</h4><p>什么时候会有新的Pod呢？也就是集群资源发生变更的时候：要么是创建了新的Pod，要么增加了PV，改变了Node等资源，导致原来不可调度的Pod可以调度了，这个时候会调用<code>SchedulingQueue.MoveAllToActiveQueue</code>（参见pkg/scheduler/eventhandler.go）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// There is a chance of errors when adding pods to other queues,</span></span><br><span class="line">	<span class="comment">// we make a temporary slice to store the pods,</span></span><br><span class="line">	<span class="comment">// since the probability is low, we set its len to 0</span></span><br><span class="line">	addErrorPods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">		pod := pInfo.Pod</span><br><span class="line">		<span class="keyword">if</span> p.isPodBackingOff(pod) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">				addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"Error adding pod %v to the scheduling queue: %v"</span>, pod.Name, err)</span><br><span class="line">				addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.unschedulableQ.clear()</span><br><span class="line">	<span class="comment">// Adding pods that we could not move to Active queue or Backoff queue back to the Unschedulable queue</span></span><br><span class="line">	<span class="keyword">for</span> _, podInfo := <span class="keyword">range</span> addErrorPods &#123;</span><br><span class="line">		p.unschedulableQ.addOrUpdate(podInfo)</span><br><span class="line">	&#125;</span><br><span class="line">	p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">	p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，会更新<code>moveRequestCycle</code>参数。</p>
<p>ActiveQ加入操作干了啥呢？</p>
<ul>
<li>会将Pod将入到activeQ，并且从backoffQ和 unschedulableQ中移除当前Pod</li>
<li>同时广播通知阻塞在Pop操作的scheduler获取新的Pod</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">Add</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">    pInfo := p.newPodInfo(pod)</span><br><span class="line">    <span class="comment">// 加入activeQ</span></span><br><span class="line">    <span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error adding pod %v/%v to the scheduling queue: %v"</span>, pod.Namespace, pod.Name, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从unschedulableQ删除</span></span><br><span class="line">    <span class="keyword">if</span> p.unschedulableQ.get(pod) != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error: pod %v/%v is already in the unschedulable queue."</span>, pod.Namespace, pod.Name)</span><br><span class="line">        p.unschedulableQ.<span class="built_in">delete</span>(pod)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete pod from backoffQ if it is backing off</span></span><br><span class="line">    <span class="comment">// 从podBackoffQ删除</span></span><br><span class="line">    <span class="keyword">if</span> err := p.podBackoffQ.Delete(pInfo); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error: pod %v/%v is already in the podBackoff queue."</span>, pod.Namespace, pod.Name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储pod和被提名的node</span></span><br><span class="line">    p.nominatedPods.add(pod, <span class="string">""</span>)</span><br><span class="line">    p.cond.Broadcast()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当Pod调度失败时"><a href="#当Pod调度失败时" class="headerlink" title="当Pod调度失败时"></a>当Pod调度失败时</h4><p>当调度失败的时候，scheduler会同时调用<code>scheduler&#39;s.Error</code>来调度之前失败的Pod</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">recordSchedulingFailure</span><span class="params">(pod *v1.Pod, err error, reason <span class="keyword">string</span>, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 错误回调</span></span><br><span class="line">    sched.Error(pod, err)</span><br><span class="line">    sched.Recorder.Eventf(pod, <span class="literal">nil</span>, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Scheduling"</span>, message)</span><br><span class="line">    <span class="keyword">if</span> err := sched.PodConditionUpdater.Update(pod, &amp;v1.PodCondition&#123;</span><br><span class="line">        Type:    v1.PodScheduled,</span><br><span class="line">        Status:  v1.ConditionFalse,</span><br><span class="line">        Reason:  reason,</span><br><span class="line">        Message: err.Error(),</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error updating the condition of the pod %s/%s: %v"</span>, pod.Namespace, pod.Name, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个错误处理函数到底干了啥呢？</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, err error)</span></span> &#123;</span><br><span class="line">    podSchedulingCycle := podQueue.SchedulingCycle()</span><br><span class="line">    <span class="comment">// 省略非核心代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//重新放回队列</span></span><br><span class="line">        <span class="keyword">if</span> err := podQueue.AddUnschedulableIfNotPresent(pod, podSchedulingCycle); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Pod调度失败，一种选择是放入到 <code>backoffQ</code>中，另一种选择是放入到 <code>unschedulableQ</code> 中，到底如何选择呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">AddUnschedulableIfNotPresent</span><span class="params">(pod *v1.Pod, podSchedulingCycle <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Every unschedulable pod is subject to backoff timers.</span></span><br><span class="line">	p.backoffPod(pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a move request has been received, move it to the BackoffQ, otherwise move</span></span><br><span class="line">	<span class="comment">// it to unschedulableQ.</span></span><br><span class="line">	<span class="keyword">if</span> p.moveRequestCycle &gt;= podSchedulingCycle &#123;</span><br><span class="line">		<span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p.unschedulableQ.addOrUpdate(pInfo)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.nominatedPods.add(pod, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，当一个Pod不能够被调度的时候，它会被放到 unschedulableQ 中，但是如果收到了一个<code>Move Request</code>，那么就将这个Pod移到BackoffQ。这是因为最近集群资源发生了变更，如果放到 BackoffQ，会更快的进行尝试这个Pod，更快地使它得到调度。</p>
<h3 id="BackoffQ-队列"><a href="#BackoffQ-队列" class="headerlink" title="BackoffQ 队列"></a>BackoffQ 队列</h3><p>BackoffQ是一个堆，每次获取堆顶的元素，查看是否到期，如果到期则将其Pop出来，加入到activeQ中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">flushBackoffQCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 获取堆顶元素</span></span><br><span class="line">        rawPodInfo := p.podBackoffQ.Peek()</span><br><span class="line">        <span class="keyword">if</span> rawPodInfo == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pod := rawPodInfo.(*framework.PodInfo).Pod</span><br><span class="line">        <span class="comment">// 获取到期时间</span></span><br><span class="line">        boTime, found := p.podBackoff.GetBackoffTime(nsNameForPod(pod))</span><br><span class="line">        <span class="keyword">if</span> !found &#123;</span><br><span class="line">            <span class="comment">// 如果当前已经不在podBackoff中，则就pop出来然后放入到activeQ</span></span><br><span class="line">            klog.Errorf(<span class="string">"Unable to find backoff value for pod %v in backoffQ"</span>, nsNameForPod(pod))</span><br><span class="line">            p.podBackoffQ.Pop()</span><br><span class="line">            p.activeQ.Add(rawPodInfo)</span><br><span class="line">            <span class="keyword">defer</span> p.cond.Broadcast()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未超时</span></span><br><span class="line">        <span class="keyword">if</span> boTime.After(p.clock.Now()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超时就pop出来</span></span><br><span class="line">        _, err := p.podBackoffQ.Pop()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(<span class="string">"Unable to pop pod %v from backoffQ despite backoff completion."</span>, nsNameForPod(pod))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入到activeQ中</span></span><br><span class="line">        p.activeQ.Add(rawPodInfo)</span><br><span class="line">        <span class="keyword">defer</span> p.cond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UnschedulableQ-队列"><a href="#UnschedulableQ-队列" class="headerlink" title="UnschedulableQ 队列"></a>UnschedulableQ 队列</h3><p>如果当前时间-pod的最后调度时间大于60s，就重新调度，转移到podBackoffQ或者activeQ中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">flushUnschedulableQLeftover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> podsToMove []*framework.PodInfo</span><br><span class="line">    currentTime := p.clock.Now()</span><br><span class="line">    <span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">        lastScheduleTime := pInfo.Timestamp</span><br><span class="line">        <span class="comment">// 如果该pod1分钟内没有被调度就加入到podsToMove</span></span><br><span class="line">        <span class="keyword">if</span> currentTime.Sub(lastScheduleTime) &gt; unschedulableQTimeInterval &#123;</span><br><span class="line">            podsToMove = <span class="built_in">append</span>(podsToMove, pInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(podsToMove) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// podsToMove将这些pod移动到activeQ</span></span><br><span class="line">        p.movePodsToActiveQueue(podsToMove)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NominatedPodMap"><a href="#NominatedPodMap" class="headerlink" title="NominatedPodMap"></a>NominatedPodMap</h3><p>优先级队列有一个<code>nominatedPods</code>用来保存那些被提议运行在特定Nodes上的Pods，其数据结构为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nominatedPodMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// nominatedPods is a map keyed by a node name and the value is a list of</span></span><br><span class="line">	<span class="comment">// pods which are nominated to run on the node. These are pods which can be in</span></span><br><span class="line">	<span class="comment">// the activeQ or unschedulableQ.</span></span><br><span class="line">	nominatedPods <span class="keyword">map</span>[<span class="keyword">string</span>][]*v1.Pod</span><br><span class="line">	<span class="comment">// nominatedPodToNode is map keyed by a Pod UID to the node name where it is</span></span><br><span class="line">	<span class="comment">// nominated.</span></span><br><span class="line">	nominatedPodToNode <span class="keyword">map</span>[ktypes.UID]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NextPod"><a href="#NextPod" class="headerlink" title="NextPod()"></a>NextPod()</h3><p>获取下一个Pod的方法，本质上是一个出队操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MakeNextPodFunc returns a function to retrieve the next pod from a given</span></span><br><span class="line"><span class="comment">// scheduling queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">		pod, err := queue.Pop()</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">			<span class="keyword">return</span> pod</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Errorf(<span class="string">"Error while retrieving next pod from scheduling queue: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="Scheduler-Cache"><a href="#Scheduler-Cache" class="headerlink" title="Scheduler Cache"></a>Scheduler Cache</h2><p>为什么需要 Scheduler Cache ? 这里的Cache主要用来收集Pod和Node级别的信息，便于Generic Scheduler在调度时高效的查询。</p>
<blockquote>
<p>Cache collects pods’ information and provides node-level aggregated information.</p>
<p>It’s intended for <strong>generic scheduler</strong> to do efficient lookup.</p>
</blockquote>
<p>下面是 <code>schedulerCache</code>结构体的详细定义，关于每个字段的具体含义，将在后面具体阐述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> schedulerCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	stop   &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	ttl    time.Duration</span><br><span class="line">	period time.Duration</span><br><span class="line"></span><br><span class="line">	mu sync.RWMutex</span><br><span class="line">	assumedPods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">	podStates <span class="keyword">map</span>[<span class="keyword">string</span>]*podState</span><br><span class="line">	nodes     <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeInfoListItem</span><br><span class="line">	csiNodes  <span class="keyword">map</span>[<span class="keyword">string</span>]*storagev1beta1.CSINode</span><br><span class="line">	headNode *nodeInfoListItem</span><br><span class="line">	nodeTree *NodeTree</span><br><span class="line">	imageStates <span class="keyword">map</span>[<span class="keyword">string</span>]*imageState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pod-状态"><a href="#Pod-状态" class="headerlink" title="Pod 状态"></a>Pod 状态</h3><p>Cache的操作都是以Pod为中心的，对于每次Pod Events，Cache会做递增式update，下面是Cache的状态机。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> State Machine of a pod's events in scheduler's cache</span><br><span class="line"><span class="string">//</span>   +<span class="params">-------------------------------------------</span>+  +<span class="params">----</span>+</span><br><span class="line"><span class="string">//</span>   |                            Add            |  |    |</span><br><span class="line"><span class="string">//</span>   |                                           |  |    | Update</span><br><span class="line"><span class="string">//</span>   +      Assume                Add            v  v    |</span><br><span class="line"><span class="string">//Initial</span> +<span class="params">--------</span>&gt; Assumed +<span class="params">------------</span>+<span class="params">---</span>&gt; Added &lt;--+</span><br><span class="line"><span class="string">//</span>   ^                +   +               |       +</span><br><span class="line"><span class="string">//</span>   |                |   |               |       |</span><br><span class="line"><span class="string">//</span>   |                |   |           Add |       | Remove</span><br><span class="line"><span class="string">//</span>   |                |   |               |       |</span><br><span class="line"><span class="string">//</span>   |                |   |               +       |</span><br><span class="line"><span class="string">//</span>   +<span class="params">----------------</span>+   +<span class="params">-----------</span>&gt; Expired   +<span class="params">----</span>&gt; Deleted</span><br><span class="line"><span class="string">//</span>         Forget             Expire</span><br></pre></td></tr></table></figure>
<p>这里有几个Event需要解释</p>
<ul>
<li>Assume：assumes a pod scheduled and aggregates the pod’s information into its node</li>
<li>Forget：removes an assumed pod from cache</li>
<li>Expire：After expiration, its information would be subtracted</li>
<li>Add：either confirms a pod if it’s assumed, or adds it back if it’s expired</li>
<li>Update：removes oldPod’s information and adds newPod’s information</li>
<li>Remove：removes a pod. The pod’s information would be subtracted from assigned node.</li>
</ul>
<p>与此同时还对应有Pod的几种状态，其中 <code>Initial</code>、<code>Expired</code>、<code>Deleted</code>这三种状态的Pod在Cache中实际上是不存在的，这里只是为了状态机的表示方便。关于这几个状态的改变，有一个具体的实现结构体，主要是通过 <code>podState</code> 和 <code>assumedPods</code> 这两个map的状态来实现的。</p>
<p><img alt="Scheduler Pod Cache State Machine" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-13_k8s-scheduler-cache.jpg"></p>
<p>在Cache的调度过程中，我们有以下几个假设</p>
<ul>
<li>Pod是不会被Assume两次的</li>
<li>一个Pod可能会直接被Add而不经过scheduler，这种情况下，我们只会看见Add Event而不会看见Assume Event</li>
<li>如果一个Pod没有被Add过，那么他不会被Remove或者Update</li>
<li><code>Expired</code>和<code>Deleted</code>都是有效的最终状态。</li>
</ul>
<h3 id="Node-状态"><a href="#Node-状态" class="headerlink" title="Node 状态"></a>Node 状态</h3><p>在Cache中，Node通过双向链表的形式保存信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeInfoListItem <span class="keyword">struct</span> &#123;</span><br><span class="line">	info *schedulernodeinfo.NodeInfo</span><br><span class="line">	next *nodeInfoListItem</span><br><span class="line">	prev *nodeInfoListItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>NodeInfo</code>保存的信息如下所示，包含了和Node相关的一系列信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	node *v1.Node</span><br><span class="line"></span><br><span class="line">	pods             []*v1.Pod</span><br><span class="line">	podsWithAffinity []*v1.Pod</span><br><span class="line">	usedPorts        HostPortInfo</span><br><span class="line"></span><br><span class="line">	requestedResource *Resource</span><br><span class="line">	nonzeroRequest *Resource</span><br><span class="line">	allocatableResource *Resource</span><br><span class="line"></span><br><span class="line">	taints    []v1.Taint</span><br><span class="line">	taintsErr error</span><br><span class="line"></span><br><span class="line">	imageStates <span class="keyword">map</span>[<span class="keyword">string</span>]*ImageStateSummary</span><br><span class="line"></span><br><span class="line">	TransientInfo *TransientSchedulerInfo</span><br><span class="line"></span><br><span class="line">	memoryPressureCondition v1.ConditionStatus</span><br><span class="line">	diskPressureCondition   v1.ConditionStatus</span><br><span class="line">	pidPressureCondition    v1.ConditionStatus</span><br><span class="line"></span><br><span class="line">	generation <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的 <code>schedulerCache</code> 中通过 <code>nodes</code> 这个 map 和 <code>headNode</code>这个指针可以很快的访问Node相关信息。</p>
<h4 id="NodeInfo-的更新"><a href="#NodeInfo-的更新" class="headerlink" title="NodeInfo 的更新"></a>NodeInfo 的更新</h4><p>当收到informer通知，知道集群Node信息发生改变时，会更新Cache中的Node信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nodeInformer.Informer().AddEventHandler(</span><br><span class="line">	cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    sched.addNodeToCache,</span><br><span class="line">		UpdateFunc: sched.updateNodeInCache,</span><br><span class="line">		DeleteFunc: sched.deleteNodeFromCache,</span><br><span class="line">	&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里的<code>add</code>、<code>update</code>、<code>delete</code>会分别调用Cache的 <code>AddNode</code>、<code>UpdateNode</code>和 <code>RemoveNode</code>等函数。以 <code>AddNode</code>为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">AddNode</span><span class="params">(node *v1.Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cache.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	n, ok := cache.nodes[node.Name]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		n = newNodeInfoListItem(schedulernodeinfo.NewNodeInfo())</span><br><span class="line">		cache.nodes[node.Name] = n</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cache.removeNodeImageStates(n.info.Node())</span><br><span class="line">	&#125;</span><br><span class="line">	cache.moveNodeInfoToHead(node.Name)</span><br><span class="line"></span><br><span class="line">	cache.nodeTree.AddNode(node)</span><br><span class="line">	cache.addNodeImageStates(node, n.info)</span><br><span class="line">	<span class="keyword">return</span> n.info.SetNode(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据需要可以创建新的 NodeInfo 结构体，并且插入到双向链表中。</li>
<li>每次更新Cache中的Node信息时，会将该Node移动到链表头。</li>
<li>同时会更新 <code>NodeTree</code> 和 <code>NodeImageStates</code>中的信息。</li>
</ul>
<h4 id="NodeTree-实现节点打散"><a href="#NodeTree-实现节点打散" class="headerlink" title="NodeTree 实现节点打散"></a>NodeTree 实现节点打散</h4><p>在Cache中还有一个<code>NodeTree</code>的指针用一个树形结构体保存Node的相关信息，目的是用于节点打散。节点打散主要是指的调度器调度的时候，在满足调度需求的情况下，为了保证pod均匀分配到所有的node节点上，通常会按照逐个zone逐个node节点进行分配，从而让pod节点打散在整个集群中。</p>
<p><code>NodeTree</code>的结构如下所示，NodeTree的tree是一个字典，key是zone的名字，value是一个nodeArray，通过这样可以把不同zone的Node分隔开。nodeArray负责存储一个zone下面的所有node节点，并且通过lastIndex记录当前zone分配的节点索引。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	tree      <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeArray <span class="comment">// a map from zone (region-zone) to an array of nodes in the zone.</span></span><br><span class="line">	zones     []<span class="keyword">string</span>              <span class="comment">// a list of all the zones in the tree (keys)</span></span><br><span class="line">	zoneIndex <span class="keyword">int</span></span><br><span class="line">	numNodes  <span class="keyword">int</span></span><br><span class="line">	mu        sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeArray <span class="keyword">struct</span> &#123;</span><br><span class="line">	nodes     []<span class="keyword">string</span></span><br><span class="line">	lastIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以把整个集群的Node看成二维数组，分别是<code>zoneIndex</code>和<code>nodeIndex</code></p>
<p><img alt="Scheduler Cache State Machine" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-13_node-tree.png"></p>
<p>每一次在 <code>findNodesThatFit</code> 函数中，通过调用 <code>nodeName := g.cache.NodeTree().Next()</code> 来获得下一个检查的Node，其具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nt *NodeTree)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	nt.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> nt.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nt.zones) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	numExhaustedZones := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> nt.zoneIndex &gt;= <span class="built_in">len</span>(nt.zones) &#123;</span><br><span class="line">			nt.zoneIndex = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		zone := nt.zones[nt.zoneIndex]</span><br><span class="line">		nt.zoneIndex++</span><br><span class="line">		<span class="comment">// We do not check the exhausted zones before calling next() on the zone. This ensures</span></span><br><span class="line">		<span class="comment">// that if more nodes are added to a zone after it is exhausted, we iterate over the new nodes.</span></span><br><span class="line">		nodeName, exhausted := nt.tree[zone].next()</span><br><span class="line">		<span class="keyword">if</span> exhausted &#123;</span><br><span class="line">			numExhaustedZones++</span><br><span class="line">			<span class="keyword">if</span> numExhaustedZones &gt;= <span class="built_in">len</span>(nt.zones) &#123; <span class="comment">// all zones are exhausted. we should reset.</span></span><br><span class="line">				nt.resetExhausted()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nodeName</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次先从当前 <code>zoneIndex</code> 获取新的zone，然后更新 <code>zoneIndex</code>。在对应zone的 <code>NodeArray</code>中，调用其 <code>next</code> 方法，获得对应的Node，同时更新 <code>nodeIndex</code>。</p>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>当scheduler获取一个待调度的pod，则需要从Cache中获取当前集群中的快照数据(当前此时集群中node的统计信息)，用于后续调度流程中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">	NodeInfoMap <span class="keyword">map</span>[<span class="keyword">string</span>]*NodeInfo</span><br><span class="line">	Generation  <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Snapshot的创建与更新"><a href="#Snapshot的创建与更新" class="headerlink" title="Snapshot的创建与更新"></a>Snapshot的创建与更新</h4><p>创建主要位于kubernetes/pkg/scheduler/core/generic_scheduler.go，实际上就是创建一个空的snapshot对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nodeInfoSnapshot:         framework.NodeInfoSnapshot(),</span><br></pre></td></tr></table></figure>
<p>数据的更新则是通过snapshot方法来调用Cache的更新接口来进行更新</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">snapshot</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Used for all fit and priority funcs.</span></span><br><span class="line">    <span class="keyword">return</span> g.cache.UpdateNodeInfoSnapshot(g.nodeInfoSnapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="借助headNode实现增量标记"><a href="#借助headNode实现增量标记" class="headerlink" title="借助headNode实现增量标记"></a>借助headNode实现增量标记</h4><p>随着集群中node和pod的数量的增加，如果每次都全量获取snapshot则会严重影响调度器的调度效率，在Cache中通过一个双向链表和node的递增计数(etcd实现)来实现增量更新。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">UpdateNodeInfoSnapshot</span><span class="params">(nodeSnapshot *schedulernodeinfo.Snapshot)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cache.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line">    balancedVolumesEnabled := utilfeature.DefaultFeatureGate.Enabled(features.BalanceAttachedNodeVolumes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前snapshot的Genration</span></span><br><span class="line">    snapshotGeneration := nodeSnapshot.Generation</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表，更新snapshot信息</span></span><br><span class="line">    <span class="keyword">for</span> node := cache.headNode; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">        <span class="keyword">if</span> node.info.GetGeneration() &lt;= snapshotGeneration &#123;</span><br><span class="line">            <span class="comment">//所有node信息都更新完毕</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> balancedVolumesEnabled &amp;&amp; node.info.TransientInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Transient scheduler info is reset here.</span></span><br><span class="line">            node.info.TransientInfo.ResetTransientSchedulerInfo()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> np := node.info.Node(); np != <span class="literal">nil</span> &#123;</span><br><span class="line">            nodeSnapshot.NodeInfoMap[np.Name] = node.info.Clone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新snapshot的genration</span></span><br><span class="line">    <span class="keyword">if</span> cache.headNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        nodeSnapshot.Generation = cache.headNode.info.GetGeneration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果snapshot里面包含过期的pod信息则进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodeSnapshot.NodeInfoMap) &gt; <span class="built_in">len</span>(cache.nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> name := <span class="keyword">range</span> nodeSnapshot.NodeInfoMap &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := cache.nodes[name]; !ok &#123;</span><br><span class="line">                <span class="built_in">delete</span>(nodeSnapshot.NodeInfoMap, name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据过期清理"><a href="#数据过期清理" class="headerlink" title="数据过期清理"></a>数据过期清理</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>Cache要定时将之前在经过本地scheduler分配完成后的假设的pod的信息进行清理，如果这些pod在给定时间内仍然没有感知到对应的pod真正的添加事件则就这些pod删除。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">assumedPods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h4 id="后台定时任务"><a href="#后台定时任务" class="headerlink" title="后台定时任务"></a>后台定时任务</h4><p>默认每1s进行清理一次，设定的 <code>ttl</code> 默认是30s。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(cache.cleanupExpiredAssumedPods, cache.period, cache.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理逻辑"><a href="#清理逻辑" class="headerlink" title="清理逻辑"></a>清理逻辑</h4><p>清理逻辑主要是针对那些已经完成绑定的pod来进行，如果一个pod完成了在scheduler里面的所有操作后，会有一个过期时间，当前是30s，如果超过该时间即deadline小于当前的时间就删除该pod。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cleanupAssumedPods exists for making test deterministic by taking time as input argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">cleanupAssumedPods</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line">    cache.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The size of assumedPods should be small</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> cache.assumedPods &#123;</span><br><span class="line">        ps, ok := cache.podStates[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"Key found in assumed set but not in podStates. Potentially a logical error."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未完成绑定的pod不会被进行清理</span></span><br><span class="line">        <span class="keyword">if</span> !ps.bindingFinished &#123;</span><br><span class="line">            klog.V(<span class="number">3</span>).Infof(<span class="string">"Couldn't expire cache for pod %v/%v. Binding is still in progress."</span>,</span><br><span class="line">                ps.pod.Namespace, ps.pod.Name)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在完成bind之后会设定一个过期时间，目前是30s,如果deadline即bind时间+30s小于当前时间就过期删除</span></span><br><span class="line">        <span class="keyword">if</span> now.After(*ps.deadline) &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Pod %s/%s expired"</span>, ps.pod.Namespace, ps.pod.Name)</span><br><span class="line">            <span class="keyword">if</span> err := cache.expirePod(key, ps); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                klog.Errorf(<span class="string">"ExpirePod failed for %s: %v"</span>, key, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理pod"><a href="#清理pod" class="headerlink" title="清理pod"></a>清理pod</h4><p>清理pod主要分为如下几个部分： </p>
<ol>
<li>对应pod假定分配node的信息 </li>
<li>清理映射的podState信息</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">expirePod</span><span class="params">(key <span class="keyword">string</span>, ps *podState)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := cache.removePod(ps.pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(cache.assumedPods, key)</span><br><span class="line">    <span class="built_in">delete</span>(cache.podStates, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Predicate-预选"><a href="#Predicate-预选" class="headerlink" title="Predicate 预选"></a>Predicate 预选</h2><p>调度器的目的就是将调度队列中的Pod合理地分配到具有匹配资源的Node上，在<code>Scheduling Framework</code>之前其算法步骤就是预选与优选。预选就是从当前集群中所有节点中，选择满足当前Pod资源和亲和性等要求Node节点，起的是过滤的作用。预选需要考虑的问题是，当集群中Node节点众多时，如何快速高效的过滤出这样的节点。</p>
<h3 id="Predicate-算法注册"><a href="#Predicate-算法注册" class="headerlink" title="Predicate 算法注册"></a>Predicate 算法注册</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Register functions that extract metadata used by predicates computations.</span></span><br><span class="line">	factory.RegisterPredicateMetadataProducerFactory(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">PredicateMetadataProducer</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewPredicateMetadataFactory(args.PodLister)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IMPORTANT NOTES for predicate developers:</span></span><br><span class="line">	<span class="comment">// Registers predicates and priorities that are not enabled by default, but user can pick when creating their</span></span><br><span class="line">	<span class="comment">// own set of priorities/predicates.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PodFitsPorts has been replaced by PodFitsHostPorts for better user understanding.</span></span><br><span class="line">	<span class="comment">// For backwards compatibility with 1.0, PodFitsPorts is registered as well.</span></span><br><span class="line">	factory.RegisterFitPredicate(<span class="string">"PodFitsPorts"</span>, predicates.PodFitsHostPorts)</span><br><span class="line">	<span class="comment">// Fit is defined based on the absence of port conflicts.</span></span><br><span class="line">	<span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line">	<span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.PodFitsHostPortsPred, predicates.PodFitsHostPorts)</span><br><span class="line">	<span class="comment">// Fit is determined by resource availability.</span></span><br><span class="line">	<span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line">	<span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.PodFitsResourcesPred, predicates.PodFitsResources)</span><br><span class="line">	<span class="comment">// Fit is determined by the presence of the Host parameter and a string match</span></span><br><span class="line">	<span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line">	<span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.HostNamePred, predicates.PodFitsHost)</span><br><span class="line">	<span class="comment">// Fit is determined by node selector query.</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.MatchNodeSelectorPred, predicates.PodMatchNodeSelector)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by volume zone requirements.</span></span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.NoVolumeZoneConflictPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewVolumeZonePredicate(args.PVInfo, args.PVCInfo, args.StorageClassInfo)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Fit is determined by whether or not there would be too many AWS EBS volumes attached to the node</span></span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.MaxEBSVolumeCountPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.EBSVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Fit is determined by whether or not there would be too many GCE PD volumes attached to the node</span></span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.MaxGCEPDVolumeCountPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.GCEPDVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Fit is determined by whether or not there would be too many Azure Disk volumes attached to the node</span></span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.MaxAzureDiskVolumeCountPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.AzureDiskVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.MaxCSIVolumeCountPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewCSIMaxVolumeLimitPredicate(args.CSINodeInfo, args.PVInfo, args.PVCInfo, args.StorageClassInfo)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.MaxCinderVolumeCountPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.CinderVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by inter-pod affinity.</span></span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.MatchInterPodAffinityPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewPodAffinityPredicate(args.NodeInfo, args.PodLister)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by non-conflicting disk volumes.</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.NoDiskConflictPred, predicates.NoDiskConflict)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GeneralPredicates are the predicates that are enforced by all Kubernetes components</span></span><br><span class="line">	<span class="comment">// (e.g. kubelet and all schedulers)</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.GeneralPred, predicates.GeneralPredicates)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by node memory pressure condition.</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.CheckNodeMemoryPressurePred, predicates.CheckNodeMemoryPressurePredicate)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by node disk pressure condition.</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.CheckNodeDiskPressurePred, predicates.CheckNodeDiskPressurePredicate)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by node pid pressure condition.</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.CheckNodePIDPressurePred, predicates.CheckNodePIDPressurePredicate)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by node conditions: not ready, network unavailable or out of disk.</span></span><br><span class="line">	factory.RegisterMandatoryFitPredicate(predicates.CheckNodeConditionPred, predicates.CheckNodeConditionPredicate)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined based on whether a pod can tolerate all of the node's taints</span></span><br><span class="line">	factory.RegisterFitPredicate(predicates.PodToleratesNodeTaintsPred, predicates.PodToleratesNodeTaints)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fit is determined by volume topology requirements.</span></span><br><span class="line">	factory.RegisterFitPredicateFactory(</span><br><span class="line">		predicates.CheckVolumeBindingPred,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> predicates.NewVolumeBindingPredicate(args.VolumeBinder)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="局部最优"><a href="#局部最优" class="headerlink" title="局部最优"></a>局部最优</h3><p>预选流程需要从当前集群中选择一台符合要求的node。随着集群规模的增长，如果每次遍历所有集群node则会必然导致性能的下降，于是通过局部最优解的方式，缩小筛选节点的数量。具体来说，<code>genericScheduler</code>定义了 <code>minFeasibleNodesToFind</code> 和 <code>minFeasibleNodesPercentageToFind</code>这两个常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	minFeasibleNodesToFind = <span class="number">100</span></span><br><span class="line">	minFeasibleNodesPercentageToFind = <span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>minFeasibleNodesToFind：定义了在调度阶段参与打分的最小节点数，默认为100。</li>
<li>minFeasibleNodesPercentageToFind：定义了在调度阶段参与打分的最小百分比，默认为5%。</li>
</ul>
<p>通过<code>numFeasibleNodesToFind</code> 函数，结合当前集群中的Node数量，和默认的最小值来决定本次预选阶段需要获取的node节点数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">numFeasibleNodesToFind</span><span class="params">(numAllNodes <span class="keyword">int32</span>)</span> <span class="params">(numNodes <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点数量小于minFeasibleNodesToFind即小于100台node</span></span><br><span class="line">    <span class="comment">// 同理百分比如果大于100就是全量取样</span></span><br><span class="line">    <span class="comment">// 这两种情况都直接遍历整个集群中所有节点</span></span><br><span class="line">    <span class="keyword">if</span> numAllNodes &lt; minFeasibleNodesToFind || g.percentageOfNodesToScore &gt;= <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numAllNodes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedulerapi.DefaultPercentageOfNodesToScore = 50</span></span><br><span class="line">    adaptivePercentage := g.percentageOfNodesToScore</span><br><span class="line">    <span class="keyword">if</span> adaptivePercentage &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        adaptivePercentage = schedulerapi.DefaultPercentageOfNodesToScore - numAllNodes/<span class="number">125</span></span><br><span class="line">        <span class="keyword">if</span> adaptivePercentage &lt; minFeasibleNodesPercentageToFind &#123;</span><br><span class="line">            adaptivePercentage = minFeasibleNodesPercentageToFind</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常取样计算：比如numAllNodes为5000，而adaptivePercentage为50%</span></span><br><span class="line">    <span class="comment">// 则numNodes=50000*0.5/100=250</span></span><br><span class="line">    numNodes = numAllNodes * adaptivePercentage / <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> numNodes &lt; minFeasibleNodesToFind &#123; <span class="comment">// 如果小于最少取样则按照最少取样进行取样</span></span><br><span class="line">        <span class="keyword">return</span> minFeasibleNodesToFind</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行加速"><a href="#并行加速" class="headerlink" title="并行加速"></a>并行加速</h3><p>在当前k8s版本中，默认会启动16个goroutine来进行并行的预选，从而提高预选的性能</p>
<p>并行取样主要通过调用下面的函数来启动16个goroutine来进行并行取样，并通过ctx来协调退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">workqueue.ParallelizeUntil(ctx, <span class="number">16</span>, <span class="keyword">int</span>(allNodes), checkNode)</span><br></pre></td></tr></table></figure>
<p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-047108dba71d6806c7fed091c15080e8_1440w.jpg"></p>
<p>通过channel来构建取样索引的管道，每个worker会负责从channel获取的指定索引取样node的填充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParallelizeUntil</span><span class="params">(ctx context.Context, workers, pieces <span class="keyword">int</span>, doWorkPiece DoWorkPieceFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> ctx != <span class="literal">nil</span> &#123;</span><br><span class="line">        stop = ctx.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成指定数量索引，worker通过索引来进行预选成功节点的存储</span></span><br><span class="line">    toProcess := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, pieces)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pieces; i++ &#123;</span><br><span class="line">        toProcess &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(toProcess)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pieces &lt; workers &#123;</span><br><span class="line">        workers = pieces</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(workers)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">        <span class="comment">// 启动多个goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> piece := <span class="keyword">range</span> toProcess &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//获取索引，后续会通过该索引来进行结果的存储</span></span><br><span class="line">                    doWorkPiece(piece)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待退出</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体每个实际并发执行函数为，它通过在 <code>NodeTree</code> 获取下一个可用的Node，然后调用 <code>podFitsOnNode</code>来检查该Pod是否可以运行在对应的Node上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  nodeName := g.cache.NodeTree().Next()</span><br><span class="line"></span><br><span class="line">  fits, failedPredicates, status, err := g.podFitsOnNode(</span><br><span class="line">    pluginContext,</span><br><span class="line">    pod,</span><br><span class="line">    meta,</span><br><span class="line">    g.nodeInfoSnapshot.NodeInfoMap[nodeName],</span><br><span class="line">    g.predicates,</span><br><span class="line">    g.schedulingQueue,</span><br><span class="line">    g.alwaysCheckAllPredicates,</span><br><span class="line">  )</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两轮筛选"><a href="#两轮筛选" class="headerlink" title="两轮筛选"></a>两轮筛选</h3><p>为了检查一个Pod是否能够运行在给定的Node上，我们通过运行 <code>podFitsOnNode</code>来检查一系列的predicate函数。在这里我们会运行两轮筛选。</p>
<ul>
<li>面向未来调度的预选：<ul>
<li>如果在这个Node上有相同或者更高优先级的<code>Nominated Pods</code>，我们把这些pods加入到meta和nodeInfo中，然后运行predicate算法。之所以考虑更高优先级，是因为当前Pod抢占了低优先级Pod的资源是OK的，但是如果占有了更高优先级资源是不允许的。</li>
<li>如果在筛选的时候，没有<code>Nominated Pods</code>，或者第一轮筛选中没有通过，那么就不会运行第二轮筛选。</li>
</ul>
</li>
<li>面向当前资源的预选：<ul>
<li>在这一轮筛选中，如果通过了所有的算法，那么需要在这些pods不加入的情况下，再运行一轮筛选。</li>
</ul>
</li>
</ul>
<p>第二轮筛选必须存在的原因是，有些预选算法（比如Pod间的亲和性算法）在没有<code>Nominated Pods</code>的条件下可能不会通过筛选。本质上运行两次是一种保守的决策算法。如果我们把<code>nominated pod</code>视作正在运行，那么resource和Pod间anti-affinity算法更有可能失败；如果我们不把<code>nominated pod</code>视作正在运行，那么像pod间的亲和性算法更有可能失败。本质上我们不能假定 <code>Nominated Pods</code> 是否运行，因为它们现在没有运行，而且有可能被调度到另一个Node运行。</p>
<p>通过两轮筛选在无论那些优先级高的pod是否被调度到当前node上，都可以满足pod的调度需求，在调度的流程中只需要获取之前注册的调度算法，完成预选检测，如果发现有条件不通过则不会进行第二轮筛选，继续选择下一个节点。</p>
<p><img alt="两轮预选" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579167028012-6daee5fe-ee2d-4821-8650-5eb25a390626.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">podFitsOnNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	pluginContext *framework.PluginContext,</span></span></span><br><span class="line"><span class="function"><span class="params">	pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">	meta predicates.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">	info *schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">	predicateFuncs <span class="keyword">map</span>[<span class="keyword">string</span>]predicates.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">	queue internalqueue.SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">	alwaysCheckAllPredicates <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">bool</span>, []predicates.PredicateFailureReason, *framework.Status, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	podsAdded := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		metaToUse := meta</span><br><span class="line">		nodeInfoToUse := info</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			podsAdded, metaToUse, nodeInfoToUse = addNominatedPods(pod, meta, info, queue)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !podsAdded || <span class="built_in">len</span>(failedPredicates) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, predicateKey := <span class="keyword">range</span> predicates.Ordering() &#123;</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(failedPredicates) == <span class="number">0</span> &amp;&amp; status.IsSuccess(), failedPredicates, status, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Priority-优选"><a href="#Priority-优选" class="headerlink" title="Priority 优选"></a>Priority 优选</h2><p>优选阶段主要是对通过了预选过滤的节点按照各种算法打分，打分的结果以 <code>HostPriority</code> 的形式记录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HostPriority represents the priority of scheduling to a particular host, higher priority is better.</span></span><br><span class="line"><span class="keyword">type</span> HostPriority <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Name of the host</span></span><br><span class="line">	Host <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Score associated with the host</span></span><br><span class="line">	Score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HostPriorityList declares a []HostPriority type.</span></span><br><span class="line"><span class="keyword">type</span> HostPriorityList []HostPriority</span><br></pre></td></tr></table></figure>
<p>为了提高优选过程中的计算速度，采用了 <code>Map/Reduce</code> 的方法对计算并行加速，结果存储在一个二维数组中。无锁计算结果的保存主要是通过下面的二维数组实现， 如果要存储一个算法针对某个node的结果，其实只需要通过两个索引即可：算法索引和节点索引。</p>
<p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579246857471-0d97105c-2a26-4237-bd7d-996e755f0fa1.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在计算的时候，会传入nodes []*v1.Node的数组，存储所有的节点，节点索引主要是指的该部分</span></span><br><span class="line">results := <span class="built_in">make</span>([]schedulerapi.HostPriorityList, <span class="built_in">len</span>(priorityConfigs), <span class="built_in">len</span>(priorityConfigs))</span><br></pre></td></tr></table></figure>
<h3 id="Priority算法注册"><a href="#Priority算法注册" class="headerlink" title="Priority算法注册"></a>Priority算法注册</h3><p>在优选过程中，每一种策略都以 <code>PriorityConfig</code> 结构表示，具体包含 <code>Map</code> 函数和 <code>Reduce</code>函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Map    PriorityMapFunction</span><br><span class="line">	Reduce PriorityReduceFunction</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Remove it after migrating all functions to</span></span><br><span class="line">	<span class="comment">// Map-Reduce pattern.</span></span><br><span class="line">	Function PriorityFunction</span><br><span class="line">	Weight   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种函数定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map：输入是(pod, meta, nodeInfo)，输出是该Pod根据该算法在该节点算出的得分</span></span><br><span class="line"><span class="keyword">type</span> PriorityMapFunction <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, meta <span class="keyword">interface</span>&#123;&#125;, nodeInfo *schedulernodeinfo.NodeInfo)</span> <span class="params">(schedulerapi.HostPriority, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce：输入是(pod, meta, map[string]*NodeInfo, result)</span></span><br><span class="line"><span class="keyword">type</span> PriorityReduceFunction <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, meta <span class="keyword">interface</span>&#123;&#125;, nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo, result schedulerapi.HostPriorityList)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>那么，这些算法是在哪里注册的呢？在factory目录下有注册函数，指定算法名和map/reduce函数以及权重，</p>
<figure class="highlight go"><figcaption><span>pkg/scheduler/factory/plugins.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterPriorityMapReduceFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	name <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	mapFunction priorities.PriorityMapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">	reduceFunction priorities.PriorityReduceFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">	weight <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> RegisterPriorityConfigFactory(name, PriorityConfigFactory&#123;</span><br><span class="line">		MapReduceFunction: <span class="function"><span class="keyword">func</span><span class="params">(PluginFactoryArgs)</span> <span class="params">(priorities.PriorityMapFunction, priorities.PriorityReduceFunction)</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mapFunction, reduceFunction</span><br><span class="line">		&#125;,</span><br><span class="line">		Weight: weight,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>pkg/scheduler/algorithmprovider/defaults/register_priorities.go</code>中有 <code>init</code>函数来注册：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Register functions that extract metadata used by priorities computations.</span></span><br><span class="line">	factory.RegisterPriorityMetadataProducerFactory(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">priorities</span>.<span class="title">PriorityMetadataProducer</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> priorities.NewPriorityMetadataFactory(args.ServiceLister, args.ControllerLister, args.ReplicaSetLister, args.StatefulSetLister)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prioritize nodes by least requested utilization.</span></span><br><span class="line">	factory.RegisterPriorityMapReduceFunction(priorities.LeastRequestedPriority, priorities.LeastRequestedPriorityMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prioritizes nodes to help achieve balanced resource usage</span></span><br><span class="line">	factory.RegisterPriorityMapReduceFunction(priorities.BalancedResourceAllocation, priorities.BalancedResourceAllocationMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set this weight large enough to override all other priority functions.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Figure out a better way to do this, maybe at same time as fixing #24720.</span></span><br><span class="line">	factory.RegisterPriorityMapReduceFunction(priorities.NodePreferAvoidPodsPriority, priorities.CalculateNodePreferAvoidPodsPriorityMap, <span class="literal">nil</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prioritizes nodes that have labels matching NodeAffinity</span></span><br><span class="line">	factory.RegisterPriorityMapReduceFunction(priorities.NodeAffinityPriority, priorities.CalculateNodeAffinityPriorityMap, priorities.CalculateNodeAffinityPriorityReduce, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prioritizes nodes that marked with taint which pod can tolerate.</span></span><br><span class="line">	factory.RegisterPriorityMapReduceFunction(priorities.TaintTolerationPriority, priorities.ComputeTaintTolerationPriorityMap, priorities.ComputeTaintTolerationPriorityReduce, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ImageLocalityPriority prioritizes nodes that have images requested by the pod present.</span></span><br><span class="line">	factory.RegisterPriorityMapReduceFunction(priorities.ImageLocalityPriority, priorities.ImageLocalityPriorityMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面对每一个策略进行简单分析。</p>
<h3 id="基于节点索引的Map计算"><a href="#基于节点索引的Map计算" class="headerlink" title="基于节点索引的Map计算"></a>基于节点索引的Map计算</h3><p>Map算法将Node方向的计算并行化，对于每一个Node，循环计算该Node在各个算法上的得分。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">workqueue.ParallelizeUntil(context.TODO(), <span class="number">16</span>, <span class="built_in">len</span>(nodes), <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	nodeInfo := nodeNameToInfo[nodes[index].Name]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">		<span class="keyword">if</span> priorityConfigs[i].Function != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		results[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			appendError(err)</span><br><span class="line">			results[i][index].Host = nodes[index].Name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="基于算法索引的Reduce计算"><a href="#基于算法索引的Reduce计算" class="headerlink" title="基于算法索引的Reduce计算"></a>基于算法索引的Reduce计算</h3><p>Reduce计算，则是为每个算法的计算都启动一个goroutine，每个goroutine通过算法索引来进行该算法的所有map阶段的结果的读取，并进行计算，后续结果仍然存储在对应的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line">	<span class="keyword">if</span> priorityConfigs[i].Reduce == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">if</span> err := priorityConfigs[index].Reduce(pod, meta, nodeNameToInfo, results[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			appendError(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> klog.V(<span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> _, hostPriority := <span class="keyword">range</span> results[index] &#123;</span><br><span class="line">				klog.Infof(<span class="string">"%v -&gt; %v: %v, Score: (%d)"</span>, util.GetPodFullName(pod), hostPriority.Host, priorityConfigs[index].Name, hostPriority.Score)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上优选算法中有 <code>Reduce</code> 函数的并不多，只有 <code>NodeAffinity</code> 和 <code>TaintToleration</code>两个算有有Reduce函数，而且它们实质上都是调用的 <code>NormalizeReduce</code>。本质上就是将之前算出来的得分正则化，使其处于 <code>[0, maxPriority]</code>区间。因此，在Scheduling Framework框架下，这一部分被 <code>Normalize Scoring</code>阶段所取代。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NormalizeReduce</span><span class="params">(maxPriority <span class="keyword">int</span>, reverse <span class="keyword">bool</span>)</span> <span class="title">PriorityReduceFunction</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		_ *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">		_ <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">		_ <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">		result schedulerapi.HostPriorityList)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> maxCount <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">			<span class="keyword">if</span> result[i].Score &gt; maxCount &#123;</span><br><span class="line">				maxCount = result[i].Score</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> maxCount == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> reverse &#123;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">					result[i].Score = maxPriority</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">			score := result[i].Score</span><br><span class="line"></span><br><span class="line">			score = maxPriority * score / maxCount</span><br><span class="line">			<span class="keyword">if</span> reverse &#123;</span><br><span class="line">				score = maxPriority - score</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			result[i].Score = score</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Preempt-抢占"><a href="#Preempt-抢占" class="headerlink" title="Preempt 抢占"></a>Preempt 抢占</h2><p>抢占调度是分布式调度中一种常见的设计，其核心目标是当不能为高优先级的任务分配资源的时候，会通过抢占低优先级的任务来进行高优先级的调度。</p>
<h3 id="抢占核心流程"><a href="#抢占核心流程" class="headerlink" title="抢占核心流程"></a>抢占核心流程</h3><h3 id="抢占条件检测"><a href="#抢占条件检测" class="headerlink" title="抢占条件检测"></a>抢占条件检测</h3><p>如果发现需要执行抢占的pod有提名的node，并且对应node上面存在比自己优先级低的pod正在进行删除, 则不允许进行抢占。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">podEligibleToPreemptOthers</span><span class="params">(pod *v1.Pod, nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo, enableNonPreempting <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enableNonPreempting &amp;&amp; pod.Spec.PreemptionPolicy != <span class="literal">nil</span> &amp;&amp; *pod.Spec.PreemptionPolicy == v1.PreemptNever &#123;</span><br><span class="line">        klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v/%v is not eligible for preemption because it has a preemptionPolicy of %v"</span>, pod.Namespace, pod.Name, v1.PreemptNever)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    nomNodeName := pod.Status.NominatedNodeName</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nomNodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeInfo, found := nodeNameToInfo[nomNodeName]; found &#123;</span><br><span class="line">            podPriority := util.GetPodPriority(pod)</span><br><span class="line">            <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfo.Pods() &#123;</span><br><span class="line">                <span class="keyword">if</span> p.DeletionTimestamp != <span class="literal">nil</span> &amp;&amp; util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">                    <span class="comment">// 正在终止的优先级低于当前pod的pod就不会进行抢占</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛选潜在节点"><a href="#筛选潜在节点" class="headerlink" title="筛选潜在节点"></a>筛选潜在节点</h3><p>每个node在预选阶段都会进行一个标记，标记当前node执行预选失败的原因，筛选潜在节点主要是根据对应的错误来进行筛选，如果不是不可解决的预选错误，则该node节点就可以参与接下来的抢占阶段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nodesWherePreemptionMightHelp</span><span class="params">(nodes []*v1.Node, fitErr *FitError)</span> []*<span class="title">v1</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line">    potentialNodes := []*v1.Node&#123;&#125;</span><br><span class="line">    <span class="comment">// 根据预选阶段的错误原因，如果不存在无法解决的错误，则这些node可能在接下来的抢占流程中被使用</span></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> fitErr.FilteredNodesStatuses[node.Name].Code() == framework.UnschedulableAndUnresolvable &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        failedPredicates, _ := fitErr.FailedPredicates[node.Name]</span><br><span class="line">        <span class="keyword">if</span> !unresolvablePredicateExists(failedPredicates) &#123; </span><br><span class="line">            <span class="comment">// 如果我们发现并不是不可解决的调度错误的时候，就将这个节点加入到这里</span></span><br><span class="line">            <span class="comment">// 可能通过后续的调整会让这些node重新满足</span></span><br><span class="line">            klog.V(<span class="number">3</span>).Infof(<span class="string">"Node %v is a potential node for preemption."</span>, node.Name)</span><br><span class="line">            potentialNodes = <span class="built_in">append</span>(potentialNodes, node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> potentialNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行筛选节点"><a href="#并行筛选节点" class="headerlink" title="并行筛选节点"></a>并行筛选节点</h3><p>筛选抢占节点主要是并行对之前筛选潜在node进行尝试，通过驱逐低优先级pod满足高优先级pod调度，最终会筛选一批可以通过抢占来满足pod调度需要的节点， 其核心实现时通过selectVictimsOnNode来进行检测。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">selectNodesForPreemption</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    pluginContext *framework.PluginContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    potentialNodes []*v1.Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    fitPredicates <span class="keyword">map</span>[<span class="keyword">string</span>]predicates.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">    metadataProducer predicates.PredicateMetadataProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue internalqueue.SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    pdbs []*policy.PodDisruptionBudget,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims, error)</span></span> &#123;</span><br><span class="line">    nodeToVictims := <span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> resultLock sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can use the same metadata producer for all nodes.</span></span><br><span class="line">    meta := metadataProducer(pod, nodeNameToInfo)</span><br><span class="line">    checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nodeName := potentialNodes[i].Name</span><br><span class="line">        <span class="keyword">var</span> metaCopy predicates.PredicateMetadata</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            metaCopy = meta.ShallowCopy()</span><br><span class="line">        &#125;</span><br><span class="line">        pods, numPDBViolations, fits := g.selectVictimsOnNode(pluginContext, pod, metaCopy, nodeNameToInfo[nodeName], fitPredicates, queue, pdbs)</span><br><span class="line">        <span class="keyword">if</span> fits &#123;</span><br><span class="line">            resultLock.Lock()</span><br><span class="line">            victims := schedulerapi.Victims&#123;</span><br><span class="line">                Pods:             pods,</span><br><span class="line">                NumPDBViolations: numPDBViolations,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeToVictims[potentialNodes[i]] = &amp;victims</span><br><span class="line">            resultLock.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    workqueue.ParallelizeUntil(context.TODO(), <span class="number">16</span>, <span class="built_in">len</span>(potentialNodes), checkNode)</span><br><span class="line">    <span class="keyword">return</span> nodeToVictims, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单点筛选节点"><a href="#单点筛选节点" class="headerlink" title="单点筛选节点"></a>单点筛选节点</h3><p><code>selectVictimsOnNode</code>即单点筛选流程是针对单个node来指向具体的驱逐抢占决策的流程, 其核心流程如下</p>
<p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579429019409-ea29afc8-b17d-410e-8bfc-531b00b49155.png"></p>
<h4 id="优先级筛选"><a href="#优先级筛选" class="headerlink" title="优先级筛选"></a>优先级筛选</h4><p>优先级筛选首先会对当前node上面的所有节点进行优先级排序，移除所有比当前pod低的pod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">potentialVictims := util.SortableList&#123;CompFunc: util.MoreImportantPod&#125;</span><br><span class="line">    nodeInfoCopy := nodeInfo.Clone()</span><br><span class="line"></span><br><span class="line">    removePod := <span class="function"><span class="keyword">func</span><span class="params">(rp *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.RemovePod(rp)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.RemovePod(rp, nodeInfoCopy.Node())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addPod := <span class="function"><span class="keyword">func</span><span class="params">(ap *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.AddPod(ap)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.AddPod(ap, nodeInfoCopy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    podPriority := util.GetPodPriority(pod)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfoCopy.Pods() &#123;</span><br><span class="line">        <span class="keyword">if</span> util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">            <span class="comment">// 移除所有优先级比自己低的pod</span></span><br><span class="line">            potentialVictims.Items = <span class="built_in">append</span>(potentialVictims.Items, p)</span><br><span class="line">            removePod(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="预选判断"><a href="#预选判断" class="headerlink" title="预选判断"></a>预选判断</h4><p>对移除所有优先级比自己的pod之后，会尝试进行预选流程，如果发现预选流程失败，则当前node即使通过移除所有比自己优先级低的pod也不能满足调度需求,则就进行下一个node判断</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">if fits, _, _, err := g.podFitsOnNode(pluginContext, pod, <span class="keyword">meta</span>, node<span class="literal">Inf</span>oCopy, fitPredicates, queue, <span class="literal">false</span>); !fits &#123;</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Encountered error while selecting victims on node %v: %v"</span>, node<span class="literal">Inf</span>o.<span class="keyword">Node</span><span class="title">().Name</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="PDB分组与分组算法"><a href="#PDB分组与分组算法" class="headerlink" title="PDB分组与分组算法"></a>PDB分组与分组算法</h4><p>PDB分组就是对当前节点上筛选出来的低优先级pod按照是否有PDB匹配来进行分组，分为违反PDB和未违反PDB的两组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">violatingVictims, nonViolatingVictims := filterPodsWithPDBViolation(potentialVictims.Items, pdbs)</span><br></pre></td></tr></table></figure>
<p>分组算法其实也不难，只需要遍历所有的pdb和pod就可以得到最终的分组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterPodsWithPDBViolation</span><span class="params">(pods []<span class="keyword">interface</span>&#123;&#125;, pdbs []*policy.PodDisruptionBudget)</span> <span class="params">(violatingPods, nonViolatingPods []*v1.Pod)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, obj := <span class="keyword">range</span> pods &#123;</span><br><span class="line">        pod := obj.(*v1.Pod)</span><br><span class="line">        pdbForPodIsViolated := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// A pod with no labels will not match any PDB. So, no need to check.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pod.Labels) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, pdb := <span class="keyword">range</span> pdbs &#123;</span><br><span class="line">                <span class="keyword">if</span> pdb.Namespace != pod.Namespace &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                selector, err := metav1.LabelSelectorAsSelector(pdb.Spec.Selector)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// A PDB with a nil or empty selector matches nothing.</span></span><br><span class="line">                <span class="keyword">if</span> selector.Empty() || !selector.Matches(labels.Set(pod.Labels)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We have found a matching PDB.</span></span><br><span class="line">                <span class="keyword">if</span> pdb.Status.PodDisruptionsAllowed &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                    pdbForPodIsViolated = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pdbForPodIsViolated &#123;</span><br><span class="line">            violatingPods = <span class="built_in">append</span>(violatingPods, pod)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonViolatingPods = <span class="built_in">append</span>(nonViolatingPods, pod)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> violatingPods, nonViolatingPods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="违反PDB计数与最少驱逐汇总"><a href="#违反PDB计数与最少驱逐汇总" class="headerlink" title="违反PDB计数与最少驱逐汇总"></a>违反PDB计数与最少驱逐汇总</h4><p>会分别对违反PDB和不违反的pod集合来进行reprievePod检测，如果加入当前pod后，不能满足预选筛选流程，则该pod则必须被进行移除加入到victims中， 同时如果是违反PDB的pod则需要进行违反pdb计数numViolatingVictim</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reprievePod := <span class="function"><span class="keyword">func</span><span class="params">(p *v1.Pod)</span> <span class="title">bool</span></span> &#123; </span><br><span class="line">      <span class="comment">// 我们首先将pod加入到meta中</span></span><br><span class="line">      addPod(p)</span><br><span class="line">      fits, _, _, _ := g.podFitsOnNode(pluginContext, pod, meta, nodeInfoCopy, fitPredicates, queue, <span class="literal">false</span>)</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> !fits &#123;</span><br><span class="line">          <span class="comment">// 如果我们加入了pod然后导致了预选不成功，则这个pod必须给移除</span></span><br><span class="line">          removePod(p)</span><br><span class="line">          victims = <span class="built_in">append</span>(victims, p) <span class="comment">// 添加到我们需要移除的列表里面</span></span><br><span class="line">          klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v/%v is a potential preemption victim on node %v."</span>, p.Namespace, p.Name, nodeInfo.Node().Name)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fits</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> violatingVictims &#123;</span><br><span class="line">      <span class="keyword">if</span> !reprievePod(p) &#123;</span><br><span class="line">          numViolatingVictim++</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now we try to reprieve non-violating victims.</span></span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> nonViolatingVictims &#123;</span><br><span class="line">      <span class="comment">// 尝试移除未违反pdb的pod</span></span><br><span class="line">      reprievePod(p)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> victims, numViolatingVictim, <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="筛选最优抢占"><a href="#筛选最优抢占" class="headerlink" title="筛选最优抢占"></a>筛选最优抢占</h3><p>最优筛选主要是通过 <code>pickOneNodeForPreemption</code> 实现，其中筛选数据存储结构主要是通过重用minNodes1和minNodes2两段内存来进行实现，这两个node数组分别配有两个计数器lenNodes1和lenNodes2, 针对具有相同优先级、相同数量的node，每增加一个会进行一次计数器累加， 核心算法流程如下</p>
<p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579429125998-3ddcaf40-b47c-4234-81bc-fce652fe6f46.png"></p>
<h4 id="最少违反PDB"><a href="#最少违反PDB" class="headerlink" title="最少违反PDB"></a>最少违反PDB</h4><p>最少违反PDB是根据前面统计的违反PDB的计数统计，找到最少违反的node，如果是单个node则直接返回筛选结束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">minNumPDBViolatingPods := math.MaxInt32</span><br><span class="line"><span class="keyword">var</span> minNodes1 []*v1.Node</span><br><span class="line">lenNodes1 := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> node, victims := <span class="keyword">range</span> nodesToVictims &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(victims.Pods) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发现一个noed不需要任何抢占，则返回它</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    numPDBViolatingPods := victims.NumPDBViolations</span><br><span class="line">    <span class="keyword">if</span> numPDBViolatingPods &lt; minNumPDBViolatingPods &#123; </span><br><span class="line">        <span class="comment">// 如果小于最小pdb数量， 如果数量发生变化，就重置</span></span><br><span class="line">        minNumPDBViolatingPods = numPDBViolatingPods</span><br><span class="line">        minNodes1 = <span class="literal">nil</span></span><br><span class="line">        lenNodes1 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numPDBViolatingPods == minNumPDBViolatingPods &#123; </span><br><span class="line">        <span class="comment">// 多个相同的node会进行追加，并累加计数器 </span></span><br><span class="line">        minNodes1 = <span class="built_in">append</span>(minNodes1, node)</span><br><span class="line">        lenNodes1++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最高优先级最小优先"><a href="#最高优先级最小优先" class="headerlink" title="最高优先级最小优先"></a>最高优先级最小优先</h4><p>最高优先级最小优先是指通过对比多个node的最高优先级的pod，优先级最低的那个node被选中，如果多个则进行下一个算法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">minHighestPriority := <span class="keyword">int32</span>(math.MaxInt32)</span><br><span class="line">    <span class="keyword">var</span> minNodes2 = <span class="built_in">make</span>([]*v1.Node, lenNodes1)</span><br><span class="line">    lenNodes2 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">        node := minNodes1[i]</span><br><span class="line">        victims := nodesToVictims[node]</span><br><span class="line">        <span class="comment">// highestPodPriority is the highest priority among the victims on this node.</span></span><br><span class="line">        <span class="comment">// 返回优先级最高的pod</span></span><br><span class="line">        highestPodPriority := util.GetPodPriority(victims.Pods[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> highestPodPriority &lt; minHighestPriority &#123;</span><br><span class="line">            <span class="comment">// 重置状态</span></span><br><span class="line">            minHighestPriority = highestPodPriority</span><br><span class="line">            lenNodes2 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> highestPodPriority == minHighestPriority &#123;</span><br><span class="line">            <span class="comment">// 如果优先级相等则加入进去</span></span><br><span class="line">            minNodes2[lenNodes2] = node</span><br><span class="line">            lenNodes2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级总和最低优先"><a href="#优先级总和最低优先" class="headerlink" title="优先级总和最低优先"></a>优先级总和最低优先</h4><p>统计每个node上的所有被抢占的pod的优先级的总和，然后在多个node之间进行比较，优先级总和最低的节点被选中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">minSumPriorities := <span class="keyword">int64</span>(math.MaxInt64)</span><br><span class="line">    lenNodes1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> sumPriorities <span class="keyword">int64</span></span><br><span class="line">        node := minNodes2[i]</span><br><span class="line">        <span class="comment">// 统计所有优先级</span></span><br><span class="line">        <span class="keyword">for</span> _, pod := <span class="keyword">range</span> nodesToVictims[node].Pods &#123;</span><br><span class="line">            </span><br><span class="line">            sumPriorities += <span class="keyword">int64</span>(util.GetPodPriority(pod)) + <span class="keyword">int64</span>(math.MaxInt32+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities &lt; minSumPriorities &#123;</span><br><span class="line">            minSumPriorities = sumPriorities</span><br><span class="line">            lenNodes1 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities == minSumPriorities &#123;</span><br><span class="line">            minNodes1[lenNodes1] = node</span><br><span class="line">            lenNodes1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最少优先级的node</span></span><br><span class="line">    <span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最少抢占数量优先"><a href="#最少抢占数量优先" class="headerlink" title="最少抢占数量优先"></a>最少抢占数量优先</h4><p>最少抢占数量优先即统计每个node被抢占的节点数量，数量最少得被选中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">minNumPods := math.MaxInt32</span><br><span class="line">lenNodes2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">    node := minNodes1[i]</span><br><span class="line">    numPods := <span class="built_in">len</span>(nodesToVictims[node].Pods)</span><br><span class="line">    <span class="keyword">if</span> numPods &lt; minNumPods &#123;</span><br><span class="line">        minNumPods = numPods</span><br><span class="line">        lenNodes2 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numPods == minNumPods &#123;</span><br><span class="line">        minNodes2[lenNodes2] = node</span><br><span class="line">        lenNodes2++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最少节点数量</span></span><br><span class="line"><span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最近更新节点优先"><a href="#最近更新节点优先" class="headerlink" title="最近更新节点优先"></a>最近更新节点优先</h4><p>该算法会筛选每个node驱逐的pod中优先级最高的pod的最早更新时间(其实就是说这个pod早就被创建了)，然后在多个node之间进行比较，如果谁上面的时间越新(即这个node上的pod可能是最近被调度上去的)，则就选中这个节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">latestStartTime := util.GetEarliestPodStartTime(nodesToVictims[minNodes2[<span class="number">0</span>]])</span><br><span class="line">   <span class="keyword">if</span> latestStartTime == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// If the earliest start time of all pods on the 1st node is nil, just return it,</span></span><br><span class="line">       <span class="comment">// which is not expected to happen.</span></span><br><span class="line">       <span class="comment">// 如果第一个节点上所有pod的最早开始时间为零，那么返回它</span></span><br><span class="line">       klog.Errorf(<span class="string">"earliestStartTime is nil for node %s. Should not reach here."</span>, minNodes2[<span class="number">0</span>])</span><br><span class="line">       <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   nodeToReturn := minNodes2[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">       node := minNodes2[i]</span><br><span class="line">       <span class="comment">// Get earliest start time of all pods on the current node.</span></span><br><span class="line">       <span class="comment">// 获取当前node最早启动时间</span></span><br><span class="line">       earliestStartTimeOnNode := util.GetEarliestPodStartTime(nodesToVictims[node])</span><br><span class="line">       <span class="keyword">if</span> earliestStartTimeOnNode == <span class="literal">nil</span> &#123;</span><br><span class="line">           klog.Errorf(<span class="string">"earliestStartTime is nil for node %s. Should not reach here."</span>, node)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> earliestStartTimeOnNode.After(latestStartTime.Time) &#123;</span><br><span class="line">           latestStartTime = earliestStartTimeOnNode</span><br><span class="line">           nodeToReturn = node</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> nodeToReturn</span><br></pre></td></tr></table></figure>
<h2 id="Scheduler-Extender"><a href="#Scheduler-Extender" class="headerlink" title="Scheduler Extender"></a>Scheduler Extender</h2><p>社区最初提供的方案是通过 Extender 的形式来扩展 scheduler。Extender 是外部服务，支持 Filter、Preempt、Prioritize 和 Bind 的扩展，scheduler 运行到相应阶段时，通过调用 Extender 注册的 webhook 来运行扩展的逻辑，影响调度流程中各阶段的决策结果。</p>
<p>以 Filter 阶段举例，执行过程会经过 2 个阶段:</p>
<p>1、scheduler 会先执行内置的 Filter 策略，如果执行失败的话，会直接标识 Pod 调度失败。<br>2、如果内置的 Filter 策略执行成功的话，scheduler 通过 Http 调用 Extender 注册的 webhook, 将调度所需要的 Pod 和 Node 的信息发送到到 Extender，根据返回 filter 结果，作为最终结果。</p>
<p><img alt="Scheduler Extender" data-src="https://static001.infoq.cn/resource/image/ba/71/ba41b64474d1afffa4fa44fe7130c071.jpg"></p>
<p>我们可以发现 Extender 存在以下问题:</p>
<p>1、调用 Extender 的接口是 HTTP 请求，受到网络环境的影响，性能远低于本地的函数调用。同时每次调用都需要将 Pod 和 Node 的信息进行 marshaling 和 unmarshalling 的操作，会进一步降低性能。<br>2、用户可以扩展的点比较有限，位置比较固定，无法支持灵活的扩展，例如只能在执行完默认的 Filter 策略后才能调用。</p>
<p>基于以上介绍，Extender 的方式在集群规模较小，调度效率要求不高的情况下，是一个灵活可用的扩展方案，但是在正常生产环境的大型集群中，Extender 无法支持高吞吐量，性能较差。</p>
<h2 id="Multiple-Schedulers"><a href="#Multiple-Schedulers" class="headerlink" title="Multiple Schedulers"></a>Multiple Schedulers</h2><p>Scheduler 在 Kubernetes 集群中其实类似于一个特殊的 Controller，通过监听 Pod 和 Node 的信息，给 Pod 挑选最佳的节点，更新 Pod 的 spec.NodeName 的信息来将调度结果同步到节点。所以对于部分有特殊的调度需求的用户，有些开发者通过自研 Custom Scheduler 来完成以上的流程，然后通过和 default scheduler 同时部署的方式，来支持自己特殊的调度需求。</p>
<p><img alt="进击的Kubernetes调度系统（一）：Scheduling Framework" data-src="https://static001.infoq.cn/resource/image/98/de/982345178a76967d014yy05300ca59de.jpg"></p>
<p>Custom Scheduler 会存在一下问题：</p>
<p>1、如果与 default scheduler 同时部署，因为每个调度器所看到的资源视图都是全局的，所以在调度决策中可能会在同一时刻在同一个节点资源上调度不同的 Pod，导致节点资源冲突的问题。<br>2、有些用户将调度器所能调度的资源通过 Label 划分不同的池子，可以避免资源冲突的现象出现。但是这样又会导致整体集群资源利用率的下降。<br>3、有些用户选择通过完全自研的方式来替换 default scheduler，这种会带来比较高的研发成本，以及 Kubernetes 版本升级后可能存在的兼容性问题。</p>
<p>Scheduler Extender 的性能较差可是维护成本较小，Custom Scheduler 的研发和维护的成本特别高但是性能较好，这种情况是开发者面临这种两难处境。这时候 Kubernetes Scheduling Framework V2 横空出世，给我们带来鱼和熊掌可以兼得的方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>k8s</tag>
        <tag>源码阅读</tag>
        <tag>scheduler</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go语言设计与实现】同步原语</title>
    <url>/posts/77ffac6b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。</p>
<p>本节会介绍 Go 语言中常见的同步原语 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 以及扩展原语 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>semaphore.Weighted</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>singleflight.Group</code></a> 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。</p>
<a id="more"></a>
<h2 id="基本原语"><a href="#基本原语" class="headerlink" title="基本原语"></a>基本原语</h2><p>Go 语言在 <a href="https://golang.org/pkg/sync/" target="_blank" rel="external nofollow noopener noreferrer"><code>sync</code></a> 包中提供了用于同步的一些基本原语，包括常见的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a>：</p>
<p><img alt="golang-basic-sync-primitives" data-src="https://img.draveness.me/2020-01-23-15797104327981-golang-basic-sync-primitives.png"></p>
<p>这些基本原语提高了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级的更高的 Channel 实现同步。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Go 语言的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 由两个字段 <code>state</code> 和 <code>sema</code> 组成。其中 <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span></span><br><span class="line">	sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：</p>
<p><img alt="golang-mutex-state" data-src="https://img.draveness.me/2020-01-23-15797104328010-golang-mutex-state.png"></p>
<p>在默认情况下，互斥锁的所有状态位都是 <code>0</code>，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<h4 id="正常模式和饥饿模式"><a href="#正常模式和饥饿模式" class="headerlink" title="正常模式和饥饿模式"></a>正常模式和饥饿模式</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。</p>
<p>在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被「饿死」。</p>
<p><img alt="golang-mutex-mode" data-src="https://img.draveness.me/2020-01-23-15797104328020-golang-mutex-mode.png"></p>
<p>饥饿模式是在 Go 语言 <a href="https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be" target="_blank" rel="external nofollow noopener noreferrer">1.9</a> 版本引入的优化<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>，引入的目的是保证互斥锁的公平性（Fairness）。</p>
<p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</p>
<p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p>
<h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h4><p>我们在这一节中将分别介绍互斥锁的加锁和解锁过程，它们分别使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 方法。</p>
<p>互斥锁的加锁是靠 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 完成的，最新的 Go 语言源代码中已经将 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 方法进行了简化，方法的主干只保留最常见、简单的情况 — 当锁的状态是 0 时，将 <code>mutexLocked</code> 位置成 1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果互斥锁的状态不是 0 时就会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L84-L171" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.lockSlow</code></a> 尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将该方法分成几个部分介绍获取锁的过程：</p>
<ol>
<li>判断当前 Goroutine 能否进入自旋；</li>
<li>通过自旋等待互斥锁的释放；</li>
<li>计算互斥锁的最新状态；</li>
<li>更新互斥锁的状态并获取锁；</li>
</ol>
<p>我们先来介绍互斥锁是如何判断当前 Goroutine 能否进入自旋等互斥锁的释放：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li><p>互斥锁只有在普通模式才能进入自旋；</p>
</li>
<li><p><code>sync.runtime_canSpin</code></p>
</li>
</ol>
<p>   需要返回</p>
   <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>   ：</p>
<ol>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ol>
<p>一旦当前 Goroutine 能够进入自旋就会调用<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L5356-L5358" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_doSpin</code></a> 和 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L593-L599" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.procyield</code></a> 并执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">	procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">	MOVL	cycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$<span class="number">1</span>, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">	<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算了新的互斥锁状态之后，就会使用 CAS 函数 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L75" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.CompareAndSwapInt32</code></a> 更新该状态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// 通过 CAS 函数获取了锁</span></span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们没有通过 CAS 获得锁，会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 使用信号量保证资源不会被两个 Goroutine 获取。<a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 方法的剩余代码也会继续执行。</p>
<ul>
<li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li>
</ul>
<p>互斥锁的解锁过程 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 与加锁过程相比就很简单，该过程会先使用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>AddInt32</code></a> 函数快速解锁，这时会发生下面的两种情况：</p>
<ul>
<li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li>
<li>如果该函数返回的新状态不等于 0，这段代码会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L194-L226" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.unlockSlow</code></a> 方法开始慢速解锁：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L194-L226" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.unlockSlow</code></a> 方法首先会校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了就会直接抛出异常 <code>sync: unlock of unlocked mutex</code> 中止当前程序。</p>
<p>在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在正常模式下，这段代码会分别处理以下两种情况处理；<ul>
<li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法就可以直接返回，不需要唤醒其他等待者；</li>
<li>如果互斥锁存在等待者，会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒等待者并移交锁的所有权；</li>
</ul>
</li>
<li>在饥饿模式下，上述代码会直接调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 方法将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们已经从多个方面分析了互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 的实现原理，在这里我们从加锁和解锁两个方面总结一下结论和注意事项。</p>
<p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，就会直接通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 并且在普通模式下工作，就会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 函数将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒当前 Goroutine；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>
<ul>
<li>当互斥锁已经被解锁时，那么调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，就会直接返回；在其他情况下会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li>
</ul>
<h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><p>读写互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>写</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<p>一个常见的服务对资源的读写比例会非常高，因为大多数的读请求之间不会相互影响，所以我们可以读写资源操作的分离，在类似场景下提高服务的性能。</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 中总共包含以下 5 个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex</span><br><span class="line">	writerSem   <span class="keyword">uint32</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span></span><br><span class="line">	readerCount <span class="keyword">int32</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>w</code> — 复用互斥锁提供的能力；</li>
<li><code>writerSem</code> 和 <code>readerSem</code> — 分别用于写等待读和读等待写：</li>
<li><code>readerCount</code> 存储了当前正在执行的读操作的数量；</li>
<li><code>readerWait</code> 表示当写操作被阻塞时等待的读操作个数；</li>
</ul>
<p>我们会依次分析获取写锁和读锁的实现原理，其中：</p>
<ul>
<li>写操作使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L92-L110" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Lock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 方法；</li>
<li>读操作使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RLock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 方法；</li>
</ul>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><p>当资源的使用者想要获取写锁时，需要调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L92-L110" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Lock</code></a> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用结构体持有的</li>
</ol>
<p>   <code>sync.Mutex</code></p>
<p>   的</p>
<p>   <code>sync.Mutex.Lock</code></p>
<p>   方法阻塞后续的写操作；</p>
<ul>
<li>因为互斥锁已经被获取，其他 Goroutine 在获取写锁时就会进入自旋或者休眠；</li>
</ul>
<ol>
<li><p>调用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 方法阻塞后续的读操作：</p>
</li>
<li><p>如果仍然有其他 Goroutine 持有互斥锁的读锁（r != 0），该 Goroutine 会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 进入休眠状态等待所有读锁所有者执行结束后释放 <code>writerSem</code> 信号量将当前协程唤醒。</p>
</li>
</ol>
<p>写锁的释放会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与加锁的过程正好相反，写锁的释放分以下几个执行：</p>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 函数将变回正数，释放读锁；</li>
<li>通过 for 循环触发所有由于获取读锁而陷入等待的 Goroutine：</li>
<li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 方法释放写锁；</li>
</ol>
<p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』。</p>
<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><p>读锁的加锁方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RLock</code></a> 很简单，该方法会通过 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 将 <code>readerCount</code> 加一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li>
<li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法就会成功返回；</li>
</ol>
<p>当 Goroutine 想要释放读锁时，会调用如下所示的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会先减少正在读资源的 <code>readerCount</code> 整数，根据 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p>
<ul>
<li>如果返回值大于等于零 — 读锁直接解锁成功；</li>
<li>如果返回值小于零 — 有一个正在执行的写操作，在这时会调用<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.rUnlockSlow</code></a> 方法；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.rUnlockSlow</code></a> 会减少获取锁的写操作等待的读操作数 <code>readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code>writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>读写互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 虽然提供的功能非常复杂，不过因为它建立在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 上，所以整体的实现上会简单很多。我们总结一下读锁和写锁的关系：</p>
<ul>
<li>调用</li>
</ul>
<p>  <code>sync.RWMutex.Lock</code></p>
<p>  尝试获取写锁时；</p>
<ul>
<li>每次 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerWait</code> 其减一，当它归零时该 Goroutine 就会获得写锁；<ul>
<li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li>
</ul>
</li>
</ul>
<ul>
<li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>
<p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p>
<h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 将原本顺序执行的代码在多个 Goroutine 中并发执行，加快程序处理的速度。</p>
<p><img alt="golang-syncgroup" data-src="https://img.draveness.me/2020-01-23-15797104328028-golang-syncgroup.png"></p>
<h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 结构体中的成员变量非常简单，其中只包含两个成员变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>noCopy</code> — 保证 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 不会被开发者通过再赋值的方式拷贝；</li>
<li><code>state1</code> — 存储着状态和信号量；</li>
</ul>
<p><a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 是一个特殊的私有结构体，<a href="http://golang.so/pkg/cmd/vendor/golang.org/x/tools/go/analysis/passes/copylock/" target="_blank" rel="external nofollow noopener noreferrer"><code>tools/go/analysis/passes/copylock</code></a> 包中的分析器会在编译期间检查被拷贝的变量中是否包含 <a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 结构体，如果包含该结构体就会在运行时报出以下错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	yawg := wg</span><br><span class="line">	fmt.Println(wg, yawg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> vet proc.<span class="keyword">go</span></span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: assignment copies lock value to yawg: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">14</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">18</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br></pre></td></tr></table></figure>
<p>这段代码会因为变量赋值或者调用函数时发生值拷贝导致分析器报错。</p>
<p>除了 <a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 字段之外，<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>` 结构体中还包含一个总共占用 12 字节的数组，这个数组会存储当前结构体的状态，在 64 位与 32 位的机器上表现也非常不同。</p>
<p><img alt="golang-waitgroup-state" data-src="https://img.draveness.me/2020-01-23-15797104328035-golang-waitgroup-state.png"></p>
<p><strong>图 6-9 WaitGroup 在 64 位和 32 位机器的不同状态</strong></p>
<p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 提供的私有方法 <a href="https://github.com/golang/go/blob/4c3f26076b6a9853bcc3c7d7e43726c044ac028a/src/sync/waitgroup.go#L32-L38" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.state</code></a> 能够帮我们从 <code>state1</code> 字段中取出它的状态和信号量。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 对外暴露了三个方法 — <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a>。</p>
<p>因为其中的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 只是向 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入了 -1，所以我们重点分析另外两个方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">	v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	w := <span class="keyword">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法可以更新 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 中的计数器 <code>counter</code>。虽然 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，也就是所有任务都执行完成时，就会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒处于等待状态的所有 Goroutine。</p>
<p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的另一个方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L55-L57" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semacquire</code></a> 陷入睡眠状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">		v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">			<span class="keyword">if</span> +statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"sync: WaitGroup is reused before previous Wait has returned"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的计数器归零时，当陷入睡眠状态的 Goroutine 就被唤醒，上述方法会立刻返回。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过对 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的分析和研究，我们能够得出以下结论：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 必须在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li>
<li><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 只是对 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Go 语言标准库中 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。在运行如下所示的代码时，我们会看到如下所示的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"only once"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">only once</span><br></pre></td></tr></table></figure>
<h4 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h4><p>每一个 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体中都只包含一个用于标识代码块是否执行过的 <code>done</code> 以及一个互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="keyword">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 是 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：</p>
<ul>
<li>如果传入的函数已经执行过，就会直接返回；</li>
<li>如果传入的函数没有执行过，就会调用 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L61-L68" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.doSlow</code></a> 执行传入的函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为当前 Goroutine 获取互斥锁；</li>
<li>执行传入的无入参函数；</li>
<li>运行延迟函数调用，将成员变量 <code>done</code> 更新成 1；</li>
</ol>
<p><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 就会通过成员变量 <code>done</code> 确保函数不会执行第二次。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>作为用于保证函数执行次数的 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a href="https://github.com/golang/go/tree/master/src/sync/atomic" target="_blank" rel="external nofollow noopener noreferrer"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li>
<li>两次调用 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 方法传入不同的函数也只会执行第一次调用的函数；</li>
</ul>
<h3 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h3><p>Go 语言标准库中的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 一个条件变量，它可以让一系列的 Goroutine 都在满足特定条件时被唤醒。每一个 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁，我们可以通过下面的例子了解它的使用方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> listen(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">	<span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(ch, os.Interrupt)</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	c.Broadcast()</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	c.Wait()</span><br><span class="line">	fmt.Println(<span class="string">"listen"</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">listen</span><br><span class="line">...</span><br><span class="line">listen</span><br></pre></td></tr></table></figure>
<p>上述代码同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情：</p>
<ul>
<li>10 个 Goroutine 通过 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 等待特定条件的满足；</li>
<li>1 个 Goroutine 会调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法通知所有陷入等待的 Goroutine；</li>
</ul>
<p>调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法后，上述代码会打印出 10 次 “listen” 并结束调用。</p>
<p><img alt="golang-cond-broadcast" data-src="https://img.draveness.me/2020-01-23-15797104328042-golang-cond-broadcast.png"></p>
<h4 id="结构体-3"><a href="#结构体-3" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 的结构体中包含以下 4 个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy  noCopy</span><br><span class="line">	L       Locker</span><br><span class="line">	notify  notifyList</span><br><span class="line">	checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>noCopy</code> — 用于保证结构体不会在编译期间拷贝；</li>
<li><code>copyChecker</code> — 用于禁止运行期间发生的拷贝；</li>
<li><code>L</code> — 用于保护内部的 <code>notify</code> 字段，<code>Locker</code> 接口类型的变量；</li>
<li><code>notify</code> — 一个 Goroutine 的链表，它是实现同步机制的核心结构；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait <span class="keyword">uint32</span></span><br><span class="line">	notify <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">	head *sudog</span><br><span class="line">	tail *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.notifyList</code></a> 结构体中，<code>head</code> 和 <code>tail</code> 分别指向的链表的头和尾，<code>wait</code> 和 <code>notify</code> 分别表示当前正在等待的和已经通知到的 Goroutine，我们通过这两个变量就能确认当前待通知和已通知的 Goroutine。</p>
<h4 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 对外暴露的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 方法会将当前 Goroutine 陷入休眠状态，它的执行过程分成以下两个步骤：</p>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L479-L483" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListAdd</code></a> 将等待计数器加一并解锁；</li>
<li>调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListWait</code></a> 等待其他 Goroutine 的唤醒并加锁：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify) <span class="comment">// runtime.notifyListAdd 的链接名</span></span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t) <span class="comment">// runtime.notifyListWait 的链接名</span></span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListWait</code></a> 函数会获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	s.g = getg()</span><br><span class="line">	s.ticket = t</span><br><span class="line">	<span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.head = s</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		l.tail.next = s</span><br><span class="line">	&#125;</span><br><span class="line">	l.tail = s</span><br><span class="line">	goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了将当前 Goroutine 追加到链表的末端之外，我们还会调用 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309-L311" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goparkunlock</code></a> 将当前 Goroutine 陷入休眠状态，该函数也是在 Go 语言切换 Goroutine 时经常会使用的方法，它会直接让出当前处理器的使用权并等待调度器的唤醒。</p>
<p><img alt="golang-cond-notifylist" data-src="https://img.draveness.me/2020-01-23-15797104328049-golang-cond-notifylist.png"></p>
<p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 和 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法就是用来唤醒调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 陷入休眠的 Goroutine，它们两个的实现有一些细微差别：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 方法会唤醒队列最前面的 Goroutine；</li>
<li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法会唤醒队列中全部的 Goroutine；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L554-L604" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListNotifyOne</code></a> 函数只会从 <a href="https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.notifyList</code></a> 链表中找到满足 <code>sudog.ticket == l.notify</code> 条件的 Goroutine 并通过 <code>readyWithTime</code> 唤醒：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	t := l.notify</span><br><span class="line">	atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">		<span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">			n := s.next</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.next = n</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.head = n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">				l.tail = p</span><br><span class="line">			&#125;</span><br><span class="line">			s.next = <span class="literal">nil</span></span><br><span class="line">			readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L522-L550" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListNotifyAll</code></a> 会依次通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L79-L84" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.readyWithTime</code></a> 函数唤醒链表中 Goroutine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	s := l.head</span><br><span class="line">	l.head = <span class="literal">nil</span></span><br><span class="line">	l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := s.next</span><br><span class="line">		s.next = <span class="literal">nil</span></span><br><span class="line">		readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">		s = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的 Goroutine 需要等待调度器的调度。</p>
<p>在一般情况下，我们都会先调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 或者 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 不是一个常用的同步机制，在遇到长时间条件无法满足时，与使用 <code>for {}</code> 进行忙碌等待相比，<a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 能够让出处理器的使用权。在使用的过程中我们需要注意以下问题：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 方法在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>
<li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 方法唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>
<li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li>
</ul>
<h2 id="扩展原语"><a href="#扩展原语" class="headerlink" title="扩展原语"></a>扩展原语</h2><p>除了标准库中提供的同步原语之外，Go 语言还在子仓库 <a href="https://github.com/golang/sync" target="_blank" rel="external nofollow noopener noreferrer">sync</a> 中提供了四种扩展原语，<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/syncmap/go19.go#L17" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/syncmap.Map</code></a>，其中的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/syncmap/go19.go#L17" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/syncmap.Map</code></a> 在 1.9 版本中被移植到了标准库中。</p>
<p><img alt="golang-extension-sync-primitives" data-src="https://img.draveness.me/2020-01-23-15797104328056-golang-extension-sync-primitives.png"></p>
<p>本节会介绍 Go 语言在扩展包中提供的三种同步原语，也就是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a>。</p>
<h3 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="ErrGroup"></a>ErrGroup</h3><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 就为我们在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能，我们可以使用如下所示的方式并行获取网页的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    url := urls[i]</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        resp, err := http.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            resp.Body.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Successfully fetched all URLs."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L51-L66" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Go</code></a> 方法能够创建一个 Goroutine 并在其中执行传入的函数，而 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L39-L45" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Wait</code></a> 会等待所有 Goroutine 全部返回，该方法的不同返回结果也有不同的含义：</p>
<ul>
<li>如果返回错误 — 这一组 Goroutine 最少返回一个错误；</li>
<li>如果返回空值 — 所有 Goroutine 都成功执行；</li>
</ul>
<h4 id="结构体-4"><a href="#结构体-4" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体同时由三个比较重要的部分组成：</p>
<ol>
<li><code>cancel</code> — 创建 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 时返回的取消函数，用于在多个 Goroutine 之间同步取消信号；</li>
<li><code>wg</code> — 用于等待一组 Goroutine 完成子任务的同步原语；</li>
<li><code>errOnce</code> — 用于保证只接收一个子任务返回的错误；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	errOnce sync.Once</span><br><span class="line">	err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些字段共同组成了 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体并为我们提供同步、错误传播以及上下文取消等功能。</p>
<h4 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h4><p>我们能通过 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L32-L35" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.WithContext</code></a> 构造器创建新的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="params">(*Group, context.Context)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行新的并行子任务需要使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L51-L66" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Go</code></a> 方法，这个方法的执行过程如下：</p>
<ol>
<li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 增加待处理的任务；</li>
<li>创建一个新的 Goroutine 并在 Goroutine 内部运行子任务；</li>
<li>返回错误时及时调用 <code>cancel</code> 并对 <code>err</code> 赋值，只有最早返回的错误才会被上游感知到，后续的错误都会被舍弃：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">	g.wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> g.wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			g.errOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				g.err = err</span><br><span class="line">				<span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">					g.cancel()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Wait</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	g.wg.Wait()</span><br><span class="line">	<span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">		g.cancel()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个用于等待的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L39-L45" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Wait</code></a> 方法只是调用了 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a>，在子任务全部完成时取消 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 并返回可能出现的错误。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 的实现没有涉及底层和运行时包中的 API，它只是对基本同步语义进行了封装以提供更加复杂的功能。在使用时，我们也需要注意以下的几个问题：</p>
<ul>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 在出现错误或者等待结束后都会调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的 <code>cancel</code> 方法同步取消信号；</li>
<li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃；</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。</p>
<ul>
<li>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来；</li>
<li>当遇到计数器大于信号量大小时就会进入休眠等待其他线程释放信号；</li>
</ul>
<p>Go 语言的扩展包中就提供了带权重的信号量 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a>，我们可以按照不同的权重对资源的访问进行管理，这个结构体对外也只暴露了四个方法：</p>
<ul>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L21-L24" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.NewWeighted</code></a> 用于创建新的信号量；</li>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 阻塞地获取指定权重的资源，如果当前没有空闲资源，就会陷入休眠等待；</li>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 非阻塞地获取指定权重的资源，如果当前没有空闲资源，就会直接返回 <code>false</code>；</li>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 用于释放指定权重的资源；</li>
</ul>
<h4 id="结构体-5"><a href="#结构体-5" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L21-L24" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.NewWeighted</code></a> 方法能根据传入的信号量最大权重创建一个 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 结构体指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWeighted</span><span class="params">(n <span class="keyword">int64</span>)</span> *<span class="title">Weighted</span></span> &#123;</span><br><span class="line">	w := &amp;Weighted&#123;size: n&#125;</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">	size    <span class="keyword">int64</span></span><br><span class="line">	cur     <span class="keyword">int64</span></span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	waiters list.List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 结构体中包含一个 <code>waiters</code> 列表，其中存储着等待获取资源的 Goroutine，除此之外它还包含当前信号量的上限以及一个计数器 <code>cur</code>，这个计数器的范围就是 [0, size]：</p>
<p><img alt="golang-semaphore" data-src="https://img.draveness.me/2020-01-23-15797104328063-golang-semaphore.png"></p>
<p><strong>图 6-11 权重信号量</strong></p>
<p>信号量中的计数器会随着用户对资源的访问和释放进行改变，引入的权重概念能够提供更细粒度的资源的访问控制，尽可能满足常见的用例。</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 方法能用于获取指定权重的资源，这个方法总共由三个不同的情况组成：</p>
<ol>
<li>当信号量中剩余的资源大于获取的资源并且没有等待的 Goroutine 时就会直接获取信号量；</li>
<li>当需要获取的信号量大于 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 的上限时，由于不可能满足条件就会直接返回错误；</li>
<li>遇到其他情况时会将当前 Goroutine 加入到等待列表并通过 <code>select</code> 等待调度器唤醒当前 Goroutine，Goroutine 被唤醒后就会获取信号量；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		s.cur += n</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">	elem := s.waiters.PushBack(w)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		err := ctx.Err()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ready:</span><br><span class="line">			err = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			s.waiters.Remove(elem)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> &lt;-ready:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个用于获取信号量的方法 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 只会非阻塞地判断当前信号量是否有充足的资源，如果有充足的资源就会直接立刻返回 <code>true</code>，否则就会返回 <code>false</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">TryAcquire</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> success &#123;</span><br><span class="line">		s.cur += n</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 不会等待资源的释放，所以可能更适用于一些延时敏感、用户需要立刻感知结果的场景。</p>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>当我们要释放信号量时，<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法会从头到尾遍历 <code>waiters</code> 列表中全部的等待者，如果释放资源后的信号量有充足的剩余资源就会通过 Channel 唤起指定的 Goroutine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.cur -= n</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		next := s.waiters.Front()</span><br><span class="line">		<span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		w := next.Value.(waiter)</span><br><span class="line">		<span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.cur += w.n</span><br><span class="line">		s.waiters.Remove(next)</span><br><span class="line">		<span class="built_in">close</span>(w.ready)</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可能会出现剩余资源无法唤起 Goroutine 的情况，在这时当前方法就会释放锁后直接返回。</p>
<p>通过对 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法的分析我们能发现，如果一个信号量需要的占用的资源非常多，它可能会长时间无法获取锁，这也是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 方法引入上下文参数的原因，为信号量的获取设置超时时间。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>带权重的信号量确实有着更多的应用场景，这也是 Go 语言对外提供的唯一一种信号量实现，在使用的过程中我们需要注意以下的几个问题：</p>
<ul>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 方法都可以用于获取资源，前者会阻塞地获取信号量，后者会非阻塞地获取信号量；</li>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法会按照 FIFO 的顺序唤醒可以被唤醒的 Goroutine；</li>
<li>如果一个 Goroutine 获取了较多地资源，由于 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 的释放策略可能会等待比较长的时间；</li>
</ul>
<h3 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h3><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 是 Go 语言扩展包中提供了另一种同步原语，它能够在一个服务中抑制对下游的多次重复请求。一个比较常见的使用场景是 — 我们在使用 Redis 对数据库中的数据进行缓存，发生缓存击穿时，大量的流量都会打到数据库上进而影响服务的尾延时。</p>
<p><img alt="golang-query-without-single-flight" data-src="https://img.draveness.me/2020-01-23-15797104328070-golang-query-without-single-flight.png"></p>
<p><strong>图 6-12 Redis 缓存击穿问题</strong></p>
<p>但是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 能有效地解决这个问题，它能够限制对同一个 <code>Key</code> 的多次重复请求，减少对下游的瞬时流量。</p>
<p><img alt="golang-extension-single-flight" data-src="https://img.draveness.me/2020-01-23-15797104328078-golang-extension-single-flight.png"></p>
<p><strong>图 6-13 缓解缓存击穿问题</strong></p>
<p>在资源的获取非常昂贵时（例如：访问缓存、数据库），就很适合使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 对服务进行优化。我们来了解一下它的使用方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    requestGroup singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context, request Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    v, err, _ := requestGroup.Do(request.Hash(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        rows, err := <span class="comment">// select * from tables</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response&#123;</span><br><span class="line">        rows: rows,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为请求的哈希在业务上一般表示相同的请求，所以上述代码使用它作为请求的键。当然，我们也可以选择其他的唯一字段作为 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 方法的第一个参数减少重复的请求。</p>
<h4 id="结构体-6"><a href="#结构体-6" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 结构体由一个互斥锁<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 和一个映射表组成，每一个 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体都保存了当前调用对应的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	dups  <span class="keyword">int</span></span><br><span class="line">	chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体中的 <code>val</code> 和 <code>err</code> 字段都只会在执行传入的函数时赋值一次并在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 返回时被读取；<code>dups</code> 和 <code>chans</code> 两个字段分别存储了抑制的请求数量以及用于同步结果的 Channel。</p>
<h4 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 提供了两个用于抑制相同请求的方法：</p>
<ul>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> — 同步等待的方法 <code>Do</code>；</li>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> — 返回 Channel 异步等待的方法；</li>
</ul>
<p>这两个方法在功能上没有太多的区别，只是在接口的表现上稍有不同。</p>
<p>每次调用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 方法时都会获取互斥锁，随后判断是否已经存在 <code>key</code> 对应的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体：</p>
<ol>
<li>当不存在对应的</li>
</ol>
<p>   <code>x/sync/singleflight.call</code></p>
<p>   时：</p>
<ol>
<li>初始化一个新的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体指针；</li>
<li>增加 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 持有的计数器；</li>
<li>将 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体指针添加到映射表；</li>
<li>释放持有的互斥锁；</li>
<li>阻塞地调用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 方法等待结果的返回；</li>
</ol>
<ol>
<li>当存在对应的</li>
</ol>
<p>   <code>x/sync/singleflight.call</code></p>
<p>   时；</p>
<ol>
<li>增加 <code>dups</code> 计数器，它表示当前重复的调用次数；</li>
<li>释放持有的互斥锁；</li>
<li>通过 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 等待请求的返回；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.dups++</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		c.wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	g.doCall(c, key, fn)</span><br><span class="line">	<span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>val</code> 和 <code>err</code> 两个字段都只会在 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 方法中赋值，所以当 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 返回时，函数调用的结果和错误都会返回给 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 函数的调用者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">doCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line">	c.wg.Done()</span><br><span class="line"></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(g.m, key)</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">		ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>运行传入的函数 <code>fn</code>，该函数的返回值就会赋值给 <code>c.val</code> 和 <code>c.err</code>；</li>
<li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 方法通知所有等待结果的 Goroutine — 当前函数已经执行完成，可以从 <code>call</code> 结构体中取出返回值并返回了；</li>
<li>获取持有的互斥锁并通过管道将信息同步给使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 方法的 Goroutine；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">DoChan</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) &lt;-<span class="title">chan</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.dups++</span><br><span class="line">		c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 方法分别提供了同步和异步的调用方式，这让我们使用起来也更加灵活。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>当我们需要减少对下游的相同请求时，就可以使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 来增加吞吐量和服务质量，不过在使用的过程中我们也需要注意以下的几个问题：</p>
<ul>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 一个用于同步阻塞调用传入的函数，一个用于异步调用传入的参数并通过 Channel 接收函数的返回值；</li>
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L113-L120" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Forget</code></a> 方法可以通知 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 在持有的映射表中删除某个键，接下来对该键的调用就不会等待前面的函数返回了；</li>
<li>一旦调用的函数返回了错误，所有在等待的 Goroutine 也都会接收到同样的错误；</li>
</ul>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>我们在这一节中介绍了 Go 语言标准库中提供的基本原语以及扩展包中的扩展原语，这些并发编程的原语能够帮助我们更好地利用 Go 语言的特性构建高吞吐量、低延时的服务、解决并发带来的问题。</p>
<p>在设计同步原语时，我们不仅要考虑 API 接口的易用、解决并发编程中可能遇到的线程竞争问题，还需要对尾延时进行、优化保证公平性，理解同步原语也是我们理解并发编程无法跨越的一个步骤。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li>“sync: allow inlining the Mutex.Lock fast path” <a href="https://github.com/golang/go/commit/41cb0aedffdf4c5087de82710c4d016a3634b4ac" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/commit/41cb0aedffdf4c5087de82710c4d016a3634b4ac</a></li>
<li>“sync: allow inlining the Mutex.Unlock fast path” <a href="https://github.com/golang/go/commit/4c3f26076b6a9853bcc3c7d7e43726c044ac028a#diff-daec021895d1400f2c064a3e851c0d2c" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/commit/4c3f26076b6a9853bcc3c7d7e43726c044ac028a#diff-daec021895d1400f2c064a3e851c0d2c</a></li>
<li>“runtime: fall back to fair locks after repeated sleep-acquire failures” <a href="https://github.com/golang/go/issues/13086" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/issues/13086</a></li>
<li>Go Team. May 2014. “The Go Memory Model” <a href="https://golang.org/ref/mem" target="_blank" rel="external nofollow noopener noreferrer">https://golang.org/ref/mem</a></li>
<li>Chris. May 2017. “The X-Files: Exploring the Golang Standard Library Sub-Repositories” <a href="https://rodaine.com/2017/05/x-files-intro/" target="_blank" rel="external nofollow noopener noreferrer">https://rodaine.com/2017/05/x-files-intro/</a></li>
</ul>
]]></content>
      <categories>
        <category>术业专攻</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>源码阅读</tag>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
