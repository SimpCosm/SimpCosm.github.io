<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-07-22T03:36:13.948Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【备忘录】Linux常见监控指标</title>
    <link href="http://houmin.cc/posts/7f85cd98/"/>
    <id>http://houmin.cc/posts/7f85cd98/</id>
    <published>2020-07-21T09:19:53.000Z</published>
    <updated>2020-07-22T03:36:13.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。</p><a id="more"></a><h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><p>CPU使用率衡量的是<strong>程序运行占用的CPU百分比</strong>。Linux的CPU使用率信息可以通过/proc/stat文件计算得到。<code>/proc/stat</code>包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计的，单位为jiffies。如下图所示，cpu一行指的是总的CPU信息，cpu0、cpu1、cpu2、cpu3几行指的是CPU各个核的CPU信息。从这里也可以看出这台服务器共有4个核。每列从左到右的<a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external nofollow noopener noreferrer">意思</a>为</p><ul><li><strong>user：</strong>从系统启动开始累计到当前时刻，用户态的CPU时间 ，不包含nice值为负进程所占用的时间</li><li><strong>nice：</strong>从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间</li><li><strong>system：</strong>从系统启动开始累计到当前时刻，内核态时间</li><li><strong>idle：</strong>从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间</li><li><strong>iowait：</strong>从系统启动开始累计到当前时刻，硬盘IO等待时间</li><li><strong>irq：</strong>从系统启动开始累计到当前时刻，硬中断时间</li><li><strong>softirq：</strong>从系统启动开始累计到当前时刻，软中断时间</li><li><strong>steal：</strong>在虚拟环境下 CPU 花在处理其他操作系统的时间，Linux 2.6.11 开始才开始支持。</li><li><strong>guest：</strong>在 Linux 内核控制下 CPU 为 guest 操作系统运行虚拟 CPU 的时间，Linux 2.6.24 开始才开始支持。</li><li><strong>guest_nice:</strong> 在 Linux 内核控制下 CPU 为 guest 操作系统在虚拟 CPU 中运行nice进程的时间，Linux 2.6.33 开始才开始支持。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/<span class="built_in">stat</span> | grep cpu</span><br><span class="line">cpu  180296 204 123070 30283108 13956 0 2046 0 0 0</span><br><span class="line">cpu0 45360 53 30785 7560073 10631 0 771 0 0 0</span><br><span class="line">cpu1 45266 47 30779 7573915 1373 0 508 0 0 0</span><br><span class="line">cpu2 44442 54 30724 7574282 1257 0 405 0 0 0</span><br><span class="line">cpu3 45228 48 30781 7574835 693 0 360 0 0 0</span><br></pre></td></tr></table></figure><p>根据这些信息，就可以计算出CPU使用率。网管Agent的CPU使用率采集算法如下（以CPU0为例）：</p><ul><li>cat /proc/stat | grep ‘cpu0’得到cpu0的信息</li><li>cpu_total1=user+nice+system+idle+iowait+irq+softirq</li><li>cpu_used1=user+nice+system+irq+softirq</li><li>sleep 15秒</li><li>再次cat /proc/stat | grep ‘cpu0’得到cpu的信息</li><li>cpu_total2=user+nice+system+idle+iowait+irq+softirq</li><li>cpu_used2=user+nice+system+irq+softirq</li><li>得到cpu0在15秒内的平均使用率：(cpu_used2 - cpu_used1) / (cpu_total2 - cpu_total1) * 100%</li></ul><p>每分钟会采集4次15秒内的CPU平均使用率。为了避免漏采集CPU峰值，可以取这一分钟内四次采集的最大值上报。</p><h2 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h2><p>系统负载指的是计算机系统执行计算工作的表现，CPU负载指的是在一段时间内计算机的系统负载，一般用1分钟内、5分钟内、15分钟内这三个数字衡量。通过<code>uptime</code>命令可以显示CPU负载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 14:34:03 up 10:43,  4 users,  load average: 0.06, 0.11, 0.09</span><br></pre></td></tr></table></figure><ul><li>对于单核单CPU，CPU负载为0表示CPU完全空闲，CPU负载为1.00表示CPU恰好发挥其最大能力，CPU负载大于1表示系统过载，有进程正在等待调度</li><li>对于多核或者多CPU系统，CPU负载为每个核的CPU负载总和</li></ul><p>关于CPU负载的计算机制，可以参考我的另一篇<a href="../">博客</a>。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p> <code>free</code>命令通过读取 <code>/proc/meminfo</code>，可以显示系统中的使用的和空闲的物理内存、Swap内存，同时也可以显示内核使用的buffer和cache，如下图所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free -w</span><br><span class="line">              total        used        free      shared     buffers       cache   available</span><br><span class="line">Mem:        7773244      311800     2456280         872      233560     4771604     7169352</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>其中各个字段意义为：</p><ul><li>total：所有可以使用的内存（包括/proc/meminfo中的MemTotal和SwapTotal）</li><li>used：使用的内存，通过 <code>total - free - buffers - cache</code> 计算得到</li><li>free：没有使用的内存（包括/proc/meminfo中的MemFree和SwapFree）</li><li>shared：主要是指tmpfs使用的内存，现在已经废弃不用，总是为0</li><li>buffers：被内核Buffers使用的内存</li><li>cache：被内核的Page Cache和Slab使用的内存</li><li>buff/cache：buffers和cache的总和</li><li>available：对于开启一个新的应用还能使用多少内存的估计，不同于cache和free内存外，还考虑了page cache和可再回收的slab内存</li></ul><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p>可以通过 <code>iostat</code>命令来监测磁盘的IO活动，它通过读取 <code>/proc/diskstats</code>文件来获取相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/diskstats</span></span><br><span class="line">3    0   hda 446216 784926 9550688 4382310 424847 312726 5922052 19310380 0 3376340 23705160 0 0 0 0</span><br></pre></td></tr></table></figure><p>hda后的各个参数含义如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Field</span>  <span class="number">1</span> --<span class="meta"> # of reads completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">2</span> --<span class="meta"> # of reads merged, field 6 -- # of writes merged</span></span><br><span class="line">为了提高IO的效率，两个相邻的读写操作会被合并，所以两个<span class="number">4</span>K的读操作在提交给磁盘之前会被合并为一个<span class="number">8</span>K的读操作，杜宇磁盘来说只会视作只有一个读操作。</span><br><span class="line"><span class="keyword">Field</span>  <span class="number">3</span> --<span class="meta"> # of sectors read</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">4</span> --<span class="meta"> # of milliseconds spent reading</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">5</span> --<span class="meta"> # of writes completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">6</span> --<span class="meta"> # of writes merged</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">7</span> --<span class="meta"> # of sectors written</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">8</span> --<span class="meta"> # of milliseconds spent writing</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">9</span> --<span class="meta"> # of I/Os currently in progress</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">10</span> --<span class="meta"> # of milliseconds spent doing I/Os</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">12</span> --<span class="meta"> # of discards completed</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">13</span> --<span class="meta"> # of discards merged</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">14</span> --<span class="meta"> # of sectors discarded</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">15</span> --<span class="meta"> # of milliseconds spent discarding</span></span><br></pre></td></tr></table></figure><p>跟记录CPU信息的/proc/stat文件一样，/proc/diskstats中每个字段的数值也是从系统启动后一直累加的。通过这些参数，可以计算出通过 <code>iostat</code>命令算出的参数，具体可以参考<a href="../#iostat">iostat</a> 。我们用delta来表示在时间t内某个字段的增量。例如<strong>定义delta(reads merged)为当前reads merged的值减去t秒前reads merged的值</strong>。</p><ul><li>rrqm/s：delta(<em>reads merged</em>) / t  （得到时间t内平均每秒reads merged的值）</li><li>wrqm/s：delta(<em>writes merged</em>) / t</li><li>r/s：delta(<em>reads completed</em>) / t</li><li>w/s：delta(<em>writes completed</em>) / t</li><li>rsec/s：delta(<em>sectors read</em>) / t</li><li>wsec/s：delta(<em>sectors written</em>) / t</li><li>rkB/s：delta(<em>sectors read</em>) / t / 2  （因为1 扇区为512字节，所以rkB/s为rsec/s的一半）</li><li>wkB/s：delta(<em>sectors written</em>) / t / 2</li><li>avgrq-sz：(delta(<em>sectors read</em>) + delta(<em>sectors written</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li><li><strong>avgqu-sz</strong>：<em>*delta(</em>weighted time spent doing I/Os*) / t / 1000 （单位为毫秒，所以除以1000）</li><li><strong>await：</strong>(delta(<em>time spent reading</em>) + delta(<em>time spent writing</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li><li><strong>svctm：</strong>delta(<em>time spent doing I/Os</em>)/ (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))**</li><li><strong>%util：</strong>delta(<em>time spent doing I/Os</em>) / t / 1000 * 100%</li></ul><p>所有磁盘汇总采集项：</p><div class="table-container"><table><thead><tr><th>采集项</th><th>采集项说明</th><th>是否乘以100以保留精度</th></tr></thead><tbody><tr><td>avgqu_sz_max</td><td>所有磁盘avgqu_sz最大值</td><td>是</td></tr><tr><td>svctm_time_max</td><td>所有磁盘svctm最大值</td><td>是</td></tr><tr><td>await_time_max</td><td>所有磁盘await最大值</td><td>是</td></tr><tr><td>util_max</td><td>所有磁盘%util最大值</td><td>否</td></tr><tr><td>disk_total_read</td><td>所有磁盘的r/s总和</td><td>是</td></tr><tr><td>disk_total_write</td><td>所有磁盘的w/s总和</td><td>是</td></tr><tr><td>磁盘IO disk_block_in</td><td>所有磁盘的rkB/s总和。bi即block in，表示从块设备（如磁盘）读取的块数。Linux块设备的块大小都为1024字节，所以disk_bi等于rkB/s。</td><td>否</td></tr><tr><td>磁盘IO disk_block_out</td><td>所有磁盘的rkB/s总和bo即block out，表示发给块设备的块数，即写磁盘。Linux块设备的块大小都为1024字节，所以disk_bi等于wkB/s。</td><td>否</td></tr></tbody></table></div><p>单个磁盘采集项：</p><p>对于安装了1个以上的磁盘的服务器，可以采集单个磁盘的IO数据。最多支持24个盘。</p><div class="table-container"><table><thead><tr><th>采集项</th><th>采集项说明</th><th>是否乘以100以保留精度</th></tr></thead><tbody><tr><td>disk_n_util（n为0-23）</td><td>第n个磁盘的%util值</td><td>否</td></tr><tr><td>disk_n_await</td><td>第n个磁盘的await值</td><td>是</td></tr><tr><td>disk_n_read</td><td>第n个磁盘的r/s值</td><td>是</td></tr><tr><td>disk_n_write</td><td>第n个磁盘的w/s值</td><td>是</td></tr><tr><td>disk_n_block_in</td><td>第n个磁盘的rkB/s值</td><td>否</td></tr><tr><td>disk_n_block_out</td><td>第n个磁盘的wkB/s值</td><td>否</td></tr></tbody></table></div><h2 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h2><h3 id="流量包量"><a href="#流量包量" class="headerlink" title="流量包量"></a>流量包量</h3><p>通过<code>/proc/net/dev</code>文件，可以计算出服务器的流量及包量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/dev</span></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   69570    1756    0    0    0     0          0         0    69570    1756    0    0    0     0       0          0</span><br><span class="line">  eth0: 2012939491 4197833    0    0    0     0          0         0 277523863 3280731    0    0    0     0       0          0</span><br><span class="line">docker0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0</span><br></pre></td></tr></table></figure><p>与记录CPU信息的 <code>/proc/stat</code>文件类似，<code>/proc/net/dev</code>中的数值，也是从系统启动后一直累加的。</p><p>计算网卡流量方法如下：</p><ul><li>读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes0、receive_packets0、transmit_bytes0、transmit_packets0</li><li>sleep 60秒</li><li>再次读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes1、receive_packets1、transmit_bytes1、transmit_packets1</li><li>根据60秒前后的/proc/net/dev文件，便可计算出下面的指标：<ul><li>60秒内平均每秒入流量：(receive_bytes1 - receive_bytes0) * 8 / 60 / 1000 （kbps）（乘以8是为了把bytes转成bit，除以1000是为了把单位转成k，除以60则是取60秒内的平均值）</li><li>60 秒内平均每秒出流量：(transmit_bytes1 - transmit_bytes0) * 8 / 60 / 1000 （kbps）</li><li>60秒内平均每秒入包数：(receive_packets1 - receive_packets0) / 60 （个）</li><li>60秒内平均每秒出包数：(transmit_packets1 - transmit_packets0) / 60 （个）</li></ul></li></ul><h3 id="TCP连接数"><a href="#TCP连接数" class="headerlink" title="TCP连接数"></a>TCP连接数</h3><p><code>/proc/net/snmp</code>记录了一些TCP信息，其中比较有用的是 <code>CurrEstab</code>字段，即当前已建立的TCP连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/snmp</span></span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 3527912 0 23 1893737 0 0 1634151 3266670 18 40 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 92566 32 0 65 0 0 0 0 92501 0 0 0 0 0 93265 0 746 0 0 0 18 0 92501 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType8 OutType0 OutType3 OutType5</span><br><span class="line">IcmpMsg: 65 92501 92501 746 18</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 65567 687 59 249 8 1516787 1268763 805 4 33191 4</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">Udp: 22034 822 0 21968 0 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="UDP接收和发送数据报"><a href="#UDP接收和发送数据报" class="headerlink" title="UDP接收和发送数据报"></a>UDP接收和发送数据报</h3><p><code>/proc/net/snmp</code>还记录了一些UDP信息，其中比较有用的是<code>InDatagrams</code>及<code>OutDatagrams</code>字段。 </p><p>UDP接收和发送数据报计算方法与 <code>/proc/net/dev</code>类似，步骤如下：</p><ul><li>读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data0和out_data0</li><li>Sleep 240秒</li><li>再次读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data1和out_data1</li><li>根据240秒前后的/proc/net/snmp文件，便可计算下面两个指标：<ul><li>240秒内平均每秒UDP入数据报：(in_data1 - in_data0) / 240</li><li>240秒内平均每秒UDP出数据报：(out_data1 - out_data0) / 240</li></ul></li><li>UDP数据每240上报一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://upload.wikimedia.org/wikipedia/commons/b/b1/Htop.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="linux" scheme="http://houmin.cc/tags/linux/"/>
    
      <category term="stats" scheme="http://houmin.cc/tags/stats/"/>
    
      <category term="monitor" scheme="http://houmin.cc/tags/monitor/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】List/Watch机制和Informer模块详解</title>
    <link href="http://houmin.cc/posts/1f0eb2ff/"/>
    <id>http://houmin.cc/posts/1f0eb2ff/</id>
    <published>2020-07-20T07:46:29.000Z</published>
    <updated>2020-07-21T02:16:52.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。</p><a id="more"></a><h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>Kubernetes中的组件，如果要访问Kubernetes中的Object，绝大部分情况下会使用Informer中的Lister()方法，而非直接请求Kubernetes API。</p><h1 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h1><p><img alt="img" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png"></p><p><img alt="Client-go Controller Interaction" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p><h2 id="client-go组件"><a href="#client-go组件" class="headerlink" title="client-go组件"></a>client-go组件</h2><ul><li><code>Reflector</code>：reflector用来watch特定的k8s API资源。具体的实现是通过<code>ListAndWatch</code>的方法，watch可以是k8s内建的资源或者是自定义的资源。当reflector通过watch API接收到有关新资源实例存在的通知时，它使用相应的列表API获取新创建的对象，并将其放入watchHandler函数内的Delta Fifo队列中。</li><li><code>Informer</code>：informer从Delta Fifo队列中弹出对象。执行此操作的功能是processLoop。base controller的作用是保存对象以供以后检索，并调用我们的控制器将对象传递给它。</li><li><code>Indexer</code>：索引器提供对象的索引功能。典型的索引用例是基于对象标签创建索引。 Indexer可以根据多个索引函数维护索引。Indexer使用线程安全的数据存储来存储对象及其键。 在Store中定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数生成对象的键作为该对象的<code>&lt;namespace&gt; / &lt;name&gt;</code>组合。</li></ul><h2 id="自定义controller组件"><a href="#自定义controller组件" class="headerlink" title="自定义controller组件"></a>自定义controller组件</h2><ul><li><code>Informer reference</code>：指的是Informer实例的引用，定义如何使用自定义资源对象。 自定义控制器代码需要创建对应的Informer。</li><li><code>Indexer reference</code>: 自定义控制器对Indexer实例的引用。自定义控制器需要创建对应的Indexser。</li></ul><blockquote><p>client-go中提供<code>NewIndexerInformer</code>函数可以创建Informer 和 Indexer。</p></blockquote><ul><li><code>Resource Event Handlers</code>：资源事件回调函数，当它想要将对象传递给控制器时，它将被调用。 编写这些函数的典型模式是获取调度对象的key，并将该key排入工作队列以进行进一步处理。</li><li><code>Workqueue</code>：任务队列。 编写资源事件处理程序函数以提取传递的对象的key并将其添加到任务队列。</li><li><code>Process Item</code>：处理任务队列中对象的函数， 这些函数通常使用Indexer引用或Listing包装器来重试与该key对应的对象。</li></ul><h1 id="关键设计"><a href="#关键设计" class="headerlink" title="关键设计"></a>关键设计</h1><p>Informer依赖Kubernetes的List/Watch API。 通过Lister()对象来List/Get对象时，Informer不会去请求Kubernetes API，而是直接查询本地缓存，减少对Kubernetes API的直接调用。</p><p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p><p>Informer组件：</p><ul><li>Controller</li><li>Reflector：通过Kubernetes Watch API监听resource下的所有事件</li><li>Lister：用来被调用List/Get方法</li><li>Processor：记录并触发回调函数</li><li>DeltaFIFO</li><li>LocalStore</li></ul><p>DeltaFIFO和LocalStore是Informer的两级缓存。 DeltaFIFO：用来存储Watch API返回的各种事件。 LocalStore：Lister的List/Get方法访问。</p><p>我们以 Pod 为例，详细说明一下 Informer 的关键逻辑：</p><ol><li>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</li><li>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</li><li>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</li><li>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</li><li>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</li><li>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</li><li>DeltaFIFO 再 Pop 这个事件到 Controller 中</li><li>Controller 收到这个事件，会触发 Processor 的回调函数</li></ol><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737350162-8e7c6121-2b0a-49fa-8ad8-a7b714de3445.png"></p><p>之前说到kubernetes里面的apiserver的只负责数据的CRUD接口实现，并不负责业务逻辑的处理，所以k8s中就通过外挂controller通过对应资源的控制器来负责事件的处理，controller如何感知事件呢？答案就是informer</p><h2 id="基于chunk的消息通知"><a href="#基于chunk的消息通知" class="headerlink" title="基于chunk的消息通知"></a>基于chunk的消息通知</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737386982-feae09ae-ac6d-4090-8ca2-d2f3f5120d61.png"></p><p>watcher的设计在之前的文章中已经介绍，服务端是如何将watcher感知到的事件发送给informer呢？我们提到过apiserver本质上就是一个http的rest接口实现，watch机制则也是基于http协议，不过不同于一般的get其通过chunk机制，来实现消息的通知</p><h2 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737435884-518fce5a-0118-4935-be61-0716e2c3ba0c.png"></p><p>服务端通过chunk进行数据的发送，在客户端同样的需要根据对应的chunk来进行数据的解包，同时还要维护这个长链接</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737496494-8a3052e1-7837-46d9-9513-8d3a64ffe8ba.png"></p><p>通过listwatch接口主要分为两部分，list接口我们可以获取到对应资源当前版本的全量资源，watch接口可以获取到后续变更的资源，通过全量加增量的数据，就构成了在client端一份完整的数据(基于当前版本的)，那后续如果要获取对应的数据，就直接可以通过本地的缓存来进行获取，为此informer抽象了cache这个组件，并且实现了store接口，如果后续要获取资源，则就可以通过本地的缓存来进行获取</p><h2 id="本地索引"><a href="#本地索引" class="headerlink" title="本地索引"></a>本地索引</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737549651-a3636652-fc91-49e1-a91e-9f5e18b05672.png"></p><p>上面将资源缓存在本地的内存中，那如果我们要进行数据查询，快速检索数据，这个时候就需要用到informer里面的indexer, 我们可以注册不同的索引函数，在添加对象的时候，会通过indexer为其建立对应的索引，这样后续我们就可以通过key来检索获取元数据</p><h2 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737669393-995cf89c-87f6-4749-9086-b9febee3a692.png"></p><p>为了协调数据生产与消费的不一致状态，在cleint-go中通过实现了一个无界队列来进行数据的缓冲，当reflector获取到数据之后，只需要将数据写入到无界队列中，则就可以继续watch后续事件，从而减少阻塞时间， 下面的事件去重也是在该队列中实现的</p><h2 id="事件去重"><a href="#事件去重" class="headerlink" title="事件去重"></a>事件去重</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737745807-e10d9521-5633-4cf7-9a0f-90ce2a3dee46.png"></p><p>事件去重是指的，在上面的无界队列中，如果针对某个资源的事件重复被触发，则就只会保留相同事件最后一个事件作为后续处理</p><p>到此对于事件接收和数据缓存相关优化就结束了，接下就是处理层的优化</p><h2 id="复用连接"><a href="#复用连接" class="headerlink" title="复用连接"></a>复用连接</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737835151-715cdc2b-b53a-4208-85d8-2383fdef8b8f.png"></p><p>在k8s中一些控制器可能会关注多种资源，比如Deployment可能会关注Pod和replicaset，replicaSet可能还会关注Pod，为了避免每个控制器都独立的去与apiserver建立链接，k8s中抽象了sharedInformer的概念，即共享的informer, 针对同一资源只建立一个链接</p><h2 id="基于观察者模式的注册"><a href="#基于观察者模式的注册" class="headerlink" title="基于观察者模式的注册"></a>基于观察者模式的注册</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738078512-ade28ada-2824-46d3-af63-45873a8a37a4.png"></p><p>因为彼此共用informer,但是每个组件的处理逻辑可能各部相同，在informer中通过观察者模式，各个组件可以注册一个EventHandler来实现业务逻辑的注入</p><h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738429252-bd646701-8543-47cd-a638-552ac419f5c9.png"></p><h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>该部分的代码主要位于<code>client-go</code>这个第三方包中。</p><p>此部分的逻辑主要位于<code>/vendor/k8s.io/client-go/tools/cache</code>包中，代码目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cache</span><br><span class="line">├── controller.go  <span class="comment"># 包含：Config、Run、processLoop、NewInformer、NewIndexerInformer</span></span><br><span class="line">├── delta_fifo.go  <span class="comment"># 包含：NewDeltaFIFO、DeltaFIFO、AddIfNotPresent</span></span><br><span class="line">├── expiration_cache.go</span><br><span class="line">├── expiration_cache_fakes.go</span><br><span class="line">├── fake_custom_store.go</span><br><span class="line">├── fifo.go   <span class="comment"># 包含：Queue、FIFO、NewFIFO</span></span><br><span class="line">├── heap.go</span><br><span class="line">├── index.go    <span class="comment"># 包含：Indexer、MetaNamespaceIndexFunc</span></span><br><span class="line">├── listers.go</span><br><span class="line">├── listwatch.go   <span class="comment"># 包含：ListerWatcher、ListWatch、List、Watch</span></span><br><span class="line">├── mutation_cache.go</span><br><span class="line">├── mutation_detector.go</span><br><span class="line">├── reflector.go   <span class="comment"># 包含：Reflector、NewReflector、Run、ListAndWatch</span></span><br><span class="line">├── reflector_metrics.go</span><br><span class="line">├── shared_informer.go  <span class="comment"># 包含：NewSharedInformer、WaitForCacheSync、Run、HasSynced</span></span><br><span class="line">├── store.go  <span class="comment"># 包含：Store、MetaNamespaceKeyFunc、SplitMetaNamespaceKey</span></span><br><span class="line">├── testing</span><br><span class="line">│   ├── fake_controller_source.go</span><br><span class="line">├── thread_safe_store.go  <span class="comment"># 包含：ThreadSafeStore、threadSafeMap</span></span><br><span class="line">├── undelta_store.go</span><br></pre></td></tr></table></figure><h2 id="sharedInformerFactory-Start"><a href="#sharedInformerFactory-Start" class="headerlink" title="sharedInformerFactory.Start"></a>sharedInformerFactory.Start</h2><p>在controller-manager的Run函数部分调用了InformerFactory.Start的方法。</p><blockquote><p>此部分代码位于/cmd/kube-controller-manager/app/controllermanager.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">        <span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InformerFactory是一个<code>SharedInformerFactory</code>的接口，接口定义如下：</p><blockquote><p>此部分代码位于vendor/k8s.io/client-go/informers/internalinterfaces/factory_interfaces.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SharedInformerFactory a small interface to allow for adding an informer without an import cycle</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    InformerFor(obj runtime.Object, newFunc NewInformerFunc) cache.SharedIndexInformer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。其中，通过<code>startdInformers</code>这个map用来追踪有哪些Informer已经启动，从而可以让Start方法被多次调用。</p><blockquote><p>此部分代码位于vendor/k8s.io/client-go/informers/factory.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">        <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">            <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">            f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sharedIndexInformer-Run"><a href="#sharedIndexInformer-Run" class="headerlink" title="sharedIndexInformer.Run"></a>sharedIndexInformer.Run</h2><blockquote><p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/shared_informer.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ListerWatcher:    s.listerWatcher,</span><br><span class="line">        ObjectType:       s.objectType,</span><br><span class="line">        FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">        RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">        Process: s.HandleDeltas,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">        s.controller = New(cfg)</span><br><span class="line">        s.controller.(*controller).clock = s.clock</span><br><span class="line">        s.started = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">    processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">        s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">    &#125;()</span><br><span class="line">    s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDeltaFIFO"><a href="#NewDeltaFIFO" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><p>DeltaFIFO是一个对象变化的存储队列，依据先进先出的原则，process的函数接收该队列的Pop方法的输出对象来处理相关功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>构造controller的配置文件，构造process，即HandleDeltas，该函数为后面使用到的process函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>调用New(cfg)，构建sharedIndexInformer的controller。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">    s.controller = New(cfg)</span><br><span class="line">    s.controller.(*controller).clock = s.clock</span><br><span class="line">    s.started = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="cacheMutationDetector-Run"><a href="#cacheMutationDetector-Run" class="headerlink" title="cacheMutationDetector.Run"></a>cacheMutationDetector.Run</h3><p>调用s.cacheMutationDetector.Run，检查缓存对象是否变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br></pre></td></tr></table></figure><p><strong>defaultCacheMutationDetector.Run</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we DON'T want protection from panics.  If we're running this code, we want to die</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d.CompareObjects()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(d.period):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CompareObjects</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">CompareObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> d.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    altered := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, obj := <span class="keyword">range</span> d.cachedObjs &#123;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(obj.cached, obj.copied) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"CACHE %s[%d] ALTERED!\n%v\n"</span>, d.name, i, diff.ObjectDiff(obj.cached, obj.copied))</span><br><span class="line">            altered = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> altered &#123;</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"cache %s modified"</span>, d.name)</span><br><span class="line">        <span class="keyword">if</span> d.failureFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">            d.failureFunc(msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processor-run"><a href="#processor-run" class="headerlink" title="processor.run"></a>processor.run</h3><p>调用s.processor.run，将调用sharedProcessor.run，会调用Listener.run和Listener.pop,执行处理queue的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.processor.run)</span><br></pre></td></tr></table></figure><p><strong>sharedProcessor.Run</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.listenersLock.RLock()</span><br><span class="line">        <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            p.wg.Start(listener.run)</span><br><span class="line">            p.wg.Start(listener.pop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">        <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分逻辑待后面分析。</p><h3 id="controller-Run"><a href="#controller-Run" class="headerlink" title="controller.Run"></a>controller.Run</h3><p>调用s.controller.Run，构建Reflector，进行对etcd的缓存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">    s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">&#125;()</span><br><span class="line">s.controller.Run(stopCh)</span><br></pre></td></tr></table></figure><p>controller.Run</p><blockquote><p>此部分代码位于/vendor/k8s.io/client-go/tools/cache/controller.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins processing items, and will continue until a value is sent down stopCh.</span></span><br><span class="line"><span class="comment">// It's an error to call Run more than once.</span></span><br><span class="line"><span class="comment">// Run blocks; call via go.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        c.config.Queue.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    r.ShouldResync = c.config.ShouldResync</span><br><span class="line">    r.clock = c.clock</span><br><span class="line"></span><br><span class="line">    c.reflectorMutex.Lock()</span><br><span class="line">    c.reflector = r</span><br><span class="line">    c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line"></span><br><span class="line">    wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建Reflector</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">    c.config.ListerWatcher,</span><br><span class="line">    c.config.ObjectType,</span><br><span class="line">    c.config.Queue,</span><br><span class="line">    c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 运行Reflector</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"><span class="comment">// 执行processLoop</span></span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br></pre></td></tr></table></figure><h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><h3 id="Reflector-1"><a href="#Reflector-1" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p><p>常用属性说明：</p><ul><li>expectedType：期望放入缓存store的资源类型。</li><li>store：watch的资源对应的本地缓存。</li><li>listerWatcher：list和watch的接口。</li><li>period：watch的周期，默认为1秒。</li><li>resyncPeriod：resync的周期，当非零的时候，会按该周期执行list。</li><li>lastSyncResourceVersion：最新一次看到的资源的版本号，主要在watch时候使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflector watches a specified resource and causes all changes to be reflected in the given store.</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">    metrics *reflectorMetrics</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The type of object we expect to place in the store.</span></span><br><span class="line">    expectedType reflect.Type</span><br><span class="line">    <span class="comment">// The destination to sync up with the watch source</span></span><br><span class="line">    store Store</span><br><span class="line">    <span class="comment">// listerWatcher is used to perform lists and watches.</span></span><br><span class="line">    listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// period controls timing between one watch ending and</span></span><br><span class="line">    <span class="comment">// the beginning of the next one.</span></span><br><span class="line">    period       time.Duration</span><br><span class="line">    resyncPeriod time.Duration</span><br><span class="line">    ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// lastSyncResourceVersion is the resource version token last</span></span><br><span class="line">    <span class="comment">// observed when doing a sync with the underlying store</span></span><br><span class="line">    <span class="comment">// it is thread safe, but not synchronized with the underlying store</span></span><br><span class="line">    lastSyncResourceVersion <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">    lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewReflector"><a href="#NewReflector" class="headerlink" title="NewReflector"></a>NewReflector</h3><p>NewReflector主要用来构建Reflector的结构体。</p><blockquote><p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/reflector.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReflector creates a new Reflector object which will keep the given store up to</span></span><br><span class="line"><span class="comment">// date with the server's contents for the given resource. Reflector promises to</span></span><br><span class="line"><span class="comment">// only put things in the store that have the type of expectedType, unless expectedType</span></span><br><span class="line"><span class="comment">// is nil. If resyncPeriod is non-zero, then lists will be executed after every</span></span><br><span class="line"><span class="comment">// resyncPeriod, so that you can use reflectors to periodically process everything as</span></span><br><span class="line"><span class="comment">// well as incrementally processing the things that change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflectorDisambiguator is used to disambiguate started reflectors.</span></span><br><span class="line"><span class="comment">// initialized to an unstable value to ensure meaning isn't attributed to the suffix.</span></span><br><span class="line"><span class="keyword">var</span> reflectorDisambiguator = <span class="keyword">int64</span>(time.Now().UnixNano() % <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflector-Run"><a href="#Reflector-Run" class="headerlink" title="Reflector.Run"></a>Reflector.Run</h3><p>Reflector.Run主要执行了<code>ListAndWatch</code>的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span></span><br><span class="line"><span class="comment">// Run will exit when stopCh is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</span><br><span class="line">    wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            utilruntime.HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListAndWatch first lists all items and get the resource version at the moment of call,</span></span><br><span class="line"><span class="comment">// and then use the resource version to watch.</span></span><br><span class="line"><span class="comment">// It returns error if ListAndWatch didn't even try to initialize watch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line">    <span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line">    <span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line">    <span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line">    options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">    r.metrics.numberOfLists.Inc()</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    list, err := r.listerWatcher.List(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.listDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">    items, err := meta.ExtractList(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.numberOfItemsInList.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(items)))</span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将资源的版本号设置为0，然后调用<code>listerWatcher.List(options)</code>，列出所有list的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号设置为0</span></span><br><span class="line">options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line"><span class="comment">// list接口</span></span><br><span class="line">list, err := r.listerWatcher.List(options)</span><br></pre></td></tr></table></figure><p>获取资源版本号，并将list的内容提取成对象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line">resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line"><span class="comment">// 将list的内容提取成对象列表</span></span><br><span class="line">items, err := meta.ExtractList(list)</span><br></pre></td></tr></table></figure><p>将list中对象列表的内容和版本号存储到本地的缓存store中，并全量替换已有的store的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.syncWith(items, resourceVersion)</span><br></pre></td></tr></table></figure><p>syncWith调用了store的Replace的方法来替换原来store中的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncWith replaces the store's items with the given list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        found = <span class="built_in">append</span>(found, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Store.Replace方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后设置最新的资源版本号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.setLastSyncResourceVersion(resourceVersion)</span><br></pre></td></tr></table></figure><p>setLastSyncResourceVersion:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">setLastSyncResourceVersion</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    r.lastSyncResourceVersionMutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.lastSyncResourceVersionMutex.Unlock()</span><br><span class="line">    r.lastSyncResourceVersion = v</span><br><span class="line"></span><br><span class="line">    rv, err := strconv.Atoi(v)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.metrics.lastResourceVersion.Set(<span class="keyword">float64</span>(rv))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="store-Resync"><a href="#store-Resync" class="headerlink" title="store.Resync"></a>store.Resync</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resyncCh, cleanup := r.resyncChan()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cleanup() <span class="comment">// Call the last one written into cleanup</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.ShouldResync == <span class="literal">nil</span> || r.ShouldResync() &#123;</span><br><span class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line">            <span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                resyncerrc &lt;- err</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanup()</span><br><span class="line">        resyncCh, cleanup = r.resyncChan()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.store.Resync()</span><br></pre></td></tr></table></figure><p>store的具体对象为<code>DeltaFIFO</code>，即调用DeltaFIFO.Resync</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resync will send a sync event for each item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keys := f.knownObjects.ListKeys()</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">    options = metav1.ListOptions&#123;</span><br><span class="line">        ResourceVersion: resourceVersion,</span><br><span class="line">        <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">        <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">        TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.metrics.numberOfWatches.Inc()</span><br><span class="line">    w, err := r.listerWatcher.Watch(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">        <span class="keyword">case</span> io.EOF:</span><br><span class="line">            <span class="comment">// watch closed normally</span></span><br><span class="line">        <span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">            glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line">        <span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line">        <span class="comment">// watch where we ended.</span></span><br><span class="line">        <span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line">        <span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置watch的超时时间，默认为5分钟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">options = metav1.ListOptions&#123;</span><br><span class="line">    ResourceVersion: resourceVersion,</span><br><span class="line">    <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">    <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">    TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行listerWatcher.Watch(options)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w, err := r.listerWatcher.Watch(options)</span><br></pre></td></tr></table></figure><p>执行watchHandler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh)</span><br></pre></td></tr></table></figure><h4 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h4><p>watchHandler主要是通过watch的方式保证当前的资源版本是最新的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    eventCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stopping the watcher should be idempotent and if we return from this function there's no way</span></span><br><span class="line">    <span class="comment">// we're coming back in with the same watch interface.</span></span><br><span class="line">    <span class="keyword">defer</span> w.Stop()</span><br><span class="line">    <span class="comment">// update metrics</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r.metrics.numberOfItemsInWatch.Observe(<span class="keyword">float64</span>(eventCount))</span><br><span class="line">        r.metrics.watchDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span> errorStopRequested</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> event.Type == watch.Error &#123;</span><br><span class="line">                <span class="keyword">return</span> apierrs.FromObject(event.Object)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            meta, err := meta.Accessor(event.Object)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">            <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">            <span class="keyword">case</span> watch.Added:</span><br><span class="line">                err := r.store.Add(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Modified:</span><br><span class="line">                err := r.store.Update(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Deleted:</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">                <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">                <span class="comment">// to change this.</span></span><br><span class="line">                err := r.store.Delete(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">            &#125;</span><br><span class="line">            *resourceVersion = newResourceVersion</span><br><span class="line">            r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">            eventCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchDuration := r.clock.Now().Sub(start)</span><br><span class="line">    <span class="keyword">if</span> watchDuration &lt; <span class="number">1</span>*time.Second &amp;&amp; eventCount == <span class="number">0</span> &#123;</span><br><span class="line">        r.metrics.numberOfShortWatches.Inc()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received"</span>, r.name)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: Watch close - %v total %v items received"</span>, r.name, r.expectedType, eventCount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取watch接口中的事件的channel，来获取事件的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获得添加、更新、删除的事件时，将对应的对象更新到本地缓存store中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line"><span class="keyword">case</span> watch.Added:</span><br><span class="line">    err := r.store.Add(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Modified:</span><br><span class="line">    err := r.store.Update(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Deleted:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">    <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">    <span class="comment">// to change this.</span></span><br><span class="line">    err := r.store.Delete(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新当前的最新版本号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">*resourceVersion = newResourceVersion</span><br><span class="line">r.setLastSyncResourceVersion(newResourceVersion)</span><br></pre></td></tr></table></figure><p>通过对Reflector模块的分析，可以看到多次使用到本地缓存store模块，而store的数据由DeltaFIFO赋值而来，以下针对DeltaFIFO和store做分析。</p><h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO由NewDeltaFIFO初始化，并赋值给config.Queue。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDeltaFIFO-1"><a href="#NewDeltaFIFO-1" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeltaFIFO returns a Store which can be used process changes to items.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// keyFunc is used to figure out what key an object should have. (It's</span></span><br><span class="line"><span class="comment">// exposed in the returned DeltaFIFO's KeyOf() method, with bonus features.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'compressor' may compress as many or as few items as it wants</span></span><br><span class="line"><span class="comment">// (including returning an empty slice), but it should do what it</span></span><br><span class="line"><span class="comment">// does quickly since it is called while the queue is locked.</span></span><br><span class="line"><span class="comment">// 'compressor' may be nil if you don't want any delta compression.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'keyLister' is expected to return a list of keys that the consumer of</span></span><br><span class="line"><span class="comment">// this queue "knows about". It is used to decide which items are missing</span></span><br><span class="line"><span class="comment">// when Replace() is called; 'Deleted' deltas are produced for these items.</span></span><br><span class="line"><span class="comment">// It may be nil if you don't need to detect all deletions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider merging keyLister with this object, tracking a list of</span></span><br><span class="line"><span class="comment">//       "known" keys when Pop() is called. Have to think about how that</span></span><br><span class="line"><span class="comment">//       affects error retrying.</span></span><br><span class="line"><span class="comment">// TODO(lavalamp): I believe there is a possible race only when using an</span></span><br><span class="line"><span class="comment">//                 external known object source that the above TODO would</span></span><br><span class="line"><span class="comment">//                 fix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Also see the comment on DeltaFIFO. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeltaFIFO</span><span class="params">(keyFunc KeyFunc, compressor DeltaCompressor, knownObjects KeyListerGetter)</span> *<span class="title">DeltaFIFO</span></span> &#123;</span><br><span class="line">    f := &amp;DeltaFIFO&#123;</span><br><span class="line">        items:           <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas&#123;&#125;,</span><br><span class="line">        queue:           []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">        keyFunc:         keyFunc,</span><br><span class="line">        deltaCompressor: compressor,</span><br><span class="line">        knownObjects:    knownObjects,</span><br><span class="line">    &#125;</span><br><span class="line">    f.cond.L = &amp;f.lock</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller.Run的部分调用了NewReflector。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewReflector构造函数，将c.config.Queue赋值给Reflector.store的属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DeltaFIFO-1"><a href="#DeltaFIFO-1" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p><p>DeltaFIFO主要用在以下场景：</p><ul><li>希望对象变更最多处理一次</li><li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li><li>要处理对象的删除</li><li>希望定期重新处理对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaFIFO is like FIFO, but allows you to process deletes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO is a producer-consumer queue, where a Reflector is</span></span><br><span class="line"><span class="comment">// intended to be the producer, and the consumer is whatever calls</span></span><br><span class="line"><span class="comment">// the Pop() method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO solves this use case:</span></span><br><span class="line"><span class="comment">//  * You want to process every object change (delta) at most once.</span></span><br><span class="line"><span class="comment">//  * When you process an object, you want to see everything</span></span><br><span class="line"><span class="comment">//    that's happened to it since you last processed it.</span></span><br><span class="line"><span class="comment">//  * You want to process the deletion of objects.</span></span><br><span class="line"><span class="comment">//  * You might want to periodically reprocess objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO's Pop(), Get(), and GetByKey() methods return</span></span><br><span class="line"><span class="comment">// interface&#123;&#125; to satisfy the Store/Queue interfaces, but it</span></span><br><span class="line"><span class="comment">// will always return an object of type Deltas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on threading: If you call Pop() in parallel from multiple</span></span><br><span class="line"><span class="comment">// threads, you could end up with multiple threads processing slightly</span></span><br><span class="line"><span class="comment">// different versions of the same object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on the KeyLister used by the DeltaFIFO: It's main purpose is</span></span><br><span class="line"><span class="comment">// to list keys that are "known", for the purpose of figuring out which</span></span><br><span class="line"><span class="comment">// items have been deleted when Replace() or Delete() are called. The deleted</span></span><br><span class="line"><span class="comment">// object will be included in the DeleteFinalStateUnknown markers. These objects</span></span><br><span class="line"><span class="comment">// could be stale.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may provide a function to compress deltas (e.g., represent a</span></span><br><span class="line"><span class="comment">// series of Updates as a single Update).</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// lock/cond protects access to 'items' and 'queue'.</span></span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    cond sync.Cond</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We depend on the property that items in the set are in</span></span><br><span class="line">    <span class="comment">// the queue and vice versa, and that all Deltas in this</span></span><br><span class="line">    <span class="comment">// map have at least one Delta.</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></span><br><span class="line">    populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">    initialPopulationCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keyFunc is used to make the key used for queued item</span></span><br><span class="line">    <span class="comment">// insertion and retrieval, and should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deltaCompressor tells us how to combine two or more</span></span><br><span class="line">    <span class="comment">// deltas. It may be nil.</span></span><br><span class="line">    deltaCompressor DeltaCompressor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// knownObjects list keys that are "known", for the</span></span><br><span class="line">    <span class="comment">// purpose of figuring out which items have been deleted</span></span><br><span class="line">    <span class="comment">// when Replace() or Delete() is called.</span></span><br><span class="line">    knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indication the queue is closed.</span></span><br><span class="line">    <span class="comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span></span><br><span class="line">    <span class="comment">// Currently, not used to gate any of CRED operations.</span></span><br><span class="line">    closed     <span class="keyword">bool</span></span><br><span class="line">    closedLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-amp-Store"><a href="#Queue-amp-Store" class="headerlink" title="Queue &amp; Store"></a>Queue &amp; Store</h3><p>DeltaFIFO的类型是Queue接口，Reflector.store是Store接口，Queue接口是一个存储队列，Process的方法执行Queue.Pop出来的数据对象，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue is exactly like a Store, but has a Pop() method too.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">    Store</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pop blocks until it has something to process.</span></span><br><span class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></span><br><span class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></span><br><span class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></span><br><span class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></span><br><span class="line">    <span class="comment">// returned by Pop back into the queue as long</span></span><br><span class="line">    <span class="comment">// as nothing else (presumably more recent)</span></span><br><span class="line">    <span class="comment">// has since been added.</span></span><br><span class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></span><br><span class="line">    HasSynced() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close queue</span></span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p><p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store is a generic object storage interface. Reflector knows how to watch a server</span></span><br><span class="line"><span class="comment">// and update a store. A generic store is provided, which allows Reflector to be used</span></span><br><span class="line"><span class="comment">// as a local caching system, and an LRU store, which allows Reflector to work like a</span></span><br><span class="line"><span class="comment">// queue of items yet to be processed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Store makes no assumptions about stored object identity; it is the responsibility</span></span><br><span class="line"><span class="comment">// of a Store implementation to provide a mechanism to correctly key objects and to</span></span><br><span class="line"><span class="comment">// define the contract for obtaining objects by some arbitrary key type.</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">    GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Replace</code>方法会删除原来store中的内容，并将新增的list的内容存入store中，即完全替换数据。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache实现了store的接口，而cache的具体实现又是调用<code>ThreadSafeStore</code>接口来实现功能的。</p><p>cache的功能主要有以下两点：</p><ul><li>通过keyFunc计算对象的key</li><li>调用ThreadSafeStorage接口的方法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache responsibilities are limited to:</span></span><br><span class="line"><span class="comment">//  1. Computing keys for objects via keyFunc</span></span><br><span class="line"><span class="comment">//  2. Invoking methods of a ThreadSafeStorage interface</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">    <span class="comment">// should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ListAndWatch主要用到以下的方法：</p><p><strong>cache.Replace</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace will delete the contents of 'c', using instead the given list.</span></span><br><span class="line"><span class="comment">// 'c' takes ownership of the list, you should not reference the list again</span></span><br><span class="line"><span class="comment">// after calling this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Replace</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">        key, err := c.keyFunc(item)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[key] = item</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Replace(items, resourceVersion)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Add</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add inserts an item into the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Add(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Update</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update sets an item in the cache to its updated state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Update</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Update(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Delete</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete removes an item from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Delete</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Delete(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p>cache的具体是调用<code>ThreadSafeStore</code>来实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadSafeStore is an interface that allows concurrent access to a storage backend.</span></span><br><span class="line"><span class="comment">// TL;DR caveats: you must not modify anything returned by Get or List as it will break</span></span><br><span class="line"><span class="comment">// the indexing feature in addition to not being thread safe.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The guarantees of thread safety provided by List/Get are only valid if the caller</span></span><br><span class="line"><span class="comment">// treats returned items as read-only. For example, a pointer inserted in the store</span></span><br><span class="line"><span class="comment">// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`</span></span><br><span class="line"><span class="comment">// on the same key and modify the pointer in a non-thread-safe way. Also note that</span></span><br><span class="line"><span class="comment">// modifying objects stored by the indexers (if any) will *not* automatically lead</span></span><br><span class="line"><span class="comment">// to a re-index. So it's not a good idea to directly modify the objects returned by</span></span><br><span class="line"><span class="comment">// Get/List, in general.</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Update(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">    Get(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Replace(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>)</span><br><span class="line">    Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">    ListIndexFuncValues(name <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>threadSafeMap</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  sync.RWMutex</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">    indexers Indexers</span><br><span class="line">    <span class="comment">// indices maps a name to an Index</span></span><br><span class="line">    indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop"></a>processLoop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller.Run方法中会调用processLoop，以下分析<code>processLoop</code>的处理逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processLoop drains the work queue.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span></span><br><span class="line"><span class="comment">// to make sure that we don't end up processing the same object multiple times</span></span><br><span class="line"><span class="comment">// concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span></span><br><span class="line"><span class="comment">// actually exit when the controller is stopped. Or just give up on this stuff</span></span><br><span class="line"><span class="comment">// ever being stoppable. Converting this whole package to use Context would</span></span><br><span class="line"><span class="comment">// also be helpful.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">                <span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">                c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processLoop主要处理任务队列中的任务，其中处理逻辑是调用具体的<code>ProcessFunc</code>函数来实现，核心代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br></pre></td></tr></table></figure><h3 id="DeltaFIFO-Pop"><a href="#DeltaFIFO-Pop" class="headerlink" title="DeltaFIFO.Pop"></a>DeltaFIFO.Pop</h3><p>Pop会阻塞住直到队列里面添加了新的对象，如果有多个对象，按照先进先出的原则处理，如果某个对象没有处理成功会重新被加入该队列中。</p><p>Pop中会调用具体的process函数来处理对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop blocks until an item is added to the queue, and then returns it.  If</span></span><br><span class="line"><span class="comment">// multiple items are ready, they are returned in the order in which they were</span></span><br><span class="line"><span class="comment">// added/updated. The item is removed from the queue (and the store) before it</span></span><br><span class="line"><span class="comment">// is returned, so if you don't successfully process it, you need to add it back</span></span><br><span class="line"><span class="comment">// with AddIfNotPresent().</span></span><br><span class="line"><span class="comment">// process function is called under lock, so it is safe update data structures</span></span><br><span class="line"><span class="comment">// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc</span></span><br><span class="line"><span class="comment">// may return an instance of ErrRequeue with a nested error to indicate the current</span></span><br><span class="line"><span class="comment">// item should be requeued (equivalent to calling AddIfNotPresent under the lock).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Pop returns a 'Deltas', which has a complete list of all the things</span></span><br><span class="line"><span class="comment">// that happened to the object (deltas) while it was sitting in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">            <span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">            <span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">            <span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        id := f.queue[<span class="number">0</span>]</span><br><span class="line">        f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">        item, ok := f.items[id]</span><br><span class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            f.initialPopulationCount--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        err := process(item)</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">            f.addIfNotPresent(id, item)</span><br><span class="line">            err = e.Err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">        <span class="comment">// ownership to the caller.</span></span><br><span class="line">        <span class="keyword">return</span> item, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    item, ok := f.items[id]</span><br><span class="line">    ...</span><br><span class="line">    err := process(item)</span><br><span class="line">    <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">        f.addIfNotPresent(id, item)</span><br><span class="line">        err = e.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">    <span class="comment">// ownership to the caller.</span></span><br><span class="line">    <span class="keyword">return</span> item, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas"></a>HandleDeltas</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中process函数就是在sharedIndexInformer.Run方法中，给config.Process赋值的<code>HandleDeltas</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.blockDeltas.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from oldest to newest</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">        <span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">            isSync := d.Type == Sync</span><br><span class="line">            s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">            <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Deleted:</span><br><span class="line">            <span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> d.Type &#123;</span><br><span class="line"><span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">    ...</span><br><span class="line">    s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的类型，调用<code>processor.distribute</code>方法，该方法将对象加入<code>processorListener</code>的channel中。</p><h3 id="sharedProcessor-distribute"><a href="#sharedProcessor-distribute" class="headerlink" title="sharedProcessor.distribute"></a>sharedProcessor.distribute</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sync &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>processorListener.add:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合以上的分析，可以看出processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。以下分析processorListener.Run的部分。</p><h2 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h2><p>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p><p>流程：</p><ol><li>listenser的add函数负责将notify装进pendingNotifications。</li><li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li><li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sharedProcessor-Run"><a href="#sharedProcessor-Run" class="headerlink" title="sharedProcessor.Run"></a>sharedProcessor.Run</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      p.listenersLock.RLock()</span><br><span class="line">      <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">      <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">         p.wg.Start(listener.run)</span><br><span class="line">         p.wg.Start(listener.pop)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   &lt;-stopCh</span><br><span class="line">   p.listenersLock.RLock()</span><br><span class="line">   <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">   <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">      <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener-pop"><a href="#listener-pop" class="headerlink" title="listener.pop"></a>listener.pop</h4><p>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextCh <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">            <span class="comment">// Notification dispatched</span></span><br><span class="line">            <span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">            notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">                nextCh = <span class="literal">nil</span> <span class="comment">// Disable this select case</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> notificationToAdd, ok := &lt;-p.addCh:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> notification == <span class="literal">nil</span> &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">                <span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">                notification = notificationToAdd</span><br><span class="line">                nextCh = p.nextCh</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">                p.pendingNotifications.WriteOne(notificationToAdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener-run"><a href="#listener-run" class="headerlink" title="listener.run"></a>listener.run</h4><p>listener.run部分根据不同的更新类型调用不同的处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">        <span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> updateNotification:</span><br><span class="line">            p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> addNotification:</span><br><span class="line">            p.handler.OnAdd(notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> deleteNotification:</span><br><span class="line">            p.handler.OnDelete(notification.oldObj)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中具体的实现函数handler是在NewDeploymentController（其他不同类型的controller类似）中赋值的，而该handler是一个接口，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceEventHandler can handle notifications for events that happen to a</span></span><br><span class="line"><span class="comment">// resource. The events are informational only, so you can't return an</span></span><br><span class="line"><span class="comment">// error.</span></span><br><span class="line"><span class="comment">//  * OnAdd is called when an object is added.</span></span><br><span class="line"><span class="comment">//  * OnUpdate is called when an object is modified. Note that oldObj is the</span></span><br><span class="line"><span class="comment">//      last known state of the object-- it is possible that several changes</span></span><br><span class="line"><span class="comment">//      were combined together, so you can't use this to see every single</span></span><br><span class="line"><span class="comment">//      change. OnUpdate is also called when a re-list happens, and it will</span></span><br><span class="line"><span class="comment">//      get called even if nothing changed. This is useful for periodically</span></span><br><span class="line"><span class="comment">//      evaluating or syncing something.</span></span><br><span class="line"><span class="comment">//  * OnDelete will get the final state of the item if it is known, otherwise</span></span><br><span class="line"><span class="comment">//      it will get an object of type DeletedFinalStateUnknown. This can</span></span><br><span class="line"><span class="comment">//      happen if the watch is closed and misses the delete event and we don't</span></span><br><span class="line"><span class="comment">//      notice the deletion until the subsequent re-list.</span></span><br><span class="line"><span class="keyword">type</span> ResourceEventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnAdd(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnUpdate(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnDelete(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResourceEventHandler"><a href="#ResourceEventHandler" class="headerlink" title="ResourceEventHandler"></a>ResourceEventHandler</h3><p>以下以DeploymentController的处理逻辑为例。</p><p>在<code>NewDeploymentController</code>部分会注册deployment的事件函数，以下注册了三种类型的事件函数，其中包括：dInformer、rsInformer和podInformer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeploymentController creates a new DeploymentController.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer extensionsinformers.DeploymentInformer, rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addDeployment,</span><br><span class="line">        UpdateFunc: dc.updateDeployment,</span><br><span class="line">        <span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">        DeleteFunc: dc.deleteDeployment,</span><br><span class="line">    &#125;)</span><br><span class="line">    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addReplicaSet,</span><br><span class="line">        UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">        DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">    &#125;)</span><br><span class="line">    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        DeleteFunc: dc.deletePod,</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addDeployment"><a href="#addDeployment" class="headerlink" title="addDeployment"></a>addDeployment</h4><p>以下以<code>addDeployment</code>为例，addDeployment主要是将对象加入到enqueueDeployment的队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">addDeployment</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    d := obj.(*extensions.Deployment)</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"Adding deployment %s"</span>, d.Name)</span><br><span class="line">    dc.enqueueDeployment(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueueDeployment的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enqueueDeployment <span class="function"><span class="keyword">func</span><span class="params">(deployment *extensions.Deployment)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将dc.enqueue赋值给dc.enqueueDeployment</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.enqueueDeployment = dc.enqueue</span><br></pre></td></tr></table></figure><p>dc.enqueue调用了dc.queue.Add(key)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">enqueue</span><span class="params">(deployment *extensions.Deployment)</span></span> &#123;</span><br><span class="line">    key, err := controller.KeyFunc(deployment)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %#v: %v"</span>, deployment, err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dc.queue主要记录了需要被同步的deployment的对象，供syncDeployment使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dc := &amp;DeploymentController&#123;</span><br><span class="line">    ...</span><br><span class="line">    queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewNamedRateLimitingQueue</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedRateLimitingQueue</span><span class="params">(rateLimiter RateLimiter, name <span class="keyword">string</span>)</span> <span class="title">RateLimitingInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;rateLimitingType&#123;</span><br><span class="line">        DelayingInterface: NewNamedDelayingQueue(name),</span><br><span class="line">        rateLimiter:       rateLimiter,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上分析，可以看出processor记录了不同类似的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析的部分主要是k8s的<code>informer</code>机制，即<code>List-Watch</code>机制。</p><h3 id="Reflector-2"><a href="#Reflector-2" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p><h3 id="ListAndWatch-1"><a href="#ListAndWatch-1" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p><code>ListAndWatch</code>第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p><h3 id="DeltaFIFO-2"><a href="#DeltaFIFO-2" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p><code>DeltaFIFO</code>是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p><p>DeltaFIFO主要用在以下场景：</p><ul><li>希望对象变更最多处理一次</li><li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li><li>要处理对象的删除</li><li>希望定期重新处理对象</li></ul><h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p><p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p><h3 id="processor-1"><a href="#processor-1" class="headerlink" title="processor"></a>processor</h3><p><code>processor</code>的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p><p>流程：</p><ol><li>listenser的add函数负责将notify装进pendingNotifications。</li><li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li><li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li></ol><p><code>processor</code>记录了不同类似的事件函数，其中事件函数在<code>NewXxxController</code>构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似<code>syncDeployment</code>的同步函数来维持期望状态的同步逻辑。</p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li>在controller-manager的Run函数部分调用了InformerFactory.Start的方法，Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。</li><li>informer.Run的部分先生成一个DeltaFIFO的队列来存储对象变化的数据。然后调用processor.Run和controller.Run函数。</li><li>controller.Run函数会生成一个Reflector，<code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</li><li>Reflector接着执行ListAndWatch函数，ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</li><li>controller.Run函数还会调用processLoop函数，processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。</li><li>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。processor记录了不同类型的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="Informer-二级缓存中的同步问题"><a href="#Informer-二级缓存中的同步问题" class="headerlink" title="Informer 二级缓存中的同步问题"></a>Informer 二级缓存中的同步问题</h2><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存 DeltaIFIFO 和 LocalStore 之间会存在 resync 机制，k8s 中 kube-controller-manager 的 StatefulSetController 中使用了两级缓存的 resync 机制（如下图所示），我们在生产环境中发现 sts 创建后过了很久 pod 才会创建，主要是由于 StatefulSetController 的两级缓存之间 30s 会同步一次，由于 StatefulSetController watch 到变化后就会把对应的 sts 放入 DeltaIFIFO 中，且每隔 30s 会把 LocalStore 中全部的 sts 重新入一遍 DeltaIFIFO，入队时会做一些处理，过滤掉一些不需要重复入队列的 sts，若间隔的 30s 内没有处理完队列中所有的 sts，则待处理队列中始终存在未处理完的 sts，并且在同步过程中产生的 sts 会加的队列的尾部，新加入队尾的 sts 只能等到前面的 sts 处理完成（也就是 resync 完成）才会被处理，所以导致的现象就是 sts 创建后过了很久 pod 才会创建。</p><p>优化的方法就是去掉二级缓存的同步策略（将 setInformer.Informer().AddEventHandlerWithResyncPeriod() 改为 informer.AddEventHandler()）或者调大同步周期，但是在研究 kube-controller-manager 其他 controller 时发现并不是所有的 controller 都有同步策略，社区也有相关的 issue 反馈了这一问题，Remove resync period for sset controller，社区也会在以后的版本中去掉两级缓存之间的 resync 策略。</p><p>k8s.io/kubernetes/pkg/controller/statefulset/stateful_set.go</p><p><img alt="Kubernetes 中 informer 的使用" data-src="https://static001.geekbang.org/wechat/images/a1/a1a5745f0c0309c9d05c484905887fb8.jpeg">kube-controller-manager sts controller</p><h2 id="使用-Informer-如何监听所有资源对象？"><a href="#使用-Informer-如何监听所有资源对象？" class="headerlink" title="使用 Informer 如何监听所有资源对象？"></a>使用 Informer 如何监听所有资源对象？</h2><p>一个 Informer 实例只能监听一种 resource，每个 resource 需要创建对应的 Informer 实例。</p><h2 id="为什么不是使用-workqueue？"><a href="#为什么不是使用-workqueue？" class="headerlink" title="为什么不是使用 workqueue？"></a>为什么不是使用 workqueue？</h2><p>建议使用 RateLimitingQueue，它相比普通的 workqueue 多了以下的功能:</p><ul><li><strong>限流：</strong>可以限制一个 item 被 reenqueued 的次数。</li><li><strong>防止 hot loop：</strong>它保证了一个 item 被 reenqueued 后，不会马上被处理。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/kubernetes/client-go/tree/master/tools/cache" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/tree/master/tools/cache</a></li><li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></li><li><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-20_client-go-controller-interaction.jpeg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="informer" scheme="http://houmin.cc/tags/informer/"/>
    
      <category term="watch" scheme="http://houmin.cc/tags/watch/"/>
    
      <category term="消息机制" scheme="http://houmin.cc/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    
      <category term="异步" scheme="http://houmin.cc/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>【下厨房】酸甜麻辣咸</title>
    <link href="http://houmin.cc/posts/8f35743d/"/>
    <id>http://houmin.cc/posts/8f35743d/</id>
    <published>2020-07-13T13:21:43.000Z</published>
    <updated>2020-07-25T14:18:13.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出<code>Hello World</code>，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印<code>Hello World</code>，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。</p><a id="more"></a><h2 id="基本调料"><a href="#基本调料" class="headerlink" title="基本调料"></a>基本调料</h2><h3 id="食盐"><a href="#食盐" class="headerlink" title="食盐"></a>食盐</h3><ul><li>盐乃百味之首，主要用于调出咸味。</li><li>做菜时，<strong>在多数情况下</strong>都是在<strong>最后调味阶段再放盐</strong>的，例如炒菜、炖汤、炖菜时，因为这样可以保证盐不会破坏掉其他的味道，也可以保证碘元素少挥发，还能保证菜品不会过咸。</li><li>但如果在准备<strong>食材时需要提前入味</strong>的情况下，就<strong>需要先放盐了</strong>，例如蒸肉、蒸鱼。</li></ul><p><img alt="盐" data-src="https://pic1.zhimg.com/v2-f828837cbf0cf989cfb25b5b1bbdac78_b.webp"></p><h3 id="酱油"><a href="#酱油" class="headerlink" title="酱油"></a>酱油</h3><ul><li>我国传统调料，主要用来增咸提鲜。酱油可分为生抽和老抽。</li><li><strong>老抽</strong>吃到嘴里很浓稠，一般用于给食物上色提鲜。</li><li><strong>生抽</strong>颜色比较淡，味道稍咸，主要用来调味，炒菜或者凉拌菜的时候用得比较多。</li></ul><h3 id="鸡精和味精"><a href="#鸡精和味精" class="headerlink" title="鸡精和味精"></a>鸡精和味精</h3><ul><li>调鲜专用，主要成分都是谷氨酸钠，两者其实在原料上差别不大，只是口感上，<strong>鸡精更鲜，更有风味</strong>。</li><li>值得一提的是，<strong>鸡精和味精其实真的不会致癌</strong>，所以正常做菜使用是没有问题的！</li></ul><p><strong>使用鸡精和味精的注意事项：</strong></p><ul><li>高汤烹制的菜肴不必使用，因为已经很鲜美了；</li><li>酸性强的菜肴，如糖醋、醋溜菜等不宜使用；</li><li>腌菜不要使用味精；</li><li>不宜过早放味精，要在将出锅时放入；</li><li>如果用于凉拌菜，可以先溶解再使用;</li><li>不能在高温下使用。</li></ul><p><img alt="鸡精和味精" data-src="https://pic3.zhimg.com/v2-73bbb13a22c0b7fd1ec322934b73c1ec_b.jpg"></p><h3 id="醋"><a href="#醋" class="headerlink" title="醋"></a>醋</h3><p>我国古代传统调味料之一。有三千多年的历史。醋在分类上通常有以下几类：<strong>米醋、陈醋、白醋。</strong></p><ul><li><strong>米醋</strong>的口感更好，口感酸甜，可用于糖醋排骨。</li><li><strong>陈醋</strong>酸味很浓烈，很开胃，基本上可用于各种常见的调味。</li><li><strong>白醋</strong>的酸味口感较淡，多用于凉拌菜或西餐的使用。</li></ul><p><strong>下面总结一下醋的各种常见功能：</strong></p><ul><li><strong>去腥去膻：</strong>做鱼做羊的时候可加入少许醋去除异味</li><li><strong>减少辣味：</strong>如果炒菜时不小心辣椒放多了，可以放一些醋减少辣味</li><li><strong>增香：</strong>做菜时候加入少许醋，可以增加菜肴香味并减少油腻程度</li><li><strong>催熟：</strong>炖牛羊肉的时候加一点醋能够让菜肴熟得更快</li><li><strong>增甜：</strong>南方朋友做甜粥的时候加入少许醋可以使粥更甜</li></ul><p><img alt="醋" data-src="https://pic1.zhimg.com/v2-3a5d4fa5e12fd226862b423e39baf703_b.jpg"></p><h3 id="糖"><a href="#糖" class="headerlink" title="糖"></a>糖</h3><ul><li><p>增甜味的调料，常见的种类有白糖、红糖、冰糖。</p><ul><li>一般使用白糖作为调料。</li><li>红糖可以补血破淤具有益气、缓中、助脾化食的作用。</li><li>冰糖可以去痰止咳，一般可用于制作红烧类菜肴时增加色泽及口感，也可用于制作甜品。</li></ul></li><li><p>少许白糖可以提鲜。</p></li><li><p>白糖还可以综合酸味，可做醋溜系的菜。</p></li><li><p>由于糖的特性，可做拔丝香蕉等“拔丝类”菜肴</p></li><li><p>挂霜：白糖入锅，加入适量清水，熬至水近干时，倒入经烘烤或油炸过的原料，离火，翻拌，冷却后，成品表面即似白霜状。如糖霜花生、糖山楂、糖霜核桃等。</p></li><li><p>炒糖色：广泛用于卤菜、红烧菜的调色、如红烧猪蹄、红烧排骨等。</p></li><li><p>糖醋菜系必备，开胃可口。</p><p><img alt="糖" data-src="https://pic3.zhimg.com/v2-0af08e21b39bc930a099b05f35c3ccfa_b.jpg"></p></li></ul><h2 id="酒类"><a href="#酒类" class="headerlink" title="酒类"></a>酒类</h2><h3 id="料酒"><a href="#料酒" class="headerlink" title="料酒"></a><strong>料酒</strong></h3><ul><li><strong>去腥</strong>专家，很多肉类、内脏等食材在初加工时，都会使用料酒去腥。</li><li>例如在<strong>炒鸡蛋的时候加入少许料酒也可以去腥提香</strong></li></ul><h3 id="啤酒"><a href="#啤酒" class="headerlink" title="啤酒"></a><strong>啤酒</strong></h3><ul><li>硬菜会用啤酒去腥、调味，请家里常备“宽啤酒”</li></ul><h3 id="高度白酒"><a href="#高度白酒" class="headerlink" title="高度白酒"></a><strong>高度白酒</strong></h3><ul><li>去除腥味较重的食物时可以用到</li></ul><h2 id="酱类"><a href="#酱类" class="headerlink" title="酱类"></a>酱类</h2><p>酱类调料：各类以酱为形式的调料</p><h3 id="豆瓣酱"><a href="#豆瓣酱" class="headerlink" title="豆瓣酱"></a>豆瓣酱</h3><p>川菜之魂，主要<strong>增加菜肴的咸鲜味</strong>。</p><h3 id="甜面酱"><a href="#甜面酱" class="headerlink" title="甜面酱"></a>甜面酱</h3><p>以面粉、水和食盐为原料的一种酱料，<strong>鲜香甜味十足</strong>。可以当做酱料使用（例如蘸黄瓜），也可以调味，是炸酱面、京酱肉丝等菜肴的必备调料。　　</p><h3 id="番茄酱"><a href="#番茄酱" class="headerlink" title="番茄酱"></a>番茄酱</h3><p>用新鲜番茄经过加工而成的酱料，鲜而酸。常用于<strong>增色、添香、增加酸味口感</strong>，如制作松鼠鱼。</p><h3 id="芝麻酱"><a href="#芝麻酱" class="headerlink" title="芝麻酱"></a>芝麻酱</h3><p>顾名思义是芝麻作为原料调制的酱料，非常的香，<strong>增香必备</strong>。可直接作为蘸料，例如北方的同学吃火锅是喜欢蘸麻酱，也常用于制作凉面、凉拌菜等。</p><h3 id="蚝油"><a href="#蚝油" class="headerlink" title="蚝油"></a>蚝油</h3><p>以素有”海底牛奶”之称的蚝牗牡蛎牍为原料，经煮熟取汁浓缩，加辅料精制而成。蚝油味道鲜美、蚝香浓郁，黏稠适度，营养价值高。适合烹制多种食材，如蚝油牛肉、蚝油生菜、蚝油荷兰豆等，还可<strong>调拌各种面食、涮海鲜、佐餐食用</strong>等。</p><h2 id="香料类"><a href="#香料类" class="headerlink" title="香料类"></a>香料类</h2><p>香料分很多种，主要功能是增加各种风味，使味更有层次感。</p><h3 id="干辣椒："><a href="#干辣椒：" class="headerlink" title="干辣椒："></a>干辣椒：</h3><p><strong>增香、增辣。</strong></p><p>油热时和葱姜一起放锅内爆香，一般家常菜都可以用。</p><h3 id="花椒与麻椒"><a href="#花椒与麻椒" class="headerlink" title="花椒与麻椒"></a>花椒与麻椒</h3><p>增加菜肴的<strong>“麻”味</strong>，同时也是<strong>爆香</strong>的“利器”！炒菜的时候加入花椒可以防止油沸，花椒粉也可以用于包子或者饺子的馅料。麻椒比花椒颜色更重，更麻，喜欢重口味的同学可以用麻椒作为调料。</p><h3 id="八角-大料"><a href="#八角-大料" class="headerlink" title="八角(大料)"></a>八角(大料)</h3><p>也叫大茴香，因此无论<strong>卤、酱、烧、炖，</strong>都可以用到它，用以<strong>去腥添香。</strong>不论炒菜、炖肉、腌菜，八角都要提前放。一份菜一般放三瓣，分量多的可以放一整朵。</p><h3 id="胡椒"><a href="#胡椒" class="headerlink" title="胡椒"></a>胡椒</h3><ul><li>又分<strong>黑胡椒和白胡椒</strong>，常用于提鲜去腥，开胃、促进食欲。</li><li>其中<strong>黑胡椒味道更浓，香中带辣</strong>，适用于炖、煎、烤肉类。</li><li><strong>白胡椒胡椒香味稍淡，辣味更浓</strong>，能提出鲜味。</li><li>需要注意的是，无论黑胡椒、白胡椒皆不能高温油炸，应在菜肴或汤羹即将出锅时加少许。</li></ul><h3 id="香叶"><a href="#香叶" class="headerlink" title="香叶"></a>香叶</h3><p>干燥后的月桂树叶，用以<strong>去腥添香</strong>，用于炖肉、卤味等。</p><h3 id="桂皮"><a href="#桂皮" class="headerlink" title="桂皮"></a>桂皮</h3><p>干燥后的月桂树皮，用以去腥添香，也可以用于炖肉、卤味等。</p><h3 id="小茴香"><a href="#小茴香" class="headerlink" title="小茴香"></a>小茴香</h3><p>用以<strong>去腥添香</strong>，用于炖肉等。其茎叶部分即茴香菜。</p><h3 id="孜然"><a href="#孜然" class="headerlink" title="孜然"></a>孜然</h3><p>祛<strong>除腥膻异味</strong>的作用很强,！还能<strong>解除肉类的油腻</strong>,常用在烧烤牛羊肉中，令肉质更加鲜美芳香并且去除膻味异味。</p><h3 id="五香粉"><a href="#五香粉" class="headerlink" title="五香粉"></a><strong>五香粉</strong></h3><p>花椒、大料、桂皮、丁香等芳香类调料混合研制而成，使用方便。尤其适合用于<strong>烘烤或快炒肉类，炖、焖、煨、蒸、煮菜肴</strong>作调味。</p><h2 id="辣椒类"><a href="#辣椒类" class="headerlink" title="辣椒类"></a>辣椒类</h2><p><img alt="辣椒" data-src="https://pic2.zhimg.com/v2-471d6358a188a14ebf240fa500d0164f_b.jpg"></p><h3 id="剁椒与糟辣椒"><a href="#剁椒与糟辣椒" class="headerlink" title="剁椒与糟辣椒"></a>剁椒与糟辣椒</h3><p>云贵地区称作糟辣椒、湖南地区叫做剁椒，<strong>口味和制作工艺稍有差别</strong>，但是总体来说外表色泽鲜红，具有香、辣、鲜、酸、嫩、咸、脆、的独特风味，有开胃消食、暖胃驱寒的功效。可以直接食用、当做蘸料，也可用于调料，比如制作剁椒鱼头、鱼香肉丝、鱼香茄子等菜肴，值得注意的是，由于<strong>剁椒和糟辣椒本身就有盐味</strong>，所以调味时就<strong>不用额外添加过多的食盐</strong>了！</p><h3 id="红油辣椒"><a href="#红油辣椒" class="headerlink" title="红油辣椒"></a>红油辣椒</h3><p>是川菜中常见的调味料，油色红亮，味道香辣。常用于<strong>凉拌菜、拌面、蘸料等。</strong></p><h3 id="泡椒"><a href="#泡椒" class="headerlink" title="泡椒"></a>泡椒</h3><p>四川特产，由新鲜辣椒腌制而成。香、酸、辣味十足，是制作泡椒类菜肴的必备调料（例如川味鱼香肉丝、泡椒牛肉等）。<br>常见的泡椒主要有两种：</p><ul><li>二荆条泡辣椒：这种辣椒相对较长，辣味适口，香气足，可以切碎了使用，制作传统川菜鱼香肉丝就离不开它</li><li>子弹头泡辣椒：这种辣椒较短，呈鸡心状，其辣味足，因成形较好，在泡椒菜肴中常整个使用，很少加工成茸或切成小块。</li></ul><h2 id="食用油"><a href="#食用油" class="headerlink" title="食用油"></a>食用油</h2><h3 id="菜油-菜籽油"><a href="#菜油-菜籽油" class="headerlink" title="菜油(菜籽油)"></a>菜油(菜籽油)</h3><p>用油菜籽榨出来的一种食用油，有一种“青气味”。菜籽油具有一定的软化血管、延缓衰老的功效。常<strong>用于炒菜，也可以做红油辣椒。不适合凉拌菜。</strong></p><h3 id="花生油"><a href="#花生油" class="headerlink" title="花生油"></a>花生油</h3><p>淡黄透明，气味芬芳，滋味可口，是一种比较容易消化的食用油。花生油的脂肪酸构成是比较好的，易于人体消化和吸收。常用于炒菜，<strong>炒蔬菜最好，比较香。</strong> </p><h3 id="葵花籽油"><a href="#葵花籽油" class="headerlink" title="葵花籽油"></a>葵花籽油</h3><p>营养价值丰富，含有丰富的胡萝卜素。不适合油炸，常用于<strong>做汤、炒菜、凉拌。</strong></p><h3 id="玉米油"><a href="#玉米油" class="headerlink" title="玉米油"></a>玉米油</h3><p>优质玉米油营养含量丰富。也常用于炒菜，清淡不油腻也可增加香味。</p><h3 id="大豆油"><a href="#大豆油" class="headerlink" title="大豆油"></a>大豆油</h3><p>通常我们称之为“大豆色拉油”，是最常用的烹调油之一。做面点，但不适合炒菜。</p><h3 id="橄榄油"><a href="#橄榄油" class="headerlink" title="橄榄油"></a>橄榄油</h3><p>非常营养健康的油。炒菜时油烟很少，但高温易破坏营养，所以要想营养最大化还是凉拌菜比较好，但是缺点是炒菜炒起来没那么“香”。</p><h3 id="猪油"><a href="#猪油" class="headerlink" title="猪油"></a>猪油</h3><p>也称为荤油或猪大油。它是从猪的脂肪中提炼出，初始状态是略黄色半透明液体的食用油，常温下为白色或浅黄色固体，加热后会融化。<strong>猪油含胆固醇较多，对身体不利，建议少吃。</strong>但是炒菜做菜时能增香、添味。另外，由于常温时是固体，故不适合做凉拌食物。</p><h3 id="芝麻油"><a href="#芝麻油" class="headerlink" title="芝麻油"></a>芝麻油</h3><p>具有特别的香味，所以也叫香油。凉拌菜、汤类及热菜首选，可以<strong>增香提味。</strong></p><h3 id="牛油"><a href="#牛油" class="headerlink" title="牛油"></a>牛油</h3><p>从牛的脂肪组织里提炼出来的油脂，常温时也呈固体。风味浓郁，是做麻辣火锅底料必备调料。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出&lt;code&gt;Hello World&lt;/code&gt;，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印&lt;code&gt;Hello World&lt;/code&gt;，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_condiment.jpg" type="image" />
    
    
      <category term="吃顿好的" scheme="http://houmin.cc/categories/%E5%90%83%E9%A1%BF%E5%A5%BD%E7%9A%84/"/>
    
    
      <category term="下厨房" scheme="http://houmin.cc/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>再出发</title>
    <link href="http://houmin.cc/posts/4987aa35/"/>
    <id>http://houmin.cc/posts/4987aa35/</id>
    <published>2020-07-12T14:59:21.000Z</published>
    <updated>2020-07-20T01:30:36.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。</p><a id="more"></a><h2 id="饮食起居"><a href="#饮食起居" class="headerlink" title="饮食起居"></a>饮食起居</h2><p>这是我整理完毕的工作台，其中购置了墙布用于装饰墙面，购买了可组装的书桌（拼了将近两个小时才拼好），又自己买了ikbc c87的键盘，从姐姐家里带来的蓝牙音响，还有之前买的LAMY钢笔，皮皮送拇指琴，真的是很喜欢很舒适的工作台了。</p><p><img alt="整理完毕的工作台" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-06_settle-down.jpg"></p><p>在上学时曾经期待过工作之后的生活场景，想着是自己每天上能够自己准备早餐，晚上下班后能够自己在家安排自己的生活。但是一周的上班生活马上用现实教育了我，每天早上8.30点出门直接在公司吃早饭，工作到9点半后下班，到家就10点后了，基本上洗漱完后就可以直接睡觉了。做饭这种事情，只能发生在周末了。然而，在入职前我就反了一个错误，一口气买了好多菜，平时也不做，好些都给浪费了。而且，为了简单，平时做的最多的就是面了。不过，不管怎样，总算是开伙了。即使只是在周末下厨，也不能丧失了生活的乐趣了啊，趁这个机会好好学习做菜是一个不错的想法。为此，我特地创建了一个<a href="../../categories/吃顿好的/">「吃顿好的」</a>专栏，用于记录我周末下厨房的菜谱。在后续的工作生涯中，这个专栏会持续更新。</p><h2 id="追光计划"><a href="#追光计划" class="headerlink" title="追光计划"></a>追光计划</h2><p>「追光计划」源自我在微博上看到一个<a href="https://weibo.com/ttarticle/p/show?id=2309404521623347921078" target="_blank" rel="external nofollow noopener noreferrer">摄影师小姐姐</a>为自己在北京最后一段时间留下记录影像的规划，她这样说道</p><blockquote><p>不知道你是否也有过类似的感觉——越是长久的生活在一个城市，反而越少了了解它的冲动。</p><p>就好比在武汉生活的四五年里，我一次都没有去过黄鹤楼，也几乎不去武大。那些外地游客心心念念的美景，本地人好像都因为太过习惯而熟视无睹。</p><p>在北京我也一样。除了故宫外，其他大众或冷门的景点，我鲜少踏足，也很少抓紧特别的天气去拍点什么，总想着：“以后还有机会的”。我拍过很多日出日落，那些绝美的光影，几乎都来自旅途，却独独少了我生活的北京。</p><p>似乎人总是这样，偶尔难得旅行，就总想紧紧抓住异乡风景。会起早贪黑去追逐日出日落，也乐于打卡各种陌生的小众景点。而你生活的地方，却总忘了多看几眼。</p><p>故事的转机发生在我决定离开北京之后。</p></blockquote><p>小姐姐和我有着类似的生活坐标（武汉与北京），直到决定离开北京后才开始意识到好好拍摄北京的风景。我也是一样，本来决定在离校前好好拍摄北大的风光，却也最终没能够实现。在过去的一两周里，我一直在质疑自己，为什么要留在北京呢？在这里呆了都七年了，为什么不换一个地方生活呢？</p><p>想到这里，我给自已一个三年之期：如果在未来三年，我没能够找到留在北京的理由，或者是因为一个人，或者是因为一件事，三年到期之时也许就是我离开北京的日子。不管到时候是否离开，在这三年里，我也有自己的追光计划。我要好好记录在北京的日子，记录那些光影。作为最基本的示例，我开创了一个新的相册，<a href="../../album/知春里知春/">知春里知春</a>，用于记录我在知春里生活的时光。另外，随着追光计划的开展，我也会把那些美丽的景色放到另一个相册，<a href="../../album/Beijing">北京</a> 。</p><h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><p>我职业生涯的正式起点，开启于腾讯云的kubernetes团队。在过去的一周里，我开始阅读kubernetes源码，在阅读的过程中，我越来越感觉到自己积淀的欠缺。不仅是CNCF云原生的生态发展，还有kubernetes本身机制的原理，或者是Go语言的最佳实践，以及Linux操作系统的基础原理，自己都知之甚少。或者说有时候只是知道一些名词，但是对其原理，发展机制都不太了解。</p><p>作为一个工程师，这些技术点是我的立身之本，必须在接下来的一年内能够快速积淀，给自己的职业发展奠定一个扎实的基础。为此，我列出了在接下来两年我要去点亮的技能树，这只是最基础的专业内容。它涉及的范围很广泛，但是要戒骄戒躁，一步一步来。</p><p><img alt="Kubernetes技能树" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-12_kubernetes-skill-map.png"></p><h2 id="运动健身"><a href="#运动健身" class="headerlink" title="运动健身"></a>运动健身</h2><p>在年初的时候，我大言不惭的说：</p><blockquote><p>数据是最重忠实的记录者，每周 3 次跑步，每次 5 公里，期待明年能够达到 700 公里的跑步量。</p></blockquote><p>现在每一次的跑步都是通过Keep记录，翻开Keep，发现上半年的记录只有27公里，真的是完全不达标啊。也许你可以归因于疫情，但是如此懈怠真的太不自律了。下半年开始，发现在公司地下有免费健身房，正好可以每天中午午饭时间去跑一个小时的步。按照下半年25周，每周5次每次5公里的跑步记录，勉强可以达到625公里的目标。如果再加上周末的户外跑步，比如附近的人民大学，海淀黄庄一带，可以大体满足700公里的目标，加油呀！</p><h2 id="阅读观影"><a href="#阅读观影" class="headerlink" title="阅读观影"></a>阅读观影</h2><p>翻了翻豆瓣，上半年的阅读依旧还是颗粒无收。主要还是没有一个Read List，也没有一个阅读规划，匆匆半年过去，一本书也没读过很正常。预计下半年看书还是会很少，更多的看的是专业相关的技术文档的内容。</p><p>至于观影，上半年看了很多金融相关的电影和纪录片，比如大空头等，对金融与市场有了更多的认识。另外，还入坑了「Rick and Morty」，这个系列可以慢慢刷。不知道为什么，现在好像对刷新的剧没有了之前那么大的激情，更多的是看木鱼和电影最Top对电影的讲解，整体开始偏快餐。</p><h2 id="行万里路"><a href="#行万里路" class="headerlink" title="行万里路"></a>行万里路</h2><p>在年初的时候，我给自己计划了两场旅行：</p><ul><li>和家里的春节南国之旅</li><li>和鹏飞的节后湖南之行</li></ul><p>然而这场疫情改变了一切，上半年创造了上大学以后呆在家的最长纪录，从1.19到5.7的一百多天。之后，我去杭州呆了两个月，好好逛了逛杭州，见识了西湖之美。本来计划的毕业旅行也因为一再爆发的疫情而最终取消，残念。</p><p>今年下半年，有意去新疆走一趟，趁着国庆，看看壮美的新疆，期待最终能够成行。作为一个已经毕业的人，除了国庆之外，已经没有了出去玩的机会，想一想真是心酸。不管怎么样，国庆一定要出去走走，可不能浪费这次假期。</p><h2 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h2><p>去年年末给自己定了一个理财的小目标：</p><blockquote><p>给自己定一个小目标，期待自己明年在投资上至少能够有 20 个点的收入，最好能够到 40 个点的收入。</p></blockquote><p>截止到现在，得益于行情好，已经获得了40个点的收益，希望可以在后面半年继续努力：）整体来说，上半年还是偏保守，在2.3春节开盘千股跌停的那天，我几近满仓。然而后面行情低迷是多年不遇的打底没敢全仓进入，只是半仓观望。加上进入资金也不多，最后的收益其实了了。</p><p><img alt="2020上半年收益曲线" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-12_investment.jpg"></p><p>关于理论知识，上半年在疫情期间听了徐高老师的「宏观经济十六讲中国专题」，看了一些炒股的基础知识，但是一直没有落实成文本的形式积淀下来，下半年在空余时间要在落实层面做到更好。毕竟，现在的股票买卖还是没有任何理论依据，选股的原因，买入的时机，抛出的选择都十分无脑，有时候迷之自信，没有任何逻辑。构建自己的交易体系，长路漫漫。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>卡林巴琴停了很久，年初的规划仍在，今天又弹了段「青花瓷」，找回了感觉，下半年的音乐计划继续。</p><p>2020上半年继续单身，工作以后社交状态越发封闭，这段时间先好好调整自己的状态吧，期待在工作上更好的适应，做出自己的成绩。</p><p>这次的半年总结拖了两个星期，工作和生活开始慢慢进入状态，继续加油呀，努力做更好的自己：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-06_sunset.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="职场" scheme="http://houmin.cc/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="个人管理系统" scheme="http://houmin.cc/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="追光计划" scheme="http://houmin.cc/tags/%E8%BF%BD%E5%85%89%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】开篇</title>
    <link href="http://houmin.cc/posts/d8b96fe4/"/>
    <id>http://houmin.cc/posts/d8b96fe4/</id>
    <published>2020-07-07T12:47:00.000Z</published>
    <updated>2020-07-15T06:39:42.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>Kubernetes来源于希腊词汇<a href="https://en.wiktionary.org/wiki/κυβερνήτης" target="_blank" rel="external nofollow noopener noreferrer">κυβερνήτης</a>，意思是<a href="https://en.wikipedia.org/wiki/Helmsman" target="_blank" rel="external nofollow noopener noreferrer">helmsman</a>，也即是舵手的意思，也可引申为<code>pilot</code>或者<code>governor</code>的含义。与此同时，kubernetes也是<a href="https://en.wikipedia.org/wiki/Cybernetics" target="_blank" rel="external nofollow noopener noreferrer">cybernetics</a>的控制系统的意味。随着容器技术的广泛应用，特别是docker的流行，对于容器编排系统的需求导致了kubernetes的出现。docker具有集装箱的意思，而kubernetes就是管理运送集装箱的舵手。</p><p>2014年中，kubernetes首次被宣布，前期的主要开发人员来自于Google的 <a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager" target="_blank" rel="external nofollow noopener noreferrer">Borg</a>)系统，它的发展与设计也深受Borg影响。与Borg采用C++设计不同，kubernetes一开始就采用Go语言实现。</p><p>Kubernetes v1.0 was released on July 21, 2015.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-13" target="_blank" rel="external nofollow noopener noreferrer">[13]</a> Along with the Kubernetes v1.0 release, Google partnered with the <a href="https://en.wikipedia.org/wiki/Linux_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Linux Foundation</a> to form the <a href="https://en.wikipedia.org/wiki/Cloud_Native_Computing_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Cloud Native Computing Foundation</a> (CNCF)<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-14" target="_blank" rel="external nofollow noopener noreferrer">[14]</a> and offered Kubernetes as a seed technology. On March 6, 2018, Kubernetes Project reached ninth place in commits at GitHub, and second place in authors and issues to the <a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="external nofollow noopener noreferrer">Linux kernel</a>.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-15" target="_blank" rel="external nofollow noopener noreferrer">[15]</a></p><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p><p>这是一艘载着一堆集装箱的轮船，轮船在大海上运着集装箱奔波，把集装箱送到它们该去的地方。我们之前其实介绍过一个概念叫做 container，container 这个英文单词也有另外的一个意思就是“集装箱”。Kubernetes 也就借着这个寓意，希望成为运送集装箱的一个轮船，来帮助我们管理这些集装箱，也就是管理这些容器。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/1f/a7/1f5c9e99df79ea86ca5062fef22e21a7.png"></p><h3 id="应用部署演进"><a href="#应用部署演进" class="headerlink" title="应用部署演进"></a>应用部署演进</h3><ul><li>传统部署时代：直接在物理服务器上部署应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。<ul><li>如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。</li><li>一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li></ul></li><li>虚拟化部署时代：引入虚拟化功能，允许在单个物理服务器的 CPU 上运行多个虚拟机（VM）。<ul><li>虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。</li><li>因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。</li><li>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li></ul></li><li>容器化部署时代：容器是轻量级的虚拟化，相对于虚拟机，其具有更多的优势<ul><li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过快速简单的回滚(由于镜像不可变性)，提供可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像，从而将应用程序与基础架构分离。</li><li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li><li>云和操作系统分发的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、Google Kubernetes Engine 和其他任何地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li><li>资源隔离：可预测的应用程序性能。</li><li>资源利用：高效率和高密度。</li></ul></li></ul><p><img alt="Container Evolution" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_container-evolution.svg"></p><p>沿着虚拟化的路径，容器流行后需要有容器编排管理的服务，于是诞生了kubernetes。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><p><strong>服务发现与负载均衡</strong></p><p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>Kubernetes 允许自动挂载选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p><strong>自动二进制打包</strong><br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong><br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 </p></li></ul><h2 id="Kubernetes-Components"><a href="#Kubernetes-Components" class="headerlink" title="Kubernetes Components"></a>Kubernetes Components</h2><p>Kubernetes集群是由众多的Node组成，遵循主从架构，整个Kubernetes集群可以被划分为控制面和控制面管理的众多Node。</p><p><img alt="Kubernetes Components" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_components-of-kubernetes.png"></p><h3 id="Control-Plane-Components"><a href="#Control-Plane-Components" class="headerlink" title="Control Plane Components"></a>Control Plane Components</h3><p>Kubernetes 的控制面负责对集群作出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的Pod）。控制面的组建可以在集群中的任意节点中运行，但是通常会在同一个节点上启动所有控制面的组建，并且这个节点不再运行用户容器，此即称作Master节点。控制面的每一个组件都既可以运行在单master节点，也可以运行在多master节点以实现高可用。</p><p>Master节点包含四个主要的组件：API Server、Controller Manager、Scheduler 以及 Etcd，如下图所示。</p><p><img alt="Control Plane" data-src="https://platform9.com/wp-content/uploads/2019/05/kubernetes-constructs-concepts-architecture.jpg"></p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>kube-apiserver 是 Kubernetes 最重要的核心组件之一，暴露了Kubernetes API，是控制面的前端组件，它主要提供以下的功能：</p><ul><li>提供集群管理的 REST API 接口，实现了认证、授权、准入控制等安全校验功能，同时也负责集群状态的存储操作（通过 etcd）。</li><li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</li></ul><p><img alt="Kube Api Server" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_kube-apiserver.png"></p><p>在实际使用中，通常通过 <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/" target="_blank" rel="external nofollow noopener noreferrer">kubectl</a> 来访问 apiserver，也可以通过 Kubernetes 各个语言的 client 库来访问 apiserver。在使用 kubectl 时，打开调试日志也可以看到每个 API 调用的格式，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --v=8 get pods</span><br></pre></td></tr></table></figure><p>可通过 <code>kubectl api-versions</code> 和 <code>kubectl api-resources</code> 查询 Kubernetes API 支持的 API 版本以及资源对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-versions</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br><span class="line">apiextensions.k8s.io/v1beta1</span><br><span class="line">apiregistration.k8s.io/v1</span><br><span class="line">apiregistration.k8s.io/v1beta1</span><br><span class="line">apps/v1</span><br><span class="line">apps/v1beta1</span><br><span class="line">apps/v1beta2</span><br><span class="line">authentication.k8s.io/v1</span><br><span class="line">authentication.k8s.io/v1beta1</span><br><span class="line">authorization.k8s.io/v1</span><br><span class="line">authorization.k8s.io/v1beta1</span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">batch/v1</span><br><span class="line">batch/v1beta1</span><br><span class="line">certificates.k8s.io/v1beta1</span><br><span class="line">events.k8s.io/v1beta1</span><br><span class="line">extensions/v1beta1</span><br><span class="line">metrics.k8s.io/v1beta1</span><br><span class="line">networking.k8s.io/v1</span><br><span class="line">policy/v1beta1</span><br><span class="line">rbac.authorization.k8s.io/v1</span><br><span class="line">rbac.authorization.k8s.io/v1beta1</span><br><span class="line">scheduling.k8s.io/v1beta1</span><br><span class="line">storage.k8s.io/v1</span><br><span class="line">storage.k8s.io/v1beta1</span><br><span class="line">v1</span><br><span class="line"></span><br><span class="line">$ kubectl api-resources --api-group=storage.k8s.io</span><br><span class="line">NAME                SHORTNAMES   APIGROUP         NAMESPACED   KIND</span><br><span class="line">storageclasses      sc           storage.k8s.io   <span class="literal">false</span>        StorageClass</span><br><span class="line">volumeattachments                storage.k8s.io   <span class="literal">false</span>        VolumeAttachment</span><br></pre></td></tr></table></figure><h4 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h4><p>Etcd是一个分布式的键值数据库，兼具一致性和高可用性，API Server 中所需要的这些原信息都被放置在 etcd 中。Etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。</p><h4 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h4><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p><p><img alt="controller manager" data-src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/controller-manager.png"></p><p>每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。从逻辑上讲，每个<a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="external nofollow noopener noreferrer">控制器</a>都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><p>我们刚刚提到的 API Server，它本身在部署结构上是一个可以水平扩展的一个部署组件；Controller 是一个可以进行热备的一个部署组件，它只有一个 active，它的调度器也是相应的，虽然只有一个 active，但是可以进行热备。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>Scheduler是Master节点上的调度器组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><p>Scheduler在整个系统中起”承上启下”作用：</p><ul><li>承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node</li><li>启下：Node上的kubelet接管Pod的生命周期。</li></ul><p>Scheduler的主要工作：</p><ul><li><p>通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中</p></li><li><p>kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</p><p><img alt="Scheduler" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/scheduler.png"></p></li></ul><p>Scheduler的调度流程：</p><ul><li>预选调度过程，即遍历所有目标Node，筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择</li><li>确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。</li></ul><p>调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。</p><h3 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a><strong>Node Components</strong></h3><p>Kubernetes 的 Node 是真正运行业务负载的，每个业务负载会以 Pod 的形式运行。一个 Pod 中运行的一个或者多个容器，真正去运行这些 Pod 的组件的是叫做 <strong>kubelet</strong>，也就是 Node 上最为关键的组件，它通过 API Server 接收到所需要 Pod 运行的状态，然后提交到 Container Runtime 组件中。</p><p>在 OS 上去创建容器所需要运行的环境，最终把容器或者 Pod 运行起来，也需要对存储跟网络进行管理。Kubernetes 并不会直接进行网络存储的操作，他们会靠 Storage Plugin 或者是网络的 Plugin 来进行操作。用户自己或者云厂商都会去写相应的 <strong>Storage Plugin</strong> 或者 <strong>Network Plugin</strong>，去完成存储操作或网络操作。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/5c/f8/5c9fe50067821e9e86a74cae4cbdd9f8.png"></p><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>Kubelet是Node上的pod管家。在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。</p><h4 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h4><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="external nofollow noopener noreferrer">kube-proxy</a> 是集群中每个节点上运行的网络代理,实现 Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。</p><h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>Container Runtime（容器运行时）是负责容器运行的软件。</p><p>Kubernetes支持几种容器运行时环境：Docker、Containerd、CRI-O等。</p><h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a><strong>Addons</strong></h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>尽管并非严格要求其他附加组件，但所有示例都依赖<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="external nofollow noopener noreferrer">集群 DNS</a>，因此所有 Kubernetes 集群都应具有 DNS。</p><p>除了您环境中的其他 DNS 服务器之外，集群 DNS 还是一个 DNS 服务器，它为 Kubernetes 服务提供 DNS 记录。</p><p>Cluster DNS 是一个 DNS 服务器，和您部署环境中的其他 DNS 服务器一起工作，为 Kubernetes 服务提供DNS记录。</p><p>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中。</p><h4 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h4><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="external nofollow noopener noreferrer">Dashboard</a> 是 Kubernetes 集群的通用基于 Web 的 UI。它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="Container-Resource-Monitoring"><a href="#Container-Resource-Monitoring" class="headerlink" title="Container Resource Monitoring"></a>Container Resource Monitoring</h4><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="external nofollow noopener noreferrer">容器资源监控</a>将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p><h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="external nofollow noopener noreferrer">集群层面日志</a> 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面我们以一个例子再去看一下 Kubernetes 架构中的这些组件，是如何互相进行 interaction 的。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/04/9b/047e4723316d6424b26341de5007329b.png"></p><p>用户可以通过 UI 或者 CLI 提交一个 Pod 给 Kubernetes 进行部署，这个 Pod 请求首先会通过 CLI 或者 UI 提交给 Kubernetes API Server，下一步 API Server 会把这个信息写入到它的存储系统 etcd，之后 Scheduler 会通过 API Server 的 watch 或者叫做 notification 机制得到这个信息：有一个 Pod 需要被调度。</p><p>这个时候 Scheduler 会根据它的内存状态进行一次调度决策，在完成这次调度之后，它会向 API Server report 说：“OK！这个 Pod 需要被调度到某一个节点上。”</p><p>这个时候 API Server 接收到这次操作之后，会把这次的结果再次写到 etcd 中，然后 API Server 会通知相应的节点进行这次 Pod 真正的执行启动。相应节点的 kubelet 会得到这个通知，kubelet 就会去调 Container runtime 来真正去启动配置这个容器和这个容器的运行环境，去调度 Storage Plugin 来去配置存储，network Plugin 去配置网络。</p><p>这个例子我们可以看到：这些组件之间是如何相互沟通相互通信，协调来完成一次 Pod 的调度执行操作的。</p><h2 id="The-Kubernetes-API"><a href="#The-Kubernetes-API" class="headerlink" title="The Kubernetes API"></a>The Kubernetes API</h2><p>Kubernetes API 允许你查询和操作 Kubernetes 集群中对象的状态。Kubernetes集群控制面的核心是 Api Server 以及他暴露的 HTTP API。用户，集群中的其他部分，还有外部组件都是通过API Server进行通信。</p><h3 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h3><p>为了使删除字段或者重构资源表示更加容易，Kubernetes 支持 多个API版本。每一个版本都在不同API路径下，例如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1</code>。</p><p>我们选择在API级别进行版本化，而不是在资源或字段级别进行版本化，以确保API提供清晰，一致的系统资源和行为视图，并控制对已废止的API和/或实验性API的访问。 JSON和Protobuf序列化模式遵循架构更改的相同准则 - 下面的所有描述都同时适用于这两种格式。</p><p>请注意，API版本控制和软件版本控制只有间接相关性。 <a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md" target="_blank" rel="external nofollow noopener noreferrer">API和发行版本建议</a> 描述了API版本与软件版本之间的关系。</p><p>不同的API版本名称意味着不同级别的软件稳定性和支持程度。 每个级别的标准在<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions" target="_blank" rel="external nofollow noopener noreferrer">API变更文档</a>中有更详细的描述。 内容主要概括如下：</p><ul><li>Alpha 测试版本：<ul><li>版本名称包含了 <strong><code>alpha</code></strong> (例如：<strong><code>v1alpha1</code></strong>)。</li><li>可能是有缺陷的。启用该功能可能会带来隐含的问题，默认情况是关闭的。</li><li>支持的功能可能在没有通知的情况下随时删除。</li><li>API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知。</li><li>由于bugs风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</li></ul></li><li>Beta 测试版本：<ul><li>版本名称包含了 <strong><code>beta</code></strong> (例如: <strong><code>v2beta3</code></strong>)。</li><li>代码已经测试过。启用该功能被认为是安全的，功能默认已启用。</li><li>所有已支持的功能不会被删除，细节可能会发生变化。</li><li>对象的模式和/或语义可能会在后续的beta测试版或稳定版中以不兼容的方式进行更改。 发生这种情况时，我们将提供迁移到下一个版本的说明。 这可能需要删除、编辑和重新创建API对象。执行编辑操作时需要谨慎行事，这可能需要停用依赖该功能的应用程序。</li><li>建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。 如果您有多个可以独立升级的集群，则可以放宽此限制。</li><li><strong>请尝试我们的 beta 版本功能并且给出反馈！一旦他们退出 beta 测试版，我们可能不会做出更多的改变。</strong></li></ul></li><li>稳定版本：<ul><li>版本名称是 <strong><code>vX</code></strong>，其中 <strong><code>X</code></strong> 是整数。</li></ul></li></ul><h3 id="API-描述"><a href="#API-描述" class="headerlink" title="API 描述"></a>API 描述</h3><p>下面我们介绍一下 Kubernetes 的 API 的基础知识。从 high-level 上看，Kubernetes API 是由 <strong>HTTP+JSON </strong> 组成的：用户访问的方式是 HTTP，访问的 API 中 content 的内容是 JSON 格式的。</p><p>Kubernetes 的 kubectl 也就是 command tool，Kubernetes UI，或者有时候用 curl，直接与 Kubernetes 进行沟通，都是使用 HTTP + JSON 这种形式。</p><p>下面有个例子：比如说，对于这个 Pod 类型的资源，它的 HTTP 访问的路径，就是 API，然后是 apiVesion: V1, 之后是相应的 Namespaces，以及 Pods 资源，最终是 Podname，也就是 Pod 的名字。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/23/2e/23921b341e482ad31ce28fc15269ad2e.png"></p><p>如果我们去提交一个 Pod，或者 get 一个 Pod 的时候，它的 content 内容都是用 JSON 或者是 YAML 表达的。上图中有个 yaml 的例子，在这个 yaml file 中，对 Pod 资源的描述也分为几个部分。</p><p>第一个部分，一般来讲会是 API 的 <strong>version</strong>。比如在这个例子中是 V1，它也会描述我在操作哪个资源；比如说我的 <strong>kind</strong> 如果是 pod，在 Metadata 中，就写上这个 Pod 的名字；比如说 nginx，我们也会给它打一些 <strong>label</strong>，我们等下会讲到 label 的概念。在 Metadata 中，有时候也会去写 <strong>annotation</strong>，也就是对资源的额外的一些用户层次的描述。</p><h2 id="Kubernetes-Objects"><a href="#Kubernetes-Objects" class="headerlink" title="Kubernetes Objects"></a>Kubernetes Objects</h2><p>Kubernetes对象是Kubernetes集群中持久化的实体，通过这些实体可以代表集群的状态。具体的，它们可以描述以下内容：</p><ul><li>哪些容器化应用在运行（以及在哪个 Node 上）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p><p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>。比如，当使用 <code>kubectl</code> 命令行接口时，CLI 会执行必要的 Kubernetes API 调用，也可以在程序中使用 <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="external nofollow noopener noreferrer">客户端库</a> 直接调用 Kubernetes API。</p><h3 id="Object-Spec-and-Status"><a href="#Object-Spec-and-Status" class="headerlink" title="Object Spec and Status"></a>Object Spec and Status</h3><p>每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象 <em>spec</em> 和 对象 <em>status</em> 。 <em>spec</em> 是必需的，它描述了对象的 <em>期望状态（Desired State）</em> —— 希望对象所具有的特征。 <em>status</em> 描述了对象的 <em>实际状态（Actual State）</em> ，它是由 Kubernetes 系统提供和更新的。在任何时刻，Kubernetes 控制面一直努力地管理着对象的实际状态以与期望状态相匹配。</p><p>例如，Kubernetes Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能需要设置 Deployment 的规约，以指定该应用需要有 3 个副本在运行。 Kubernetes 系统读取 Deployment 规约，并启动我们所期望的该应用的 3 个实例 —— 更新状态以与规约相匹配。 如果那些实例中有失败的（一种状态变更），Kubernetes 系统通过修正来响应规约和状态之间的不一致 —— 这种情况，会启动一个新的实例来替换。</p><p>关于对象 spec、status 和 metadata 的更多信息，查看 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 约定</a>。</p><h3 id="Describing-a-Kubernetes-object"><a href="#Describing-a-Kubernetes-object" class="headerlink" title="Describing a Kubernetes object"></a>Describing a Kubernetes object</h3><p>当创建 Kubernetes 对象时，必须提供对象的Spec，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>），API 请求必须在请求体中包含 JSON 格式的信息。 <strong>大多数情况下，需要在 .yaml 文件中为 <code>kubectl</code> 提供这些信息</strong>。 <code>kubectl</code> 在发起 API 请求时，将这些信息转换成 JSON 格式。</p><p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：</p><figure class="highlight yaml"><figcaption><span>application/deployment.yaml </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="Required-Fields"><a href="#Required-Fields" class="headerlink" title="Required Fields"></a>Required Fields</h3><p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p><ul><li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li><li><code>kind</code> - 想要创建的对象的类型</li><li><code>metadata</code> - 帮助识别对象唯一性的数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li><li><code>spec</code> - 你对该对象期望的状态</li></ul><p>对象 <code>spec</code> 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 参考</a>能够帮助我们找到任何我们想创建的对象的 spec 格式。 例如，可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Pod</code> 的 <code>spec</code> 格式， 并且可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deploymentspec-v1-apps" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Deployment</code> 的 <code>spec</code> 格式。</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是 Kubernetes 应用程序的基本执行单元，是Kubernetes对象模型中创建的最小单元，Pod表示集群是运行的进程。</p><p>用户可以通过 Kubernetes 的 Pod API 生产一个 Pod，让 Kubernetes 对这个 Pod 进行调度，也就是把它放在某一个 Kubernetes 管理的节点上运行起来。一个 Pod 简单来说是对一组容器的抽象，它里面会包含一个或多个容器。</p><p>比如像下面的这幅图里面，它包含了两个容器，每个容器可以指定它所需要资源大小。比如说，一个核一个 G，或者说 0.5 个核，0.5 个 G。</p><p>当然在这个 Pod 中也可以包含一些其他所需要的资源：比如说我们所看到的 Volume 卷这个存储资源；比如说我们需要 100 个 GB 的存储或者 20GB 的另外一个存储。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/b2/9f/b246d174b3169a242ac5799bc962f69f.png"></p><p>在 Pod 里面，我们也可以去定义容器所需要运行的方式。比如说运行容器的 Command，以及运行容器的环境变量等等。Pod 这个抽象也给这些容器提供了一个共享的运行环境，它们会共享同一个网络环境，这些容器可以用 localhost 来进行直接的连接。而 Pod 与 Pod 之间，是互相有 isolation 隔离的。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume 就是卷的概念，它是用来管理 Kubernetes 存储的，是用来声明在 Pod 中的容器可以访问文件目录的，一个卷可以被挂载在 Pod 中一个或者多个容器的指定路径下面。</p><p>而 Volume 本身是一个抽象的概念，一个 Volume 可以去支持多种的后端的存储。比如说 Kubernetes 的 Volume 就支持了很多存储插件，它可以支持本地的存储，可以支持分布式的存储，比如说像 ceph，GlusterFS ；它也可以支持云存储，比如说阿里云上的云盘、AWS 上的云盘、Google 上的云盘等等。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/54/5b/542cf5c317c5e567ba63a720802ae85b.png"></p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 是在 Pod 这个抽象上更为上层的一个抽象，它可以定义一组 Pod 的副本数目、以及这个 Pod 的版本。一般大家用 Deployment 这个抽象来做应用的真正的管理，而 Pod 是组成 Deployment 最小的单元。</p><p>Kubernetes 是通过 Controller，也就是我们刚才提到的控制器去维护 Deployment 中 Pod 的数目，它也会去帮助 Deployment 自动恢复失败的 Pod。</p><p>比如说我可以定义一个 Deployment，这个 Deployment 里面需要两个 Pod，当一个 Pod 失败的时候，控制器就会监测到，它重新把 Deployment 中的 Pod 数目从一个恢复到两个，通过再去新生成一个 Pod。通过控制器，我们也会帮助完成发布的策略。比如说进行滚动升级，进行重新生成的升级，或者进行版本的回滚。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/4e/e2/4ea8feaad09e871bbca804e7f61738e2.png"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 提供了一个或者多个 Pod 实例的稳定访问地址。</p><p>比如在上面的例子中，我们看到：一个 Deployment 可能有两个甚至更多个完全相同的 Pod。对于一个外部的用户来讲，访问哪个 Pod 其实都是一样的，所以它希望做一次负载均衡，在做负载均衡的同时，我只想访问某一个固定的 VIP，也就是 Virtual IP 地址，而不希望得知每一个具体的 Pod 的 IP 地址。</p><p>我们刚才提到，这个 pod 本身可能 terminal go（终止），如果一个 Pod 失败了，可能会换成另外一个新的。</p><p>对一个外部用户来讲，提供了多个具体的 Pod 地址，这个用户要不停地去更新 Pod 地址，当这个 Pod 再失败重启之后，我们希望有一个抽象，把所有 Pod 的访问能力抽象成一个第三方的一个 IP 地址，实现这个的 Kubernetes 的抽象就叫 Service。</p><p>实现 Service 有多种方式，Kubernetes 支持 Cluster IP，上面我们讲过的 kuber-proxy 的组网，它也支持 nodePort、 LoadBalancer 等其他的一些访问的能力。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/bb/4a/bbcd5a617d228099f69ddc987ca18f4a.png"></p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace 是用来做一个集群内部的逻辑隔离的，它包括鉴权、资源管理等。Kubernetes 的每个资源，比如刚才讲的 Pod、Deployment、Service 都属于一个 Namespace，同一个 Namespace 中的资源需要命名的唯一性，不同的 Namespace 中的资源可以重名。</p><p>Namespace 一个用例，比如像在阿里巴巴，我们内部会有很多个 business units，在每一个 business units 之间，希望有一个视图上的隔离，并且在鉴权上也不一样，在 cuda 上面也不一样，我们就会用 Namespace 来去给每一个 BU 提供一个他所看到的这么一个看到的隔离的机制。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/a0/4d/a00719f494ae94a40be0be6012e5134d.png"></p><h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><p>参考 <a href="https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl</span></span><br><span class="line"><span class="comment">## 声明式资源管理</span></span><br><span class="line"><span class="comment"># kubectl apply</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令式资源管理</span></span><br><span class="line"><span class="comment"># kubectl create</span></span><br><span class="line"><span class="comment"># kubectl expose</span></span><br><span class="line"><span class="comment"># kubectl scale</span></span><br><span class="line"><span class="comment"># kubectl annotate</span></span><br><span class="line"><span class="comment"># kubectl label</span></span><br><span class="line"><span class="comment"># kubectl delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl get</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl get [(-o|--output=)](TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags] [options]</span><br><span class="line"><span class="comment"># Examples: </span></span><br><span class="line">kubectl get services                          <span class="comment"># 列出当前NS中所有service资源</span></span><br><span class="line">kubectl get pods --all-namespaces             <span class="comment"># 列出集群所有NS中所有的Pod</span></span><br><span class="line">kubectl get pods -o wide                      <span class="comment"># -o wide也比较常用，可以显示更多资源信息，比如pod的IP等</span></span><br><span class="line">kubectl get deployment my-dep                 <span class="comment"># 可以直接指定资源名查看</span></span><br><span class="line">kubectl get deployment my-dep --watch         <span class="comment"># --watch 参数可以监控资源的状态，在状态变换时输出。在跟踪服务部署情况时很有用</span></span><br><span class="line">kubectl get pod my-pod -o yaml                <span class="comment"># 查看yaml格式的资源配置，这里包括资实际的status，可以用--export排除</span></span><br><span class="line">kubectl get pod my-pod -l app=nginx           <span class="comment"># 查看所有带有标签app: nginx的pod</span></span><br><span class="line"><span class="comment"># kubectl describe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器管理</span></span><br><span class="line"><span class="comment"># kubectl log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl exec</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> POD [-c CONTAINER] -- COMMAND [args...] [options]</span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod ls                         <span class="comment"># 对my-pod执行ls命令</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -t -i nginx-78f5d695bd-czm8z bash <span class="comment"># 进入pod的shell，并打开伪终端和标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl cp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 集群管理</span></span><br><span class="line"><span class="comment"># kubectl cluster-info</span></span><br><span class="line"><span class="comment"># kubectl version</span></span><br><span class="line"><span class="comment"># kubectl cordon/uncordon</span></span><br><span class="line"><span class="comment"># kubectl drain</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_kubernetes.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="CNCF" scheme="http://houmin.cc/tags/CNCF/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="系统设计" scheme="http://houmin.cc/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业快乐</title>
    <link href="http://houmin.cc/posts/959c2cfa/"/>
    <id>http://houmin.cc/posts/959c2cfa/</id>
    <published>2020-07-05T14:58:46.000Z</published>
    <updated>2020-07-20T01:30:36.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。</p><a id="more"></a><h2 id="欢迎回家"><a href="#欢迎回家" class="headerlink" title="欢迎回家"></a>欢迎回家</h2><p>在 7 月 5 日，我得到一次毕业生返校机会，用于打包行李。在此之前，我已经委托 HT 和 CR 帮忙把行李寄了出来，事实上已经没有什么东西需要打包。但是我仍然申请了返校，为的是再以毕业生的身份看一看燕园。在去年冬天，刚开始迷上摄影的我在下雪的燕园拍了好些照片，当时的我还想着要好好利用这最后的半年，多拍一些学校的照片。没想到这次的疫情直接导致了这半年完全不能回来，真的很遗憾了。</p><p><img alt="欢迎回家，半年后再次回到燕园" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_welcome-back.jpg"></p><p>作为 <a href="../c924112f">对比</a>，我在去年冬天拍照的机位再次拍摄了夏天的景色，再见燕园已经是另一幅样子。</p><p><img alt="夏日翠影中的塞万提斯" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_cervantes.jpg"></p><p><img alt="大雅之堂" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_daya.jpg"></p><p><img alt="上次拍的这个视角，正是几个女孩子在这里堆雪人，今天的静园静悄悄的，只有偶尔几个毕业生过来拍照" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_green.jpg"></p><p><img alt="南北阁，夏天的味道" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_south-north.jpg"></p><p><img alt="二体，与冬天下雪时不同，这次回来正下着零星的小雨" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_roof.jpg"></p><p><img alt="夏日未名湖，没有冰场，没有雪花，只有满满的绿色" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_tower.jpg"></p><h2 id="毕业快乐"><a href="#毕业快乐" class="headerlink" title="毕业快乐"></a>毕业快乐</h2><p>2013年8月29日，我和大姐二姐第一次来到燕园，那天还没有正式开学，小雨迷蒙，绕着燕园转了好半天，当时觉得燕园很大，一切都很新，未来充满希望；2020年7月5日，我最后一次以学生的身份回到燕园，同样是小雨淅沥，时隔半年，燕园显得熟悉而又陌生。在2017年的夏天，我已经毕业过一次。只是那一次，从本专业本科保研到对应实验室，毕业的感觉并没有很强烈。但是这一次，是彻底结束了学生生涯，走向社会，走向独立。七年前，我对于未来会如何发展一无所知，不知道自己未来会去向何处；今天，我对于自己想做什么内心大致有了方向，但是不确定性仍然存在。在这七年间，我见到了很多很厉害，很努力，很有趣的同学，他们始终是我前进和奋斗的榜样。我一直会告诉自己，我永远可以变得更好。</p><p>当我坐着自如搬家师傅帮我把好几大箱的行李搬到租住的房间，看着行李我累得完全不想动，我清醒地意识到，从此刻开始，我的学生生涯永远不再。我甚至还不争气的流下了眼泪，仿佛是为了给自己一个正式的道别。毋庸置疑，毕业是人生中的一个重要节点，从社会意义上来讲你完成了你身份的转变。但是毕业真的是那么值得伤感的一件事情吗？看到一些师兄毕业后的生活状态，按照他们的话说，从此成为一名社畜，日常995，还得承受工作的压力。也许这就是现实，但是我还是愿意乐观一点。对我来说，毕业标志着我进入了人生新的一个阶段，你需要在这个阶段去做更有意义、有价值的事情。也许有时候会很辛苦，但是作为一个独立的人，你可以探索更多有意思的事情。</p><p>毕业快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-02_graduation.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="毕业" scheme="http://houmin.cc/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>西湖印象</title>
    <link href="http://houmin.cc/posts/2f653e3b/"/>
    <id>http://houmin.cc/posts/2f653e3b/</id>
    <published>2020-06-20T07:05:47.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。</p><p>这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。</p><a id="more"></a><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><img alt="这天去西湖的时候，天空的云彩特别好看，再加上山峦剪影，很有感觉" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-lake.jpg"></p><p><img alt="在这个地方拍了会延时，发现还是日落那会拍延时更好看，这里镜头应该往前推一点" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-tower.jpg"></p><p><img alt="厨师帽？" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-hat.jpg"></p><h2 id="湖"><a href="#湖" class="headerlink" title="湖"></a>湖</h2><p><img alt="集贤亭，走到这里看到很多大爷专业设备都准备好了，经典取景地" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_pavilion.jpg"></p><p><img alt="不是三潭印月，拍的晚霞时的小亭子" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_tower.jpg"></p><p><img alt="湖边的旅游警察" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_police.jpg"></p><h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p><img alt="湖边喂鸽子的小女孩，这个小男孩正在看着下一张图片的场景" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_dove.jpg"></p><p><img alt="对，一大堆人正在喂着小松鼠，西湖边的松鼠可真多" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_squirrel.jpg"></p><p><img alt="前一天过来转的时候，正好下雨，碰到一对在湖边看风景的情侣，很有感觉" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_lover.jpg"></p><h2 id="霞"><a href="#霞" class="headerlink" title="霞"></a>霞</h2><p>傍晚的时候又拍了会延时，没带三脚架，镜头有一些晃动，下次再弄弄</p><iframe src="//player.bilibili.com/player.html?aid=796036715&bvid=BV1CC4y1a7iw&cid=203569493&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。&lt;/p&gt;
&lt;p&gt;这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_pavilion.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="西湖" scheme="http://houmin.cc/tags/%E8%A5%BF%E6%B9%96/"/>
    
      <category term="杭州" scheme="http://houmin.cc/tags/%E6%9D%AD%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>【普鲁斯特问卷】2020</title>
    <link href="http://houmin.cc/posts/ab5f63d0/"/>
    <id>http://houmin.cc/posts/ab5f63d0/</id>
    <published>2020-05-25T12:23:33.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? </p><p>作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）</p><a id="more"></a><p>话不多说，我们开始。</p><h3 id="你认为最完美的快乐是怎样的？"><a href="#你认为最完美的快乐是怎样的？" class="headerlink" title="你认为最完美的快乐是怎样的？"></a><strong>你认为最完美的快乐是怎样的？</strong></h3><ul><li>做成一件事之后的满足感。</li><li>和好朋友一起无所忌惮的吐槽。</li><li>运动完之后多巴胺分泌的快感。</li></ul><h3 id="你最希望拥有哪种才华？"><a href="#你最希望拥有哪种才华？" class="headerlink" title="你最希望拥有哪种才华？"></a><strong>你最希望拥有哪种才华？</strong></h3><p>羡慕那些拥有绝对音感的人，希望自己能够拥有音乐方面的才华。</p><p>最近在玩卡林巴和尤克里里，记谱对我来说真的是一件困难的事情，心手协调更是需要训练。一直觉得那些音乐创作人是很厉害的存在，自己也想要学乐器词曲，期待有一天能够创作出在音乐上自己的作品。</p><h3 id="你最恐惧的是什么？"><a href="#你最恐惧的是什么？" class="headerlink" title="你最恐惧的是什么？"></a><strong>你最恐惧的是什么？</strong></h3><p>快节奏的都市生活，害怕自己陷入对升职加薪追求的焦虑，而忘了自己到底想要什么。</p><h3 id="你目前的心境怎样？"><a href="#你目前的心境怎样？" class="headerlink" title="你目前的心境怎样？"></a><strong>你目前的心境怎样？</strong></h3><p>现在的我，身处杭州，刚刚提交毕业论文，准备着毕业答辩。将近 20 年的学生生涯即将结束，期待着顺利完成答辩，开始职场的生活。希望能够回到北京，见到那些很久没有见到的朋友。马上就要工作，开始自己独立的生活，希望自己之后的生活忙碌而有节奏，有机会的话也许可以认识我喜欢的人。</p><h3 id="还在世的人中你最钦佩的是谁？"><a href="#还在世的人中你最钦佩的是谁？" class="headerlink" title="还在世的人中你最钦佩的是谁？"></a><strong>还在世的人中你最钦佩的是谁？</strong></h3><p>Linus，开源软件之神。</p><h3 id="你认为自己最伟大的成就是什么？"><a href="#你认为自己最伟大的成就是什么？" class="headerlink" title="你认为自己最伟大的成就是什么？"></a><strong>你认为自己最伟大的成就是什么？</strong></h3><p>距今为止，没有什么伟大的成就。</p><p>希望自己以后能够做出一些有意义，有价值的事情。</p><h3 id="你自己的哪个特点让你最觉得痛恨？"><a href="#你自己的哪个特点让你最觉得痛恨？" class="headerlink" title="你自己的哪个特点让你最觉得痛恨？"></a><strong>你自己的哪个特点让你最觉得痛恨？</strong></h3><p>不够勇敢，不能勇敢地说出自己的喜欢。</p><h3 id="你最喜欢的旅行是哪一次？"><a href="#你最喜欢的旅行是哪一次？" class="headerlink" title="你最喜欢的旅行是哪一次？"></a><strong>你最喜欢的旅行是哪一次？</strong></h3><p>去年找完工作后，<code>Four Sum</code>一起的云南之旅。</p><p>经历了春天的找实习与夏天的找工作，确定完工作去向后，精神一下子放松下来，实验室的四个同学一起说走就走，去了大理和丽江。大理风光很美，苍山洱海，分外惬意；丽江古镇差强人意，玉龙雪山蓝月谷令人惊异。除了美丽的自然风光，主要还是当时四个人都轻松自在，潇洒自得。</p><p>大西南可以去很多次，还有大西北，期望以后有机会可以和自己喜欢的人一起去旅行。</p><h3 id="你最痛恨别人的什么特点？"><a href="#你最痛恨别人的什么特点？" class="headerlink" title="你最痛恨别人的什么特点？"></a><strong>你最痛恨别人的什么特点？</strong></h3><p>虚伪。</p><p>讨厌虚伪的客套，对真诚、聪明、对世界有热情的人自带好感。</p><h3 id="你最珍惜的财产是什么？"><a href="#你最珍惜的财产是什么？" class="headerlink" title="你最珍惜的财产是什么？"></a><strong>你最珍惜的财产是什么？</strong></h3><p>宝贵的时间，自由的灵魂。</p><h3 id="你最奢侈的是什么？"><a href="#你最奢侈的是什么？" class="headerlink" title="你最奢侈的是什么？"></a><strong>你最奢侈的是什么？</strong></h3><p>爱与被爱。</p><h3 id="你认为程度最浅的痛苦是什么？"><a href="#你认为程度最浅的痛苦是什么？" class="headerlink" title="你认为程度最浅的痛苦是什么？"></a><strong>你认为程度最浅的痛苦是什么？</strong></h3><p>不了解万千世界的痛苦。</p><h3 id="你认为哪种美德是被过高的评估的？"><a href="#你认为哪种美德是被过高的评估的？" class="headerlink" title="你认为哪种美德是被过高的评估的？"></a><strong>你认为哪种美德是被过高的评估的？</strong></h3><p>艰苦朴素，无私奉献。</p><p>哪里有那么多的无私，更多的是无奈与不舍。不是很喜欢新闻里面那些对于无私奉献广泛的宣传，我更喜欢那些给这些人优厚的物质与精神回报，并宣传之，比如最近的海尔救人小哥奖房的宣传我就挺喜欢的。</p><h3 id="你最喜欢的职业是什么？"><a href="#你最喜欢的职业是什么？" class="headerlink" title="你最喜欢的职业是什么？"></a><strong>你最喜欢的职业是什么？</strong></h3><p>工程师。</p><p>用自己的双手构建自己的世界。</p><h3 id="你对自己的外表哪一点不满意？"><a href="#你对自己的外表哪一点不满意？" class="headerlink" title="你对自己的外表哪一点不满意？"></a><strong>你对自己的外表哪一点不满意？</strong></h3><p>整体上挺满意的，就是之前脸上的痘痘让我有些烦恼。</p><p>不过，经过最近一段时间的调养，痘痘已经基本消失啦，接下来就是消除痘印了。</p><h3 id="你最后悔的事情是什么？"><a href="#你最后悔的事情是什么？" class="headerlink" title="你最后悔的事情是什么？"></a><strong>你最后悔的事情是什么？</strong></h3><p>做过很多后悔的事情，最后悔的还是与人相关。在不懂事的时候，说过一些令人伤心的话，尤其是对那些爱自己的人。现在想起来那些场景，脸上依然会不由自主的发烫。</p><h3 id="还在世的人中你最鄙视的是谁？"><a href="#还在世的人中你最鄙视的是谁？" class="headerlink" title="还在世的人中你最鄙视的是谁？"></a><strong>还在世的人中你最鄙视的是谁？</strong></h3><p>不太好说鄙视谁，鄙视那些身在其位不谋其政的人。</p><h3 id="你最喜欢男性身上的什么品质？"><a href="#你最喜欢男性身上的什么品质？" class="headerlink" title="你最喜欢男性身上的什么品质？"></a><strong>你最喜欢男性身上的什么品质？</strong></h3><p>大气。</p><p>待人接物落落大方，不卑不亢；处理事情自信沉稳，界限分明；对个人专业熟稔明晰，对不是自己的专业充满好奇心，能够积极主动的去了解；对爱的人温柔体贴，以真心告以真心。</p><h3 id="你使用过的最多的单词或者是词语是什么？"><a href="#你使用过的最多的单词或者是词语是什么？" class="headerlink" title="你使用过的最多的单词或者是词语是什么？"></a><strong>你使用过的最多的单词或者是词语是什么？</strong></h3><p>哈哈哈。</p><h3 id="你最喜欢女性身上的什么品质？"><a href="#你最喜欢女性身上的什么品质？" class="headerlink" title="你最喜欢女性身上的什么品质？"></a><strong>你最喜欢女性身上的什么品质？</strong></h3><p>我最喜欢女性的品质，是温柔与活泼、有自己的思考、善于沟通、具有爱人与被爱的能力。</p><h3 id="你最伤痛的事是什么？"><a href="#你最伤痛的事是什么？" class="headerlink" title="你最伤痛的事是什么？"></a><strong>你最伤痛的事是什么？</strong></h3><p>最伤痛的事情，莫过于全然付出的真心不被对方珍视吧。</p><h3 id="你最看重朋友的什么特点？"><a href="#你最看重朋友的什么特点？" class="headerlink" title="你最看重朋友的什么特点？"></a><strong>你最看重朋友的什么特点？</strong></h3><p>真诚、靠谱、乐观。</p><p>不喜欢虚伪滑头的人，也不喜欢一直悲悲戚戚的人。</p><h3 id="你这一生中最爱的人或东西是什么？"><a href="#你这一生中最爱的人或东西是什么？" class="headerlink" title="你这一生中最爱的人或东西是什么？"></a><strong>你这一生中最爱的人或东西是什么？</strong></h3><p>或许是我自己？</p><p>我希望我自己永远能够变得更好，也希望自己能够给自己爱的人带来更多的欢乐。</p><h3 id="你希望以什么样的方式死去？"><a href="#你希望以什么样的方式死去？" class="headerlink" title="你希望以什么样的方式死去？"></a><strong>你希望以什么样的方式死去？</strong></h3><p>我希望自己能够平平静静的走，就像睡着了那样，不要拖累自己的孩子们，也不要因为化疗等让自己万分痛苦。</p><p>另外，如果年老的时候我心爱的人在我身边时，我希望她能够走在我的前面，不要留她一个人在后面。</p><h3 id="如果你可以改变你的家庭一件事，那会是什么？"><a href="#如果你可以改变你的家庭一件事，那会是什么？" class="headerlink" title="如果你可以改变你的家庭一件事，那会是什么？"></a><strong>如果你可以改变你的家庭一件事，那会是什么？</strong></h3><p>如果可以改变的话，希望小时候爷爷和妈妈的关系能够好一些吧。两个人都很爱我，但是却因为爷爷的一些难以改变的观念，导致他们两人关系一直很差。即使如此，妈妈在爷爷走的时候仍然贴心的照顾他，如果之前关系能够好一些，那么小时候的家庭可以说很完美吧。</p><p>不过这些都是已经过去的事情了，现在家里的孩子都已经长大，爷爷已经离去。虽然不是大富大贵之家，小康家庭倒也过的很好，还记得爸妈为了家里能够过的更好一些而辛苦地工作，朴素的家庭条件也给我们留下了勤恳踏实的作风。</p><h3 id="如果你能选择的话，你希望让什么重现？"><a href="#如果你能选择的话，你希望让什么重现？" class="headerlink" title="如果你能选择的话，你希望让什么重现？"></a><strong>如果你能选择的话，你希望让什么重现？</strong></h3><p>爱。</p><p>现在仍然单身一人，希望能够找到一个自己喜欢，并且她也喜欢我的人。</p><h3 id="你的座右铭是什么？"><a href="#你的座右铭是什么？" class="headerlink" title="你的座右铭是什么？"></a><strong>你的座右铭是什么？</strong></h3><blockquote><p>我将融入剧烈争斗的大人世界，要在那边孤军奋战，必须变得比任何人都坚不可摧。</p></blockquote><p>倒也不是座右铭，一直没有明确的座右铭，只是正好看到这句话比较符合当前的心境罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? &lt;/p&gt;
&lt;p&gt;作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-05-25_proustquestionnaire.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="价值观" scheme="http://houmin.cc/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"/>
    
      <category term="普鲁斯特问卷" scheme="http://houmin.cc/tags/%E6%99%AE%E9%B2%81%E6%96%AF%E7%89%B9%E9%97%AE%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>四月物语</title>
    <link href="http://houmin.cc/posts/43b91bee/"/>
    <id>http://houmin.cc/posts/43b91bee/</id>
    <published>2020-04-25T05:40:59.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。</p>    <div id="aplayer-KFXcoxae" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="610725" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><p>最近在忙些啥？对，我在写论文，持续处于焦虑状态，期待能够早点写完，具体心情此处不表。夏天真的来了，眼见着窗外的杉树从冬日的灰冷，到春日的嫩绿，到现在的青翠。一转眼，已经在家呆了三个多月，冬日归来，到现在也不知何日返京。每天早上起来，听到窗外清脆的鸟叫声，会觉得这样每天在家的日子也很不错。但是，实际上这些天的状态并不是很好，毕业的焦虑，每天早上翻看着最新疫情的状况，期待着能够早点回到北京，早点回到正常的生活中。</p><p>然而，现实却告诉我，很有可能我们即将面临一种新常态了。在未来的一两年中，新冠可能将会持续潜伏在我们身边。这是一次真正引起全局性改变的疫情。作为毕业生，可以预见，北京应该会在五月份或者六月份让我们回去，可能只是收拾行李，毕业典礼之类的活动很可能都没了，真的是很难得的毕业季。</p><p>所有的这些，对我有什么影响？这些都是我所无力改变的现实，相比于父辈祖辈们所见识过的历史，这些都还只能算是开始。我能够做些什么呢？继续沉淀自己吧，好好的完成毕业论文，继续学习和总结。</p><p>等，春天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。&lt;/p&gt;

    &lt;div id=&quot;aplayer-KFXcoxae&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;610725&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-25_beyond-the-window.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="春天" scheme="http://houmin.cc/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="新冠" scheme="http://houmin.cc/tags/%E6%96%B0%E5%86%A0/"/>
    
      <category term="新常态" scheme="http://houmin.cc/tags/%E6%96%B0%E5%B8%B8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>【备忘录】播客录</title>
    <link href="http://houmin.cc/posts/d7e805bd/"/>
    <id>http://houmin.cc/posts/d7e805bd/</id>
    <published>2020-04-18T12:30:31.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。</p><a id="more"></a><h2 id="收听工具"><a href="#收听工具" class="headerlink" title="收听工具"></a>收听工具</h2><p>下面是收听 PodCast 常见的一些工具，目前我选用的是 Moon FM。</p><h3 id="Pocket-Casts-全平台的播客老字号"><a href="#Pocket-Casts-全平台的播客老字号" class="headerlink" title="Pocket Casts - 全平台的播客老字号"></a>Pocket Casts - 全平台的播客老字号</h3><p>有条件科学上网、不介意英文界面的朋友，用它绝不会错！</p><p>👍优点：</p><ul><li>目前Android体验第一梯队选手，比较推荐。</li><li>主流的播放功能很全，前进后退30s/变速/跳过空白/人声加强/定时关闭都有，还有比较罕见的手动Skipping Intros，给开头废话比较多的节目用上还挺爽的。</li><li>有数据统计功能，如果作为主力App的话很适合定期回顾做记录。</li><li>全平台可用，即使换了设备也不用转移收听数据。</li><li>设计好看，配色可自选，无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>英文界面，需要爬梯收听。推荐页几乎见不到中文播客。</li></ul><h3 id="Castbox-主攻海外市场的国产播客App"><a href="#Castbox-主攻海外市场的国产播客App" class="headerlink" title="Castbox - 主攻海外市场的国产播客App"></a>Castbox - 主攻海外市场的国产播客App</h3><p>适合有条件科学上网，且不打算用英文App的朋友。</p><p>如果你恰好有多种兴趣，还有查收听数据的习惯，那用它再好不过了！</p><p>👍优点：</p><ul><li>体验第一梯队的选手，比较推荐。</li><li>主流功能很全，除了Skipping Intros，Pocket Casts有的它都有。</li><li>Castbox支持自建多个播放列表，非常适合兴趣纷杂，喜欢在老节目里寻宝的听众。单集添加到播放列表就会自动下载，听完自动删除，顺滑极了。</li><li>可视化的数据统计也是一个亮点。除了收听总时长，还能看到过去一周的每日收听时长</li></ul><p>🤦‍♂️缺点：</p><ul><li>需要爬梯收听。主阵地在海外，所以推荐内容里英文浓度高。页面广告略多。</li></ul><h3 id="Spotify-正版流媒体音乐服务平台"><a href="#Spotify-正版流媒体音乐服务平台" class="headerlink" title="Spotify - 正版流媒体音乐服务平台"></a>Spotify - 正版流媒体音乐服务平台</h3><p>适合正好用Spotify听音乐的朋友，为了听播客而单独下载就不太值。</p><p>👍优点：</p><ul><li>毕竟是老牌音乐App，音频的基本功能它都有。登录后无广告。</li><li>如果你正好会使用Spotify听音乐，那顺带用它听播客就不错。</li></ul><p>🤦‍♂️缺点：</p><h3 id="Moon-FM-全平台的国产播客App"><a href="#Moon-FM-全平台的国产播客App" class="headerlink" title="Moon FM - 全平台的国产播客App"></a>Moon FM - 全平台的国产播客App</h3><p>对App颜值有高要求的朋友请一定试试它！</p><p>👍优点：</p><ul><li>去年新诞生的一个播客App，也是目前中文播客应用的佼佼者，对中文用户很友好。</li><li>页面灵巧又清爽，设计上是费了心的。好看的App提名必须有它。</li><li>有一定的发现功能。基础收听功能虽然比不上老牌应用全面，但变速、睡眠定时都有。</li><li>全平台可用。无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>交互逻辑比较小众，需要接受时间。没有前进后退30s。</li><li>发现功能仅限于精选播客，个性化推荐有待完善。</li></ul><h3 id="海盗电台-快速生长的国产播客App新面孔"><a href="#海盗电台-快速生长的国产播客App新面孔" class="headerlink" title="海盗电台 - 快速生长的国产播客App新面孔"></a>海盗电台 - 快速生长的国产播客App新面孔</h3><ul><li>适合已有一些常听节目的爱好者，给“听”换上更干净纯粹的工具。</li></ul><p>👍优点：</p><ul><li>开发者更新很积极，功能不断完善中，DarkMode也有了。</li><li>基础播放功能不错，除了前进后退30s、变速、睡眠定时，跳过空白的功能也已经有了。</li><li>因为是国产App，所以对中文用户很友好。</li><li>设计简洁舒适。无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>暂无发现功能。一些基本功能也待完善，比如自动下载。</li></ul><h3 id="网易云-播客作为边角料"><a href="#网易云-播客作为边角料" class="headerlink" title="网易云 - 播客作为边角料"></a>网易云 - 播客作为边角料</h3><p>适合正好在用网易云听音乐，且固定只听几个播客节目的朋友。</p><p>👍优点：</p><ul><li>中文播客较全，播客主为了流量几乎都会上传。</li><li>沾了音乐区的光，播客的评论氛围还不错。</li><li>如果正好在用网易云听音乐，就不用多下一个app专门听播客了。</li></ul><p>🤦‍♂️缺点：</p><ul><li>我头一次听播客就是在网易云。当时是iOS的朋友锲而不舍推一档节目给我，而网易云给了我非常便利的起步。但在此之后很久，我都只听那一档播客。</li><li>原因很简单，网易云毕竟主业在音乐，播客作为非常边角的板块，甚至没有推荐功能，发现新节目纯靠搜索，也没有播客app的基础播放功能。</li></ul><h3 id="喜马拉雅-大而全的老牌泛音频平台"><a href="#喜马拉雅-大而全的老牌泛音频平台" class="headerlink" title="喜马拉雅 - 大而全的老牌泛音频平台"></a>喜马拉雅 - 大而全的老牌泛音频平台</h3><p>适合对界面简洁要求不高，希望多多发现中文播客节目的听众。</p><p>👍优点：</p><ul><li>中文播客较全，播客主为了流量几乎都会上传。</li><li>毕竟是老牌音频平台，应该是国产app中基础收听功能最全的，前进后退30s/变速/定时关闭/跳过头尾配齐了。</li><li>推荐功能对中文用户很友好，尤其发现相关播客的功能，对需要扩充收听列表的朋友来说很实用。</li><li>可以顺带听听有声书。</li></ul><p>🤦‍♂️缺点：</p><ul><li>页面真的有点繁杂。</li><li>不像别的平台广告只出现在屏幕上，喜马拉雅的片头片尾是有音频广告的，需要付费去除。</li><li>还有一点有些苛刻了，毕竟是目前播客app的通病：被推荐的来来回回就是几个头部节目，成长中的小众播客很难被发现。</li><li>荔枝、蜻蜓和喜马拉雅的情况非常相近。不再赘述。</li></ul><h2 id="收听栏目"><a href="#收听栏目" class="headerlink" title="收听栏目"></a>收听栏目</h2><p>正在尝试去探索一些比较知名的播客，等过段时间再来反馈。</p><h3 id="GQ-Talk"><a href="#GQ-Talk" class="headerlink" title="GQ Talk"></a>GQ Talk</h3><h3 id="忽左忽右"><a href="#忽左忽右" class="headerlink" title="忽左忽右"></a>忽左忽右</h3><h3 id="得意忘形"><a href="#得意忘形" class="headerlink" title="得意忘形"></a>得意忘形</h3><h3 id="内核恐慌"><a href="#内核恐慌" class="headerlink" title="内核恐慌"></a>内核恐慌</h3><h3 id="日谈公园"><a href="#日谈公园" class="headerlink" title="日谈公园"></a>日谈公园</h3><h3 id="面面相趣"><a href="#面面相趣" class="headerlink" title="面面相趣"></a>面面相趣</h3>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="好奇计划" scheme="http://houmin.cc/categories/%E5%A5%BD%E5%A5%87%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="podcast" scheme="http://houmin.cc/tags/podcast/"/>
    
      <category term="rss" scheme="http://houmin.cc/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>程序员王小波</title>
    <link href="http://houmin.cc/posts/c835f157/"/>
    <id>http://houmin.cc/posts/c835f157/</id>
    <published>2020-04-17T15:12:26.000Z</published>
    <updated>2020-07-14T11:57:25.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十四期，这一期我要聊一聊「王小波」。<code>20200411</code>是王小波逝世 23 周年祭日，我们对他的第一印象是他那奇妙诡谲的小说，是他那汪洋恣肆的杂文，是他和李银河的爱情故事。我依稀记得他写过自己的软件，直到今天我看到<a href="http://91biji.com/social/leon/framebook/notes/note/9174/" target="_blank" rel="external nofollow noopener noreferrer">这个</a>，我开始了对王小波的重新认识。他是一个真正的斜杠青年，比我上次说到的 <a href="https://www.linkedin.com/in/damienriehl" target="_blank" rel="external nofollow noopener noreferrer">Damien Riehl</a> 老哥还要厉害。</p><a id="more"></a><h2 id="斜杠青年"><a href="#斜杠青年" class="headerlink" title="斜杠青年"></a>斜杠青年</h2><p>这是我在维基百科上看到的他的经历：</p><blockquote><ul><li>1952年5月13日出生于北京一个知识分子家庭。</li><li>1968～1970年云南<strong>农场知青</strong>。这段经历成为他最著名的作品《黄金时代》的背景。</li><li>1971～1972年山东牟平插队；后作<strong>民办教师</strong>。</li><li>1972～1973年北京牛街<strong>教学仪器厂工人</strong>。</li><li>1974～1978年北京西城区<strong>半导体厂工人</strong>。工人生活是他《革命时期的爱情》等小说的写作背景。</li><li>1977年与当时在《光明日报》担任编辑的李银河相识相恋，后结合。</li><li>1980年王小波和李银河结婚，同年发表处女作《地久天长》。</li><li>1978～1982年<strong>中国人民大学贸易经济系本科学生</strong>。就读于贸易经济商品学专业。</li><li>1982～1984年中国人民大学一分校教师。开始写作《黄金时代》。</li><li>1984～1988年<strong>美国匹兹堡大学东亚研究中心研究生</strong>，获硕士学位。开始写作以唐传奇为蓝本的小说，其间得到许倬云先生的指点。</li><li>在美留学期间，游历了美国各地，并利用1986年暑假游历了西欧诸国。</li><li>1988～1991年<strong>北京大学社会学系讲师</strong>。</li><li>1991～1992年<strong>中国人民大学会计系讲师</strong>教授统计学。</li><li>1992～1997年自由撰稿人，他的唯一一部电影剧本《东宫西宫》获阿根廷国际电影节<strong>最佳编剧奖</strong>，并且入围1997年戛纳国际电影节。</li><li>1997年4月11日因心脏病逝世于北京。</li></ul></blockquote><p>是的，仅仅只是这些经历，就已经非常惊人了：<code>知青</code>、<code>民办教师</code>、<code>半导体厂工人</code>、<code>经济学</code>、<code>社会学</code>、<code>会计</code>、<code>编剧</code>、<code>小说家</code>。但是，神奇的王小波并不止步于此，看看他自己的描述：</p><blockquote><p>我现在既不是化学家，也不是数学家，更不是物理学家。我靠写文章为生，与科技绝缘——只是有时弄弄计算机。<strong>这个行当我会得不少，从最低等的汇编语言到最新潮的C++全会写，硬件知识也有一些。</strong>但从我自己的利益来看，我还不如一点都不会，省得整夜不睡，鼓捣我的电脑，删东加西，最后把整个系统弄垮，手头又没有软件备份。</p></blockquote><p>是的，他不仅仅在人文社科上作出了很多的成绩，还是一个理科 Geek，精通<strong>统计学</strong>，软硬兼修的程序员。为了写文章，他先是学会了FORTRAN，汇编，C等各种语言，接着又要学习数据结构，算法的相关知识，还有编译原理。在做出了自己的中文编辑器和输入法后，他觉得写软件可以赚钱，写小说同样也可以赚钱。</p><p>这是知乎上的一个评论：</p><blockquote><p>王小波可以算的上是个GEEK。大学学的贸易，后来又学化学，再后来转到了数学系。他的同学形容他解数学题就像杀猪一样，特别来劲，一道一道解决，那感觉可能就像打CS拿人头一样爽。不过解多了也觉得没意思。</p><p> 王小波小说里的男主角基本都是理工男，除了天天意淫还有一些奇怪的想法。其中一些还有自己的发明，比如《未来世界》里的王二是个工程师，整天想着和单位一起研制的永动机，还有《红拂夜奔》里的李靖发明过一个巨大的开跟号机器，在战场上，这台机器运转起来挥舞着杠杆边开跟攻击敌人，有的人死在根号3下，有的人倒在了根号5下。这些都只有GEEK才会想得出来。</p></blockquote><h2 id="程序员时间线"><a href="#程序员时间线" class="headerlink" title="程序员时间线"></a>程序员时间线</h2><p>下面是王小波和他朋友的书信中关于计算机内容的汇总。</p><h3 id="1988-12"><a href="#1988-12" class="headerlink" title="1988.12"></a>1988.12</h3><blockquote><p>回来之前我曾往人大一分校计算机站写过一封信，问他们可要带什么软件，主管的工程师回了封信，我没收到。回来之后人家还提到此事。现在国内软件一面混乱，又逐渐有形成市场之势。首先以年兄学统计这一事实来看，回来做事非有会用的软件不可。<strong>Macintosh根本就没打进中国市场</strong>，你非带几个可用的IBM微机软件回来不可。至于什么机器上能使倒不必太担心。我这个狗屁计算机室，IBMPS/2就有二台。AT机也不少。SAS SPSS Statistx都有，可代表国内上等一般统计微机房的水平，可就是少了一种宜于作统计的语言。年兄如有APL(A Programming Language)之IBM微机本，可给我寄copy来。我在美还有一个户头，连manual复印费一并写支票给你们。Glim我也没有，如年兄有便人可捎来。邮寄太贵，能省就省吧。</p></blockquote><ul><li><strong>Macintosh</strong> 在 1984 年1月24日发布，到 1988 年还没打开市场</li><li>那个时候，王小波用的还是 IBM PS/2 和 IBM PC/AT，AT机1984 年发布，他创造了 PC（Personal Computer）的概念</li><li>SPSS 是 IBM 1984 年推出的统计分析软件，迄今仍在被广泛使用。SAS，Statistx 也同样是那个时代推出的软件。</li><li>APL是哈佛大学的肯尼斯·艾佛于 1962 年设计开发，为此他获得了 1979 年的图灵奖。</li></ul><h3 id="1990-01"><a href="#1990-01" class="headerlink" title="1990.01"></a>1990.01</h3><blockquote><p>我现在正给北大社会学所做统计，手上除<strong>SPSS</strong>没有可用的软件，国内这方面很差。我现在会用<strong>FORTRAN</strong>，编统计程序不方便。闻兄谈起你们用S语言，不知是否好用。工具书也不知好找不。不管好歹，烦兄找个拷贝给我，要就算了。照我看只要能解决各种<strong>矩阵运算</strong>就够：当然也要有各种<strong>分布函数</strong>。反正也是瞎胡混，我就算努把力，少混点吧。</p></blockquote><ul><li>FORTRAN是世界上第一个被正式推广使用的高级语言，1954年被提出来。</li><li>S 语言是贝尔实验室的John Chambers等于1976年共同开发的一种用来进行统计分析的解释型语言，R 语言被认为是S 语言的一个分支。</li></ul><h3 id="1990-05"><a href="#1990-05" class="headerlink" title="1990.05"></a>1990.05</h3><blockquote><p>晓阳到底也加入了IBM的行列。照我看，苹果机还是买不得。因为IBM-PC的兼容机队伍庞大。INTEL又总能推出新一代CPU，将来还有大发展。买微机钱的投资是大事，时间、精力投资更为巨大，买<strong>386兼容机</strong>是明智之举。   我最近可能调入人大，投奔班长。最近胡思乱想想出了个理论来，还没认真推导，大抵是设立多个Dummy(两分变量)构成的<strong>联合分布</strong>，其合计样本点构成一球面，点到点的距离以总误差计算。所以一样本点的对点就是它的否，误差最大。其余的正在想。</p></blockquote><ul><li>1985年，Intel 386 CPU 推出</li><li>1989年，Intel 486 CPU 推出</li></ul><h3 id="1991-02"><a href="#1991-02" class="headerlink" title="1991.02"></a>1991.02</h3><blockquote><p>兄谈及IBM中文软件不可用，估计是图像版有问题，可至有Color Monitor之机器上一试。Mac机国内亦有，唯不及美国多也。</p></blockquote><h3 id="1991-03"><a href="#1991-03" class="headerlink" title="1991.03"></a>1991.03</h3><blockquote><p>你寄来的严氏2.0A我也收到，还没用。因为一者是3盘要倒，二者我自己写的WK也有重大进展。我也自做了词组功能，是棵<strong>B树</strong>，<strong>我觉得自写的软件自用，感觉是最好的</strong>。词组用处不是很大，主要用于定义人地名等专有名词，但是严氏软件对我还是有重大启示，拼音加四声是个极好的主意，写起东西来声韵铿锵，与其他软件大不一样。自写一遍，从分页到编辑键分配，都能合乎自家习惯，不是存心狗尾续貂也。如能见到严氏，可代为致意。</p></blockquote><ul><li>是的，B 树，你没看错，王小波将 B 树用于词组功能</li><li>1991 年就自己开发中文输入法软件，那年雷军刚刚毕业来到北京，认识求伯君</li></ul><h3 id="1991-05"><a href="#1991-05" class="headerlink" title="1991.05"></a>1991.05</h3><blockquote><p>前次寄来软件，上机一试发现<strong>非有浮点处理机</strong>不能运转。因为缺少软件，国内机器一般不装<strong>协处理机</strong>，冷不丁撞出您这一件来，搞得不大有办法。</p><p>闲着没事搞了个发明。原有中文软件是用线扫描方式出汉字。我做了一个用调整字模发生器方法出汉字的系统，自以为很优越，可惜还未找到用户。用此法可以很容易地在西文软件上出中文窗口，还在SPSS上加了几句骂娘的话。</p></blockquote><h3 id="1991-09"><a href="#1991-09" class="headerlink" title="1991.09"></a>1991.09</h3><blockquote><p>晓阳托人带来软件，周转很多日才到手里，软盘有些污损，坏一片烂一套，不可用矣。但是十分感念晓阳的好意。去年托人带来的中文软件(严氏By×)，我用着尚好，而且又用C语言仿编了一个，程序是我的，拼音字典是人家的，执此招摇撞骗，骗了一些钱。干这个事，熟悉了<strong>C语言</strong>，都是拜小阳所赐。</p><p><strong>不过现在我对微机已无兴趣，因为发现写小说也可赚到钱。</strong></p></blockquote><h3 id="1992-01"><a href="#1992-01" class="headerlink" title="1992.01"></a>1992.01</h3><blockquote><p><strong>编译程序</strong>一盘(有说明书，见shou)，<strong>源程序</strong>一盘。我的音典与严氏同名内容不同。功能上与严氏的近似，但是多了改进拼音字典的功能。按F4后可以把拼音重定义。也可加字，在拼音拣字时，按enter，就进入国标拣字，拣到的字加入字典。这个软件由五个c语言(另有两个头文件)和一个汇编语言文件组成，可用<strong>turboc</strong>编译，但是汇编部分不必重汇了，可以把<strong>汇编文件</strong>写成的部分形成的obj(我的磁盘上叫wk5.obj)放到硬盘上，与其它c语言文件分开，用turboc的<code>command line</code>编译器编一下，命令如下:  <code>tcc-mc-ewka:wk*.ca:wk5.obj graphics.lib</code>  形成wk.exe，但是必须有yindian，cclib，egavga.bgi三文件支持才工作。<em>.bgi是图象板参数表，可以包括到</em>.exe内的。但是要改改程序。你的机器好。我还用个老掉牙的XT机，简直落伍了。turbo.c你一定能找到。假如你用过其它c软件，有一点要提醒你，turbo.c有一种极讨厌的特性，就是你在一个函数内<strong>alloc</strong>的内存，退出该函数时不会<strong>自动释放</strong>；还有一点也很糟，就是模型问题，在大模型下写的程序，到了小模型上一概不能用，我的程序是在<strong>compact</strong>模型下写的，就不能用small来编译，这两条是可以气死人的。据说可以用<strong>far，near之类的前缀</strong>说明指针，其实是屁用不管。我干了一年多c，得到的结论是微机c还不能使人快乐，有时叫人怀念汇编。   f1是提示键。我的打印机有汉卡，F5你恐不能用。这个打印机是人家借给我的，性能非常之好，(美国amt-525)；但是不知能用多久。这个程序我还在修改中。与严氏的软件比，在硬的方面的优点是达到了很好的紧凑性，现在编译后是55k，扩展余地大。缺点是图象更新没他的快(在我的老爷机上可以看出区别)，不知他是怎么搞的，我很佩服。<strong>我的图像部分也是汇编写的，反复优化，也达不到他的水平，不得不承认技不如人。</strong>另外，<strong>磁盘文件的处理</strong>，我也写不好。还要请阳公指教。</p></blockquote><ul><li>Turbo C是美国Borland公司1987年推出的一款集成开发环境（IDE）</li></ul><h3 id="1992-07"><a href="#1992-07" class="headerlink" title="1992.07"></a>1992.07</h3><blockquote><p>小阳的信又用MAC机，看来你的机器不少，可喜可贺。<strong>我这一台老PC/ⅩT，用了六年换不下来，太惭愧，近来老想狠狠心，花几百块买个286主板换上，老婆又不同意，真是要命了。</strong>   我自编软件又有进展，把一部分程序<strong>递归化</strong>，出现了很新奇的特征。等我换了286，就需要能<strong>写虚址方式</strong>的C语言了，未知晓阳能否找到？</p></blockquote><h3 id="1992-09"><a href="#1992-09" class="headerlink" title="1992.09"></a>1992.09</h3><blockquote><p>你给我寄的软件因为是三寸盘，在这里很不通用，所以我也没用。盘上有什么，至今不知。我用C编的软件已经用熟，并做出了各种写小说的工具，别人的软件已不用了。现在主要是写书赚钱。从今年初开始写长篇，首先做了写长篇的专用软件，现在基本<strong>调通</strong>，开始写了。</p><p><strong>递归论</strong>我没学过。我哥哥大概懂一些。我和你说的大概是计算机内的<strong>递归算法</strong>。我在美国读的书都是关于机器的。有关<strong>算法</strong>、<strong>数据结</strong>构等等，全在国内看的，也不知英文叫什么。在C语言里是指在一个函数(相当于其他语言的subprocedure)内调用同一个函数。一般程序书里都能查到。   所谓保护方式，是指<strong>286 protected mode</strong>。因为一般的IBM机器，不管是386，486，只要是<strong>dos操作系统</strong>，实际能操作的内存只是640K，相当于一个较快的PC机。想要用到640K以外的<strong>extend memory</strong>，只有用protect mode才能用上，我打算换286，还是想用多于640K的内存。这就要有比现在的C更好的编程工具。当然，我也不一定要用到保护方式，有各种EMS软件，不过我还是想往多里捞摸，多留一手。MSC我只见过5.0版，7.0版的性能还不知道。不过我猜现在流行的C应该有这些手段，到这时候了。   我有一段时间很关心<strong>personal computer</strong>的发展，属于想玩玩不到过干瘾的那种。这路东西的发展都是由处理机片芯的发展开始。从8088到286，386看文献就知道快了很多。从实用的角度来看，286多了虚存保护，386又多了很<strong>多用户多任务</strong>手段。<strong>486据说把386，387，和64K的高速缓存集成到一个片子上，不但整数运算快，浮点也快多了。不过不做科学运算，意义就小了。</strong>586还不知道是个什么东西，想必有惊人之处。不过到了我手上用作文字处理，也是暴殄天物。我有个286用用就算行了。太好的东西我也使不出来。   听说美国微机多媒体搞得甚火，微机接电视，音响，video等等。这玩艺听上去倒是蛮有意思的。</p></blockquote><ul><li>微软的windows 95直到1995年发布以后，才成为了真正意义上的图形界面的操作系统，有了图形用户界面</li><li>Linux 的第一个版本在 1991 年发布</li><li>王小波那年用的还是 DOS 操作系统</li></ul><h3 id="1992-10"><a href="#1992-10" class="headerlink" title="1992.10"></a>1992.10</h3><blockquote><p>当时不知道你为什么这么干，原来是机器坏了。居然叫人敲去150dollars，老兄真是有钱。这种事叫我遇上，肯定自己修了。<strong>现在的微机修理都是换线换板，机器一坏，先找块表量量是不是电源坏了。</strong>只要不是电源坏，估摸是哪部分不好，就去买块版换上。送出去也是这么修，还要敲你手工钱。我看150什么板子都能买来。万一自己故障没找对，就说人家的板子不好，退给他。我的机器里什么牌子的板子都有了，都像你那样挨人敲，还玩得起吗？这么弄，还能有点乐趣。比方说，你爱486，就去买块486主机板，把自己的主机板换下来，这种搞法不怕杂牌水货，坏了再换，反正便宜。我的问题在于这么搞都搞不起。</p><p>我现在从我哥哥那里弄了一套<strong>TurboC++</strong>，软件方面暂时没有问题了。只是286还没买，因为听说中国要加入<strong>关贸总协定</strong>，这类东西要掉价；有钱先买家具。无论如何，我是用不到486的，因为要286也不是为了追求高速度，主要是要解决内存问题。<strong>我现在软件写得出神入化，大概8088上能做到的一切，我都做到了</strong>。自己觉得该告一段落，去写小说了。</p></blockquote><ul><li>是的，王小波对计算机硬件也有很多了解</li><li>C++ 90 年代才有了第一次标准化，王小波 92 年开始玩 C++了。</li></ul><h3 id="1992-11"><a href="#1992-11" class="headerlink" title="1992.11"></a>1992.11</h3><blockquote><p>先有朋友把你寄来的软盘倒了一下，看看是数字，就没动它。记得原来有一套干这种事的软件，是你给的，但是盘坏过，再也找不到了。今天写了个小程序倒出来，拜读了大作，甚是有趣。</p></blockquote><h3 id="1993-03"><a href="#1993-03" class="headerlink" title="1993.03"></a>1993.03</h3><blockquote><p>我终于下决心买了一台286，这些日子在改造软件，作了不少汇编工作。其核心是它在<strong>虚拟保护方式(virtual address protected)</strong>下工作，以便利<strong>扩展内存(expanded memory)</strong>。现在终于完全成功，我的软件现在可以编辑400K长的文件，可以把一部长篇小说全部调到内存里编写了。只可惜我这个机器还是低级，只有<strong>1M RAM</strong>，并且没有硬盘，所以也就到此为止了。这个程序的缺点是太低级，有大量对<strong>端口(port)</strong>的操作，虽然效率是高的，兼容性不会太好。我的XT机给山妻用了，算起来我用那台机器已经七年，就如一位老友，骤然割爱，如心头割肉。</p></blockquote><h3 id="年份不详"><a href="#年份不详" class="headerlink" title="年份不详"></a>年份不详</h3><blockquote><p><strong>我们的pc机还没有和Internet连上。本来中国有几个国内网发展得很快，现在又出了问题，谁要上Internet，必须到有关部门去登记，留个案底，以备当局监控，很有一点监狱的气味。</strong>我还不想找这份麻烦，再说，通过Chinanet联网，每月也要交七八百的月费，我也没有这么多的钱。既然×反对信息时代，我们就不进这个时代罢，有什么法子。所以还是写信好了。</p></blockquote><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>我是跪着一条一条读着一条有一条的书信的，里面出现了太多太多的熟悉的名词。涉及到基础的数据结构 B 树，涉及到基本的编程语言，涉及到从 8086 到 80286 兼容的保护模式，扩展内存，涉及到统计学分布知识。</p><p>这些，都是媒体上广为传播他和李银河美丽爱情同时发生的事情（为什么媒体就知道炒那些爱情故事呢，王小波这么多的传奇都不说一下）</p><p>本科的时候草草翻过他的杂文集，当时就觉得很有趣，但是小说没太看懂。我觉得，是时候重新认识王小波了，过段时间再把他的书找回来读一读。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://91biji.com/social/leon/framebook/notes/note/9174/" target="_blank" rel="external nofollow noopener noreferrer">http://91biji.com/social/leon/framebook/notes/note/9174/</a></li><li><a href="https://www.zhihu.com/question/20964366" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/20964366</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十四期，这一期我要聊一聊「王小波」。&lt;code&gt;20200411&lt;/code&gt;是王小波逝世 23 周年祭日，我们对他的第一印象是他那奇妙诡谲的小说，是他那汪洋恣肆的杂文，是他和李银河的爱情故事。我依稀记得他写过自己的软件，直到今天我看到&lt;a href=&quot;http://91biji.com/social/leon/framebook/notes/note/9174/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;这个&lt;/a&gt;，我开始了对王小波的重新认识。他是一个真正的斜杠青年，比我上次说到的 &lt;a href=&quot;https://www.linkedin.com/in/damienriehl&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Damien Riehl&lt;/a&gt; 老哥还要厉害。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-17_programmer-wxb.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="斜杠青年" scheme="http://houmin.cc/tags/%E6%96%9C%E6%9D%A0%E9%9D%92%E5%B9%B4/"/>
    
      <category term="王小波" scheme="http://houmin.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>政治坐标系</title>
    <link href="http://houmin.cc/posts/125bc0e5/"/>
    <id>http://houmin.cc/posts/125bc0e5/</id>
    <published>2020-04-09T09:16:26.000Z</published>
    <updated>2020-07-14T11:57:25.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><p>「政治坐标系」的概念来源于著名的<code>political compass</code>，用于表明一个人的政治倾向。这里是我的政治坐标测试，其中「中国政治坐标测试」最早是 2007 年北大未名 BBS 的同学们讨论制作的，并在后期根据中国实际情况进行了订正和修改，在 <a href="http://www.zuobiao.me/zuobiao2015/index.php/66331?lang=zh-Hans" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 可以看到目前的版本。令我感到惊讶的是，居然在这个<a href="https://bbs.pku.edu.cn/v2/post-read-single.php?bid=1004&amp;type=3&amp;postid=5656284" target="_blank" rel="external nofollow noopener noreferrer">帖子</a>下面看到了<a href="http://blog.farmostwood.net/" target="_blank" rel="external nofollow noopener noreferrer">木遥</a>的踪迹，世界真小。</p><blockquote><p>需要强调说明的是，<strong>这个测试初始并且唯一的目标在于给使用者提供一个自我思考和认同的提示器。</strong></p><p>「公共政治议题讨论的阙失和长期的无限夸大式的政治宣传方式，使得很多人几乎是凭着脑海中浮现的口号来作出自己的选择，而完全不曾在理性上真正确认过自己的立场。」这是我对现实的悲观理解。这个问卷如此流行，足以反过来说明政治观点的分歧和相关观点在意识层面上（而非政策层面上）的讨论和争锋如何构成了公众生活的禁忌。网上关于这个测试的很多评论都反映出<strong>很多人并不习惯于拥有自己的观点，更不用说是在如此广泛的层面上。我相信这并非出自天性，而只是长期的怠惰使然。</strong></p></blockquote><p>与此同时，我也附上了来自英文「<a href="https://www.politicalcompass.org/test" target="_blank" rel="external nofollow noopener noreferrer">政治指南针</a>」网站的西方政治坐标测试，这份测试系统建立于西方政治价值体系基础之上，<strong>某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。</strong> 不管怎样，倒也可以提供一个自我思考的提示器。</p><a id="more"></a><p><img alt="Political Compass" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Political_chart.svg/941px-Political_chart.svg.png"></p><h2 id="中国政治坐标"><a href="#中国政治坐标" class="headerlink" title="中国政治坐标"></a>中国政治坐标</h2><h3 id="测试试题"><a href="#测试试题" class="headerlink" title="测试试题"></a>测试试题</h3><p>整个测试有 50 道题，分别从政治、经济、文化三个方面界定。这里列出了我在今天的选择，具体打分可到原网页进行测试。</p><p><form id="chinese-questions">    <ol>        <li>如果人民没有受过民主教育，他们是不应该拥有普选权的。<br><input name="c1" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c1" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c1" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c1" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>人权高于主权。<br><input name="c2" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c2" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c2" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c2" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>西方的多党制不适合中国国情。<br><input name="c3" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c3" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c3" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c3" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>由高校自主考试招生比全国统一考试招生更好。<br><input name="c4" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c4" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c4" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c4" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>在中国照搬西方式的言论自由会导致社会失序。<br><input name="c5" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c5" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c5" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c5" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>应该容许宗教人士在非宗教场所公开传教。<br><input name="c6" type="radio" data-x="-2" data-y="0" data-z="0" checked>强烈反对<br><input name="c6" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c6" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c6" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>无论中小学生或大学生，都应参加由国家统一安排的军训。<br><input name="c7" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c7" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c7" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c7" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家的统一和领土完整是社会的最高利益。<br><input name="c8" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c8" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c8" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c8" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家没有义务进行对外援助。<br><input name="c9" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c9" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c9" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c9" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>哪怕经历了违反程序规定的审讯和取证过程，确实有罪的罪犯也应被处以死刑。<br><input name="c10" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c10" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c10" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c10" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家领导人及开国领袖的形象可以作为文艺作品的丑化对象。<br><input name="c11" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c11" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c11" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c11" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>当法律未能充分制止罪恶行为时，通过极端手段对犯罪进行制裁是可以容忍的。<br><input name="c12" type="radio" data-x="2" data-y="0" data-z="0" checked>强烈反对<br><input name="c12" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c12" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c12" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>应当允许媒体代表某一特定阶层或利益集团发言。<br><input name="c13" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c13" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c13" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c13" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>如果国家综合实力许可，那么中国有权为了维护自己的利益而采取任何行动。<br><input name="c14" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c14" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c14" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c14" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>条件允许的话应该武力统一台湾。<br><input name="c15" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c15" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c15" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c15" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家应当采取措施培养和支持体育健儿在各种国际比赛场合为国争光。<br><input name="c16" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c16" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c16" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c16" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>律师即使明知被辩护人的犯罪事实也应当尽力为其进行辩护。<br><input name="c17" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c17" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c17" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c17" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>以美国为首的西方国家不可能真正容许中国崛起成为一流强国。<br><input name="c18" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c18" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c18" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c18" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>两个成年人之间自愿的性行为是其自由，无论其婚姻关系为何。<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>不应当公开谈论自己的长辈的缺点。<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="-1" checked>同意<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>现代中国社会需要儒家思想。<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="-1" checked>同意<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>判断艺术作品的价值的根本标准是看是不是受到人民大众喜爱。<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="-1" checked>反对<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="1">同意<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>即使有人口压力，国家和社会也无权干涉个人要不要孩子，要几个孩子。<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>周易八卦能够有效的解释很多事情。<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="2" checked>强烈反对<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>中国传统医学对人体健康的观念比现代主流医学更高明。<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="1" checked>反对<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>汉字无需人为推行简化。<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="1" checked>反对<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>应当将中国传统文化的经典作品作为儿童基础教育读物。<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="2" checked>强烈反对<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>如果是出于自愿，我会认可我的孩子和同性结成伴侣关系。<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>最低工资应由国家规定。<br><input name="c29" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c29" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c29" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c29" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>中国改革开放以来经济发展的成果很多都被一小群人占有了，大多数人没得到什么好处。<br><input name="c30" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈反对<br><input name="c30" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c30" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c30" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>在重大工程项目的决策中，个人利益应该为社会利益让路。<br><input name="c31" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c31" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c31" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c31" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>浪费粮食也是个人的自由。<br><input name="c32" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c32" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c32" type="radio" data-x="0" data-y="1" data-z="0" checked>同意<br><input name="c32" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>        <li>如果猪肉价格过高，政府应当干预。<br><input name="c33" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c33" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c33" type="radio" data-x="0" data-y="1" data-z="0" checked>同意<br><input name="c33" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>        <li>应当对国外同类产品征收高额关税来保护国内民族工业。<br><input name="c34" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c34" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c34" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c34" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>国有企业的利益属于国家利益。<br><input name="c35" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c35" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c35" type="radio" data-x="0" data-y="1" data-z="0">同意<br><input name="c35" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈同意<br></li>        <li>试图控制房地产价格会破坏经济发展。<br><input name="c36" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c36" type="radio" data-x="0" data-y="-1" data-z="0" checked>反对<br><input name="c36" type="radio" data-x="0" data-y="1" data-z="0">同意<br><input name="c36" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>        <li>教育应当尽可能公立。<br><input name="c37" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c37" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c37" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c37" type="radio" data-x="0" data-y="-2" data-z="0" checked>强烈同意<br></li>        <li>改善低收入者生活的首要手段是国家给予财政补贴和扶持。<br><input name="c38" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c38" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c38" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c38" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>有钱人理应获得更好的医疗服务。<br><input name="c39" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c39" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c39" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c39" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>高收入者应该公开自己的经济来源。<br><input name="c40" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c40" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c40" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c40" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>与其让国有企业亏损破产，不如转卖给资本家。<br><input name="c41" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c41" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c41" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c41" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>那些关系到国家安全、以及其他重要国计民生的领域，必须全部由国有企业掌控。<br><input name="c42" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c42" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c42" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c42" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>市场竞争中自然形成的垄断地位是无害的。<br><input name="c43" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c43" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c43" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c43" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>资本积累的过程总是伴随着对普通劳动人民利益的伤害。<br><input name="c44" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c44" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c44" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c44" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>应该允许中国公民同时具有外国国籍。<br><input name="c45" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c45" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c45" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c45" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>政府应当提高粮食收购价格以增加农民收入。<br><input name="c46" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c46" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c46" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c46" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>为保障社会公平，对富人征税应采用更高的税率。<br><input name="c47" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈反对<br><input name="c47" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c47" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c47" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>在华外国资本应享受和民族资本同样的待遇。<br><input name="c48" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c48" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c48" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c48" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>私人应当可以拥有和买卖土地。<br><input name="c49" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c49" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c49" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c49" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>发生重大社会安全事件时，即使认为信息公开会导致骚乱的风险，政府仍应该开放信息传播。<br><input name="c50" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c50" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c50" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c50" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>    </ol></form><br><div class="note info">            <ul><li>政治观念坐标，负值为左，即威权主义 (Authoritarianism)，正值为右，即自由主义 (Libertarianism)。</li><li>社会文化观念坐标，负值为保守与复古派 (Conservatism)，正值为自由与激进派 (Liberalism)。</li><li>经济观念坐标，负值为左，即集体主义与福利主义 (Welfarism, Collectivism)，正值为右，即新自由主义(Neoliberalism)。</li></ul><p>三个维度的最大区间均为 [-2,2]。</p><p>本测试系统建立于中国政治价值体系基础之上，试图充分反映中国的特殊国情与政治文化。请注意，很多问题反映的是中国现实语境中的「左与右」，而非严格意义上的西方政治语汇中的「左与右」。</p>          </div></p><h3 id="测试反思"><a href="#测试反思" class="headerlink" title="测试反思"></a>测试反思</h3><p>整个测试做完，我的得分如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">政治立场坐标: <span class="number">0.4</span></span><br><span class="line">文化立场坐标: <span class="number">0.6</span></span><br><span class="line">经济立场坐标: <span class="number">-0.3</span></span><br></pre></td></tr></table></figure><p>什么意思呢？也就是说，我政治观念偏自由主义，社会文化观念偏自由主义，经济观念偏集体主义。这个测试结果和我在 <a href="https://www.idrlabs.com/" target="_blank" rel="external nofollow noopener noreferrer">IDRlabs</a>上面的<a href="https://www.idrlabs.com/cn/political-coordinates/test.php" target="_blank" rel="external nofollow noopener noreferrer">政治观点测试</a>大体类似，整体上政治文化偏自由，但是很明显经济方面自己的不确定性太大，整体上属于温和中间派。</p><p><img alt="IDRlabs Political Coordinate" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-09_political-compass.png"></p><p>倒也不是说通过这个测试就对我的左右进行了划分，把我划分成左派或右派。左右意识形态的纠葛在过去一百多年给人类社会带来撕扯与分裂，以至于对于左和右的定义国内国外都不太一样。一直以来，我的观点就是搁置意识形态上的争论，踏踏实实的讨论实际问题。但是搁置争论并不等于没有自己的观点，并不等于不去思考这些问题，而这个测试恰恰提供了这样的机会。</p><p>关于这五十个问题，做的时候有的并不是百分百的确定，很多问题涉及到经济问题。经济基础决定上层建筑，经济问题是可以用数学来解释的，过段时间等对于经济问题有了更多的理解后，再来做这个测试，或许答案又不一样了。</p><ul><li>人权与主权。教科书告诉我们主权高于人权，真的是这样吗？</li><li>真的应该公开所有的信息吗？一直以来我认为公开信息是能够促进事情更加透明的，现在我有些犹豫。</li><li>关注自主招生，应该认识到，自主招生确实是招到优秀同学的一种重要方式。但是我们也会看到这里面有很多不公平的现象产生，我选择公平。</li><li>国家的统一和领土完整真的是社会的最高利益吗？人民的幸福不才应该是吗？犹豫。</li><li>国家真的没有义务对外援助吗？大国责任呢？犹豫。</li><li>有罪的罪犯，取证不规范，这是程序正义的问题。现在是坚决反对的，即使他确实有问题，我们取证不规范，那和他又有什么区别呢？</li><li>国家领导人和开国领袖可以作为丑化对象吗？不能，原因说不清楚，觉得这样不好。</li><li>媒体不应该是尽量公正客观的吗？所以直觉认为媒体当然不应该为某一特定利益集团发言，又一转念，这不正是当下的显示吗？哪家媒体不是代表的某些人的利益的呢？</li><li>国籍问题是知识盲区，这个不是很懂，到底双重国籍有什么具体的影响。 </li><li>武统台湾，我们已经有条件了，但是这是我们最不愿意看到的，难道就没有别的办法吗，中国人这么聪明。 </li><li>现代社会需要儒家思想，当然是需要，但是看是那部分，君君臣臣那套还是算了。</li><li>判断艺术作品的价值真的是是否受到人民大众喜欢吗？不一定吧。</li><li>关于最低工资，这点并不太懂其背后的经济学原理。</li><li>个人利益应当为社会利益让路吗？犹豫。</li><li>粮食浪费也是个人自由吗？自由应该如何界定？</li><li>猪肉价格过高，政府应该干预吗？经济学上怎么说？</li><li>应该试图控制房地产吗？经济学上怎么说？</li><li>教育应该完全公立吗？从我的角度来说，我是赞成的。</li><li>有钱人应该公开自己的收入来源吗？直观感受是应该的。</li><li>涉及到国计民生的领域，真的都应该由国企掌控吗？</li><li>资本积累的过程看起来确实都伴随着对普通劳动人民利益的伤害。</li><li>政府应该高价格收购粮食吗？</li><li>私人应该可以自由买卖土地吗？是否会再次出现土地兼并的问题？ </li></ul><h2 id="西方政治坐标"><a href="#西方政治坐标" class="headerlink" title="西方政治坐标"></a>西方政治坐标</h2><h3 id="测试试题-1"><a href="#测试试题-1" class="headerlink" title="测试试题"></a>测试试题</h3><p>下面是我的测试结果，经济上偏自由，政治上偏自由。</p><p><form id="western-questions">    <p><strong>第一部分</strong>：你如何看待国家与世界。</p>    <ol>        <li>如果全球化无法避免，应该首先为人服务而不是跨国公司的利益。<br><input name="c1" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c1" type="radio" data-x="0.25" data-y="0">反对<br><input name="c1" type="radio" data-x="-0.375" data-y="0" checked>同意<br><input name="c1" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>我会一直支持我的国家，无论它是对是错。<br><input name="c2" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c2" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c2" type="radio" data-x="0" data-y="0.15">同意<br><input name="c2" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>没有人可以选择祖国，因此为祖国自豪很愚蠢。<br><input name="c3" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c3" type="radio" data-x="0" data-y="0.13" checked>反对<br><input name="c3" type="radio" data-x="0" data-y="-0.13">同意<br><input name="c3" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>我的种族和其他种族相比有很多出众的优点。<br><input name="c4" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c4" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c4" type="radio" data-x="0" data-y="0.13">同意<br><input name="c4" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>敌人的敌人是朋友。<br><input name="c5" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c5" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c5" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c5" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>违反国际法的军事行动有时候是正当的。<br><input name="c6" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c6" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c6" type="radio" data-x="0" data-y="0.11">同意<br><input name="c6" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>现在信息和娱乐已经令人忧虑的交融在一起。<br><input name="c7" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c7" type="radio" data-x="0" data-y="0.13">反对<br><input name="c7" type="radio" data-x="0" data-y="-0.13">同意<br><input name="c7" type="radio" data-x="0" data-y="-0.23" checked>强烈同意<br></li>    </ol>    <p><strong>第二部分</strong>：经济问题。</p>    <ol>        <li>人民根本上说是通过阶级而不是国籍来区分的。<br><input name="c8" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c8" type="radio" data-x="0.25" data-y="0">反对<br><input name="c8" type="radio" data-x="-0.375" data-y="0" checked>同意<br><input name="c8" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>控制通货膨胀比控制失业要重要。<br><input name="c9" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c9" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c9" type="radio" data-x="0.375" data-y="0">同意<br><input name="c9" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>        <li>因为无法信任企业能够自觉保护环境，因此需要规章来规范它们。<br><input name="c10" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c10" type="radio" data-x="0.25" data-y="0">反对<br><input name="c10" type="radio" data-x="-0.25" data-y="0">同意<br><input name="c10" type="radio" data-x="-0.5" data-y="0" checked>强烈同意<br></li>        <li>“各尽所能，各取所需”从根本上说是个好的想法。<br><input name="c11" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c11" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c11" type="radio" data-x="-0.375" data-y="0">同意<br><input name="c11" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>令人沮丧的是在我们的社会中一些最基本的事物比如饮用水现在都成为了瓶装、注明商标的商品。<br><input name="c12" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c12" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c12" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c12" type="radio" data-x="-0.75" data-y="0">强烈同意<br></li>        <li>土地不应当被作为商品买卖。<br><input name="c13" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c13" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c13" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c13" type="radio" data-x="-0.75" data-y="0">强烈同意<br></li>        <li>靠运作资金赚钱的人对社会的贡献比不上靠劳动赚钱的人。<br><input name="c14" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c14" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c14" type="radio" data-x="-0.375" data-y="0">同意<br><input name="c14" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>保护主义对贸易来说有时候是必须的。<br><input name="c15" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c15" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c15" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c15" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>公司为它的股东赚取利润就是它仅有的社会职责。<br><input name="c16" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c16" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c16" type="radio" data-x="0.375" data-y="0">同意<br><input name="c16" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>        <li>对富人征的税太高了。<br><input name="c17" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c17" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c17" type="radio" data-x="0.375" data-y="0">同意<br><input name="c17" type="radio" data-x="0.5" data-y="0">强烈同意<br></li>        <li>那些付得起钱的人应该有权获得更好的医疗服务。<br><input name="c18" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c18" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c18" type="radio" data-x="0.25" data-y="0">同意<br><input name="c18" type="radio" data-x="0.5" data-y="0">强烈同意<br></li>        <li>政府应该惩罚误导公众的商业行为。<br><input name="c19" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c19" type="radio" data-x="0.25" data-y="0">反对<br><input name="c19" type="radio" data-x="-0.25" data-y="0">同意<br><input name="c19" type="radio" data-x="-0.375" data-y="0" checked>强烈同意<br></li>        <li>一个真正的自由市场需要对跨国大公司的垄断进行限制。<br><input name="c20" type="radio" data-x="0" data-y="0">强烈反对<br><input name="c20" type="radio" data-x="0" data-y="0">反对<br><input name="c20" type="radio" data-x="0" data-y="0">同意<br><input name="c20" type="radio" data-x="0" data-y="0" checked>强烈同意<br></li>        <li>市场越自由，人民越自由。<br><input name="c21" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c21" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c21" type="radio" data-x="0.5" data-y="0">同意<br><input name="c21" type="radio" data-x="0.75" data-y="0">强烈同意<br></li>    </ol>    <p><strong>第三部分</strong>：社会价值观。</p>    <ol>        <li>除非妇女的生命受到危及，否则总应该禁止堕胎。<br><input name="c22" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c22" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c22" type="radio" data-x="0" data-y="0.11">同意<br><input name="c22" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>一切当权者都应该受到质询。<br><input name="c23" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c23" type="radio" data-x="0" data-y="0.175">反对<br><input name="c23" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c23" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>以眼还眼，以牙还牙。<br><input name="c24" type="radio" data-x="0" data-y="-0.18">强烈反对<br><input name="c24" type="radio" data-x="0" data-y="-0.125" checked>反对<br><input name="c24" type="radio" data-x="0" data-y="0.08">同意<br><input name="c24" type="radio" data-x="0" data-y="0.18">强烈同意<br></li>        <li>税收不应该支持那些没法靠商业手段活下去的剧院和博物馆。<br><input name="c25" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c25" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c25" type="radio" data-x="0.5" data-y="0">同意<br><input name="c25" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>        <li>学校不应该强制学生签到。<br><input name="c26" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c26" type="radio" data-x="0" data-y="0.055">反对<br><input name="c26" type="radio" data-x="0" data-y="-0.15" checked>同意<br><input name="c26" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>        <li>所有人都有自己的权利，但让不同类型的人保持自己的个性对每个人来说都更好。<br><input name="c27" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c27" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c27" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c27" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>好父母有时候也不得不打孩子。<br><input name="c28" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c28" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c28" type="radio" data-x="0" data-y="0.1" checked>同意<br><input name="c28" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>孩子对父母有秘密很正常。<br><input name="c29" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c29" type="radio" data-x="0" data-y="0.13">反对<br><input name="c29" type="radio" data-x="0" data-y="-0.08" checked>同意<br><input name="c29" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>大麻应该合法。<br><input name="c30" type="radio" data-x="0" data-y="0.2">强烈反对<br><input name="c30" type="radio" data-x="0" data-y="0.045" checked>反对<br><input name="c30" type="radio" data-x="0" data-y="-0.11">同意<br><input name="c30" type="radio" data-x="0" data-y="-0.21">强烈同意<br></li>        <li>学校的首要职能是让下一代人能找到工作。<br><input name="c31" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c31" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c31" type="radio" data-x="0" data-y="0.1">同意<br><input name="c31" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>应当不允许有严重遗传疾病的残疾人生育。<br><input name="c32" type="radio" data-x="0" data-y="-0.29">强烈反对<br><input name="c32" type="radio" data-x="0" data-y="-0.185">反对<br><input name="c32" type="radio" data-x="0" data-y="0.17" checked>同意<br><input name="c32" type="radio" data-x="0" data-y="0.275">强烈同意<br></li>        <li>孩子最重要的事是学会遵守纪律。<br><input name="c33" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c33" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c33" type="radio" data-x="0" data-y="0.15">同意<br><input name="c33" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>没有野蛮人和文明人，只有不同的文化。<br><input name="c34" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c34" type="radio" data-x="0" data-y="0.175">反对<br><input name="c34" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c34" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>那些有能力工作却拒绝工作机会的人，不应该接受社会的资助。<br><input name="c35" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c35" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c35" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c35" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>当你遇到困难时，最好不要去想它，而是不断地做令人高兴的事。<br><input name="c36" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c36" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c36" type="radio" data-x="0" data-y="0.11">同意<br><input name="c36" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>第一代移民永远无法完全融入他们的新国家。<br><input name="c37" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c37" type="radio" data-x="0" data-y="-0.075">反对<br><input name="c37" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c37" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>有利于最成功的企业的事物，最终也总是有利于我们大家的。<br><input name="c38" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c38" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c38" type="radio" data-x="0.75" data-y="0">同意<br><input name="c38" type="radio" data-x="0.875" data-y="0">强烈同意<br></li>        <li>任何广播电视机构，无论它的内容有多独立，都不应该接受公共资金的支持。<br><input name="c39" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c39" type="radio" data-x="-0.375" data-y="0" checked>反对<br><input name="c39" type="radio" data-x="0.125" data-y="0">同意<br><input name="c39" type="radio" data-x="0.25" data-y="0">强烈同意<br></li>    </ol>    <p><strong>第四部分</strong>：你如何看待更广阔的社会。</p>    <p></p>    <ol>        <li>在反恐的名义下，公民自由被过度限制了。<br><input name="c40" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c40" type="radio" data-x="0" data-y="0.155" checked>反对<br><input name="c40" type="radio" data-x="0" data-y="-0.1">同意<br><input name="c40" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>        <li>一党制国家的一个显著优点是它避免了在民主政体中耽误发展的所有那些争论。<br><input name="c41" type="radio" data-x="0" data-y="-0.29">强烈反对<br><input name="c41" type="radio" data-x="0" data-y="-0.135">反对<br><input name="c41" type="radio" data-x="0" data-y="0.17" checked>同意<br><input name="c41" type="radio" data-x="0" data-y="0.275">强烈同意<br></li>        <li>尽管在电子时代官方的监听更容易了，但只有坏人才需要对此担忧。<br><input name="c42" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c42" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c42" type="radio" data-x="0" data-y="0.15" checked>同意<br><input name="c42" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>对罪大恶极的犯罪分子，死刑不失为一种选项。<br><input name="c43" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c43" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c43" type="radio" data-x="0" data-y="0.15" checked>同意<br><input name="c43" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>在一个文明社会，一个人必须遵从上级、命令下级。<br><input name="c44" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c44" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c44" type="radio" data-x="0" data-y="0.11">同意<br><input name="c44" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>那些什么也没有表达的抽象艺术根本就不应该被称为艺术。<br><input name="c45" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c45" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c45" type="radio" data-x="0" data-y="0.15">同意<br><input name="c45" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>在刑事审判中，惩罚比改造更重要。<br><input name="c46" type="radio" data-x="0" data-y="-0.23" checked>强烈反对<br><input name="c46" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c46" type="radio" data-x="0" data-y="0.13">同意<br><input name="c46" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>改造有些犯罪分子就是浪费时间。<br><input name="c47" type="radio" data-x="0" data-y="-0.26" checked>强烈反对<br><input name="c47" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c47" type="radio" data-x="0" data-y="0.15">同意<br><input name="c47" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>商人和制造业者比作家和艺术家更重要。<br><input name="c48" type="radio" data-x="0" data-y="-0.18">强烈反对<br><input name="c48" type="radio" data-x="0" data-y="-0.08" checked>反对<br><input name="c48" type="radio" data-x="0" data-y="0.08">同意<br><input name="c48" type="radio" data-x="0" data-y="0.18">强烈同意<br></li>        <li>母亲们可以有职业，但她们的首要职责是家庭主妇。<br><input name="c49" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c49" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c49" type="radio" data-x="0" data-y="0.13">同意<br><input name="c49" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>跨国公司正在不道德地开发发展中国家的植物基因资源。<br><input name="c50" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c50" type="radio" data-x="0" data-y="0.13">反对<br><input name="c50" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c50" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>同现有体制和谐相处是成熟的重要一方面。<br><input name="c51" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c51" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c51" type="radio" data-x="0" data-y="0.11" checked>同意<br><input name="c51" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>    </ol>    <p></p>    <p><strong>第五部分</strong>：关于宗教。</p>    <p></p>    <ol>        <li>占星术精确地解释了很多东西。<br><input name="c52" type="radio" data-x="0" data-y="-0.23" checked>强烈反对<br><input name="c52" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c52" type="radio" data-x="0" data-y="0.13">同意<br><input name="c52" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>你如果不信宗教就不可能道德。<br><input name="c53" type="radio" data-x="0" data-y="-0.2" checked>强烈反对<br><input name="c53" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c53" type="radio" data-x="0" data-y="0.11">同意<br><input name="c53" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>慈善捐助在帮助真正的弱势群体时做得比社会保障要好。<br><input name="c54" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c54" type="radio" data-x="-0.375" data-y="0" checked>反对<br><input name="c54" type="radio" data-x="0.625" data-y="0">同意<br><input name="c54" type="radio" data-x="0.75" data-y="0">强烈同意<br></li>        <li>有些人天生不走运。<br><input name="c55" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c55" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c55" type="radio" data-x="0" data-y="0.13">同意<br><input name="c55" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>我孩子的学校向他传授宗教价值观，这点非常重要。<br><input name="c56" type="radio" data-x="0" data-y="-0.2" checked>强烈反对<br><input name="c56" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c56" type="radio" data-x="0" data-y="0.11">同意<br><input name="c56" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>    </ol>    <p></p>    <p><strong>第六部分</strong>：关于性。</p>    <ol>        <li>婚姻之外的性是不道德的。<br><input name="c57" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c57" type="radio" data-x="0" data-y="-0.175">反对<br><input name="c57" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c57" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>一对稳定、相爱的同性伴侣，应有收养孩子的权利。<br><input name="c58" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c58" type="radio" data-x="0" data-y="0.175">反对<br><input name="c58" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c58" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>由成年人自愿演出的色情影视应该对成人合法化。<br><input name="c59" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c59" type="radio" data-x="0" data-y="0.13">反对<br><input name="c59" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c59" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>在私人卧室里两个成年人只见不管做什么，只要是自愿的，国家就管不着。<br><input name="c60" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c60" type="radio" data-x="0" data-y="0.155">反对<br><input name="c60" type="radio" data-x="0" data-y="-0.15" checked>同意<br><input name="c60" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>        <li>没有人会天生同性恋。<br><input name="c61" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c61" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c61" type="radio" data-x="0" data-y="0.15">同意<br><input name="c61" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>社会对性开放并没错，但现在已经开放的过分了。<br><input name="c62" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c62" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c62" type="radio" data-x="0" data-y="0.11">同意<br><input name="c62" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>    </ol></form></p><div id="western-wrapper">    <button id="western-submit" type="button" class="button button-inverse button-rounded">提交</button>    <br>    <span id="western-answer" class="red">    政治立场坐标（左翼&lt;-&gt;右翼）-3.87，经济立场坐标（左翼&lt;-&gt;右翼）-2.42    </span></div><script type="text/javascript">  $(function() {    $("#western-submit").click(function(){      var t=0, a=0;      $('#western-questions input[name^="c"]:checked').each(function(){        t += parseFloat($(this).attr("data-x")),        a += parseFloat($(this).attr("data-y"))      }),      t = Math.round(100*t)/100,      a = Math.round(100*a)/100,      $("#western-answer").html("经济立场坐标（左翼<->右翼）"+ t + "，政治立场坐标（专制<->自由）" + a)    })  });</script><div class="note info">            <p>横坐标反映经济观念，负值为左（Communism, Collectivism），正值为右（Neo-Liberalism, Libertaranism）。纵坐标反映政治社会观念，负值为自由（Anarchism, Libertarian），正值为专制或保守（Facism, Authoritarian）。</p><p>本测试系统建立于西方政治价值体系基础之上，某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。根据周围人群的实验结果，中国人的测试结果普遍位于第三象限（即两坐标均为负值），平均值位于(-2,-2)附近。为了区分中国人习惯意义上的「左与右」，可以以(-2,-2)为坐标原点重新划分坐标平面，即经济坐标小于-2为左，反之为右。政治坐标小于-2为自由，反之为保守或专制。</p><p>下面是著名政治人物的坐标位置以供参考：</p><ul><li>第一象限（经济右，政治保守）：希特勒，撒切尔夫人，布什，布莱尔，希拉克。</li><li>第二象限（经济左，政治保守）：斯大林，萨达姆，教皇本笃十四世。</li><li>第三象限（经济左，政治自由）：甘地，达赖喇嘛，曼德拉。</li><li>第四象限（经济右，政治自由）：弗里德曼，哈耶克。</li></ul>          </div><h3 id="测试反思-1"><a href="#测试反思-1" class="headerlink" title="测试反思"></a>测试反思</h3><ul><li>我的种族和其他种族相比有很多出众的优点？我下意识想选择同意。但是真的是这样吗？</li><li>各尽所能，各取所需？人类的惰性</li><li>土地应该自由买卖吗？</li><li>以眼还眼以牙还牙，对吗？主观上会这么做。理性上为了更好的共处，应该放下。</li><li>学校应当强制学生签到吗？对于大学生，学不学是你的主观意愿。但是如果是义务教育，需要。</li><li>堕胎应当被允许吗？这应该是个人选择吧。 </li><li>大麻应该合法吗？介于毒品和香烟之间，但是更偏毒品，偏向于禁止大麻。</li><li>应当允许有严重遗传疾病的残疾人生育吗？不应该，遗传疾病生下来对于孩子也是痛苦，领养不好吗？</li><li>对于电子监听，我们需要担忧吗？ 对于绝大多数普通人，这应该不是问题。 </li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>还是原来的观点，这个测试结果并不一定代表什么，但是可以作为参考。最重要的是，给自己提供了一个思考的机会。很多问题选择不够坚决，说明很多时候对这方面的思考欠缺。这个测试不应该是一次性的测试，随着人的动态变化，观点也在发生改变。在以后的时间，可以回头再看这些问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;「政治坐标系」的概念来源于著名的&lt;code&gt;political compass&lt;/code&gt;，用于表明一个人的政治倾向。这里是我的政治坐标测试，其中「中国政治坐标测试」最早是 2007 年北大未名 BBS 的同学们讨论制作的，并在后期根据中国实际情况进行了订正和修改，在 &lt;a href=&quot;http://www.zuobiao.me/zuobiao2015/index.php/66331?lang=zh-Hans&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;这里&lt;/a&gt; 可以看到目前的版本。令我感到惊讶的是，居然在这个&lt;a href=&quot;https://bbs.pku.edu.cn/v2/post-read-single.php?bid=1004&amp;amp;type=3&amp;amp;postid=5656284&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;帖子&lt;/a&gt;下面看到了&lt;a href=&quot;http://blog.farmostwood.net/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;木遥&lt;/a&gt;的踪迹，世界真小。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要强调说明的是，&lt;strong&gt;这个测试初始并且唯一的目标在于给使用者提供一个自我思考和认同的提示器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「公共政治议题讨论的阙失和长期的无限夸大式的政治宣传方式，使得很多人几乎是凭着脑海中浮现的口号来作出自己的选择，而完全不曾在理性上真正确认过自己的立场。」这是我对现实的悲观理解。这个问卷如此流行，足以反过来说明政治观点的分歧和相关观点在意识层面上（而非政策层面上）的讨论和争锋如何构成了公众生活的禁忌。网上关于这个测试的很多评论都反映出&lt;strong&gt;很多人并不习惯于拥有自己的观点，更不用说是在如此广泛的层面上。我相信这并非出自天性，而只是长期的怠惰使然。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与此同时，我也附上了来自英文「&lt;a href=&quot;https://www.politicalcompass.org/test&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;政治指南针&lt;/a&gt;」网站的西方政治坐标测试，这份测试系统建立于西方政治价值体系基础之上，&lt;strong&gt;某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。&lt;/strong&gt; 不管怎样，倒也可以提供一个自我思考的提示器。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-09_political-compass.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="politics" scheme="http://houmin.cc/tags/politics/"/>
    
      <category term="价值观" scheme="http://houmin.cc/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"/>
    
  </entry>
  
  <entry>
    <title>自动抓取经济学人</title>
    <link href="http://houmin.cc/posts/d1848f4f/"/>
    <id>http://houmin.cc/posts/d1848f4f/</id>
    <published>2020-04-08T14:05:25.000Z</published>
    <updated>2020-07-14T08:24:44.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>作为信息源建设的一部分，最近突然想把「经济学人」阅读捡起来。为了能够固定获取「经济学人」文本，研究了一下其爬取过程，记录如下，希望能够有所帮助。</p><h2 id="经济学人是什么"><a href="#经济学人是什么" class="headerlink" title="经济学人是什么"></a>经济学人是什么</h2><p>经济学人是一份创办于 1843 年 9 月 2 日的英国杂志。这是一本涉及全球政治、经济、文化、科技等多方面事务的综合性新闻评论刊物，着重于对这些议题提供深入的分析和评论。它的社论持有<a href="https://zh.wikipedia.org/wiki/古典自由主義" target="_blank" rel="external nofollow noopener noreferrer">古典自由主义</a>与<a href="https://zh.wikipedia.org/wiki/經濟自由主義" target="_blank" rel="external nofollow noopener noreferrer">经济自由主义</a>的立场，倾向于支持<a href="https://zh.wikipedia.org/wiki/自由貿易" target="_blank" rel="external nofollow noopener noreferrer">自由贸易</a>、<a href="https://zh.wikipedia.org/wiki/全球化" target="_blank" rel="external nofollow noopener noreferrer">全球化</a>、<a href="https://zh.wikipedia.org/w/index.php?title=人口自由流動&amp;action=edit&amp;redlink=1" target="_blank" rel="external nofollow noopener noreferrer">人口自由流动</a>和<a href="https://zh.wikipedia.org/wiki/社會自由主義" target="_blank" rel="external nofollow noopener noreferrer">社会自由主义</a>。</p><a id="more"></a><ul><li>在创刊之初，其议题主要囊括英国及其殖民地的政治、经济及自由贸易等范围。</li><li>1941 年珍珠港事件后首次开辟美国专栏，这是其第一个专门报道某个国家的栏目。</li><li>2012年1月，首次开设了中国专栏，这是继1941年的美国栏目之后的首个国家栏目。</li></ul><h2 id="神奇的calibre"><a href="#神奇的calibre" class="headerlink" title="神奇的calibre"></a>神奇的calibre</h2><p><a href="https://calibre-ebook.com/" target="_blank" rel="external nofollow noopener noreferrer">calibre</a>是一个开源的多平台（支持 Linux，macOS，Windows）电子书管理工具，它支持以下功能：</p><ul><li>强大的电子书管理工具，支持从网络上下载电子书的元数据。</li><li>强大的电子书阅读工具，支持 ToC，搜索，复制等功能。</li><li>支持从网络上下载新闻杂志，比如 <code>The Economist</code>, <code>New York Times</code>等，甚至是 RSS源。</li><li>内置 web 服务器，可以更加方便的分享和备份图书库</li><li>支持编辑电子书，进行格式转换，包括 epub，mobi 等格式</li></ul><p>calibre 支持一种 <code>recipe</code>的概念，calibre 可以通过 <code>recipe</code>从网络上下载新闻，并且组织成电子书。</p><blockquote><p><strong>A recipe is a set of instructions that teach calibre how to convert an online news source</strong>, such as a magazine or a blog, into an e-book.</p></blockquote><p><code>recipe</code>本质上都是 Python 代码，最简单的时候他们只是一些变量，比如 URL，用来告诉 calibre 要从哪里下载新闻。</p><p>下面以 <a href="https://lwn.net/" target="_blank" rel="external nofollow noopener noreferrer">LWN</a> 为例（对的，calibre 也可以爬 LWN，但是我太穷了，还订不起）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env  python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> calibre.web.feeds.news <span class="keyword">import</span> BasicNewsRecipe</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LWN</span><span class="params">(BasicNewsRecipe)</span>:</span></span><br><span class="line">    title = <span class="string">u'lwn'</span></span><br><span class="line">    __author__ = <span class="string">'Oliver Niesner'</span></span><br><span class="line">    description = <span class="string">'Linux Weekly News'</span></span><br><span class="line">    oldest_article = <span class="number">54</span></span><br><span class="line">    language = _(<span class="string">'English'</span>)</span><br><span class="line">    max_articles_per_feed = <span class="number">100</span></span><br><span class="line">    needs_subscription = <span class="literal">True</span></span><br><span class="line">    language = <span class="string">'en'</span></span><br><span class="line">    remove_javascript = <span class="literal">True</span></span><br><span class="line">    simultaneous_downloads = <span class="number">1</span></span><br><span class="line">    delay = <span class="number">1</span></span><br><span class="line">    LOGIN = <span class="string">'https://lwn.net/login'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_browser</span><span class="params">(self)</span>:</span></span><br><span class="line">        br = BasicNewsRecipe.get_browser(self)</span><br><span class="line">        <span class="keyword">if</span> self.username <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.password <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            br.open(self.LOGIN)</span><br><span class="line">            br.select_form(name=<span class="string">'loginform'</span>)</span><br><span class="line">            br[<span class="string">'Username'</span>] = self.username</span><br><span class="line">            br[<span class="string">'Password'</span>] = self.password</span><br><span class="line">            br.submit()</span><br><span class="line">        <span class="keyword">return</span> br</span><br><span class="line"></span><br><span class="line">    remove_tags = [</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'LeftColumn'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'NavLink'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'FormattedComment'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'MCTopBanner'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'CommentBox'</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    feeds = [</span><br><span class="line">        (<span class="string">u'lwn'</span>, <span class="string">u'http://lwn.net/headlines/newrss'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postprocess_html</span><span class="params">(self, soup, first)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> tag <span class="keyword">in</span> soup.findAll(name=[<span class="string">'table'</span>, <span class="string">'tr'</span>, <span class="string">'td'</span>]):</span><br><span class="line">            tag.name = <span class="string">'div'</span></span><br><span class="line">        <span class="keyword">return</span> soup</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_version</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> url.replace(<span class="string">'rss'</span>, <span class="string">'?format=printable'</span>)</span><br></pre></td></tr></table></figure><p>首先我们看到 LWN 这个 recipe 继承自 <a href="https://manual.calibre-ebook.com/news_recipe.html" target="_blank" rel="external nofollow noopener noreferrer">BasicRecipe</a> 这个基本的类， <a href="https://manual.calibre-ebook.com/news_recipe.html" target="_blank" rel="external nofollow noopener noreferrer">BasicRecipe</a> 实现了所有 recipe 都会用到的逻辑，比如 <strong>get_browser</strong>、<strong>postprocess_html</strong> 等方法，LWN 只需要根据自己的逻辑去重载即可。</p><p>我们还可以看到，LWN 这个类下面也定义了很多的参数，这些参数都是根据自己的这次抓取的定制参数。比如最关键的 <code>feeds</code>，这是一个告诉 calibre 从哪下载的 list。</p><p>到现在应该明白 calibre 的工作原理了吧。所有下载的源文件都在互联网上以 HTML 的形式你存在，不论是订阅还是非订阅。calibre 通过将这些源文件（HTML 以及图片等）下载后，对 HTML 文本进行再组织，最常用的工具就是 BeautifulSoup。最后，根据 epub 或者 mobi 等格式的要求，进行格式转换即可。</p><p>在<a href="https://github.com/kovidgoyal/calibre/blob/master/recipes/economist.recipe" target="_blank" rel="external nofollow noopener noreferrer">这里</a>你可以看到经济学人的 recipe，比较复杂，主要是对 html文本的处理，有时间可以仔细研究。</p><p>在 <a href="https://manual.calibre-ebook.com/news.html" target="_blank" rel="external nofollow noopener noreferrer">calibre 的官方文档</a>可以看到关于下载新闻更加详细的教程，以后折腾 RSS 的时候可以再看看。</p><h2 id="自动定时抓取经济学人"><a href="#自动定时抓取经济学人" class="headerlink" title="自动定时抓取经济学人"></a>自动定时抓取经济学人</h2><h3 id="ebook-convert"><a href="#ebook-convert" class="headerlink" title="ebook-convert"></a>ebook-convert</h3><p>从 calibre manual 中可以看到，calibre 给我们提供了众多的命令行工具，但是如果只是下载经济学人的话，我们只需要用到 <code>ebook-convert</code>这一工具。其使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ebook-convert input_file output_file [options]</span><br></pre></td></tr></table></figure><p>一般情况下，这里的 <code>input_file</code>是需要进行格式转换的输入文件，<code>output_file</code>是格式转换的输出文件。比如我们把一个 epub 格式转换成 <code>mobi</code>格式。但是，calibre 也能够对于 <code>recipe</code>文件进行自动解析，去网络上下载对应的 HTML 文件，并将其输出成需要的格式。具体的，对于经济学人：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ebook-convert <span class="string">"The Economist.recipe"</span> <span class="string">"te2020-04-06.epub'</span></span><br></pre></td></tr></table></figure><p>在这里，calibre 会自动根据输出文件的后缀名，将输出文件转换成相应格式，真棒。</p><p>对于不同格式的输入输出文件，还有相应的options。</p><ul><li>对于 Recipe 的输入格式，有以下参数<ul><li><code>--username</code>和<code>--password</code>，如果需要用户名和密码的话，可以用于指定相关参数</li></ul></li><li><code>--output-profile</code>可以针对不同设备对输出文件进行优化，比如 <code>--output-profile=kindle_pw3</code></li></ul><h3 id="什么时候抓取"><a href="#什么时候抓取" class="headerlink" title="什么时候抓取"></a>什么时候抓取</h3><p>根据经济学人的recipe，我们可以看到，其实它每次是以 <a href="https://www.economist.com/printedition" target="_blank" rel="external nofollow noopener noreferrer">https://www.economist.com/printedition</a> 为根节点进行遍历，爬取下面所有的文章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Economist</span><span class="params">(BasicNewsRecipe)</span>:</span></span><br><span class="line"></span><br><span class="line">    title = <span class="string">'The Economist'</span></span><br><span class="line">    language = <span class="string">'en'</span></span><br><span class="line"></span><br><span class="line">    __author__ = <span class="string">"Kovid Goyal"</span></span><br><span class="line">    INDEX = <span class="string">'https://www.economist.com/printedition'</span></span><br><span class="line">    description = (</span><br><span class="line">        <span class="string">'Global news and current affairs from a European'</span></span><br><span class="line">        <span class="string">' perspective. Best downloaded on Friday mornings (GMT)'</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>什么时候爬取最合适呢，它也写了最好是在 GMT 时间的星期五上午，北京时间是 GMT + 8，所以我们设定自动定时就可以了。</p><h3 id="如何抓取音频"><a href="#如何抓取音频" class="headerlink" title="如何抓取音频"></a>如何抓取音频</h3><p>经济学人在官方已经开源了所有的音频文件，其文件地址格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>audiocdn.economist.com<span class="regexp">/sites/</span>default<span class="regexp">/files/</span>AudioArchive<span class="regexp">/2013/</span><span class="number">2013</span>MMDD<span class="regexp">/Issue_****_2013MMDD_The_Economist_Full_edition.zip</span></span><br></pre></td></tr></table></figure><ul><li>MMDD为每周发行日（周六）的月份与日期</li><li><code>****</code>为该周六距离1843年9月2日的周数，也就是其期数。</li></ul><p>为了便于计算，我们计算和查找 <code>2020-01-04</code>是其出版的第 <code>9175</code> 期，之后的期数以这一天为起点计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_date = <span class="string">'2020-01-04'</span></span><br><span class="line">end_date = <span class="string">'2020-04-04'</span></span><br><span class="line">week_start = <span class="number">9175</span></span><br><span class="line">start_sec = time.mktime(time.strptime(start_date,<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line">end_sec = time.mktime(time.strptime(end_date,<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line">week_delta = int((end_sec - start_sec)/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>))</span><br><span class="line">week_now = week_start + week_delta</span><br></pre></td></tr></table></figure><div class="note info">            <p>这里的期数应该不是严格按照每一周一期，因为我们发现 <code>20131109</code>这一期的期号为8861，而 <code>20200404</code>这一期的期号为 <code>9188</code>，其间周数间隔为334，而期数间隔为 327，应该是中间有几期没有音频。</p>          </div><h2 id="容器化主宰世界"><a href="#容器化主宰世界" class="headerlink" title="容器化主宰世界"></a>容器化主宰世界</h2><p>将 calibre 容器化，Dockerfile 如下，这里主要是在 alpine 系统上安装了 <code>calibre</code>，然后启动 crontab 定时调用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ljnelson/docker-calibre-alpine</span><br><span class="line"><span class="keyword">MAINTAINER</span> houmin &lt;houmin.wei@pku.edu.cn&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache python3 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="keyword">if</span> [ ! -e /usr/bin/python ]; <span class="keyword">then</span> ln -sf python3 /usr/bin/python ; <span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> crontab.txt /crontab.txt</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> main.py /main.py</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entry.sh /entry.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /entry.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /usr/bin/crontab /crontab.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/entry.sh"</span>]</span></span><br></pre></td></tr></table></figure><p>为了让外界能够访问这些爬取到的数据，启动一个 FTP 服务器。整体的 <code>docker-compose.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vsftpd:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">vsftpd</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"fauria/vsftpd"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/calibre/data:/home/vsftpd</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"20:20"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"21:21"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"21100-21110:21100-21110"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FTP_USER=[user]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FTP_PASS=[passwd]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_ADDRESS=127.0.0.1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_MIN_PORT=21100</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_MAX_PORT=21110</span></span><br><span class="line">  <span class="attr">calibre:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">calibre</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"unicosmos/calibre"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/calibre/data/[user]:/data</span></span><br></pre></td></tr></table></figure><p>把这里的 <code>user</code> 和 <code>passwd</code> 改成自己服务器的就好了。</p><p>程序主函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime, time, os</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"></span><br><span class="line">mail_host = <span class="string">"smtp.163.com"</span></span><br><span class="line">mail_user = <span class="string">"houmin_wei@163.com"</span></span><br><span class="line">mail_pass = <span class="string">"********"</span></span><br><span class="line"></span><br><span class="line">sender = <span class="string">'houmin_wei@163.com'</span></span><br><span class="line">receivers = [<span class="string">'houmin.wei@pku.edu.cn'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_week</span><span class="params">(date)</span>:</span></span><br><span class="line">    start_date = <span class="string">'20200104'</span></span><br><span class="line">    week_start = <span class="number">9175</span></span><br><span class="line">    start_sec = time.mktime(time.strptime(start_date, <span class="string">'%Y%m%d'</span>))</span><br><span class="line">    date_sec = time.mktime(time.strptime(date, <span class="string">'%Y%m%d'</span>))</span><br><span class="line">    week_delta = int((date_sec - start_sec)/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>))</span><br><span class="line">    week_now = week_start + week_delta</span><br><span class="line">    <span class="keyword">return</span> week_now</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_audio</span><span class="params">(date, path)</span>:</span></span><br><span class="line">    week_now = cal_week(date)</span><br><span class="line">    url = <span class="string">"https://audiocdn.economist.com/sites/default/files/AudioArchive/&#123;year&#125;/&#123;date&#125;/Issue_&#123;week&#125;_&#123;date&#125;_The_Economist_Full_edition.zip"</span>.format(year=date[<span class="number">0</span>:<span class="number">4</span>], date=date, week=week_now)</span><br><span class="line">    print(url)</span><br><span class="line">    cmd = <span class="string">"cd &#123;path&#125;/audio &amp;&amp; wget &#123;url&#125; &amp;&amp; cd -;"</span>.format(path=path, url=url)</span><br><span class="line">    os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_book</span><span class="params">(date, path)</span>:</span></span><br><span class="line">    filename = path + <span class="string">"/ebook/te"</span> + date</span><br><span class="line">    <span class="comment">#cmd = 'ebook-convert \"The Economist.recipe\" ' + filename + '.mobi --output-profile=kindle'</span></span><br><span class="line">    cmd = <span class="string">'ebook-convert \"The Economist.recipe\" '</span> + filename + <span class="string">'.epub'</span></span><br><span class="line">    os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(date, path, sender, receivers)</span>:</span></span><br><span class="line">    epubFile = path + <span class="string">"/ebook/te"</span> + date + <span class="string">'.epub'</span></span><br><span class="line">    epubApart = MIMEApplication(open(epubFile, <span class="string">'rb'</span>).read())</span><br><span class="line">    epubApart.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=epubFile)</span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()</span><br><span class="line">    message.attach(epubApart)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = <span class="string">"The Economist "</span> + date</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP(mail_host, <span class="number">465</span>)</span><br><span class="line">        smtpObj.login(mail_user, mail_pass)</span><br><span class="line">        smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">        print(<span class="string">"sending mail success!"</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        print(<span class="string">"Error: cannot send mail"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operator</span><span class="params">(path)</span>:</span></span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    tomorrow = today + datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    date = tomorrow.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line">    print(<span class="string">"==============================================="</span>)</span><br><span class="line">    print(<span class="string">"Fetch The Economist &#123;date&#125; begin..."</span>.format(date=date))</span><br><span class="line">    get_book(date, path)</span><br><span class="line">    <span class="comment">#get_audio(date, path)</span></span><br><span class="line">    <span class="comment">#send_mail(date, path, sender, receivers)</span></span><br><span class="line">    print(<span class="string">"Fetch The Economist &#123;date&#125; end."</span>.format(date=date))</span><br><span class="line">    print(<span class="string">"===============================================\n\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    operator(<span class="string">"./data"</span>)</span><br></pre></td></tr></table></figure><p>更多具体的内容，可以参考我的 <a href="https://github.com/SimpCosm/calibre" target="_blank" rel="external nofollow noopener noreferrer">Github Repo</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://manual.calibre-ebook.com/" target="_blank" rel="external nofollow noopener noreferrer">calibre manual</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;作为信息源建设的一部分，最近突然想把「经济学人」阅读捡起来。为了能够固定获取「经济学人」文本，研究了一下其爬取过程，记录如下，希望能够有所帮助。&lt;/p&gt;&lt;h2 id=&quot;经济学人是什么&quot;&gt;&lt;a href=&quot;#经济学人是什么&quot; class=&quot;headerlink&quot; title=&quot;经济学人是什么&quot;&gt;&lt;/a&gt;经济学人是什么&lt;/h2&gt;&lt;p&gt;经济学人是一份创办于 1843 年 9 月 2 日的英国杂志。这是一本涉及全球政治、经济、文化、科技等多方面事务的综合性新闻评论刊物，着重于对这些议题提供深入的分析和评论。它的社论持有&lt;a href=&quot;https://zh.wikipedia.org/wiki/古典自由主義&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;古典自由主义&lt;/a&gt;与&lt;a href=&quot;https://zh.wikipedia.org/wiki/經濟自由主義&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;经济自由主义&lt;/a&gt;的立场，倾向于支持&lt;a href=&quot;https://zh.wikipedia.org/wiki/自由貿易&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;自由贸易&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/全球化&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;全球化&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=人口自由流動&amp;amp;action=edit&amp;amp;redlink=1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;人口自由流动&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/社會自由主義&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;社会自由主义&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://www.economist.com/sites/default/files/imagecache/400-width/print-covers/20200404_cuk1280.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="docker" scheme="http://houmin.cc/tags/docker/"/>
    
      <category term="calibre" scheme="http://houmin.cc/tags/calibre/"/>
    
      <category term="ebook" scheme="http://houmin.cc/tags/ebook/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化技术概览</title>
    <link href="http://houmin.cc/posts/65866329/"/>
    <id>http://houmin.cc/posts/65866329/</id>
    <published>2020-04-07T01:04:08.000Z</published>
    <updated>2020-07-14T08:24:44.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>虚拟化的本质是<strong>抽象</strong>，虚拟化技术本质就是<strong>资源管理与优化</strong>技术。通过将计算机的各种物理资源，比如 <strong>CPU</strong>、<strong>内存</strong>以及磁盘空间、网络适配器等其他 <strong>I/O</strong> 设备，进行抽象转换，呈现出一个可供分割并且可以任意组合的多个计算机的配置环境。通过虚拟化技术，计算、网络、存储等计算机硬件资源得到更好的利用，而这些资源的虚拟形式将不受现有架设方式、地域或物理配置所限制。</p><a id="more"></a><h2 id="计算虚拟化"><a href="#计算虚拟化" class="headerlink" title="计算虚拟化"></a>计算虚拟化</h2><h3 id="理想数学模型-Turing-Machine"><a href="#理想数学模型-Turing-Machine" class="headerlink" title="理想数学模型 Turing Machine"></a>理想数学模型 Turing Machine</h3><p>在计算机领域，研究的一切问题都是 <strong>可计算问题（Computational Problem）</strong>。</p><blockquote><p><em>A computational problem</em> is collection of questions that computers might be able to solve.</p></blockquote><p>通过对问题可计算的判定，我们知道不管计算机的存储和计算能力有多强，有些问题总是不能够被解决的。对于那些可计算的问题，怎么解决呢？1936年，图灵在现代计算领域奠基性论文 「论可计算数及其在判定性问题上的应用」<a href="https://en.wikipedia.org/wiki/On_Computable_Numbers,_with_an_Application_to_the_Entscheidungsproblem" target="_blank" rel="external nofollow noopener noreferrer">On Computable Numbers, with an Application to the Entscheidungsproblem</a> 中提出 <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank" rel="external nofollow noopener noreferrer">图灵机</a> 这一纸带和读写头表示的数学模型，并且证明了<strong>假设</strong>上述模型里所说的功能都能被以某种形式物理实现，<strong>那么</strong> <code>任意可计算问题都可以被解决</code>。</p><p><img alt="Turing Machine" data-src="https://upload.wikimedia.org/wikipedia/en/thumb/b/bb/Turing_machine_1.JPG/1024px-Turing_machine_1.JPG"></p><h3 id="二战产物-ENIAC"><a href="#二战产物-ENIAC" class="headerlink" title="二战产物 ENIAC"></a>二战产物 ENIAC</h3><p>二战极大促进了电子计算机的诞生，为了帮助美国陆军的弹道研究实验室（BRL）计算火炮的火力表， ENIAC 在 1946 年被设计了出来。ENIAC 并不是二战中第一个被设计出来的计算机，机械和电子计算机器从19世纪就开始出现了，但是20世纪40年代被看作是现代计算机时代的开端。</p><ul><li>德国<a href="https://zh.wikipedia.org/w/index.php?title=Z3_(计算机" target="_blank" rel="external nofollow noopener noreferrer">Z3</a>&amp;action=edit&amp;redlink=1)计算机于1941年5月公布，这是第一台通用的数字计算机<ul><li>使用<a href="https://zh.wikipedia.org/wiki/继电器" target="_blank" rel="external nofollow noopener noreferrer">继电器</a>，机电计算机，不是电子计算机</li><li>使用二进制进行逻辑计算</li><li>可用打孔纸带编程，但是没有逻辑分支</li></ul></li><li>美国<a href="https://en.wikipedia.org/wiki/Atanasoff–Berry_Computer" target="_blank" rel="external nofollow noopener noreferrer">ABC</a>，1941年夏天公布，是第一台电子计算设备<ul><li>使用电子管，电子计算机</li><li>使用二进制进行逻辑计算</li><li>不是通用的，仅用于求解线性方程组</li><li>没有利用电子计算的速度优势，旋转电容鼓存储器，输入输出系统要把中间结果写出到纸片</li><li>手动控制的，不可编程</li></ul></li><li>英国的<a href="https://zh.wikipedia.org/wiki/巨人计算机" target="_blank" rel="external nofollow noopener noreferrer">巨人计算机</a> Colossus computer，1943年用于密码分析<ul><li>使用电子管，电子计算机</li><li>可用插板和开关编程</li><li>不是通用的，仅用于密码破译</li></ul></li></ul><p>对比这些几乎同时期独立的计算机，ENIAC有以下特点：</p><ul><li>使用电子管，电子计算机</li><li>采用十进制计算</li><li>计算速度高，具备逻辑分支能力</li><li>符合<strong>图灵完全性</strong>，<strong>能够重新编程</strong>，<strong>解决各种计算问题</strong></li><li>缺乏存储程序能力，<strong>冯诺依曼结构</strong>在下一代计算机<a href="https://zh.wikipedia.org/wiki/EDVAC" target="_blank" rel="external nofollow noopener noreferrer">EDVAC</a>上实现</li></ul><p><img alt="ENIAC, 美国弹道研究实验室" data-src="https://upload.wikimedia.org/wikipedia/commons/4/4e/Eniac.jpg"></p><h3 id="多道程序设计-Multiprogramming"><a href="#多道程序设计-Multiprogramming" class="headerlink" title="多道程序设计 Multiprogramming"></a>多道程序设计 Multiprogramming</h3><p>最初的计算机都是串行运行的，一次只能录入并执行一个程序，当程序进行缓慢的 IO 操作时，CPU 只好空转等待。这不仅造成了 CPU 的浪费，也造成了其他计算机硬件资源的浪费。那时的计算机科学家们都在思考着要如何能够提高 CPU 的利用率，直到有人提出了多道程序设计（Multiprogramming，多任务处理的前身）。</p><p>在整个上世纪 50-60 年代，多道程序设计的讨论非常流行。它令 CPU 一次性读取多个程序到内存，先运行第一个程序直到它出现了 IO 操作，此时 CPU 切换到运行第二个程序。</p><blockquote><p>即，<strong>第 n+1 个程序得以执行的条件是第 n 个程序进行 IO 操作或已经运行完毕</strong>。</p></blockquote><p><img alt data-src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/multiprogramming.jpg"></p><p>多道程序设计的特征就是：<strong>多道程序、宏观上并行、微观上串行</strong>。有效的提高了 CPU 的利用率，也充分发挥着其他计算机系统部件的并行性。</p><h3 id="分时-Time-Sharing"><a href="#分时-Time-Sharing" class="headerlink" title="分时 Time Sharing"></a>分时 Time Sharing</h3><p>但多道程序设计存在一个问题， 就是<strong>它并不会去考虑分配给各个程序的时间是否均等，很可能第一个程序运行了几个小时而不出现 IO 操作，故第二个程序没有运行</strong>。最初，这个问题是令人接受的，那时的必须多个程序之间的执行顺序更加关心程序的执行结果。直到有人提出了新的需求：多用户同时使用计算机。应需而生的正是时间共享，或者称之为 “分时” 的概念（Time Sharing）。</p><p>所谓 “分时” 的含义是将 CPU 占用切分为多个极短（1/100sec）的时间片，每个时间片都执行着不同的任务。分时系统中允许几个、几十个甚至几百个用户通过终端机连接到同一台主机，将处理机时间与内存空间按一定的时间间隔，轮流地切换给各终端用户的程序使用。由于时间间隔很短，每个用户感觉就像他独占了计算机一样。<strong>分时系统达到了多个程序分时共享计算机硬件和软件资源的效果</strong>，本质就是一个多用户交互式操作系统。</p><p>分时系统与多道程序设计虽然类似，却也有着底层实现细节的不同</p><ul><li>分时系统是为了给不同用户提供程序的使用，而多道程序则是为了不同程序间的穿插运行</li></ul><p>1959 年，牛津大学的计算机教授，Christopher Strachey 发表了一篇名为 <a href="https://archive.org/details/large-fast-computers" target="_blank" rel="external nofollow noopener noreferrer">Time sharing in large fast computers</a> 的学术报告，他在文中首次提出了 “虚拟化” 的基本概念，还论述了什么是虚拟化技术。</p><blockquote><p><strong>Time sharing</strong>, in the sense of causing the main computer to interrupt its program to perform the arithmetic and control operations required by external or peripheral equipment, has been used on a limited scale for a long time. this paper explores the possibility of applying time sharing to a large fast computer on a very extensive scale.</p></blockquote><p>本质上，Strachey 是在讨论如何将分时的概念融入到多道程序设计当中，从而实现一个可多用户操作（CPU 执行时间切片），又具有多程序设计效益（CPU 主动让出）的虚拟化系统。可见，<strong>虚拟化概念最初的提出就是为了满足多用户同时操作大型计算机，并充分利用大型计算机各部件资源的现实需求</strong>。而对这一需求的实现与演进，贯穿了整个大型机与小型机虚拟化技术的发展历程。</p><p>1961年 MIT 在 IBM7094 型机器上实现了首个分时系统CTSS（Compatible Time-Sharing System，相容分时系统）</p><h3 id="超级计算机-Altas"><a href="#超级计算机-Altas" class="headerlink" title="超级计算机 Altas"></a>超级计算机 Altas</h3><p>1962 年 12 月 7 日，第一台 Atlas 超级计算机在英国诞生，Atlas 是第二代晶体管计算机，被认为是当时世界上最强大的计算机。Atlas 开创了许多沿用至今的软件概念：</p><ul><li>第一次实现名为 Atlas Supervisor 的底层资源管理组件，<strong>Supervisor</strong> 通过特殊的指令或代码来管理主机的硬件资源</li><li>第一次实现分页技术（<strong>Paging Techniques</strong>）</li><li>第一次实现虚拟内存（<strong>Virtual Memory</strong>），当时被称为一级存储（One-Level Store）</li></ul><h3 id="第一个支持虚拟化-IBM-M44-44X"><a href="#第一个支持虚拟化-IBM-M44-44X" class="headerlink" title="第一个支持虚拟化 IBM M44/44X"></a>第一个支持虚拟化 IBM M44/44X</h3><p>1964 年的 IBM M44/44X 被认为是世界上第一个支持虚拟化的系统。它采用专门的硬件和软件，能够在一台物理机器上虚拟多个当时流行的 IBM 7044 大型机。它使用的虚拟化方法是非常原始的：像分时系统一样，在每个时间片，一个 IBM 7044 大型机独占所有硬件资源来运行。</p><p>值得一提的是，这个研究用的原型系统不仅开启了虚拟化技术的时代，M44/44X 实现了多个具有突破性的虚拟化概念，包括部分<strong>硬件共享（Partial Hardware Sharing）</strong>、<strong>分时（Time Sharing）</strong>、<strong>内存分页（Memory Paging）</strong>以及<strong>虚拟内存（Virtual Memory）</strong>。M44/44X 项目首次使用了 “<strong>Virtual Machine</strong>” 这一术语，所以被认为是世界上第一个支持虚拟机的计算机系统。虽然 M44/44X 只实现了部分的虚拟化功能，但其最大的成功在于证明了虚拟机的运行效率并不一定比传统的方式更低</p><p>在那个 “进程” 概念尚未被发明的年代，多任务操作系统和虚拟化技术事实上是难以分开的，因为 “虚拟机” 就是一个任务，而且当时还没有 Intel x86 这种霸主地位的体系结构，各家的大型机各自为政，也谈不上兼容别家的体系结构。这种 “任务级” 或者说 “进程级” 虚拟化，从概念上延续到今天，就是以 LXC 和 OpenVZ 为代表的操作系统级虚拟化。</p><h3 id="IBM的豪赌-System-360"><a href="#IBM的豪赌-System-360" class="headerlink" title="IBM的豪赌 System/360"></a>IBM的豪赌 System/360</h3><p>1964 年，IBM推出了著名的 System/360 大型计算机系统，整个研发过程投资巨大，其出货时间也不断延迟。但最终，取得了巨大的商业成功。当时的项目经理 <code>Frederick P. Brooks</code>事后根据这项计划的开发经验写出了同样著名的《人月神话：软件项目管理之道》（“The Mythical Man-Month: Essays on Software Engineering”），记述了人类工程史上一项里程碑式的大型复杂软件系统的开发经验。</p><ul><li>System/360 实现了基于全硬件的虚拟化解决方案（<strong>Full Hardware Virtualization</strong>）</li><li>System/360 实现了 TSS（Time Sharing System）分时系统，TSS 被认为是最原始的 <strong>CPU 虚拟化技术</strong>，它可以让低端电脑连接大型主机，上传和下载程序或资料，将电子数据处理的 “松散终端” 连接起来。</li></ul><blockquote><p><strong>虚拟化技术的应用和发展源于大型机对分时系统的需求</strong>。这种通过硬件的方式来生成多个可以运行独立操作系统软件的虚拟机实例，解决了早期大型计算机只能单任务处理而不能分时多任务处理的问题。由于这种虚拟化技术是基于硬件设备来实现的，故被称为<strong>硬件虚拟化（Hardware virtualization）</strong>。但需要注意的是，这一定义在后来被进一步细分为了狭义的硬件虚拟化技术，<strong>现今更加被公认的硬件虚拟化定义是：一种对计算机或操作系统的虚拟化，能够对用户隐藏真实的计算机硬件，表现出另一个抽象的计算平台。</strong></p></blockquote><h3 id="伟大实验-MULTICS"><a href="#伟大实验-MULTICS" class="headerlink" title="伟大实验 MULTICS"></a>伟大实验 MULTICS</h3><p>MULTICS，全名 <code>MULTiplexed Information and Computing System</code>，是1964年由贝尔实验室、麻省理工学院及美国通用电气公司所共同参与研发的，是一套安装在大型主机上多人多任务的操作系统，是连接1000部终端机，支持300的用户同时上线。</p><p>MULTICS 是一个伟大的实验，得意于第一代分时系统 CTSS 的成功，它在开发之初就提出了很高的要求：</p><ul><li>首次在大型软件中采用结构化的程序设计方法，使得开发周期大大缩短</li><li>首次采用高级语言编写操作系统，使得系统程序在功能上独立于机器</li><li>首次采用成熟软件作为工具，MULTICS中的很大一部分程序是用CTSS来编写</li><li>首次引入动态链接和分层文件系统的概念</li></ul><p>然而，由于当时编写 MULTICS 的 PL/I 语言并没有很成熟，无力肩负编写操作系统这样的重担。而且整个开发过程中求大求全，多个单位参与，进展过慢，贝尔实验室退出此计划。</p><h3 id="玩具而已-UNIX"><a href="#玩具而已-UNIX" class="headerlink" title="玩具而已 UNIX"></a>玩具而已 UNIX</h3><p>1969年，在 AT&amp;T 的Bell Labs，<code>Ken Thompson</code>为了一项名为<code>Space Travel</code>的游戏，需要一个操作系统。他找了一台闲置的PDP-7 小型机，独自经过 4 个星期的奋斗，以汇编语言写出了一组内核程序，同时包括一些内核工具程序，以及一个小的文件系统，这就是伟大的 UNIX 操作系统的原型。</p><p>UNIX 系统本质上是对 MULTICS 系统的简化，当时开发者 <code>Brian Kernighann</code> 开玩笑地戏称这个不完善系统MULTICS其实是 <code>UNiplexed Information and Computing System</code>，缩写为<code>UNICS</code>。后来，大家取其谐音这个名字被改为<code>UNIX</code>。</p><p>1973 年，贝尔实验室的<code>Dennis Ritchie</code> 以 B 语言为基础开发了一种称为 C 的编程语言。C 语言的设计原则就是好用，非常自由、弹性很大。<code>Ken Thompson</code>和<code>Dennis Ritchie</code>使用 C 语言完全重写了 UNIX，此后 UNIX 就真正成为了可移植的操作系统，那时已是 1977 年。</p><p>1979 年，Unix 的第 7 个版本引入了 chroot 机制，意味着第一个<strong>操作系统虚拟化（OS-level virtualization）</strong>诞生了。chroot 是直到现在我们依然在使用的一个系统调用，这个系统调用会让一个进程把指定的目录作为根目录，它的所有文件系统操作都只能在这个指定目录中进行，本质是一种文件系统层的隔离。</p><h3 id="虚拟化准则-VMM"><a href="#虚拟化准则-VMM" class="headerlink" title="虚拟化准则 VMM"></a>虚拟化准则 VMM</h3><p>1974 年，<code>Gerald J. Popek</code> 和 <code>Robert P. Goldberg</code>在合作论文《可虚拟第三代架构的规范化条件》（“Formal Requirements for Virtualizable Third Generation Architectures”）中提出了一组称为虚拟化准则的充分条件，又称波佩克与戈德堡虚拟化需求（<strong>Popek and Goldberg virtualization requirements</strong>），即：虚拟化系统结构的三个基本条件。满足这些条件的控制程序才可以被称为<strong>虚拟机监控器（Virtual Machine Monitor，简称 VMM）</strong>：</p><ul><li><strong>资源控制（Resource Control）</strong>，控制程序必须能够管理所有的系统资源。</li><li><strong>等价性（Equivalence）</strong>，在控制程序管理下运行的程序（包括操作系统），除时序和资源可用性之外的行为应该与没有控制程序时的完全一致，且预先编写的特权指令可以自由地执行。</li><li><strong>效率性（Efficiency）</strong>，绝大多数的客户机指令应该由主机硬件直接执行而无需控制程序的参与。</li></ul><p>该论文尽管基于简化的假设，但上述条件仍为评判一个计算机体系结构是否能够有效支持虚拟化提供了一个便利方法，也为设计可虚拟化的计算机架构给出了指导原则。同时，Gerald J. Popek 和 Robert P. Goldberg 还在论文中介绍了两种 Hypervisor 类型。</p><p><img alt="Hypervisor" data-src="https://upload.wikimedia.org/wikipedia/commons/e/e1/Hyperviseur.png"></p><ul><li>类型 I (<strong>Bare-metal Hypervisors</strong>)<ul><li>这些虚拟机管理程序直接运行在宿主机（Host）的硬件上来控制硬件和管理虚拟机。</li><li>需要硬件支持</li><li>VMM 作为宿主机操作系统（Host OS）</li><li>运行效率高</li></ul></li></ul><p><img alt="Hypervisor" data-src="https://microkerneldude.files.wordpress.com/2012/01/type1-vs-2.png"></p><ul><li>类型 II（<strong>Hosted Hypervisorsr</strong>）<ul><li>VMM 运行在传统的宿主机操作系统（Host OS）上，就像其他应用程序那样运行。</li><li>VMM 作为应用程序运行在宿主机操作系统之上</li><li>运行效率一般较类型 I 低</li></ul></li></ul><p>由于技术的原因，早期的 VMM 产品大多实现的是寄居式，例如：VMware 5.5 以前的版本、Xen 3.0 以前的版本。随着技术的成熟，主要是硬件虚拟化技术的诞生，几乎所有的 VMM 产品都转向了裸金属 Hypervisor 实现。例如：VMware 5.5 及以后版本、Xen 3.0 及以后版本以及 KVM。</p><h3 id="接棒开源-GNU-Linux"><a href="#接棒开源-GNU-Linux" class="headerlink" title="接棒开源 GNU/Linux"></a>接棒开源 GNU/Linux</h3><p><img alt="GNU/Linux" data-src="https://i1.wp.com/www.linuxandubuntu.com/wp-content/uploads/2019/07/What-is-GNU-in-GNULinux.jpg"></p><h3 id="软件辅助虚拟化-QEMU"><a href="#软件辅助虚拟化-QEMU" class="headerlink" title="软件辅助虚拟化 QEMU"></a>软件辅助虚拟化 QEMU</h3><p>2001，Fabrice Bellard 发布了目前最流行的、采用了<strong>动态二进制翻译（Binary Translation）</strong>技术的开源虚拟化软件 QEMU（Quick EMUlator）。QEMU 可以模拟 x86、x86_64、ARM、MIPS、SPARC、PowerPC 等多种处理器架构，无修改地运行这些架构上的操作系统。</p><p><strong>软件辅助虚拟化</strong> 是通过 <strong>优先级压缩（Ring Compression）</strong>和 <strong>二进制代码翻译（Binary Translation）</strong>这两个技术来完成的。RC 基于 CPU 特权级的原理。也就是 guest、VMM 和 host 分别处于不同的特权级上，guest 要访问 host 就属于越级访问，会抛异常，这时 VMM 会截获这个异常，并模拟出其可能的行为，从而进行相应处理。</p><p>以我们最熟悉的 Intel x86 架构为例，分为四个特权级 0~3。一般情况下，操作系统内核（特权代码）运行在 ring 0（最高特权级），而用户进程（非特权代码）运行在 ring 3（最低特权级）。</p><p><img alt data-src="https://ring0.me/images/2014/12/9c37a75e8e2164f50ffe76681c6d4522.png"></p><p>使用了虚拟机之后，Guest OS 运行在 ring 1，VMM 运行在 ring 0。比如在 Windows 上装个 Linux 虚拟机，Windows 内核运行在 ring 0，而被虚拟的 Linux 内核运行在 ring 1，Linux 系统里的应用程序则运行在 ring 3。当虚拟机系统需要执行特权指令时，VMM 就会立即捕获它（谁让 ring 0 比 ring 1 的特权级高呢！）并模拟执行这条特权指令，再返回到虚拟机系统。</p><p>为了提高系统调用、中断处理的性能，有时会利用动态二进制翻译的技术，在运行前把这些特权指令替换成调用虚拟机管理器 API 的指令。如果所有特权指令都模拟得天衣无缝，虚拟机系统就像运行在物理机器上一样，完全不能发现自己运行在虚拟机里。</p><h3 id="半虚拟化-Xen"><a href="#半虚拟化-Xen" class="headerlink" title="半虚拟化 Xen"></a>半虚拟化 Xen</h3><p>2003 年，英国剑桥大学的一位讲师发布了开源虚拟化项目 Xen 1.0，通过<strong>半虚拟化技术</strong>为 x86-64 提供虚拟化支持。</p><p>既然<strong>动态二进制翻译的难点和性能瓶颈在于模拟执行那些杂七杂八的特权指令</strong>，我们能不能修改虚拟机系统的内核，把那些特权指令改得好看些？毕竟在多数情况下，我们并不需要对虚拟机刻意 “隐瞒” 虚拟化层的存在，而是要在虚拟机之间提供必要的隔离，同时又不造成太多性能开销。</p><p>Paravirtualization 这个单词的前缀是 para-，即 “with” “alongside” 之意。也就是虚拟机系统与虚拟化层（主机系统）不再是严格的上下级关系，而是互信合作的关系，<strong>虚拟化层要在一定程度上信任虚拟机系统。在 x86 架构中，虚拟化层（Virtualization Layer）和虚拟机系统的内核（Guest OS）都运行在 ring 0。</strong></p><p><img alt data-src="https://ring0.me/images/2014/12/98ce27bf0640053df5db977f6c41cc3e.png"></p><p><strong>虚拟机系统的内核需要经过特殊修改，把特权指令改成对虚拟化层 API 的调用</strong>。在现代操作系统中，由于这些体系结构相关的特权操作都被封装起来了（例如 Linux 内核源码中的 arch/ 目录），比起二进制翻译需要考虑各种边角情况，这种对虚拟机内核源码的修改就简单一些了。</p><p><strong>相比使用二进制翻译的全虚拟化（full virtualization），半虚拟化是牺牲了通用性来换取性能，因为任何操作系统都可以无修改地运行在全虚拟化平台上，而每个半虚拟化的操作系统内核都要经过人肉修改。</strong></p><h3 id="硬件辅助虚拟化-Intel-VT-x"><a href="#硬件辅助虚拟化-Intel-VT-x" class="headerlink" title="硬件辅助虚拟化 Intel VT-x"></a>硬件辅助虚拟化 Intel VT-x</h3><p>2006 年，Intel 和 AMD 等厂商相继将对虚拟化技术的支持加入到 x86 体系结构的CPU中（AMD-V，Intel VT-x/d），使原来纯软件实现的各项功能可以用借助硬件的力量实现提速，此即 <strong>硬件辅助的虚拟化</strong>。</p><p>Xen这种<strong>将 Guest OS 中的特权指令改成对虚拟化层 API 的调用</strong>方式<strong>并不通用</strong>，要去改 Guest OS 的代码，只能看作是一种定制。为了能够通用，又能够提高性能，就只能从硬件上去做文章了。通过对硬件本身加入更多的虚拟化功能，就可以截获更多的敏感指令，填补上漏洞。所以后来，以 Intel 的 VT-x 和 AMD 的 AMD-V 为主的硬件辅助的 CPU 虚拟化就被提出来（Intel VT 包括 VT-x （支持 CPU 虚拟化）、EPT（支持内存虚拟化）和 VT-d（支持 I/O 虚拟化））。</p><p><img alt data-src="https://ring0.me/images/2014/12/05112238fed78cb9df19c07ec82544cf.png"></p><p>CPU 硬件辅助虚拟化在 Ring 模式的基础上引入了一种新的模式，叫 VMX 模式。它包括根操作模式（VMX Root Operation）和非根操作模式（VMX Non-Root Operation）。</p><p>引入这种模式的好处就在于，Guest OS 运行在 Ring 0 上，就意味着它的核心指令可以直接下达到硬件层去执行，而特权指令等敏感指令的执行则是由硬件辅助，直接切换到 VMM 执行，这是自动执行的，应用程序是感知不到的，性能自然就提高了。</p><p>这种切换 VT-x 定义了一套机制，称为 VM-entry 和 VM-exit。从非根模式切换到根模式，也就是从 Guest 切换到 Host VMM，称为 VM-exit，反之称为 VM-entry。</p><ul><li>VM-exit ： 如果 Guest OS 运行过程中遇到需要 VMM 处理的事件，比如中断或缺页异常，或者主动调用 <code>VMCAL</code>指 令调用 VMM 服务的时候（类似于系统调用），硬件自动挂起 Guest OS，切换到根模式，VMM 开始执行。</li><li>VM-entry： VMM 通过显示调用 <code>VMLAUNCH</code> 或 <code>VMRESUME</code> 指令切换到非根模式，硬件自动加载 Guest OS 的上下文，Guest OS 开始执行。</li></ul><p><img alt data-src="https://images2018.cnblogs.com/blog/431521/201712/431521-20171203175521851-450299329.png"></p><h3 id="基于内核的虚拟化-KVM"><a href="#基于内核的虚拟化-KVM" class="headerlink" title="基于内核的虚拟化 KVM"></a>基于内核的虚拟化 KVM</h3><p>2007 年 2 月，Linux Kernel 2.6.20 合入了 KVM 内核模块，使用 KVM 的前提是 CPU 必须要支持虚拟化技术。</p><p>一般 KVM 只负责 CPU 和内存的虚拟化，I/O 的虚拟化则由另外一个技术来完成，即 QEMU。</p><p><img alt="Kernel-based Virtual Machine" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Kernel-based_Virtual_Machine.svg/967px-Kernel-based_Virtual_Machine.svg.png"></p><p>KVM 是一种硬件辅助的虚拟化技术，支持 Intel VT-x 和 AMD-v 技术，怎么知道 CPU 是否支持 KVM 虚拟化呢？可以通过如下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -E '(vmx|svm)' /proc/cpuinfo</span></span><br></pre></td></tr></table></figure><p>如果输出是 vmx 或 svm，则表明当前 CPU 支持 KVM，Intel 是 vmx，AMD 是svm。</p><p>从本质上看，一个 KVM 虚拟机对应 Host 上的一个 qemu-kvm 进程，它和其他 Linux 进程一样被调度，而 qemu-kvm 进程中的一个线程就对应虚拟机的虚拟 CPU （vCPU），虚拟机中的任务线程就被 vCPU 所调度。</p><p>比如下面这个例子，Host 机有两个物理 CPU，上面起了两个虚拟机 VM1 和 VM2，VM1 有两个 vCPU，VM2 有 3 个 vCPU，VM1 和 VM2 分别有 2 个 和 3 个线程在 2 个物理 CPU 上调度。VM1 和 VM2 中又分别有 3 个任务线程在被 vCPU 调度。</p><p>所以，这里有两级的 CPU 调度，Guest OS 中的 vCPU 负责一级调度，Host VMM 负责另一级调度，即 vCPU 在物理 CPU 上的调度。</p><p><img alt data-src="https://images2018.cnblogs.com/blog/431521/201712/431521-20171203175802101-1388918605.png"></p><p>我们也可以看到，vCPU 的个数，可以超过物理 CPU 的个数，这个叫 CPU 「超配」，这正是 CPU 虚拟化的优势所在，这表明了虚拟机能够充分利用 Host 的 CPU 资源，进行相应的业务处理，运维人员也可以据此控制 CPU 资源使用，达到灵活调度。</p><h3 id="大数据时代-GFS-MapReduce-BigTable"><a href="#大数据时代-GFS-MapReduce-BigTable" class="headerlink" title="大数据时代 GFS/MapReduce/BigTable"></a>大数据时代 GFS/MapReduce/BigTable</h3><ul><li>2003 年，Google 发布 <code>The Google File System</code>，讲述了一种可扩展的分布式文件系统</li><li>2004 年，Google 发布 <code>MapReduce: Simplified Data Processing on Large Clusters</code>，讲述了大数据的分布式计算方式，即将任务分解然后在多台处理能力较弱的计算节点中同时处理，然后将结果合并从而完成大数据处理。</li><li>2006 年，Google 发布 <code>Bigtable: A Distributed Storage System for Structured Data</code>，讲述了用于存储和管理结构化数据的分布式存储系统，其建立在 GFS、MapReduce 等基础之上。该论文启发了后期的很多的 NoSQL 数据库，包括 Cassandra、HBase 等。</li></ul><p>在 Google 的三篇论文发布之后，大数据时代宣告到来，于此同时，Hadoop 生态开始建立。</p><h3 id="云计算吃螃蟹的人-AWS"><a href="#云计算吃螃蟹的人-AWS" class="headerlink" title="云计算吃螃蟹的人 AWS"></a>云计算吃螃蟹的人 AWS</h3><p>2006 年，<strong>Amazon Web Services</strong> 开始以 Web 服务的形式向企业提供 IT 基础设施服务，包括弹性计算网云（EC2）、简单储存服务（S3）、简单数据库（SimpleDB）等，现在通常称为云计算。尽管云计算最早是由谷歌CEO <code>Eric Schmidt</code>，真正第一个吃螃蟹的人却是 Amazon。</p><p><img alt data-src="https://img-blog.csdnimg.cn/20190817201518961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"></p><h3 id="操作系统级虚拟化-LXC"><a href="#操作系统级虚拟化-LXC" class="headerlink" title="操作系统级虚拟化 LXC"></a>操作系统级虚拟化 LXC</h3><p><strong>2008 年 6 月</strong>，Linux Container（LXC） 发布 0.1.0 版本，其可以提供轻量级的虚拟化，用来隔离进程和资源，是 Docker 最初使用的容器技术支撑。</p><p>很多时候，我们并不是想在虚拟机里运行任意的操作系统，而是希望在不同的任务间实现一定程度的隔离。前面提到的虚拟化技术，每个虚拟机都是一个独立的操作系统，有自己的任务调度、内存管理、文件系统、设备驱动程序等，还会运行一定数量的系统服务（如刷新磁盘缓冲区、日志记录器、定时任务、ssh 服务器、时间同步服务），这些东西都会消耗系统资源（主要是内存），而且虚拟机和虚拟机管理器的两层任务调度、设备驱动等也会增加时间开销。能不能让虚拟机共享操作系统内核，又保持一定的隔离性呢？</p><p><img alt data-src="https://ring0.me/images/2014/12/30cc029394b7687320fbca8c654b7671.png"></p><p>chroot 的文件系统隔离给我们带来部分的思路，但是要成为一个真正的虚拟化解决方案，只有文件系统隔离是不够的。另外两个重要的方面是：</p><ul><li>进程、网络、IPC（进程间通信）、用户等<strong>命名空间的隔离</strong>。使得虚拟机内部只能看到自己的进程，只能使用自己的虚拟网卡，进程间通信时不会干扰到虚拟机外面，虚拟机内的 UID/GID 与外面的独立。</li><li>资源的限制和审计。不能因为虚拟机内的程序 “跑飞了”，就占掉物理机器的所有 CPU、内存、硬盘等资源。必须要能统计虚拟机占了多少资源，并能够对资源进行限制。</li></ul><p>上述两件事情就是 BSD 和 Linux 社区在进入 21 世纪以来逐步在做的。在 Linux 中，命名空间的隔离叫做用户命名空间，在创建进程时，通过指定 clone 系统调用的参数来创建新的命名空间；资源的限制和审计是 cgroups 做的，它的 API 位于 proc 虚拟文件系统中。</p><p>这种虚拟机里运行一个或多个进程、虚拟机与主机共享一个内核的虚拟化方案，被称为 <strong>操作系统级虚拟化</strong> 或 <strong>任务级虚拟化</strong>。由于 Linux Containers（LXC）从 Linux 3.8 版本开始被纳入内核主线，操作系统级虚拟化又被称为 “容器”（container）。为了与虚拟机是一个完整的操作系统的虚拟化方案相区分，被隔离执行的进程（进程组）往往不称为 “虚拟机”，而称为 “容器”。由于没有多余的一层操作系统内核，容器比虚拟机更加轻量，启动更快，内存开销、调度开销也更小，更重要的是访问磁盘等 I/O 设备不需要经过虚拟化层，没有性能损失。</p><h3 id="云计算操作系统-OpenStack"><a href="#云计算操作系统-OpenStack" class="headerlink" title="云计算操作系统 OpenStack"></a>云计算操作系统 OpenStack</h3><p>2010 年 7 月，NASA 和 Rackspace 联合发起了 OpenStack 云操作系统开源项目。</p><p>OpenStack 要对云上的各种资源进行虚拟化：</p><ul><li><strong>计算</strong>：OpenStack 可以使用多种多样的虚拟化解决方案，如 Xen、KVM、QEMU、Docker。管理组件 Nova 根据各物理节点的负载决定把虚拟机调度到哪台物理机，再调用这些虚拟化解决方案的 API 来创建、删除、开机、关机等。</li><li><strong>存储</strong>：虚拟机镜像如果只能存储在计算节点本地，那么不仅不利于数据的冗余，也不利于虚拟机的迁移。因此在云中，一般采用逻辑上集中、物理上分布式的存储系统，独立于计算节点，也就是计算节点对数据磁盘的访问一般是通过网络访问。</li><li><strong>网络</strong>：每个客户要有自己的虚拟网络，如何让不同客户的虚拟网络在物理网络上互不干扰，就是网络虚拟化的事情。</li></ul><p>除了最核心的虚拟化管理器 Nova，OpenStack 还有虚拟机镜像管理器 Glance、对象存储 Swift、块存储 Cinder、虚拟网络 Neutron、身份认证服务 Keystone、控制面板 Horizon 等众多组件。</p><p><img alt="OpenStack Architecture" data-src="https://docs.openstack.org/install-guide/_images/openstack_kilo_conceptual_arch.png"></p><h3 id="容器的好管家-Docker"><a href="#容器的好管家-Docker" class="headerlink" title="容器的好管家 Docker"></a>容器的好管家 Docker</h3><p><strong>2014 年 6 月</strong>，Docker 基于 LXC 发布了第一个正式版本 v1.0。</p><p>Docker 是为系统运维而生，它大大降低了软件安装、部署的成本。软件的安装之所以是个麻烦事，是因为</p><ul><li><p><strong>软件之间存在依赖关系</strong>。比如，Linux 上依赖标准 C 库 glibc，依赖密码学库 OpenSSL，依赖 Java 运行环境；Windows 上依赖 .NET Framework，依赖 Flash 播放器。如果每个软件都带上它所有的依赖，那就太臃肿了，如何找到并安装软件的依赖，是一门大学问，也是各个 Linux 发行版的特色所在。</p></li><li><p><strong>软件之间存在冲突</strong>。比如，程序 A 依赖 glibc 2.13，而程序 B 依赖 glibc 2.14；甲脚本需要 Python 3，乙脚本需要 Python 2；Apache 和 Nginx 两个 Web 服务器都想要监听 80 端口。互相冲突的软件安装在同一个系统里，总是容易带来一些混乱，比如 Windows 早期的 DLL Hell。解决软件冲突之道就是隔离，让多个版本在系统里共存，并提供方法来找到匹配的版本。</p></li></ul><p>我们看看 Docker 如何解决这两个问题：</p><ol><li>把软件的所有依赖关系和运行环境打包在一个镜像里，而不是使用复杂的脚本来在未知的环境里 “安装” 软件；</li><li><p>这个包含了所有依赖的包一定很大，因此 Docker 的镜像是层次化的，即应用程序的镜像一般是基于基本系统镜像，只需要传输和存储增量部分就行了，这依赖于Linux 的 AUFS（Another Union File System）。<br><img alt data-src="https://ring0.me/images/2014/12/f584cb21ff9e39a0164bfc6e7b54900a.png"></p></li><li><p>Docker 使用基于容器的虚拟化，把每个软件运行在独立的容器里，避免了不同软件的文件系统路径冲突和运行时的资源冲突。<br><img alt data-src="https://ring0.me/images/2014/12/bd0b38dbee5e3dd50e89367a440fc6bf.png"></p></li></ol><p>Docker 最开始基于 LXC 实现，后来则是基于 libcontainer。libcontainer 和 LXC 事实上都是基于 Linux 内核提供的 cgroups 资源审计、chroot 文件系统隔离、命名空间隔离等机制。</p><h3 id="云原生时代-Kubernetes"><a href="#云原生时代-Kubernetes" class="headerlink" title="云原生时代 Kubernetes"></a>云原生时代 Kubernetes</h3><p><strong>2015 年 7 月 21 日</strong>：Kubernetes v1.0 发布！进入云原生时代。</p><p><img alt="Kubernetes Architecture" data-src="https://platform9.com/wp-content/uploads/2019/05/kubernetes-constructs-concepts-architecture.jpg"></p><hr><p>实际上，上述从二十世纪四十年代以来的发展历程，主要说的是计算虚拟化的事情，也就是 CPU 虚拟化。CPU 虚拟化固然是核心中的核心，但是计算机其他组件的虚拟化也不容忽视，比如内存的虚拟化，包括存储、网络等在内的 I/O 虚拟化。</p><h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><h3 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h3><p>前面讲虚拟化的鼻祖 IBM M44/44X 的时候，提到它提出了 “分页” 的概念。也就是每个任务（虚拟机）似乎独占所有内存空间，分页机制负责把不同任务的内存地址映射到物理内存。如果物理内存不够了，操作系统就会把不常用的任务的内存交换到磁盘之类的外部存储，等那个不常用任务需要执行时再加载回来（当然，这种机制是后来才发明的）。这样，程序的开发者就不需要考虑物理内存空间有多大，也不需要考虑不同任务的内存地址是否会冲突。</p><p>现在我们用的计算机都有分页机制，应用程序（用户态进程）看到的是一片广阔无涯的虚拟内存（Virtual Memory），似乎整台机器都被自己独占；操作系统负责设置用户态进程的虚拟内存到物理内存的映射关系；CPU 中的 MMU（Memory Management Unit）负责在用户态程序运行时，通过查询映射关系（所谓的页表），把指令中的虚拟地址翻译成物理地址。</p><p><img alt data-src="https://images2018.cnblogs.com/blog/431521/201712/431521-20171203180443851-1606756853.png"></p><p>这里要说的不是这种虚拟内存，而是<strong>基于虚拟机的内存虚拟化</strong>，它们本质上是一样的，通过对虚拟内存的理解，再去理解内存虚拟化就比较容易了。</p><p>内存虚拟化也分为<strong>基于软件的内存虚拟化</strong>和<strong>硬件辅助的内存虚拟化</strong>，其中，常用的基于软件的内存虚拟化技术为<strong>「影子页表」</strong>技术，硬件辅助内存虚拟化技术为 Intel 的 <strong>EPT（Extended Page Table，扩展页表）</strong>技术。</p><h3 id="Shadow-Page-Table"><a href="#Shadow-Page-Table" class="headerlink" title="Shadow Page Table"></a>Shadow Page Table</h3><p>内存软件虚拟化的目标就是要将虚拟机的虚拟地址（Guest Virtual Address, GVA）转化为 Host 的物理地址（Host Physical Address, HPA），中间要经过虚拟机的物理地址（Guest Physical Address, GPA）和 Host 虚拟地址（Host Virtual Address）的转化，即：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GVA -&gt; GPA -&gt; HVA -&gt; HPA</span><br></pre></td></tr></table></figure><p>其中前两步由虚拟机的系统页表完成，中间两步由 VMM 定义的映射表（由数据结构 kvm_memory_slot 记录）完成，它可以将连续的虚拟机物理地址映射成非连续的 Host 机虚拟地址，后面两步则由 Host 机的系统页表完成。如下图所示。</p><p><img alt="Shadow Page Table" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-07_shadow-page-table.png"></p><p>这样做得目的有两个：</p><ol><li>提供给虚拟机一个从零开始的连续的物理内存空间。</li><li>在各虚拟机之间有效隔离、调度以及共享内存资源。</li></ol><p>我们可以看到，传统的内存虚拟化方式，虚拟机的每次内存访问都需要 VMM 介入，并由软件进行多次地址转换，其效率是非常低的。因此才有了影子页表技术和 EPT 技术。</p><p><strong>影子页表简化了地址转换的过程，实现了 Guest 虚拟地址空间到 Host 物理地址空间的直接映射。</strong></p><p>要实现这样的映射，必须为 Guest 的系统页表设计一套对应的影子页表，然后将影子页表装入 Host 的 MMU 中，这样当 Guest 访问 Host 内存时，就可以根据 MMU 中的影子页表映射关系，完成 GVA 到 HPA 的直接映射。而维护这套影子页表的工作则由 VMM 来完成。</p><p>由于 Guest 中的每个进程都有自己的虚拟地址空间，这就意味着 VMM 要为 Guest 中的每个进程页表都维护一套对应的影子页表，当 Guest 进程访问内存时，才将该进程的影子页表装入 Host 的 MMU 中，完成地址转换。</p><p>我们也看到，这种方式虽然减少了地址转换的次数，但本质上还是纯软件实现的，效率还是不高，而且 VMM 承担了太多影子页表的维护工作，设计不好。</p><p>为了改善这个问题，就提出了基于硬件的内存虚拟化方式，将这些繁琐的工作都交给硬件来完成，从而大大提高了效率。</p><h3 id="Extended-Page-Table"><a href="#Extended-Page-Table" class="headerlink" title="Extended Page Table"></a>Extended Page Table</h3><p>下图是 EPT 的基本原理图示，EPT 在原有 CR3 页表地址映射的基础上，引入了 EPT 页表来实现另一层映射，这样，GVA-&gt;GPA-&gt;HPA 的两次地址转换都由硬件来完成。</p><p><img alt="Extended Page Table" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-07_ept.png"></p><p>这里举一个小例子来说明整个地址转换的过程。假设现在 Guest 中某个进程需要访问内存，CPU 首先会访问 Guest 中的 CR3 页表来完成 GVA 到 GPA 的转换，如果 GPA 不为空，则 CPU 接着通过 EPT 页表来实现 GPA 到 HPA 的转换（实际上，CPU 会首先查看硬件 EPT TLB 或者缓存，如果没有对应的转换，才会进一步查看 EPT 页表），如果 HPA 为空呢，则 CPU 会抛出 EPT Violation 异常由 VMM 来处理。</p><p>如果 GPA 地址为空，即缺页，则 CPU 产生缺页异常，注意，这里，如果是软件实现的方式，则会产生 VM-exit，但是硬件实现方式，并不会发生 VM-exit，而是按照一般的缺页中断处理，这种情况下，也就是交给 Guest 内核的中断处理程序处理。</p><p>在中断处理程序中会产生 EXIT_REASON_EPT_VIOLATION，Guest 退出，VMM 截获到该异常后，分配物理地址并建立 GVA 到 HPA 的映射，并保存到 EPT 中，这样在下次访问的时候就可以完成从 GVA 到 HPA 的转换了。</p><p>有人也许会担心增加的一级映射关系会减慢内存访问速度，事实上不论是否启用二级内存翻译（SLAT），页表高速缓存（Translation Lookaside Buffer，TLB）都会存储虚拟地址（VA）到机器地址（MA）的映射。如果 TLB 的命中率较高，则增加的一级内存翻译不会显著影响内存访问性能。</p><p><img alt data-src="https://ring0.me/images/2014/12/a45258f97f500142bfcff56770ba2106.png"></p><h2 id="I-O-虚拟化"><a href="#I-O-虚拟化" class="headerlink" title="I/O 虚拟化"></a>I/O 虚拟化</h2><p>首先我们来回顾一下 I/O 模型：</p><p><img alt="Interactions With I/O Devices" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-07_interaction-with-io-devices.png"> </p><h3 id="Emulation"><a href="#Emulation" class="headerlink" title="Emulation"></a>Emulation</h3><p>模拟模型是使用最为广泛的I/O设备虚拟化模型，该模型采用软件的方式模拟设备行为，为虚拟机模拟出与底层硬件完全一致的虚拟化环境，保证虚拟机操作系统的行为与非虚拟化环境下完全一致。</p><p>在模拟模型中，虚拟设备必须以某种方式让虚拟机可以发现，导致虚拟机被“欺骗”。当 VM 访问虚拟设备时，访问请求被 VMM 截获，然后VMM 将I/O请求交由domain0 来模拟完成，最后将结果返回给虚拟机。</p><p>模拟模型分为以下两类：</p><h4 id="Hypervisor-based-device-emulation"><a href="#Hypervisor-based-device-emulation" class="headerlink" title="Hypervisor-based device emulation"></a>Hypervisor-based device emulation</h4><p><img alt="Hypervisor-based device emulation" data-src="https://www.ibm.com/developerworks/library/l-pci-passthrough/figure1.gif"></p><h4 id="User-space-device-emulation"><a href="#User-space-device-emulation" class="headerlink" title="User-space device emulation"></a>User-space device emulation</h4><p><img alt="User-space device emulation" data-src="https://developer.ibm.com/developer/tutorials/l-pci-passthrough/images/figure2.gif"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本文是对虚拟化概览，也是作为 <a href="../../tags/虚拟化">虚拟化技术系列</a> 的第一篇。开篇概览对整体有了基本的认识，毋庸置疑，里面涉及到的技术细节凡凡总总。掌握了大的方向，后续本系列可以继续扩展，拓展到网络虚拟化、存储虚拟化、GPU 虚拟化等等。不管细节如何，我们做的都是抽象。</p><p>纵观虚拟化技术的发展历史，可以看到它始终如一的目标就是实现对 IT 资源的充分利用。虚拟化本质是对 IT 资源的抽象，沿着虚拟化的道路继续发展，我们看到了云计算的开花结果，实现了更上层的对企业业务能力的抽象。抽象之外，我们也可以在这个过程中不断的看到软硬件结合与替代的思路，做一件事软件与硬件只是不同的路径，到底路该怎么走，就得看我们想到哪了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.kernelthread.com/publications/virtualization" target="_blank" rel="external nofollow noopener noreferrer">http://www.kernelthread.com/publications/virtualization</a></li><li><a href="https://blog.csdn.net/Jmilk/article/details/99675664" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Jmilk/article/details/99675664</a></li><li><a href="https://ring0.me/2014/12/virtualization-overview" target="_blank" rel="external nofollow noopener noreferrer">https://ring0.me/2014/12/virtualization-overview</a></li><li><a href="https://developer.ibm.com/tutorials/l-pci-passthrough" target="_blank" rel="external nofollow noopener noreferrer">https://developer.ibm.com/tutorials/l-pci-passthrough</a></li><li><a href="https://developer.ibm.com/technologies/linux/articles/l-virtio" target="_blank" rel="external nofollow noopener noreferrer">https://developer.ibm.com/technologies/linux/articles/l-virtio</a></li><li><a href="https://developer.ibm.com/tutorials/l-hypervisor" target="_blank" rel="external nofollow noopener noreferrer">https://developer.ibm.com/tutorials/l-hypervisor</a></li><li><a href="https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/io_virtualization.pdf" target="_blank" rel="external nofollow noopener noreferrer">https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/io_virtualization.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟化的本质是&lt;strong&gt;抽象&lt;/strong&gt;，虚拟化技术本质就是&lt;strong&gt;资源管理与优化&lt;/strong&gt;技术。通过将计算机的各种物理资源，比如 &lt;strong&gt;CPU&lt;/strong&gt;、&lt;strong&gt;内存&lt;/strong&gt;以及磁盘空间、网络适配器等其他 &lt;strong&gt;I/O&lt;/strong&gt; 设备，进行抽象转换，呈现出一个可供分割并且可以任意组合的多个计算机的配置环境。通过虚拟化技术，计算、网络、存储等计算机硬件资源得到更好的利用，而这些资源的虚拟形式将不受现有架设方式、地域或物理配置所限制。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://upload.wikimedia.org/wikipedia/commons/e/e1/Hyperviseur.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="虚拟化" scheme="http://houmin.cc/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="hypervisor" scheme="http://houmin.cc/tags/hypervisor/"/>
    
      <category term="VMM" scheme="http://houmin.cc/tags/VMM/"/>
    
      <category term="云计算" scheme="http://houmin.cc/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>清明</title>
    <link href="http://houmin.cc/posts/95185ec7/"/>
    <id>http://houmin.cc/posts/95185ec7/</id>
    <published>2020-04-04T10:12:07.000Z</published>
    <updated>2020-07-14T08:24:44.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是一个非同寻常的清明节，如同汶川大地震那次的全国默哀一样，今天注定会成为所有国民的国家记忆。封面图是我特别喜欢的一个镜头，<code>20200404</code>、清明、武汉、江汉关、降半旗，在 2020 年的伊始，根本没有人会将这几个词组合在一起。此刻才真正理解了生命无常，在历史、灾难、自然面前，人类是多么的弱小，所有之前的预设都推倒全来。</p><p>这里是「朝花夕拾」第十二期，今天我们为他们哀悼，为我们逝去的先辈哀悼，为所有在新冠疫情斗争中牺牲的英烈，为在西昌凉州山火中牺牲的英烈哀悼，为已经逝去的伟大的中国人民哀悼。逝者已去，我们追思低首，缅怀往事；生者继续，我们看向未来，在磨难中不断前行。</p>    <div id="aplayer-NFeYeqzr" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1298843453" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><p><img alt data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-04_qingming.jpg"></p><a id="more"></a><p>今年清明没有下雨，难得清明在家（虽然去年春招结束清明也跑了回来），像小时候一样，跟着爸妈去两边的祖坟祭扫。小时候不懂得清明扫墓的意义，听着爸妈的安排，坟头黑土盖瓦、黄纸标墓、火盆烧纸、红香磕头。听着爸妈的絮语，希望他们在地下安好，希望他们能够保佑我们在世的孩子。整个过程不许嬉笑，潜移默化中认识了中国这种传统的祖先崇拜。</p><p>年岁渐长，开始对于生死有了更多认识。</p><hr><p>六年级春末奶奶逝去，心里更多的是害怕，看着奶奶越来越消瘦，也知道奶奶是胃癌晚期。直到有一天中午放学回家的路上，突然碰到村里人告知我奶奶去世的消息。回到家中，整个家里白事帐篷已经搭起，看到奶奶一动不动的躺在大堂。心里还是害怕，不愿意接受这个事实。爸妈忙着接待往来客人，无暇顾及我，我也不愿意呆在那个环境下，没吃午饭就自己回到了学校。奶奶是一个典型的传统中国劳动妇女，她勤劳坚忍，和爷爷一起在那个贫乏的年代养活了他们的儿女，也正是因此落下了胃部疾病。她爱她的儿孙们，即使在她病重的时候，还会把家里人买给她好吃的零食分给她那傻傻的孙子吃。当时的我对于死亡还是麻木的，只知道一个疼我爱我的奶奶离开了，但是我却不怎么流泪。</p><p>十年后，在我大四即将本科毕业的时候，爷爷也去世了。我仍然记得，接到电话的时候，我正在艺园吃午饭，手机上刷到的是吴文俊院士去世的消息。从北京赶回武汉，协助爸妈打理接待，送爷爷的遗体火葬。</p><p>火葬那天下午六点，八大脚用豪华的寿衣将爷爷打扮好，旁边的人问爸爸，「这一套得好几千吧」。「老人生前没穿过这么好的衣服，走的时候希望他能享受一下」，爸爸答道。遗体抬出家门，姑姑们立即高声哭起来。八大脚将爷爷的遗体抬到灵车，我和爸爸一起坐在灵车最前面，前往火葬场。回家以后，我一直没哭过，觉得自己已经在内心接受了这件事情。然而，灵车发动，哀乐奏起，鞭炮响起，突然间抑制不住自己的眼泪。灵车缓缓地从村子里开出，沿路上村里的老人听到音乐，停在路边想这里张望。这样的一幕顿时让我想到了侯孝贤的电影。出来看的主要是老人，看着村里有一个老人走了，他们心里在想着什么呢？也许他们在心里默数，和他们一样大的还剩下哪些人，他们自己距离这件事还有多远，走的时候自己的儿孙们能否料理好自己？出了村，现在还在地里劳作的依然是上了年纪的人，他们停下自己手中的事情，向这边张望着。</p><p>回来的路上，田里的麦子开始熟了。家乡所在处早在那之前两年就被设置为拆迁区，武船正在积极建设，武汉国家航天基地的拆迁区也被标识了出来。在走向殡仪馆的路上，沿路黄色的麦子仿佛和以前没有什么不同，而拆迁的标识却告诉我，这里不久就将不复存在了。我看到，麦子熟了，而在麦地里，已经竖下了标语——「航天创造美好生活」。</p><hr><p>今天，那片麦田早已被繁忙建设的航天基地所取代，村里也马上就要拆迁，家里已经搬到了街道。在这次疫情中，家里人身体都安好，这算是难得的幸运吧。</p><p>你们保重，我们会好好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个非同寻常的清明节，如同汶川大地震那次的全国默哀一样，今天注定会成为所有国民的国家记忆。封面图是我特别喜欢的一个镜头，&lt;code&gt;20200404&lt;/code&gt;、清明、武汉、江汉关、降半旗，在 2020 年的伊始，根本没有人会将这几个词组合在一起。此刻才真正理解了生命无常，在历史、灾难、自然面前，人类是多么的弱小，所有之前的预设都推倒全来。&lt;/p&gt;
&lt;p&gt;这里是「朝花夕拾」第十二期，今天我们为他们哀悼，为我们逝去的先辈哀悼，为所有在新冠疫情斗争中牺牲的英烈，为在西昌凉州山火中牺牲的英烈哀悼，为已经逝去的伟大的中国人民哀悼。逝者已去，我们追思低首，缅怀往事；生者继续，我们看向未来，在磨难中不断前行。&lt;/p&gt;

    &lt;div id=&quot;aplayer-NFeYeqzr&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;1298843453&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-04_qingming.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="清明" scheme="http://houmin.cc/tags/%E6%B8%85%E6%98%8E/"/>
    
      <category term="死亡" scheme="http://houmin.cc/tags/%E6%AD%BB%E4%BA%A1/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu自动选择镜像源</title>
    <link href="http://houmin.cc/posts/63a566a0/"/>
    <id>http://houmin.cc/posts/63a566a0/</id>
    <published>2020-04-02T07:45:34.000Z</published>
    <updated>2020-07-14T08:24:44.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>众所周知，Ubuntu 使用官方源执行 <code>apt update</code> 等命令有时候会非常慢。国内有很多镜像服务，但是某些时候偶尔也会抽风，这就导致我们需要日常修改 apt 源。 apt 源是支持 <code>mirror</code> 协议的，从而自动选择可用的一个。</p><a id="more"></a><p>以下即是使用 mirror 协议后的 <code>/etc/apt/sources.list</code></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">###### Ubuntu Main Repos</span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">###### Ubuntu Update Repos</span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-security main restricted universe multiverse</span></span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-security main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb-src mirror:<span class="comment">//mirrors.ubuntu.com/mirrors.txt bionic-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>当使用 <code>mirror</code> 协议后，执行 <code>apt update</code> 时会首先<strong>通过 http 访问</strong> <code>mirrors.ubuntu.com/mirrors.txt</code> 文本；文本内容实际上就是<strong>本地</strong>当前可用的镜像源列表，如下所示</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.ustc.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.huaweicloud.com/repository/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.yun-idc.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.nju.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirror.lzu.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.sohu.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.cn99.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//ftp.sjtu.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.cqu.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.aliyun.com/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//mirrors.dgut.edu.cn/ubuntu/</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//archive.ubuntu.com/ubuntu/</span></span><br></pre></td></tr></table></figure><p>得到列表后 apt 会自动选择一个网速快的作为镜像源。</p><p>另外一种使用 mirror 协议的方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl -pi -e <span class="string">'s@^\s*(deb(\-src)?)\s+http://us.archive.*?\s+@\1 mirror://mirrors.ubuntu.com/mirrors.txt @g'</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>在命令行执行完上述命令后，<code>/etc/apt/sources.list</code>变为如下，说明其选择了阿里云作为源。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Ubuntu 使用官方源执行 &lt;code&gt;apt update&lt;/code&gt; 等命令有时候会非常慢。国内有很多镜像服务，但是某些时候偶尔也会抽风，这就导致我们需要日常修改 apt 源。 apt 源是支持 &lt;code&gt;mirror&lt;/code&gt; 协议的，从而自动选择可用的一个。&lt;/p&gt;
    
    </summary>
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="linux" scheme="http://houmin.cc/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://houmin.cc/tags/ubuntu/"/>
    
      <category term="mirror" scheme="http://houmin.cc/tags/mirror/"/>
    
  </entry>
  
  <entry>
    <title>流れ行く雲</title>
    <link href="http://houmin.cc/posts/d4ef9777/"/>
    <id>http://houmin.cc/posts/d4ef9777/</id>
    <published>2020-03-29T03:51:35.000Z</published>
    <updated>2020-07-14T08:24:44.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是武汉封城第六十七天，两个多月过去了，武汉现存的确诊数由当初的 5 万已经减少到了今天的 2045。武汉重启的时间表也已经提上日程，公交地铁开始恢复运营，武汉中欧班列携带防疫物资启程，城市里开始迎来了烟火气，4 月 8 日这座沉睡了两个多月的城市就要迎来解封。三月即将结束，武汉等到了春暖花开。</p><p>这里是「朝花夕拾」第十一期，这是一次难忘的春天，不知道以后还有没有机会在家里呆这么长的时间。享受当下，这一期，我们继续来看这美丽的家乡。</p>    <div id="aplayer-NPaoFMtB" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="441532" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="始"><a href="#始" class="headerlink" title="始"></a>始</h2><p><img alt="从街道出发，人们还是很谨慎的戴着口罩" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_rumor.jpg"></p><p><img alt="走到大堤边，江边的人家就地养鸡" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_chicken2.jpg"></p><p><img alt="一群鸡躲在坑里，似乎在抢什么东西吃" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_chicken1.jpg"></p><p><img alt="走上大堤，依稀过往的车辆，春天的油菜花，嫩绿的新草" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_levee.jpg"></p><h2 id="亭"><a href="#亭" class="headerlink" title="亭"></a>亭</h2><p><img alt="接着往前走，走到了小时候差点在丧命的一个亭子，这又是一个遥远的故事了" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_loft1.jpg"></p><p><img alt="对称" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_loft2.jpg"></p><p><img alt="走进去，可以看到远处的长江" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_loft4.jpg"></p><p><img alt="豁然开朗" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_loft3.jpg"></p><h2 id="花"><a href="#花" class="headerlink" title="花"></a>花</h2><p>一路上走走拍拍，看到了许多的花花草草。</p><p><img alt="蚕豆的花" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_flower1.jpg"></p><p><img alt="萝卜也开花啦" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_flower2.jpg"></p><p><img alt="不知道是什么花，好像是油菜花？" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_flower3.jpg"></p><p><img alt="人间四月芳菲尽，山寺桃花始盛开，还在三月，桃花已残" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_flower4.jpg"></p><h2 id="草"><a href="#草" class="headerlink" title="草"></a>草</h2><p><img alt="野火烧不尽，春风吹又生" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_grass2.jpg"></p><p><img alt="焦土下崭新的生命" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_grass3.jpg"></p><p><img alt="很常见却叫不出名字的藤蔓" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_leave6.jpg"></p><p><img alt="一片翠绿的草地" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_grass5.jpg"></p><h2 id="叶"><a href="#叶" class="headerlink" title="叶"></a>叶</h2><p><img alt="最常见的构树，我们这叫蔲树，已经长出了花果" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_leave2.jpg"></p><p><img alt="苦楝树，我们这里叫苦溜子树，小时候经常在这个树上捉到星天牛" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_leave3.jpg"></p><p><img alt="这也是我们这很常见的枫杨，也叫大叶柳，长大后会有长条状的果序" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_leave4.jpg"></p><p><img alt="嘿嘿，这个我最熟，桑树嘛，毕竟是小时候养过蚕的男人" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_leave5.jpg"></p><h2 id="江"><a href="#江" class="headerlink" title="江"></a>江</h2><p><img alt="长江上的大货轮" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_boat1.jpg"></p><p><img alt="家附近新建了一个大水厂，好像是在这里抽水" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_boat2.jpg"></p><p><img alt="来往长江两岸的轮渡" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_boat3.jpg"></p><p><img alt="一度停歇的打渔船" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_river-boat.jpg"></p><p><img alt="来来往往的拖沙船" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_cloud.jpg"></p><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p>之前在大理的时候拍过一次延时，那次完全不懂。今天简单学习了一下，还不是很熟悉，用的是 PR 制作的，Final Cut Pro 也试了试，不知道为什么时间轴总是没有设置正确。之后在专门学习下这几个软件，摸索出自己的工作流。</p><p>BGM 用的是岸部真明的「流れ行く雲」，和江边流动的烟，流动的云很搭。弹得很好听，以后要玩玩吉他🤔</p><iframe src="//player.bilibili.com/player.html?aid=100203108&bvid=BV1P7411D7k2&cid=170913370&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2><p><img alt="居家小三轮，嘻嘻" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_grass1.jpg"></p><p><img alt="不知从何来到这里的摩拜单车" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_mobike.jpg"></p><p><img alt="水天一色" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_water.jpg"></p><p><img alt="这次再出门，麦子已经开始灌浆了" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_grass4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是武汉封城第六十七天，两个多月过去了，武汉现存的确诊数由当初的 5 万已经减少到了今天的 2045。武汉重启的时间表也已经提上日程，公交地铁开始恢复运营，武汉中欧班列携带防疫物资启程，城市里开始迎来了烟火气，4 月 8 日这座沉睡了两个多月的城市就要迎来解封。三月即将结束，武汉等到了春暖花开。&lt;/p&gt;
&lt;p&gt;这里是「朝花夕拾」第十一期，这是一次难忘的春天，不知道以后还有没有机会在家里呆这么长的时间。享受当下，这一期，我们继续来看这美丽的家乡。&lt;/p&gt;

    &lt;div id=&quot;aplayer-NPaoFMtB&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;441532&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-28_cloud.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="春天" scheme="http://houmin.cc/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>理解 initramfs</title>
    <link href="http://houmin.cc/posts/7c0e6000/"/>
    <id>http://houmin.cc/posts/7c0e6000/</id>
    <published>2020-03-25T04:19:54.000Z</published>
    <updated>2020-07-14T08:24:44.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是 linux kernel <a href="../../tags/Documentation">Documentation</a> 阅读系列第一篇，在这个系列中，我会记录每一次阅读到的 linux 内核文档。这一篇阅读的是 <a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="external nofollow noopener noreferrer">ramfs, rootfs and initramfs</a>，主要是介绍 <code>initramfs</code>。</p><a id="more"></a><h2 id="What-is-ramfs"><a href="#What-is-ramfs" class="headerlink" title="What is ramfs?"></a>What is ramfs?</h2><p><code>ramfs</code>是 linux 中利用linux的<code>disk caching</code>机制（page cache 和 dentry cache）实现的可动态伸缩的基于RAM做存储的文件系统。</p><p>文件一般放在磁盘上，当需要对其读写的时候会将其加载到内存中。为了提高文件的读写效率，根据局部性原理，linux 基本上都会文件缓存到内存中。</p><ul><li>当文件的数据被 OS 从后端存储读取到内存的时候，因为这段数据可能之后会被用到，并不会被马上释放，这块数据将会被标记为 <code>clean</code>，就是说可以被释放掉。只有当 VM 系统需要用到这块内存做其他事情的时候，这些数据才会被释放掉。</li><li>当有数据写到文件后，这段数据也会被标记为 <code>clean</code>，但是仍然保存在内存中而不释放，以用作缓存的目的。只有当 VM 系统重新申请这块内存的时候，这段数据才会被释放掉。</li></ul><p>对于 <code>dentry cache</code>，linux 也有类似的机制，从而大大加快了对于目录的访问。</p><p>上述说的是我们常见文件系统的机制，对于 <code>ramfs</code>而言，这里根本没有所谓的后端存储。当你要向 <code>ramfs</code>写文件时，我们像原来一样，在内存上分配 <code>page cache</code>和<code>dentry cache</code>，但是这些 cache 不会被写到磁盘这些后端存储中 。所以，这些 cache根本不会被标记为 <code>clean</code>，而会一直存在于内存中，VM系统也无法回收他们的内存，重新分配做它用。</p><p>实现 <code>ramfs</code>需要的代码量非常的少，因为他们基本上就是依靠Linux现有的<code>caching infastructure</code>。对于用户而言，我们只是把一个 <code>disk cache</code>加载成文件系统。因此，<code>ramfs</code>就不是通过<code>menuconfig</code>可以被移去的可选模块，它底层的机制是 linux 所必须的。</p><p>下面做了一个简单的实验，这是当前系统能够看到的文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vagrant@cosmos:~$ df -a</span><br><span class="line">文件系统                   1K-块      已用     可用 已用% 挂载点</span><br><span class="line">sysfs                          0         0        0     - /sys</span><br><span class="line">proc                           0         0        0     - /proc</span><br><span class="line">udev                     1014960         0  1014960    0% /dev</span><br><span class="line">devpts                         0         0        0     - /dev/pts</span><br><span class="line">tmpfs                     204804      5784   199020    3% /run</span><br><span class="line">/dev/sda1               10098468   1978740  8103344   20% /</span><br><span class="line">tmpfs                    1024004         0  1024004    0% /dev/shm</span><br><span class="line">tmpfs                       5120         0     5120    0% /run/lock</span><br><span class="line">home_vagrant_workspace 244810132 199558164 45251968   82% /home/vagrant/workspace</span><br></pre></td></tr></table></figure><p>我们可以通过下列命令自己创建 <code>ramfs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vagrant@cosmos:~$ mkdir ramfs</span><br><span class="line">vagrant@cosmos:~$ sudo mount -t ramfs -o size=10M ramfs ./ramfs/</span><br><span class="line">vagrant@cosmos:~$ df -a</span><br><span class="line">文件系统                   1K-块      已用     可用 已用% 挂载点</span><br><span class="line">sysfs                          0         0        0     - /sys</span><br><span class="line">proc                           0         0        0     - /proc</span><br><span class="line">udev                     1014960         0  1014960    0% /dev</span><br><span class="line">devpts                         0         0        0     - /dev/pts</span><br><span class="line">tmpfs                     204804      5784   199020    3% /run</span><br><span class="line">/dev/sda1               10098468   1978740  8103344   20% /</span><br><span class="line">tmpfs                    1024004         0  1024004    0% /dev/shm</span><br><span class="line">tmpfs                       5120         0     5120    0% /run/lock</span><br><span class="line">home_vagrant_workspace 244810132 199558164 45251968   82% /home/vagrant/workspace</span><br><span class="line">ramfs                          0         0        0     - /home/vagrant/ramfs</span><br><span class="line">vagrant@cosmos:~$ ls -alh ramfs/</span><br><span class="line">总用量 21M</span><br><span class="line">drwxr-xr-x 2 root    root       0 3月  30 09:34 .</span><br><span class="line">drwxr-xr-x 7 vagrant vagrant 4.0K 3月  30 09:32 ..</span><br><span class="line">-rw-r--r-- 1 root    root     20M 3月  30 09:25 test.file</span><br></pre></td></tr></table></figure><h2 id="ramfs-and-ramdisk"><a href="#ramfs-and-ramdisk" class="headerlink" title="ramfs and ramdisk"></a>ramfs and ramdisk</h2><p><code>ramdisk</code>是比<code>ramfs</code>出现更早的机制，是利用 RAM 模拟生成一个块设备，以此作为文件系统的后端存储。这个块设备是固定大小的，所以它上面 mount 的文件系统也是固定大小的。和实际的块设备一样，我们需要把<code>page cache</code>从这块假的块设备复制到内存，然后把改变复制回去，对于 <code>dentry cache</code>也是一样。除此之外，它还需要文件系统驱动（比如 ext2）去格式化和解释这段数据。</p><p>相较于<code>ramfs</code>，<code>ramdisk</code>会浪费更多的内存，占用更多的内存总线带宽，给 CPU 带来更多的工作，并且污染 CPU 的 cache。相较而言，<code>ramfs</code>的实现机制更加简单和高效。</p><p><code>loopback devices</code>是导致 <code>ramdisk</code> 淘汰的另一个原因，它相对于<code>ramdisk</code>而言提供了一种更加灵活和方便的方式来创建块设备，现在是通过文件而不是通过内存。</p><h2 id="ramfs-and-tmpfs"><a href="#ramfs-and-tmpfs" class="headerlink" title="ramfs and tmpfs"></a>ramfs and tmpfs</h2><p><code>ramfs</code>的一个问题是，你可以一直往 <code>ramfs</code>里面写数据，直到你用完了所有的内存。而且 VM 系统也不能释放这段内存，因为 VM 认为这些数据应该被写到后端存储，而对于 <code>ramfs</code>而言他没有后端存储。因此，只有 root用户能够往 <code>ramfs</code>写数据。</p><p>为了解决上述问题，linux 内核开发者又发明了 <code>tmpfs</code>，给添加了大小的限制和普通用户写数据的权限。</p><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">tmpfs</th><th style="text-align:center">ramfs</th></tr></thead><tbody><tr><td style="text-align:center">达到空间上限时继续写入</td><td style="text-align:center">提示错误信息并终止</td><td style="text-align:center">可以继续写尚未分配的空间</td></tr><tr><td style="text-align:center">是否固定大小</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否使用swap</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">具有易失性</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table></div><h2 id="What-is-rootfs"><a href="#What-is-rootfs" class="headerlink" title="What is rootfs?"></a>What is rootfs?</h2><p><code>rootfs</code>是<code>ramfs</code>或者<code>tmpfs</code>的一种特殊实例，根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载（mount）所必要的文件。例如：</p><ul><li>init进程的应用程序必须运行在根文件系统上</li><li>根文件系统提供了根目录“/”</li><li>linux挂载分区时所依赖的信息存放于根文件系统/etc/fstab这个文件中</li><li>shell命令程序必须运行在根文件系统上，譬如ls、cd等命令</li></ul><p>一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin /sbin等目录下的shell命令，还有/lib目录下的库文件等···）相配合才能工作。</p><p>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。成功之后可以自动或手动挂载其他的文件系统。</p><p>下面是 linux 的内核代码。rootfs是基于内存的文件系统，所有操作都在内存中完成；也没有实际的存储设备，所以不需要设备驱动程序的参与。基于以上原因，linux在启动阶段使用rootfs文件系统，当磁盘驱动程序和磁盘文件系统成功加载后，linux系统会将系统根目录从rootfs切换到磁盘文件系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init/main.c-&gt;</span><br><span class="line">  start_kernel()-&gt;</span><br><span class="line">  vfs_caches_init(totalram_pages)–&gt;</span><br><span class="line">  mnt_init()–&gt;</span><br><span class="line">　　　　　<span class="comment">/* sysfs用来记录和展示linux驱动模型，sysfs先于rootfs挂载是为全面展示linux驱动模型做好准备 */</span></span><br><span class="line">　　　　　sysfs_init();</span><br><span class="line">　　　　　<span class="comment">/* mnt_init()调用sysfs_init()注册并挂载sysfs文件系统，然后调用kobject_create_and_add()创建fs目录 */</span></span><br><span class="line">fs_kobj = kobject_create_and_add(<span class="string">"fs"</span>, <span class="literal">NULL</span>);</span><br><span class="line">　　　　　<span class="comment">/* init_rootfs()注册rootfs，然后调用init_mount_tree()挂载rootfs */</span></span><br><span class="line">　　　　　init_rootfs();</span><br><span class="line">　　　　　init_mount_tree();</span><br></pre></td></tr></table></figure><p>下面是 <code>init_rootfs</code>的代码，可以看到，如果 <code>CONFIG_TMPFS</code>开启，rootfs 将会默认使用 <code>tmpfs</code>，否则使用 <code>ramfs</code>。</p><figure class="highlight c"><figcaption><span>init/do_mounts.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">init_rootfs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err = register_filesystem(&amp;rootfs_fs_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; !saved_root_name[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">(!root_fs_names || <span class="built_in">strstr</span>(root_fs_names, <span class="string">"tmpfs"</span>))) &#123;</span><br><span class="line">err = shmem_init();</span><br><span class="line">is_tmpfs = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = init_ramfs_fs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">unregister_filesystem(&amp;rootfs_fs_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="What-is-initramfs"><a href="#What-is-initramfs" class="headerlink" title="What is initramfs?"></a>What is initramfs?</h2><p>initramfs是一种ramfs文件系统，在内核启动完成后把它复制到rootfs中，作为内核初始的根文件系统，它的任务是挂载系统真正的根文件系统。所有的 2.6 版本的 linux 内核都包含一个gzip 压缩过的 cpio 存档，在kernel 启动的时候，将会将其解压成 <code>rootfs</code>。解压之后，内核将会检查 rootfs 是否有一个 <code>init</code>文件，如果有的话，将会执行 <code>init</code>程序作为 PID 为 1 的进程。在这之后，<code>init</code>进程将会负责其启动整个系统，包括找到并加载真正的根设备。</p><p>相对于老的 <code>initrd</code>机制，<code>initramfs</code>有以下几点区别：</p><ul><li>老的 <code>initrd</code>总是一个独立的文件，而<code>initramfs</code>存档是被链接到内核镜像中去的</li><li>老的 <code>initrd</code>文件是一个 gzip 压缩过的文件系统镜像，新的 <code>initramfs</code>是 gzip 压缩过的 cpio存档，相对而言更简单</li><li>以往的基于ramdisk 的initrd 使用pivot_root命令切换到新的根文件系统，然后卸载ramdisk。但是initramfs是rootfs，而rootfs既不能pivot_root，也不能umount。为了从initramfs中切换到新根文件系统，需要作如下处理：<ul><li>删除rootfs的全部内容，释放空间<br><code>find -xdev / -exec rm &#39;{}&#39; &#39;;&#39;</code></li><li>安装新的根文件系统，并切换<br><code>cd /newmount; mount --move . /; chroot .</code></li><li>把stdin/stdout/stderr 附加到新的/dev/console，然后执行新文件系统的init程序</li></ul></li></ul><p>上述步骤比较麻烦，而且要解决一个重要的问题：第一步删除rootfs的所有内容也删除了所有的命令，那么后续如何再使用这些命令完成其他步骤？busybox的解决方案是，提供了switch_root命令，完成全部的处理过程，使用起来非常方便。</p><p><code>switch_root</code>命令的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ switch_root [options] &lt;newrootdir&gt; &lt;init&gt; &lt;args to init&gt;</span><br></pre></td></tr></table></figure><ul><li><code>newrootdir</code>是实际的根文件系统的挂载目录，执行switch_root命令前需要挂载到系统中</li><li>init<code>是实际根文件系统的init程序的路径，一般是/sbin/init；</code></li><li>args to init`则是传递给实际的根文件系统的init程序的参数，也是可选的。</li></ul><p><strong>需要特别注意的是</strong>：switch_root命令必须由PID=1的进程调用，也就是必须由initramfs的init程序直接调用，不能由init派生的其他进程调用，否则会出错，提示：<code>switch_root: not rootfs</code>。也是同样的原因，init脚本调用switch_root命令必须用exec命令调用，否则也会出错，提示：<code>switch_root: not rootfs</code></p><h2 id="Contents-of-initramfs"><a href="#Contents-of-initramfs" class="headerlink" title="Contents of initramfs"></a>Contents of initramfs</h2><blockquote><p>An initramfs archive is a complete self-contained root filesystem for Linux.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; hello.c &lt;&lt; EOF</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">  sleep(999999999);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ gcc -static hello.c -o init</span><br><span class="line">$ <span class="built_in">echo</span> init | cpio -o -H newc | gzip &gt; test.cpio.gz</span><br><span class="line"><span class="comment"># Testing external initramfs using the initrd loading mechanism.</span></span><br><span class="line">$ qemu -kernel /boot/vmlinuz -initrd test.cpio.gz /dev/zero</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="external nofollow noopener noreferrer">https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是 linux kernel &lt;a href=&quot;../../tags/Documentation&quot;&gt;Documentation&lt;/a&gt; 阅读系列第一篇，在这个系列中，我会记录每一次阅读到的 linux 内核文档。这一篇阅读的是 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;ramfs, rootfs and initramfs&lt;/a&gt;，主要是介绍 &lt;code&gt;initramfs&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="linux" scheme="http://houmin.cc/tags/linux/"/>
    
      <category term="kernel" scheme="http://houmin.cc/tags/kernel/"/>
    
      <category term="Documentation" scheme="http://houmin.cc/tags/Documentation/"/>
    
      <category term="ramfs" scheme="http://houmin.cc/tags/ramfs/"/>
    
      <category term="rootfs" scheme="http://houmin.cc/tags/rootfs/"/>
    
      <category term="initramfs" scheme="http://houmin.cc/tags/initramfs/"/>
    
  </entry>
  
  <entry>
    <title>Linux启动过程</title>
    <link href="http://houmin.cc/posts/e27e5d75/"/>
    <id>http://houmin.cc/posts/e27e5d75/</id>
    <published>2020-03-24T04:17:40.000Z</published>
    <updated>2020-07-14T08:24:44.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文介绍了 Linux 启动的整个过程。</p><p><img alt="Linux Startup Process" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_linux-startup-process.svg"></p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>总的来说我们可以把 Linux 系统启动的过程分为下面几个阶段：</p><ul><li>ROM Stage<ul><li>在这个阶段没有内存，需要在ROM上运行代码。这时因为没有内存，没有C语言运行需要的栈空间，开始往往是汇编语言，直接在ROM空间上运行。在找到个临时空间（Cache空间用作RAM，Cache As Ram, CAR）后，C语言终于可以粉墨登场了，后期用C语言初始化内存和为这个目的需要做的一切服务。</li></ul></li><li>RAM Stage<ul><li>经过 ROM阶段的困难情况后，我们终于有了可以大展拳脚的内存，很多额外需要大内存的东西可以开始运行了。在这时我们开始进行初始化芯片组、CPU、主板模块等等核心过程。</li></ul></li><li>Find Something To Boot Stage<ul><li>终于要进入正题了，需要启动，我们找到启动设备。就要枚举设备，发现启动设备，并把启动设备之前需要依赖的节点统统打通。然后开始移交工作，Windows或者Linux的时代开始。</li></ul></li></ul><p>具体来说，</p><ul><li>在 ROM/RAM Stage，运行的代码我们一般称作固件，也就是 Firmware，最早是 BIOS，现在 UEFI 应用越来越广泛。</li><li>固件初始化执行完毕后，Firmware 会将控制权交给 <code>boot loader</code>，最常见的是 GRUB。</li><li><code>boot loader</code>之后会将OS内核加载进内存，开始进入操作系统。</li><li>OS 一般通过一个 init 进程启动所有的进程，最开始用的是 <code>SysVinit</code>，现在 <code>Systemd</code>应用越来越广泛。</li></ul><h2 id="Firmware"><a href="#Firmware" class="headerlink" title="Firmware"></a>Firmware</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>BIOS， <code>Basic Input-Output System</code></p><p>BIOS 是一组固化在计算机主板ROM里的程序代码，其主要功能是在计算机上电时对硬件进行初始化配置，并将硬件操作封装为BIOS中断服务。这样，各种硬件间的差异便由BIOS负责维护，程序直接调用BIOS中断服务即可实现对硬件的控制。</p><p><img alt data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Elitegroup_761GX-M754_-_AMIBIOS_%28American_Megatrends%29_in_a_Winbond_W39V040APZ-5491.jpg/1600px-Elitegroup_761GX-M754_-_AMIBIOS_%28American_Megatrends%29_in_a_Winbond_W39V040APZ-5491.jpg"></p><p>在系统上电后，CPU运行于<strong>实模式</strong>工作环境中，数据位宽为16位，最大物理地址寻址范围是0~1MB，其中的物理地址0x0C0000~0x0FFFFF保留给BIOS使用。开机后，CPU硬件逻辑设计为在加电瞬间强行将CS值置为0XF000，IP为0XFFF0，这样CS:IP就指向<strong>0XFFFF0</strong>这个位置，这个位置正是BIOS程序的入口地址。一般情况下，这里是一条跳转指令，CPU通过执行此处的跳转指令跳转到真正的BIOS入口地址处执行，以下是BIOS的启动流程：</p><p><img alt="BIOS Boot Process" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_bios-boot-process.png"></p><h4 id="加电自检"><a href="#加电自检" class="headerlink" title="加电自检"></a>加电自检</h4><p>BIOS代码首先做的是<strong>POST</strong>（Power On Self Test，<strong>加电自检</strong>）操作，主要是检测关键设备是否正常工作，设备设置是否与CMOS中的设置一致。如果发现硬件错误，则通过喇叭报警；如果没有问题，屏幕就会显示出CPU、内存等信息。</p><p><img alt="BIOS POST" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_bios-post.png"></p><h4 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h4><p>BIOS的第二步动作就是<strong>枚举本地设备并初始化</strong>。</p><p>有一项对启动操作系统至关重要的工作，那就是<strong>BIOS在内存中建立中断向量表和中断服务程序</strong>。</p><p>BIOS程序在内存最开始的位置（0x00000）用1KB的内存空间（0x00000~0x003FF）构建中断向量表，在紧挨着它的位置用256KB的内存空间构建BIOS数据区（0x00400~0x004FF），并在大约57KB以后得位置（0x0e05b）加载了8KB左右的与中断向量表相应的若干中断服务程序。</p><p>中断向量表有256个中断向量，每个中断向量占4个字节，其中两个字节是CS值，两个字节是IP值。每个中断向量都指向一个具体的中断服务程序。</p><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p><p>这时，BIOS需要知道「下一阶段的启动程序」具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p><p>打开BIOS的操作界面，里面有一项就是<code>设定启动顺序</code>。</p><p><img alt="BIOS Boot Sequence" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_bios-boot-order.png"></p><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</p><div class="note info">            <p>CMOS又被称作互补金属氧化物半导体，电压控制的一种放大器件，是组成CMOS数字集成电路的基本单元。在计算机领域，CMOS常指保存计算机基本启动信息（如日期、时间、启动设置等）的位于微机主板上的一块<strong>可读写RAM芯片</strong>。在今日，CMOS制造工艺也被应用于制作数码影像器材的感光元件，尤其是片幅规格较大的单反数码相机。</p><p>CMOS主要用来保存当前系统的硬件配置和操作人员对某些参数的设定，CMOS RAM芯片由系统通过<strong>后备电池</strong>供电，在关机状态中，还是遇到系统掉电，<strong>CMOS信息不会丢失</strong>。</p>          </div><p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p><p>这最前面的512个字节，就叫做<a href="http://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="external nofollow noopener noreferrer">“主引导记录”</a>（Master boot record，缩写为<code>MBR</code>）。</p><p><img alt="MBR Structure" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_bios-mbr.png"></p><p>MBR 只有 512 字节，由以下三个部分组成：</p><ul><li>Bootstrap Code Area，前 446 字节，它里面就包含有可执行代码以及错误消息文本。</li><li>Partition Table，接下来的64字节，其中包含有四个分区的各自的记录（一个分区占16字节）。</li><li>Boot Signature，最后两个字节，0x55AA</li></ul><p>简单来说，MBR 从 BIOS 获得控制权之后，主要做的事情就是寻找并加载 <code>boot loader</code>。MBR 的前 446 字节包含某个启动引导器，像 <a href="https://wiki.archlinux.org/index.php/GRUB_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">GRUB</a>) 、<a href="https://wiki.archlinux.org/index.php/Syslinux_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">Syslinux</a>) 和 <a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external nofollow noopener noreferrer">LILO</a> 之类的第一启动阶段代码。</p><p>MBR 接管后，执行它之后的第二阶段代码，如果后者存在的话，它一般就是Boot Loader。在这之后，我们就进入了 <code>Boot Loader Phase</code>。</p><h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>UEFI，<code>Unified Extensible Firmware Interface</code>，前身是EFI规范1.10。UEFI规范描述了<strong>操作系统</strong>和<strong>平台固件</strong>之间的接口，其目的是为操作系统和平台固件定义一种通信方法。</p><p>UEFI规范仅提供<strong>操作系统引导过程</strong>所需的信息，旨在无需对平台或操作系统进行深入定制便可在处理器规范兼容的平台上运行操作系统。UEFI规范还允许平台引入创新的特性和功能，在<strong>无需为OS引导程序重新编程的情况下增强平台功能</strong>。UEFI规范适用于从移动系统到服务器的各种硬件平台，并允许原始设备制造商具有最大的<strong>扩展性和定制能力</strong>，以实现差异化。</p><p>UEFI接口的表现形式是<strong>数据表</strong>，其中包括<strong>与平台相关的信息</strong>，以及<strong>操作系统加载器</strong>和<strong>操作系统可使用的引导服务</strong>和<strong>运行时服务</strong>。它们一起为启动操作系统提供了一个<strong>标准环境</strong>。UEFI规范设计为纯接口规范。因此，UEFI规范定义了平台固件必须实现的一组接口和结构。</p><p>以下是UEFI设计的基本要素：</p><ul><li><strong>重用现有接口表</strong>。为了让操作系统和固件中的代码可以在现有设计结构中持续使用。凡是兼容UEFI规范的处理器平台都必须遵照UEFI规范进行实现。</li><li><strong>系统分区</strong>。系统分区定义了一个独立的、可共享的分区和文件系统，这个系统分区可允许多个供应商之间安全共享数据，即使这些供应商出于不同目的去访问系统分区。</li><li><strong>引导服务</strong>。引导服务提供了在启动期间可以使用的设备和系统功能的接口。设备的访问是通过句柄（Handle）和协议（Protocol）抽象出来的。UEFI通过将基础实现隔离在规范之外，以避免给设备的访问者带来负担，进而促进现有BIOS代码的重用。</li><li><strong>运行时服务</strong>。运行时服务为操作系统提供了正常运行期间可以使用的基础平台硬件资源的接口。</li></ul><p>UEFI 不仅能读取分区表，还能自动支持文件系统。所以它不像 BIOS，已经没有仅仅 440 字节可执行代码即 MBR 的限制了，它完全用不到 MBR。</p><p>不管第一块上有没有 MBR，UEFI 都不会执行它。相反，它依赖分区表上的一个特殊分区，叫 EFI 系统分区，里面有 UEFI 所要用到的一些文件。计算机供应商可以在 <code>/EFI//</code> 文件夹里放官方指定的文件，还能用固件或它的 shell，即 UEFI shell，来启动引导程序。EFI 系统分区一般被格式化成 FAT32，或比较非主流的 FAT16。</p><p><img alt data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_uefi-platform-overview.png"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>系统开机 - 上电自检（Power On Self Test 或 POST）。</span><br><span class="line"><span class="bullet">- </span>UEFI 固件被加载，并由它初始化启动要用的硬件。</span><br><span class="line"><span class="bullet">- </span>固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个 UEFI 应用。</span><br><span class="line"><span class="bullet">- </span>固件按照引导管理器中的启动项目，加载UEFI 应用。</span><br><span class="line"><span class="bullet">- </span>已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况）或者启动内核及initramfs（对应于GRUB之类引导器的情况），这取决于 UEFI 应用的配置。</span><br></pre></td></tr></table></figure><p><img alt="UEFI Platform Initilization Boot Process" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_uefi-pi-boot-process.jpg"></p><h4 id="Security-Phase"><a href="#Security-Phase" class="headerlink" title="Security Phase"></a>Security Phase</h4><p>验证阶段 （Security，SEC）</p><p>系统上电后，CPU开始执行第一条指令，此时系统就进入SEC阶段。这个阶段的内存尚未被初始化，不可使用。所以，SEC阶段最主要的工作是建立一些临时内存并将CPU切换到保护模式，这里提到的临时内存可以是处理器的缓存，亦或者系统的物理内存。</p><h4 id="Pre-EFI-Initailization-Phase"><a href="#Pre-EFI-Initailization-Phase" class="headerlink" title="Pre-EFI Initailization Phase"></a>Pre-EFI Initailization Phase</h4><p>EFI环境预初始化阶段（Pre-EFI Initialization Environment，PEI）</p><p>PEI阶段最主要的工作就是对内存、CPU以及芯片组等关键设备进行初始化。由于这部分代码没有进行压缩，因此代码必须越精简越好。而且，在PEI阶段还要确定操作系统的引导路径，初始化UEFI驱动和固件需要的内存。</p><h4 id="Driver-eXecution-Environment-Phase"><a href="#Driver-eXecution-Environment-Phase" class="headerlink" title="Driver eXecution Environment Phase"></a>Driver eXecution Environment Phase</h4><p>驱动运行环境阶段（Driver Execution Environment，DXE）</p><p>DXE是EFI最重要的阶段，大部分的驱动、固件加载工作都是在这个阶段完成的。</p><h4 id="Boot-Device-Selection-Phase"><a href="#Boot-Device-Selection-Phase" class="headerlink" title="Boot Device Selection Phase"></a>Boot Device Selection Phase</h4><p>引导设备选择阶段（Boot Device Select，BDS）</p><p>BDS阶段的主要工作是初始化控制台设备的环境变量，尝试加载环境变量列表中记录的驱动，并尝试从环境变量列表中记录的启动设备中启动。</p><h4 id="Transient-System-Load-Phase"><a href="#Transient-System-Load-Phase" class="headerlink" title="Transient System Load Phase"></a>Transient System Load Phase</h4><p>临时系统运行阶段（Transient System Load，TSL）</p><p>这个阶段将进入UEFI的临时Shell系统环境。</p><h4 id="Run-Time-Phase"><a href="#Run-Time-Phase" class="headerlink" title="Run Time Phase"></a>Run Time Phase</h4><p>运行时阶段（RunTime，RT）</p><p>当操作系统调用 <code>EFI_BOOT_SERVICES.ExitBootServices</code> 服务后，系统进入RT阶段。此时，DXE与引导服务都将销毁，只有EFI运行时服务和EFI系统表可以继续使用。</p><h4 id="After-Life-Phase"><a href="#After-Life-Phase" class="headerlink" title="After Life Phase"></a>After Life Phase</h4><p>后世阶段（After Life，AL）</p><p>当操作系统调用 <code>EFI_RUNTIME_SERVICES.ResetSystem</code> 服务或者调用<code>ACPI Sleep State</code>，系统进入AL阶段。触发异步事件（比如：SMI、NMI）亦可使系统进入AL阶段，这在服务器和工作站中比较常见。</p><h3 id="UEFI-VS-BIOS"><a href="#UEFI-VS-BIOS" class="headerlink" title="UEFI VS BIOS"></a>UEFI VS BIOS</h3><ul><li><p>开发效率</p><ul><li>BIOS开发一般采用汇编语言，代码大多与硬件控制相关。</li><li>在UEFI中，绝大部分代码采用C语言编写，UEFI应用程序和驱动甚至可以使用C++编写。UEFI通过固件-操作系统接口（引导服务和运行时服务）为操作系统和操作系统加载器屏蔽了底层硬件细节，使得UEFI上层应用可以方便重用。</li></ul></li><li><p>可扩展性</p><p>大部分硬件的初始化通过UEFI驱动实现。每个驱动是一个独立的模块，可以包含在固件中，也可以放在设备上，运行时根据需要动态加载。UEFI中的每个表和协议（包括驱动）都有版本号，这使得系统升级过程更加简单、平滑。</p><p>UEFI系统的可扩展性体现在两个方面</p><ul><li>一是驱动的模块化设计</li><li>二是软硬件升级的兼容性</li></ul></li><li><p>性能</p><p>相比BIOS，UEFI有了很大的性能提升，从启动到进入操作系统的时间大大缩短。性能的提高源于以下几个方面：</p><ul><li>UEFI提供了<strong>异步操作</strong>。基于事件的异步操作，提高了CPU利用率，减少了总的等待时间。</li><li>UEFI舍弃了中断这种比较耗时的操作外部设备的方式，仅仅保留了时钟中断。外部设备的操作采用“事件+异步操作”完成。</li><li>可伸缩的设备遍历方式，启动时可以仅仅遍历启动所需的设备，进而加速系统启动。</li></ul></li><li><p>安全性</p><p>UEFI的一个重要突破就是其安全方面的考虑。当系统的安全启动功能被打开后，UEFI在执行应用程序和驱动前会先检测程序和驱动的证书，仅当证书被信任时才会执行这个应用程序或驱动。UEFI应用程序和驱动采用PE/COFF格式，其签名放在签名块中。</p></li></ul><h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p><code>bootloader</code>是 <a href="https://en.wikipedia.org/wiki/BIOS" target="_blank" rel="external nofollow noopener noreferrer">BIOS</a> 或 <a href="https://wiki.archlinux.org/index.php/UEFI" target="_blank" rel="external nofollow noopener noreferrer">UEFI</a> 启动的第一个程序。它负责使用正确的 <a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="external nofollow noopener noreferrer">内核参数</a> 加载内核, 并根据配置文件加载 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio" target="_blank" rel="external nofollow noopener noreferrer">初始化 RAM disk</a>。对于 UEFI，内核本身可以由 UEFI 使用 EFI boot stub 直接启动，也可以使用单独的引导加载程序或引导管理器来在引导之前编辑内核参数。</p><p>在 Linux 中，GRUB是最常用的一个<code>boot loader</code>。在 <code>/boot</code>目录下，我们可以看到，除了内核的四个文件，另外就是<code>grub</code>的相关文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vagrant@cosmos:/boot$ tree -L 2</span><br><span class="line">.</span><br><span class="line">├── config-4.4.0-140-generic</span><br><span class="line">├── grub</span><br><span class="line">│   ├── default</span><br><span class="line">│   ├── fonts</span><br><span class="line">│   ├── gfxblacklist.txt</span><br><span class="line">│   ├── grub.cfg</span><br><span class="line">│   ├── grubenv</span><br><span class="line">│   ├── i386-pc</span><br><span class="line">│   ├── locale</span><br><span class="line">│   ├── menu.lst</span><br><span class="line">│   └── unicode.pf2</span><br><span class="line">├── initrd.img-4.4.0-140-generic</span><br><span class="line">├── System.map-4.4.0-140-generic</span><br><span class="line">└── vmlinuz-4.4.0-140-generic</span><br></pre></td></tr></table></figure><p>在这里，内核的四个文件解释如下：</p><ul><li>vmlinuz<ul><li>vmlinuz是可引导的、压缩的内核。“vm”代表“Virtual Memory”。</li><li>vmlinuz的建立有两种方式。<ul><li>zImage<ul><li>编译内核时执行<code>make zImage</code></li><li>然后通过：<code>cp /usr/src/linux-2.4/arch/i386/linux/boot/zImage /boot/vmlinuz</code>产生</li><li>zImage适用于小内核的情况，它的存在是为了向后的兼容性。</li></ul></li><li>bzImage<ul><li>内核编译时执行<code>make bzImage</code></li><li>然后通过：<code>cp /usr/src/linux-2.4/arch/i386/linux/boot/bzImage /boot/vmlinuz</code>产生</li><li>bzImage是压缩的内核映像，需要注意，bzImage不是用bzip2压缩的，bzImage中的bz容易引起误解，bz表示<code>big zImage</code>。</li></ul></li><li>zImage和bzImage都是用gzip压缩的。它们不仅是一个压缩文件，而且在这两个文件的开头部分内嵌有gzip解压缩代码。所以你不能用gunzip 或 gzip –dc解包vmlinuz。</li><li>内核文件中包含一个微型的gzip用于解压缩内核并引导它。两者的不同之处在于，老的zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么可以采用zImage 或bzImage之一，两种方式引导的系统运行时是相同的。大的内核采用bzImage，不能采用zImage。</li><li>vmlinux是未压缩的内核，vmlinuz是vmlinux的压缩文件。</li></ul></li></ul></li><li>initrd.img<ul><li>initrd是<code>initial ramdisk</code>的简写，值得是一个临时文件系统，它在启动阶段被内核调用。</li><li><code>initrd</code>和<code>initramfs</code>是实现的两种技术。<ul><li>initrd 是kernel 2.4 及更早的用法</li><li>initramfs 是kernel 2.6的技术，现在看到的 initrd文件基本上都是initramfs 了。启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs 的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。</li></ul></li><li>Initrd是在实际根文件系统可用之前挂载到系统中的一个<strong>初始根文件系统</strong>。initrd 与内核绑定在一起，并作为内核引导过程的一部分进行加载。内核然后会将这个 initrd 文件作为其两阶段引导过程的一部分来加载模块，这样才能稍后使用真正的文件系统，并挂载实际的根文件系统。</li><li>initrd 中包含了实现这个目标所需要的目录和可执行程序的最小集合，例如将内核模块加载到内核中所使用的 insmod 工具。在桌面或服务器 Linux 系统中，initrd 是一个临时的文件系统。其生存周期很短，只会用作到真实文件系统的一个桥梁。在没有存储设备的嵌入式系统中，initrd 是永久的根文件系统。</li></ul></li><li>System.map<ul><li>System.map 内核符号映射表，顾名思义就是将内核中的符号（也就是内核中的函数）和它的地址能联系起来的一个列表。是所有符号及其对应地址的一个列表。之所以这样就使为了用户编程方便，直接使用函数符号就可以了，而不用去记要使用函数的地址。当你编译一个新内核时，原来的System.map中的符号信息就不正确了。随着每次内核的编译，就会产生一个新的 System.map文件，并且需要用该文件取代原来的文件。System.map是一个特定内核的内核符号表。它是你当前运行的内核的System.map的链接。</li></ul></li><li>config<ul><li>内核编译时的配置选项。</li></ul></li></ul><p>下面是一个典型的 <code>grub.cfg</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shutdown menu</span></span><br><span class="line">menuentry <span class="string">"System shutdown"</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"System shutting down..."</span></span><br><span class="line">halt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># restart menu</span></span><br><span class="line">menuentry <span class="string">"System restart"</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"System rebooting..."</span></span><br><span class="line">reboot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># UEFI shell</span></span><br><span class="line">menuentry <span class="string">"UEFI Shell"</span> &#123;</span><br><span class="line">insmod fat</span><br><span class="line">insmod chain</span><br><span class="line">search <span class="params">--no-floppy</span> <span class="params">--set=root</span> <span class="params">--file</span> <span class="string">/shellx64.efi</span></span><br><span class="line">chainloader <span class="string">/shellx64.efi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux boot menu</span></span><br><span class="line">menuentry <span class="string">"Linux"</span> &#123;</span><br><span class="line"><span class="keyword">set</span> root=<span class="params">(hd0,1)</span></span><br><span class="line">linux <span class="string">/boot/vmlinuz</span> <span class="params">(add other options here as required)</span></span><br><span class="line">initrd <span class="string">/boot/initrd.img</span> <span class="params">(if the other kernel uses/needs one)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Linux内核处理所有操作系统进程，如内存管理、任务调度、I/O、进程间通信和系统总体控制。</p><p>在 <code>bootloader</code>加载 kernel 和可用的 initramfs 文件，并执行 kernel 之后，kernel 将 initramfs（初始RAM文件系统）压缩包解压缩到（然后清空）rootfs（初始根文件系统，特别是ramfs或tmpfs）。首先提取的 initramfs 是在 kernel 构建过程中嵌入 kernel 二进制Update translation.的 initramfs，然后提取可用的外部 initramfs 文件。因此，外部 initramfs 中的文件会覆盖嵌入式 initramfs 中具有相同名称的文件。然后， kernel 执行 <code>/init</code> （在rootfs中）作为第一个进程。<em>early userspace</em>开始。</p><p>initramfs 之所以存在，是为了帮系统访问真正的根文件系统（参见 <a href="https://wiki.archlinux.org/index.php/Arch_filesystem_hierarchy_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">Arch filesystem hierarchy (简体中文)</a>)）。也就是说，那些硬件 IDE, SCSI, SATA, USB/FW 所要求的 kernel 模块，如果并没有内置在 kernel 里，就会被 initramfs 负责加载。一旦通过 <a href="https://wiki.archlinux.org/index.php/Udev_(简体中文" target="_blank" rel="external nofollow noopener noreferrer">udev (简体中文)</a>) 之类的程序或脚本加载好模块，启动流程才会继续下去。所以，initramfs 只要有能够让系统访问真实根文件系统的模块就可以了，不用尽可能地包含一切模块。当然，其它真正有用的模块之后会在 init 流程中被 udev 加载好。</p><h2 id="Init-Process"><a href="#Init-Process" class="headerlink" title="Init Process"></a>Init Process</h2><p>在「早期用户空间」的最终环节里，<strong>真正</strong>的根文件系统被挂载好后，就会替换掉原来的<strong>伪</strong>根文件系统。接着 <code>/sbin/init</code> 被执行，同样也替换掉原来的 <code>/init</code> 进程。</p><h3 id="SysVinit"><a href="#SysVinit" class="headerlink" title="SysVinit"></a>SysVinit</h3><p>1983 年以来，System V 便是 Unix 和类 Unix （例如 Linux）系统中的经典启动过程。它包括小程序 init 用于 启动诸如 login （由 getty 启动）这样的基础程序，并运行着名为 rc 的脚本。该脚本，控制着一众附加脚本的 执行，而那些附加脚本便是实施系统初始化所需要的任务的脚本。 </p><p>程序 init 由文件 /etc/inittab 控制着，并且被组织成用户能够运行的运行级别形式：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>— 停止</span><br><span class="line"><span class="symbol">1 </span>— 单用户模式</span><br><span class="line"><span class="symbol">2 </span>— 多用户，无网络</span><br><span class="line"><span class="symbol">3 </span>— 完整的多用户模式</span><br><span class="line"><span class="symbol">4 </span>— 用户可定义</span><br><span class="line"><span class="symbol">5 </span>— 完整的多用户模式，附带显示管理</span><br><span class="line"><span class="symbol">6 </span>— 重启</span><br></pre></td></tr></table></figure><p>常用的默认运行级为 3 或 5。 </p><ul><li>启动时间长，init是串行启动，只有前一个进程启动完，才会启动下一个进程</li><li>启动脚本复杂，Init进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况，这往往使得脚本变得很长</li><li>由Linux内核加载运行，位于 <code>/sbin/init</code>   ,是系统中第一个进程，PID永远为1</li></ul><h3 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h3><ul><li>按需启动服务，减少系统资源消耗。</li><li>尽可能并行启动进程，减少系统启动等待时间</li><li>由Linx内核加载运行，位于 <code>/usr/lib/systemd/systemd</code> ，是系统中第一个进程，PID永远为1</li></ul><h3 id="命令对比"><a href="#命令对比" class="headerlink" title="命令对比"></a>命令对比</h3><div class="table-container"><table><thead><tr><th>动作</th><th style="text-align:left">SystemV</th><th style="text-align:left">Systemd</th></tr></thead><tbody><tr><td>停止某服务</td><td style="text-align:left">service httpd stop</td><td style="text-align:left">systemctl stop httpd</td></tr><tr><td>重启某服务</td><td style="text-align:left">service httpd restart</td><td style="text-align:left">systemctl restart httpd</td></tr><tr><td>检查服务状态</td><td style="text-align:left">service httpd status</td><td style="text-align:left">systemctl status httpd</td></tr><tr><td>删除某服务</td><td style="text-align:left">chkconfig —del  httpd</td><td style="text-align:left">停掉应用，删除其配置文件</td></tr><tr><td>使服务开机自启动</td><td style="text-align:left">chkconfig —level 5 httpd on</td><td style="text-align:left">systemctl enable httpd</td></tr><tr><td>使服务开机不自启动</td><td style="text-align:left">chkconfig —level 5 httpd off</td><td style="text-align:left">systemctl disable httpd</td></tr><tr><td>显示所有已启动的服务</td><td style="text-align:left">chkconfig —list</td><td style="text-align:left">systemctl list-unit-files</td></tr><tr><td>加入自定义服务</td><td style="text-align:left">chkconfig —add  test</td><td style="text-align:left">systemctl load test</td></tr></tbody></table></div><h2 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h2><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录　</li></ul><p>这三种情况，都有自己的方式对用户进行认证。</p><ul><li>命令行登录：init进程调用getty程序（意为get teletype），让用户输入用户名和密码。输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序/etc/pam.d/login）。如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。</li><li>ssh登录：这时系统调用sshd程序（Debian还会再运行/etc/pam.d/ssh ），取代getty和login，然后启动shell。</li><li>图形界面登录：init进程调用显示管理器，Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Arch_boot_process" target="_blank" rel="external nofollow noopener noreferrer">https://wiki.archlinux.org/index.php/Arch_boot_process</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了 Linux 启动的整个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-24_linux-startup-process.svg&quot; alt=&quot;Linux Startup Process&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="linux" scheme="http://houmin.cc/tags/linux/"/>
    
      <category term="BIOS" scheme="http://houmin.cc/tags/BIOS/"/>
    
      <category term="UEFI" scheme="http://houmin.cc/tags/UEFI/"/>
    
      <category term="GRUB" scheme="http://houmin.cc/tags/GRUB/"/>
    
      <category term="systemd" scheme="http://houmin.cc/tags/systemd/"/>
    
      <category term="sysvinit" scheme="http://houmin.cc/tags/sysvinit/"/>
    
  </entry>
  
  <entry>
    <title>春分</title>
    <link href="http://houmin.cc/posts/b2b4fac7/"/>
    <id>http://houmin.cc/posts/b2b4fac7/</id>
    <published>2020-03-20T06:43:33.000Z</published>
    <updated>2020-07-14T08:24:44.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天是武汉封城第五十八天，时值春分，正是郊外踏青的好时节。这些天里，武汉现存确证病例可见地迅速减少到了六千人以内，与此同时海外的疫情仍然在爆发性的增长。这一周资本市场又发生了很多事情，美联储再一次会议中紧急降息100 个基点到 0 ~ 0.25%，美股在接下来的交易日再次熔断，大跌 12 个点，创造 1987 年以来最大历史跌幅。有人开始把这次崩盘和 1929 联系起来，真的会这样吗？</p><p>这里是「朝花夕拾」第十期，本来这次打算回顾一下 <code>The Great Depression</code>。看了一些资料觉得那次可以聊得东西太多了，决定在新一期的「资本不眠」单独做一个梳理，这里先挖个坑。今天，我们不聊经济，我们来看看这美丽的春天。</p>    <div id="aplayer-ahBdITey" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="441520" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><p>疫情期间，难得出门，这周和老妈老姐一起出去摘了次草莓。</p><p><img alt="小区里的桃花已经开放" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_peach-blossom.jpg"></p><p><img alt="路边随处可见的油菜花" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_rape-flower.jpg"></p><p><img alt="刚过马路，一个大哥拖着一车雪里蕻路过" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_road.jpg"></p><p><img alt="因为疫情停止建设的武汉国家航空基地道路" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_construction.jpg"></p><p><img alt="仍然在地里劳作的老爷爷" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_oldman.jpg"></p><p><img alt="现在正应该是往年春耕繁忙的时节" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_farmer.jpg"></p><p><img alt="走到菜地里，已经有小麦抽穗了" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_wheat.jpg"></p><p><img alt="各个路口仍然有关卡，还有执勤的工作人员" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_rescue.jpg"></p><p><img alt="到达农场，养鸡和养鸭的小院没有看见人影" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_duck.jpg"></p><p><img alt="农场老板写上的草莓价格，这是一个从河南跑到武汉承包农场的大哥，疫情期间也不容易" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_price.jpg"></p><p><img alt="狗狗们在很认真的承担他们的责任：）" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_dog.jpg"></p><p><img alt="一大棚的草莓" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_greenhouse.jpg"></p><p><img alt="地里挂满的草莓，老板让我们放开了吃，最后按照摘的价格付钱，可是我吃了一会儿就饱了" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_strawberry.jpg"></p><p><img alt="下午五点出门，等到我们返回，天已经快黑了" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_sunset.jpg"></p><p><img alt="傍晚的晚霞，特别漂亮" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_sunset2.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是武汉封城第五十八天，时值春分，正是郊外踏青的好时节。这些天里，武汉现存确证病例可见地迅速减少到了六千人以内，与此同时海外的疫情仍然在爆发性的增长。这一周资本市场又发生了很多事情，美联储再一次会议中紧急降息100 个基点到 0 ~ 0.25%，美股在接下来的交易日再次熔断，大跌 12 个点，创造 1987 年以来最大历史跌幅。有人开始把这次崩盘和 1929 联系起来，真的会这样吗？&lt;/p&gt;
&lt;p&gt;这里是「朝花夕拾」第十期，本来这次打算回顾一下 &lt;code&gt;The Great Depression&lt;/code&gt;。看了一些资料觉得那次可以聊得东西太多了，决定在新一期的「资本不眠」单独做一个梳理，这里先挖个坑。今天，我们不聊经济，我们来看看这美丽的春天。&lt;/p&gt;

    &lt;div id=&quot;aplayer-ahBdITey&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;441520&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-03-17_rape-flower.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="春天" scheme="http://houmin.cc/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
</feed>
