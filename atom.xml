<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-08-06T14:21:28.780Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Kubernetes解读】ApiServer</title>
    <link href="http://houmin.cc/posts/3bc1a603/"/>
    <id>http://houmin.cc/posts/3bc1a603/</id>
    <published>2020-08-07T12:46:14.000Z</published>
    <updated>2020-08-06T14:21:28.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>ApiServer</code>作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。</p><p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：</p><ul><li>提供 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用；</li><li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；</li><li>创建 kubernetes 服务，即提供 apiserver 的 Service，kubernetes Service；</li><li>资源在不同版本之间的转换；</li></ul><a id="more"></a><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img alt="apiserver diagram" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png"></p><ul><li>Scheme：定义了资源序列化和反序列化的方法，以及资源类型和版本的对应关系</li><li>Storage：是对资源的完整封装，实现了资源创建、删除、watch等操作</li><li>APIGroupInfo：是同一个group下所有资源的集合</li></ul><p>每个资源对应着两个版本：</p><ul><li>External Object：这个版本是对外给用户访问创建的接口对象，比如使用yaml或json创建对象时，都要使用External Object</li><li>Internal Object：这个版本是核心对象，实现了资源的创建和删除，对应了在ETCD中持久化的版本</li></ul><p>这两个版本的资源是需要相互转换的，而转换的函数就需要事先初始化到Scheme中， 多个external version版本之间的资源进行相互转换，都是需要通过internal version进行中转。所以在ETCD中存储的资源是带版本的，这也是kubernetes能实现多版本转换的关键。</p><h3 id="kube-apiserver-处理流程"><a href="#kube-apiserver-处理流程" class="headerlink" title="kube-apiserver 处理流程"></a>kube-apiserver 处理流程</h3><p>kube-apiserver 主要通过对外提供 API 的方式与其他组件进行交互，可以调用 kube-apiserver 的接口 <code>$ curl -k https://&lt;masterIP&gt;:6443</code>或者通过其提供的 <strong>swagger-ui</strong> 获取到，其主要有以下三种 API：</p><ul><li>core group：主要在 <code>/api/v1</code> 下；</li><li>named groups：其 path 为 <code>/apis/$NAME/$VERSION</code>；</li><li>暴露系统状态的一些 API：如<code>/metrics</code> 、<code>/healthz</code> 等；</li></ul><p>API 的 URL 大致以 <code>/apis/group/version/namespaces/my-ns/myresource</code> 组成，其中 API 的结构大致如下图所示：</p><p><a href="http://cdn.tianfeiyu.com/API-server-space-1.png" target="_blank" rel="external nofollow noopener noreferrer"><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-space-1.png"></a></p><p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</p><p><a href="http://cdn.tianfeiyu.com/API-server-flow-2.png" target="_blank" rel="external nofollow noopener noreferrer"><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-flow-2.png"></a></p><p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链，该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：</p><p><a href="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png" target="_blank" rel="external nofollow noopener noreferrer"><img alt="API-server-storage-flow-2" data-src="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png"></a></p><p><strong>Decoder</strong></p><p>kubernetes 中的多数 resource 都会有一个 <code>internal version</code>，因为在整个开发过程中一个 resource 可能会对应多个 version，比如 deployment 会有 <code>extensions/v1beta1</code>，<code>apps/v1</code>。 为了避免出现问题，kube-apiserver 必须要知道如何在每一对版本之间进行转换（例如，v1⇔v1alpha1，v1⇔v1beta1，v1beta1⇔v1alpha1），因此其使用了一个特殊的<code>internal version</code>，<code>internal version</code> 作为一个通用的 version 会包含所有 version 的字段，它具有所有 version 的功能。 Decoder 会首先把 creater object 转换到 <code>internal version</code>，然后将其转换为 <code>storage version</code>，<code>storage version</code> 是在 etcd 中存储时的另一个 version。</p><p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。</p><p><strong>Admission</strong></p><p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 <code>k8s.io/kubernetes/plugin/pkg/admission</code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 <code>--enable-admission-plugins</code> 参数来开启需要使用的插件，通过 <code>ValidatingAdmissionWebhook</code> 或 <code>MutatingAdmissionWebhook</code> 添加的插件也都会在此处进行工作。</p><p><strong>Validation</strong></p><p>主要检查 object 中字段的合法性。</p><p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |<span class="string">    ⇒       </span>|<span class="string">    ⇒  v1  ⇒ json/yaml ⇒ etcd</span></span><br><span class="line"><span class="string">                     admission    validation</span></span><br></pre></td></tr></table></figure><h3 id="kube-apiserver-中的组件"><a href="#kube-apiserver-中的组件" class="headerlink" title="kube-apiserver 中的组件"></a>kube-apiserver 中的组件</h3><p>kube-apiserver 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：</p><ul><li><strong>Aggregator</strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；</li><li><strong>KubeAPIServer</strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；</li><li><strong>APIExtensionServer</strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。</li></ul><p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。</p><h4 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h4><p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 <code>GenericAPIServer</code> 和维护自身状态的 Controller。其中 <code>GenericAPIServer</code> 主要处理 <code>apiregistration.k8s.io</code> 组下的 APIService 资源请求。</p><p><strong>Aggregator 除了处理资源请求外还包含几个 controller：</strong></p><ul><li>1、<code>apiserviceRegistrationController</code>：负责 APIServices 中资源的注册与删除；</li><li>2、<code>availableConditionController</code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；</li><li>3、<code>autoRegistrationController</code>：用于保持 API 中存在的一组特定的 APIServices；</li><li>4、<code>crdRegistrationController</code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；</li><li>5、<code>openAPIAggregationController</code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；</li></ul><p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="external nofollow noopener noreferrer">apiserver-builder</a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。</p><h5 id="启用-API-Aggregation"><a href="#启用-API-Aggregation" class="headerlink" title="启用 API Aggregation"></a>启用 API Aggregation</h5><p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--proxy-client-cert-file</span>=/etc/kubernetes/certs/proxy.crt</span><br><span class="line"><span class="attr">--proxy-client-key-file</span>=/etc/kubernetes/certs/proxy.key</span><br><span class="line"><span class="attr">--requestheader-client-ca-file</span>=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line"><span class="attr">--requestheader-allowed-names</span>=aggregator</span><br><span class="line"><span class="attr">--requestheader-extra-headers-prefix</span>=X-Remote-Extra-</span><br><span class="line"><span class="attr">--requestheader-group-headers</span>=X-Remote-Group</span><br><span class="line"><span class="attr">--requestheader-username-headers</span>=X-Remote-User</span><br></pre></td></tr></table></figure><h4 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h4><p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。</p><h4 id="APIExtensionServer"><a href="#APIExtensionServer" class="headerlink" title="APIExtensionServer"></a>APIExtensionServer</h4><p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。</p><p>其中包含的 controller 以及功能如下所示：</p><ul><li>1、<code>openapiController</code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 <code>/openapi/v2</code> 进行查看；</li><li>2、<code>crdController</code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 <code>$ kubectl api-versions</code> 和 <code>$ kubectl api-resources</code> 查看；</li><li>3、<code>namingController</code>：检查 crd obj 中是否有命名冲突，可在 crd <code>.status.conditions</code> 中查看；</li><li>4、<code>establishingController</code>：检查 crd 是否处于正常状态，可在 crd <code>.status.conditions</code> 中查看；</li><li>5、<code>nonStructuralSchemaController</code>：检查 crd obj 结构是否正常，可在 crd <code>.status.conditions</code> 中查看；</li><li>6、<code>apiApprovalController</code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd <code>.status.conditions</code> 中查看；</li><li>7、<code>finalizingController</code>：类似于 finalizes 的功能，与 CRs 的删除有关；</li></ul><h3 id="kube-apiserver-启动流程分析"><a href="#kube-apiserver-启动流程分析" class="headerlink" title="kube-apiserver 启动流程分析"></a>kube-apiserver 启动流程分析</h3><blockquote><p>kubernetes 版本：v1.16</p></blockquote><p>首先分析 kube-apiserver 的启动方式，kube-apiserver 也是通过其 <code>Run</code> 方法启动主逻辑的，在<code>Run</code> 方法调用之前会进行解析命令行参数、设置默认值等。</p><h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><p><code>Run</code> 方法的主要逻辑为：</p><ul><li>1、调用 <code>CreateServerChain</code> 构建服务调用链并判断是否启动非安全的 http server，http server 链中包含 apiserver 要启动的三个 server，以及为每个 server 注册对应资源的路由；</li><li>2、调用 <code>server.PrepareRun</code> 进行服务运行前的准备，该方法主要完成了健康检查、存活检查和<code>OpenAPI</code>路由的注册工作；</li><li>3、调用 <code>prepared.Run</code> 启动 https server；</li></ul><p>server 的初始化使用委托模式，通过 DelegationTarget 接口，把基本的 API Server、CustomResource、Aggregator 这三种服务采用链式结构串联起来，对外提供服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span>:<span class="number">147</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(completeOptions completedServerRunOptions, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server, err := CreateServerChain(completeOptions, stopCh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepared, err := server.PrepareRun()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prepared.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CreateServerChain"><a href="#CreateServerChain" class="headerlink" title="CreateServerChain"></a>CreateServerChain</h4><p><code>CreateServerChain</code> 是完成 server 初始化的方法，里面包含 <code>APIExtensionsServer</code>、<code>KubeAPIServer</code>、<code>AggregatorServer</code> 初始化的所有流程，最终返回 <code>aggregatorapiserver.APIAggregator</code> 实例，初始化流程主要有：http filter chain 的配置、API Group 的注册、http path 与 handler 的关联以及 handler 后端存储 etcd 的配置。其主要逻辑为：</p><ul><li>1、调用 <code>CreateKubeAPIServerConfig</code> 创建 KubeAPIServer 所需要的配置，主要是创建 <code>master.Config</code>，其中会调用 <code>buildGenericConfig</code> 生成 genericConfig，genericConfig 中包含 apiserver 的核心配置；</li><li>2、判断是否启用了扩展的 API server 并调用 <code>createAPIExtensionsConfig</code> 为其创建配置，apiExtensions server 是一个代理服务，用于代理 kubeapiserver 中的其他 server，比如 metric-server；</li><li>3、调用 <code>createAPIExtensionsServer</code> 创建 apiExtensionsServer 实例；</li><li>4、调用 <code>CreateKubeAPIServer</code>初始化 kubeAPIServer；</li><li>5、调用 <code>createAggregatorConfig</code> 为 aggregatorServer 创建配置并调用 <code>createAggregatorServer</code> 初始化 aggregatorServer；</li><li>6、配置并判断是否启动非安全的 http server；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span>:<span class="number">165</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateServerChain</span><span class="params">(completedOptions completedServerRunOptions, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*aggregatorapiserver.APIAggregator, error)</span></span> &#123;</span><br><span class="line">    nodeTunneler, proxyTransport, err := CreateNodeDialer(completedOptions)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、为 kubeAPIServer 创建配置</span></span><br><span class="line">    kubeAPIServerConfig, insecureServingInfo, serviceResolver, pluginInitializer, admissionPostStartHook, err :=                                         CreateKubeAPIServerConfig(completedOptions, nodeTunneler, proxyTransport)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否配置了 APIExtensionsServer，创建 apiExtensionsConfig </span></span><br><span class="line">    apiExtensionsConfig, err := createAPIExtensionsConfig(*kubeAPIServerConfig.GenericConfig, kubeAPIServerConfig.ExtraConfig.VersionedInformers,        pluginInitializer, completedOptions.ServerRunOptions, completedOptions.MasterCount,</span><br><span class="line">        serviceResolver, webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, kubeAPIServerConfig.GenericConfig.LoopbackClientConfig))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、初始化 APIExtensionsServer</span></span><br><span class="line">    apiExtensionsServer, err := createAPIExtensionsServer(apiExtensionsConfig, genericapiserver.NewEmptyDelegate())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、初始化 KubeAPIServer</span></span><br><span class="line">    kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer, admissionPostStartHook)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5、创建 AggregatorConfig</span></span><br><span class="line">    aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, completedOptions.ServerRunOptions, kubeAPIServerConfig.          ExtraConfig.VersionedInformers, serviceResolver, proxyTransport, pluginInitializer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6、初始化 AggregatorServer</span></span><br><span class="line">    aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、判断是否启动非安全端口的 http server</span></span><br><span class="line">    <span class="keyword">if</span> insecureServingInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">        insecureHandlerChain := kubeserver.BuildInsecureHandlerChain(aggregatorServer.GenericAPIServer.UnprotectedHandler(), kubeAPIServerConfig.GenericConfig)</span><br><span class="line">        <span class="keyword">if</span> err := insecureServingInfo.Serve(insecureHandlerChain, kubeAPIServerConfig.GenericConfig.RequestTimeout, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CreateKubeAPIServerConfig"><a href="#CreateKubeAPIServerConfig" class="headerlink" title="CreateKubeAPIServerConfig"></a>CreateKubeAPIServerConfig</h5><p>在 <code>CreateKubeAPIServerConfig</code> 中主要是调用 <code>buildGenericConfig</code> 创建 genericConfig 以及构建 master.Config 对象。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server<span class="selector-class">.go</span>:<span class="number">271</span></span><br><span class="line">func CreateKubeAPIServerConfig(</span><br><span class="line">    s completedServerRunOptions,</span><br><span class="line">    nodeTunneler tunneler<span class="selector-class">.Tunneler</span>,</span><br><span class="line">    proxyTransport *http<span class="selector-class">.Transport</span>,</span><br><span class="line">) (......) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、构建 genericConfig</span></span><br><span class="line">    genericConfig, versionedInformers, insecureServingInfo, serviceResolver, pluginInitializers, admissionPostStartHook, storageFactory,    lastErr = buildGenericConfig(s<span class="selector-class">.ServerRunOptions</span>, proxyTransport)</span><br><span class="line">    <span class="keyword">if</span> lastErr != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化所支持的 capabilities</span></span><br><span class="line">    capabilities.Initialize(capabilities.Capabilities&#123;</span><br><span class="line">        AllowPrivileged: s<span class="selector-class">.AllowPrivileged</span>,</span><br><span class="line">        PrivilegedSources: capabilities.PrivilegedSources&#123;</span><br><span class="line">            HostNetworkSources: []string&#123;&#125;,</span><br><span class="line">            HostPIDSources:     []string&#123;&#125;,</span><br><span class="line">            HostIPCSources:     []string&#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        PerConnectionBandwidthLimitBytesPerSec: s<span class="selector-class">.MaxConnectionBytesPerSec</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、获取 service ip range 以及 api server service IP</span></span><br><span class="line">    serviceIPRange, apiServerServiceIP, lastErr := master.DefaultServiceIPRange(s.PrimaryServiceClusterIPRange)</span><br><span class="line">    <span class="keyword">if</span> lastErr != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、构建 master.Config 对象</span></span><br><span class="line">    config = &amp;master.Config&#123;......&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> nodeTunneler != nil &#123;</span><br><span class="line">        config<span class="selector-class">.ExtraConfig</span><span class="selector-class">.KubeletClientConfig</span><span class="selector-class">.Dial</span> = nodeTunneler.Dial</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> config<span class="selector-class">.GenericConfig</span><span class="selector-class">.EgressSelector</span> != nil &#123;</span><br><span class="line">        config<span class="selector-class">.ExtraConfig</span><span class="selector-class">.KubeletClientConfig</span><span class="selector-class">.Lookup</span> = config<span class="selector-class">.GenericConfig</span><span class="selector-class">.EgressSelector</span>.Lookup</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="buildGenericConfig"><a href="#buildGenericConfig" class="headerlink" title="buildGenericConfig"></a>buildGenericConfig</h5><p>主要逻辑为：</p><ul><li>1、调用 <code>genericapiserver.NewConfig</code> 生成默认的 genericConfig，genericConfig 中主要配置了 <code>DefaultBuildHandlerChain</code>，<code>DefaultBuildHandlerChain</code> 中包含了认证、鉴权等一系列 http filter chain；</li><li>2、调用 <code>master.DefaultAPIResourceConfigSource</code> 加载需要启用的 API Resource，集群中所有的 API Resource 可以在代码的 <code>k8s.io/api</code> 目录中看到，随着版本的迭代也会不断变化；</li><li>3、为 genericConfig 中的部分字段设置默认值；</li><li>4、调用 <code>completedStorageFactoryConfig.New</code> 创建 storageFactory，后面会使用 storageFactory 为每种API Resource 创建对应的 RESTStorage；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.<span class="keyword">go</span>:<span class="number">386</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGenericConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    s *options.ServerRunOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    proxyTransport *http.Transport,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(......)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1、为 genericConfig 设置默认值</span></span><br><span class="line">    genericConfig = genericapiserver.NewConfig(legacyscheme.Codecs)</span><br><span class="line">    genericConfig.MergedResourceConfig = master.DefaultAPIResourceConfigSource()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lastErr = s.GenericServerRunOptions.ApplyTo(genericConfig); lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    genericConfig.OpenAPIConfig = genericapiserver.DefaultOpenAPIConfig(......)</span><br><span class="line">    genericConfig.OpenAPIConfig.Info.Title = <span class="string">"Kubernetes"</span></span><br><span class="line">    genericConfig.LongRunningFunc = filters.BasicLongRunningRequestCheck(</span><br><span class="line">        sets.NewString(<span class="string">"watch"</span>, <span class="string">"proxy"</span>),</span><br><span class="line">        sets.NewString(<span class="string">"attach"</span>, <span class="string">"exec"</span>, <span class="string">"proxy"</span>, <span class="string">"log"</span>, <span class="string">"portforward"</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    kubeVersion := version.Get()</span><br><span class="line">    genericConfig.Version = &amp;kubeVersion</span><br><span class="line"></span><br><span class="line">    storageFactoryConfig := kubeapiserver.NewStorageFactoryConfig()</span><br><span class="line">    storageFactoryConfig.ApiResourceConfig = genericConfig.MergedResourceConfig</span><br><span class="line">    completedStorageFactoryConfig, err := storageFactoryConfig.Complete(s.Etcd)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = err</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 storageFactory</span></span><br><span class="line">    storageFactory, lastErr = completedStorageFactoryConfig.New()</span><br><span class="line">    <span class="keyword">if</span> lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> genericConfig.EgressSelector != <span class="literal">nil</span> &#123;</span><br><span class="line">        storageFactory.StorageConfig.Transport.EgressLookup = genericConfig.EgressSelector.Lookup</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、初始化 RESTOptionsGetter，后期根据其获取操作 Etcd 的句柄，同时添加 etcd 的健康检查方法</span></span><br><span class="line">    <span class="keyword">if</span> lastErr = s.Etcd.ApplyWithStorageFactoryTo(storageFactory, genericConfig); lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、设置使用 protobufs 用来内部交互，并且禁用压缩功能</span></span><br><span class="line">    genericConfig.LoopbackClientConfig.ContentConfig.ContentType = <span class="string">"application/vnd.kubernetes.protobuf"</span></span><br><span class="line">    </span><br><span class="line">    genericConfig.LoopbackClientConfig.DisableCompression = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建 clientset</span></span><br><span class="line">    kubeClientConfig := genericConfig.LoopbackClientConfig</span><br><span class="line">    clientgoExternalClient, err := clientgoclientset.NewForConfig(kubeClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"failed to create real external clientset: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    versionedInformers = clientgoinformers.NewSharedInformerFactory(clientgoExternalClient, <span class="number">10</span>*time.Minute)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、创建认证实例，支持多种认证方式：请求 Header 认证、Auth 文件认证、CA 证书认证、Bearer token 认证、</span></span><br><span class="line">    <span class="comment">// ServiceAccount 认证、BootstrapToken 认证、WebhookToken 认证等</span></span><br><span class="line">    genericConfig.Authentication.Authenticator, genericConfig.OpenAPIConfig.SecurityDefinitions, err = BuildAuthenticator(s,                 clientgoExternalClient, versionedInformers)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"invalid authentication config: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、创建鉴权实例，包含：Node、RBAC、Webhook、ABAC、AlwaysAllow、AlwaysDeny</span></span><br><span class="line">    genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer(s, versionedInformers)</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    serviceResolver = buildServiceResolver(s.EnableAggregatorRouting, genericConfig.LoopbackClientConfig.Host, versionedInformers)</span><br><span class="line"></span><br><span class="line">    authInfoResolverWrapper := webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, genericConfig.LoopbackClientConfig)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、审计插件的初始化</span></span><br><span class="line">    lastErr = s.Audit.ApplyTo(......)</span><br><span class="line">    <span class="keyword">if</span> lastErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8、准入插件的初始化</span></span><br><span class="line">    pluginInitializers, admissionPostStartHook, err = admissionConfig.New(proxyTransport, serviceResolver)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"failed to create admission plugin initializer: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = s.Admission.ApplyTo(......)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        lastErr = fmt.Errorf(<span class="string">"failed to initialize admission: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上主要分析 KubeAPIServerConfig 的初始化，其他两个 server config 的初始化暂且不详细分析，下面接着继续分析 server 的初始化。</p><h5 id="createAPIExtensionsServer"><a href="#createAPIExtensionsServer" class="headerlink" title="createAPIExtensionsServer"></a>createAPIExtensionsServer</h5><p>APIExtensionsServer 是最先被初始化的，在 <code>createAPIExtensionsServer</code> 中调用 <code>apiextensionsConfig.Complete().New</code> 来完成 server 的初始化，其主要逻辑为：</p><ul><li>1、首先调用 <code>c.GenericConfig.New</code> 按照<code>go-restful</code>的模式初始化 Container，在 <code>c.GenericConfig.New</code> 中会调用 <code>NewAPIServerHandler</code> 初始化 handler，APIServerHandler 包含了 API Server 使用的多种http.Handler 类型，包括 <code>go-restful</code> 以及 <code>non-go-restful</code>，以及在以上两者之间选择的 Director 对象，<code>go-restful</code> 用于处理已经注册的 handler，<code>non-go-restful</code> 用来处理不存在的 handler，API URI 处理的选择过程为：<code>FullHandlerChain-&gt; Director -&gt;{GoRestfulContainer， NonGoRestfulMux}</code>。在 <code>c.GenericConfig.New</code> 中还会调用 <code>installAPI</code>来添加包括 <code>/</code>、<code>/debug/*</code>、<code>/metrics</code>、<code>/version</code> 等路由信息。三种 server 在初始化时首先都会调用 <code>c.GenericConfig.New</code> 来初始化一个 genericServer，然后进行 API 的注册；</li><li>2、调用 <code>s.GenericAPIServer.InstallAPIGroup</code> 在路由中注册 API Resources，此方法的调用链非常深，主要是为了将需要暴露的 API Resource 注册到 server 中，以便能通过 http 接口进行 resource 的 REST 操作，其他几种 server 在初始化时也都会执行对应的 <code>InstallAPI</code>；</li><li>3、初始化 server 中需要使用的 controller，主要有 <code>openapiController</code>、<code>crdController</code>、<code>namingController</code>、<code>establishingController</code>、<code>nonStructuralSchemaController</code>、<code>apiApprovalController</code>、<code>finalizingControlle</code>r；</li><li>4、将需要启动的 controller 以及 informer 添加到 PostStartHook 中；</li></ul><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/apiextensions.go:94</span><br><span class="line">func createAPIExtensionsServer(apiextensionsConfig *apiextensionsapiserver.Config, delegateAPIServer genericapiserver.DelegationTarget) (*  apiextensionsapiserver.CustomResourceDefinitions, error) &#123;</span><br><span class="line">    <span class="attribute">return apiextensionsConfig.Complete().New(delegateAPIServer)</span></span><br><span class="line"><span class="attribute">&#125;</span></span><br><span class="line"><span class="attribute">k8s.io/kubernetes/staging/src/k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go</span>:132</span><br><span class="line">func (c completedConfig) New(delegationTarget genericapiserver<span class="variable">.DelegationTarget</span>) (*CustomResourceDefinitions, error) &#123;</span><br><span class="line">    // 1、初始化 genericServer</span><br><span class="line">    genericServer, err := c<span class="variable">.GenericConfig</span><span class="variable">.New</span>("apiextensions-apiserver", delegationTarget)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s := &amp;CustomResourceDefinitions&#123;</span><br><span class="line">        GenericAPIServer: genericServer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、初始化 APIGroup Info，APIGroup 指该 server 需要暴露的 API</span><br><span class="line">    apiResourceConfig := c<span class="variable">.GenericConfig</span><span class="variable">.MergedResourceConfig</span></span><br><span class="line">    apiGroupInfo := genericapiserver<span class="variable">.NewDefaultAPIGroupInfo</span>(apiextensions<span class="variable">.GroupName</span>, Scheme, metav1<span class="variable">.ParameterCodec</span>, Codecs)</span><br><span class="line">    if apiResourceConfig<span class="variable">.VersionEnabled</span>(v1beta1<span class="variable">.SchemeGroupVersion</span>) &#123;</span><br><span class="line">        storage := map[string]rest<span class="variable">.Storage</span>&#123;&#125;</span><br><span class="line">        customResourceDefintionStorage := customresourcedefinition<span class="variable">.NewREST</span>(Scheme, c<span class="variable">.GenericConfig</span><span class="variable">.RESTOptionsGetter</span>)</span><br><span class="line">        storage["customresourcedefinitions"] = customResourceDefintionStorage</span><br><span class="line">        storage["customresourcedefinitions/status"] = customresourcedefinition<span class="variable">.NewStatusREST</span>(Scheme, customResourceDefintionStorage)</span><br><span class="line"></span><br><span class="line">        apiGroupInfo<span class="variable">.VersionedResourcesStorageMap</span>[v1beta1<span class="variable">.SchemeGroupVersion</span><span class="variable">.Version</span>] = storage</span><br><span class="line">    &#125;</span><br><span class="line">    if apiResourceConfig<span class="variable">.VersionEnabled</span>(v1<span class="variable">.SchemeGroupVersion</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、注册 APIGroup</span><br><span class="line">    if err := s<span class="variable">.GenericAPIServer</span><span class="variable">.InstallAPIGroup</span>(&amp;apiGroupInfo); <span class="attribute">err != nil &#123;</span></span><br><span class="line"><span class="attribute">        return nil, err</span></span><br><span class="line"><span class="attribute">    &#125;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">    // 4、初始化需要使用的 controller</span></span><br><span class="line"><span class="attribute">    crdClient, err</span> := internalclientset<span class="variable">.NewForConfig</span>(s<span class="variable">.GenericAPIServer</span><span class="variable">.LoopbackClientConfig</span>)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, fmt<span class="variable">.Errorf</span>("failed to create clientset: %v", err)</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="variable">.Informers</span> = internalinformers<span class="variable">.NewSharedInformerFactory</span>(crdClient, 5*time<span class="variable">.Minute</span>)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    establishingController := establish<span class="variable">.NewEstablishingController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>().                    CustomResourceDefinitions(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    crdHandler, err := NewCustomResourceDefinitionHandler(......)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.Handler</span><span class="variable">.NonGoRestfulMux</span><span class="variable">.Handle</span>("/apis", crdHandler)</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.Handler</span><span class="variable">.NonGoRestfulMux</span><span class="variable">.HandlePrefix</span>("/apis/", crdHandler)</span><br><span class="line"></span><br><span class="line">    crdController := NewDiscoveryController(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>(),                 versionDiscoveryHandler, groupDiscoveryHandler)</span><br><span class="line">    namingController := status<span class="variable">.NewNamingConditionController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    nonStructuralSchemaController := nonstructuralschema<span class="variable">.NewConditionController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>().         CustomResourceDefinitions(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    apiApprovalController := apiapproval<span class="variable">.NewKubernetesAPIApprovalPolicyConformantConditionController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>().      InternalVersion()<span class="variable">.CustomResourceDefinitions</span>(), crdClient<span class="variable">.Apiextensions</span>())</span><br><span class="line">    finalizingController := finalizer<span class="variable">.NewCRDFinalizer</span>(</span><br><span class="line">        s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>(),</span><br><span class="line">        crdClient<span class="variable">.Apiextensions</span>(),</span><br><span class="line">        crdHandler,</span><br><span class="line">    )</span><br><span class="line">    var openapiController *openapicontroller<span class="variable">.Controller</span></span><br><span class="line">    if utilfeature<span class="variable">.DefaultFeatureGate</span><span class="variable">.Enabled</span>(apiextensionsfeatures<span class="variable">.CustomResourcePublishOpenAPI</span>) &#123;</span><br><span class="line">        openapiController = openapicontroller<span class="variable">.NewController</span>(s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5、将 informer 以及 controller 添加到 PostStartHook 中</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.AddPostStartHookOrDie</span>("start-apiextensions-informers", func(context genericapiserver<span class="variable">.PostStartHookContext</span>) error &#123;</span><br><span class="line">        s<span class="variable">.Informers</span><span class="variable">.Start</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;)</span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.AddPostStartHookOrDie</span>("start-apiextensions-controllers", func(context genericapiserver<span class="variable">.PostStartHookContext</span>) error &#123;</span><br><span class="line">        ......</span><br><span class="line">        go crdController<span class="variable">.Run</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        go namingController<span class="variable">.Run</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        go establishingController<span class="variable">.Run</span>(context<span class="variable">.StopCh</span>)</span><br><span class="line">        go nonStructuralSchemaController<span class="variable">.Run</span>(5, context<span class="variable">.StopCh</span>)</span><br><span class="line">        go apiApprovalController<span class="variable">.Run</span>(5, context<span class="variable">.StopCh</span>)</span><br><span class="line">        go finalizingController<span class="variable">.Run</span>(5, context<span class="variable">.StopCh</span>)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    s<span class="variable">.GenericAPIServer</span><span class="variable">.AddPostStartHookOrDie</span>("crd-informer-synced", func(context genericapiserver<span class="variable">.PostStartHookContext</span>) error &#123;</span><br><span class="line">        return wait<span class="variable">.PollImmediateUntil</span>(100*time<span class="variable">.Millisecond</span>, func() (bool, error) &#123;</span><br><span class="line">            return s<span class="variable">.Informers</span><span class="variable">.Apiextensions</span>()<span class="variable">.InternalVersion</span>()<span class="variable">.CustomResourceDefinitions</span>()<span class="variable">.Informer</span>()<span class="variable">.HasSynced</span>(), nil</span><br><span class="line">        &#125;, context<span class="variable">.StopCh</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return s, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 APIExtensionsServer 的初始化流程，其中最核心方法是 <code>s.GenericAPIServer.InstallAPIGroup</code>，也就是 API 的注册过程，三种 server 中 API 的注册过程都是其核心。</p><h5 id="CreateKubeAPIServer"><a href="#CreateKubeAPIServer" class="headerlink" title="CreateKubeAPIServer"></a>CreateKubeAPIServer</h5><p>本节继续分析 KubeAPIServer 的初始化，在<code>CreateKubeAPIServer</code> 中调用了 <code>kubeAPIServerConfig.Complete().New</code> 来完成相关的初始化操作。</p><h5 id="kubeAPIServerConfig-Complete-New"><a href="#kubeAPIServerConfig-Complete-New" class="headerlink" title="kubeAPIServerConfig.Complete().New"></a>kubeAPIServerConfig.Complete().New</h5><p>主要逻辑为：</p><ul><li>1、调用 <code>c.GenericConfig.New</code> 初始化 GenericAPIServer，其主要实现在上文已经分析过；</li><li>2、判断是否支持 logs 相关的路由，如果支持，则添加 <code>/logs</code> 路由；</li><li>3、调用 <code>m.InstallLegacyAPI</code> 将核心 API Resource 添加到路由中，对应到 apiserver 就是以 <code>/api</code> 开头的 resource；</li><li>4、调用 <code>m.InstallAPIs</code> 将扩展的 API Resource 添加到路由中，在 apiserver 中即是以 <code>/apis</code> 开头的 resource；</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/server.go:<span class="number">214</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeAPIServer</span><span class="params">(......)</span></span> (*master.<span class="type">Master</span>, error) &#123;</span><br><span class="line">    kubeAPIServer, err := kubeAPIServerConfig.<span class="type">Complete</span>().<span class="type">New</span>(delegateAPIServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kubeAPIServer.<span class="type">GenericAPIServer</span>.<span class="type">AddPostStartHookOrDie</span>(<span class="string">"start-kube-apiserver-admission-initializer"</span>, admissionPostStartHook)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kubeAPIServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">k8s.io/kubernetes/pkg/master/master.go:<span class="number">325</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> completedConfig)</span></span> <span class="type">New</span>(delegationTarget genericapiserver.<span class="type">DelegationTarget</span>) (*<span class="type">Master</span>, error) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1、初始化 GenericAPIServer</span></span><br><span class="line">    s, err := <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">New</span>(<span class="string">"kube-apiserver"</span>, delegationTarget)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、注册 logs 相关的路由</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">EnableLogsSupport</span> &#123;</span><br><span class="line">        routes.<span class="type">Logs</span>&#123;&#125;.<span class="type">Install</span>(s.<span class="type">Handler</span>.<span class="type">GoRestfulContainer</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := &amp;<span class="type">Master</span>&#123;</span><br><span class="line">        <span class="type">GenericAPIServer</span>: s,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、安装 LegacyAPI</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">APIResourceConfigSource</span>.<span class="type">VersionEnabled</span>(apiv1.<span class="type">SchemeGroupVersion</span>) &#123;</span><br><span class="line">        legacyRESTStorageProvider := corerest.<span class="type">LegacyRESTStorageProvider</span>&#123;</span><br><span class="line">            <span class="type">StorageFactory</span>:              <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">StorageFactory</span>,</span><br><span class="line">            <span class="type">ProxyTransport</span>:              <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">ProxyTransport</span>,</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := m.<span class="type">InstallLegacyAPI</span>(&amp;<span class="built_in">c</span>, <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">RESTOptionsGetter</span>, legacyRESTStorageProvider); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    restStorageProviders := []<span class="type">RESTStorageProvider</span>&#123;</span><br><span class="line">        auditregistrationrest.<span class="type">RESTStorageProvider</span>&#123;&#125;,</span><br><span class="line">        authenticationrest.<span class="type">RESTStorageProvider</span>&#123;<span class="type">Authenticator</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">Authentication</span>.<span class="type">Authenticator</span>, <span class="type">APIAudiences</span>: <span class="built_in">c</span>.<span class="type">GenericConfig</span>.  <span class="type">Authentication</span>.<span class="type">APIAudiences</span>&#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、安装 APIs</span></span><br><span class="line">    <span class="keyword">if</span> err := m.<span class="type">InstallAPIs</span>(<span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">APIResourceConfigSource</span>, <span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">RESTOptionsGetter</span>, restStorageProviders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">Tunneler</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.installTunneler(<span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">Tunneler</span>, corev1client.<span class="type">NewForConfigOrDie</span>(<span class="built_in">c</span>.<span class="type">GenericConfig</span>.<span class="type">LoopbackClientConfig</span>).<span class="type">Nodes</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.<span class="type">GenericAPIServer</span>.<span class="type">AddPostStartHookOrDie</span>(<span class="string">"ca-registration"</span>, <span class="built_in">c</span>.<span class="type">ExtraConfig</span>.<span class="type">ClientCARegistrationHook</span>.<span class="type">PostStartHook</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="m-InstallLegacyAPI"><a href="#m-InstallLegacyAPI" class="headerlink" title="m.InstallLegacyAPI"></a>m.InstallLegacyAPI</h5><p>此方法的主要功能是将 core API 注册到路由中，是 apiserver 初始化流程中最核心的方法之一，不过其调用链非常深，下面会进行深入分析。将 API 注册到路由其最终的目的就是对外提供 RESTful API 来操作对应 resource，注册 API 主要分为两步，第一步是为 API 中的每个 resource 初始化 RESTStorage 以此操作后端存储中数据的变更，第二步是为每个 resource 根据其 verbs 构建对应的路由。<code>m.InstallLegacyAPI</code> 的主要逻辑为：</p><ul><li>1、调用 <code>legacyRESTStorageProvider.NewLegacyRESTStorage</code> 为 LegacyAPI 中各个资源创建 RESTStorage，RESTStorage 的目的是将每种资源的访问路径及其后端存储的操作对应起来；</li><li>2、初始化 <code>bootstrap-controller</code>，并将其加入到 PostStartHook 中，<code>bootstrap-controller</code> 是 apiserver 中的一个 controller，主要功能是创建系统所需要的一些 namespace 以及创建 kubernetes service 并定期触发对应的 sync 操作，apiserver 在启动后会通过调用 PostStartHook 来启动 <code>bootstrap-controller</code>；</li><li>3、在为资源创建完 RESTStorage 后，调用 <code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 为 APIGroup 注册路由信息，<code>InstallLegacyAPIGroup</code>方法的调用链非常深，主要为<code>InstallLegacyAPIGroup--&gt; installAPIResources --&gt; InstallREST --&gt; Install --&gt; registerResourceHandlers</code>，最终核心的路由构造在<code>registerResourceHandlers</code>方法内，该方法比较复杂，其主要功能是通过上一步骤构造的 REST Storage 判断该资源可以执行哪些操作（如 create、update等），将其对应的操作存入到 action 中，每一个 action 对应一个标准的 REST 操作，如 create 对应的 action 操作为 POST、update 对应的 action 操作为PUT。最终根据 actions 数组依次遍历，对每一个操作添加一个 handler 方法，注册到 route 中去，再将 route 注册到 webservice 中去，webservice 最终会注册到 container 中，遵循 go-restful 的设计模式；</li></ul><p>关于 <code>legacyRESTStorageProvider.NewLegacyRESTStorage</code> 以及 <code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 方法的详细说明在后文中会继续进行讲解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/master/master.<span class="keyword">go</span>:<span class="number">406</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(......)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error building core storage: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controllerName := <span class="string">"bootstrap-controller"</span></span><br><span class="line">    coreClient := corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    bootstrapController := c.NewBootstrapController(legacyRESTStorage, coreClient, coreClient, coreClient, coreClient.RESTClient())</span><br><span class="line">    m.GenericAPIServer.AddPostStartHookOrDie(controllerName, bootstrapController.PostStartHook)</span><br><span class="line">    m.GenericAPIServer.AddPreShutdownHookOrDie(controllerName, bootstrapController.PreShutdownHook)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstallAPIs</code> 与 <code>InstallLegacyAPI</code> 的主要流程是类似的，限于篇幅此处不再深入分析。</p><h4 id="createAggregatorServer"><a href="#createAggregatorServer" class="headerlink" title="createAggregatorServer"></a>createAggregatorServer</h4><p><code>AggregatorServer</code> 主要用于自定义的聚合控制器的，使 CRD 能够自动注册到集群中。</p><p>主要逻辑为：</p><ul><li>1、调用 <code>aggregatorConfig.Complete().NewWithDelegate</code> 创建 aggregatorServer；</li><li>2、初始化 <code>crdRegistrationController</code> 和 <code>autoRegistrationController</code>，<code>crdRegistrationController</code> 负责注册 CRD，<code>autoRegistrationController</code> 负责将 CRD 对应的 APIServices 自动注册到 apiserver 中，CRD 创建后可通过 <code>$ kubectl get apiservices</code> 查看是否注册到 apiservices 中；</li><li>3、将 <code>autoRegistrationController</code> 和 <code>crdRegistrationController</code> 加入到 PostStartHook 中；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/cmd/kube-apiserver/app/aggregator.<span class="keyword">go</span>:<span class="number">124</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAggregatorServer</span><span class="params">(......)</span> <span class="params">(*aggregatorapiserver.APIAggregator, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1、初始化 aggregatorServer</span></span><br><span class="line">    aggregatorServer, err := aggregatorConfig.Complete().NewWithDelegate(delegateAPIServer)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化 auto-registration controller</span></span><br><span class="line">    apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    autoRegistrationController := autoregister.NewAutoRegisterController(......)</span><br><span class="line">    apiServices := apiServicesToRegister(delegateAPIServer, autoRegistrationController)</span><br><span class="line">    crdRegistrationController := crdregistration.NewCRDRegistrationController(......)</span><br><span class="line">    err = aggregatorServer.GenericAPIServer.AddPostStartHook(<span class="string">"kube-apiserver-autoregistration"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> crdRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> aggregatorConfig.GenericConfig.MergedResourceConfig.AnyVersionForGroupEnabled(<span class="string">"apiextensions.k8s.io"</span>) &#123;</span><br><span class="line">                crdRegistrationController.WaitForInitialSync()</span><br><span class="line">            &#125;</span><br><span class="line">            autoRegistrationController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = aggregatorServer.GenericAPIServer.AddBootSequenceHealthChecks(</span><br><span class="line">        makeAPIServiceAvailableHealthCheck(</span><br><span class="line">            <span class="string">"autoregister-completion"</span>,</span><br><span class="line">            apiServices,</span><br><span class="line">            aggregatorServer.APIRegistrationInformers.Apiregistration().V1().APIServices(),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aggregatorServer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="aggregatorConfig-Complete-NewWithDelegate"><a href="#aggregatorConfig-Complete-NewWithDelegate" class="headerlink" title="aggregatorConfig.Complete().NewWithDelegate"></a>aggregatorConfig.Complete().NewWithDelegate</h5><p><code>aggregatorConfig.Complete().NewWithDelegate</code> 是初始化 aggregatorServer 的方法，主要逻辑为：</p><ul><li>1、调用 <code>c.GenericConfig.New</code> 初始化 GenericAPIServer，其内部的主要功能在上文已经分析过；</li><li>2、调用 <code>apiservicerest.NewRESTStorage</code> 为 APIServices 资源创建 RESTStorage，RESTStorage 的目的是将每种资源的访问路径及其后端存储的操作对应起来；</li><li>3、调用 <code>s.GenericAPIServer.InstallAPIGroup</code> 为 APIGroup 注册路由信息；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span>:<span class="number">158</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">NewWithDelegate</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*APIAggregator, error)</span></span> &#123;</span><br><span class="line">    openAPIConfig := c.GenericConfig.OpenAPIConfig</span><br><span class="line">    c.GenericConfig.OpenAPIConfig = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 1、初始化 genericServer</span></span><br><span class="line">    genericServer, err := c.GenericConfig.New(<span class="string">"kube-aggregator"</span>, delegationTarget)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apiregistrationClient, err := clientset.NewForConfig(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    informerFactory := informers.NewSharedInformerFactory(</span><br><span class="line">        apiregistrationClient,</span><br><span class="line">        <span class="number">5</span>*time.Minute, </span><br><span class="line">    )</span><br><span class="line">    s := &amp;APIAggregator&#123;</span><br><span class="line">        GenericAPIServer: genericServer,</span><br><span class="line">        delegateHandler: delegationTarget.UnprotectedHandler(),</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、为 API 注册路由</span></span><br><span class="line">    apiGroupInfo := apiservicerest.NewRESTStorage(c.GenericConfig.MergedResourceConfig, c.GenericConfig.RESTOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err := s.GenericAPIServer.InstallAPIGroup(&amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、初始化 apiserviceRegistrationController、availableController</span></span><br><span class="line">    apisHandler := &amp;apisHandler&#123;</span><br><span class="line">        codecs: aggregatorscheme.Codecs,</span><br><span class="line">        lister: s.lister,</span><br><span class="line">    &#125;</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">"/apis"</span>, apisHandler)</span><br><span class="line">    s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle(<span class="string">"/apis/"</span>, apisHandler)</span><br><span class="line">    apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().V1().APIServices(), s)</span><br><span class="line">    availableController, err := statuscontrollers.NewAvailableConditionController(</span><br><span class="line">       ......</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、添加 PostStartHook</span></span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">"start-kube-aggregator-informers"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        informerFactory.Start(context.StopCh)</span><br><span class="line">        c.GenericConfig.SharedInformerFactory.Start(context.StopCh)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">"apiservice-registration-controller"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span>      <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> apiserviceRegistrationController.Run(context.StopCh)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    s.GenericAPIServer.AddPostStartHookOrDie(<span class="string">"apiservice-status-available-controller"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context genericapiserver.PostStartHookContext)</span>  <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> availableController.Run(<span class="number">5</span>, context.StopCh)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是对 AggregatorServer 初始化流程的分析，可以看出，在创建 APIExtensionsServer、KubeAPIServer 以及 AggregatorServer 时，其模式都是类似的，首先调用 <code>c.GenericConfig.New</code> 按照<code>go-restful</code>的模式初始化 Container，然后为 server 中需要注册的资源创建 RESTStorage，最后将 resource 的 APIGroup 信息注册到路由中。</p><p>至此，CreateServerChain 中流程已经分析完，其中的调用链如下所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                    |<span class="string">--&gt; CreateNodeDialer</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">--&gt; CreateKubeAPIServerConfig</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">CreateServerChain --|<span class="string">--&gt; createAPIExtensionsConfig</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">                                                                       </span>|<span class="string">--&gt; c.GenericConfig.New</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">--&gt; createAPIExtensionsServer --&gt; apiextensionsConfig.Complete().New --</span>|</span><br><span class="line">                    |<span class="string">                                                                       </span>|<span class="string">--&gt; s.GenericAPIServer.InstallAPIGroup</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">                                                                 </span>|<span class="string">--&gt; c.GenericConfig.New --&gt; legacyRESTStorageProvider.NewLegacyRESTStorage</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">                                                                 </span>|</span><br><span class="line">                    |<span class="string">--&gt; CreateKubeAPIServer --&gt; kubeAPIServerConfig.Complete().New --</span>|<span class="string">--&gt; m.InstallLegacyAPI</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">                                                                 </span>|</span><br><span class="line">                    |<span class="string">                                                                 </span>|<span class="string">--&gt; m.InstallAPIs</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |</span><br><span class="line"><span class="string">                    </span>|<span class="string">--&gt; createAggregatorConfig</span></span><br><span class="line"><span class="string">                    </span>|</span><br><span class="line">                    |<span class="string">                                                                             </span>|<span class="string">--&gt; c.GenericConfig.New</span></span><br><span class="line"><span class="string">                    </span>|<span class="string">                                                                             </span>|</span><br><span class="line">                    |<span class="string">--&gt; createAggregatorServer --&gt; aggregatorConfig.Complete().NewWithDelegate --</span>|<span class="string">--&gt; apiservicerest.NewRESTStorage</span></span><br><span class="line"><span class="string">                                                                                                  </span>|</span><br><span class="line">                                                                                                  |<span class="string">--&gt; s.GenericAPIServer.InstallAPIGroup</span></span><br></pre></td></tr></table></figure><h4 id="prepared-Run"><a href="#prepared-Run" class="headerlink" title="prepared.Run"></a>prepared.Run</h4><p>在 <code>Run</code> 方法中首先调用 <code>CreateServerChain</code> 完成各 server 的初始化，然后调用 <code>server.PrepareRun</code> 完成服务启动前的准备工作，最后调用 <code>prepared.Run</code> 方法来启动安全的 http server。<code>server.PrepareRun</code> 主要完成了健康检查、存活检查和<code>OpenAPI</code>路由的注册工作，下面继续分析 <code>prepared.Run</code> 的流程，在 <code>prepared.Run</code> 中主要调用 <code>s.NonBlockingRun</code> 来完成启动工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.<span class="keyword">go</span>:<span class="number">269</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedAPIAggregator)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.runnable.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.<span class="keyword">go</span>:<span class="number">316</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    delayedStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(delayedStopCh)</span><br><span class="line">        &lt;-stopCh</span><br><span class="line"></span><br><span class="line">        time.Sleep(s.ShutdownDelayDuration)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 s.NonBlockingRun 完成启动流程</span></span><br><span class="line">    err := s.NonBlockingRun(delayedStopCh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当收到退出信号后完成一些收尾工作</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    err = s.RunPreShutdownHooks()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;-delayedStopCh</span><br><span class="line">    s.HandlerChainWaitGroup.Wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="s-NonBlockingRun"><a href="#s-NonBlockingRun" class="headerlink" title="s.NonBlockingRun"></a>s.NonBlockingRun</h5><p><code>s.NonBlockingRun</code> 的主要逻辑为：</p><ul><li>1、判断是否要启动审计日志服务；</li><li>2、调用 <code>s.SecureServingInfo.Serve</code> 配置并启动 https server；</li><li>3、执行 postStartHooks；</li><li>4、向 systemd 发送 ready 信号；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.<span class="keyword">go</span>:<span class="number">351</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">NonBlockingRun</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    auditStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、判断是否要启动审计日志</span></span><br><span class="line">    <span class="keyword">if</span> s.AuditBackend != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := s.AuditBackend.Run(auditStopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to run the audit backend: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、启动 https server</span></span><br><span class="line">    internalStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> stoppedCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> s.SecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.Handler != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        stoppedCh, err = s.SecureServingInfo.Serve(s.Handler, s.ShutdownTimeout, internalStopCh)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">close</span>(internalStopCh)</span><br><span class="line">            <span class="built_in">close</span>(auditStopCh)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        <span class="built_in">close</span>(s.readinessStopCh)</span><br><span class="line">        <span class="built_in">close</span>(internalStopCh)</span><br><span class="line">        <span class="keyword">if</span> stoppedCh != <span class="literal">nil</span> &#123;</span><br><span class="line">            &lt;-stoppedCh</span><br><span class="line">        &#125;</span><br><span class="line">        s.HandlerChainWaitGroup.Wait()</span><br><span class="line">        <span class="built_in">close</span>(auditStopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、执行 postStartHooks</span></span><br><span class="line">    s.RunPostStartHooks(stopCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、向 systemd 发送 ready 信号</span></span><br><span class="line">    <span class="keyword">if</span> _, err := systemd.SdNotify(<span class="literal">true</span>, <span class="string">"READY=1\n"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Unable to send systemd daemon successful start message: %v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 server 的初始化以及启动流程过程的分析，上文已经提到各 server 初始化过程中最重要的就是 API Resource RESTStorage 的初始化以及路由的注册，由于该过程比较复杂，下文会单独进行讲述。</p><h3 id="storageFactory-的构建"><a href="#storageFactory-的构建" class="headerlink" title="storageFactory 的构建"></a>storageFactory 的构建</h3><p>上文已经提到过，apiserver 最终实现的 handler 对应的后端数据是以 <strong>Store</strong> 的结构保存的，这里以 <code>/api</code> 开头的路由举例，通过<code>NewLegacyRESTStorage</code>方法创建各个资源的<strong>RESTStorage</strong>。RESTStorage 是一个结构体，具体的定义在<code>k8s.io/apiserver/pkg/registry/generic/registry/store.go</code>下，结构体内主要包含<code>NewFunc</code>返回特定资源信息、<code>NewListFunc</code>返回特定资源列表、<code>CreateStrategy</code>特定资源创建时的策略、<code>UpdateStrategy</code>更新时的策略以及<code>DeleteStrategy</code>删除时的策略等重要方法。在<code>NewLegacyRESTStorage</code>内部，可以看到创建了多种资源的 RESTStorage。</p><p><code>NewLegacyRESTStorage</code> 的调用链为 <code>CreateKubeAPIServer --&gt; kubeAPIServerConfig.Complete().New --&gt; m.InstallLegacyAPI --&gt; legacyRESTStorageProvider.NewLegacyRESTStorage</code>。</p><h4 id="NewLegacyRESTStorage"><a href="#NewLegacyRESTStorage" class="headerlink" title="NewLegacyRESTStorage"></a>NewLegacyRESTStorage</h4><p>一个 API Group 下的资源都有其 REST 实现，<code>k8s.io/kubernetes/pkg/registry</code>下所有的 Group 都有一个rest目录，存储的就是对应资源的 RESTStorage。在<code>NewLegacyRESTStorage</code>方法中，通过<code>NewREST</code>或者<code>NewStorage</code>会生成各种资源对应的 Storage，此处以 pod 为例进行说明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/registry/core/rest/storage_core.<span class="keyword">go</span>:<span class="number">102</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c LegacyRESTStorageProvider)</span> <span class="title">NewLegacyRESTStorage</span><span class="params">(restOptionsGetter generic.RESTOptionsGetter)</span> <span class="params">(LegacyRESTStorage, genericapiserver.  APIGroupInfo, error)</span></span> &#123;</span><br><span class="line">    apiGroupInfo := genericapiserver.APIGroupInfo&#123;</span><br><span class="line">        PrioritizedVersions:          legacyscheme.Scheme.PrioritizedVersionsForGroup(<span class="string">""</span>),</span><br><span class="line">        VersionedResourcesStorageMap: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;&#125;,</span><br><span class="line">        Scheme:                       legacyscheme.Scheme,</span><br><span class="line">        ParameterCodec:               legacyscheme.ParameterCodec,</span><br><span class="line">        NegotiatedSerializer:         legacyscheme.Codecs,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> podDisruptionClient policyclient.PodDisruptionBudgetsGetter</span><br><span class="line">    <span class="keyword">if</span> policyGroupVersion := (schema.GroupVersion&#123;Group: <span class="string">"policy"</span>, Version: <span class="string">"v1beta1"</span>&#125;); legacyscheme.Scheme.                               IsVersionRegistered(policyGroupVersion) &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        podDisruptionClient, err = policyclient.NewForConfig(c.LoopbackClientConfig)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、LegacyAPI 下的 resource RESTStorage 的初始化</span></span><br><span class="line">    restStorage := LegacyRESTStorage&#123;&#125;</span><br><span class="line"></span><br><span class="line">    podTemplateStorage, err := podtemplatestore.NewREST(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    eventStorage, err := eventstore.NewREST(restOptionsGetter, <span class="keyword">uint64</span>(c.EventTTL.Seconds()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    limitRangeStorage, err := limitrangestore.NewREST(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    endpointsStorage, err := endpointsstore.NewREST(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodeStorage, err := nodestore.NewStorage(restOptionsGetter, c.KubeletClientConfig, c.ProxyTransport)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、pod RESTStorage 的初始化</span></span><br><span class="line">    podStorage, err := podstore.NewStorage(......)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    serviceClusterIPAllocator, err := ipallocator.NewAllocatorCIDRRange(&amp;serviceClusterIPRange, <span class="function"><span class="keyword">func</span><span class="params">(max <span class="keyword">int</span>, rangeSpec <span class="keyword">string</span>)</span> <span class="params">(allocator. Interface, error)</span></span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, fmt.Errorf(<span class="string">"cannot create cluster IP allocator: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    restStorage.ServiceClusterIPAllocator = serviceClusterIPRegistry</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> secondaryServiceClusterIPAllocator ipallocator.Interface</span><br><span class="line">    <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.IPv6DualStack) &amp;&amp; c.SecondaryServiceIPRange.IP != <span class="literal">nil</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> serviceNodePortRegistry rangeallocation.RangeRegistry</span><br><span class="line">    serviceNodePortAllocator, err := portallocator.NewPortAllocatorCustom(c.ServiceNodePortRange, <span class="function"><span class="keyword">func</span><span class="params">(max <span class="keyword">int</span>, rangeSpec <span class="keyword">string</span>)</span>      <span class="params">(allocator.Interface, error)</span></span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, fmt.Errorf(<span class="string">"cannot create cluster port allocator: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    restStorage.ServiceNodePortAllocator = serviceNodePortRegistry</span><br><span class="line"></span><br><span class="line">    controllerStorage, err := controllerstore.NewStorage(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LegacyRESTStorage&#123;&#125;, genericapiserver.APIGroupInfo&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serviceRest, serviceRestProxy := servicestore.NewREST(......)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、restStorageMap 保存 resource http path 与 RESTStorage 对应关系</span></span><br><span class="line">    restStorageMap := <span class="keyword">map</span>[<span class="keyword">string</span>]rest.Storage&#123;</span><br><span class="line">        <span class="string">"pods"</span>:             podStorage.Pod,</span><br><span class="line">        <span class="string">"pods/attach"</span>:      podStorage.Attach,</span><br><span class="line">        <span class="string">"pods/status"</span>:      podStorage.Status,</span><br><span class="line">        <span class="string">"pods/log"</span>:         podStorage.Log,</span><br><span class="line">        <span class="string">"pods/exec"</span>:        podStorage.Exec,</span><br><span class="line">        <span class="string">"pods/portforward"</span>: podStorage.PortForward,</span><br><span class="line">        <span class="string">"pods/proxy"</span>:       podStorage.Proxy,</span><br><span class="line">        ......</span><br><span class="line">        <span class="string">"componentStatuses"</span>: componentstatus.NewStorage(componentStatusStorage&#123;c.StorageFactory&#125;.serversToValidate),</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="podstore-NewStorage"><a href="#podstore-NewStorage" class="headerlink" title="podstore.NewStorage"></a>podstore.NewStorage</h5><p><code>podstore.NewStorage</code> 是为 pod 生成 storage 的方法，该方法主要功能是为 pod 创建后端存储最终返回一个 RESTStorage 对象，其中调用 <code>store.CompleteWithOptions</code> 来创建后端存储的。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">k8s.io<span class="meta-keyword">/kubernetes/</span>pkg<span class="meta-keyword">/registry/</span>core<span class="meta-keyword">/pod/</span>storage/storage.go:<span class="number">71</span></span><br><span class="line">func NewStorage(......) (PodStorage, error) &#123;</span><br><span class="line">    store := <span class="variable">&amp;genericregistry</span>.Store&#123;</span><br><span class="line"><span class="symbol">        NewFunc:</span>                  func() runtime.<span class="class">Object </span>&#123; return <span class="variable">&amp;api</span>.Pod&#123;&#125; &#125;,</span><br><span class="line"><span class="symbol">        NewListFunc:</span>              func() runtime.<span class="class">Object </span>&#123; return <span class="variable">&amp;api</span>.PodList&#123;&#125; &#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    options := <span class="variable">&amp;generic</span>.StoreOptions&#123;</span><br><span class="line"><span class="symbol">        RESTOptions:</span> optsGetter,</span><br><span class="line"><span class="symbol">        AttrFunc:</span>    pod.GetAttrs,</span><br><span class="line"><span class="symbol">        TriggerFunc:</span> map[string]storage.IndexerFunc&#123;<span class="string">"spec.nodeName"</span>: pod.NodeNameTriggerFunc&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 store.CompleteWithOptions</span></span><br><span class="line">    if err := store.CompleteWithOptions(options); err != <span class="class">nil </span>&#123;</span><br><span class="line">        return PodStorage&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    statusStore := *store</span><br><span class="line">    statusStore.UpdateStrategy = pod.StatusStrategy</span><br><span class="line">    ephemeralContainersStore := *store</span><br><span class="line">    ephemeralContainersStore.UpdateStrategy = pod.EphemeralContainersStrategy</span><br><span class="line"></span><br><span class="line">    bindingREST := <span class="variable">&amp;</span>BindingREST&#123;store: store&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PodStorage 对象</span></span><br><span class="line">    return PodStorage&#123;</span><br><span class="line"><span class="symbol">        Pod:</span>                 <span class="variable">&amp;</span>REST&#123;store, proxyTransport&#125;,</span><br><span class="line"><span class="symbol">        Binding:</span>             <span class="variable">&amp;</span>BindingREST&#123;store: store&#125;,</span><br><span class="line"><span class="symbol">        LegacyBinding:</span>       <span class="variable">&amp;</span>LegacyBindingREST&#123;bindingREST&#125;,</span><br><span class="line"><span class="symbol">        Eviction:</span>            newEvictionStorage(store, podDisruptionBudgetClient),</span><br><span class="line"><span class="symbol">        Status:</span>              <span class="variable">&amp;</span>StatusREST&#123;store: <span class="variable">&amp;</span>statusStore&#125;,</span><br><span class="line"><span class="symbol">        EphemeralContainers:</span> <span class="variable">&amp;</span>EphemeralContainersREST&#123;store: <span class="variable">&amp;</span>ephemeralContainersStore&#125;,</span><br><span class="line"><span class="symbol">        Log:</span>                 <span class="variable">&amp;podrest</span>.LogREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line"><span class="symbol">        Proxy:</span>               <span class="variable">&amp;podrest</span>.ProxyREST&#123;Store: store, ProxyTransport: proxyTransport&#125;,</span><br><span class="line"><span class="symbol">        Exec:</span>                <span class="variable">&amp;podrest</span>.ExecREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line"><span class="symbol">        Attach:</span>              <span class="variable">&amp;podrest</span>.AttachREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line"><span class="symbol">        PortForward:</span>         <span class="variable">&amp;podrest</span>.PortForwardREST&#123;Store: store, KubeletConn: k&#125;,</span><br><span class="line">    &#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终返回的对象里对 pod 的不同操作都是一个 REST 对象，REST 中自动集成了 <code>genericregistry.Store</code> 对象，而 <code>store.CompleteWithOptions</code> 方法就是对 <code>genericregistry.Store</code> 对象中存储实例就行初始化的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type REST struct &#123;</span><br><span class="line">    *genericregistry.Store</span><br><span class="line">    proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BindingREST struct &#123;</span><br><span class="line">    store *genericregistry.Store</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><h5 id="store-CompleteWithOptions"><a href="#store-CompleteWithOptions" class="headerlink" title="store.CompleteWithOptions"></a>store.CompleteWithOptions</h5><p><code>store.CompleteWithOptions</code> 主要功能是为 store 中的配置设置一些默认的值以及根据提供的 options 更新 store，其中最主要的就是初始化 store 的后端存储实例。</p><p>在<code>CompleteWithOptions</code>方法内，调用了<code>options.RESTOptions.GetRESTOptions</code> 方法，其最终返回<code>generic.RESTOptions</code> 对象，<code>generic.RESTOptions</code> 对象中包含对 etcd 初始化的一些配置、数据序列化方法以及对 etcd 操作的 storage.Interface 对象。其会依次调用<code>StorageWithCacher--&gt;NewRawStorage--&gt;Create</code>方法创建最终依赖的后端存储。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go:1192</span><br><span class="line">func (e *Store) CompleteWithOptions(options *generic.StoreOptions) error &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="attribute">var isNamespaced bool</span></span><br><span class="line"><span class="attribute">    switch &#123;</span></span><br><span class="line"><span class="attribute">    case e.CreateStrategy != nil</span>:</span><br><span class="line">        isNamespaced = e<span class="variable">.CreateStrategy</span><span class="variable">.NamespaceScoped</span>()</span><br><span class="line">    case e<span class="variable">.UpdateStrategy</span> != nil:</span><br><span class="line">        isNamespaced = e<span class="variable">.UpdateStrategy</span><span class="variable">.NamespaceScoped</span>()</span><br><span class="line">    default:</span><br><span class="line">        return fmt<span class="variable">.Errorf</span>("store for %s must have CreateStrategy or UpdateStrategy set", e<span class="variable">.DefaultQualifiedResource</span><span class="variable">.String</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 1、调用 options<span class="variable">.RESTOptions</span><span class="variable">.GetRESTOptions</span> </span><br><span class="line">    opts, err := options<span class="variable">.RESTOptions</span><span class="variable">.GetRESTOptions</span>(e<span class="variable">.DefaultQualifiedResource</span>)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、设置 ResourcePrefix </span><br><span class="line">    prefix := opts<span class="variable">.ResourcePrefix</span></span><br><span class="line">    if !strings<span class="variable">.HasPrefix</span>(prefix, "/") &#123;</span><br><span class="line">        prefix = "/" + prefix</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if prefix == "/" &#123;</span><br><span class="line">        return fmt<span class="variable">.Errorf</span>("store for %s has an invalid prefix %q", e<span class="variable">.DefaultQualifiedResource</span><span class="variable">.String</span>(), opts<span class="variable">.ResourcePrefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if e<span class="variable">.KeyRootFunc</span> == nil &amp;&amp; e<span class="variable">.KeyFunc</span> == nil &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyFunc := func(obj runtime<span class="variable">.Object</span>) (string, error) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、以下操作主要是将 opts 对象中的值赋值到 store 对象中</span><br><span class="line">    if e<span class="variable">.DeleteCollectionWorkers</span> == 0 &#123;</span><br><span class="line">        e<span class="variable">.DeleteCollectionWorkers</span> = opts<span class="variable">.DeleteCollectionWorkers</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e<span class="variable">.EnableGarbageCollection</span> = opts<span class="variable">.EnableGarbageCollection</span></span><br><span class="line">    if e<span class="variable">.ObjectNameFunc</span> == nil &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if e<span class="variable">.Storage</span><span class="variable">.Storage</span> == nil &#123;</span><br><span class="line">        e<span class="variable">.Storage</span><span class="variable">.Codec</span> = opts<span class="variable">.StorageConfig</span><span class="variable">.Codec</span></span><br><span class="line">        var err error</span><br><span class="line">        e<span class="variable">.Storage</span><span class="variable">.Storage</span>, e<span class="variable">.DestroyFunc</span>, err = opts<span class="variable">.Decorator</span>(</span><br><span class="line">            opts<span class="variable">.StorageConfig</span>,</span><br><span class="line">            prefix,</span><br><span class="line">            keyFunc,</span><br><span class="line">            e<span class="variable">.NewFunc</span>,</span><br><span class="line">            e<span class="variable">.NewListFunc</span>,</span><br><span class="line">            attrFunc,</span><br><span class="line">            options<span class="variable">.TriggerFunc</span>,</span><br><span class="line">        )</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        e<span class="variable">.StorageVersioner</span> = opts<span class="variable">.StorageConfig</span><span class="variable">.EncodeVersioner</span></span><br><span class="line"></span><br><span class="line">        if opts<span class="variable">.CountMetricPollPeriod</span> &gt; 0 &#123;</span><br><span class="line">            stopFunc := e<span class="variable">.startObservingCount</span>(opts<span class="variable">.CountMetricPollPeriod</span>)</span><br><span class="line">            previousDestroy := e<span class="variable">.DestroyFunc</span></span><br><span class="line">            e<span class="variable">.DestroyFunc</span> = func() &#123;</span><br><span class="line">                stopFunc()</span><br><span class="line">                if previousDestroy != nil &#123;</span><br><span class="line">                    previousDestroy()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options.RESTOptions</code> 是一个 interface，想要找到其 <code>GetRESTOptions</code> 方法的实现必须知道 <code>options.RESTOptions</code> 初始化时对应的实例，其初始化是在 <code>CreateKubeAPIServerConfig --&gt; buildGenericConfig --&gt; s.Etcd.ApplyWithStorageFactoryTo</code> 方法中进行初始化的，<code>RESTOptions</code> 对应的实例为 <code>StorageFactoryRestOptionsFactory</code>，所以 PodStorage 初始时构建的 store 对象中<code>genericserver.Config.RESTOptionsGetter</code> 实际的对象类型为 <code>StorageFactoryRestOptionsFactory</code>，其 <code>GetRESTOptions</code> 方法如下所示：</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/server/options/etcd.go:253</span><br><span class="line">func (f *StorageFactoryRestOptionsFactory) GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, error) &#123;</span><br><span class="line">    <span class="attribute">storageConfig, err</span> := f<span class="variable">.StorageFactory</span><span class="variable">.NewConfig</span>(resource)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return generic<span class="variable">.RESTOptions</span>&#123;&#125;, fmt<span class="variable">.Errorf</span>("unable to find storage destination for %v, due to %v", resource, err<span class="variable">.Error</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret := generic<span class="variable">.RESTOptions</span>&#123;</span><br><span class="line">        StorageConfig:           storageConfig,</span><br><span class="line">        Decorator:               generic<span class="variable">.UndecoratedStorage</span>,</span><br><span class="line">        DeleteCollectionWorkers: f<span class="variable">.Options</span><span class="variable">.DeleteCollectionWorkers</span>,</span><br><span class="line">        EnableGarbageCollection: f<span class="variable">.Options</span><span class="variable">.EnableGarbageCollection</span>,</span><br><span class="line">        ResourcePrefix:          f<span class="variable">.StorageFactory</span><span class="variable">.ResourcePrefix</span>(resource),</span><br><span class="line">        CountMetricPollPeriod:   f<span class="variable">.Options</span><span class="variable">.StorageConfig</span><span class="variable">.CountMetricPollPeriod</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    if f<span class="variable">.Options</span><span class="variable">.EnableWatchCache</span> &#123;</span><br><span class="line">        sizes, err := ParseWatchCacheSizes(f<span class="variable">.Options</span><span class="variable">.WatchCacheSizes</span>)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return generic<span class="variable">.RESTOptions</span>&#123;&#125;, err</span><br><span class="line">        &#125;</span><br><span class="line">        cacheSize, ok := sizes[resource]</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            cacheSize = f<span class="variable">.Options</span><span class="variable">.DefaultWatchCacheSize</span></span><br><span class="line">        &#125;</span><br><span class="line">        // 调用 generic<span class="variable">.StorageDecorator</span></span><br><span class="line">        ret<span class="variable">.Decorator</span> = genericregistry<span class="variable">.StorageWithCacher</span>(cacheSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>genericregistry.StorageWithCacher</code> 中又调用了不同的方法最终会调用 <code>factory.Create</code> 来初始化存储实例，其调用链为：<code>genericregistry.StorageWithCacher --&gt; generic.NewRawStorage --&gt; factory.Create</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/factory.go:<span class="number">30</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(<span class="built_in">c</span> storagebackend.Config)</span></span> (storage.<span class="type">Interface</span>, <span class="type">DestroyFunc</span>, error) &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">c</span>.<span class="type">Type</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"etcd2"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.<span class="type">Errorf</span>(<span class="string">"%v is no longer a supported storage backend"</span>, <span class="built_in">c</span>.<span class="type">Type</span>)</span><br><span class="line">    <span class="comment">// 目前 k8s 只支持使用 etcd v3</span></span><br><span class="line">    <span class="keyword">case</span> storagebackend.<span class="type">StorageTypeUnset</span>, storagebackend.<span class="type">StorageTypeETCD3</span>:</span><br><span class="line">        <span class="keyword">return</span> newETCD3Storage(<span class="built_in">c</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.<span class="type">Errorf</span>(<span class="string">"unknown storage type: %s"</span>, <span class="built_in">c</span>.<span class="type">Type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="newETCD3Storage"><a href="#newETCD3Storage" class="headerlink" title="newETCD3Storage"></a>newETCD3Storage</h6><p>在 <code>newETCD3Storage</code> 中，首先通过调用 <code>newETCD3Client</code> 创建 etcd 的 client，client 的创建最终是通过 etcd 官方提供的客户端工具 <a href="https://github.com/etcd-io/etcd/tree/master/clientv3" target="_blank" rel="external nofollow noopener noreferrer">clientv3</a> 进行创建的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go:<span class="number">209</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newETCD3Storage</span><span class="params">(<span class="built_in">c</span> storagebackend.Config)</span></span> (storage.<span class="type">Interface</span>, <span class="type">DestroyFunc</span>, error) &#123;</span><br><span class="line">    stopCompactor, err := startCompactorOnce(<span class="built_in">c</span>.<span class="type">Transport</span>, <span class="built_in">c</span>.<span class="type">CompactionInterval</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client, err := newETCD3Client(<span class="built_in">c</span>.<span class="type">Transport</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        stopCompactor()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> once sync.<span class="type">Once</span></span><br><span class="line">    destroyFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.<span class="type">Do</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            stopCompactor()</span><br><span class="line">            client.<span class="type">Close</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    transformer := <span class="built_in">c</span>.<span class="type">Transformer</span></span><br><span class="line">    <span class="keyword">if</span> transformer == <span class="literal">nil</span> &#123;</span><br><span class="line">        transformer = value.<span class="type">IdentityTransformer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> etcd3.<span class="type">New</span>(client, <span class="built_in">c</span>.<span class="type">Codec</span>, <span class="built_in">c</span>.<span class="type">Prefix</span>, transformer, <span class="built_in">c</span>.<span class="type">Paging</span>), destroyFunc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此对于 pod resource 中 store 的构建基本分析完成，不同 resource 对应一个 REST 对象，其中又引用了 <code>genericregistry.Store</code> 对象，最终是对 <code>genericregistry.Store</code> 的初始化。在分析完 store 的初始化后还有一个重要的步骤就是路由的注册，路由注册主要的流程是为 resource 根据不同 verbs 构建 http path 以及将 path 与对应 handler 进行绑定。</p><h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>上文 RESTStorage 的构建对应的是 <code>InstallLegacyAPI</code> 中的 <code>legacyRESTStorageProvider.NewLegacyRESTStorage</code> 方法，下面继续分析 <code>InstallLegacyAPI</code> 中的 <code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 方法的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/pkg/master/master.<span class="keyword">go</span>:<span class="number">406</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(......)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error building core storage: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>m.GenericAPIServer.InstallLegacyAPIGroup</code> 的调用链非常深，最终是为 Group 下每一个 API resources 注册 handler 及路由信息，其调用链为：<code>m.GenericAPIServer.InstallLegacyAPIGroup --&gt; s.installAPIResources --&gt; apiGroupVersion.InstallREST --&gt; installer.Install --&gt; a.registerResourceHandlers</code>。其中几个方法的作用如下所示：</p><ul><li><code>s.installAPIResources</code>：为每一个 API resource 调用 <code>apiGroupVersion.InstallREST</code> 添加路由；</li><li><code>apiGroupVersion.InstallREST</code>：将 <code>restful.WebServic</code> 对象添加到 container 中；</li><li><code>installer.Install</code>：返回最终的 <code>restful.WebService</code> 对象</li></ul><h5 id="a-registerResourceHandlers"><a href="#a-registerResourceHandlers" class="headerlink" title="a.registerResourceHandlers"></a>a.registerResourceHandlers</h5><p>该方法实现了 <code>rest.Storage</code> 到 <code>restful.Route</code> 的转换，其首先会判断 API Resource 所支持的 REST 接口，然后为 REST 接口添加对应的 handler，最后将其注册到路由中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/installer.<span class="keyword">go</span>:<span class="number">181</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *APIInstaller)</span> <span class="title">registerResourceHandlers</span><span class="params">(path <span class="keyword">string</span>, storage rest.Storage, ws *restful.WebService)</span> <span class="params">(*metav1.APIResource, error)</span></span> &#123;       </span><br><span class="line">    admit := a.group.Admit</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 1、判断该 resource 实现了哪些 REST 操作接口，以此来判断其支持的 verbs 以便为其添加路由</span></span><br><span class="line">    creater, isCreater := storage.(rest.Creater)</span><br><span class="line">    namedCreater, isNamedCreater := storage.(rest.NamedCreater)</span><br><span class="line">    lister, isLister := storage.(rest.Lister)</span><br><span class="line">    getter, isGetter := storage.(rest.Getter)</span><br><span class="line">    getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)</span><br><span class="line">    gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)</span><br><span class="line">    collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)</span><br><span class="line">    updater, isUpdater := storage.(rest.Updater)</span><br><span class="line">    patcher, isPatcher := storage.(rest.Patcher)</span><br><span class="line">    watcher, isWatcher := storage.(rest.Watcher)</span><br><span class="line">    connecter, isConnecter := storage.(rest.Connecter)</span><br><span class="line">    storageMeta, isMetadata := storage.(rest.StorageMetadata)</span><br><span class="line">    storageVersionProvider, isStorageVersionProvider := storage.(rest.StorageVersionProvider)</span><br><span class="line">    <span class="keyword">if</span> !isMetadata &#123;</span><br><span class="line">        storageMeta = defaultStorageMetadata&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exporter, isExporter := storage.(rest.Exporter)</span><br><span class="line">    <span class="keyword">if</span> !isExporter &#123;</span><br><span class="line">        exporter = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、为 resource 添加对应的 actions 并根据是否支持 namespace </span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> !namespaceScoped:</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"LIST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isLister)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"POST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCreater)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"DELETECOLLECTION"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCollectionDeleter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"WATCHLIST"</span>, <span class="string">"watch/"</span> + resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, allowWatchList)</span><br><span class="line"></span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isGetter)</span><br><span class="line">        <span class="keyword">if</span> getSubpath &#123;</span><br><span class="line">            actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="literal">false</span>&#125;, isGetter)</span><br><span class="line">        &#125;</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"PUT"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isUpdater)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"PATCH"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isPatcher)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"DELETE"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isGracefulDeleter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"WATCH"</span>, <span class="string">"watch/"</span> + itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isWatcher)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"CONNECT"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isConnecter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"CONNECT"</span>, itemPath + <span class="string">"/&#123;path:*&#125;"</span>, proxyParams, namer, <span class="literal">false</span>&#125;, isConnecter &amp;&amp; connectSubpath)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ......</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"LIST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isLister)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"POST"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCreater)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"DELETECOLLECTION"</span>, resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, isCollectionDeleter)</span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"WATCHLIST"</span>, <span class="string">"watch/"</span> + resourcePath, resourceParams, namer, <span class="literal">false</span>&#125;, allowWatchList)</span><br><span class="line"></span><br><span class="line">        actions = appendIf(actions, action&#123;<span class="string">"GET"</span>, itemPath, nameParams, namer, <span class="literal">false</span>&#125;, isGetter)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、根据 action 创建对应的 route</span></span><br><span class="line">    kubeVerbs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    reqScope := handlers.RequestScope&#123;</span><br><span class="line">        Serializer:      a.group.Serializer,</span><br><span class="line">        ParameterCodec:  a.group.ParameterCodec,</span><br><span class="line">        Creater:         a.group.Creater,</span><br><span class="line">        Convertor:       a.group.Convertor,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 4、从 rest.Storage 到 restful.Route 映射</span></span><br><span class="line">    <span class="comment">// 为每个操作添加对应的 handler</span></span><br><span class="line">    <span class="keyword">for</span> _, action := <span class="keyword">range</span> actions &#123;</span><br><span class="line">        ......</span><br><span class="line">        verbOverrider, needOverride := storage.(StorageMetricsOverride)</span><br><span class="line">        <span class="keyword">switch</span> action.Verb &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"GET"</span>: ......</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"LIST"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"PUT"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"PATCH"</span>:</span><br><span class="line">        <span class="comment">// 此处以 POST 操作进行说明</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"POST"</span>: </span><br><span class="line">            <span class="keyword">var</span> handler restful.RouteFunction</span><br><span class="line">            <span class="comment">// 5、初始化 handler</span></span><br><span class="line">            <span class="keyword">if</span> isNamedCreater &#123;</span><br><span class="line">                handler = restfulCreateNamedResource(namedCreater, reqScope, admit)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler = restfulCreateResource(creater, reqScope, admit)</span><br><span class="line">            &#125;</span><br><span class="line">            handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)</span><br><span class="line">            article := GetArticleForNoun(kind, <span class="string">" "</span>)</span><br><span class="line">            doc := <span class="string">"create"</span> + article + kind</span><br><span class="line">            <span class="keyword">if</span> isSubresource &#123;</span><br><span class="line">                doc = <span class="string">"create "</span> + subresource + <span class="string">" of"</span> + article + kind</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6、route 与 handler 进行绑定</span></span><br><span class="line">            route := ws.POST(action.Path).To(handler).</span><br><span class="line">                Doc(doc).</span><br><span class="line">                Param(ws.QueryParameter(<span class="string">"pretty"</span>, <span class="string">"If 'true', then the output is pretty printed."</span>)).</span><br><span class="line">                Operation(<span class="string">"create"</span>+namespaced+kind+strings.Title(subresource)+operationSuffix).</span><br><span class="line">                Produces(<span class="built_in">append</span>(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).</span><br><span class="line">                Returns(http.StatusOK, <span class="string">"OK"</span>, producedObject).</span><br><span class="line">                Returns(http.StatusCreated, <span class="string">"Created"</span>, producedObject).</span><br><span class="line">                Returns(http.StatusAccepted, <span class="string">"Accepted"</span>, producedObject).</span><br><span class="line">                Reads(defaultVersionedObject).</span><br><span class="line">                Writes(producedObject)</span><br><span class="line">            <span class="keyword">if</span> err := AddObjectParams(ws, route, versionedCreateOptions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            addParams(route, action.Params)</span><br><span class="line">            <span class="comment">// 7、添加到路由中</span></span><br><span class="line">            routes = <span class="built_in">append</span>(routes, route)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"DELETE"</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"DELETECOLLECTION"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"WATCH"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"WATCHLIST"</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"CONNECT"</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> &amp;apiResource, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="restfulCreateNamedResource"><a href="#restfulCreateNamedResource" class="headerlink" title="restfulCreateNamedResource"></a>restfulCreateNamedResource</h5><p><code>restfulCreateNamedResource</code> 是 POST 操作对应的 handler，最终会调用 <code>createHandler</code> 方法完成。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/installer.go:<span class="number">1087</span></span><br><span class="line">func restful<span class="constructor">CreateNamedResource(<span class="params">r</span> <span class="params">rest</span>.NamedCreater, <span class="params">scope</span> <span class="params">handlers</span>.RequestScope, <span class="params">admit</span> <span class="params">admission</span>.Interface)</span> restful.RouteFunction &#123;</span><br><span class="line">    return func(req *restful.Request, res *restful.Response) &#123;</span><br><span class="line">        handlers.<span class="constructor">CreateNamedResource(<span class="params">r</span>, &amp;<span class="params">scope</span>, <span class="params">admit</span>)</span>(res.ResponseWriter, req.Request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="constructor">CreateNamedResource(<span class="params">r</span> <span class="params">rest</span>.NamedCreater, <span class="params">scope</span> <span class="operator">*</span>RequestScope, <span class="params">admission</span> <span class="params">admission</span>.Interface)</span> http.HandlerFunc &#123;</span><br><span class="line">    return create<span class="constructor">Handler(<span class="params">r</span>, <span class="params">scope</span>, <span class="params">admission</span>, <span class="params">true</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="createHandler"><a href="#createHandler" class="headerlink" title="createHandler"></a>createHandler</h5><p><code>createHandler</code> 是将数据写入到后端存储的方法，对于资源的操作都有相关的权限控制，在 <code>createHandler</code> 中首先会执行 <code>decoder</code> 和 <code>admission</code> 操作，然后调用 <code>create</code> 方法完成 resource 的创建，在 <code>create</code> 方法中会进行 <code>validate</code> 以及最终将数据保存到后端存储中。<code>admit</code> 操作即执行 kube-apiserver 中的 admission-plugins，admission-plugins 在 <code>CreateKubeAPIServerConfig</code> 中被初始化为了 admissionChain，其初始化的调用链为 <code>CreateKubeAPIServerConfig --&gt; buildGenericConfig --&gt; s.Admission.ApplyTo --&gt; a.GenericAdmission.ApplyTo --&gt; a.Plugins.NewFromPlugins</code>，最终在 <code>a.Plugins.NewFromPlugins</code> 中将所有已启用的 plugins 封装为 admissionChain，此处要执行的 admit 操作即执行 admission-plugins 中的 admit 操作。</p><p><code>createHandler</code> 中调用的 create 方法是<code>genericregistry.Store</code> 对象的方法，在每个 resource 初始化 RESTStorage 都会引入 <code>genericregistry.Store</code> 对象。</p><p><code>createHandler</code> 中所有的操作就是本文开头提到的请求流程，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |    ⇒       |    ⇒  v1  ⇒ json/yaml ⇒ etcd</span><br><span class="line">                     admission    validation</span><br><span class="line">k8s.io/kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.<span class="keyword">go</span>:<span class="number">46</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createHandler</span><span class="params">(r rest.NamedCreater, scope *RequestScope, admit admission.Interface, includeName <span class="keyword">bool</span>)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        trace := utiltrace.New(<span class="string">"Create"</span>, utiltrace.Field&#123;<span class="string">"url"</span>, req.URL.Path&#125;)</span><br><span class="line">        <span class="keyword">defer</span> trace.LogIfLong(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        gv := scope.Kind.GroupVersion()</span><br><span class="line">        <span class="comment">// 1、得到合适的SerializerInfo</span></span><br><span class="line">        s, err := negotiation.NegotiateInputSerializer(req, <span class="literal">false</span>, scope.Serializer)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            scope.err(err, w, req)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、找到合适的 decoder</span></span><br><span class="line">        decoder := scope.Serializer.DecoderToVersion(s.Serializer, scope.HubGroupVersion)</span><br><span class="line"></span><br><span class="line">        body, err := limitedReadBody(req, scope.MaxRequestBodyBytes)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            scope.err(err, w, req)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        defaultGVK := scope.Kind</span><br><span class="line">        original := r.New()</span><br><span class="line">        trace.Step(<span class="string">"About to convert to expected version"</span>)</span><br><span class="line">        <span class="comment">// 3、decoder 解码</span></span><br><span class="line">        obj, gvk, err := decoder.Decode(body, &amp;defaultGVK, original)</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        ae := request.AuditEventFrom(ctx)</span><br><span class="line">        admit = admission.WithAudit(admit, ae)</span><br><span class="line">        audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)</span><br><span class="line"></span><br><span class="line">        userInfo, _ := request.UserFrom(ctx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">            _, name, _ = scope.Namer.ObjectName(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、执行 admit 操作，即执行 kube-apiserver 启动时加载的 admission-plugins，</span></span><br><span class="line">        admissionAttributes := admission.NewAttributesRecord(......)</span><br><span class="line">        <span class="keyword">if</span> mutatingAdmission, ok := admit.(admission.MutationInterface); ok &amp;&amp; mutatingAdmission.Handles(admission.Create) &#123;</span><br><span class="line">            err = mutatingAdmission.Admit(ctx, admissionAttributes, scope)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                scope.err(err, w, req)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 5、执行 create 操作</span></span><br><span class="line">        result, err := finishRequest(timeout, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r.Create(</span><br><span class="line">                ctx,</span><br><span class="line">                name,</span><br><span class="line">                obj,</span><br><span class="line">                rest.AdmissionToValidateObjectFunc(admit, admissionAttributes, scope),</span><br><span class="line">                options,</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析 kube-apiserver 的启动流程，kube-apiserver 中包含三个 server，分别为 KubeAPIServer、APIExtensionsServer 以及 AggregatorServer，三个 server 是通过委托模式连接在一起的，初始化过程都是类似的，首先为每个 server 创建对应的 config，然后初始化 http server，http server 的初始化过程为首先初始化 <code>GoRestfulContainer</code>，然后安装 server 所包含的 API，安装 API 时首先为每个 API Resource 创建对应的后端存储 RESTStorage，再为每个 API Resource 支持的 verbs 添加对应的 handler，并将 handler 注册到 route 中，最后将 route 注册到 webservice 中，启动流程中 RESTFul API 的实现流程是其核心，至于 kube-apiserver 中认证鉴权等 filter 的实现、多版本资源转换、kubernetes service 的实现等一些细节会在后面的文章中继续进行分析。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>在<code>cmd/kube-apiserver/apiserver.go</code>的main包中启动apiserver，使用<code>options</code>包中的<code>NewServerRunOptions()</code>函数初始化默认配置，并使用<code>pflag</code>包和<code>AddFlags()</code>方法通过命令行启动参数填充配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">s := options.NewServerRunOptions()</span><br><span class="line">s.AddFlags(pflag.CommandLine)</span><br><span class="line"></span><br><span class="line">flag.InitFlags()</span><br><span class="line">logs.InitLogs()</span><br><span class="line"><span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := app.Run(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后调用<code>app</code>包中的<code>Run()</code>函数启动实例，将创建的<code>ServerRunOptions</code>对象传入<code>app.Run()</code>中，并创建一个http server和一个https server。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run()让apiserver跑起来，永远不会退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(s *options.ServerRunOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">genericvalidation.VerifyEtcdServersList(s.GenericServerRunOptions)</span><br><span class="line">genericapiserver.DefaultAndValidateRunOptions(s.GenericServerRunOptions)</span><br><span class="line">genericConfig := genericapiserver.NewConfig(). <span class="comment">// create the new config</span></span><br><span class="line">ApplyOptions(s.GenericServerRunOptions). <span class="comment">// apply the options selected</span></span><br><span class="line">Complete()                               <span class="comment">// set default values based on the known values</span></span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">  </span><br><span class="line">m, err := config.Complete().New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sharedInformers.Start(wait.NeverStop)</span><br><span class="line">m.GenericAPIServer.PrepareRun().Run(wait.NeverStop)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要用于生成master实例对象，<code>m, err := config.Complete().New()</code> 用来创建master，<code>Complete()</code>完善Config的初始化，<code>New()</code>进行resources的初始化和RESTful-api的注册，各种api的请求最后都是通过master对象来处理的，在最后APIServer会通过启动<code>Run(wait.NeverStop)</code>的方法来启动HTTP/HTTPS服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s preparedGenericAPIServer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.SecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.Handler != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := s.serveSecurely(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.InsecureServingInfo != <span class="literal">nil</span> &amp;&amp; s.InsecureHandler != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := s.serveInsecurely(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.RunPostStartHooks()</span><br><span class="line"></span><br><span class="line"><span class="comment">// err == systemd.SdNotifyNoSocket when not running on a systemd system</span></span><br><span class="line"><span class="keyword">if</span> err := systemd.SdNotify(<span class="string">"READY=1\n"</span>); err != <span class="literal">nil</span> &amp;&amp; err != systemd.SdNotifyNoSocket &#123;</span><br><span class="line">glog.Errorf(<span class="string">"Unable to send systemd daemon successful start message: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个Run()中实际由<code>s.serveSecurely(stopCh)</code>和<code>s.serveInsecurely(stopCh)</code>分别运行了https和http server。</p><p>而实际上，<code>s.serveSecurely(stopCh)</code>和<code>s.serveInsecurely(stopCh)</code>中都会调用<code>runServer()</code>函数来运行http和https server，<code>runServer()</code>会监听传入的端口号，调用goroutine持续服务直到<code>stopCH</code>这个只读通道关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runServer</span><span class="params">(server *http.Server, network <span class="keyword">string</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(server.Addr) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"address cannot be empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(network) == <span class="number">0</span> &#123;</span><br><span class="line">network = <span class="string">"tcp"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first listen is synchronous (fail early!)</span></span><br><span class="line">ln, err := net.Listen(network, server.Addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"failed to listen on %v: %v"</span>, server.Addr, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get port</span></span><br><span class="line">tcpAddr, ok := ln.Addr().(*net.TCPAddr)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">ln.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"invalid listen address: %q"</span>, ln.Addr().String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock := sync.Mutex&#123;&#125; <span class="comment">// to avoid we close an old listener during a listen retry</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-stopCh</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">ln.Close()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> listener net.Listener</span><br><span class="line">listener = tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;</span><br><span class="line"><span class="keyword">if</span> server.TLSConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">listener = tls.NewListener(listener, server.TLSConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := server.Serve(listener)</span><br><span class="line">glog.Errorf(<span class="string">"Error serving %v (%v); will try again."</span>, server.Addr, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen again</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line"></span><br><span class="line">ln, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">glog.Errorf(<span class="string">"Error listening on %v (%v); will try again."</span>, server.Addr, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tcpAddr.Port, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以整个apiserver的启动主体过程就是下图： <img alt="apiserver start" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_start.png"></p><h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><h3 id="type-APIRegistrationManager-struct"><a href="#type-APIRegistrationManager-struct" class="headerlink" title="type APIRegistrationManager struct"></a>type APIRegistrationManager struct</h3><p><code>APIRegistrationManager</code>负责对外提供已经注册并enable了的<code>GroupVersions</code>，将所有已经注册的，已经enable的，第三方的的<code>GroupVersions</code>进行了汇总，还包括了各个<code>GroupVersion</code>的<code>GroupMeta</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIRegistrationManager <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// registeredGroupVersions stores all API group versions for which RegisterGroup is called.</span></span><br><span class="line">    <span class="comment">//所有已经registered的GroupVersions都是通过调用RegisterVersions()方法来进行注册的</span></span><br><span class="line"></span><br><span class="line">registeredVersions <span class="keyword">map</span>[unversioned.GroupVersion]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thirdPartyGroupVersions are API versions which are dynamically</span></span><br><span class="line"><span class="comment">// registered (and unregistered) via API calls to the apiserver</span></span><br><span class="line"><span class="comment">//第三方注册的GroupVersions,这些都向apiServer动态注册的使用AddThirdPartyAPIGroupVersions()进行注册</span></span><br><span class="line"></span><br><span class="line">thirdPartyGroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// enabledVersions represents all enabled API versions. It should be a</span></span><br><span class="line"><span class="comment">// subset of registeredVersions. Please call EnableVersions() to add</span></span><br><span class="line"><span class="comment">// enabled versions.</span></span><br><span class="line"><span class="comment">//所有已经enable的GroupVersions，可以通过EnableVersions()将要enable的GroupVersion加入进来。只有enable了，才能使用对应的GroupVersion</span></span><br><span class="line"></span><br><span class="line">enabledVersions <span class="keyword">map</span>[unversioned.GroupVersion]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map of group meta for all groups.</span></span><br><span class="line"><span class="comment">// 所有groups的GroupMeta</span></span><br><span class="line"></span><br><span class="line">groupMetaMap <span class="keyword">map</span>[<span class="keyword">string</span>]*apimachinery.GroupMeta</span><br><span class="line"></span><br><span class="line"><span class="comment">// envRequestedVersions represents the versions requested via the</span></span><br><span class="line"><span class="comment">// KUBE_API_VERSIONS environment variable. The install package of each group</span></span><br><span class="line"><span class="comment">// checks this list before add their versions to the latest package and</span></span><br><span class="line"><span class="comment">// Scheme.  This list is small and order matters, so represent as a slice</span></span><br><span class="line"><span class="comment">//存储KUBE_API_VERSIONS环境变量包含的版本，如果未指定，则KUBE_API_VERSIONS为空</span></span><br><span class="line"></span><br><span class="line">envRequestedVersions []unversioned.GroupVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-GroupVersion-struct"><a href="#type-GroupVersion-struct" class="headerlink" title="type GroupVersion struct"></a>type GroupVersion struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GroupVersion</code>中就是两个string类型，<code>Group</code>和<code>Version</code>，分别对应了api所处的分组和版本，这也是kubernetes实现多版本的基础。</p><h3 id="type-GroupMeta-struct"><a href="#type-GroupMeta-struct" class="headerlink" title="type GroupMeta struct"></a>type GroupMeta struct</h3><p><code>GroupMeta</code>主要包括Group的元信息，里面的成员RESTMapper，与APIGroupVersion一样，其实APIGroupVersion的RESTMapper直接取值于GroupMeta的RESTMapper。一个Group可能包含多个版本，存储在 GroupVersions 中，而 GroupVersion 是默认存储在etcd中的版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupMeta <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// GroupVersion represents the preferred version of the group.</span></span><br><span class="line"><span class="comment">// 该group的默认版本</span></span><br><span class="line">GroupVersion unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupVersions is Group + all versions in that group.</span></span><br><span class="line"><span class="comment">// 该Group中可能会有多个版本，该字段就包含了所有的versions</span></span><br><span class="line">GroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// Codec is the default codec for serializing output that should use</span></span><br><span class="line"><span class="comment">// the preferred version.  Use this Codec when writing to</span></span><br><span class="line"><span class="comment">// disk, a data store that is not dynamically versioned, or in tests.</span></span><br><span class="line"><span class="comment">// This codec can decode any object that the schema is aware of.</span></span><br><span class="line"><span class="comment">// 用于编解码</span></span><br><span class="line">Codec runtime.Codec</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelfLinker can set or get the SelfLink field of all API types.</span></span><br><span class="line"><span class="comment">// to go through the InterfacesFor method below.</span></span><br><span class="line">SelfLinker runtime.SelfLinker</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known</span></span><br><span class="line"><span class="comment">// versions.</span></span><br><span class="line"><span class="comment">// RESTMapper提供 REST路径 与 那些在api.Scheme和所有已知版本中声明的对象之间的默认映射。用于类型，对象之间的转换</span></span><br><span class="line"></span><br><span class="line">RESTMapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesFor returns the default Codec and ResourceVersioner for a given version</span></span><br><span class="line"><span class="comment">// string, or an error if the version is not known.</span></span><br><span class="line"><span class="comment">// function provided below once every place that populates this field has been changed.</span></span><br><span class="line">InterfacesFor <span class="function"><span class="keyword">func</span><span class="params">(version unversioned.GroupVersion)</span> <span class="params">(*meta.VersionInterfaces, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesByVersion stores the per-version interfaces.</span></span><br><span class="line">InterfacesByVersion <span class="keyword">map</span>[unversioned.GroupVersion]*meta.VersionInterfaces</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-RESTMapper-interface"><a href="#type-RESTMapper-interface" class="headerlink" title="type RESTMapper interface"></a>type RESTMapper interface</h3><p><code>RESTMapper</code>是一个接口，<code>RESTMapper</code>可以从GVR获取GVK，并生成一个<code>RESTMapping</code>来处理该GVR</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RESTMapper allows clients to map resources to kind, and map kind and version</span></span><br><span class="line"><span class="comment">// to interfaces for manipulating those objects. It is primarily intended for</span></span><br><span class="line"><span class="comment">// consumers of Kubernetes compatible REST APIs as defined in docs/devel/api-conventions.md.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Kubernetes API provides versioned resources and object kinds which are scoped</span></span><br><span class="line"><span class="comment">// to API groups. In other words, kinds and resources should not be assumed to be</span></span><br><span class="line"><span class="comment">// unique across groups.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RESTMapper <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// KindFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches</span></span><br><span class="line">KindFor(resource unversioned.GroupVersionResource) (unversioned.GroupVersionKind, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// KindsFor takes a partial resource and returns the list of potential kinds in priority order</span></span><br><span class="line">KindsFor(resource unversioned.GroupVersionResource) ([]unversioned.GroupVersionKind, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourceFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches</span></span><br><span class="line">ResourceFor(input unversioned.GroupVersionResource) (unversioned.GroupVersionResource, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourcesFor takes a partial resource and returns the list of potential resource in priority order</span></span><br><span class="line">ResourcesFor(input unversioned.GroupVersionResource) ([]unversioned.GroupVersionResource, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTMapping identifies a preferred resource mapping for the provided group kind.</span></span><br><span class="line"><span class="comment">// RESTMapping为指定的group kind 生成一个resource mapping。</span></span><br><span class="line">RESTMapping(gk unversioned.GroupKind, versions ...<span class="keyword">string</span>) (*RESTMapping, error)</span><br><span class="line"><span class="comment">// RESTMappings returns all resource mappings for the provided group kind.</span></span><br><span class="line">RESTMappings(gk unversioned.GroupKind) ([]*RESTMapping, error)</span><br><span class="line"></span><br><span class="line">AliasesForResource(resource <span class="keyword">string</span>) ([]<span class="keyword">string</span>, <span class="keyword">bool</span>)</span><br><span class="line">ResourceSingularizer(resource <span class="keyword">string</span>) (singular <span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GroupVersionKind-GroupVersionResource-GroupKind"><a href="#GroupVersionKind-GroupVersionResource-GroupKind" class="headerlink" title="GroupVersionKind GroupVersionResource GroupKind"></a>GroupVersionKind GroupVersionResource GroupKind</h3><p>通过结构体字段可以发现，它们其实就是Group、Version、Kind、Resource的不同组合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Kind    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">Group    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Resource <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Kind  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>Resource就是指定了一个名字和kind的资源对象，不管它有没有namespace。 resource是通过<code>plural, singular := KindToResource(kind)</code>取值，singular是将Kind转换为小写字母，而plural是变为复数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// name is the name of the resource.</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"><span class="comment">// namespaced indicates if a resource is namespaced or not.</span></span><br><span class="line">Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line"><span class="comment">// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')</span></span><br><span class="line">Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reousrce := unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"nodes"</span>, </span><br><span class="line">Namespaced: <span class="literal">false</span>,</span><br><span class="line">Kind:       <span class="string">"Node"</span>, </span><br><span class="line">&#125;</span><br><span class="line">reousrce = unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"pods"</span>,</span><br><span class="line">Namespaced: <span class="literal">true</span>,</span><br><span class="line">Kind:       <span class="string">"Pod"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h4><p>Kind就是一个资源对象对应的种类 kind是通过<code>Kind=reflector.TypeOf(&amp;Pod{}).Elem().Name()</code>进行取值，取得的就是Pod这个结构体的名字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> PodList <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> NodeList <span class="keyword">struct</span></span><br></pre></td></tr></table></figure><h4 id="Group-Version"><a href="#Group-Version" class="headerlink" title="Group Version"></a>Group Version</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Group=<span class="string">"core"</span></span><br><span class="line">Version=v1</span><br><span class="line"></span><br><span class="line">Group=<span class="string">"apps"</span></span><br><span class="line">Version=v1beta1</span><br></pre></td></tr></table></figure><p>各个Group是相互独立的，发展速度也不同，所有每个Group都会有不同的Version，而kubernetes是通过插件的方式来使用各个Group的，可以根据需求决定使用哪个Group。</p><h3 id="type-RESTMapping-struct"><a href="#type-RESTMapping-struct" class="headerlink" title="type RESTMapping struct"></a>type RESTMapping struct</h3><p>RESTMapping包含一个Resource名称，及其对应的GVK，一个Scope(标明资源是否为root或者namespaced)，一个Convertor用来转换该GVK对应的Object和一个MetadataAccessor用来提取Object的meta信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RESTMapping <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Resource is a string representing the name of this resource as a REST client would see it</span></span><br><span class="line">Resource <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">GroupVersionKind unversioned.GroupVersionKind</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scope contains the information needed to deal with REST Resources that are in a resource hierarchy</span></span><br><span class="line">Scope RESTScope</span><br><span class="line"></span><br><span class="line">runtime.ObjectConvertor</span><br><span class="line">MetadataAccessor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-RESTScope-interface"><a href="#type-RESTScope-interface" class="headerlink" title="type RESTScope interface"></a>type RESTScope interface</h3><p>RESTScope用于标识某个资源是处于Namespace下，还是全局资源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"></span><br><span class="line">RESTScopeNameNamespace RESTScopeName = <span class="string">"namespace"</span></span><br><span class="line">RESTScopeNameRoot      RESTScopeName = <span class="string">"root"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTScope contains the information needed to deal with REST resources that are in a resource hierarchy</span></span><br><span class="line"><span class="comment">// RESTScope包含处理资源层次结构中的REST资源所需的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RESTScope <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Name of the scope</span></span><br><span class="line">Name() RESTScopeName</span><br><span class="line"><span class="comment">// ParamName is the optional name of the parameter that should be inserted in the resource url</span></span><br><span class="line"><span class="comment">// If empty, no param will be inserted</span></span><br><span class="line">ParamName() <span class="keyword">string</span></span><br><span class="line"><span class="comment">// ArgumentName is the optional name that should be used for the variable holding the value.</span></span><br><span class="line">ArgumentName() <span class="keyword">string</span></span><br><span class="line"><span class="comment">// ParamDescription is the optional description to use to document the parameter in api documentation</span></span><br><span class="line">ParamDescription() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-ObjectConvertor-interface"><a href="#type-ObjectConvertor-interface" class="headerlink" title="type ObjectConvertor interface"></a>type ObjectConvertor interface</h3><p>Convertor用来转换该GVK对应的Object</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectConvertor converts an object to a different version.</span></span><br><span class="line"><span class="comment">// ObjectConvertor将一个object转换为不同的版本。</span></span><br><span class="line"><span class="keyword">type</span> ObjectConvertor <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Convert attempts to convert one object into another, or returns an error. This method does</span></span><br><span class="line"><span class="comment">// not guarantee the in object is not mutated. The context argument will be passed to</span></span><br><span class="line"><span class="comment">// all nested conversions.</span></span><br><span class="line">Convert(in, out, context <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"><span class="comment">// ConvertToVersion takes the provided object and converts it the provided version. This</span></span><br><span class="line"><span class="comment">// method does not guarantee that the in object is not mutated. This method is similar to</span></span><br><span class="line"><span class="comment">// Convert() but handles specific details of choosing the correct output version.</span></span><br><span class="line">ConvertToVersion(in Object, gv GroupVersioner) (out Object, err error)</span><br><span class="line">ConvertFieldLabel(version, kind, label, value <span class="keyword">string</span>) (<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-MetadataAccessor-interface"><a href="#type-MetadataAccessor-interface" class="headerlink" title="type MetadataAccessor interface"></a>type MetadataAccessor interface</h3><p><code>type MetadataAccessor interface</code>可以让你在任何external version或者internal version中操作object和list这些metadata</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MetadataAccessor <span class="keyword">interface</span> &#123;</span><br><span class="line">APIVersion(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">SetAPIVersion(obj runtime.Object, version <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">Kind(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">SetKind(obj runtime.Object, kind <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">Namespace(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">SetNamespace(obj runtime.Object, namespace <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">Name(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">SetName(obj runtime.Object, name <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">GenerateName(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">SetGenerateName(obj runtime.Object, name <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">UID(obj runtime.Object) (types.UID, error)</span><br><span class="line">SetUID(obj runtime.Object, uid types.UID) error</span><br><span class="line"></span><br><span class="line">SelfLink(obj runtime.Object) (<span class="keyword">string</span>, error)</span><br><span class="line">SetSelfLink(obj runtime.Object, selfLink <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">Labels(obj runtime.Object) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span><br><span class="line">SetLabels(obj runtime.Object, labels <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">Annotations(obj runtime.Object) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span><br><span class="line">SetAnnotations(obj runtime.Object, annotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">runtime.ResourceVersioner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//runtime.Object 定义在/pkg/runtime/interfaces.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All API types registered with Scheme must support the Object interface. Since objects in a scheme are</span></span><br><span class="line"><span class="comment">// expected to be serialized to the wire, the interface an Object must provide to the Scheme allows</span></span><br><span class="line"><span class="comment">// serializers to set the kind, version, and group the object is represented as. An Object may choose</span></span><br><span class="line"><span class="comment">// to return a no-op ObjectKindAccessor in cases where it is not expected to be serialized.</span></span><br><span class="line"><span class="comment">// 在Scheme中注册的所有API类型都必须支持Object接口。这是因为在scheme中的objects是会被序列化成线的，所以一个Object必须提供接口给scheme来序列化地设置其kind、version、group。在不需要序列化的情况下，Object可以选择返回一个无操作的ObjectKindAccessor。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span> &#123;</span><br><span class="line">GetObjectKind() unversioned.ObjectKind</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourceVersioner provides methods for setting and retrieving</span></span><br><span class="line"><span class="comment">// the resource version from an API object.</span></span><br><span class="line"><span class="comment">// 设置和接收一个API object的resource version</span></span><br><span class="line"><span class="keyword">type</span> ResourceVersioner <span class="keyword">interface</span> &#123;</span><br><span class="line">SetResourceVersion(obj Object, version <span class="keyword">string</span>) error</span><br><span class="line">ResourceVersion(obj Object) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多版本资源注册"><a href="#多版本资源注册" class="headerlink" title="多版本资源注册"></a>多版本资源注册</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>在<code>pkg/master/import_known_versions.go</code>中会初始化所有group的install包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> master</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k8s现阶段，API一共分为13个Group：</span></span><br><span class="line"><span class="comment">Core、</span></span><br><span class="line"><span class="comment">apps、authentication、authorization、</span></span><br><span class="line"><span class="comment">autoscaling、batch、certificates、componentconfig、</span></span><br><span class="line"><span class="comment">extensions、imagepolicy、policy、rbac、storage。</span></span><br><span class="line"><span class="comment">其中Core的Group Name为空，它包含的API是最核心的API,如Pod、Service等，它的代码位于pkg/api下面。</span></span><br><span class="line"><span class="comment">其它12个Group代码位于pkg/apis。</span></span><br><span class="line"><span class="comment">每个目录下都有一个install目录，里面有一个install.go文件，接着通过init()负责初始化。</span></span><br><span class="line"><span class="comment">所有的install都是通过下面的import进行导入的！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These imports are the API groups the API server will support.</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/api/install"</span></span><br><span class="line"><span class="string">"k8s.io/kubernetes/pkg/apimachinery/registered"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/apps/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/authentication/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/authorization/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/autoscaling/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/batch/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/certificates/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/componentconfig/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/extensions/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/imagepolicy/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/policy/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/rbac/install"</span></span><br><span class="line">_ <span class="string">"k8s.io/kubernetes/pkg/apis/storage/install"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> missingVersions := registered.ValidateEnvRequestedVersions(); <span class="built_in">len</span>(missingVersions) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"KUBE_API_VERSIONS contains versions that are not installed: %q."</span>, missingVersions))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有的<code>/install/install.go</code>文件中，都会生成<code>groupMeta</code>，并向<code>registered.DefaultAPIRegistrationManager</code>注册。这个<code>groupMeta</code>中包含一个<code>DefaultRESTMapper</code> 以<code>pkg/api/install/install.go</code>中core group的install包为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过registered.RegisterVersions将core group所有的versions注册到DefaultAPIRegistrationManager中</span></span><br><span class="line">registered.RegisterVersions(availableVersions)</span><br><span class="line">externalVersions := []unversioned.GroupVersion&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> availableVersions &#123;</span><br><span class="line">        <span class="comment">// 判断下环境变量KUBE_API_VERSIONS的设置是否允许该gv，并append成一个切片，默认情况下，是不会设置环境变量KUBE_API_VERSIONS，就Core Group而言，此时externalVersions的值应该是 v1</span></span><br><span class="line"><span class="keyword">if</span> registered.IsAllowedVersion(v) &#123;</span><br><span class="line">externalVersions = <span class="built_in">append</span>(externalVersions, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(externalVersions) == <span class="number">0</span> &#123;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"No version is registered for group %v"</span>, api.GroupName)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再进行gv的enable，其实就是存入APIRegistrationManager.enabledVersions</span></span><br><span class="line"><span class="keyword">if</span> err := registered.EnableVersions(externalVersions...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := enableVersions(externalVersions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步的<code>err := enableVersions(externalVersions)</code>非常重要，完成了填充Scheme，初始化groupMeta的步骤：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enableVersions</span><span class="params">(externalVersions []unversioned.GroupVersion)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将所有的GroupVersions添加到Scheme</span></span><br><span class="line">    </span><br><span class="line">    addVersionsToScheme(externalVersions...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将第一个GroupVersion作为默认的值 ""/v1</span></span><br><span class="line">    </span><br><span class="line">preferredExternalVersion := externalVersions[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里开始进行GroupMeta的初始化。主要是用external versions去填充GroupMeta以及其成员RESTMapper。GroupMeta主要用于初始化APIGroupVersion</span></span><br><span class="line">    </span><br><span class="line">groupMeta := apimachinery.GroupMeta&#123;</span><br><span class="line">GroupVersion:  preferredExternalVersion,</span><br><span class="line">GroupVersions: externalVersions,</span><br><span class="line">RESTMapper:    newRESTMapper(externalVersions),</span><br><span class="line">SelfLinker:    runtime.SelfLinker(accessor),</span><br><span class="line">InterfacesFor: interfacesFor,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// registered.RegisterGroup(groupMeta)其实就是以第一个GroupVersion的groupName为key，groupMeta为value，向APIRegistrationManager注册了v1版本的groupMeta。所有group的/install/install.go文件中，都会生成groupMeta，并向registered.DefaultAPIRegistrationManager注册</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> err := registered.RegisterGroup(groupMeta); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addVersionsToScheme：将所有的Versions添加到Scheme</li><li>生成一个groupMeta，即groupMeta的初始化</li><li>registered.RegisterGroup(groupMeta)，真正注册一个group</li></ul><p>其中<code>newRESTMapper(externalVersions)</code>其实包含的是一种转换关系，resource到kind，kind到resource，kind到scope的转换。 <code>RESTMapper</code>映射是指GVR(<code>GroupVersionResource</code>)和GVK(<code>GroupVersionKind</code>)的关系，可以通过GVR找到合适的GVK</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRESTMapper</span><span class="params">(externalVersions []unversioned.GroupVersion)</span> <span class="title">meta</span>.<span class="title">RESTMapper</span></span> &#123;</span><br><span class="line"><span class="comment">// the list of kinds that are scoped at the root of the api hierarchy</span></span><br><span class="line"><span class="comment">// if a kind is not enumerated here, it is assumed to have a namespace scope</span></span><br><span class="line"><span class="comment">//rootScoped枚举列出的是API最顶层的对象，可以理解为没有namespace的对象。</span></span><br><span class="line">rootScoped := sets.NewString(</span><br><span class="line"><span class="string">"Node"</span>,</span><br><span class="line"><span class="string">"Namespace"</span>,</span><br><span class="line"><span class="string">"PersistentVolume"</span>,</span><br><span class="line"><span class="string">"ComponentStatus"</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// these kinds should be excluded from the list of resources</span></span><br><span class="line"><span class="comment">//ignoredKinds是下面接口需要用到的参数，表示遍历Scheme时忽略这些kinds。</span></span><br><span class="line">ignoredKinds := sets.NewString(</span><br><span class="line"><span class="string">"ListOptions"</span>,</span><br><span class="line"><span class="string">"DeleteOptions"</span>,</span><br><span class="line"><span class="string">"Status"</span>,</span><br><span class="line"><span class="string">"PodLogOptions"</span>,</span><br><span class="line"><span class="string">"PodExecOptions"</span>,</span><br><span class="line"><span class="string">"PodAttachOptions"</span>,</span><br><span class="line"><span class="string">"PodProxyOptions"</span>,</span><br><span class="line"><span class="string">"NodeProxyOptions"</span>,</span><br><span class="line"><span class="string">"ServiceProxyOptions"</span>,</span><br><span class="line"><span class="string">"ThirdPartyResource"</span>,</span><br><span class="line"><span class="string">"ThirdPartyResourceData"</span>,</span><br><span class="line"><span class="string">"ThirdPartyResourceList"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用api.NewDefaultRESTMapper()，</span></span><br><span class="line"><span class="comment">==&gt;定义在pkg/api/mapper.go</span></span><br><span class="line"><span class="comment">==&gt;func NewDefaultRESTMapper</span></span><br><span class="line"><span class="comment">importPrefix 的值为："k8s.io/kubernetes/pkg/api"，</span></span><br><span class="line"><span class="comment">externalVersions: [v1]</span></span><br><span class="line"><span class="comment">interfacesFor是一个函数func interfacesFor(version unversioned.GroupVersion)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mapper := api.NewDefaultRESTMapper(externalVersions, interfacesFor, importPrefix, ignoredKinds, rootScoped)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>NewDefaultRESTMapper</code>定义在<code>pkg/api/mapper.go</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据在api.Scheme中注册的types来实例化一个DefaultRESTMapper</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultRESTMapper</span><span class="params">(defaultGroupVersions []unversioned.GroupVersion, interfacesFunc meta.VersionInterfacesFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">importPathPrefix <span class="keyword">string</span>, ignoredKinds, rootScoped sets.String)</span> *<span class="title">meta</span>.<span class="title">DefaultRESTMapper</span></span> &#123;</span><br><span class="line"><span class="comment">// 指定一个Scheme,并继续调用下面的接口</span></span><br><span class="line"><span class="keyword">return</span> NewDefaultRESTMapperFromScheme(defaultGroupVersions, interfacesFunc, importPathPrefix, ignoredKinds, rootScoped, Scheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再调用<code>NewDefaultRESTMapperFromScheme</code>函数，它主要流程是：</p><ol><li>先创建了一个空的<code>DefaultRESTMapper</code>,</li><li>然后根据”<code>/api/v1</code>“的<code>groupVersion</code>（只举了其中的一个<code>groupversion</code>，所以可以依据<code>defaultGroupVersions</code>来区别<code>DefaultRESTMapper</code>）,</li><li>遍历Scheme中所有的kinds，</li><li>接着再调用<code>mapper.Add(gvk, scope)</code>去填充这个mapper，</li><li>最后返回该mapper。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基于指定的 Scheme 中注册的“types”实例化一个DefaultRESTMapper</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">scope=RESTScopeNamespace或RESTScopeRoot</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NewDefaultRESTMapperFromScheme()函数依据传入的defaultGroupVersions和interfacesFunc参数生成mapper，</span></span><br><span class="line"><span class="comment">然后把在Scheme中defaultGroupVersions下的资源注册到mapper中。</span></span><br><span class="line"><span class="comment">这里的Scheme即api.Scheme，全部的类型都会注册到api.Scheme中。</span></span><br><span class="line"><span class="comment">所以可以依据defaultGroupVersions来区别DefaultRESTMapper。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultRESTMapperFromScheme</span><span class="params">(defaultGroupVersions []unversioned.GroupVersion, interfacesFunc meta.VersionInterfacesFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">importPathPrefix <span class="keyword">string</span>, ignoredKinds, rootScoped sets.String, scheme *runtime.Scheme)</span> *<span class="title">meta</span>.<span class="title">DefaultRESTMapper</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化了一个DefaultRESTMapper对象</span></span><br><span class="line"><span class="comment">meta.NewDefaultRESTMapper定义在/pkg/api/meta/restmapper.go</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mapper := meta.NewDefaultRESTMapper(defaultGroupVersions, interfacesFunc)</span><br><span class="line">fmt.Println(<span class="string">"defaultGroupVersions is: "</span>, reflect.ValueOf(defaultGroupVersions))</span><br><span class="line">fmt.Println(<span class="string">"initial time, mapper is: "</span>, reflect.ValueOf(mapper))</span><br><span class="line"><span class="comment">// enumerate all supported versions, get the kinds, and register with the mapper how to address</span></span><br><span class="line"><span class="comment">// our resources.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历所有支持的versions，获取kinds，在mapper中注册如何去address our resource</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据输入的defaultGroupVersions,比如"/api/v1"，</span></span><br><span class="line"><span class="comment">从Scheme中遍历所有的kinds，</span></span><br><span class="line"><span class="comment">然后进行Add</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> _, gv := <span class="keyword">range</span> defaultGroupVersions &#123;</span><br><span class="line"><span class="comment">//从scheme获取一个指定GV的所有Type</span></span><br><span class="line"><span class="keyword">for</span> kind, oType := <span class="keyword">range</span> scheme.KnownTypes(gv) &#123;</span><br><span class="line">fmt.Println(<span class="string">"gv, kind is:"</span>, gv, kind)</span><br><span class="line">gvk := gv.WithKind(kind)</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove import path check.</span></span><br><span class="line"><span class="comment">// We check the import path because we currently stuff both "api" and "extensions" objects</span></span><br><span class="line"><span class="comment">// into the same group within Scheme since Scheme has no notion of groups yet.</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> !strings.Contains(oType.PkgPath(), importPathPrefix) || ignoredKinds.Has(kind) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该kind是否有namespace属性</span></span><br><span class="line">scope := meta.RESTScopeNamespace</span><br><span class="line"><span class="keyword">if</span> rootScoped.Has(kind) &#123;</span><br><span class="line">scope = meta.RESTScopeRoot</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">然后将该gvk加入到对应的组中</span></span><br><span class="line"><span class="comment">Add定义在/pkg/api/meta/restmapper.go</span></span><br><span class="line"><span class="comment">==&gt;func (m *DefaultRESTMapper) Add(kind unversioned.GroupVersionKind, scope RESTScope)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mapper.Add(gvk, scope)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>mapper.Add(gvk, scope)</code>方法是把GVK（kind）和GVK对应的scope加入到<code>DefaultRESTMapper</code>对应的map属性中</p><p><code>type DefaultRESTMapper struct</code>中字段的含义：</p><ul><li>defaultGroupVersions: 默认的GroupVersion，如v1，apps/v1beta1等，一般一个DefaultRESTMapper只设一个默认的GroupVersion</li><li>resourceToKind：GVR(单数,复数)到GVK的map；</li><li>kindToPluralResource：GVK到GVR(复数)的map；</li><li>kindToScope：GVK到Scope的map；</li><li>singularToPlural：GVR(单数)到GVR(复数)的map；</li><li>interfacesFunc：用来产生Convertor和MetadataAccessor，具体实现为/pkg/api/install/install.go中的interfacesFor()函数。</li><li>aliasToResource：用于将别名映射到资源</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DefaultRESTMapper <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">defaultGroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line">resourceToKind       <span class="keyword">map</span>[unversioned.GroupVersionResource]unversioned.GroupVersionKind</span><br><span class="line">kindToPluralResource <span class="keyword">map</span>[unversioned.GroupVersionKind]unversioned.GroupVersionResource</span><br><span class="line">kindToScope          <span class="keyword">map</span>[unversioned.GroupVersionKind]RESTScope</span><br><span class="line">singularToPlural     <span class="keyword">map</span>[unversioned.GroupVersionResource]unversioned.GroupVersionResource</span><br><span class="line">pluralToSingular     <span class="keyword">map</span>[unversioned.GroupVersionResource]unversioned.GroupVersionResource</span><br><span class="line"></span><br><span class="line">interfacesFunc VersionInterfacesFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// aliasToResource is used for mapping aliases to resources</span></span><br><span class="line">aliasToResource <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addVersionsToScheme</code>：将所有的Versions添加到Scheme，Apiserver全局范围内，只有一个Scheme，即api.Scheme。 所有的GroupVersion受这个api.Scheme管理。所有的GroupVersion的Type都是往这个全局唯一的api.Scheme里面注册。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scheme`定义在`pkg/api/register.go`，`NewScheme()`定义在`/pkg/runtime/scheme.go</span><br><span class="line">var Scheme = runtime.NewScheme()</span><br></pre></td></tr></table></figure><p>在Scheme的定义里面</p><ul><li>一个Type，就是一个特定的Go Struct</li><li>一个Version，是该Type的特定表示的时间点标识符（通常向后兼容）</li><li>一个Kind，是一个Type在该Version中的唯一name</li><li>一个Group，标识了一组Versions, Kinds, and Types</li><li>一个Unversioned Type，是一种还没正式绑定到一个Type的Type，会被往后兼容</li></ul><p><code>RESTMapper</code>管理的是GVR和GVK的关系，<code>Scheme</code>管理的是GVK和Type的关系</p><p>在<code>pkg/runtime/scheme.go</code>中，定义了<code>type Scheme struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// versionMap allows one to figure out the go type of an object with</span></span><br><span class="line"><span class="comment">// the given version and name.</span></span><br><span class="line"><span class="comment">// 用gvk找出对应的Type，一个gvk只能对应一个Type</span></span><br><span class="line">gvkToType <span class="keyword">map</span>[unversioned.GroupVersionKind]reflect.Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeToGroupVersion allows one to find metadata for a given go object.</span></span><br><span class="line"><span class="comment">// The reflect.Type we index by should *not* be a pointer.</span></span><br><span class="line"><span class="comment">// 存储Type和gvk的关系，一个type可能对应多个GVK</span></span><br><span class="line">typeToGVK <span class="keyword">map</span>[reflect.Type][]unversioned.GroupVersionKind</span><br><span class="line"></span><br><span class="line"><span class="comment">// unversionedTypes are transformed without conversion in ConvertToVersion.</span></span><br><span class="line"><span class="comment">// 记录没有版本控制的Type（即unversionedTypes）和GVK的关系，unversionedTypes无需版本转换</span></span><br><span class="line">unversionedTypes <span class="keyword">map</span>[reflect.Type]unversioned.GroupVersionKind</span><br><span class="line"></span><br><span class="line"><span class="comment">// unversionedKinds are the names of kinds that can be created in the context of any group</span></span><br><span class="line"><span class="comment">// or version</span></span><br><span class="line">    <span class="comment">// 记录unversioned的GVK和Type的关系</span></span><br><span class="line">unversionedKinds <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map from version and resource to the corresponding func to convert</span></span><br><span class="line"><span class="comment">// resource field labels in that version to internal version.</span></span><br><span class="line">fieldLabelConversionFuncs <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]FieldLabelConversionFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// defaulterFuncs is an array of interfaces to be called with an object to provide defaulting</span></span><br><span class="line"><span class="comment">// the provided object must be a pointer.</span></span><br><span class="line">defaulterFuncs <span class="keyword">map</span>[reflect.Type]<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// converter stores all registered conversion functions. It also has</span></span><br><span class="line"><span class="comment">// default coverting behavior.</span></span><br><span class="line"><span class="comment">// converter存储所有注册转换函数。 它还具有默认转换功能。用来转换不同版本的结构体值</span></span><br><span class="line">converter *conversion.Converter</span><br><span class="line"></span><br><span class="line"><span class="comment">// cloner stores all registered copy functions. It also has default</span></span><br><span class="line"><span class="comment">// deep copy behavior.</span></span><br><span class="line"><span class="comment">// 用来获取结构体值的拷贝</span></span><br><span class="line">cloner *conversion.Cloner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kubernetes内部组件的流通的结构体值使用的是内部版本，所有的外部版本都要向内部版本进行转换； 内部版本必须转换成外部版本才能进行输出。 外部版本之间不能直接转换。 etcd中存储的是带有版本的数据</p><p>在<code>addVersionsToScheme()</code>函数中，主要就是向Scheme注册internal version和external version</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addVersionsToScheme</span><span class="params">(externalVersions ...unversioned.GroupVersion)</span></span> &#123;</span><br><span class="line"><span class="comment">// add the internal version to Scheme</span></span><br><span class="line">    <span class="comment">/* 将internal version加入到api.Scheme。</span></span><br><span class="line"><span class="comment">Scheme就是在pkg/api/register.go中初始化的</span></span><br><span class="line"><span class="comment">var Scheme = runtime.NewScheme()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := api.AddToScheme(api.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Programmer error, detect immediately</span></span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add the enabled external versions to Scheme</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> externalVersions &#123;</span><br><span class="line"><span class="keyword">if</span> !registered.IsEnabledVersion(v) &#123;</span><br><span class="line">glog.Errorf(<span class="string">"Version %s is not enabled, so it will not be added to the Scheme."</span>, v)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> v &#123;</span><br><span class="line"><span class="keyword">case</span> v1.SchemeGroupVersion:</span><br><span class="line"><span class="keyword">if</span> err := v1.AddToScheme(api.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Programmer error, detect immediately</span></span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>func (c completedConfig) New()</code>基于给定的配置生成一个新的Master实例，在这个方法中生成各版本资源对应的RESTful API。</p><p><code>func (c completedConfig) New()</code>方法的流程如下：</p><ol><li>调用<code>func (c completedConfig) New() (*GenericAPIServer, error)</code>，创建一<code>type GenericAPIServer struct</code>实例</li><li>判断是否enable了用于Watch的Cache，和etcd建立连接</li><li>调用<code>InstallLegacyAPI</code>进行”<code>/api</code>“的API安装</li><li>调用<code>InstallAPIs</code>进行”<code>/apis</code>“的API安装，如果其处于enabled状态</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*Master, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> reflect.DeepEqual(c.KubeletClientConfig, kubeletclient.KubeletClientConfig&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Master.New() called with empty config.KubeletClientConfig"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值s中包涵了s.HandlerContainer，也就是说s.HandlerContainer在这里完成了初始化</span></span><br><span class="line"><span class="comment">里面还完成WebService的创建，该WebService是用于list 一个group下的所有versions，因为只注册了简单的路由规则。同时把WebService注入到了s.HandlerContainer中,真正核心的注册都会在pkg/apiserver/apiserver.go中的func (g *APIGroupVersion) InstallREST 中进行</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">s, err := c.Config.GenericConfig.SkipComplete().New() <span class="comment">// completion is done in Complete, no need for a second time</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.EnableUISupport &#123;</span><br><span class="line">routes.UIRedirect&#123;&#125;.Install(s.HandlerContainer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.EnableLogsSupport &#123;</span><br><span class="line">routes.Logs&#123;&#125;.Install(s.HandlerContainer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := &amp;Master&#123;</span><br><span class="line">GenericAPIServer: s,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restOptionsFactory := restOptionsFactory&#123;</span><br><span class="line">deleteCollectionWorkers: c.DeleteCollectionWorkers,</span><br><span class="line">enableGarbageCollection: c.GenericConfig.EnableGarbageCollection,</span><br><span class="line">storageFactory:          c.StorageFactory,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    判断是否enable了用于Watch的Cache。有无cache，赋值的是不同的接口实现。</span></span><br><span class="line"><span class="comment">    有无cache的接口差异就在于：</span></span><br><span class="line"><span class="comment">有cache的话，就提供操作cache的接口；</span></span><br><span class="line"><span class="comment">无cache的话，就提供直接操作etcd的接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> c.EnableWatchCache &#123;</span><br><span class="line">restOptionsFactory.storageDecorator = registry.StorageWithCacher</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">restOptionsFactory.storageDecorator = generic.UndecoratedStorage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// install legacy rest storage</span></span><br><span class="line">    <span class="comment">// 判断/api/v1的group是否已经注册并enable，是的话再进行install</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> c.GenericConfig.APIResourceConfigSource.AnyResourcesForVersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;</span><br><span class="line">StorageFactory:       c.StorageFactory,</span><br><span class="line">ProxyTransport:       c.ProxyTransport,</span><br><span class="line">KubeletClientConfig:  c.KubeletClientConfig,</span><br><span class="line">EventTTL:             c.EventTTL,</span><br><span class="line">ServiceIPRange:       c.ServiceIPRange,</span><br><span class="line">ServiceNodePortRange: c.ServiceNodePortRange,</span><br><span class="line">LoopbackClientConfig: c.GenericConfig.LoopbackClientConfig,</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行"/api"的API安装</span></span><br><span class="line">        </span><br><span class="line">m.InstallLegacyAPI(c.Config, restOptionsFactory.NewFor, legacyRESTStorageProvider)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restStorageProviders := []genericapiserver.RESTStorageProvider&#123;</span><br><span class="line">appsrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">authenticationrest.RESTStorageProvider&#123;Authenticator: c.GenericConfig.Authenticator&#125;,</span><br><span class="line">authorizationrest.RESTStorageProvider&#123;Authorizer: c.GenericConfig.Authorizer&#125;,</span><br><span class="line">autoscalingrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">batchrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">certificatesrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">extensionsrest.RESTStorageProvider&#123;ResourceInterface: thirdparty.NewThirdPartyResourceServer(s, c.StorageFactory)&#125;,</span><br><span class="line">policyrest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">rbacrest.RESTStorageProvider&#123;AuthorizerRBACSuperUser: c.GenericConfig.AuthorizerRBACSuperUser&#125;,</span><br><span class="line">storagerest.RESTStorageProvider&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行"/apis"的API安装</span></span><br><span class="line">    </span><br><span class="line">m.InstallAPIs(c.Config.GenericConfig.APIResourceConfigSource, restOptionsFactory.NewFor, restStorageProviders...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.Tunneler != <span class="literal">nil</span> &#123;</span><br><span class="line">m.installTunneler(c.Tunneler, coreclient.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig).Nodes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>InstallLegacyAPI()</code>进行了/api的安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallLegacyAPI</span><span class="params">(c *Config, restOptionsGetter genericapiserver.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">glog.Infof(<span class="string">"生成apiGroupInfo, apiGroupInfo携带着restStorageMap"</span>)</span><br><span class="line">legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"Error building core storage: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.EnableCoreControllers &#123;</span><br><span class="line">serviceClient := coreclient.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)</span><br><span class="line"></span><br><span class="line">bootstrapController := c.NewBootstrapController(legacyRESTStorage, serviceClient)</span><br><span class="line"><span class="keyword">if</span> err := m.GenericAPIServer.AddPostStartHook(<span class="string">"bootstrap-controller"</span>, bootstrapController.PostStartHook); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"Error registering PostStartHook %q: %v"</span>, <span class="string">"bootstrap-controller"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// install core Group's API</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用InstallLegacyAPIGroup，定义在</span></span><br><span class="line"><span class="comment">==&gt;/pkg/genericapiserver/genericapiserver.go</span></span><br><span class="line"><span class="comment">==&gt;func (s *GenericAPIServer) InstallLegacyAPIGroup(apiPrefix string, apiGroupInfo *APIGroupInfo)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在<code>NewLegacyRESTStorage</code>方法中，会进行storage的创建，其流程如下：</p><ol><li>生成一个type APIGroupInfo struct实例，这个和前面说的资源注册的<code>APIRegistrationManager、Scheme、GroupMeta...</code>有关系。</li><li>初始化一个LegacyRESTStorage对象，即restStorage</li><li>创建各类Storage，如podStorage、nodeStorage..</li><li>把步骤3中创建的各种Storage保存到restStorageMap中，然后装在到APIGroupInfo中，APIGroupInfo.VersionedResourcesStorageMap[“v1”]。这是API映射map，这很重要，在后面的利用APIGroupInfo来生成APIGroupVersion的时候，就是依靠这个map映射关系来获取对应version的资源的rest strorage实现。</li><li>return restStorage, APIGroupInfo</li></ol><p><code>InstallLegacyAPIGroup()</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">InstallLegacyAPIGroup</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断前缀参数是否正确</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s.legacyAPIGroupPrefixes is: map[/api:&#123;&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> !s.legacyAPIGroupPrefixes.Has(apiPrefix) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%q is not in the allowed legacy API prefixes: %v"</span>, apiPrefix, s.legacyAPIGroupPrefixes.List())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键接口，真正install API（转化为resuful api）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := s.installAPIResources(apiPrefix, apiGroupInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup discovery</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取了该Group下所有的version信息</span></span><br><span class="line"><span class="comment">添加一个WebService，其route路径是/api</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">apiVersions := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.GroupMeta.GroupVersions &#123;</span><br><span class="line">apiVersions = <span class="built_in">append</span>(apiVersions, groupVersion.Version)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Install the version handler.</span></span><br><span class="line"><span class="comment">// Add a handler at /&lt;apiPrefix&gt; to enumerate the supported api versions.</span></span><br><span class="line">apiserver.AddApiWebService(s.Serializer, s.HandlerContainer.Container, apiPrefix, <span class="function"><span class="keyword">func</span><span class="params">(req *restful.Request)</span> *<span class="title">unversioned</span>.<span class="title">APIVersions</span></span> &#123;</span><br><span class="line">clientIP := utilnet.GetClientIP(req.Request)</span><br><span class="line"></span><br><span class="line">apiVersionsForDiscovery := unversioned.APIVersions&#123;</span><br><span class="line">ServerAddressByClientCIDRs: s.discoveryAddresses.ServerAddressByClientCIDRs(clientIP),</span><br><span class="line">Versions:                   apiVersions,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;apiVersionsForDiscovery</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>installAPIResources()</code>方法用于安装每个api groupversionresource的REST存储，基本流程如下：</p><ol><li>遍历该Group的所有versions（一个Group调用一次本函数，亦即所有Group最后都是调用本函数来安装Restful API）</li><li>基于<code>apiGroupInfo</code>, <code>groupVersion</code>, <code>apiPrefix</code>创建一个<code>type APIGroupVersion struct</code>对象</li><li>根据创建的<code>APIGroupVersion</code>,然后安装restful API，<code>apiGroupVersion.InstallREST</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GenericAPIServer)</span> <span class="title">installAPIResources</span><span class="params">(apiPrefix <span class="keyword">string</span>, apiGroupInfo *APIGroupInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 遍历该Group下的所有GroupVersons</span></span><br><span class="line"><span class="keyword">for</span> _, groupVersion := <span class="keyword">range</span> apiGroupInfo.GroupMeta.GroupVersions &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建APIGroupVersion</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">调用func (s *GenericAPIServer) getAPIGroupVersion</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">apiGroupVersion, err := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> apiGroupInfo.OptionsExternalVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">apiGroupVersion.OptionsExternalVersion = apiGroupInfo.OptionsExternalVersion</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据之前创建的APIGroupVersion,然后安装restful API</span></span><br><span class="line"><span class="comment">该s.HandlerContainer.Container就是go-restful的Container</span></span><br><span class="line"><span class="comment">InstallREST 定义在：pkg/apiserver/apiserver.go</span></span><br><span class="line"><span class="comment">==&gt;func (g *APIGroupVersion) InstallREST(container *restful.Container)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := apiGroupVersion.InstallREST(s.HandlerContainer.Container); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"Unable to setup API %v: %v"</span>, apiGroupInfo, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用<code>InstallREST()</code>安装restful API，<code>InstallREST()</code>将REST handlers（storage, watch, proxy and redirect）注册到go-restful框架的Container中，流程如下：</p><ol><li>创建了一个type APIInstaller struct对象</li><li>构造一个webservice</li><li>往webservice里面添加Route</li><li>往container中添加webservice</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *APIGroupVersion)</span> <span class="title">InstallREST</span><span class="params">(container *restful.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">newInstaller()  拼装path: "Prefix/Group/Version"</span></span><br><span class="line"><span class="comment">然后填充并返回一个APIInstaller对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">installer := g.newInstaller()</span><br><span class="line"><span class="comment">// 创建一个WebService，设置了ws的path属性</span></span><br><span class="line">ws := installer.NewWebService()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*********************************************</span></span><br><span class="line"><span class="comment">*********************************************</span></span><br><span class="line"><span class="comment">调用Install函数</span></span><br><span class="line"><span class="comment">这个是关键，会对各种URL进行注册！</span></span><br><span class="line"><span class="comment">在这个注册的过程中，InstallREST最终调用了registerResourceHandlers()接口，</span></span><br><span class="line"><span class="comment">registerResourceHandlers()接口最终会把一个rest.Storage对象转换成实际的getter、lister等处理函数，</span></span><br><span class="line"><span class="comment">并和实际的URL关联起来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">apiResources, registrationErrors := installer.Install(ws)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个list功能的API</span></span><br><span class="line"><span class="comment">添加了一个Route，对应路径是"/"</span></span><br><span class="line"><span class="comment">访问形如"Prefix/Group/Version"这样的根路径时候，返回该GroupVersion所支持的resources</span></span><br><span class="line"><span class="comment">    curl http://192.168.56.101:8080/api/v1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">lister := g.ResourceLister</span><br><span class="line"><span class="keyword">if</span> lister == <span class="literal">nil</span> &#123;</span><br><span class="line">lister = staticLister&#123;apiResources&#125;</span><br><span class="line">&#125;</span><br><span class="line">AddSupportedResourcesWebService(g.Serializer, ws, g.GroupVersion, lister)</span><br><span class="line"><span class="comment">// 将该WebService加入到Container</span></span><br><span class="line">container.Add(ws)</span><br><span class="line"><span class="keyword">return</span> utilerrors.NewAggregate(registrationErrors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstallAPIs()</code>进行/apis的安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">InstallAPIs</span><span class="params">(apiResourceConfigSource genericapiserver.APIResourceConfigSource, restOptionsGetter genericapiserver.RESTOptionsGetter, restStorageProviders ...genericapiserver.RESTStorageProvider)</span></span> &#123;</span><br><span class="line">apiGroupsInfo := []genericapiserver.APIGroupInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, restStorageBuilder := <span class="keyword">range</span> restStorageProviders &#123;</span><br><span class="line">groupName := restStorageBuilder.GroupName()</span><br><span class="line"><span class="keyword">if</span> !apiResourceConfigSource.AnyResourcesForGroupEnabled(groupName) &#123;</span><br><span class="line">glog.V(<span class="number">1</span>).Infof(<span class="string">"Skipping disabled API group %q."</span>, groupName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">apiGroupInfo, enabled := restStorageBuilder.NewRESTStorage(apiResourceConfigSource, restOptionsGetter)</span><br><span class="line"><span class="keyword">if</span> !enabled &#123;</span><br><span class="line">glog.Warningf(<span class="string">"Problem initializing API group %q, skipping."</span>, groupName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">glog.V(<span class="number">1</span>).Infof(<span class="string">"Enabling API group %q."</span>, groupName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> postHookProvider, ok := restStorageBuilder.(genericapiserver.PostStartHookProvider); ok &#123;</span><br><span class="line">name, hook, err := postHookProvider.PostStartHook()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"Error building PostStartHook: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := m.GenericAPIServer.AddPostStartHook(name, hook); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"Error registering PostStartHook %q: %v"</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apiGroupsInfo = <span class="built_in">append</span>(apiGroupsInfo, apiGroupInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> apiGroupsInfo &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用func (s *GenericAPIServer) InstallAPIGroup(apiGroupInfo *APIGroupInfo)</span></span><br><span class="line"><span class="comment">==&gt;定义在/pkg/genericapiserver/genericapiserver.go</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := m.GenericAPIServer.InstallAPIGroup(&amp;apiGroupsInfo[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"Error in registering group versions: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s, err := c.Config.GenericConfig.SkipComplete().New()</code>会根据config创建了一个<code>GenericAPIServer</code>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">()</span> <span class="params">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.Serializer == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Genericapiserver.New() called with config.Serializer == nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := &amp;GenericAPIServer&#123;</span><br><span class="line">discoveryAddresses:     c.DiscoveryAddresses,</span><br><span class="line">LoopbackClientConfig:   c.LoopbackClientConfig,</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c.LegacyAPIGroupPrefixes值是/api，取值于</span></span><br><span class="line"><span class="comment">==&gt;/pkg/genericapiserver/config.go</span></span><br><span class="line"><span class="comment">==&gt;DefaultLegacyAPIPrefix = "/api"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">legacyAPIGroupPrefixes: c.LegacyAPIGroupPrefixes,</span><br><span class="line">admissionControl:       c.AdmissionControl,</span><br><span class="line">requestContextMapper:   c.RequestContextMapper,</span><br><span class="line">Serializer:             c.Serializer,</span><br><span class="line"></span><br><span class="line">minRequestTimeout:    time.Duration(c.MinRequestTimeout) * time.Second,</span><br><span class="line">enableSwaggerSupport: c.EnableSwaggerSupport,</span><br><span class="line"></span><br><span class="line">SecureServingInfo:   c.SecureServingInfo,</span><br><span class="line">InsecureServingInfo: c.InsecureServingInfo,</span><br><span class="line">ExternalAddress:     c.ExternalAddress,</span><br><span class="line"></span><br><span class="line">apiGroupsForDiscovery: <span class="keyword">map</span>[<span class="keyword">string</span>]unversioned.APIGroup&#123;&#125;,</span><br><span class="line"></span><br><span class="line">enableOpenAPISupport: c.EnableOpenAPISupport,</span><br><span class="line">openAPIConfig:        c.OpenAPIConfig,</span><br><span class="line"></span><br><span class="line">postStartHooks: <span class="keyword">map</span>[<span class="keyword">string</span>]postStartHookEntry&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里进行了HandlerContainer的初始化</span></span><br><span class="line"><span class="comment">NewAPIContainer定义在/pkg/genericapiserver/mux/container.go</span></span><br><span class="line"><span class="comment">==&gt;func NewAPIContainer(mux *http.ServeMux, s runtime.NegotiatedSerializer) *APIContainer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">传进去的两个参数：</span></span><br><span class="line"><span class="comment">http.NewServeMux()新建了一个http的ServeMux;</span></span><br><span class="line"><span class="comment">c.Serializer则是实现了编解码序列化反序列化的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.HandlerContainer = mux.NewAPIContainer(http.NewServeMux(), c.Serializer)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面Container已创建并且也进行了初始化。该轮到WebService了，添加了WebService</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.installAPI(c.Config)</span><br><span class="line"></span><br><span class="line">s.Handler, s.InsecureHandler = c.BuildHandlerChainsFunc(s.HandlerContainer.ServeMux, c.Config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个初始化流程：</p><ol><li><code>initial.go</code>中的初始化主要用<code>internal version</code>和<code>external versions</code>填充了<code>Scheme</code>，完成了 <code>APIRegistrationManager</code>中<code>GroupMeta</code>的初始化。<code>GroupMeta</code>的主要用于后面的初始化<code>APIGroupVersion</code></li><li>初始化<code>groupMeta</code>的时候会根据<code>Scheme</code>和<code>externalVersions</code>新建一个<code>RESTMapper</code></li><li><code>/pkg/registry/core/rest/storage_core.go</code>中的<code>NewLegacyRESTStorage</code>基于上面的<code>Scheme</code>和<code>GroupMeta</code>生成了一个<code>APIGroupInfo</code></li><li>然后基于<code>APIGroupInfo</code>生成一个<code>APIGroupVersion</code></li><li>基于<code>APIGroupVersion</code>来生成<code>Restful API</code></li></ol><p>多版本资源的初始化调用图</p><p><img alt="init" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_init.png"></p><p>资源注册成RESTful API调用图</p><p><img alt="restful api" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/restfulapi_new.png"></p><h2 id="kube-apiserver端List-Watch机制"><a href="#kube-apiserver端List-Watch机制" class="headerlink" title="kube-apiserver端List-Watch机制"></a>kube-apiserver端List-Watch机制</h2><p>apiserver针对集群中的每一类资源都会与etcd建立一个连接，获取该资源的opt，watch功能是其中一个opt。kubelet、kube-controller-manager、kube-scheduler需要监控各种资源的变化， 当这些对象发生变化时(add、delete、update)，kube-apiserver能够主动通知这些组件。而apiserver端的Watch机制是建立在etcd的Watch基础上的。 etcd的watch是没有过滤功能的，而kube-apiserver增加了过滤功能，能将订阅方感兴趣的部分资源发给订阅方。</p><p>Event数据流向如下：</p><ol><li>从etcd—&gt;Cacher，是一个watchCache，存储apiserver从etcd那里watch到的对象。</li><li>结合etcd和Cacher的resourceVersion进行对比，形成一个WatchEvent，分发到各个观察者watcher中</li></ol><p>在<code>/pkg/storage/cacher.go</code>中的<code>func NewCacherFromConfig()</code>，用来创建一个新的cacher，负责服务内部的watch-list缓存请求，并在后台更新缓存，流程如下：</p><ol><li>新建一个watchCache，用来存储apiserver从etcd那里watch到的对象</li><li>新建一个listerWatcher</li><li>实例化一个type Cacher struct对象，其核心是reflector机制</li><li>启动dispatchEvents协程，分发event到各个订阅方</li><li>cacher.startCaching(stopCh)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCacherFromConfig</span><span class="params">(config CacherConfig)</span> *<span class="title">Cacher</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">新建一个watchCache，用来存储apiserver从etcd那里watch到的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">watchCache := newWatchCache(config.CacheCapacity, config.KeyFunc)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对config.Storage进行list和watch</span></span><br><span class="line"><span class="comment">config.Storage是数据源（可以简单理解为etcd、带cache的etcd），一个资源的etcd handler</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">listerWatcher := newCacherListerWatcher(config.Storage, config.ResourcePrefix, config.NewListFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give this error when it is constructed rather than when you get the</span></span><br><span class="line"><span class="comment">// first watch item, because it's much easier to track down that way.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">译：在构造时给出错误，而不是在第一次去watch该item时。因为这种方式更容易跟踪。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">编码器进行类型检查</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> obj, ok := config.Type.(runtime.Object); ok &#123;</span><br><span class="line"><span class="keyword">if</span> err := runtime.CheckCodec(config.Codec, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"storage codec doesn't seem to match given type: "</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cacher接口必然也实现了storage.Interface接口所需要的方法。</span></span><br><span class="line"><span class="comment">因为该Cacher只用于WATCH和LIST的request，</span></span><br><span class="line"><span class="comment">所以可以看下cacher提供的API,除了WATCH和LIST相关的之外的接口都是调用了之前创建的storage的API。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四个重要的成员：storage、watchCache、reflector、watchers</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cacher := &amp;Cacher&#123;</span><br><span class="line">ready: newReady(),</span><br><span class="line"><span class="comment">//config.Storage就是和etcd建立连接后返回该资源的handler</span></span><br><span class="line">storage:    config.Storage,</span><br><span class="line">objectType: reflect.TypeOf(config.Type),</span><br><span class="line"><span class="comment">//watchCache用来存储apiserver从etcd那里watch到的对象</span></span><br><span class="line">watchCache: watchCache,</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reflector这个对象，包含两个重要的数据成员listerWatcher和watchCache,</span></span><br><span class="line"><span class="comment">而listerWatcher包装了config.Storage，会对storage进行list和watch。</span></span><br><span class="line"><span class="comment">reflector工作主要是将watch到的config.Type类型的对象存放到watcherCache中。</span></span><br><span class="line"><span class="comment">==&gt;定义在/pkg/client/cache/reflector.go</span></span><br><span class="line"><span class="comment">==&gt;func NewReflector</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reflector: cache.NewReflector(listerWatcher, config.Type, watchCache, <span class="number">0</span>),</span><br><span class="line"><span class="comment">//Versioner控制resource的版本</span></span><br><span class="line">versioner:   config.Versioner,</span><br><span class="line">triggerFunc: config.TriggerPublisherFunc,</span><br><span class="line">watcherIdx:  <span class="number">0</span>,</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allWatchers、valueWatchers 都是一个map，map的值类型为cacheWatcher，</span></span><br><span class="line"><span class="comment">当kubelet、kube-scheduler需要watch某类资源时，</span></span><br><span class="line"><span class="comment">他们会向kube-apiserver发起watch请求，kube-apiserver就会生成一个cacheWatcher，</span></span><br><span class="line"><span class="comment">他们负责将watch的资源通过http从apiserver传递到kubelet、kube-scheduler</span></span><br><span class="line"><span class="comment">==&gt;event分发功能是在下面的 go cacher.dispatchEvents()中完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">watcher是kube-apiserver watch的发布方和订阅方的枢纽</span></span><br><span class="line"><span class="comment">watchers是在哪里注册添加成员的？？?</span></span><br><span class="line"><span class="comment">==&gt;func newCacheWatcher(resourceVersion uint64, chanSize int, initEvents []watchCacheEvent, filter filterObjectFunc, forget func(bool)) *cacheWatcher &#123;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">watchers: indexedWatchers&#123;</span><br><span class="line">allWatchers:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*cacheWatcher),</span><br><span class="line">valueWatchers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]watchersMap),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Figure out the correct value for the buffer size.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">incoming会被分发到 watchers中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个要和/pkg/storage/etcd/etcd_watcher.go中的channel etcdIncoming进行区分，两者不是一个通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">incoming: <span class="built_in">make</span>(<span class="keyword">chan</span> watchCacheEvent, <span class="number">100</span>),</span><br><span class="line"><span class="comment">// We need to (potentially) stop both:</span></span><br><span class="line"><span class="comment">// - wait.Until go-routine</span></span><br><span class="line"><span class="comment">// - reflector.ListAndWatch</span></span><br><span class="line"><span class="comment">// and there are no guarantees on the order that they will stop.</span></span><br><span class="line"><span class="comment">// So we will be simply closing the channel, and synchronizing on the WaitGroup.</span></span><br><span class="line">stopCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置watchCache的onEvent这个handler。</span></span><br><span class="line"><span class="comment">cacher.processEvent是incoming chan watchCacheEvent的生产者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">watchCache.SetOnEvent(cacher.processEvent)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完成event分发功能，把event分发到对应的watchers中。</span></span><br><span class="line"><span class="comment">是incoming chan watchCacheEvent的消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">go</span> cacher.dispatchEvents()</span><br><span class="line"></span><br><span class="line">stopCh := cacher.stopCh</span><br><span class="line">cacher.stopWg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cacher.stopWg.Done()</span><br><span class="line">wait.Until(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !cacher.isStopped() &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">apiserver端，list-watch机制 V1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cacher.startCaching(stopCh)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, stopCh,</span><br><span class="line">)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> cacher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startCaching()</code>方法流程如下：</p><ol><li>首先会通过terminateAllWatchers注销所有的cachewatcher,因为这个时候apiserver还处于初始化阶段，因此不可能接受其他组件的watch，也就不可能有watcher。</li><li>然后调用c.reflector.ListAndWatch函数，完成前面说过的功能：reflector主要将apiserver组件从etcd中watch到的资源存储到watchCache中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">startCaching</span><span class="params">(stopChannel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// The 'usable' lock is always 'RLock'able when it is safe to use the cache.</span></span><br><span class="line"><span class="comment">// It is safe to use the cache after a successful list until a disconnection.</span></span><br><span class="line"><span class="comment">// We start with usable (write) locked. The below OnReplace function will</span></span><br><span class="line"><span class="comment">// unlock it after a successful list. The below defer will then re-lock</span></span><br><span class="line"><span class="comment">// it when this function exits (always due to disconnection), only if</span></span><br><span class="line"><span class="comment">// we actually got a successful list. This cycle will repeat as needed.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在连接中断之前，在一个成功的lis操作之后使用cache是读写安全的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">successfulList := <span class="literal">false</span></span><br><span class="line">c.watchCache.SetOnReplace(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">successfulList = <span class="literal">true</span></span><br><span class="line">c.ready.set(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> successfulList &#123;</span><br><span class="line">c.ready.set(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//终止所有的watcher</span></span><br><span class="line">c.terminateAllWatchers()</span><br><span class="line"><span class="comment">// Note that since onReplace may be not called due to errors, we explicitly</span></span><br><span class="line"><span class="comment">// need to retry it on errors under lock.</span></span><br><span class="line"><span class="comment">// Also note that startCaching is called in a loop, so there's no need</span></span><br><span class="line"><span class="comment">// to have another loop here.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">apiserver端，list-watch机制</span></span><br><span class="line"><span class="comment">func (c *Cacher) startCaching已经是在一个循环中被调用，所以这里不再有循环</span></span><br><span class="line"><span class="comment">ListAndWatch(stopChannel)定义在/pkg/client/cache/reflector.go</span></span><br><span class="line"><span class="comment">==&gt;func (r *Reflector) ListAndWatch(stopCh &lt;-chan struct&#123;&#125;) error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := c.reflector.ListAndWatch(stopChannel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Errorf(<span class="string">"unexpected ListAndWatch error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Reflector的<code>ListAndWatch()</code></p><p>分析其流程，如下：</p><ol><li>执行list操作</li><li>执行watch操作</li><li>调用<code>func (r *Reflector) watchHandler</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">译：func (r *Reflector) ListAndWatch 首先会list所有的items，得到resource version；</span></span><br><span class="line"><span class="comment">然后使用该resource version去watch。</span></span><br><span class="line"><span class="comment">如果ListAndWatch没有尝试去初始化watch，返回error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意func (r *Reflector) ListAndWatch函数会被apiserver和kubelet等多个组件复用。</span></span><br><span class="line"><span class="comment">区别： apiserver去watch etcd，而kubelet去watch apiserver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line"><span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line">resyncCh, cleanup := r.resyncChan()</span><br><span class="line"><span class="keyword">defer</span> cleanup()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line"><span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line"><span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">译：明确把resource version设置为"0"---这样子是适用于对cache进行 List()操作的，虽然可能会造成内容相对于</span></span><br><span class="line"><span class="comment">etcd中的数据有所延迟。</span></span><br><span class="line"><span class="comment">   Reflector框架是通过Watch()操作来追赶上来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">options := api.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">apiserver端，list-watch机制 V3.0 ，List操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用resource version＝"0"来进行list操作，</span></span><br><span class="line"><span class="comment">r.listerWatcher.List定义在/pkg/storage/cacher.go</span></span><br><span class="line"><span class="comment">==&gt;func (lw *cacherListerWatcher) List(options api.ListOptions)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">list, err := r.listerWatcher.List(options)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取该类型的List接口，定义在</span></span><br><span class="line"><span class="comment">==&gt;/pkg/api/meta/meta.go</span></span><br><span class="line"><span class="comment">==&gt;func ListAccessor(obj interface&#123;&#125;) (List, error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">&#125;</span><br><span class="line">resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">items, err := meta.ExtractList(list)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">&#125;</span><br><span class="line">r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line"></span><br><span class="line">resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line"><span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">resyncerrc &lt;- err</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cleanup()</span><br><span class="line">resyncCh, cleanup = r.resyncChan()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">options = api.ListOptions&#123;</span><br><span class="line">ResourceVersion: resourceVersion,</span><br><span class="line"><span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line"><span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">apiserver端，list-watch机制 V3.0 ，Watch操作</span></span><br><span class="line"><span class="comment">定义在/pkg/storage/cacher.go</span></span><br><span class="line"><span class="comment">==&gt;func (lw *cacherListerWatcher) Watch(options api.ListOptions) (watch.Interface, error)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">生成一个watcher，该watcher实现了watch.Interface（用接口来让kubelet、apiserver复用该接口）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">w, err := r.listerWatcher.Watch(options)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> err &#123;</span><br><span class="line"><span class="keyword">case</span> io.EOF:</span><br><span class="line"><span class="comment">// watch closed normally</span></span><br><span class="line"><span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line"><span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line"><span class="comment">// watch where we ended.</span></span><br><span class="line"><span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line"><span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line"><span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line"><span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">apiserver端，list-watch机制 V4.0</span></span><br><span class="line"><span class="comment">把上面生成的watcher w传进去</span></span><br><span class="line"><span class="comment">调用func (r *Reflector) watchHandler</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>list, err := r.listerWatcher.List(options)</code>和<code>w, err := r.listerWatcher.Watch(options)</code>，真正调用的是etcdHelper的list watch方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *cacherListerWatcher)</span> <span class="title">List</span><span class="params">(options api.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">list := lw.newListFunc()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用storage的List方法，定义在</span></span><br><span class="line"><span class="comment">==&gt;/pkg/storage/etcd/etcd_helper.go</span></span><br><span class="line"><span class="comment">==&gt;func (h *etcdHelper) List(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate, listObj runtime.Object) error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> err := lw.storage.List(context.TODO(), lw.resourcePrefix, <span class="string">""</span>, Everything, list); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implements cache.ListerWatcher interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *cacherListerWatcher)</span> <span class="title">Watch</span><span class="params">(options api.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用storage的WatchList方法，定义在</span></span><br><span class="line"><span class="comment">==&gt;/pkg/storage/etcd/etcd_helper.go</span></span><br><span class="line"><span class="comment">==&gt;func (h *etcdHelper) WatchList(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> lw.storage.WatchList(context.TODO(), lw.resourcePrefix, options.ResourceVersion, Everything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>err := r.watchHandler</code>是将event对象从channel outgoing中读取出来，而方法中调用的<code>r.store.Add(event.Object)</code>则是将event添加到cache中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watchCache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">object, resourceVersion, err := objectToVersionedRuntimeObject(obj)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把入口参数object重新包装成event</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">event := watch.Event&#123;Type: watch.Added, Object: object&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义函数面值f， w.store.Add(elem)定义在是pkg/client/cache/store.go</span></span><br><span class="line"><span class="comment">==&gt;func (c *cache) Add(obj interface&#123;&#125;) error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(elem *storeElement)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> w.store.Add(elem) &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用func (w *watchCache) processEvent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> w.processEvent(event, resourceVersion, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的<code>processEvent()</code>方法最终完成了Event从etcd流向Cache。</p><p>以上是完成了event的生产过程，最终event都要流向消费它的订阅方，在上面的代码中<code>dispatchEvents()</code>就是那个分发event的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvents</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type Cacher struct的channel incoming的消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">case</span> event, ok := &lt;-c.incoming:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.dispatchEvent(&amp;event)</span><br><span class="line"><span class="keyword">case</span> &lt;-c.stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用<code>dispatchEvent()</code>方法，将event分发给所有的watcher</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取event中的value、前一个event的value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">triggerValues, supported := c.triggerValues(event)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> For now we assume we have a given &lt;timeout&gt; budget for dispatching</span></span><br><span class="line"><span class="comment">// a single event. We should consider changing to the approach with:</span></span><br><span class="line"><span class="comment">// - budget has upper bound at &lt;max_timeout&gt;</span></span><br><span class="line"><span class="comment">// - we add &lt;portion&gt; to current timeout every second</span></span><br><span class="line">timeout := time.Duration(<span class="number">250</span>) * time.Millisecond</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   RWMutex提供了四个方法：</span></span><br><span class="line"><span class="comment">   func (*RWMutex) Lock  写锁定</span></span><br><span class="line"><span class="comment">   func (*RWMutex) Unlock  写解锁</span></span><br><span class="line"><span class="comment">   func (*RWMutex) RLock  读锁定</span></span><br><span class="line"><span class="comment">   func (*RWMutex) RUnlock  读解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">c.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.Unlock()</span><br><span class="line"><span class="comment">// Iterate over "allWatchers" no matter what the trigger function is.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对Cacher中的watchers.allWatchers进行遍历，</span></span><br><span class="line"><span class="comment">把event 发送到所有的watcher中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.allWatchers &#123;</span><br><span class="line">watcher.add(event, &amp;timeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> supported &#123;</span><br><span class="line"><span class="comment">// Iterate over watchers interested in the given values of the trigger.</span></span><br><span class="line"><span class="keyword">for</span> _, triggerValue := <span class="keyword">range</span> triggerValues &#123;</span><br><span class="line"><span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchers.valueWatchers[triggerValue] &#123;</span><br><span class="line">watcher.add(event, &amp;timeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// supported equal to false generally means that trigger function</span></span><br><span class="line"><span class="comment">// is not defined (or not aware of any indexes). In this case,</span></span><br><span class="line"><span class="comment">// watchers filters should generally also don't generate any</span></span><br><span class="line"><span class="comment">// trigger values, but can cause problems in case of some</span></span><br><span class="line"><span class="comment">// misconfiguration. Thus we paranoidly leave this branch.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate over watchers interested in exact values for all values.</span></span><br><span class="line"><span class="keyword">for</span> _, watchers := <span class="keyword">range</span> c.watchers.valueWatchers &#123;</span><br><span class="line"><span class="keyword">for</span> _, watcher := <span class="keyword">range</span> watchers &#123;</span><br><span class="line">watcher.add(event, &amp;timeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>watcher.add(event, &amp;timeout)</code>方法，把event分发到一个<code>type cacheWatcher struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">add</span><span class="params">(event *watchCacheEvent, timeout *time.Duration)</span></span> &#123;</span><br><span class="line"><span class="comment">// Try to send the event immediately, without blocking.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">channel取不到值时，走default通道，就是select语句结束，继续执行后续部分</span></span><br><span class="line"><span class="comment">如果取到值，直接return</span></span><br><span class="line"><span class="comment">这里完成event的分发，channel input的生产者，</span></span><br><span class="line"><span class="comment">其对应的消费者在type cacheWatcher struct</span></span><br><span class="line"><span class="comment">==&gt;/pkg/storage/cacher.go</span></span><br><span class="line"><span class="comment">==&gt;func newCacheWatcher</span></span><br><span class="line"><span class="comment">==&gt;func (c *cacheWatcher) process(initEvents []watchCacheEvent, resourceVersion uint64)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c.input &lt;- *event:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, block sending, but only for up to &lt;timeout&gt;.</span></span><br><span class="line"><span class="comment">// cacheWatcher.add is called very often, so arrange</span></span><br><span class="line"><span class="comment">// to reuse timers instead of constantly allocating.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func (c *cacheWatcher) add会很频繁地被调用，设置了一个定时器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">startTime := time.Now()</span><br><span class="line"></span><br><span class="line">t, ok := timerPool.Get().(*time.Timer)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">t.Reset(*timeout)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t = time.NewTimer(*timeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> timerPool.Put(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c.input &lt;- *event:</span><br><span class="line">stopped := t.Stop()</span><br><span class="line"><span class="keyword">if</span> !stopped &#123;</span><br><span class="line"><span class="comment">// Consume triggered (but not yet received) timer event</span></span><br><span class="line"><span class="comment">// so that future reuse does not get a spurious timeout.</span></span><br><span class="line">&lt;-t.C</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line"><span class="comment">// This means that we couldn't send event to that watcher.</span></span><br><span class="line"><span class="comment">// Since we don't want to block on it infinitely,</span></span><br><span class="line"><span class="comment">// we simply terminate it.</span></span><br><span class="line">c.forget(<span class="literal">false</span>)</span><br><span class="line">c.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *timeout = *timeout - time.Since(startTime); *timeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">*timeout = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里Event已经分发到了各个订阅者的watcher中了，后续各个Watcher组件会从channel input中获取到event</p><p>kube-apiserver初始化时，建立对etcd的连接，并对etcd进行watch，将watch的结果存入watchCache。 当其他组件需要watch资源时，其他组件向apiserver发送一个watch请求，这个请求是可以带filter函数的。 apiserver针对这个请求会创建一个watcher，并基于watcher创建WatchServer。 watchCache watch的对象，首先会通过filter函数的过滤，假如过滤通过的话，则会通过WatcherServer发送给订阅组件。</p><p>整个list-watch过程的调用链</p><p><img alt="list-watch" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/list_watch.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ApiServer&lt;/code&gt;作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。&lt;/p&gt;
&lt;p&gt;kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/kubernetes-api/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Kubernetes API&lt;/a&gt;，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用；&lt;/li&gt;
&lt;li&gt;代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；&lt;/li&gt;
&lt;li&gt;创建 kubernetes 服务，即提供 apiserver 的 Service，kubernetes Service；&lt;/li&gt;
&lt;li&gt;资源在不同版本之间的转换；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="apiserver" scheme="http://houmin.cc/tags/apiserver/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】调度策略</title>
    <link href="http://houmin.cc/posts/b130e91a/"/>
    <id>http://houmin.cc/posts/b130e91a/</id>
    <published>2020-08-03T06:39:15.000Z</published>
    <updated>2020-08-06T03:52:39.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文分析了Kubernetes内置的各种调度策略。</p><a id="more"></a><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><h3 id="整体梳理"><a href="#整体梳理" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container"><table><thead><tr><th>策略名称</th><th>策略算法</th><th>备注</th></tr></thead><tbody><tr><td>CheckNodeUnschedulable</td><td>在 Node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了</td><td></td></tr><tr><td>CheckVolumeBinding</td><td>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验</td><td></td></tr><tr><td>GeneralPredicates</td><td>是 PodFitsHostPorts，PodFitsResources，HostName，MatchNodeSelector这四个的组合</td><td></td></tr><tr><td>MatchInterPodAffinity</td><td>亲和性检查，当Node上所有正在运行的Pod与待调度的Pod不互相排斥时，则可调度</td><td></td></tr><tr><td>MaxAzureDiskVolumeCount</td><td>当Node上被挂载的Azure Disk Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>MaxCSIVolumeCountPred</td><td>当Node上被挂载的CSI Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>MaxEBSVolumeCount</td><td>当Node上被挂载的AWS EBS Volume超过默认限制39，该Node不可调度</td><td></td></tr><tr><td>MaxGCEPDVolumeCount</td><td>当Node上被挂载的GCD Persistent Disk超过默认限制16，该Node不可调度</td><td></td></tr><tr><td>MaxQcloudCbsVolumeCount</td><td>当Node上被挂载的Qcloud CBS Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>NoDiskConflict</td><td>当Node上所有Pod使用的卷和待调度Pod使用的卷存在冲突，该Node不可调度</td><td></td></tr><tr><td>NoVolumeZoneConflict</td><td>当Node上的zone-lable包含Pod中PV卷下的zone-label时，可以调度。当Node上没有zone-label，表示没有zone限制，也可调度</td><td></td></tr><tr><td>PodToleratesNodeTaints</td><td>当Pod可以容忍Node上所有的taint时，该Node才可以调度</td><td></td></tr><tr><td>PodFitsHostPorts</td><td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td><td></td></tr><tr><td>PodFitsResources</td><td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td><td></td></tr><tr><td>HostName</td><td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td><td></td></tr><tr><td>MatchNodeSelector</td><td>校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配</td><td></td></tr><tr><td>CheckNodeMemoryPressure</td><td>当Node剩余内存紧张时，BestEffort类型的Pod无法调度到该主机</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>CheckNodeDiskPressure</td><td>当Node剩余磁盘空间紧张时，无法调度到该主机</td><td></td></tr><tr><td>PodFitsHostPorts</td><td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td><td></td></tr><tr><td>PodFitsResources</td><td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td><td></td></tr><tr><td>HostName</td><td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td><td></td></tr><tr><td>EvenPodsSpread</td><td>在1.18版本默认启动，符合条件的一组 Pod 在指定 TopologyKey 上的打散要求</td><td></td></tr><tr><td>CheckNodeLabelPresence</td><td>主要用于检查指定的Label是否在Node上存在</td><td></td></tr><tr><td>CheckServiceAffinityPred</td><td>根据当前POD对象所属的service已有的其他POD对象所运行的节点进行调度，其目的在于将相同service的POD 对象放置与同一个或同一类节点上以提高效率，此预选此类试图将那些在其节点选择器中带有特定标签的POD资源调度至拥有同样标签的节点上，具体的标签则取决于用户的定义。</td></tr></tbody></table></div><h3 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h3><h4 id="NoVolumeZoneConflictPred"><a href="#NoVolumeZoneConflictPred" class="headerlink" title="NoVolumeZoneConflictPred"></a>NoVolumeZoneConflictPred</h4><p>当在 k8s 集群中使用 zone 时，所有的Node都会被标记上 zone label，下面四种是常见的lable的key：</p><figure class="highlight go"><figcaption><span>k8s.io/api/core/v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LabelZoneFailureDomain       = <span class="string">"failure-domain.beta.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegion              = <span class="string">"failure-domain.beta.kubernetes.io/region"</span></span><br><span class="line">LabelZoneFailureDomainStable = <span class="string">"topology.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegionStable        = <span class="string">"topology.kubernetes.io/region"</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">node.alpha.kubernetes.io/ttl:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">volumes.kubernetes.io/controller-managed-attach-detach:</span> <span class="string">"true"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2020-07-20T12:11:34Z"</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"334106446"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/nodes/10.0.1.28</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">5943d3fc-0841-43f2-b519-c32af755c1c5</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/instance-type:</span> <span class="string">QCLOUD</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">cloud.tencent.com/node-instance-id:</span> <span class="string">ins-r3gy6izp</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">    <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">qcloud:///800002/ins-r3gy6izp</span></span><br></pre></td></tr></table></figure><p>当一个Pod有存储卷要求时，需要检查该存储卷的zone调度约束是否与Node的zone限制存在冲突。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/volumezone/volume_zone.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> pv.ObjectMeta.Labels &#123;</span><br><span class="line"><span class="keyword">if</span> !volumeZoneLabels.Has(k) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">nodeV, _ := nodeConstraints[k]</span><br><span class="line">volumeVSet, err := volumehelpers.LabelZonesToSet(v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Failed to parse label for %q: %q. Ignoring the label. err=%v. "</span>, k, v, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !volumeVSet.Has(nodeV) &#123;</span><br><span class="line">klog.V(<span class="number">10</span>).Infof(<span class="string">"Won't schedule pod %q onto node %q due to volume %q (mismatch on %q)"</span>, pod.Name, node.Name, pvName, k)</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonConflict)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检查的条件是：属于该Pod的所有volumes都必须与Node上的zone label完全匹配。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoVolumeZoneConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumezone.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckVolumeBindingPred"><a href="#CheckVolumeBindingPred" class="headerlink" title="CheckVolumeBindingPred"></a>CheckVolumeBindingPred</h4><p>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验，里头的逻辑写的比较复杂，主要都是如何复用 pv；</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckVolumeBindingPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Reserve = appendToPluginSet(plugins.Reserve, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreBind = appendToPluginSet(plugins.PreBind, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NoDiskConflictPred"><a href="#NoDiskConflictPred" class="headerlink" title="NoDiskConflictPred"></a>NoDiskConflictPred</h4><p>SCSI 存储不会被重复的 volume, 检查在此主机上是否存在卷冲突。如果这个主机已经挂载了卷，其它同样使用这个卷的Pod不能调度到这个主机上，不同的存储后端具体规则不同</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoDiskConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumerestrictions.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MaxCSIVolumeCountPred"><a href="#MaxCSIVolumeCountPred" class="headerlink" title="MaxCSIVolumeCountPred"></a>MaxCSIVolumeCountPred</h4><p>一个Pod请求Volumes的时候，节点上可能已经有Volumes，需要检查加上这个Pod之后的Volumes是否超过Node最大允许的Volumes限制。MaxCSIVolumeCountPred 用来校验 pvc 上指定的 Provision 在 CSI plugin 上的单机最大 pv 数限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> volumeLimitKey, count := <span class="keyword">range</span> newVolumeCount &#123;</span><br><span class="line">maxVolumeLimit, ok := nodeVolumeLimits[v1.ResourceName(volumeLimitKey)]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">currentVolumeCount := attachedVolumeCount[volumeLimitKey]</span><br><span class="line"><span class="keyword">if</span> currentVolumeCount+count &gt; <span class="keyword">int</span>(maxVolumeLimit) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCSIVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CSIName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MaxNonCSIVolumeCountPred"><a href="#MaxNonCSIVolumeCountPred" class="headerlink" title="MaxNonCSIVolumeCountPred"></a>MaxNonCSIVolumeCountPred</h4><p>对于不是CSI标准的存储插件，也需要满足最大PV数限制，整体逻辑类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> numExistingVolumes+numNewVolumes &gt; maxAttachLimit &#123;</span><br><span class="line"><span class="comment">// violates MaxEBSVolumeCount or MaxGCEPDVolumeCount</span></span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MaxEBSVolumeCountPred"><a href="#MaxEBSVolumeCountPred" class="headerlink" title="MaxEBSVolumeCountPred"></a>MaxEBSVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxEBSVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.EBSName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxGCEPDVolumeCountPred"><a href="#MaxGCEPDVolumeCountPred" class="headerlink" title="MaxGCEPDVolumeCountPred"></a>MaxGCEPDVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxGCEPDVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.GCEPDName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxAzureDiskVolumeCountPred"><a href="#MaxAzureDiskVolumeCountPred" class="headerlink" title="MaxAzureDiskVolumeCountPred"></a>MaxAzureDiskVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxAzureDiskVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.AzureDiskName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxCinderVolumeCountPred"><a href="#MaxCinderVolumeCountPred" class="headerlink" title="MaxCinderVolumeCountPred"></a>MaxCinderVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCinderVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CinderName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-与-Node-匹配相关"><a href="#Pod-与-Node-匹配相关" class="headerlink" title="Pod 与 Node 匹配相关"></a>Pod 与 Node 匹配相关</h3><ul><li>CheckNodeCondition：校验节点是否准备好被调度，校验node.condition的condition type ：Ready为true和NetworkUnavailable为false以及Node.Spec.Unschedulable为false；</li><li></li><li>PodFitsHostPorts：校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用；</li><li>MatchNodeSelector: 校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配。</li></ul><h4 id="PodFitsHostPortsPred"><a href="#PodFitsHostPortsPred" class="headerlink" title="PodFitsHostPortsPred"></a>PodFitsHostPortsPred</h4><p><code>PodFitsHostPorts</code>策略主要用于校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用。</p><p>在 PreFilter 阶段，获取当前 Pod 对应的所有容器的Port，并且写入cycleState。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreFilter invoked at the prefilter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">PreFilter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">s := getContainerPorts(pod)</span><br><span class="line">cycleState.Write(preFilterStateKey, preFilterState(s))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Filter 阶段，从Cycle拿到当前Pod请求的Port，对比当前系统中已使用的 Port，看是否会发生冲突。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">wantPorts, err := getPreFilterState(cycleState)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fits := fitsPorts(wantPorts, nodeInfo)</span><br><span class="line"><span class="keyword">if</span> !fits &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsHostPortsPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="PodFitsResourcesPred"><a href="#PodFitsResourcesPred" class="headerlink" title="PodFitsResourcesPred"></a>PodFitsResourcesPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsResourcesPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="PodToleratesNodeTaintsPred"><a href="#PodToleratesNodeTaintsPred" class="headerlink" title="PodToleratesNodeTaintsPred"></a>PodToleratesNodeTaintsPred</h4><p><code>PodToleratesNodeTaints</code>策略校验 Node 的 Taints 是否被 Pod Tolerates 包含。这里主要检查 <code>NoSchedule</code> 和 <code>NoExecute</code> 这两个 taint，如果不容忍，那么返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"invalid nodeInfo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filterPredicate := <span class="function"><span class="keyword">func</span><span class="params">(t *v1.Taint)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// PodToleratesNodeTaints is only interested in NoSchedule and NoExecute taints.</span></span><br><span class="line"><span class="keyword">return</span> t.Effect == v1.TaintEffectNoSchedule || t.Effect == v1.TaintEffectNoExecute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taint, isUntolerated := v1helper.FindMatchingUntoleratedTaint(nodeInfo.Node().Spec.Taints, pod.Spec.Tolerations, filterPredicate)</span><br><span class="line"><span class="keyword">if</span> !isUntolerated &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errReason := fmt.Sprintf(<span class="string">"node(s) had taint &#123;%s: %s&#125;, that the pod didn't tolerate"</span>,</span><br><span class="line">taint.Key, taint.Value)</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, errReason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodToleratesNodeTaintsPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="HostNamePred"><a href="#HostNamePred" class="headerlink" title="HostNamePred"></a>HostNamePred</h4><p><code>NodeNamePred</code>策略主要用于检查Pod Spec声明的Node Name是否与Node实际的Name匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filter invoked at the filter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fits actually checks if the pod fits the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fits</span><span class="params">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(HostNamePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MatchNodeSelectorPred"><a href="#MatchNodeSelectorPred" class="headerlink" title="MatchNodeSelectorPred"></a>MatchNodeSelectorPred</h4><p><code>MatchNodeSelectorPred</code>策略用于校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PodMatchesNodeSelectorAndAffinityTerms</span><span class="params">(pod *v1.Pod, node *v1.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Check if node.Labels match pod.Spec.NodeSelector.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeSelector) &gt; <span class="number">0</span> &#123;</span><br><span class="line">selector := labels.SelectorFromSet(pod.Spec.NodeSelector)</span><br><span class="line"><span class="keyword">if</span> !selector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. nil NodeSelector matches all nodes (i.e. does not filter out any nodes)</span></span><br><span class="line"><span class="comment">// 2. nil []NodeSelectorTerm (equivalent to non-nil empty NodeSelector) matches no nodes</span></span><br><span class="line"><span class="comment">// 3. zero-length non-nil []NodeSelectorTerm matches no nodes also, just for simplicity</span></span><br><span class="line"><span class="comment">// 4. nil []NodeSelectorRequirement (equivalent to non-nil empty NodeSelectorTerm) matches no nodes</span></span><br><span class="line"><span class="comment">// 5. zero-length non-nil []NodeSelectorRequirement matches no nodes also, just for simplicity</span></span><br><span class="line"><span class="comment">// 6. non-nil empty NodeSelectorRequirement is not allowed</span></span><br><span class="line">nodeAffinityMatches := <span class="literal">true</span></span><br><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &#123;</span><br><span class="line">nodeAffinity := affinity.NodeAffinity</span><br><span class="line"><span class="comment">// if no required NodeAffinity requirements, will do no-op, means select all nodes.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Replace next line with subsequent commented-out line when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution == nil &amp;&amp; nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil &#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match node selector for requiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Uncomment this block when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution != nil &#123;</span></span><br><span class="line"><span class="comment">// nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution.NodeSelectorTerms</span></span><br><span class="line"><span class="comment">// klog.V(10).Infof("Match for RequiredDuringSchedulingRequiredDuringExecution node selector terms %+v", nodeSelectorTerms)</span></span><br><span class="line"><span class="comment">// nodeAffinityMatches = nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Match node selector for requiredDuringSchedulingIgnoredDuringExecution.</span></span><br><span class="line"><span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line">nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms</span><br><span class="line">nodeAffinityMatches = nodeAffinityMatches &amp;&amp; nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodeAffinityMatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个典型的Node亲和性示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">pod: &amp;v1.Pod&#123;</span><br><span class="line">Spec: v1.PodSpec&#123;</span><br><span class="line">Affinity: &amp;v1.Affinity&#123;</span><br><span class="line">NodeAffinity: &amp;v1.NodeAffinity&#123;</span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution: &amp;v1.NodeSelector&#123;</span><br><span class="line">NodeSelectorTerms: []v1.NodeSelectorTerm&#123;</span><br><span class="line">&#123;</span><br><span class="line">MatchExpressions: []v1.NodeSelectorRequirement&#123;</span><br><span class="line">&#123;</span><br><span class="line">Key:      <span class="string">"kernel-version"</span>,</span><br><span class="line">Operator: v1.NodeSelectorOpGt,</span><br><span class="line">Values:   []<span class="keyword">string</span>&#123;<span class="string">"0204"</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="comment">// We use two digit to denote major version and two digit for minor version.</span></span><br><span class="line"><span class="string">"kernel-version"</span>: <span class="string">"0206"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name: <span class="string">"Pod with matchExpressions using Gt operator that matches the existing node"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchNodeSelectorPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="GeneralPred"><a href="#GeneralPred" class="headerlink" title="GeneralPred"></a>GeneralPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(GeneralPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// GeneralPredicate is a combination of predicates.</span></span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckNodeUnschedulablePred"><a href="#CheckNodeUnschedulablePred" class="headerlink" title="CheckNodeUnschedulablePred"></a>CheckNodeUnschedulablePred</h4><p><code>CheckNodeUnschedulable</code> 在 node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了，形如这种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node: &amp;v1.Node&#123;</span><br><span class="line">   Spec: v1.NodeSpec&#123;</span><br><span class="line">     Unschedulable: <span class="literal">true</span>,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>在 1.16 的版本里，这个 Unschedulable 已经变成了一个 Taints。也就是说需要校验一下 Pod 上打上的 Tolerates 是不是可以容忍这个 Taints。如果容忍了这个不可调度的taint，那么它也可以容忍 NodeSpec的不可调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeUnschedulable)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnknownCondition)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If pod tolerate unschedulable taint, it's also tolerate `node.Spec.Unschedulable`.</span></span><br><span class="line">podToleratesUnschedulable := v1helper.TolerationsTolerateTaint(pod.Spec.Tolerations, &amp;v1.Taint&#123;</span><br><span class="line">Key:    v1.TaintNodeUnschedulable,</span><br><span class="line">Effect: v1.TaintEffectNoSchedule,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TODO (k82cn): deprecates `node.Spec.Unschedulable` in 1.13.</span></span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node().Spec.Unschedulable &amp;&amp; !podToleratesUnschedulable &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnschedulable)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeUnschedulablePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeunschedulable.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckNodeLabelPresencePred"><a href="#CheckNodeLabelPresencePred" class="headerlink" title="CheckNodeLabelPresencePred"></a>CheckNodeLabelPresencePred</h4><p><code>CheckNodeLablePresencePred</code>策略主要用于检查指定的Label是否在Node上存在。这里检查的是两种情况：</p><ul><li>一种检查Node上面是否有指定Label。比如有时候通过 <code>region/zone/racks</code> 这种label来划分空间，想要把Pod调度到有特定region/zone/racks的Node。</li><li>一种是检查Node上面是否没有指定的Label。比如有的Node被打上 <code>retiring</code> 的 label，想要制定Pod不调度到这些Node上。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nodeLabels := labels.Set(node.Labels)</span><br><span class="line">check := <span class="function"><span class="keyword">func</span><span class="params">(labels []<span class="keyword">string</span>, presence <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> labels &#123;</span><br><span class="line">exists := nodeLabels.Has(label)</span><br><span class="line"><span class="keyword">if</span> (exists &amp;&amp; !presence) || (!exists &amp;&amp; presence) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> check(pl.args.PresentLabels, <span class="literal">true</span>) &amp;&amp; check(pl.args.AbsentLabels, <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonPresenceViolated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个策略，需要在注册的时候设定策略插件的参数。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-与-Pod-匹配相关"><a href="#Pod-与-Pod-匹配相关" class="headerlink" title="Pod 与 Pod 匹配相关"></a>Pod 与 Pod 匹配相关</h3><h4 id="MatchInterPodAffinityPred"><a href="#MatchInterPodAffinityPred" class="headerlink" title="MatchInterPodAffinityPred"></a>MatchInterPodAffinityPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchInterPodAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-服务打散相关"><a href="#Pod-服务打散相关" class="headerlink" title="Pod 服务打散相关"></a>Pod 服务打散相关</h3><h4 id="EvenPodsSpread"><a href="#EvenPodsSpread" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckServiceAffinity"><a href="#CheckServiceAffinity" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckServiceAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h2><h3 id="整体梳理-1"><a href="#整体梳理-1" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container"><table><thead><tr><th>策略名称</th><th>策略算法</th><th>权重</th></tr></thead><tbody><tr><td>BalancedResourceAllocation</td><td>CPU和内存利用率越接近，得分越高</td><td>1</td></tr><tr><td>ImageLocalityPriority</td><td>待调度的Pod会使用一些镜像，拥有这些镜像越多的节点，得分越高</td><td>1</td></tr><tr><td>InterPodAffinityPriority</td><td>Pod与Node上正运行的其他Pod亲和性匹配度越高，得分越高</td><td>1</td></tr><tr><td>LeastRequestedPriority</td><td>剩余资源越多，得分越高</td><td>1</td></tr><tr><td>NodeAffinityPriority</td><td>Pod与Node亲和性匹配度越高，得分越高</td><td>1</td></tr><tr><td>NodePreferAvoidPodsPriority</td><td>该Node的annotation scheduler.alpha.kubernetes.io/preferAvoidPods被设置时，说明该Node不希望被调度，得分低。</td><td>10000</td></tr><tr><td>SelectorSpreadPriority</td><td>相同service/rc的Pods越分散，得分越高</td><td>1</td></tr><tr><td>TaintTolerationPriority</td><td>Pod对Node的taint容忍度越高，得分越高</td><td>1</td></tr><tr><td>ServiceSpreadingPriority</td><td>相同Service的Pods越分散，得分越高，被 SelectorSpreadPriority取代，保留在系统中并不使用</td><td>1</td></tr><tr><td>EqualPriority</td><td>所有机器得分一样</td><td>1</td></tr><tr><td>MostRequestPriority</td><td>Request资源越多，得分越高，与LeastRequestPriority相反</td><td>1</td></tr><tr><td>EvenPodsSpreadPriority</td><td>在1.18版本默认启动，用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式</td><td>2</td></tr><tr><td>RequestedToCapacityRatioName</td><td>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing</td><td></td></tr><tr><td>NodeLabel</td><td>主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</td><td></td></tr><tr><td>ServiceAffinity</td><td>是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。</td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><p>打分算法主要解决的问题就是集群的碎片、容灾、水位、亲和、反亲和等，可以分为以下四个大类。</p><h3 id="资源水位"><a href="#资源水位" class="headerlink" title="资源水位"></a>资源水位</h3><ul><li>资源水位公式的概念：Request：Node 已经分配的资源；Allocatable：Node 的可调度的资源。</li><li>优先打散：把 Pod 分到资源空闲率最高的节点上，而非空闲资源最大的节点，公式：资源空闲率 = (Allocatable - Request) / Allocatable，当这个值越大，表示分数越高，优先分配到高分数的节点。其中 (Allocatable - Request) 表示为 Pod 分配到这个节点之后空闲的资源数。</li><li>优先堆叠：把 Pod 分配到资源使用率最高的节点上，公式:资源使用率 = Request / Allocatable ，资源使用率越高，表示得分越高，会优先分配到高分数的节点。</li><li>碎片率：是指 Node 上的多种资源之间的资源使用率的差值，目前支持 CPU/Mem/Disk 三类资源, 假如仅考虑 CPU/Mem，那么碎片率的公式 = Abs[CPU(Request / Allocatable) - Mem(Request / Allocatable)] 。举一个例子，当 CPU 的分配率是 99%，内存的分配率是 50%，那么碎片率 = 99% - 50% = 50%，那么这个例子中剩余 1% CPU, 50% Mem，很难有这类规格的容器能用完 Mem。得分 = 1 - 碎片率，碎片率越高得分低。</li><li>指定比率：可以在 Scheduler 启动的时候，为每一个资源使用率设置得分，从而实现控制集群上 node 资源分配分布曲线。</li></ul><h4 id="LeastRequestedPriority"><a href="#LeastRequestedPriority" class="headerlink" title="LeastRequestedPriority"></a>LeastRequestedPriority</h4><p><code>LeastRequestedPriority</code> 策略对于那些使用率越低的Node的优先级越高。通过这种算法，可以使得各个节点的资源得到均衡利用。</p><p>计算公式如下：</p><script type="math/tex; mode=display">(cpu((capacity-sum(requested))*MaxNodeScore/capacity) + memory((capacity-sum(requested))*MaxNodeScore/capacity))/weightSum</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(LeastRequestedPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.LeastAllocatedName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MostRequestedPriority"><a href="#MostRequestedPriority" class="headerlink" title="MostRequestedPriority"></a>MostRequestedPriority</h4><p><code>MostRequestedPriority</code> 策略对于那些使用率更高的Node的优先级更高。这种算法在动态伸缩集群环境比较适用，会优先调度pod到使用率最高的主机节点，这样在伸缩集群时，就会腾出空闲机器，从而进行停机处理。</p><p>其计算公式如下：</p><script type="math/tex; mode=display">(cpu(MaxNodeScore * sum(requested) / capacity) + memory(MaxNodeScore * sum(requested) / capacity)) / weightSum</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(MostRequestedPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.MostAllocatedName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="BalancedResourceAllocation"><a href="#BalancedResourceAllocation" class="headerlink" title="BalancedResourceAllocation"></a>BalancedResourceAllocation</h4><p>BalancedResourceAllocation：尽量选择在部署Pod后各项资源更均衡的机器。BalancedResourceAllocation不能单独使用，而且必须和LeastRequestedPriority同时使用，它分别计算主机上的cpu和memory的比重，主机的分值由cpu比重和memory比重的“距离”决定。</p><p>计算公式如下：</p><script type="math/tex; mode=display">score = (1 - variance(cpuFraction,memoryFraction,volumeFraction)) * MaxNodeScore</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(BalancedResourceAllocation,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.BalancedAllocationName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="RequestedToCapacityRatioPriority"><a href="#RequestedToCapacityRatioPriority" class="headerlink" title="RequestedToCapacityRatioPriority"></a>RequestedToCapacityRatioPriority</h4><p><code>RequestedToCapacityRatioPriority</code>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing。</p><p>所谓 <a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="external nofollow noopener noreferrer">Bin Packing</a> ，又称装箱问题，是运筹学中的一个经典问题。问题的背景是，现有若干个小盒子，想要把它们装进有限个给定大小的箱子中，如何既能够装的多油装的快，使得尽可能每个箱子都装满，从而减少箱子的使用数目。BinPack问题有很多变种，当限制箱子的数目为1，每个盒子给定value和weight，binpack问题就变成了背包问题。</p><p>Kubernetes默认开启的资源调度策略是Spread的策略，资源尽量打散，但是会导致较多的资源碎片，使得整体资源利用率下降。通过RequestedToCapacityRatioPriority配置支持CPU、内存和GPU等扩展卡的权重，在打分阶段计算对应资源的利用率，通过利用率进行排序，优先打满一个节点后再向后调度，从而实现bin packing。</p><p><code>RequestedToCapacityRatioResourceAllocation</code> 优先级函数的行为可以通过名为 <code>requestedToCapacityRatioArguments</code> 的配置选项进行控制。 该标志由两个参数 <code>shape</code> 和 <code>resources</code> 组成。 shape 允许用户根据 <code>utilization</code> 和 <code>score</code> 值将函数调整为最少请求（least requested）或 最多请求（most requested）计算。 resources 由 <code>name</code> 和 <code>weight</code> 组成，<code>name</code> 指定评分时要考虑的资源，<code>weight</code> 指定每种资源的权重。</p><p>以下是一个配置示例，该配置将 <code>requestedToCapacityRatioArguments</code> 设置为对扩展资源 <code>intel.com/foo</code> 和 <code>intel.com/bar</code> 的装箱行为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span> : <span class="string">"Policy"</span>,</span><br><span class="line">    <span class="attr">"apiVersion"</span> : <span class="string">"v1"</span>,</span><br><span class="line">    ...</span><br><span class="line">    "priorities" : [</span><br><span class="line">       ...</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"RequestedToCapacityRatioPriority"</span>,</span><br><span class="line">        <span class="attr">"weight"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"argument"</span>: &#123;</span><br><span class="line">          <span class="attr">"requestedToCapacityRatioArguments"</span>: &#123;</span><br><span class="line">            <span class="attr">"shape"</span>: [</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">0</span>, <span class="attr">"score"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">100</span>, <span class="attr">"score"</span>: <span class="number">10</span>&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"resources"</span>: [</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/foo"</span>, <span class="attr">"weight"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/bar"</span>, <span class="attr">"weight"</span>: <span class="number">5</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际上，这里的shape参数定义的是不同utilization下对应的得分，是对 <code>LeastRequestedPriority</code> 和 <code>MostRequestedPriority</code> 的进一步抽象。</p><p>这种配置对应的是<code>LeastRequestedPriority</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这种配置对应的是<code>MostRequestedPriority</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(noderesources.RequestedToCapacityRatioName,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.RequestedToCapacityRatioName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">if</span> args.RequestedToCapacityRatioArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.RequestedToCapacityRatioName, Args: args.RequestedToCapacityRatioArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-打散"><a href="#Pod-打散" class="headerlink" title="Pod 打散"></a>Pod 打散</h3><p>Pod打散目的是支持符合条件的一组 Pod 在不同 topology 上部署的 spread 需求。</p><h4 id="ServiceSpreadingPriority"><a href="#ServiceSpreadingPriority" class="headerlink" title="ServiceSpreadingPriority"></a>ServiceSpreadingPriority</h4><p>ServiceSpreadingPriority：官方注释上说大概率会用来替换 SelectorSpreadPriority，为什么呢？我个人理解：Service 代表一组服务，我们只要能做到服务的打散分配就足够了。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="EvenPodsSpread-1"><a href="#EvenPodsSpread-1" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>EvenPodsSpreadPriority：用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式。因为这个使用方式可能会一直变化，我们假设这个拓扑结构是这样的：Spec 是要求在 node 上进行分布的，我们就可以按照上图中的计算公式，计算一下在这个 node 上满足 Spec 指定 labelSelector 条件的 pod 数量，然后计算一下最大的差值，接着计算一下 Node 分配的权重，如果说这个值越大，表示这个值越优先。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(EvenPodsSpreadPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, podtopologyspread.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckServiceAffinity-1"><a href="#CheckServiceAffinity-1" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(serviceaffinity.Name,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are n ServiceAffinity priorities in the policy, the weight for the corresponding</span></span><br><span class="line"><span class="comment">// score plugin is n*weight (note that the validation logic verifies that all ServiceAffinity</span></span><br><span class="line"><span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.ServiceAffinityArgs.AntiAffinityLabelsPreference))</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, serviceaffinity.Name, &amp;weight)</span><br><span class="line"><span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="SelectorSpreadPriority"><a href="#SelectorSpreadPriority" class="headerlink" title="SelectorSpreadPriority"></a>SelectorSpreadPriority</h4><p>SelectorSpreadPriority：用于实现 Pod 所属的 Controller 下所有的 Pod 在 Node 上打散的要求。实现方式是这样的：它会依据待分配的 Pod 所属的 controller，计算该 controller 下的所有 Pod,假设总数为 T，对这些 Pod 按照所在的 Node 分组统计；假设为 N (表示为某个 Node 上的统计值)，那么对 Node上的分数统计为  (T-N)/T 的分数，值越大表示这个节点的 controller 部署的越少，分数越高，从而达到 workload 的 pod 打散需求。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(SelectorSpreadPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, selectorspread.Name, &amp;args.Weight)</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, selectorspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-亲和-反亲和"><a href="#Pod-亲和-反亲和" class="headerlink" title="Pod 亲和/反亲和"></a>Pod 亲和/反亲和</h3><h4 id="InterPodAffinityPriority"><a href="#InterPodAffinityPriority" class="headerlink" title="InterPodAffinityPriority"></a>InterPodAffinityPriority</h4><p>InterPodAffinityPriority：先介绍一下使用场景：第一个例子，比如说应用 A 提供数据，应用 B 提供服务，A 和 B 部署在一起可以走本地网络，优化网络传输；第二个例子，如果应用 A 和应用 B 之间都是 CPU 密集型应用，而且证明它们之间是会互相干扰的，那么可以通过这个规则设置尽量让它们不在一个节点上。pod亲和性选择策略，类似NodeAffinityPriority，提供两种选择器支持：requiredDuringSchedulingIgnoredDuringExecution（保证所选的主机必须满足所有Pod对主机的规则要求）、preferresDuringSchedulingIgnoredDuringExecution（调度器会尽量但不保证满足NodeSelector的所有要求），两个子策略：podAffinity和podAntiAffinity</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(InterPodAffinityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, interpodaffinity.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">if</span> args.InterPodAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: interpodaffinity.Name, Args: args.InterPodAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Node-亲和-反亲和"><a href="#Node-亲和-反亲和" class="headerlink" title="Node 亲和/反亲和"></a>Node 亲和/反亲和</h3><ul><li>NodeAffinityPriority，这个是为了满足 Pod 和 Node 的亲和 &amp; 反亲和；</li><li>ServiceAntiAffinity，是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。比如：集群的节点有云上也有云下两组节点，我们要求服务在云上云下均衡去分布，假设 Node 上有某个 label，那我们就可以用这个 ServiceAntiAffinity 进行打散分布；</li><li>NodeLabelPrioritizer，主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配;</li><li>ImageLocalityPriority，节点亲和主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</li></ul><h4 id="NodePreferAvoidPodsPriority"><a href="#NodePreferAvoidPodsPriority" class="headerlink" title="NodePreferAvoidPodsPriority"></a>NodePreferAvoidPodsPriority</h4><p><code>NodePreferAvoidPodsPriority</code>策略用于实现某些 controller 尽量不分配到某些节点上的能力；通过在 node 上加 annotation 声明哪些 controller 不要分配到 Node 上，如果不满足就优先。</p><p>具体实现就是会在Node上加上Annotation，形如这种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">annotations1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">v1.PreferAvoidPodsAnnotationKey: <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "preferAvoidPods": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "podSignature": &#123;</span></span><br><span class="line"><span class="string">                "podController": &#123;</span></span><br><span class="line"><span class="string">                    "apiVersion": "v1",</span></span><br><span class="line"><span class="string">                    "kind": "ReplicationController",</span></span><br><span class="line"><span class="string">                    "name": "foo",</span></span><br><span class="line"><span class="string">                    "uid": "abcdef123456",</span></span><br><span class="line"><span class="string">                    "controller": true</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "reason": "some reason",</span></span><br><span class="line"><span class="string">            "message": "some message"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检查的时候，对于那些不被 <code>ReplicaSet</code> 和 <code>ReplicationController</code> 拥有的 Pod，直接跳过，给予最高分。如果和 <code>annotation</code> 中标记的相同，那么给予最低分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePreferAvoidPods)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">controllerRef := metav1.GetControllerOf(pod)</span><br><span class="line"><span class="keyword">if</span> controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Ignore pods that are owned by other controller than ReplicationController</span></span><br><span class="line"><span class="comment">// or ReplicaSet.</span></span><br><span class="line"><span class="keyword">if</span> controllerRef.Kind != <span class="string">"ReplicationController"</span> &amp;&amp; controllerRef.Kind != <span class="string">"ReplicaSet"</span> &#123;</span><br><span class="line">controllerRef = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avoids, err := v1helper.GetAvoidPodsFromNodeAnnotations(node.Annotations)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If we cannot get annotation, assume it's schedulable there.</span></span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> avoids.PreferAvoidPods &#123;</span><br><span class="line">avoid := &amp;avoids.PreferAvoidPods[i]</span><br><span class="line"><span class="keyword">if</span> avoid.PodSignature.PodController.Kind == controllerRef.Kind &amp;&amp; avoid.PodSignature.PodController.UID == controllerRef.UID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodePreferAvoidPodsPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodepreferavoidpods.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NodeAffinityPriority"><a href="#NodeAffinityPriority" class="headerlink" title="NodeAffinityPriority"></a>NodeAffinityPriority</h4><p><code>NodeAffinityPriority</code>策略用于满足Pod与Node之间的亲和与反亲和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="comment">// A nil element of PreferredDuringSchedulingIgnoredDuringExecution matches no objects.</span></span><br><span class="line"><span class="comment">// An element of PreferredDuringSchedulingIgnoredDuringExecution that refers to an</span></span><br><span class="line"><span class="comment">// empty PreferredSchedulingTerm matches all objects.</span></span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Match PreferredDuringSchedulingIgnoredDuringExecution term by term.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution &#123;</span><br><span class="line">preferredSchedulingTerm := &amp;affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i]</span><br><span class="line"><span class="keyword">if</span> preferredSchedulingTerm.Weight == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Avoid computing it for all nodes if this becomes a performance problem.</span></span><br><span class="line">nodeSelector, err := v1helper.NodeSelectorRequirementsAsSelector(preferredSchedulingTerm.Preference.MatchExpressions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nodeSelector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line">count += <span class="keyword">int64</span>(preferredSchedulingTerm.Weight)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodeAffinityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodeaffinity.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="TaintTolerationPriority"><a href="#TaintTolerationPriority" class="headerlink" title="TaintTolerationPriority"></a>TaintTolerationPriority</h4><p><code>TaintTolerationPriority</code> 策略，Pod 对 Node 的 taint 容忍程度越高，优先级越大。</p><p>在 <code>PreScore</code> 阶段，拿到所有 <code>all Tolerations with Effect PreferNoSchedule or with no effect</code>，并将其写到cycleState。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">PreScore</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodes []*v1.Node)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">tolerationsPreferNoSchedule := getAllTolerationPreferNoSchedule(pod.Spec.Tolerations)</span><br><span class="line">state := &amp;preScoreState&#123;</span><br><span class="line">tolerationsPreferNoSchedule: tolerationsPreferNoSchedule,</span><br><span class="line">&#125;</span><br><span class="line">cycleState.Write(preScoreStateKey, state)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在 <code>Score</code> 阶段，具体算法就是Pod不能容忍的taint越多，那么得分就越高（之后会在Normalize处正则化，将得分逆序），也就是其优先级越低。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">&#125;</span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"></span><br><span class="line">s, err := getPreScoreState(state)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">score := <span class="keyword">int64</span>(countIntolerableTaintsPreferNoSchedule(node.Spec.Taints, s.tolerationsPreferNoSchedule))</span><br><span class="line"><span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(TaintTolerationPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, tainttoleration.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ImageLocalityPriority"><a href="#ImageLocalityPriority" class="headerlink" title="ImageLocalityPriority"></a>ImageLocalityPriority</h4><p><code>ImageLocalityPriority</code>策略主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumImageScores</span><span class="params">(nodeInfo *framework.NodeInfo, containers []v1.Container, totalNumNodes <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> containers &#123;</span><br><span class="line"><span class="keyword">if</span> state, ok := nodeInfo.ImageStates[normalizedImageName(container.Image)]; ok &#123;</span><br><span class="line">sum += scaledImageScore(state, totalNumNodes)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(ImageLocalityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, imagelocality.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NodeLabel"><a href="#NodeLabel" class="headerlink" title="NodeLabel"></a>NodeLabel</h4><p><code>NodeLabel</code>策略主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v, node is nil: %v"</span>, nodeName, err, nodeInfo.Node() == <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line">score := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.PresentLabelsPreference &#123;</span><br><span class="line"><span class="keyword">if</span> labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">score += framework.MaxNodeScore</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.AbsentLabelsPreference &#123;</span><br><span class="line"><span class="keyword">if</span> !labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">score += framework.MaxNodeScore</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Take average score for each label to ensure the score doesn't exceed MaxNodeScore.</span></span><br><span class="line">score /= <span class="keyword">int64</span>(<span class="built_in">len</span>(pl.args.PresentLabelsPreference) + <span class="built_in">len</span>(pl.args.AbsentLabelsPreference))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(nodelabel.Name,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are n LabelPreference priorities in the policy, the weight for the corresponding</span></span><br><span class="line"><span class="comment">// score plugin is n*weight (note that the validation logic verifies that all LabelPreference</span></span><br><span class="line"><span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.NodeLabelArgs.PresentLabelsPreference)+<span class="built_in">len</span>(args.NodeLabelArgs.AbsentLabelsPreference))</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodelabel.Name, &amp;weight)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分析了Kubernetes内置的各种调度策略。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>【下厨房】电饭锅焖鸡腿</title>
    <link href="http://houmin.cc/posts/45418583/"/>
    <id>http://houmin.cc/posts/45418583/</id>
    <published>2020-07-26T14:23:43.000Z</published>
    <updated>2020-07-26T12:51:54.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。</p><a id="more"></a><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><div class="table-container"><table><thead><tr><th>原料</th><th>分量</th></tr></thead><tbody><tr><td>鸡腿</td><td>5只</td></tr><tr><td>洋葱</td><td>半只</td></tr><tr><td>姜</td><td>3片</td></tr><tr><td>水</td><td>3汤匙</td></tr></tbody></table></div><p>腌料</p><div class="table-container"><table><thead><tr><th>配料</th><th>分量</th></tr></thead><tbody><tr><td>老抽</td><td>1汤匙</td></tr><tr><td>生抽</td><td>1汤匙</td></tr><tr><td>料酒</td><td>1汤匙</td></tr><tr><td>糖</td><td>2汤匙</td></tr><tr><td>芝麻香油</td><td>1茶匙</td></tr><tr><td>盐</td><td>1/4茶匙</td></tr><tr><td>胡椒粉</td><td>适量</td></tr></tbody></table></div><blockquote><p>汤匙：15mL，茶匙：5mL</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>鸡腿洗净切几刀，便于入味</li><li>腌料拌匀，研制入味，冷藏半天或者一夜</li><li>电饭锅底铺上洋葱丝、小葱、姜片，水</li><li>放入腌制好的鸡腿，倒入腌制的汁</li><li>铺均匀后按下煮饭按钮，40分钟</li><li>中间20分钟翻动一次</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>倒入腌鸡腿的汁后不用加水了，因为洋葱也会出很多的水</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="吃顿好的" scheme="http://houmin.cc/categories/%E5%90%83%E9%A1%BF%E5%A5%BD%E7%9A%84/"/>
    
    
      <category term="下厨房" scheme="http://houmin.cc/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>Project Ocean</title>
    <link href="http://houmin.cc/posts/f7bd8265/"/>
    <id>http://houmin.cc/posts/f7bd8265/</id>
    <published>2020-07-26T13:10:19.000Z</published>
    <updated>2020-07-26T14:58:00.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。</p><p>然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。</p><a id="more"></a><h2 id="雄心勃勃的计划"><a href="#雄心勃勃的计划" class="headerlink" title="雄心勃勃的计划"></a>雄心勃勃的计划</h2><p>从工程师的角度来说，这个计划毋庸置疑是一个雄心勃勃的伟大的计划。如果这件事情做成了，这将是留给人类的一个伟大礼物。2000年后出版的图书是可以直接电子化的，问题在于将之前存在的纸质的图书电子化。人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。</p><p>然而，这么多的知识中，很大的一部分都深藏在世界上各大图书馆深深的房间中，很少有人能够访问。设想一下，如果这些积累了千年的知识电子化后，人们通过浏览器就可以搜索到对应的知识，这将有多么的大的裨益。</p><h2 id="技术的问题"><a href="#技术的问题" class="headerlink" title="技术的问题"></a>技术的问题</h2><ul><li>首先我们需要知道，有多少本书需要电子化。在2010年8月，也就是10年前，谷歌在博客中发了一条消息，说全世界总共有<code>129864880</code>册图书。这里主要是英文图书，如果算上其他文字的，还是在亿这个量级。</li><li>第二个问题，如何电子化。Google给的方法是扫描，他们研发了一套专门的扫描系统，每台仪器一小时可以数字化1000页左右的图书。</li></ul><blockquote><p>待扫描的书会被放在一个特别设计的自动支架上，支架可以适应不同的书脊，并且将图书固定。仪器上方有一排灯，还有价值至少1000美元的光学器材，包括四个摄像头，两个分别照着摊开的书的左右两半，还有一个负责确定扫描范围的光学雷达，它会在图书表面生成一层激光网格，从而捕捉到纸页的曲度。操作员负责手动翻页，因为也没有机器能比得上人手的快捷和轻柔了，然后脚踩踏板来触发相机进行拍照，一系列动作仿佛是在弹一架奇怪的钢琴。</p></blockquote><ul><li>是的，这个系统还是需要人来翻页的，因为也没有机器能比得上人手的快捷和轻柔了。</li><li>第三个问题，扫描后如何将这些扫描的照片转化为文字，识别书籍中的插图和图表、提取页码、把脚注转化为引用、将所有的书籍形成网络，形成一个知识库。这个就更多的是OCR和NLP等研究的领域。</li></ul><p>其实，Google并不是第一个产生这个想法，密歇根大学早就开始了其700万册图书馆藏数字化的计划。按照他们的计划，700万册图书需要1000年，而Google告诉他们，同样的事情，他们只需要六年。</p><blockquote><p>Google给密歇根大学图书馆提议：图书馆将所有的书借给谷歌，谷歌来替对方完成全部的扫描。最后你能得到你的全部馆藏的电子版，而谷歌将获得海量的还不曾被人问津的数据资源。布林如此描述谷歌对图书馆藏的渴望，“人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。”试想如果所有被尘封在纸页间的知识能够进入搜索引擎？</p><p>早在2004年之前，谷歌就开始了扫描工作。之后，谷歌和密歇根大学、哈佛、斯坦福、牛津、纽约公共图书馆和许多其他图书馆系统都订立了合约，并且以超过佩吉预言的速度，在十年多一点的时间里扫描了大约<strong>2500万册图书</strong>。图书扫描工作花掉了谷歌大约4亿美元。这项工作不仅仅依靠技术，还依靠强大的物流支持。</p></blockquote><ul><li>因为有的图书比较古老，在扫描过程中可能会出现错误。谷歌提出了一个机智的<a href="https://en.wikipedia.org/wiki/ReCAPTCHA" target="_blank" rel="external nofollow noopener noreferrer">ReCAPTCHA</a>计划用于解决在扫描中发现的错误。其基本思路是，为了验证人类所输入的文字是正确的，而不是随意输入，有两个字会被显示出来；一个是光学文字识别软件无法辨别的字，另一个是一个已经知道正确答案的字。如果用户正确的回答出已知正确答案的字，那么就假设所输入的另一个光学识别软件无法识别的字是认真的查看后被输入而非随便输入。</li></ul><h2 id="人的问题"><a href="#人的问题" class="headerlink" title="人的问题"></a>人的问题</h2><p>经过10年的时间，Google已经扫描了2500万册的图书，这是他们之前预计的图书总量五分之一。然而，在这个过程中，逐渐出现了很多反对的声音，并最终导致了这个项目的终止。</p><ul><li><p>美国作家协会和出版商对Google提出了集体诉讼，<strong>指控谷歌大规模侵犯知识产权</strong>，毕竟他们才有图书的版权。</p></li><li><p>Google则认为他们的目标是为了让用户能够检索图书，对于那些有版权的书，谷歌只能显示图书的片段，搜索结果中只能显示你搜索到的条目前后的几句话。Google认为他们只是制作了图书的副本，属于对于图书的合理使用。</p></li><li><p>事实上，这种版权问题早就发生在唱片、广播、有线电视等传统出版商身上，并不是版权所有者想要打压新技术，相反他们是想从新技术中分一杯羹。</p></li><li><p>随着诉讼的进展，出版商发现，他们实际上并不想阻止Google扫描绝版图书，甚至鼓励这种行为。</p></li><li><p>于是在这个过程中，Google，作家，出版商，图书馆四方进行了妥协，形成了「谷歌图书搜索修正协议」</p><ul><li>协议要求谷歌支付1亿2500万美元，其中包括一次性支付给它已经扫描过的图书的版权方的4500万美元（大约按每本书60美元计算），分别向出版商和作者支付的1550万美元和3000万美元诉讼费，以及用来创立图书版权登记处的3450万美元。</li><li>这项协议中也规定了到底应该如何展示和出售这些重获新生的绝版图书。按照协议，谷歌可以展示该书至多20%的部分来诱使用户购买，谷歌可以出售可下载的电子版，价格则由算法或者版权所有者来确定，由1.99美元到29.99美元不等。所有绝版书都会被打包存进一个“机构订阅数据库”，大学可以买下这个数据库，供全校师生免费搜索和阅读里面的全部书籍。</li><li>这个解决方案像是一个三赢——图书馆可以得到成千上万的图书，谷歌在图书搜索服务上的投资没有白费，作者和出版商能够从已经毫无商业价值的书中获得一笔新的收入来源。</li></ul></li><li><p>但是这个「谷歌图书搜索修正协议」引起了更大的争议</p><ul><li><p>学校的教授们担心发生在学术期刊市场的事情会在谷歌图书的数据库上重演，一旦图书馆和学校对订购谷歌的数据库产生依赖，订购价格将会像高利贷一样暴涨，最终涨的和各路学术期刊一样高</p></li><li><p>Google的竞争对手也觉得收到了这份协议的威胁。</p><ul><li><blockquote><p>微软公司就不出所料地声称，如果谷歌是唯一一个可以合法地检索绝版图书的搜索引擎，这无疑会强化谷歌在全世界作为搜索引擎霸主的地位。如果谷歌利用这些绝版图书来满足用户的长尾需求，这将是一个对于其他公司来说很不公平的竞争优势。</p></blockquote></li></ul></li></ul></li></ul><pre><code>- &gt;   &gt;  &gt; 亚马逊公司则担心这项协议会让谷歌建立一个无可匹敌的图书商店。亚马逊认为，任何想要出售绝版图书的人，都必须要一本一本地确认图书版权，这是最好的，但是集体诉讼的协议却让谷歌一次性获得了所有图书的授权。</code></pre><p>  随着一轮又一轮的诉讼与协议，现在的状态是，Google基本尘封了这个计划。之前扫描的这2500万册图书以50PB的大小的文件存在于硬盘上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.thepaper.cn/newsDetail_forward_1679335" target="_blank" rel="external nofollow noopener noreferrer">https://www.thepaper.cn/newsDetail_forward_1679335</a></li><li><a href="https://www.theatlantic.com/technology/archive/2017/04/the-tragedy-of-google-books/523320/" target="_blank" rel="external nofollow noopener noreferrer">Torching the Modern-Day Library of Alexandria</a></li><li>Blow Your Mind</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。&lt;/p&gt;
&lt;p&gt;然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-26_google-books.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="google" scheme="http://houmin.cc/tags/google/"/>
    
      <category term="图书" scheme="http://houmin.cc/tags/%E5%9B%BE%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【备忘录】Linux常见监控指标</title>
    <link href="http://houmin.cc/posts/7f85cd98/"/>
    <id>http://houmin.cc/posts/7f85cd98/</id>
    <published>2020-07-21T09:19:53.000Z</published>
    <updated>2020-07-22T03:36:13.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。</p><a id="more"></a><h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><p>CPU使用率衡量的是<strong>程序运行占用的CPU百分比</strong>。Linux的CPU使用率信息可以通过/proc/stat文件计算得到。<code>/proc/stat</code>包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计的，单位为jiffies。如下图所示，cpu一行指的是总的CPU信息，cpu0、cpu1、cpu2、cpu3几行指的是CPU各个核的CPU信息。从这里也可以看出这台服务器共有4个核。每列从左到右的<a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external nofollow noopener noreferrer">意思</a>为</p><ul><li><strong>user：</strong>从系统启动开始累计到当前时刻，用户态的CPU时间 ，不包含nice值为负进程所占用的时间</li><li><strong>nice：</strong>从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间</li><li><strong>system：</strong>从系统启动开始累计到当前时刻，内核态时间</li><li><strong>idle：</strong>从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间</li><li><strong>iowait：</strong>从系统启动开始累计到当前时刻，硬盘IO等待时间</li><li><strong>irq：</strong>从系统启动开始累计到当前时刻，硬中断时间</li><li><strong>softirq：</strong>从系统启动开始累计到当前时刻，软中断时间</li><li><strong>steal：</strong>在虚拟环境下 CPU 花在处理其他操作系统的时间，Linux 2.6.11 开始才开始支持。</li><li><strong>guest：</strong>在 Linux 内核控制下 CPU 为 guest 操作系统运行虚拟 CPU 的时间，Linux 2.6.24 开始才开始支持。</li><li><strong>guest_nice:</strong> 在 Linux 内核控制下 CPU 为 guest 操作系统在虚拟 CPU 中运行nice进程的时间，Linux 2.6.33 开始才开始支持。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/<span class="built_in">stat</span> | grep cpu</span><br><span class="line">cpu  180296 204 123070 30283108 13956 0 2046 0 0 0</span><br><span class="line">cpu0 45360 53 30785 7560073 10631 0 771 0 0 0</span><br><span class="line">cpu1 45266 47 30779 7573915 1373 0 508 0 0 0</span><br><span class="line">cpu2 44442 54 30724 7574282 1257 0 405 0 0 0</span><br><span class="line">cpu3 45228 48 30781 7574835 693 0 360 0 0 0</span><br></pre></td></tr></table></figure><p>根据这些信息，就可以计算出CPU使用率。网管Agent的CPU使用率采集算法如下（以CPU0为例）：</p><ul><li>cat /proc/stat | grep ‘cpu0’得到cpu0的信息</li><li>cpu_total1=user+nice+system+idle+iowait+irq+softirq</li><li>cpu_used1=user+nice+system+irq+softirq</li><li>sleep 15秒</li><li>再次cat /proc/stat | grep ‘cpu0’得到cpu的信息</li><li>cpu_total2=user+nice+system+idle+iowait+irq+softirq</li><li>cpu_used2=user+nice+system+irq+softirq</li><li>得到cpu0在15秒内的平均使用率：(cpu_used2 - cpu_used1) / (cpu_total2 - cpu_total1) * 100%</li></ul><p>每分钟会采集4次15秒内的CPU平均使用率。为了避免漏采集CPU峰值，可以取这一分钟内四次采集的最大值上报。</p><h2 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h2><p>系统负载指的是计算机系统执行计算工作的表现，CPU负载指的是在一段时间内计算机的系统负载，一般用1分钟内、5分钟内、15分钟内这三个数字衡量。通过<code>uptime</code>命令可以显示CPU负载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 14:34:03 up 10:43,  4 users,  load average: 0.06, 0.11, 0.09</span><br></pre></td></tr></table></figure><ul><li>对于单核单CPU，CPU负载为0表示CPU完全空闲，CPU负载为1.00表示CPU恰好发挥其最大能力，CPU负载大于1表示系统过载，有进程正在等待调度</li><li>对于多核或者多CPU系统，CPU负载为每个核的CPU负载总和</li></ul><p>关于CPU负载的计算机制，可以参考我的另一篇<a href="../">博客</a>。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p> <code>free</code>命令通过读取 <code>/proc/meminfo</code>，可以显示系统中的使用的和空闲的物理内存、Swap内存，同时也可以显示内核使用的buffer和cache，如下图所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free -w</span><br><span class="line">              total        used        free      shared     buffers       cache   available</span><br><span class="line">Mem:        7773244      311800     2456280         872      233560     4771604     7169352</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>其中各个字段意义为：</p><ul><li>total：所有可以使用的内存（包括/proc/meminfo中的MemTotal和SwapTotal）</li><li>used：使用的内存，通过 <code>total - free - buffers - cache</code> 计算得到</li><li>free：没有使用的内存（包括/proc/meminfo中的MemFree和SwapFree）</li><li>shared：主要是指tmpfs使用的内存，现在已经废弃不用，总是为0</li><li>buffers：被内核Buffers使用的内存</li><li>cache：被内核的Page Cache和Slab使用的内存</li><li>buff/cache：buffers和cache的总和</li><li>available：对于开启一个新的应用还能使用多少内存的估计，不同于cache和free内存外，还考虑了page cache和可再回收的slab内存</li></ul><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p>可以通过 <code>iostat</code>命令来监测磁盘的IO活动，它通过读取 <code>/proc/diskstats</code>文件来获取相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/diskstats</span></span><br><span class="line">3    0   hda 446216 784926 9550688 4382310 424847 312726 5922052 19310380 0 3376340 23705160 0 0 0 0</span><br></pre></td></tr></table></figure><p>hda后的各个参数含义如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Field</span>  <span class="number">1</span> --<span class="meta"> # of reads completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">2</span> --<span class="meta"> # of reads merged, field 6 -- # of writes merged</span></span><br><span class="line">为了提高IO的效率，两个相邻的读写操作会被合并，所以两个<span class="number">4</span>K的读操作在提交给磁盘之前会被合并为一个<span class="number">8</span>K的读操作，杜宇磁盘来说只会视作只有一个读操作。</span><br><span class="line"><span class="keyword">Field</span>  <span class="number">3</span> --<span class="meta"> # of sectors read</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">4</span> --<span class="meta"> # of milliseconds spent reading</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">5</span> --<span class="meta"> # of writes completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">6</span> --<span class="meta"> # of writes merged</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">7</span> --<span class="meta"> # of sectors written</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">8</span> --<span class="meta"> # of milliseconds spent writing</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">9</span> --<span class="meta"> # of I/Os currently in progress</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">10</span> --<span class="meta"> # of milliseconds spent doing I/Os</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">12</span> --<span class="meta"> # of discards completed</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">13</span> --<span class="meta"> # of discards merged</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">14</span> --<span class="meta"> # of sectors discarded</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">15</span> --<span class="meta"> # of milliseconds spent discarding</span></span><br></pre></td></tr></table></figure><p>跟记录CPU信息的/proc/stat文件一样，/proc/diskstats中每个字段的数值也是从系统启动后一直累加的。通过这些参数，可以计算出通过 <code>iostat</code>命令算出的参数，具体可以参考<a href="../#iostat">iostat</a> 。我们用delta来表示在时间t内某个字段的增量。例如<strong>定义delta(reads merged)为当前reads merged的值减去t秒前reads merged的值</strong>。</p><ul><li>rrqm/s：delta(<em>reads merged</em>) / t  （得到时间t内平均每秒reads merged的值）</li><li>wrqm/s：delta(<em>writes merged</em>) / t</li><li>r/s：delta(<em>reads completed</em>) / t</li><li>w/s：delta(<em>writes completed</em>) / t</li><li>rsec/s：delta(<em>sectors read</em>) / t</li><li>wsec/s：delta(<em>sectors written</em>) / t</li><li>rkB/s：delta(<em>sectors read</em>) / t / 2  （因为1 扇区为512字节，所以rkB/s为rsec/s的一半）</li><li>wkB/s：delta(<em>sectors written</em>) / t / 2</li><li>avgrq-sz：(delta(<em>sectors read</em>) + delta(<em>sectors written</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li><li><strong>avgqu-sz</strong>：<em>*delta(</em>weighted time spent doing I/Os*) / t / 1000 （单位为毫秒，所以除以1000）</li><li><strong>await：</strong>(delta(<em>time spent reading</em>) + delta(<em>time spent writing</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li><li><strong>svctm：</strong>delta(<em>time spent doing I/Os</em>)/ (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))**</li><li><strong>%util：</strong>delta(<em>time spent doing I/Os</em>) / t / 1000 * 100%</li></ul><p>所有磁盘汇总采集项：</p><div class="table-container"><table><thead><tr><th>采集项</th><th>采集项说明</th><th>是否乘以100以保留精度</th></tr></thead><tbody><tr><td>avgqu_sz_max</td><td>所有磁盘avgqu_sz最大值</td><td>是</td></tr><tr><td>svctm_time_max</td><td>所有磁盘svctm最大值</td><td>是</td></tr><tr><td>await_time_max</td><td>所有磁盘await最大值</td><td>是</td></tr><tr><td>util_max</td><td>所有磁盘%util最大值</td><td>否</td></tr><tr><td>disk_total_read</td><td>所有磁盘的r/s总和</td><td>是</td></tr><tr><td>disk_total_write</td><td>所有磁盘的w/s总和</td><td>是</td></tr><tr><td>磁盘IO disk_block_in</td><td>所有磁盘的rkB/s总和。bi即block in，表示从块设备（如磁盘）读取的块数。Linux块设备的块大小都为1024字节，所以disk_bi等于rkB/s。</td><td>否</td></tr><tr><td>磁盘IO disk_block_out</td><td>所有磁盘的rkB/s总和bo即block out，表示发给块设备的块数，即写磁盘。Linux块设备的块大小都为1024字节，所以disk_bi等于wkB/s。</td><td>否</td></tr></tbody></table></div><p>单个磁盘采集项：</p><p>对于安装了1个以上的磁盘的服务器，可以采集单个磁盘的IO数据。最多支持24个盘。</p><div class="table-container"><table><thead><tr><th>采集项</th><th>采集项说明</th><th>是否乘以100以保留精度</th></tr></thead><tbody><tr><td>disk_n_util（n为0-23）</td><td>第n个磁盘的%util值</td><td>否</td></tr><tr><td>disk_n_await</td><td>第n个磁盘的await值</td><td>是</td></tr><tr><td>disk_n_read</td><td>第n个磁盘的r/s值</td><td>是</td></tr><tr><td>disk_n_write</td><td>第n个磁盘的w/s值</td><td>是</td></tr><tr><td>disk_n_block_in</td><td>第n个磁盘的rkB/s值</td><td>否</td></tr><tr><td>disk_n_block_out</td><td>第n个磁盘的wkB/s值</td><td>否</td></tr></tbody></table></div><h2 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h2><h3 id="流量包量"><a href="#流量包量" class="headerlink" title="流量包量"></a>流量包量</h3><p>通过<code>/proc/net/dev</code>文件，可以计算出服务器的流量及包量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/dev</span></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   69570    1756    0    0    0     0          0         0    69570    1756    0    0    0     0       0          0</span><br><span class="line">  eth0: 2012939491 4197833    0    0    0     0          0         0 277523863 3280731    0    0    0     0       0          0</span><br><span class="line">docker0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0</span><br></pre></td></tr></table></figure><p>与记录CPU信息的 <code>/proc/stat</code>文件类似，<code>/proc/net/dev</code>中的数值，也是从系统启动后一直累加的。</p><p>计算网卡流量方法如下：</p><ul><li>读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes0、receive_packets0、transmit_bytes0、transmit_packets0</li><li>sleep 60秒</li><li>再次读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes1、receive_packets1、transmit_bytes1、transmit_packets1</li><li>根据60秒前后的/proc/net/dev文件，便可计算出下面的指标：<ul><li>60秒内平均每秒入流量：(receive_bytes1 - receive_bytes0) * 8 / 60 / 1000 （kbps）（乘以8是为了把bytes转成bit，除以1000是为了把单位转成k，除以60则是取60秒内的平均值）</li><li>60 秒内平均每秒出流量：(transmit_bytes1 - transmit_bytes0) * 8 / 60 / 1000 （kbps）</li><li>60秒内平均每秒入包数：(receive_packets1 - receive_packets0) / 60 （个）</li><li>60秒内平均每秒出包数：(transmit_packets1 - transmit_packets0) / 60 （个）</li></ul></li></ul><h3 id="TCP连接数"><a href="#TCP连接数" class="headerlink" title="TCP连接数"></a>TCP连接数</h3><p><code>/proc/net/snmp</code>记录了一些TCP信息，其中比较有用的是 <code>CurrEstab</code>字段，即当前已建立的TCP连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/snmp</span></span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 3527912 0 23 1893737 0 0 1634151 3266670 18 40 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 92566 32 0 65 0 0 0 0 92501 0 0 0 0 0 93265 0 746 0 0 0 18 0 92501 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType8 OutType0 OutType3 OutType5</span><br><span class="line">IcmpMsg: 65 92501 92501 746 18</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 65567 687 59 249 8 1516787 1268763 805 4 33191 4</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">Udp: 22034 822 0 21968 0 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="UDP接收和发送数据报"><a href="#UDP接收和发送数据报" class="headerlink" title="UDP接收和发送数据报"></a>UDP接收和发送数据报</h3><p><code>/proc/net/snmp</code>还记录了一些UDP信息，其中比较有用的是<code>InDatagrams</code>及<code>OutDatagrams</code>字段。 </p><p>UDP接收和发送数据报计算方法与 <code>/proc/net/dev</code>类似，步骤如下：</p><ul><li>读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data0和out_data0</li><li>Sleep 240秒</li><li>再次读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data1和out_data1</li><li>根据240秒前后的/proc/net/snmp文件，便可计算下面两个指标：<ul><li>240秒内平均每秒UDP入数据报：(in_data1 - in_data0) / 240</li><li>240秒内平均每秒UDP出数据报：(out_data1 - out_data0) / 240</li></ul></li><li>UDP数据每240上报一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://upload.wikimedia.org/wikipedia/commons/b/b1/Htop.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="linux" scheme="http://houmin.cc/tags/linux/"/>
    
      <category term="stats" scheme="http://houmin.cc/tags/stats/"/>
    
      <category term="monitor" scheme="http://houmin.cc/tags/monitor/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】List/Watch机制和Informer模块详解</title>
    <link href="http://houmin.cc/posts/1f0eb2ff/"/>
    <id>http://houmin.cc/posts/1f0eb2ff/</id>
    <published>2020-07-20T07:46:29.000Z</published>
    <updated>2020-07-21T02:16:52.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。</p><a id="more"></a><h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>Kubernetes中的组件，如果要访问Kubernetes中的Object，绝大部分情况下会使用Informer中的Lister()方法，而非直接请求Kubernetes API。</p><h1 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h1><p><img alt="img" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png"></p><p><img alt="Client-go Controller Interaction" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p><h2 id="client-go组件"><a href="#client-go组件" class="headerlink" title="client-go组件"></a>client-go组件</h2><ul><li><code>Reflector</code>：reflector用来watch特定的k8s API资源。具体的实现是通过<code>ListAndWatch</code>的方法，watch可以是k8s内建的资源或者是自定义的资源。当reflector通过watch API接收到有关新资源实例存在的通知时，它使用相应的列表API获取新创建的对象，并将其放入watchHandler函数内的Delta Fifo队列中。</li><li><code>Informer</code>：informer从Delta Fifo队列中弹出对象。执行此操作的功能是processLoop。base controller的作用是保存对象以供以后检索，并调用我们的控制器将对象传递给它。</li><li><code>Indexer</code>：索引器提供对象的索引功能。典型的索引用例是基于对象标签创建索引。 Indexer可以根据多个索引函数维护索引。Indexer使用线程安全的数据存储来存储对象及其键。 在Store中定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数生成对象的键作为该对象的<code>&lt;namespace&gt; / &lt;name&gt;</code>组合。</li></ul><h2 id="自定义controller组件"><a href="#自定义controller组件" class="headerlink" title="自定义controller组件"></a>自定义controller组件</h2><ul><li><code>Informer reference</code>：指的是Informer实例的引用，定义如何使用自定义资源对象。 自定义控制器代码需要创建对应的Informer。</li><li><code>Indexer reference</code>: 自定义控制器对Indexer实例的引用。自定义控制器需要创建对应的Indexser。</li></ul><blockquote><p>client-go中提供<code>NewIndexerInformer</code>函数可以创建Informer 和 Indexer。</p></blockquote><ul><li><code>Resource Event Handlers</code>：资源事件回调函数，当它想要将对象传递给控制器时，它将被调用。 编写这些函数的典型模式是获取调度对象的key，并将该key排入工作队列以进行进一步处理。</li><li><code>Workqueue</code>：任务队列。 编写资源事件处理程序函数以提取传递的对象的key并将其添加到任务队列。</li><li><code>Process Item</code>：处理任务队列中对象的函数， 这些函数通常使用Indexer引用或Listing包装器来重试与该key对应的对象。</li></ul><h1 id="关键设计"><a href="#关键设计" class="headerlink" title="关键设计"></a>关键设计</h1><p>Informer依赖Kubernetes的List/Watch API。 通过Lister()对象来List/Get对象时，Informer不会去请求Kubernetes API，而是直接查询本地缓存，减少对Kubernetes API的直接调用。</p><p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p><p>Informer组件：</p><ul><li>Controller</li><li>Reflector：通过Kubernetes Watch API监听resource下的所有事件</li><li>Lister：用来被调用List/Get方法</li><li>Processor：记录并触发回调函数</li><li>DeltaFIFO</li><li>LocalStore</li></ul><p>DeltaFIFO和LocalStore是Informer的两级缓存。 DeltaFIFO：用来存储Watch API返回的各种事件。 LocalStore：Lister的List/Get方法访问。</p><p>我们以 Pod 为例，详细说明一下 Informer 的关键逻辑：</p><ol><li>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</li><li>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</li><li>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</li><li>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</li><li>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</li><li>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</li><li>DeltaFIFO 再 Pop 这个事件到 Controller 中</li><li>Controller 收到这个事件，会触发 Processor 的回调函数</li></ol><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737350162-8e7c6121-2b0a-49fa-8ad8-a7b714de3445.png"></p><p>之前说到kubernetes里面的apiserver的只负责数据的CRUD接口实现，并不负责业务逻辑的处理，所以k8s中就通过外挂controller通过对应资源的控制器来负责事件的处理，controller如何感知事件呢？答案就是informer</p><h2 id="基于chunk的消息通知"><a href="#基于chunk的消息通知" class="headerlink" title="基于chunk的消息通知"></a>基于chunk的消息通知</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737386982-feae09ae-ac6d-4090-8ca2-d2f3f5120d61.png"></p><p>watcher的设计在之前的文章中已经介绍，服务端是如何将watcher感知到的事件发送给informer呢？我们提到过apiserver本质上就是一个http的rest接口实现，watch机制则也是基于http协议，不过不同于一般的get其通过chunk机制，来实现消息的通知</p><h2 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737435884-518fce5a-0118-4935-be61-0716e2c3ba0c.png"></p><p>服务端通过chunk进行数据的发送，在客户端同样的需要根据对应的chunk来进行数据的解包，同时还要维护这个长链接</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737496494-8a3052e1-7837-46d9-9513-8d3a64ffe8ba.png"></p><p>通过listwatch接口主要分为两部分，list接口我们可以获取到对应资源当前版本的全量资源，watch接口可以获取到后续变更的资源，通过全量加增量的数据，就构成了在client端一份完整的数据(基于当前版本的)，那后续如果要获取对应的数据，就直接可以通过本地的缓存来进行获取，为此informer抽象了cache这个组件，并且实现了store接口，如果后续要获取资源，则就可以通过本地的缓存来进行获取</p><h2 id="本地索引"><a href="#本地索引" class="headerlink" title="本地索引"></a>本地索引</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737549651-a3636652-fc91-49e1-a91e-9f5e18b05672.png"></p><p>上面将资源缓存在本地的内存中，那如果我们要进行数据查询，快速检索数据，这个时候就需要用到informer里面的indexer, 我们可以注册不同的索引函数，在添加对象的时候，会通过indexer为其建立对应的索引，这样后续我们就可以通过key来检索获取元数据</p><h2 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737669393-995cf89c-87f6-4749-9086-b9febee3a692.png"></p><p>为了协调数据生产与消费的不一致状态，在cleint-go中通过实现了一个无界队列来进行数据的缓冲，当reflector获取到数据之后，只需要将数据写入到无界队列中，则就可以继续watch后续事件，从而减少阻塞时间， 下面的事件去重也是在该队列中实现的</p><h2 id="事件去重"><a href="#事件去重" class="headerlink" title="事件去重"></a>事件去重</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737745807-e10d9521-5633-4cf7-9a0f-90ce2a3dee46.png"></p><p>事件去重是指的，在上面的无界队列中，如果针对某个资源的事件重复被触发，则就只会保留相同事件最后一个事件作为后续处理</p><p>到此对于事件接收和数据缓存相关优化就结束了，接下就是处理层的优化</p><h2 id="复用连接"><a href="#复用连接" class="headerlink" title="复用连接"></a>复用连接</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737835151-715cdc2b-b53a-4208-85d8-2383fdef8b8f.png"></p><p>在k8s中一些控制器可能会关注多种资源，比如Deployment可能会关注Pod和replicaset，replicaSet可能还会关注Pod，为了避免每个控制器都独立的去与apiserver建立链接，k8s中抽象了sharedInformer的概念，即共享的informer, 针对同一资源只建立一个链接</p><h2 id="基于观察者模式的注册"><a href="#基于观察者模式的注册" class="headerlink" title="基于观察者模式的注册"></a>基于观察者模式的注册</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738078512-ade28ada-2824-46d3-af63-45873a8a37a4.png"></p><p>因为彼此共用informer,但是每个组件的处理逻辑可能各部相同，在informer中通过观察者模式，各个组件可以注册一个EventHandler来实现业务逻辑的注入</p><h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738429252-bd646701-8543-47cd-a638-552ac419f5c9.png"></p><h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>该部分的代码主要位于<code>client-go</code>这个第三方包中。</p><p>此部分的逻辑主要位于<code>/vendor/k8s.io/client-go/tools/cache</code>包中，代码目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cache</span><br><span class="line">├── controller.go  <span class="comment"># 包含：Config、Run、processLoop、NewInformer、NewIndexerInformer</span></span><br><span class="line">├── delta_fifo.go  <span class="comment"># 包含：NewDeltaFIFO、DeltaFIFO、AddIfNotPresent</span></span><br><span class="line">├── expiration_cache.go</span><br><span class="line">├── expiration_cache_fakes.go</span><br><span class="line">├── fake_custom_store.go</span><br><span class="line">├── fifo.go   <span class="comment"># 包含：Queue、FIFO、NewFIFO</span></span><br><span class="line">├── heap.go</span><br><span class="line">├── index.go    <span class="comment"># 包含：Indexer、MetaNamespaceIndexFunc</span></span><br><span class="line">├── listers.go</span><br><span class="line">├── listwatch.go   <span class="comment"># 包含：ListerWatcher、ListWatch、List、Watch</span></span><br><span class="line">├── mutation_cache.go</span><br><span class="line">├── mutation_detector.go</span><br><span class="line">├── reflector.go   <span class="comment"># 包含：Reflector、NewReflector、Run、ListAndWatch</span></span><br><span class="line">├── reflector_metrics.go</span><br><span class="line">├── shared_informer.go  <span class="comment"># 包含：NewSharedInformer、WaitForCacheSync、Run、HasSynced</span></span><br><span class="line">├── store.go  <span class="comment"># 包含：Store、MetaNamespaceKeyFunc、SplitMetaNamespaceKey</span></span><br><span class="line">├── testing</span><br><span class="line">│   ├── fake_controller_source.go</span><br><span class="line">├── thread_safe_store.go  <span class="comment"># 包含：ThreadSafeStore、threadSafeMap</span></span><br><span class="line">├── undelta_store.go</span><br></pre></td></tr></table></figure><h2 id="sharedInformerFactory-Start"><a href="#sharedInformerFactory-Start" class="headerlink" title="sharedInformerFactory.Start"></a>sharedInformerFactory.Start</h2><p>在controller-manager的Run函数部分调用了InformerFactory.Start的方法。</p><blockquote><p>此部分代码位于/cmd/kube-controller-manager/app/controllermanager.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">        <span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InformerFactory是一个<code>SharedInformerFactory</code>的接口，接口定义如下：</p><blockquote><p>此部分代码位于vendor/k8s.io/client-go/informers/internalinterfaces/factory_interfaces.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SharedInformerFactory a small interface to allow for adding an informer without an import cycle</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    InformerFor(obj runtime.Object, newFunc NewInformerFunc) cache.SharedIndexInformer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。其中，通过<code>startdInformers</code>这个map用来追踪有哪些Informer已经启动，从而可以让Start方法被多次调用。</p><blockquote><p>此部分代码位于vendor/k8s.io/client-go/informers/factory.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">        <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">            <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">            f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sharedIndexInformer-Run"><a href="#sharedIndexInformer-Run" class="headerlink" title="sharedIndexInformer.Run"></a>sharedIndexInformer.Run</h2><blockquote><p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/shared_informer.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ListerWatcher:    s.listerWatcher,</span><br><span class="line">        ObjectType:       s.objectType,</span><br><span class="line">        FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">        RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">        Process: s.HandleDeltas,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">        s.controller = New(cfg)</span><br><span class="line">        s.controller.(*controller).clock = s.clock</span><br><span class="line">        s.started = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">    processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">        s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">    &#125;()</span><br><span class="line">    s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDeltaFIFO"><a href="#NewDeltaFIFO" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><p>DeltaFIFO是一个对象变化的存储队列，依据先进先出的原则，process的函数接收该队列的Pop方法的输出对象来处理相关功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>构造controller的配置文件，构造process，即HandleDeltas，该函数为后面使用到的process函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>调用New(cfg)，构建sharedIndexInformer的controller。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">    s.controller = New(cfg)</span><br><span class="line">    s.controller.(*controller).clock = s.clock</span><br><span class="line">    s.started = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="cacheMutationDetector-Run"><a href="#cacheMutationDetector-Run" class="headerlink" title="cacheMutationDetector.Run"></a>cacheMutationDetector.Run</h3><p>调用s.cacheMutationDetector.Run，检查缓存对象是否变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br></pre></td></tr></table></figure><p><strong>defaultCacheMutationDetector.Run</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we DON'T want protection from panics.  If we're running this code, we want to die</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d.CompareObjects()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(d.period):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CompareObjects</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">CompareObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> d.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    altered := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, obj := <span class="keyword">range</span> d.cachedObjs &#123;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(obj.cached, obj.copied) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"CACHE %s[%d] ALTERED!\n%v\n"</span>, d.name, i, diff.ObjectDiff(obj.cached, obj.copied))</span><br><span class="line">            altered = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> altered &#123;</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"cache %s modified"</span>, d.name)</span><br><span class="line">        <span class="keyword">if</span> d.failureFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">            d.failureFunc(msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processor-run"><a href="#processor-run" class="headerlink" title="processor.run"></a>processor.run</h3><p>调用s.processor.run，将调用sharedProcessor.run，会调用Listener.run和Listener.pop,执行处理queue的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.processor.run)</span><br></pre></td></tr></table></figure><p><strong>sharedProcessor.Run</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.listenersLock.RLock()</span><br><span class="line">        <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            p.wg.Start(listener.run)</span><br><span class="line">            p.wg.Start(listener.pop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">        <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分逻辑待后面分析。</p><h3 id="controller-Run"><a href="#controller-Run" class="headerlink" title="controller.Run"></a>controller.Run</h3><p>调用s.controller.Run，构建Reflector，进行对etcd的缓存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">    s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">&#125;()</span><br><span class="line">s.controller.Run(stopCh)</span><br></pre></td></tr></table></figure><p>controller.Run</p><blockquote><p>此部分代码位于/vendor/k8s.io/client-go/tools/cache/controller.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins processing items, and will continue until a value is sent down stopCh.</span></span><br><span class="line"><span class="comment">// It's an error to call Run more than once.</span></span><br><span class="line"><span class="comment">// Run blocks; call via go.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        c.config.Queue.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    r.ShouldResync = c.config.ShouldResync</span><br><span class="line">    r.clock = c.clock</span><br><span class="line"></span><br><span class="line">    c.reflectorMutex.Lock()</span><br><span class="line">    c.reflector = r</span><br><span class="line">    c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line"></span><br><span class="line">    wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建Reflector</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">    c.config.ListerWatcher,</span><br><span class="line">    c.config.ObjectType,</span><br><span class="line">    c.config.Queue,</span><br><span class="line">    c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 运行Reflector</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"><span class="comment">// 执行processLoop</span></span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br></pre></td></tr></table></figure><h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><h3 id="Reflector-1"><a href="#Reflector-1" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p><p>常用属性说明：</p><ul><li>expectedType：期望放入缓存store的资源类型。</li><li>store：watch的资源对应的本地缓存。</li><li>listerWatcher：list和watch的接口。</li><li>period：watch的周期，默认为1秒。</li><li>resyncPeriod：resync的周期，当非零的时候，会按该周期执行list。</li><li>lastSyncResourceVersion：最新一次看到的资源的版本号，主要在watch时候使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflector watches a specified resource and causes all changes to be reflected in the given store.</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">    metrics *reflectorMetrics</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The type of object we expect to place in the store.</span></span><br><span class="line">    expectedType reflect.Type</span><br><span class="line">    <span class="comment">// The destination to sync up with the watch source</span></span><br><span class="line">    store Store</span><br><span class="line">    <span class="comment">// listerWatcher is used to perform lists and watches.</span></span><br><span class="line">    listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// period controls timing between one watch ending and</span></span><br><span class="line">    <span class="comment">// the beginning of the next one.</span></span><br><span class="line">    period       time.Duration</span><br><span class="line">    resyncPeriod time.Duration</span><br><span class="line">    ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// lastSyncResourceVersion is the resource version token last</span></span><br><span class="line">    <span class="comment">// observed when doing a sync with the underlying store</span></span><br><span class="line">    <span class="comment">// it is thread safe, but not synchronized with the underlying store</span></span><br><span class="line">    lastSyncResourceVersion <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">    lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewReflector"><a href="#NewReflector" class="headerlink" title="NewReflector"></a>NewReflector</h3><p>NewReflector主要用来构建Reflector的结构体。</p><blockquote><p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/reflector.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReflector creates a new Reflector object which will keep the given store up to</span></span><br><span class="line"><span class="comment">// date with the server's contents for the given resource. Reflector promises to</span></span><br><span class="line"><span class="comment">// only put things in the store that have the type of expectedType, unless expectedType</span></span><br><span class="line"><span class="comment">// is nil. If resyncPeriod is non-zero, then lists will be executed after every</span></span><br><span class="line"><span class="comment">// resyncPeriod, so that you can use reflectors to periodically process everything as</span></span><br><span class="line"><span class="comment">// well as incrementally processing the things that change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflectorDisambiguator is used to disambiguate started reflectors.</span></span><br><span class="line"><span class="comment">// initialized to an unstable value to ensure meaning isn't attributed to the suffix.</span></span><br><span class="line"><span class="keyword">var</span> reflectorDisambiguator = <span class="keyword">int64</span>(time.Now().UnixNano() % <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflector-Run"><a href="#Reflector-Run" class="headerlink" title="Reflector.Run"></a>Reflector.Run</h3><p>Reflector.Run主要执行了<code>ListAndWatch</code>的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span></span><br><span class="line"><span class="comment">// Run will exit when stopCh is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</span><br><span class="line">    wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            utilruntime.HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListAndWatch first lists all items and get the resource version at the moment of call,</span></span><br><span class="line"><span class="comment">// and then use the resource version to watch.</span></span><br><span class="line"><span class="comment">// It returns error if ListAndWatch didn't even try to initialize watch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line">    <span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line">    <span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line">    <span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line">    options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">    r.metrics.numberOfLists.Inc()</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    list, err := r.listerWatcher.List(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.listDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">    items, err := meta.ExtractList(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.numberOfItemsInList.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(items)))</span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将资源的版本号设置为0，然后调用<code>listerWatcher.List(options)</code>，列出所有list的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号设置为0</span></span><br><span class="line">options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line"><span class="comment">// list接口</span></span><br><span class="line">list, err := r.listerWatcher.List(options)</span><br></pre></td></tr></table></figure><p>获取资源版本号，并将list的内容提取成对象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line">resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line"><span class="comment">// 将list的内容提取成对象列表</span></span><br><span class="line">items, err := meta.ExtractList(list)</span><br></pre></td></tr></table></figure><p>将list中对象列表的内容和版本号存储到本地的缓存store中，并全量替换已有的store的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.syncWith(items, resourceVersion)</span><br></pre></td></tr></table></figure><p>syncWith调用了store的Replace的方法来替换原来store中的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncWith replaces the store's items with the given list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        found = <span class="built_in">append</span>(found, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Store.Replace方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后设置最新的资源版本号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.setLastSyncResourceVersion(resourceVersion)</span><br></pre></td></tr></table></figure><p>setLastSyncResourceVersion:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">setLastSyncResourceVersion</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    r.lastSyncResourceVersionMutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.lastSyncResourceVersionMutex.Unlock()</span><br><span class="line">    r.lastSyncResourceVersion = v</span><br><span class="line"></span><br><span class="line">    rv, err := strconv.Atoi(v)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.metrics.lastResourceVersion.Set(<span class="keyword">float64</span>(rv))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="store-Resync"><a href="#store-Resync" class="headerlink" title="store.Resync"></a>store.Resync</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resyncCh, cleanup := r.resyncChan()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cleanup() <span class="comment">// Call the last one written into cleanup</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.ShouldResync == <span class="literal">nil</span> || r.ShouldResync() &#123;</span><br><span class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line">            <span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                resyncerrc &lt;- err</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanup()</span><br><span class="line">        resyncCh, cleanup = r.resyncChan()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.store.Resync()</span><br></pre></td></tr></table></figure><p>store的具体对象为<code>DeltaFIFO</code>，即调用DeltaFIFO.Resync</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resync will send a sync event for each item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keys := f.knownObjects.ListKeys()</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">    options = metav1.ListOptions&#123;</span><br><span class="line">        ResourceVersion: resourceVersion,</span><br><span class="line">        <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">        <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">        TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.metrics.numberOfWatches.Inc()</span><br><span class="line">    w, err := r.listerWatcher.Watch(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">        <span class="keyword">case</span> io.EOF:</span><br><span class="line">            <span class="comment">// watch closed normally</span></span><br><span class="line">        <span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">            glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line">        <span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line">        <span class="comment">// watch where we ended.</span></span><br><span class="line">        <span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line">        <span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置watch的超时时间，默认为5分钟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">options = metav1.ListOptions&#123;</span><br><span class="line">    ResourceVersion: resourceVersion,</span><br><span class="line">    <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">    <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">    TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行listerWatcher.Watch(options)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w, err := r.listerWatcher.Watch(options)</span><br></pre></td></tr></table></figure><p>执行watchHandler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh)</span><br></pre></td></tr></table></figure><h4 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h4><p>watchHandler主要是通过watch的方式保证当前的资源版本是最新的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    eventCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stopping the watcher should be idempotent and if we return from this function there's no way</span></span><br><span class="line">    <span class="comment">// we're coming back in with the same watch interface.</span></span><br><span class="line">    <span class="keyword">defer</span> w.Stop()</span><br><span class="line">    <span class="comment">// update metrics</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r.metrics.numberOfItemsInWatch.Observe(<span class="keyword">float64</span>(eventCount))</span><br><span class="line">        r.metrics.watchDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span> errorStopRequested</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> event.Type == watch.Error &#123;</span><br><span class="line">                <span class="keyword">return</span> apierrs.FromObject(event.Object)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            meta, err := meta.Accessor(event.Object)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">            <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">            <span class="keyword">case</span> watch.Added:</span><br><span class="line">                err := r.store.Add(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Modified:</span><br><span class="line">                err := r.store.Update(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Deleted:</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">                <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">                <span class="comment">// to change this.</span></span><br><span class="line">                err := r.store.Delete(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">            &#125;</span><br><span class="line">            *resourceVersion = newResourceVersion</span><br><span class="line">            r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">            eventCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchDuration := r.clock.Now().Sub(start)</span><br><span class="line">    <span class="keyword">if</span> watchDuration &lt; <span class="number">1</span>*time.Second &amp;&amp; eventCount == <span class="number">0</span> &#123;</span><br><span class="line">        r.metrics.numberOfShortWatches.Inc()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received"</span>, r.name)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: Watch close - %v total %v items received"</span>, r.name, r.expectedType, eventCount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取watch接口中的事件的channel，来获取事件的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获得添加、更新、删除的事件时，将对应的对象更新到本地缓存store中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line"><span class="keyword">case</span> watch.Added:</span><br><span class="line">    err := r.store.Add(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Modified:</span><br><span class="line">    err := r.store.Update(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Deleted:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">    <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">    <span class="comment">// to change this.</span></span><br><span class="line">    err := r.store.Delete(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新当前的最新版本号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">*resourceVersion = newResourceVersion</span><br><span class="line">r.setLastSyncResourceVersion(newResourceVersion)</span><br></pre></td></tr></table></figure><p>通过对Reflector模块的分析，可以看到多次使用到本地缓存store模块，而store的数据由DeltaFIFO赋值而来，以下针对DeltaFIFO和store做分析。</p><h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO由NewDeltaFIFO初始化，并赋值给config.Queue。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDeltaFIFO-1"><a href="#NewDeltaFIFO-1" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeltaFIFO returns a Store which can be used process changes to items.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// keyFunc is used to figure out what key an object should have. (It's</span></span><br><span class="line"><span class="comment">// exposed in the returned DeltaFIFO's KeyOf() method, with bonus features.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'compressor' may compress as many or as few items as it wants</span></span><br><span class="line"><span class="comment">// (including returning an empty slice), but it should do what it</span></span><br><span class="line"><span class="comment">// does quickly since it is called while the queue is locked.</span></span><br><span class="line"><span class="comment">// 'compressor' may be nil if you don't want any delta compression.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'keyLister' is expected to return a list of keys that the consumer of</span></span><br><span class="line"><span class="comment">// this queue "knows about". It is used to decide which items are missing</span></span><br><span class="line"><span class="comment">// when Replace() is called; 'Deleted' deltas are produced for these items.</span></span><br><span class="line"><span class="comment">// It may be nil if you don't need to detect all deletions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider merging keyLister with this object, tracking a list of</span></span><br><span class="line"><span class="comment">//       "known" keys when Pop() is called. Have to think about how that</span></span><br><span class="line"><span class="comment">//       affects error retrying.</span></span><br><span class="line"><span class="comment">// TODO(lavalamp): I believe there is a possible race only when using an</span></span><br><span class="line"><span class="comment">//                 external known object source that the above TODO would</span></span><br><span class="line"><span class="comment">//                 fix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Also see the comment on DeltaFIFO. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeltaFIFO</span><span class="params">(keyFunc KeyFunc, compressor DeltaCompressor, knownObjects KeyListerGetter)</span> *<span class="title">DeltaFIFO</span></span> &#123;</span><br><span class="line">    f := &amp;DeltaFIFO&#123;</span><br><span class="line">        items:           <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas&#123;&#125;,</span><br><span class="line">        queue:           []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">        keyFunc:         keyFunc,</span><br><span class="line">        deltaCompressor: compressor,</span><br><span class="line">        knownObjects:    knownObjects,</span><br><span class="line">    &#125;</span><br><span class="line">    f.cond.L = &amp;f.lock</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller.Run的部分调用了NewReflector。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewReflector构造函数，将c.config.Queue赋值给Reflector.store的属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DeltaFIFO-1"><a href="#DeltaFIFO-1" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p><p>DeltaFIFO主要用在以下场景：</p><ul><li>希望对象变更最多处理一次</li><li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li><li>要处理对象的删除</li><li>希望定期重新处理对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaFIFO is like FIFO, but allows you to process deletes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO is a producer-consumer queue, where a Reflector is</span></span><br><span class="line"><span class="comment">// intended to be the producer, and the consumer is whatever calls</span></span><br><span class="line"><span class="comment">// the Pop() method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO solves this use case:</span></span><br><span class="line"><span class="comment">//  * You want to process every object change (delta) at most once.</span></span><br><span class="line"><span class="comment">//  * When you process an object, you want to see everything</span></span><br><span class="line"><span class="comment">//    that's happened to it since you last processed it.</span></span><br><span class="line"><span class="comment">//  * You want to process the deletion of objects.</span></span><br><span class="line"><span class="comment">//  * You might want to periodically reprocess objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO's Pop(), Get(), and GetByKey() methods return</span></span><br><span class="line"><span class="comment">// interface&#123;&#125; to satisfy the Store/Queue interfaces, but it</span></span><br><span class="line"><span class="comment">// will always return an object of type Deltas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on threading: If you call Pop() in parallel from multiple</span></span><br><span class="line"><span class="comment">// threads, you could end up with multiple threads processing slightly</span></span><br><span class="line"><span class="comment">// different versions of the same object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on the KeyLister used by the DeltaFIFO: It's main purpose is</span></span><br><span class="line"><span class="comment">// to list keys that are "known", for the purpose of figuring out which</span></span><br><span class="line"><span class="comment">// items have been deleted when Replace() or Delete() are called. The deleted</span></span><br><span class="line"><span class="comment">// object will be included in the DeleteFinalStateUnknown markers. These objects</span></span><br><span class="line"><span class="comment">// could be stale.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may provide a function to compress deltas (e.g., represent a</span></span><br><span class="line"><span class="comment">// series of Updates as a single Update).</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// lock/cond protects access to 'items' and 'queue'.</span></span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    cond sync.Cond</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We depend on the property that items in the set are in</span></span><br><span class="line">    <span class="comment">// the queue and vice versa, and that all Deltas in this</span></span><br><span class="line">    <span class="comment">// map have at least one Delta.</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></span><br><span class="line">    populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">    initialPopulationCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keyFunc is used to make the key used for queued item</span></span><br><span class="line">    <span class="comment">// insertion and retrieval, and should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deltaCompressor tells us how to combine two or more</span></span><br><span class="line">    <span class="comment">// deltas. It may be nil.</span></span><br><span class="line">    deltaCompressor DeltaCompressor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// knownObjects list keys that are "known", for the</span></span><br><span class="line">    <span class="comment">// purpose of figuring out which items have been deleted</span></span><br><span class="line">    <span class="comment">// when Replace() or Delete() is called.</span></span><br><span class="line">    knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indication the queue is closed.</span></span><br><span class="line">    <span class="comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span></span><br><span class="line">    <span class="comment">// Currently, not used to gate any of CRED operations.</span></span><br><span class="line">    closed     <span class="keyword">bool</span></span><br><span class="line">    closedLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-amp-Store"><a href="#Queue-amp-Store" class="headerlink" title="Queue &amp; Store"></a>Queue &amp; Store</h3><p>DeltaFIFO的类型是Queue接口，Reflector.store是Store接口，Queue接口是一个存储队列，Process的方法执行Queue.Pop出来的数据对象，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue is exactly like a Store, but has a Pop() method too.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">    Store</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pop blocks until it has something to process.</span></span><br><span class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></span><br><span class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></span><br><span class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></span><br><span class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></span><br><span class="line">    <span class="comment">// returned by Pop back into the queue as long</span></span><br><span class="line">    <span class="comment">// as nothing else (presumably more recent)</span></span><br><span class="line">    <span class="comment">// has since been added.</span></span><br><span class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></span><br><span class="line">    HasSynced() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close queue</span></span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p><p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store is a generic object storage interface. Reflector knows how to watch a server</span></span><br><span class="line"><span class="comment">// and update a store. A generic store is provided, which allows Reflector to be used</span></span><br><span class="line"><span class="comment">// as a local caching system, and an LRU store, which allows Reflector to work like a</span></span><br><span class="line"><span class="comment">// queue of items yet to be processed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Store makes no assumptions about stored object identity; it is the responsibility</span></span><br><span class="line"><span class="comment">// of a Store implementation to provide a mechanism to correctly key objects and to</span></span><br><span class="line"><span class="comment">// define the contract for obtaining objects by some arbitrary key type.</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">    GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Replace</code>方法会删除原来store中的内容，并将新增的list的内容存入store中，即完全替换数据。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache实现了store的接口，而cache的具体实现又是调用<code>ThreadSafeStore</code>接口来实现功能的。</p><p>cache的功能主要有以下两点：</p><ul><li>通过keyFunc计算对象的key</li><li>调用ThreadSafeStorage接口的方法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache responsibilities are limited to:</span></span><br><span class="line"><span class="comment">//  1. Computing keys for objects via keyFunc</span></span><br><span class="line"><span class="comment">//  2. Invoking methods of a ThreadSafeStorage interface</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">    <span class="comment">// should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ListAndWatch主要用到以下的方法：</p><p><strong>cache.Replace</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace will delete the contents of 'c', using instead the given list.</span></span><br><span class="line"><span class="comment">// 'c' takes ownership of the list, you should not reference the list again</span></span><br><span class="line"><span class="comment">// after calling this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Replace</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">        key, err := c.keyFunc(item)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[key] = item</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Replace(items, resourceVersion)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Add</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add inserts an item into the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Add(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Update</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update sets an item in the cache to its updated state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Update</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Update(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Delete</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete removes an item from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Delete</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Delete(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p>cache的具体是调用<code>ThreadSafeStore</code>来实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadSafeStore is an interface that allows concurrent access to a storage backend.</span></span><br><span class="line"><span class="comment">// TL;DR caveats: you must not modify anything returned by Get or List as it will break</span></span><br><span class="line"><span class="comment">// the indexing feature in addition to not being thread safe.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The guarantees of thread safety provided by List/Get are only valid if the caller</span></span><br><span class="line"><span class="comment">// treats returned items as read-only. For example, a pointer inserted in the store</span></span><br><span class="line"><span class="comment">// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`</span></span><br><span class="line"><span class="comment">// on the same key and modify the pointer in a non-thread-safe way. Also note that</span></span><br><span class="line"><span class="comment">// modifying objects stored by the indexers (if any) will *not* automatically lead</span></span><br><span class="line"><span class="comment">// to a re-index. So it's not a good idea to directly modify the objects returned by</span></span><br><span class="line"><span class="comment">// Get/List, in general.</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Update(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">    Get(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Replace(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>)</span><br><span class="line">    Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">    ListIndexFuncValues(name <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>threadSafeMap</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  sync.RWMutex</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">    indexers Indexers</span><br><span class="line">    <span class="comment">// indices maps a name to an Index</span></span><br><span class="line">    indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop"></a>processLoop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller.Run方法中会调用processLoop，以下分析<code>processLoop</code>的处理逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processLoop drains the work queue.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span></span><br><span class="line"><span class="comment">// to make sure that we don't end up processing the same object multiple times</span></span><br><span class="line"><span class="comment">// concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span></span><br><span class="line"><span class="comment">// actually exit when the controller is stopped. Or just give up on this stuff</span></span><br><span class="line"><span class="comment">// ever being stoppable. Converting this whole package to use Context would</span></span><br><span class="line"><span class="comment">// also be helpful.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">                <span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">                c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processLoop主要处理任务队列中的任务，其中处理逻辑是调用具体的<code>ProcessFunc</code>函数来实现，核心代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br></pre></td></tr></table></figure><h3 id="DeltaFIFO-Pop"><a href="#DeltaFIFO-Pop" class="headerlink" title="DeltaFIFO.Pop"></a>DeltaFIFO.Pop</h3><p>Pop会阻塞住直到队列里面添加了新的对象，如果有多个对象，按照先进先出的原则处理，如果某个对象没有处理成功会重新被加入该队列中。</p><p>Pop中会调用具体的process函数来处理对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop blocks until an item is added to the queue, and then returns it.  If</span></span><br><span class="line"><span class="comment">// multiple items are ready, they are returned in the order in which they were</span></span><br><span class="line"><span class="comment">// added/updated. The item is removed from the queue (and the store) before it</span></span><br><span class="line"><span class="comment">// is returned, so if you don't successfully process it, you need to add it back</span></span><br><span class="line"><span class="comment">// with AddIfNotPresent().</span></span><br><span class="line"><span class="comment">// process function is called under lock, so it is safe update data structures</span></span><br><span class="line"><span class="comment">// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc</span></span><br><span class="line"><span class="comment">// may return an instance of ErrRequeue with a nested error to indicate the current</span></span><br><span class="line"><span class="comment">// item should be requeued (equivalent to calling AddIfNotPresent under the lock).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Pop returns a 'Deltas', which has a complete list of all the things</span></span><br><span class="line"><span class="comment">// that happened to the object (deltas) while it was sitting in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">            <span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">            <span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">            <span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        id := f.queue[<span class="number">0</span>]</span><br><span class="line">        f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">        item, ok := f.items[id]</span><br><span class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            f.initialPopulationCount--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        err := process(item)</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">            f.addIfNotPresent(id, item)</span><br><span class="line">            err = e.Err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">        <span class="comment">// ownership to the caller.</span></span><br><span class="line">        <span class="keyword">return</span> item, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    item, ok := f.items[id]</span><br><span class="line">    ...</span><br><span class="line">    err := process(item)</span><br><span class="line">    <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">        f.addIfNotPresent(id, item)</span><br><span class="line">        err = e.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">    <span class="comment">// ownership to the caller.</span></span><br><span class="line">    <span class="keyword">return</span> item, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas"></a>HandleDeltas</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中process函数就是在sharedIndexInformer.Run方法中，给config.Process赋值的<code>HandleDeltas</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.blockDeltas.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from oldest to newest</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">        <span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">            isSync := d.Type == Sync</span><br><span class="line">            s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">            <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Deleted:</span><br><span class="line">            <span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> d.Type &#123;</span><br><span class="line"><span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">    ...</span><br><span class="line">    s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的类型，调用<code>processor.distribute</code>方法，该方法将对象加入<code>processorListener</code>的channel中。</p><h3 id="sharedProcessor-distribute"><a href="#sharedProcessor-distribute" class="headerlink" title="sharedProcessor.distribute"></a>sharedProcessor.distribute</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sync &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>processorListener.add:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合以上的分析，可以看出processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。以下分析processorListener.Run的部分。</p><h2 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h2><p>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p><p>流程：</p><ol><li>listenser的add函数负责将notify装进pendingNotifications。</li><li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li><li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sharedProcessor-Run"><a href="#sharedProcessor-Run" class="headerlink" title="sharedProcessor.Run"></a>sharedProcessor.Run</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      p.listenersLock.RLock()</span><br><span class="line">      <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">      <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">         p.wg.Start(listener.run)</span><br><span class="line">         p.wg.Start(listener.pop)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   &lt;-stopCh</span><br><span class="line">   p.listenersLock.RLock()</span><br><span class="line">   <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">   <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">      <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener-pop"><a href="#listener-pop" class="headerlink" title="listener.pop"></a>listener.pop</h4><p>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextCh <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">            <span class="comment">// Notification dispatched</span></span><br><span class="line">            <span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">            notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">                nextCh = <span class="literal">nil</span> <span class="comment">// Disable this select case</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> notificationToAdd, ok := &lt;-p.addCh:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> notification == <span class="literal">nil</span> &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">                <span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">                notification = notificationToAdd</span><br><span class="line">                nextCh = p.nextCh</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">                p.pendingNotifications.WriteOne(notificationToAdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener-run"><a href="#listener-run" class="headerlink" title="listener.run"></a>listener.run</h4><p>listener.run部分根据不同的更新类型调用不同的处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">        <span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> updateNotification:</span><br><span class="line">            p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> addNotification:</span><br><span class="line">            p.handler.OnAdd(notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> deleteNotification:</span><br><span class="line">            p.handler.OnDelete(notification.oldObj)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中具体的实现函数handler是在NewDeploymentController（其他不同类型的controller类似）中赋值的，而该handler是一个接口，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceEventHandler can handle notifications for events that happen to a</span></span><br><span class="line"><span class="comment">// resource. The events are informational only, so you can't return an</span></span><br><span class="line"><span class="comment">// error.</span></span><br><span class="line"><span class="comment">//  * OnAdd is called when an object is added.</span></span><br><span class="line"><span class="comment">//  * OnUpdate is called when an object is modified. Note that oldObj is the</span></span><br><span class="line"><span class="comment">//      last known state of the object-- it is possible that several changes</span></span><br><span class="line"><span class="comment">//      were combined together, so you can't use this to see every single</span></span><br><span class="line"><span class="comment">//      change. OnUpdate is also called when a re-list happens, and it will</span></span><br><span class="line"><span class="comment">//      get called even if nothing changed. This is useful for periodically</span></span><br><span class="line"><span class="comment">//      evaluating or syncing something.</span></span><br><span class="line"><span class="comment">//  * OnDelete will get the final state of the item if it is known, otherwise</span></span><br><span class="line"><span class="comment">//      it will get an object of type DeletedFinalStateUnknown. This can</span></span><br><span class="line"><span class="comment">//      happen if the watch is closed and misses the delete event and we don't</span></span><br><span class="line"><span class="comment">//      notice the deletion until the subsequent re-list.</span></span><br><span class="line"><span class="keyword">type</span> ResourceEventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnAdd(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnUpdate(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnDelete(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResourceEventHandler"><a href="#ResourceEventHandler" class="headerlink" title="ResourceEventHandler"></a>ResourceEventHandler</h3><p>以下以DeploymentController的处理逻辑为例。</p><p>在<code>NewDeploymentController</code>部分会注册deployment的事件函数，以下注册了三种类型的事件函数，其中包括：dInformer、rsInformer和podInformer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeploymentController creates a new DeploymentController.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer extensionsinformers.DeploymentInformer, rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addDeployment,</span><br><span class="line">        UpdateFunc: dc.updateDeployment,</span><br><span class="line">        <span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">        DeleteFunc: dc.deleteDeployment,</span><br><span class="line">    &#125;)</span><br><span class="line">    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addReplicaSet,</span><br><span class="line">        UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">        DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">    &#125;)</span><br><span class="line">    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        DeleteFunc: dc.deletePod,</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addDeployment"><a href="#addDeployment" class="headerlink" title="addDeployment"></a>addDeployment</h4><p>以下以<code>addDeployment</code>为例，addDeployment主要是将对象加入到enqueueDeployment的队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">addDeployment</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    d := obj.(*extensions.Deployment)</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"Adding deployment %s"</span>, d.Name)</span><br><span class="line">    dc.enqueueDeployment(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueueDeployment的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enqueueDeployment <span class="function"><span class="keyword">func</span><span class="params">(deployment *extensions.Deployment)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将dc.enqueue赋值给dc.enqueueDeployment</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.enqueueDeployment = dc.enqueue</span><br></pre></td></tr></table></figure><p>dc.enqueue调用了dc.queue.Add(key)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">enqueue</span><span class="params">(deployment *extensions.Deployment)</span></span> &#123;</span><br><span class="line">    key, err := controller.KeyFunc(deployment)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %#v: %v"</span>, deployment, err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dc.queue主要记录了需要被同步的deployment的对象，供syncDeployment使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dc := &amp;DeploymentController&#123;</span><br><span class="line">    ...</span><br><span class="line">    queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewNamedRateLimitingQueue</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedRateLimitingQueue</span><span class="params">(rateLimiter RateLimiter, name <span class="keyword">string</span>)</span> <span class="title">RateLimitingInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;rateLimitingType&#123;</span><br><span class="line">        DelayingInterface: NewNamedDelayingQueue(name),</span><br><span class="line">        rateLimiter:       rateLimiter,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上分析，可以看出processor记录了不同类似的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析的部分主要是k8s的<code>informer</code>机制，即<code>List-Watch</code>机制。</p><h3 id="Reflector-2"><a href="#Reflector-2" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p><h3 id="ListAndWatch-1"><a href="#ListAndWatch-1" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p><code>ListAndWatch</code>第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p><h3 id="DeltaFIFO-2"><a href="#DeltaFIFO-2" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p><code>DeltaFIFO</code>是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p><p>DeltaFIFO主要用在以下场景：</p><ul><li>希望对象变更最多处理一次</li><li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li><li>要处理对象的删除</li><li>希望定期重新处理对象</li></ul><h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p><p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p><h3 id="processor-1"><a href="#processor-1" class="headerlink" title="processor"></a>processor</h3><p><code>processor</code>的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p><p>流程：</p><ol><li>listenser的add函数负责将notify装进pendingNotifications。</li><li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li><li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li></ol><p><code>processor</code>记录了不同类似的事件函数，其中事件函数在<code>NewXxxController</code>构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似<code>syncDeployment</code>的同步函数来维持期望状态的同步逻辑。</p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li>在controller-manager的Run函数部分调用了InformerFactory.Start的方法，Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。</li><li>informer.Run的部分先生成一个DeltaFIFO的队列来存储对象变化的数据。然后调用processor.Run和controller.Run函数。</li><li>controller.Run函数会生成一个Reflector，<code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</li><li>Reflector接着执行ListAndWatch函数，ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</li><li>controller.Run函数还会调用processLoop函数，processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。</li><li>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。processor记录了不同类型的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="Informer-二级缓存中的同步问题"><a href="#Informer-二级缓存中的同步问题" class="headerlink" title="Informer 二级缓存中的同步问题"></a>Informer 二级缓存中的同步问题</h2><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存 DeltaIFIFO 和 LocalStore 之间会存在 resync 机制，k8s 中 kube-controller-manager 的 StatefulSetController 中使用了两级缓存的 resync 机制（如下图所示），我们在生产环境中发现 sts 创建后过了很久 pod 才会创建，主要是由于 StatefulSetController 的两级缓存之间 30s 会同步一次，由于 StatefulSetController watch 到变化后就会把对应的 sts 放入 DeltaIFIFO 中，且每隔 30s 会把 LocalStore 中全部的 sts 重新入一遍 DeltaIFIFO，入队时会做一些处理，过滤掉一些不需要重复入队列的 sts，若间隔的 30s 内没有处理完队列中所有的 sts，则待处理队列中始终存在未处理完的 sts，并且在同步过程中产生的 sts 会加的队列的尾部，新加入队尾的 sts 只能等到前面的 sts 处理完成（也就是 resync 完成）才会被处理，所以导致的现象就是 sts 创建后过了很久 pod 才会创建。</p><p>优化的方法就是去掉二级缓存的同步策略（将 setInformer.Informer().AddEventHandlerWithResyncPeriod() 改为 informer.AddEventHandler()）或者调大同步周期，但是在研究 kube-controller-manager 其他 controller 时发现并不是所有的 controller 都有同步策略，社区也有相关的 issue 反馈了这一问题，Remove resync period for sset controller，社区也会在以后的版本中去掉两级缓存之间的 resync 策略。</p><p>k8s.io/kubernetes/pkg/controller/statefulset/stateful_set.go</p><p><img alt="Kubernetes 中 informer 的使用" data-src="https://static001.geekbang.org/wechat/images/a1/a1a5745f0c0309c9d05c484905887fb8.jpeg">kube-controller-manager sts controller</p><h2 id="使用-Informer-如何监听所有资源对象？"><a href="#使用-Informer-如何监听所有资源对象？" class="headerlink" title="使用 Informer 如何监听所有资源对象？"></a>使用 Informer 如何监听所有资源对象？</h2><p>一个 Informer 实例只能监听一种 resource，每个 resource 需要创建对应的 Informer 实例。</p><h2 id="为什么不是使用-workqueue？"><a href="#为什么不是使用-workqueue？" class="headerlink" title="为什么不是使用 workqueue？"></a>为什么不是使用 workqueue？</h2><p>建议使用 RateLimitingQueue，它相比普通的 workqueue 多了以下的功能:</p><ul><li><strong>限流：</strong>可以限制一个 item 被 reenqueued 的次数。</li><li><strong>防止 hot loop：</strong>它保证了一个 item 被 reenqueued 后，不会马上被处理。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/kubernetes/client-go/tree/master/tools/cache" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/tree/master/tools/cache</a></li><li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></li><li><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-20_client-go-controller-interaction.jpeg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="informer" scheme="http://houmin.cc/tags/informer/"/>
    
      <category term="watch" scheme="http://houmin.cc/tags/watch/"/>
    
      <category term="消息机制" scheme="http://houmin.cc/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    
      <category term="异步" scheme="http://houmin.cc/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>得意忘形</title>
    <link href="http://houmin.cc/posts/c2f57f16/"/>
    <id>http://houmin.cc/posts/c2f57f16/</id>
    <published>2020-07-18T09:19:12.000Z</published>
    <updated>2020-07-26T08:22:57.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Podcast 在我最近的生活中占据了很大的部分，每天走在上下班的路上，带着耳机，听播客中主播与嘉宾的聊天，会觉得是难得自在和舒适的时间。有时候聊到有意思的地方，自己也不禁乐了起来；有时候听到一些新的观点或者事情，自己也好像恍然大悟；或者有时候自己一直以来的感受被主播们说了出来，感同身受豁然开朗。</p><p>「得意忘形」是最近听的比较多的一个播客，他的风格偏务虚，更新也并不太频繁，拖更的现象也常有。但是翻看「得意忘形」两年前录的播客，现在听来很多还是觉得会有启发性。毕竟，他关注的是自我与世界这个主题：我到底是一个什么样的人，我作为人整个系统是如何运作的，我与外界是如何产生交互，到底是什么影响了我对这个世界的看法。</p><blockquote><p>「得意忘形」是一个主张追求个体自由与探寻真理的媒体计划。我们见证了第一次工业革命以来科技对人类社会的极大推动与助益，但也意识到资本主义与市场经济不可避免地催生了消费文化、剥夺了个人价值、并窃取了大众时间。带着对生命的有限性与无目的性的敬畏，我们试图为读者与听众提供更全面的<strong>觉察自我与认知世界</strong>的工具，以不断重建当下的方式穿越时间、抵达生活的本质。</p></blockquote><p>这里是「朝花夕拾」第二十期，选题来自于最近听「得意忘形」两年前的一期：「快乐」到底是什么东西？选择「得意忘形」作为这期的题目，是因为我非常喜欢得意忘形这个词本来描述的那种 <code>in the zone</code>的状态。这一次，我们再聊聊关于「快乐」的问题。</p><blockquote><p>嗜酒能啸，善弹琴。当其得意，忽忘形骸。                                —— 《晋书·阮籍传》</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="1500" height="80" src="//music.163.com/outchain/player?type=3&id=904186633&auto=0&height=66"></iframe><a id="more"></a><h2 id="什么时候会让你开心"><a href="#什么时候会让你开心" class="headerlink" title="什么时候会让你开心"></a>什么时候会让你开心</h2><p>想一想那些让我感觉到开心的时刻</p><ul><li>在羽毛球场双打时候的那种快节奏的刺激感让我觉得开心，打完球后大汗淋漓的状态</li><li>大四时特别喜欢跑步，最开始的时候是比较痛苦的，经过一段时间的适应后，喜欢上了那种<code>Runner&#39;s High</code>的感觉</li><li>自己一个人在路上听播客听到好玩的地方的时候</li><li>自己做了一道色香味俱全的菜的时候，看着开心，吃着也开心</li><li>北京的秋天那种蓝天白云，清风徐来的状态</li><li>去云南玩的时候和同伴们插科打诨，完全自由的那种状态</li><li>自己实验达到预期的效果的时候</li><li>和喜欢的女孩子聊天时候那种自在惬意的感觉</li><li>朋友圈收到很多赞的时候</li></ul><p>总结这些时刻，可以把它大体分为以下几类：</p><ul><li>运动及其带来的成就</li><li>做成一件事情的成就感</li><li>人与人之间的交互和融洽感</li><li>良好的环境，包括天气、美景等</li></ul><h2 id="为什么这些会让我感到快乐？多巴胺？"><a href="#为什么这些会让我感到快乐？多巴胺？" class="headerlink" title="为什么这些会让我感到快乐？多巴胺？"></a>为什么这些会让我感到快乐？多巴胺？</h2><p>多巴胺到底是什么？很多媒体把多巴胺描述成人类感到愉悦的来源，是人类通过药物、运动、食物、性或者地位来追求高潮体验的本质。实际上现在的医学研究表明，多巴胺的作用有很多，其中的一个就是并不是给人带来快乐，而是向大脑承诺奖赏、承诺快乐并控制人的行为。这里需要区分的是，你渴望得到某个东西的快乐，和你实际做那个东西的快乐，这两件事情是不一样的。</p><p>一个典型的例子，你喜欢跑步。跑步的时候确实会感到开心，可能由于分泌了内啡肽等东西，让人体感觉到舒适。但是跑步让你感到快乐的，可能更多的是来源于，「你觉得你是一个跑步的人」以及随之发朋友圈的行为。当你每次跑完步的时候，你会进一步更新你的认知，觉得自己做了一件有意义的事情，然后会觉得开心。</p><p>多巴胺会让人上瘾，你可以因为多巴胺而沉迷于刷手机，也可能因为多巴胺坚持跑步。这是一个固有的生理机制，关键在于你如何利用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Podcast 在我最近的生活中占据了很大的部分，每天走在上下班的路上，带着耳机，听播客中主播与嘉宾的聊天，会觉得是难得自在和舒适的时间。有时候聊到有意思的地方，自己也不禁乐了起来；有时候听到一些新的观点或者事情，自己也好像恍然大悟；或者有时候自己一直以来的感受被主播们说了出来，感同身受豁然开朗。&lt;/p&gt;
&lt;p&gt;「得意忘形」是最近听的比较多的一个播客，他的风格偏务虚，更新也并不太频繁，拖更的现象也常有。但是翻看「得意忘形」两年前录的播客，现在听来很多还是觉得会有启发性。毕竟，他关注的是自我与世界这个主题：我到底是一个什么样的人，我作为人整个系统是如何运作的，我与外界是如何产生交互，到底是什么影响了我对这个世界的看法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「得意忘形」是一个主张追求个体自由与探寻真理的媒体计划。我们见证了第一次工业革命以来科技对人类社会的极大推动与助益，但也意识到资本主义与市场经济不可避免地催生了消费文化、剥夺了个人价值、并窃取了大众时间。带着对生命的有限性与无目的性的敬畏，我们试图为读者与听众提供更全面的&lt;strong&gt;觉察自我与认知世界&lt;/strong&gt;的工具，以不断重建当下的方式穿越时间、抵达生活的本质。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里是「朝花夕拾」第二十期，选题来自于最近听「得意忘形」两年前的一期：「快乐」到底是什么东西？选择「得意忘形」作为这期的题目，是因为我非常喜欢得意忘形这个词本来描述的那种 &lt;code&gt;in the zone&lt;/code&gt;的状态。这一次，我们再聊聊关于「快乐」的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嗜酒能啸，善弹琴。当其得意，忽忘形骸。                                —— 《晋书·阮籍传》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;1500&quot; height=&quot;80&quot; src=&quot;//music.163.com/outchain/player?type=3&amp;id=904186633&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-23_cat.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="快乐" scheme="http://houmin.cc/tags/%E5%BF%AB%E4%B9%90/"/>
    
      <category term="个人管理系统" scheme="http://houmin.cc/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="podcast" scheme="http://houmin.cc/tags/podcast/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Scheduling Framework</title>
    <link href="http://houmin.cc/posts/83a17de0/"/>
    <id>http://houmin.cc/posts/83a17de0/</id>
    <published>2020-07-15T06:48:27.000Z</published>
    <updated>2020-08-04T02:39:56.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes Scheduling Framework 是在Kubernetes 1.15版本后新出现的一种调度框架。Scheduling Framework 在原有的调度流程中, 定义了丰富扩展点接口，开发者可以通过实现扩展点所定义的接口来实现插件，将插件注册到扩展点。Scheduling Framework 在执行调度流程时，运行到相应的扩展点时，会调用用户注册的插件，影响调度决策的结果。通过这种方式来将用户的调度逻辑集成到 Scheduling Framework 中。</p><a id="more"></a><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>随着越来越多的Feature被加入到Kubernetes调度器，整个调度器的代码量越来越大，逻辑越来越复杂，使得对其的维护和调试越来越困难。与此同时，对于那些自己定制调度器的研发人员来说，跟上社区的进展也越来越难。在Kubernetes 1.15版本前的调度器支持了Scheduler Extender的方式来基于HTTP的Webhook来对调度器支持的功能扩展。但是，他们明显存在以下几个问题：</p><ul><li>调度器功能扩展点的数目有限。Extender只有Filter、Prioritize、Preempt和Bind这几个扩展点，而没有起其他的扩展点，比如不能在运行Predicate函数前调用</li><li>每一次调用调度器都需要Marshaling和Unmarshaling JSON数据，相比于直接调用原生函数而言Webhook的HTTP请求方式更慢</li><li>难以通知Extender调度器已经放弃调度一个Pod</li><li>因为Extender以独立进程形式运行，他们不能使用Scheduler Cache</li></ul><p>以上的问题影响了Scheduler的性能与扩展新的特性，基于此提出的Framework框架会将现有的功能转换为Plugin的形式，比如Predicate函数和Prioritize函数。这些Plugin将会被编译进调度器的二进制文件中。此外，对于那些自己定制调度器的研发人员可以基于未经修改的调度器代码和自己的插件代码编译自己的调度器。</p><p>目标：</p><ul><li>让调度器更加可扩展</li><li>通过移动调度器的代码到Plugin从而让其核心代码更加简单</li><li>在Framework中提出扩展点</li><li>提出一个机制来接收Plugin的结果，并且根结收到的结果来继续或者终止调度</li><li>提出一个机制来处理问题并且和Plugin通信</li></ul><h2 id="Proposals"><a href="#Proposals" class="headerlink" title="Proposals"></a>Proposals</h2><p>Scheduling Framework定义了新的扩展点和Go API，这种方式称作Plugin。通过配置Scheduler的ComponentConfig可以开启、关闭或者重排序这些插件。such</p><h2 id="Scheduling-Cycle-amp-Binding-Cycle"><a href="#Scheduling-Cycle-amp-Binding-Cycle" class="headerlink" title="Scheduling Cycle &amp; Binding Cycle"></a>Scheduling Cycle &amp; Binding Cycle</h2><p>每次尝试调度一个Pod都会经历两个阶段：</p><ul><li>Scheduling Cycle：为Pod选择一个Node进行调度</li><li>Binding Cycle：将Scheduling Cycle阶段的决定应用到集群</li></ul><p>这两个阶段一起被称作是 <code>Scheduling Context</code>，也就是调度上下文。</p><p>不同的Scheduling Cycle间串行运行，同一个时间只有一个 scheduling cycle，是线程安全的。binding cycle 是异步执行的，同一个时间中可能会有多个 binding cycle 在运行，是线程不安全的。</p><p>如果一个Pod被认为是Unschedulable，或者是发生了内存错误，那么一个Scheduling Cycle或者Binding Cycle会被终止。然后这个Pod可能被返回到调度队列中。如果一个Binding Cycle终止了，那么会触发 <code>Un-reserve</code>插件。</p><h2 id="Extension-points"><a href="#Extension-points" class="headerlink" title="Extension points"></a>Extension points</h2><p>下图定义了Scheduling Framework中暴露的扩展点，其中Filter等同于原来的Predicate，Scoring等同于之前的Prioritize。对于一个插件，它可能在一个或者多个扩展点注册，从而满足业务的不同逻辑。</p><p><img alt="Scheduling Framework" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-01-25_scheduling-framework-extensions.png"></p><h3 id="Queue-Sort"><a href="#Queue-Sort" class="headerlink" title="Queue Sort"></a>Queue Sort</h3><p>这里的插件用来对调度队列中的Pod排序，同一时间只有一个Queue Sort可以被启用。</p><h3 id="Pre-filter"><a href="#Pre-filter" class="headerlink" title="Pre-filter"></a>Pre-filter</h3><p>这里的插件用来预处理Pod信息，或者检查集群或Pod需满足的特定条件。</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter用于过滤那些不能运行对应Pod的Node，调度器可能会同时评估这些Node，在一个Scheduling Cycle中Filter插件可能被运行多次。</p><h3 id="Pre-Score"><a href="#Pre-Score" class="headerlink" title="Pre-Score"></a>Pre-Score</h3><p>在V1alpha2中，Pre-Score已经可用，之前被称作Post-Filter。</p><p>这个插件会接收来自Filter阶段的Node列表，可以用这些数据来更新内部状态或者产生日志或Metrics。</p><h3 id="Scoring"><a href="#Scoring" class="headerlink" title="Scoring"></a>Scoring</h3><p>Score插件会有两个阶段：</p><ul><li>Scoring：为Filter阶段的Node列表中的Node排序，调度器对于每个Node调用每个Score插件中的 <code>Score</code>方法</li><li>Normalize Scoring：用于修改各个Score插件的分数，从而计算出最终的Node得分列表</li></ul><p>Score插件最终输出的数值必须在  <strong>[MinNodeScore, MaxNodeScore]</strong> 区间，如果不是，Scheduling Cycle将会被终止。</p><h3 id="Reserve"><a href="#Reserve" class="headerlink" title="Reserve"></a>Reserve</h3><p>Reserve插件是一个信息型的插件。当一个Node上的资源被保留给某个Pod的时候，那些需要维护runtime状态的插件，需要利用Reserve扩展点来接收来自Scheduler的通知。这发生在调度器实际上绑定Pod到Node的时候，用来避免在调度器等待Bind成功时候发生Race Condition。</p><p>Reserve是Scheduling Cycle的最后一步，一点Pod进入Reserved状态，它之后要么在调度失败的时候触发Un-reserve插件，要么调度成功的时候触发Post-bind插件。</p><blockquote><p>Note：这个概念以前叫做 Assume</p></blockquote><h3 id="Permit"><a href="#Permit" class="headerlink" title="Permit"></a>Permit</h3><p>Permit插件用来阻止或者推迟对一个Pod的绑定，一个Permit可以做下面三件操作</p><ul><li>Allow；执行approve操作后，一个Pod将被送去Binding</li><li>Reject：执行deny操作后，Pod被返回调度队列，同时触发Un-reserve插件</li><li>Wait (with a timeout)：执行wait操作后，一个Pod保持在Permit阶段知道一个Plugin对它approve；如果timeout了，wait将会变为den y，之后Pod被返回调度队列，触发Un-reserve插件</li></ul><h4 id="WaitPod"><a href="#WaitPod" class="headerlink" title="WaitPod"></a>WaitPod</h4><p>在framework interface中定义了Permit阶段中处于等待的WaitingPod。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/interface.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitingPod represents a pod currently waiting in the permit phase.</span></span><br><span class="line"><span class="keyword">type</span> WaitingPod <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// GetPod returns a reference to the waiting pod.</span></span><br><span class="line">GetPod() *v1.Pod</span><br><span class="line"><span class="comment">// GetPendingPlugins returns a list of pending permit plugin's name.</span></span><br><span class="line">GetPendingPlugins() []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// Allow declares the waiting pod is allowed to be scheduled by plugin pluginName.</span></span><br><span class="line"><span class="comment">// If this is the last remaining plugin to allow, then a success signal is delivered</span></span><br><span class="line"><span class="comment">// to unblock the pod.</span></span><br><span class="line">Allow(pluginName <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// Reject declares the waiting pod unschedulable.</span></span><br><span class="line">Reject(msg <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitingPod则是一个具体的pod的等待实例，其内部通过pendingPlugins保存插件定义的timer等待时间，对外通过<code>chan *status</code>来接受当前pod的状态，并通过读写锁来进行串行化。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitingPod <span class="keyword">struct</span> &#123;</span><br><span class="line">    pod            *v1.Pod</span><br><span class="line">    pendingPlugins <span class="keyword">map</span>[<span class="keyword">string</span>]*time.Timer</span><br><span class="line">    s              <span class="keyword">chan</span> *Status</span><br><span class="line">    mu             sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitingPodsMap其内部通过pod的uid保存一个map映射，同时通过读写锁来进行数据保护</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitingPodsMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    pods <span class="keyword">map</span>[types.UID]WaitingPod</span><br><span class="line">    mu   sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据每个plugin的wait等待时间构建N个timer, 如果任一的timer到期，则就拒绝</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWaitingPod</span><span class="params">(pod *v1.Pod, pluginsMaxWaitTime <span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration)</span> *<span class="title">waitingPod</span></span> &#123;</span><br><span class="line">    wp := &amp;waitingPod&#123;</span><br><span class="line">        pod: pod,</span><br><span class="line">        s:   <span class="built_in">make</span>(<span class="keyword">chan</span> *Status, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wp.pendingPlugins = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*time.Timer, <span class="built_in">len</span>(pluginsMaxWaitTime))</span><br><span class="line">    <span class="comment">// The time.AfterFunc calls wp.Reject which iterates through pendingPlugins map. Acquire the</span></span><br><span class="line">    <span class="comment">// lock here so that time.AfterFunc can only execute after newWaitingPod finishes.</span></span><br><span class="line">    wp.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> wp.mu.Unlock()</span><br><span class="line">    <span class="comment">// 根据插件的等待时间来构建timer，如果有任一timer到期，还未曾有任何plugin Allow则会进行Reject</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> pluginsMaxWaitTime &#123;</span><br><span class="line">        plugin, waitTime := k, v</span><br><span class="line">        wp.pendingPlugins[plugin] = time.AfterFunc(waitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            msg := fmt.Sprintf(<span class="string">"rejected due to timeout after waiting %v at plugin %v"</span>,</span><br><span class="line">                waitTime, plugin)</span><br><span class="line">            wp.Reject(msg)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>允许操作必须等待所有的plugin都Allow后，才能发送允许事件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *waitingPod)</span> <span class="title">Allow</span><span class="params">(pluginName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> timer, exist := w.pendingPlugins[pluginName]; exist &#123;</span><br><span class="line">        <span class="comment">// 停止当前plugin的定时器</span></span><br><span class="line">        timer.Stop()</span><br><span class="line">        <span class="built_in">delete</span>(w.pendingPlugins, pluginName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only signal success status after all plugins have allowed</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(w.pendingPlugins) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有当所有的plugin都允许，才会发生成功允许事件</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> w.s &lt;- NewStatus(Success, <span class="string">""</span>): <span class="comment">// 发送事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reject"><a href="#Reject" class="headerlink" title="Reject"></a>Reject</h4><p>任一一个plugin的定时器到期，或者plugin主动发起reject操作，则都会暂停所有的定时器，并进行消息广播</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *waitingPod)</span> <span class="title">Reject</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    w.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.RUnlock()</span><br><span class="line">    <span class="comment">// 停止所有的timer</span></span><br><span class="line">    <span class="keyword">for</span> _, timer := <span class="keyword">range</span> w.pendingPlugins &#123;</span><br><span class="line">        timer.Stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过管道发送拒绝事件</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> w.s &lt;- NewStatus(Unschedulable, msg):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Premit-阶段-Wait-实现"><a href="#Premit-阶段-Wait-实现" class="headerlink" title="Premit 阶段 Wait 实现"></a>Premit 阶段 Wait 实现</h4><p>首先会遍历所有的插件，然后如果发现状态设置为Wait，则会根据插件的等待时间进行wait操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">RunPermitPlugins</span><span class="params">(ctx context.Context, state *CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(status *Status)</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">metrics.FrameworkExtensionPointDuration.WithLabelValues(permit, status.Code().String()).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line">&#125;()</span><br><span class="line">pluginsWaitTime := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration)</span><br><span class="line">statusCode := Success</span><br><span class="line"><span class="keyword">for</span> _, pl := <span class="keyword">range</span> f.permitPlugins &#123;</span><br><span class="line">status, timeout := f.runPermitPlugin(ctx, pl, state, pod, nodeName)</span><br><span class="line"><span class="keyword">if</span> !status.IsSuccess() &#123;</span><br><span class="line"><span class="keyword">if</span> status.IsUnschedulable() &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"rejected pod %q by permit plugin %q: %v"</span>, pod.Name, pl.Name(), status.Message())</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(status.Code(), msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> status.Code() == Wait &#123;</span><br><span class="line"><span class="comment">// Not allowed to be greater than maxTimeout.</span></span><br><span class="line"><span class="keyword">if</span> timeout &gt; maxTimeout &#123;</span><br><span class="line">timeout = maxTimeout</span><br><span class="line">&#125;</span><br><span class="line">pluginsWaitTime[pl.Name()] = timeout</span><br><span class="line">statusCode = Wait</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"error while running %q permit plugin for pod %q: %v"</span>, pl.Name(), pod.Name, status.Message())</span><br><span class="line">klog.Error(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(Error, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> statusCode == Wait &#123;</span><br><span class="line">waitingPod := newWaitingPod(pod, pluginsWaitTime)</span><br><span class="line">f.waitingPods.add(waitingPod)</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"one or more plugins asked to wait and no plugin rejected pod %q"</span>, pod.Name)</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(Wait, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitOnPermit will block, if the pod is a waiting pod, until the waiting pod is rejected or allowed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">WaitOnPermit</span><span class="params">(ctx context.Context, pod *v1.Pod)</span> <span class="params">(status *Status)</span></span> &#123;</span><br><span class="line">waitingPod := f.waitingPods.get(pod.UID)</span><br><span class="line"><span class="keyword">if</span> waitingPod == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.waitingPods.remove(pod.UID)</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"pod %q waiting on permit"</span>, pod.Name)</span><br><span class="line"></span><br><span class="line">startTime := time.Now()</span><br><span class="line">s := &lt;-waitingPod.s</span><br><span class="line">metrics.PermitWaitDuration.WithLabelValues(s.Code().String()).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !s.IsSuccess() &#123;</span><br><span class="line"><span class="keyword">if</span> s.IsUnschedulable() &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"pod %q rejected while waiting on permit: %v"</span>, pod.Name, s.Message())</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(s.Code(), msg)</span><br><span class="line">&#125;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"error received while waiting on permit for pod %q: %v"</span>, pod.Name, s.Message())</span><br><span class="line">klog.Error(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(Error, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pre-Bind"><a href="#Pre-Bind" class="headerlink" title="Pre-Bind"></a>Pre-Bind</h3><p>执行Bind前的必要工作，比如在目标Node上设置一个网络磁盘并且mount上去。</p><h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><p>当所有的Pre-Bind插件执行完毕后，才会执行Bind插件，每一个Bind插件都按照配置的顺序被调用。一个Bind插件可以选择是否处理对应的Pod，一旦一个Bind插件选择处理Pod，剩余的其他Bind插件都被跳过。</p><h3 id="Post-Bind"><a href="#Post-Bind" class="headerlink" title="Post-Bind"></a>Post-Bind</h3><p>这是一个信息型的插件，当Bind成功后，可以用来清理一些关联的资源。</p><h3 id="Un-reserve"><a href="#Un-reserve" class="headerlink" title="Un-reserve"></a>Un-reserve</h3><p>这是一个信息型的插件，当一个Pod被reserved了，然后在之后的阶段被reject，就会执行Un-reserve插件，主要用来清理一些reserved Pod的状态。</p><h2 id="Plugin-API"><a href="#Plugin-API" class="headerlink" title="Plugin API"></a>Plugin API</h2><p>Plugin首先需要注册和配置，然后使用扩展点的接口，一般形式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueSortPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   Less(*PodInfo, *PodInfo) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PreFilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   PreFilter(CycleState, *v1.Pod) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="CycleState"><a href="#CycleState" class="headerlink" title="CycleState"></a>CycleState</h3><p>很多插件函数会调用一个<code>CycleState</code>参数，它代表了当前的调度上下文，主要是负责调度流程中数据的保存和克隆，其对外暴露了读写锁接口，各扩展点插件可以根据需求独立进行加锁选择。</p><blockquote><p>The <code>CycleState</code> also provides an API similar to <a href="https://godoc.org/context#WithValue" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithValue</code></a> that can be used to pass data between plugins at different extension points. Multiple plugins can share the state or communicate via this mechanism. The state is preserved only during a single scheduling context. It is worth noting that plugins are assumed to be <strong>trusted</strong>. The scheduler does not prevent one plugin from accessing or modifying another plugin’s state.</p><p>* <em>The only exception is for <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#queue-sort" target="_blank" rel="external nofollow noopener noreferrer">queue sort</a> plugins.</em></p><p><strong>WARNING</strong>: The data available through a <code>CycleState</code> is not valid after a scheduling context ends, and plugins should not hold references to that data longer than necessary.</p></blockquote><p>CycleState主要保存StateData数据，只需要实现一个clone接口即可，CycleState里面的数据，可以被当前framework所有的插件进行数据增加和修改，里面会通过读写锁来保证线程安全，但并不会针对插件进行限制，即信任所有插件，可以任意进行增删。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CycleState <span class="keyword">struct</span> &#123;</span><br><span class="line">    mx      sync.RWMutex</span><br><span class="line">    storage <span class="keyword">map</span>[StateKey]StateData</span><br><span class="line">    <span class="comment">// if recordPluginMetrics is true, PluginExecutionDuration will be recorded for this cycle.</span></span><br><span class="line">    recordPluginMetrics <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateData is a generic type for arbitrary data stored in CycleState.</span></span><br><span class="line"><span class="keyword">type</span> StateData <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Clone is an interface to make a copy of StateData. For performance reasons,</span></span><br><span class="line">    <span class="comment">// clone should make shallow copies for members (e.g., slices or maps) that are not</span></span><br><span class="line">    <span class="comment">// impacted by PreFilter's optional AddPod/RemovePod methods.</span></span><br><span class="line">    Clone() StateData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对外接口的实现，需要对应的插件主动选择进行加读锁或者加写锁，然后进行相关数据的读取和修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Read</span><span class="params">(key StateKey)</span> <span class="params">(StateData, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v, ok := c.storage[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(NotFound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write stores the given "val" in CycleState with the given "key".</span></span><br><span class="line"><span class="comment">// This function is not thread safe. In multi-threaded code, lock should be</span></span><br><span class="line"><span class="comment">// acquired first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Write</span><span class="params">(key StateKey, val StateData)</span></span> &#123;</span><br><span class="line">    c.storage[key] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete deletes data with the given key from CycleState.</span></span><br><span class="line"><span class="comment">// This function is not thread safe. In multi-threaded code, lock should be</span></span><br><span class="line"><span class="comment">// acquired first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Delete</span><span class="params">(key StateKey)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(c.storage, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock acquires CycleState lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock releases CycleState lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RLock acquires CycleState read lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.RLock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RUnlock releases CycleState read lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FrameworkHandle"><a href="#FrameworkHandle" class="headerlink" title="FrameworkHandle"></a>FrameworkHandle</h3><p>FrameworkHandle提供了对于ApiServer和SchedulerCache的访问。<code>FrameworkHandle</code>作为一个Interface，具体是通过framework结构体实现的。</p><blockquote><p>While the <code>CycleState</code> provides APIs relevant to a single scheduling context, the <code>FrameworkHandle</code> provides APIs relevant to the lifetime of a plugin. This is how plugins can get a client (<code>kubernetes.Interface</code>) and <code>SharedInformerFactory</code>, or read data from the scheduler’s cache of cluster state. The handle will also provide APIs to list and approve or reject <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#permit" target="_blank" rel="external nofollow noopener noreferrer">waiting pods</a>.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FrameworkHandle <span class="keyword">interface</span> &#123;</span><br><span class="line">SnapshotSharedLister() schedulerlisters.SharedLister</span><br><span class="line"></span><br><span class="line"><span class="comment">// IterateOverWaitingPods acquires a read lock and iterates over the WaitingPods map.</span></span><br><span class="line">IterateOverWaitingPods(callback <span class="function"><span class="keyword">func</span><span class="params">(WaitingPod)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetWaitingPod returns a waiting pod given its UID.</span></span><br><span class="line">GetWaitingPod(uid types.UID) WaitingPod</span><br><span class="line"></span><br><span class="line"><span class="comment">// RejectWaitingPod rejects a waiting pod given its UID.</span></span><br><span class="line">RejectWaitingPod(uid types.UID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientSet returns a kubernetes clientSet.</span></span><br><span class="line">ClientSet() clientset.Interface</span><br><span class="line"></span><br><span class="line">SharedInformerFactory() informers.SharedInformerFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// VolumeBinder returns the volume binder used by scheduler.</span></span><br><span class="line">VolumeBinder() scheduling.SchedulerVolumeBinder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugin-Registration"><a href="#Plugin-Registration" class="headerlink" title="Plugin Registration"></a>Plugin Registration</h3><p>对于每一个插件，都需要定义一个构造函数，并且把它加入到注册工厂中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PluginFactory = <span class="function"><span class="keyword">func</span><span class="params">(runtime.Unknown, FrameworkHandle)</span> <span class="params">(Plugin, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">map</span>[<span class="keyword">string</span>]PluginFactory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span> <span class="title">Registry</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Registry&#123;</span><br><span class="line">      fooplugin.Name: fooplugin.New,</span><br><span class="line">      barplugin.Name: barplugin.New,</span><br><span class="line">      <span class="comment">// New plugins are registered here.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>NodeAffinity</code>为例，在定义了<code>NodeAffinity</code>这个插件结构体后，需要有一个<code>New</code>函数，函数参数同上面的<code>PluginFactory</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeAffinity is a plugin that checks if a pod node selector matches the node label.</span></span><br><span class="line"><span class="keyword">type</span> NodeAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line">handle framework.FrameworkHandle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New initializes a new plugin and returns it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(_ *runtime.Unknown, h framework.FrameworkHandle)</span> <span class="params">(framework.Plugin, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NodeAffinity&#123;handle: h&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么是在哪里将这些插件注册到Framework的呢？在 <code>NewFramework</code>函数中对Framework初始化时，会对registry中的每一个插件，如果是配置需要的插件，就调用<code>factory</code>工厂函数，对各个插件初始化构造，并注册到 <code>pluginsMap</code>中。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pluginsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Plugin)</span><br><span class="line"><span class="keyword">for</span> name, factory := <span class="keyword">range</span> r &#123;</span><br><span class="line"><span class="comment">// initialize only needed plugins.</span></span><br><span class="line"><span class="keyword">if</span> _, ok := pg[name]; !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p, err := factory(pluginConfig[name], f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error initializing plugin %q: %v"</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">pluginsMap[name] = p</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>pluginsMap</code>是一个临时的字典，真正注册到framework结构体中，是调用<code>updatePluginList</code>函数利用反射进行注册。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> _, e := <span class="keyword">range</span> f.getExtensionPoints(plugins) &#123;</span><br><span class="line"><span class="keyword">if</span> err := updatePluginList(e.slicePtr, e.plugins, pluginsMap); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>e</code>是framework的插件扩展点</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">getExtensionPoints</span><span class="params">(plugins *config.Plugins)</span> []<span class="title">extensionPoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []extensionPoint&#123;</span><br><span class="line">&#123;plugins.PreFilter, &amp;f.preFilterPlugins&#125;,</span><br><span class="line">&#123;plugins.Filter, &amp;f.filterPlugins&#125;,</span><br><span class="line">&#123;plugins.Reserve, &amp;f.reservePlugins&#125;,</span><br><span class="line">&#123;plugins.PreScore, &amp;f.preScorePlugins&#125;,</span><br><span class="line">&#123;plugins.Score, &amp;f.scorePlugins&#125;,</span><br><span class="line">&#123;plugins.PreBind, &amp;f.preBindPlugins&#125;,</span><br><span class="line">&#123;plugins.Bind, &amp;f.bindPlugins&#125;,</span><br><span class="line">&#123;plugins.PostBind, &amp;f.postBindPlugins&#125;,</span><br><span class="line">&#123;plugins.Unreserve, &amp;f.unreservePlugins&#125;,</span><br><span class="line">&#123;plugins.Permit, &amp;f.permitPlugins&#125;,</span><br><span class="line">&#123;plugins.QueueSort, &amp;f.queueSortPlugins&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，slicePtr指向的是对于framework不同扩展点，存储的不同插件具体实现；而 plugins 这个 PluginSet这个配置，主要配置哪些插件开启，哪些插件关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> extensionPoint <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// the set of plugins to be configured at this extension point.</span></span><br><span class="line">plugins *config.PluginSet</span><br><span class="line"><span class="comment">// a pointer to the slice storing plugins implementations that will run at this</span></span><br><span class="line"><span class="comment">// extension point.</span></span><br><span class="line">slicePtr <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updatePluginList</code>函数其具体实现如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updatePluginList</span><span class="params">(pluginList <span class="keyword">interface</span>&#123;&#125;, pluginSet *config.PluginSet, pluginsMap <span class="keyword">map</span>[<span class="keyword">string</span>]Plugin)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pluginSet == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先通过Elem获取当前数组的类型</span></span><br><span class="line">    plugins := reflect.ValueOf(pluginList).Elem()</span><br><span class="line">    <span class="comment">// 通过数组类型来获取数组内部元素的类型</span></span><br><span class="line">    pluginType := plugins.Type().Elem()</span><br><span class="line">    set := sets.NewString()</span><br><span class="line">    <span class="keyword">for</span> _, ep := <span class="keyword">range</span> pluginSet.Enabled &#123;</span><br><span class="line">        pg, ok := pluginsMap[ep.Name]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s %q does not exist"</span>, pluginType.Name(), ep.Name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合法性检查：如果发现当前插件未实现当前接口，则报错</span></span><br><span class="line">        <span class="keyword">if</span> !reflect.TypeOf(pg).Implements(pluginType) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"plugin %q does not extend %s plugin"</span>, ep.Name, pluginType.Name())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> set.Has(ep.Name) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"plugin %q already registered as %q"</span>, ep.Name, pluginType.Name())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        set.Insert(ep.Name)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加插件到slice中，并保存指针指向</span></span><br><span class="line">        newPlugins := reflect.Append(plugins, reflect.ValueOf(pg))</span><br><span class="line">        plugins.Set(newPlugins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，<code>Registry</code>中的插件是在哪里注册的呢？在 <code>pkg/scheduler/scheduler.go</code>中</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line"><span class="keyword">if</span> err := registry.Merge(options.frameworkOutOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是在plugin目录下硬编码的，也就是Framework内置的插件。对于自己写的插件，需要通过 <code>frameworkOutOfTreeRegistry</code> 配置。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInTreeRegistry</span><span class="params">()</span> <span class="title">framework</span>.<span class="title">Registry</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.Registry&#123;</span><br><span class="line">defaultpodtopologyspread.Name:              defaultpodtopologyspread.New,</span><br><span class="line">imagelocality.Name:                         imagelocality.New,</span><br><span class="line">tainttoleration.Name:                       tainttoleration.New,</span><br><span class="line">nodename.Name:                              nodename.New,</span><br><span class="line">nodeports.Name:                             nodeports.New,</span><br><span class="line">nodepreferavoidpods.Name:                   nodepreferavoidpods.New,</span><br><span class="line">nodeaffinity.Name:                          nodeaffinity.New,</span><br><span class="line">podtopologyspread.Name:                     podtopologyspread.New,</span><br><span class="line">nodeunschedulable.Name:                     nodeunschedulable.New,</span><br><span class="line">noderesources.FitName:                      noderesources.NewFit,</span><br><span class="line">noderesources.BalancedAllocationName:       noderesources.NewBalancedAllocation,</span><br><span class="line">noderesources.MostAllocatedName:            noderesources.NewMostAllocated,</span><br><span class="line">noderesources.LeastAllocatedName:           noderesources.NewLeastAllocated,</span><br><span class="line">noderesources.RequestedToCapacityRatioName: noderesources.NewRequestedToCapacityRatio,</span><br><span class="line">noderesources.ResourceLimitsName:           noderesources.NewResourceLimits,</span><br><span class="line">volumebinding.Name:                         volumebinding.New,</span><br><span class="line">volumerestrictions.Name:                    volumerestrictions.New,</span><br><span class="line">volumezone.Name:                            volumezone.New,</span><br><span class="line">nodevolumelimits.CSIName:                   nodevolumelimits.NewCSI,</span><br><span class="line">nodevolumelimits.EBSName:                   nodevolumelimits.NewEBS,</span><br><span class="line">nodevolumelimits.GCEPDName:                 nodevolumelimits.NewGCEPD,</span><br><span class="line">nodevolumelimits.AzureDiskName:             nodevolumelimits.NewAzureDisk,</span><br><span class="line">nodevolumelimits.CinderName:                nodevolumelimits.NewCinder,</span><br><span class="line">interpodaffinity.Name:                      interpodaffinity.New,</span><br><span class="line">nodelabel.Name:                             nodelabel.New,</span><br><span class="line">serviceaffinity.Name:                       serviceaffinity.New,</span><br><span class="line">queuesort.Name:                             queuesort.New,</span><br><span class="line">defaultbinder.Name:                         defaultbinder.New,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个问题，对于Plugins目录下的每个插件，是如何决定自己属于那个扩展点呢？</p><h2 id="Plugin-Lifecycle"><a href="#Plugin-Lifecycle" class="headerlink" title="Plugin Lifecycle"></a>Plugin Lifecycle</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><blockquote><p>There are two steps to plugin initialization. First, <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#plugin-registration" target="_blank" rel="external nofollow noopener noreferrer">plugins are registered</a>. Second, the scheduler uses its configuration to decide which plugins to instantiate. If a plugin registers for multiple extension points, <em>it is instantiated only once</em>.</p><p>When a plugin is instantiated, it is passed <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#optional-args" target="_blank" rel="external nofollow noopener noreferrer">config args</a> and a <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#frameworkhandle" target="_blank" rel="external nofollow noopener noreferrer"><code>FrameworkHandle</code></a>.</p></blockquote><h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><blockquote><p>There are two types of concurrency that plugin writers should consider. A plugin might be invoked several times concurrently when evaluating multiple nodes, and a plugin may be called concurrently from <em>different <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#scheduling-cycle--binding-cycle" target="_blank" rel="external nofollow noopener noreferrer">scheduling contexts</a></em>.</p><p><em>Note: Within one scheduling context, each extension point is evaluated serially.</em></p><p>In the main thread of the scheduler, only one scheduling cycle is processed at a time. Any extension point up to and including <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#reserve" target="_blank" rel="external nofollow noopener noreferrer">reserve</a> will be finished before the next scheduling cycle begins*. After the reserve phase, the binding cycle is executed asynchronously. This means that a plugin could be called concurrently from two different scheduling contexts, provided that at least one of the calls is to an extension point after reserve. Stateful plugins should take care to handle these situations.</p><p>Finally, <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#un-reserve" target="_blank" rel="external nofollow noopener noreferrer">un-reserve</a> plugins may be called from either the Permit thread or the Bind thread, depending on how the pod was rejected.</p><p>* <em>The queue sort extension point is a special case. It is not part of a scheduling context and may be called concurrently for many pod pairs.</em></p><p><img alt="image" data-src="https://github.com/kubernetes/enhancements/raw/master/keps/sig-scheduling/20180409-scheduling-framework-threads.png"></p></blockquote><h2 id="Configuring-Plugins"><a href="#Configuring-Plugins" class="headerlink" title="Configuring Plugins"></a>Configuring Plugins</h2><h2 id="Interaction-with-Cluster-Autoscaler"><a href="#Interaction-with-Cluster-Autoscaler" class="headerlink" title="Interaction with Cluster Autoscaler"></a>Interaction with Cluster Autoscaler</h2><h1 id="调度器核心组件流程"><a href="#调度器核心组件流程" class="headerlink" title="调度器核心组件流程"></a>调度器核心组件流程</h1><h2 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h2><h3 id="调度器参数初始化"><a href="#调度器参数初始化" class="headerlink" title="调度器参数初始化"></a>调度器参数初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultSchedulerOptions = schedulerOptions&#123;</span><br><span class="line">profiles: []schedulerapi.KubeSchedulerProfile&#123;</span><br><span class="line"><span class="comment">// Profiles' default plugins are set from the algorithm provider.</span></span><br><span class="line">&#123;SchedulerName: v1.DefaultSchedulerName&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">schedulerAlgorithmSource: schedulerapi.SchedulerAlgorithmSource&#123;</span><br><span class="line">Provider: defaultAlgorithmSourceProviderName(),</span><br><span class="line">&#125;,</span><br><span class="line">disablePreemption:        <span class="literal">false</span>,</span><br><span class="line">percentageOfNodesToScore: schedulerapi.DefaultPercentageOfNodesToScore,</span><br><span class="line">bindTimeoutSeconds:       BindTimeoutSeconds,</span><br><span class="line">podInitialBackoffSeconds: <span class="keyword">int64</span>(internalqueue.DefaultPodInitialBackoffDuration.Seconds()),</span><br><span class="line">podMaxBackoffSeconds:     <span class="keyword">int64</span>(internalqueue.DefaultPodMaxBackoffDuration.Seconds()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件工厂注册表的初始化"><a href="#插件工厂注册表的初始化" class="headerlink" title="插件工厂注册表的初始化"></a>插件工厂注册表的初始化</h3><p>插件工厂注册表的初始化分为两个部分in tree和out of tree即当前版本自带的和用户自定义的两部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先进行当前版本的插件注册表的注册</span></span><br><span class="line">registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line"><span class="comment">// 加载用户自定义的插件注册表</span></span><br><span class="line"><span class="keyword">if</span> err := registry.Merge(options.frameworkOutOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件informer回调handler绑定"><a href="#事件informer回调handler绑定" class="headerlink" title="事件informer回调handler绑定"></a>事件informer回调handler绑定</h3><p>绑定事件回调主要是通过AddAllEventHandlers主要是将各种资源数据通过SchedulerCache放入本地缓存中，同时针对未调度的pod(!assignedPod即没有绑定Node的pod)加入到调度队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">    schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    informerFactory informers.SharedInformerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br></pre></td></tr></table></figure><h3 id="触发未调度队列中的pod转移"><a href="#触发未调度队列中的pod转移" class="headerlink" title="触发未调度队列中的pod转移"></a>触发未调度队列中的pod转移</h3><p>当资源发生变化的时候，比如service、volume等就会对unschedulableQ中的之前调度失败的pod进行重试，选择将其转移到activeQ或者backoffQ中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveOrBackoffQueue</span><span class="params">(event <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">    unschedulablePods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>, <span class="built_in">len</span>(p.unschedulableQ.podInfoMap))</span><br><span class="line">    <span class="comment">// 获取所有unschedulable的pod</span></span><br><span class="line">    <span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">        unschedulablePods = <span class="built_in">append</span>(unschedulablePods, pInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将unschedulable的pod转移到backoffQ队列或者activeQ队列中</span></span><br><span class="line">    p.movePodsToActiveOrBackoffQueue(unschedulablePods, event)</span><br><span class="line">    <span class="comment">// 修改迁移调度器请求周期, 在失败的时候会进行比较pod的moveRequestCycle是否&gt;=schedulingCycle</span></span><br><span class="line">    p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">    p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h3><p>最后则会启动调度器，其核心流程是在scheduleOne中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先会进行同步缓存</span></span><br><span class="line">    <span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动调度队列的后台定时任务</span></span><br><span class="line">    sched.SchedulingQueue.Run()</span><br><span class="line">    <span class="comment">// 启动调度流程</span></span><br><span class="line">    wait.UntilWithContext(ctx, sched.scheduleOne, <span class="number">0</span>)</span><br><span class="line">    sched.SchedulingQueue.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建调度器核心组件基础数据"><a href="#构建调度器核心组件基础数据" class="headerlink" title="构建调度器核心组件基础数据"></a>构建调度器核心组件基础数据</h2><h3 id="获取等待调度的pod"><a href="#获取等待调度的pod" class="headerlink" title="获取等待调度的pod"></a>获取等待调度的pod</h3><p>获取等待调度的pod则直接通过NextPod进行，其实内部就是对 <code>schedulingQueue.pop</code>的封装</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列中获取等待调度的pod</span></span><br><span class="line">podInfo := sched.NextPod()</span><br><span class="line"><span class="comment">// pod could be nil when schedulerQueue is closed</span></span><br><span class="line"><span class="keyword">if</span> podInfo == <span class="literal">nil</span> || podInfo.Pod == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>NextPod</code> 方法是在Scheduler初始化时候指定的。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">SchedulerCache:  c.schedulerCache,</span><br><span class="line">Algorithm:       algo,</span><br><span class="line">Profiles:        profiles,</span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, podQueue, c.schedulerCache),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">VolumeBinder:    c.volumeBinder,</span><br><span class="line">SchedulingQueue: podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>具体实现方法如下：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/internal/queue/scheduling_queue.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">PodInfo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">PodInfo</span></span> &#123;</span><br><span class="line">        podInfo, err := queue.Pop()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v/%v"</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class="line">            <span class="keyword">return</span> podInfo</span><br><span class="line">        &#125;</span><br><span class="line">        klog.Errorf(<span class="string">"Error while retrieving next pod from scheduling queue: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取调度器Profile"><a href="#获取调度器Profile" class="headerlink" title="获取调度器Profile"></a>获取调度器Profile</h3><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prof, err := sched.profileForPod(pod)</span><br></pre></td></tr></table></figure><p>这里的Profile是根据每个Pod制定的Scheduler Name获得对应的调度器Profile</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">profileForPod</span><span class="params">(pod *v1.Pod)</span> <span class="params">(*profile.Profile, error)</span></span> &#123;</span><br><span class="line">prof, ok := sched.Profiles[pod.Spec.SchedulerName]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"profile not found for scheduler name %q"</span>, pod.Spec.SchedulerName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prof, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Profiles</code>是一个对于Framework的封装</p><figure class="highlight go"><figcaption><span>pkg/scheduler/profile/profile.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Profile is a scheduling profile.</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">framework.Framework</span><br><span class="line">Recorder events.EventRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProfile builds a Profile for the given configuration.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProfile</span><span class="params">(cfg config.KubeSchedulerProfile, frameworkFact FrameworkFactory, recorderFact RecorderFactory)</span> <span class="params">(*Profile, error)</span></span> &#123;</span><br><span class="line">f, err := frameworkFact(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r := recorderFact(cfg.SchedulerName)</span><br><span class="line"><span class="keyword">return</span> &amp;Profile&#123;</span><br><span class="line">Framework: f,</span><br><span class="line">Recorder:  r,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map holds profiles indexed by scheduler name.</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]*Profile</span><br></pre></td></tr></table></figure><p>在创建scheduler的时候，建立profiles</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiles, err := profile.NewMap(c.profiles, c.buildFramework, c.recorderFactory)</span><br></pre></td></tr></table></figure><p>关于Profile，可以参考 <a href="https://github.com/kubernetes/kubernetes/pull/88285" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kubernetes/pull/88285</a></p><h3 id="跳过提议Pod重调度"><a href="#跳过提议Pod重调度" class="headerlink" title="跳过提议Pod重调度"></a>跳过提议Pod重调度</h3><p>skipPodSchedule即检查当前 pod是否可以进行跳过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sched.skipPodSchedule(pod) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两种情况下Pod就不需要进行重复的调度</p><ul><li>pod已经被删除</li><li>pod已经被提议调度到某个节点，此时如果只是版本的更新，即除了ResourceVersion、Annotations、NodeName三个字段其余的都未曾变化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipPodSchedule returns true if we could skip scheduling the pod for specified cases.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">skipPodSchedule</span><span class="params">(prof *profile.Profile, pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Case 1: pod is being deleted.</span></span><br><span class="line"><span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">prof.Recorder.Eventf(pod, <span class="literal">nil</span>, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Scheduling"</span>, <span class="string">"skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"Skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2: pod has been assumed and pod updates could be skipped.</span></span><br><span class="line"><span class="comment">// An assumed pod can be added again to the scheduling queue if it got an update event</span></span><br><span class="line"><span class="comment">// during its previous scheduling cycle but before getting assumed.</span></span><br><span class="line"><span class="keyword">if</span> sched.skipPodUpdate(pod) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的判断规则是</p><figure class="highlight go"><figcaption><span>pkg/scheduler/eventhandler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipPodUpdate checks whether the specified pod update should be ignored.</span></span><br><span class="line"><span class="comment">// This function will return true if</span></span><br><span class="line"><span class="comment">//   - The pod has already been assumed, AND</span></span><br><span class="line"><span class="comment">//   - The pod has only its ResourceVersion, Spec.NodeName, Annotations,</span></span><br><span class="line"><span class="comment">//     ManagedFields, Finalizers and/or Conditions updated.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">skipPodUpdate</span><span class="params">(pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Non-assumed pods should never be skipped.</span></span><br><span class="line">isAssumed, err := sched.SchedulerCache.IsAssumedPod(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to check whether pod %s/%s is assumed: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !isAssumed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gets the assumed pod from the cache.</span></span><br><span class="line">assumedPod, err := sched.SchedulerCache.GetPod(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to get assumed pod %s/%s from cache: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compares the assumed pod in the cache with the pod update. If they are</span></span><br><span class="line"><span class="comment">// equal (with certain fields excluded), this pod update will be skipped.</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">p := pod.DeepCopy()</span><br><span class="line"><span class="comment">// ResourceVersion must be excluded because each object update will</span></span><br><span class="line"><span class="comment">// have a new resource version.</span></span><br><span class="line">p.ResourceVersion = <span class="string">""</span></span><br><span class="line"><span class="comment">// Spec.NodeName must be excluded because the pod assumed in the cache</span></span><br><span class="line"><span class="comment">// is expected to have a node assigned while the pod update may nor may</span></span><br><span class="line"><span class="comment">// not have this field set.</span></span><br><span class="line">p.Spec.NodeName = <span class="string">""</span></span><br><span class="line"><span class="comment">// Annotations must be excluded for the reasons described in</span></span><br><span class="line"><span class="comment">// https://github.com/kubernetes/kubernetes/issues/52914.</span></span><br><span class="line">p.Annotations = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Same as above, when annotations are modified with ServerSideApply,</span></span><br><span class="line"><span class="comment">// ManagedFields may also change and must be excluded</span></span><br><span class="line">p.ManagedFields = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// The following might be changed by external controllers, but they don't</span></span><br><span class="line"><span class="comment">// affect scheduling decisions.</span></span><br><span class="line">p.Finalizers = <span class="literal">nil</span></span><br><span class="line">p.Status.Conditions = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">assumedPodCopy, podCopy := f(assumedPod), f(pod)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(assumedPodCopy, podCopy) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"Skipping pod %s/%s update"</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建调度上下文"><a href="#构建调度上下文" class="headerlink" title="构建调度上下文"></a>构建调度上下文</h3><p>生成CycleState和context, 其中CycleState用于进行调度器周期上线文数据传递共享，而context则负责统一的退出协调管理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建CycleState和context</span></span><br><span class="line">state := framework.NewCycleState()</span><br><span class="line">state.SetRecordPluginMetrics(rand.Intn(<span class="number">100</span>) &lt; pluginMetricsSamplePercent)</span><br><span class="line">schedulingCycleCtx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br></pre></td></tr></table></figure><h2 id="正常调度流程"><a href="#正常调度流程" class="headerlink" title="正常调度流程"></a>正常调度流程</h2><h3 id="调度算法执行"><a href="#调度算法执行" class="headerlink" title="调度算法执行"></a>调度算法执行</h3><p>正常调度只需要调度ScheduleAlgorithm来进行调度，具体实现细节可以看之前的文章</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, state, pod)</span><br></pre></td></tr></table></figure><h3 id="Assume-Pod"><a href="#Assume-Pod" class="headerlink" title="Assume Pod"></a>Assume Pod</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br></pre></td></tr></table></figure><p>如果一个Pod被提议存储到某个节点，则会先将其加入到SchedulerCache中，同时从SchedulingQueue中移除，避免重复调度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    assumed.Spec.NodeName = host</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到SchedulerCache中这样下个调度周期中，pod会占用对应node的资源</span></span><br><span class="line">    <span class="keyword">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"scheduler cache AssumePod failed: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if "assumed" is a nominated pod, we should remove it from internal cache</span></span><br><span class="line">    <span class="comment">// 从调度队列中移除pod</span></span><br><span class="line">    <span class="keyword">if</span> sched.SchedulingQueue != <span class="literal">nil</span> &#123;</span><br><span class="line">        sched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定调度流程"><a href="#绑定调度流程" class="headerlink" title="绑定调度流程"></a>绑定调度流程</h2><p>首先会遍历所有的插件，然后如果发现状态设置为Wait，则会根据插件的等待时间进行wait操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run "permit" plugins.</span></span><br><span class="line">runPermitStatus := prof.RunPermitPlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br></pre></td></tr></table></figure><p>运行Permit插件之后，Bind阶段可以异步运行，依次绑定Volumes，运行Prebind插件，执行bind操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">bindingCycleCtx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">waitOnPermitStatus := prof.WaitOnPermit(bindingCycleCtx, assumedPod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind volumes first before Pod</span></span><br><span class="line"><span class="keyword">if</span> !allBound &#123;</span><br><span class="line">err := sched.bindVolumes(assumedPod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run "prebind" plugins.</span></span><br><span class="line">preBindStatus := prof.RunPreBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line"></span><br><span class="line">err := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Run "postbind" plugins.</span></span><br><span class="line">prof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>如果是预选失败的，并且当前调度器允许抢占功能，则会进行抢占调度处理即sched.preempt</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> fitError, ok := err.(*core.FitError); ok &#123;</span><br><span class="line">    <span class="comment">// 如果是预选失败则进行</span></span><br><span class="line">    <span class="keyword">if</span> sched.DisablePreemption &#123;</span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">"Pod priority feature is not enabled or preemption is disabled by scheduler configuration."</span> +</span><br><span class="line">            <span class="string">" No preemption is performed."</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preemptionStartTime := time.Now()</span><br><span class="line">        <span class="comment">// 抢占调度</span></span><br><span class="line">        sched.preempt(schedulingCycleCtx, state, fwk, pod, fitError)</span><br><span class="line">        metrics.PreemptionAttempts.Inc()</span><br><span class="line">        metrics.SchedulingAlgorithmPreemptionEvaluationDuration.Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">        metrics.DeprecatedSchedulingDuration.WithLabelValues(metrics.PreemptionEvaluation).Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取抢占者"><a href="#获取抢占者" class="headerlink" title="获取抢占者"></a>获取抢占者</h3><p>首先通过apiserver获取当前需要执行抢占的pod的最新Pod信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preemptor, err := sched.podPreemptor.getUpdatedPod(preemptor)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">"Error getting the updated preemptor pod object: %v"</span>, err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过抢占算法筛选"><a href="#通过抢占算法筛选" class="headerlink" title="通过抢占算法筛选"></a>通过抢占算法筛选</h3><p>通过Preempt筛选要进行抢占操作的node节点、待驱逐的pod、待驱逐的提议的pod</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node, victims, nominatedPodsToClear, err := sched.Algorithm.Preempt(ctx, state, preemptor, scheduleErr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">"Error preempting victims to make room for %v/%v: %v"</span>, preemptor.Namespace, preemptor.Name, err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新调度队列中的Pod信息"><a href="#更新调度队列中的Pod信息" class="headerlink" title="更新调度队列中的Pod信息"></a>更新调度队列中的Pod信息</h3><p>如果节点抢占一个pod成功，则会更新队列中的抢占节点的提议节点信息，这样在下个调度周期中，就可以使用该信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sched.SchedulingQueue.<span class="constructor">UpdateNominatedPodForNode(<span class="params">preemptor</span>, <span class="params">nodeName</span>)</span></span><br></pre></td></tr></table></figure><h3 id="更新Pod的提议节点信息"><a href="#更新Pod的提议节点信息" class="headerlink" title="更新Pod的提议节点信息"></a>更新Pod的提议节点信息</h3><p>这里会直接调用apiserver中节点的提议节点信息，为什么要这样做呢？因为当前pod已经抢占了node上部分的节点信息，但是在被抢占的pod完全从节点上删除之前的这段时间，该pod调度依然会失败，但是此时不能继续调用抢占流程了，因为你已经执行了抢占，此时只需要等待对应节点上的node都删除，则再次继续尝试调度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = sched.podPreemptor.setNominatedNodeName(preemptor, nodeName)</span><br></pre></td></tr></table></figure><h3 id="删除被驱逐节点"><a href="#删除被驱逐节点" class="headerlink" title="删除被驱逐节点"></a>删除被驱逐节点</h3><p>删除被驱逐节点直接调用apiserver进行操作，如果此时发现当前pod还在等待插件的Allow操作，则直接进行Reject</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">        <span class="comment">// 调用apiserver进行删除pod</span></span><br><span class="line">        <span class="keyword">if</span> err := sched.podPreemptor.deletePod(victim); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(<span class="string">"Error preempting pod %v/%v: %v"</span>, victim.Namespace, victim.Name, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the victim is a WaitingPod, send a reject message to the PermitPlugin</span></span><br><span class="line">        <span class="keyword">if</span> waitingPod := fwk.GetWaitingPod(victim.UID); waitingPod != <span class="literal">nil</span> &#123;</span><br><span class="line">            waitingPod.Reject(<span class="string">"preempted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sched.Recorder.Eventf(victim, preemptor, v1.EventTypeNormal, <span class="string">"Preempted"</span>, <span class="string">"Preempting"</span>, <span class="string">"Preempted by %v/%v on node %v"</span>, preemptor.Namespace, preemptor.Name, nodeName)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="更新被抢占的提议节点"><a href="#更新被抢占的提议节点" class="headerlink" title="更新被抢占的提议节点"></a>更新被抢占的提议节点</h3><p>针对那些已经被提议调度到当前node的pod，会将其node设置为空，重新进行调度选择</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> nominatedPodsToClear &#123;</span><br><span class="line">    <span class="comment">// 清理这些提议的pod</span></span><br><span class="line">    rErr := sched.podPreemptor.removeNominatedNodeName(p)</span><br><span class="line">    <span class="keyword">if</span> rErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Cannot remove 'NominatedPod' field of pod: %v"</span>, rErr)</span><br><span class="line">        <span class="comment">// We do not return as this error is not critical.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Algorithm-Source"><a href="#Algorithm-Source" class="headerlink" title="Algorithm Source"></a>Algorithm Source</h2><h3 id="Algorithm-Provider"><a href="#Algorithm-Provider" class="headerlink" title="Algorithm Provider"></a>Algorithm Provider</h3><h3 id="Algorithm-Policy"><a href="#Algorithm-Policy" class="headerlink" title="Algorithm Policy"></a>Algorithm Policy</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md" target="_blank" rel="external nofollow noopener noreferrer">KEP for scheduling framework</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes Scheduling Framework 是在Kubernetes 1.15版本后新出现的一种调度框架。Scheduling Framework 在原有的调度流程中, 定义了丰富扩展点接口，开发者可以通过实现扩展点所定义的接口来实现插件，将插件注册到扩展点。Scheduling Framework 在执行调度流程时，运行到相应的扩展点时，会调用用户注册的插件，影响调度决策的结果。通过这种方式来将用户的调度逻辑集成到 Scheduling Framework 中。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-01-25_scheduling-framework-extensions.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
      <category term="framework" scheme="http://houmin.cc/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>【下厨房】酸甜麻辣咸</title>
    <link href="http://houmin.cc/posts/8f35743d/"/>
    <id>http://houmin.cc/posts/8f35743d/</id>
    <published>2020-07-13T13:21:43.000Z</published>
    <updated>2020-07-25T14:18:13.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出<code>Hello World</code>，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印<code>Hello World</code>，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。</p><a id="more"></a><h2 id="基本调料"><a href="#基本调料" class="headerlink" title="基本调料"></a>基本调料</h2><h3 id="食盐"><a href="#食盐" class="headerlink" title="食盐"></a>食盐</h3><ul><li>盐乃百味之首，主要用于调出咸味。</li><li>做菜时，<strong>在多数情况下</strong>都是在<strong>最后调味阶段再放盐</strong>的，例如炒菜、炖汤、炖菜时，因为这样可以保证盐不会破坏掉其他的味道，也可以保证碘元素少挥发，还能保证菜品不会过咸。</li><li>但如果在准备<strong>食材时需要提前入味</strong>的情况下，就<strong>需要先放盐了</strong>，例如蒸肉、蒸鱼。</li></ul><p><img alt="盐" data-src="https://pic1.zhimg.com/v2-f828837cbf0cf989cfb25b5b1bbdac78_b.webp"></p><h3 id="酱油"><a href="#酱油" class="headerlink" title="酱油"></a>酱油</h3><ul><li>我国传统调料，主要用来增咸提鲜。酱油可分为生抽和老抽。</li><li><strong>老抽</strong>吃到嘴里很浓稠，一般用于给食物上色提鲜。</li><li><strong>生抽</strong>颜色比较淡，味道稍咸，主要用来调味，炒菜或者凉拌菜的时候用得比较多。</li></ul><h3 id="鸡精和味精"><a href="#鸡精和味精" class="headerlink" title="鸡精和味精"></a>鸡精和味精</h3><ul><li>调鲜专用，主要成分都是谷氨酸钠，两者其实在原料上差别不大，只是口感上，<strong>鸡精更鲜，更有风味</strong>。</li><li>值得一提的是，<strong>鸡精和味精其实真的不会致癌</strong>，所以正常做菜使用是没有问题的！</li></ul><p><strong>使用鸡精和味精的注意事项：</strong></p><ul><li>高汤烹制的菜肴不必使用，因为已经很鲜美了；</li><li>酸性强的菜肴，如糖醋、醋溜菜等不宜使用；</li><li>腌菜不要使用味精；</li><li>不宜过早放味精，要在将出锅时放入；</li><li>如果用于凉拌菜，可以先溶解再使用;</li><li>不能在高温下使用。</li></ul><p><img alt="鸡精和味精" data-src="https://pic3.zhimg.com/v2-73bbb13a22c0b7fd1ec322934b73c1ec_b.jpg"></p><h3 id="醋"><a href="#醋" class="headerlink" title="醋"></a>醋</h3><p>我国古代传统调味料之一。有三千多年的历史。醋在分类上通常有以下几类：<strong>米醋、陈醋、白醋。</strong></p><ul><li><strong>米醋</strong>的口感更好，口感酸甜，可用于糖醋排骨。</li><li><strong>陈醋</strong>酸味很浓烈，很开胃，基本上可用于各种常见的调味。</li><li><strong>白醋</strong>的酸味口感较淡，多用于凉拌菜或西餐的使用。</li></ul><p><strong>下面总结一下醋的各种常见功能：</strong></p><ul><li><strong>去腥去膻：</strong>做鱼做羊的时候可加入少许醋去除异味</li><li><strong>减少辣味：</strong>如果炒菜时不小心辣椒放多了，可以放一些醋减少辣味</li><li><strong>增香：</strong>做菜时候加入少许醋，可以增加菜肴香味并减少油腻程度</li><li><strong>催熟：</strong>炖牛羊肉的时候加一点醋能够让菜肴熟得更快</li><li><strong>增甜：</strong>南方朋友做甜粥的时候加入少许醋可以使粥更甜</li></ul><p><img alt="醋" data-src="https://pic1.zhimg.com/v2-3a5d4fa5e12fd226862b423e39baf703_b.jpg"></p><h3 id="糖"><a href="#糖" class="headerlink" title="糖"></a>糖</h3><ul><li><p>增甜味的调料，常见的种类有白糖、红糖、冰糖。</p><ul><li>一般使用白糖作为调料。</li><li>红糖可以补血破淤具有益气、缓中、助脾化食的作用。</li><li>冰糖可以去痰止咳，一般可用于制作红烧类菜肴时增加色泽及口感，也可用于制作甜品。</li></ul></li><li><p>少许白糖可以提鲜。</p></li><li><p>白糖还可以综合酸味，可做醋溜系的菜。</p></li><li><p>由于糖的特性，可做拔丝香蕉等“拔丝类”菜肴</p></li><li><p>挂霜：白糖入锅，加入适量清水，熬至水近干时，倒入经烘烤或油炸过的原料，离火，翻拌，冷却后，成品表面即似白霜状。如糖霜花生、糖山楂、糖霜核桃等。</p></li><li><p>炒糖色：广泛用于卤菜、红烧菜的调色、如红烧猪蹄、红烧排骨等。</p></li><li><p>糖醋菜系必备，开胃可口。</p><p><img alt="糖" data-src="https://pic3.zhimg.com/v2-0af08e21b39bc930a099b05f35c3ccfa_b.jpg"></p></li></ul><h2 id="酒类"><a href="#酒类" class="headerlink" title="酒类"></a>酒类</h2><h3 id="料酒"><a href="#料酒" class="headerlink" title="料酒"></a><strong>料酒</strong></h3><ul><li><strong>去腥</strong>专家，很多肉类、内脏等食材在初加工时，都会使用料酒去腥。</li><li>例如在<strong>炒鸡蛋的时候加入少许料酒也可以去腥提香</strong></li></ul><h3 id="啤酒"><a href="#啤酒" class="headerlink" title="啤酒"></a><strong>啤酒</strong></h3><ul><li>硬菜会用啤酒去腥、调味，请家里常备“宽啤酒”</li></ul><h3 id="高度白酒"><a href="#高度白酒" class="headerlink" title="高度白酒"></a><strong>高度白酒</strong></h3><ul><li>去除腥味较重的食物时可以用到</li></ul><h2 id="酱类"><a href="#酱类" class="headerlink" title="酱类"></a>酱类</h2><p>酱类调料：各类以酱为形式的调料</p><h3 id="豆瓣酱"><a href="#豆瓣酱" class="headerlink" title="豆瓣酱"></a>豆瓣酱</h3><p>川菜之魂，主要<strong>增加菜肴的咸鲜味</strong>。</p><h3 id="甜面酱"><a href="#甜面酱" class="headerlink" title="甜面酱"></a>甜面酱</h3><p>以面粉、水和食盐为原料的一种酱料，<strong>鲜香甜味十足</strong>。可以当做酱料使用（例如蘸黄瓜），也可以调味，是炸酱面、京酱肉丝等菜肴的必备调料。　　</p><h3 id="番茄酱"><a href="#番茄酱" class="headerlink" title="番茄酱"></a>番茄酱</h3><p>用新鲜番茄经过加工而成的酱料，鲜而酸。常用于<strong>增色、添香、增加酸味口感</strong>，如制作松鼠鱼。</p><h3 id="芝麻酱"><a href="#芝麻酱" class="headerlink" title="芝麻酱"></a>芝麻酱</h3><p>顾名思义是芝麻作为原料调制的酱料，非常的香，<strong>增香必备</strong>。可直接作为蘸料，例如北方的同学吃火锅是喜欢蘸麻酱，也常用于制作凉面、凉拌菜等。</p><h3 id="蚝油"><a href="#蚝油" class="headerlink" title="蚝油"></a>蚝油</h3><p>以素有”海底牛奶”之称的蚝牗牡蛎牍为原料，经煮熟取汁浓缩，加辅料精制而成。蚝油味道鲜美、蚝香浓郁，黏稠适度，营养价值高。适合烹制多种食材，如蚝油牛肉、蚝油生菜、蚝油荷兰豆等，还可<strong>调拌各种面食、涮海鲜、佐餐食用</strong>等。</p><h2 id="香料类"><a href="#香料类" class="headerlink" title="香料类"></a>香料类</h2><p>香料分很多种，主要功能是增加各种风味，使味更有层次感。</p><h3 id="干辣椒："><a href="#干辣椒：" class="headerlink" title="干辣椒："></a>干辣椒：</h3><p><strong>增香、增辣。</strong></p><p>油热时和葱姜一起放锅内爆香，一般家常菜都可以用。</p><h3 id="花椒与麻椒"><a href="#花椒与麻椒" class="headerlink" title="花椒与麻椒"></a>花椒与麻椒</h3><p>增加菜肴的<strong>“麻”味</strong>，同时也是<strong>爆香</strong>的“利器”！炒菜的时候加入花椒可以防止油沸，花椒粉也可以用于包子或者饺子的馅料。麻椒比花椒颜色更重，更麻，喜欢重口味的同学可以用麻椒作为调料。</p><h3 id="八角-大料"><a href="#八角-大料" class="headerlink" title="八角(大料)"></a>八角(大料)</h3><p>也叫大茴香，因此无论<strong>卤、酱、烧、炖，</strong>都可以用到它，用以<strong>去腥添香。</strong>不论炒菜、炖肉、腌菜，八角都要提前放。一份菜一般放三瓣，分量多的可以放一整朵。</p><h3 id="胡椒"><a href="#胡椒" class="headerlink" title="胡椒"></a>胡椒</h3><ul><li>又分<strong>黑胡椒和白胡椒</strong>，常用于提鲜去腥，开胃、促进食欲。</li><li>其中<strong>黑胡椒味道更浓，香中带辣</strong>，适用于炖、煎、烤肉类。</li><li><strong>白胡椒胡椒香味稍淡，辣味更浓</strong>，能提出鲜味。</li><li>需要注意的是，无论黑胡椒、白胡椒皆不能高温油炸，应在菜肴或汤羹即将出锅时加少许。</li></ul><h3 id="香叶"><a href="#香叶" class="headerlink" title="香叶"></a>香叶</h3><p>干燥后的月桂树叶，用以<strong>去腥添香</strong>，用于炖肉、卤味等。</p><h3 id="桂皮"><a href="#桂皮" class="headerlink" title="桂皮"></a>桂皮</h3><p>干燥后的月桂树皮，用以去腥添香，也可以用于炖肉、卤味等。</p><h3 id="小茴香"><a href="#小茴香" class="headerlink" title="小茴香"></a>小茴香</h3><p>用以<strong>去腥添香</strong>，用于炖肉等。其茎叶部分即茴香菜。</p><h3 id="孜然"><a href="#孜然" class="headerlink" title="孜然"></a>孜然</h3><p>祛<strong>除腥膻异味</strong>的作用很强,！还能<strong>解除肉类的油腻</strong>,常用在烧烤牛羊肉中，令肉质更加鲜美芳香并且去除膻味异味。</p><h3 id="五香粉"><a href="#五香粉" class="headerlink" title="五香粉"></a><strong>五香粉</strong></h3><p>花椒、大料、桂皮、丁香等芳香类调料混合研制而成，使用方便。尤其适合用于<strong>烘烤或快炒肉类，炖、焖、煨、蒸、煮菜肴</strong>作调味。</p><h2 id="辣椒类"><a href="#辣椒类" class="headerlink" title="辣椒类"></a>辣椒类</h2><p><img alt="辣椒" data-src="https://pic2.zhimg.com/v2-471d6358a188a14ebf240fa500d0164f_b.jpg"></p><h3 id="剁椒与糟辣椒"><a href="#剁椒与糟辣椒" class="headerlink" title="剁椒与糟辣椒"></a>剁椒与糟辣椒</h3><p>云贵地区称作糟辣椒、湖南地区叫做剁椒，<strong>口味和制作工艺稍有差别</strong>，但是总体来说外表色泽鲜红，具有香、辣、鲜、酸、嫩、咸、脆、的独特风味，有开胃消食、暖胃驱寒的功效。可以直接食用、当做蘸料，也可用于调料，比如制作剁椒鱼头、鱼香肉丝、鱼香茄子等菜肴，值得注意的是，由于<strong>剁椒和糟辣椒本身就有盐味</strong>，所以调味时就<strong>不用额外添加过多的食盐</strong>了！</p><h3 id="红油辣椒"><a href="#红油辣椒" class="headerlink" title="红油辣椒"></a>红油辣椒</h3><p>是川菜中常见的调味料，油色红亮，味道香辣。常用于<strong>凉拌菜、拌面、蘸料等。</strong></p><h3 id="泡椒"><a href="#泡椒" class="headerlink" title="泡椒"></a>泡椒</h3><p>四川特产，由新鲜辣椒腌制而成。香、酸、辣味十足，是制作泡椒类菜肴的必备调料（例如川味鱼香肉丝、泡椒牛肉等）。<br>常见的泡椒主要有两种：</p><ul><li>二荆条泡辣椒：这种辣椒相对较长，辣味适口，香气足，可以切碎了使用，制作传统川菜鱼香肉丝就离不开它</li><li>子弹头泡辣椒：这种辣椒较短，呈鸡心状，其辣味足，因成形较好，在泡椒菜肴中常整个使用，很少加工成茸或切成小块。</li></ul><h2 id="食用油"><a href="#食用油" class="headerlink" title="食用油"></a>食用油</h2><h3 id="菜油-菜籽油"><a href="#菜油-菜籽油" class="headerlink" title="菜油(菜籽油)"></a>菜油(菜籽油)</h3><p>用油菜籽榨出来的一种食用油，有一种“青气味”。菜籽油具有一定的软化血管、延缓衰老的功效。常<strong>用于炒菜，也可以做红油辣椒。不适合凉拌菜。</strong></p><h3 id="花生油"><a href="#花生油" class="headerlink" title="花生油"></a>花生油</h3><p>淡黄透明，气味芬芳，滋味可口，是一种比较容易消化的食用油。花生油的脂肪酸构成是比较好的，易于人体消化和吸收。常用于炒菜，<strong>炒蔬菜最好，比较香。</strong> </p><h3 id="葵花籽油"><a href="#葵花籽油" class="headerlink" title="葵花籽油"></a>葵花籽油</h3><p>营养价值丰富，含有丰富的胡萝卜素。不适合油炸，常用于<strong>做汤、炒菜、凉拌。</strong></p><h3 id="玉米油"><a href="#玉米油" class="headerlink" title="玉米油"></a>玉米油</h3><p>优质玉米油营养含量丰富。也常用于炒菜，清淡不油腻也可增加香味。</p><h3 id="大豆油"><a href="#大豆油" class="headerlink" title="大豆油"></a>大豆油</h3><p>通常我们称之为“大豆色拉油”，是最常用的烹调油之一。做面点，但不适合炒菜。</p><h3 id="橄榄油"><a href="#橄榄油" class="headerlink" title="橄榄油"></a>橄榄油</h3><p>非常营养健康的油。炒菜时油烟很少，但高温易破坏营养，所以要想营养最大化还是凉拌菜比较好，但是缺点是炒菜炒起来没那么“香”。</p><h3 id="猪油"><a href="#猪油" class="headerlink" title="猪油"></a>猪油</h3><p>也称为荤油或猪大油。它是从猪的脂肪中提炼出，初始状态是略黄色半透明液体的食用油，常温下为白色或浅黄色固体，加热后会融化。<strong>猪油含胆固醇较多，对身体不利，建议少吃。</strong>但是炒菜做菜时能增香、添味。另外，由于常温时是固体，故不适合做凉拌食物。</p><h3 id="芝麻油"><a href="#芝麻油" class="headerlink" title="芝麻油"></a>芝麻油</h3><p>具有特别的香味，所以也叫香油。凉拌菜、汤类及热菜首选，可以<strong>增香提味。</strong></p><h3 id="牛油"><a href="#牛油" class="headerlink" title="牛油"></a>牛油</h3><p>从牛的脂肪组织里提炼出来的油脂，常温时也呈固体。风味浓郁，是做麻辣火锅底料必备调料。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出&lt;code&gt;Hello World&lt;/code&gt;，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印&lt;code&gt;Hello World&lt;/code&gt;，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_condiment.jpg" type="image" />
    
    
      <category term="吃顿好的" scheme="http://houmin.cc/categories/%E5%90%83%E9%A1%BF%E5%A5%BD%E7%9A%84/"/>
    
    
      <category term="下厨房" scheme="http://houmin.cc/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Scheduler</title>
    <link href="http://houmin.cc/posts/d3e0e7a2/"/>
    <id>http://houmin.cc/posts/d3e0e7a2/</id>
    <published>2020-07-13T12:46:33.000Z</published>
    <updated>2020-08-04T06:41:06.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>调度器（Scheduler）是 Kubernetes 的核心组件，它的主要功能是为待运行的工作负载 Pod 绑定运行的节点 Node。从最早基于谓词和优先级（Predicates and Priorities）的调度器，到 V1.15基于调度框架（Scheduling Framework）的调度器，Kubernetes的调度器正在快速演进，以满足不同场景对于资源调度的需求。</p><p>本文是「Kubernetes解读」的第二篇，本篇将首先介绍Kubernetes Scheduler的背景和它的演进过程，然后会通过 Kubernetes 1.16 版本分析基于谓词与优先级的调度器原理。在「Kubernetes解读」的第三篇 <a href="../83a17de0/">Scheduling Framework</a> 中，我将通过 Kubernetes 1.18 版本分析基于Framwork的调度器原理。</p><a id="more"></a><h2 id="Scheduler-概述"><a href="#Scheduler-概述" class="headerlink" title="Scheduler 概述"></a>Scheduler 概述</h2><h3 id="关于任务资源调度"><a href="#关于任务资源调度" class="headerlink" title="关于任务资源调度"></a>关于任务资源调度</h3><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computing" target="_blank" rel="external nofollow noopener noreferrer">computing</a>, <strong>scheduling</strong> is the method by which work is assigned to resources that complete the work.</p></blockquote><p>在计算机中，调度指的是为任务（Work）分配它所需要的资源（Resource），从而使得完成任务的方法。这里的任务可能是计算的线程，进程或者是数据流，与此同时，对应的资源可能是CPU、网络、内存或者是扩展卡等硬件资源。在计算机中，调度系统无处不在，不论是操作系统级别的调度器，还是编程语言级别的调度器，或者是CDN的资源调度，打车平台订单的调度等等。</p><p><strong>调度的核心就是对有限资源的合理分配，以达到我们期待实现的调度目标，本质上是解决资源的需求与供给不平衡的问题。</strong></p><p>一个调度系统可能会有多种调度目标，比如：</p><ul><li>最大化吞吐量</li><li>最小化等待时间</li><li>最小化延时或者响应时间</li><li>最大化公平</li></ul><p>在实践中，这些指标往往是互相矛盾的，因此调度器的设计往往是根据实际需求的权衡利弊的折中方案。在操作系统的进程调度器中，待调度的任务就是线程，而需要给任务分配的资源就是CPU时间。对于Kubernetes来说，它调度的基本单位是Pod，这些Pod会被调度到不同的Node上执行。不同的节点上资源类型不同，包括CPU、GPU和内存等资源。这些资源可以被拆分，但是都属于当前节点。</p><h3 id="任务资源调度设计的挑战"><a href="#任务资源调度设计的挑战" class="headerlink" title="任务资源调度设计的挑战"></a>任务资源调度设计的挑战</h3><ul><li>调度：任务最少等待时间与优先级</li><li>调度： 任务的本地性：尽可能将任务分配到包含任务执行资源的节点上</li><li>集群：高可用性</li><li>系统：可扩展性：系统如何如何应对业务需求的变化，提供的一种可扩展机制，在集群默认调度策略不满足业务需求时，通过扩展接口，来进行系统的扩展满足业务需求</li></ul><h3 id="Pod调度场景的挑战"><a href="#Pod调度场景的挑战" class="headerlink" title="Pod调度场景的挑战"></a>Pod调度场景的挑战</h3><h4 id="亲和性与反亲和性"><a href="#亲和性与反亲和性" class="headerlink" title="亲和性与反亲和性"></a>亲和性与反亲和性</h4><p>在kubernetes中的亲和性主要是指Pod和Node两种资源</p><ul><li>亲和性：<ul><li>Pod和Pod之间的亲和性</li><li>Pod和Node之间的亲和性</li></ul></li><li>反亲和性<ul><li>Pod和Pod之间的反亲和性</li><li>Pod和Node之间的反亲和性</li></ul></li></ul><p>举个例子：</p><ul><li>Pod之间的反亲和: 为了保证高可用我们通常会将同一业务的多个节点分散在不通的数据中心和机架</li><li>Pod与Node亲和性: 比如某些需要磁盘IO操作的Pod，我们可以调度到具有SSD的机器上，提高IO性能</li></ul><h4 id="多租户与容量规划"><a href="#多租户与容量规划" class="headerlink" title="多租户与容量规划"></a>多租户与容量规划</h4><p>多租户通常是为了进行集群资源的隔离，在业务系统中，通常会按照业务线来进行资源的隔离，同时会给业务设定对应的容量，从而避免单个业务线资源的过度使用影响整个公司的所有业务</p><h4 id="Zone和Node的选择"><a href="#Zone和Node的选择" class="headerlink" title="Zone和Node的选择"></a>Zone和Node的选择</h4><p>zone通常是在业务容灾中常见的概念，通过将服务分散在多个数据中心，避免因为单个数据中心故障导致业务完全不可用</p><p>因为之前亲和性的问题，如何在多个zone中的所有node中选择出一个合适的节点，则是一个比较大的挑战</p><h4 id="多样化资源的扩展"><a href="#多样化资源的扩展" class="headerlink" title="多样化资源的扩展"></a>多样化资源的扩展</h4><p>系统资源除了cpu、内存还包括网络、磁盘io、gpu等等，针对其余资源的分配调度，kubernetes还需要提供额外的扩展机制来进行调度扩展的支持</p><h4 id="资源混部"><a href="#资源混部" class="headerlink" title="资源混部"></a>资源混部</h4><p>kubernetes初期是针对pod调度场景而生，主要其实是在线web业务，这类任务的特点大部分都是无状态的，那如何针对离线场景的去支持离线的批处理计算等任务</p><h3 id="Kubernetes-Pod-LifeCycle"><a href="#Kubernetes-Pod-LifeCycle" class="headerlink" title="Kubernetes Pod LifeCycle"></a>Kubernetes Pod LifeCycle</h3><p>下图展示了一个Pod在Kubernetes集群中从创建到运行的过程：</p><ul><li>用户通过REST API 向ApiServer 创建 Deployment/DaemonSet/Job等任务</li><li>ApiServer收到用户请求后，存储相关数据到Etcd</li><li>Scheduler通过监听ApiServer，获取未调度的 Pod 列表</li><li>Scheduler通过调度算法算出分配给Pod的Node，并将Node信息和Pod进行绑定，结果存储在Etcd</li><li>Node上的Kubelet感知到调度结果，拉取镜像并运行Pod</li></ul><p><img alt="Kubernetes Pod LifeCycle" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-27_k8s-scheduler.png"></p><p>可以看到，Scheduler作为Kubernetes集群中核心模块，可以被视作一个黑盒：</p><ul><li>黑盒的输入为待调度的 Pod 和全部计算节点（Node）的信息</li><li>黑盒的输出为经过内部调度算法和策略处理算出的最优节点</li></ul><h3 id="Scheduler-基本职责"><a href="#Scheduler-基本职责" class="headerlink" title="Scheduler 基本职责"></a>Scheduler 基本职责</h3><p><code>kube-scheduler</code> 是作为单独的进程启动的，可以总结 <code>kube-scheduler</code> 的职责有以下这些：</p><ol><li><strong>Schduler高可用</strong>：基于Etcd实现分布式锁的竞争，实现高可用</li><li><strong>调度资源监听</strong>：基于List/Watch机制监听ApiServer上资源的变化，这里的资源主要指的是 Pod 和 Node ；</li><li><strong>调度节点分配</strong>：通过内部算法算出最优节点，并将结果写入Etcd</li></ol><h3 id="Scheduler-演进"><a href="#Scheduler-演进" class="headerlink" title="Scheduler 演进"></a>Scheduler 演进</h3><p>从Kubernetes v1.0发布开始，Scheduler就采用了基于谓词和优先级的算法进行调度，在完全切换到Scheduling Framework之前，分别在</p><ul><li>v1.2 引入了Scheduler Extender，支持外部扩展</li><li>v1.5 为调度器的优先级算法引入Map/Reduce的计算模式</li><li>v1.15 提出了基于Scheduling Framework的方式，实现Scheduler的轻量化、接口化与组件化</li><li>v1.18 将所有策略全部组件化，默认调度流程切换为Scheduling Framework</li><li>v1.19 将抢占过程也组件化，同时支持multi scheduling profile</li></ul><p><img alt="Scheduler Evolution Timeline" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-30_scheduler-timeline.png"></p><p>随着容器化技术普及，Kubernetes已经成为容器管理领域的事实标准，除了传统的互联网场景的应用，像AI、大数据、边缘计算等场景也开始迁移到 k8s 平台。与此同时，不同场景对于k8s调度器提出的要求也越来越高，k8s调度器正在快速演进中。</p><p>在本篇后续的分析中，将基于Kubernetes 1.16版本对其设计实现的原理和思路进行分析。</p><h2 id="Scheduler-初始化"><a href="#Scheduler-初始化" class="headerlink" title="Scheduler 初始化"></a>Scheduler 初始化</h2><h3 id="调度器结构体初识"><a href="#调度器结构体初识" class="headerlink" title="调度器结构体初识"></a>调度器结构体初识</h3><p>首先看一下调度器这个结构体的实现，其中比较关键的成员是 <code>SchedulerCache</code>、    <code>SchedulingQueue</code> 和 <code>Algorithm</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">  SchedulerCache internalcache.Cache</span><br><span class="line">  Algorithm core.ScheduleAlgorithm</span><br><span class="line">  GetBinder <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span> <span class="title">factory</span>.<span class="title">Binder</span></span></span><br><span class="line">  PodConditionUpdater factory.PodConditionUpdater</span><br><span class="line">  PodPreemptor factory.PodPreemptor</span><br><span class="line">  Framework framework.Framework</span><br><span class="line">  NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span></span><br><span class="line">  WaitForCacheSync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">  Error <span class="function"><span class="keyword">func</span><span class="params">(*v1.Pod, error)</span></span></span><br><span class="line">  Recorder events.EventRecorder</span><br><span class="line">  StopEverything &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  VolumeBinder *volumebinder.VolumeBinder</span><br><span class="line">  DisablePreemption <span class="keyword">bool</span></span><br><span class="line">  SchedulingQueue internalqueue.SchedulingQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了几个标准动作的函数</p><ul><li>NextPod()：当有下一个可用的Pod的时候，返回对应Pod，否则阻塞。</li><li>WaitForCache()：用于等待Cache同步。</li><li>Error()：当调度出现错误的时候，会调用Error函数，其参数是错误的Pod和错误。</li></ul><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">SchedulerCache:      c.schedulerCache,</span><br><span class="line">Algorithm:           algo,</span><br><span class="line">GetBinder:           getBinderFunc(c.client, extenders),</span><br><span class="line">PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">Framework:           c.framework,</span><br><span class="line">WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">&#125;,</span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(c.podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, c.podQueue, c.schedulerCache, c.StopEverything),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">VolumeBinder:    c.volumeBinder,</span><br><span class="line">SchedulingQueue: c.podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在创建 scheduler Config的时候，会依次对这几个函数定义</p><ul><li>NextPod()：调用SchedulingQueue的<code>MakeNextPodFunc</code>来获取下一个可调用Pod，本质上是调用Queue的Pop方法。</li><li>WaitForCache()：调用SchedulerCache的<code>WaitForCacheSync</code>来等待Cache同步</li><li>Error()：调用 <code>MakeDefaultErrorFunc</code>函数注入一个失败处理函数，主要讲失败的Pod放入到合适的队列重新再调度</li></ul><p>除了这几个主要函数外，还为<code>Scheduler</code>结构定义了几个动作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">schedule</span><span class="params">(pod *v1.Pod, pluginContext *framework.PluginContext)</span> <span class="params">(core.ScheduleResult, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">preempt</span><span class="params">(pluginContext *framework.PluginContext, fwk framework.Framework, preemptor *v1.Pod, scheduleErr error)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assumeVolumes</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="params">(allBound <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bindVolumes</span><span class="params">(assumed *v1.Pod)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(assumed *v1.Pod, targetNode <span class="keyword">string</span>, pluginContext *framework.PluginContext)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">recordSchedulingFailure</span><span class="params">(pod *v1.Pod, err error, reason <span class="keyword">string</span>, message <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>schedule()：输入是Pod，输出是调度结果，执行调度主要逻辑，通过 <code>genericScheduler</code>实现</li><li>preempt()：抢占调度，通过genericScheduler实现，并且更新 <code>Nominated</code></li><li>assumeVolumes()：根据选择的binding来更新Volume Cache</li><li>bindVolumes()：绑定PV</li><li>assume()：将Pod状态调整到Cache中，变为assumed</li><li>Bind()：执行绑定操作</li></ul><h3 id="调度器参数初始化"><a href="#调度器参数初始化" class="headerlink" title="调度器参数初始化"></a>调度器参数初始化</h3><p>我们在创建Scheduler结构体的时候会制定很多的参数：</p><figure class="highlight go"><figcaption><span>cmd/kube-scheduler/server.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the scheduler.</span></span><br><span class="line">sched, err := scheduler.New(cc.Client,</span><br><span class="line">cc.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">cc.PodInformer,</span><br><span class="line">cc.InformerFactory.Core().V1().PersistentVolumes(),</span><br><span class="line">cc.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">cc.InformerFactory.Core().V1().ReplicationControllers(),</span><br><span class="line">cc.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">cc.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">cc.InformerFactory.Core().V1().Services(),</span><br><span class="line">cc.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span><br><span class="line">cc.InformerFactory.Storage().V1().StorageClasses(),</span><br><span class="line">cc.InformerFactory.Storage().V1beta1().CSINodes(),</span><br><span class="line">cc.Recorder,</span><br><span class="line">cc.ComponentConfig.AlgorithmSource,</span><br><span class="line">stopCh,</span><br><span class="line">registry,</span><br><span class="line">cc.ComponentConfig.Plugins,</span><br><span class="line">cc.ComponentConfig.PluginConfig,</span><br><span class="line">scheduler.WithName(cc.ComponentConfig.SchedulerName),</span><br><span class="line">scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),</span><br><span class="line">scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),</span><br><span class="line">scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">scheduler.WithBindTimeoutSeconds(*cc.ComponentConfig.BindTimeoutSeconds))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>New</code>传递来自于cmd的参数，并且创建一个 <code>Configurator</code></p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns a Scheduler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(client clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">replicationControllerInformer coreinformers.ReplicationControllerInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">replicaSetInformer appsinformers.ReplicaSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">statefulSetInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pdbInformer policyinformers.PodDisruptionBudgetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">storageClassInformer storageinformersv1.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">csiNodeInformer storageinformersv1beta1.CSINodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">recorder events.EventRecorder,</span></span></span><br><span class="line"><span class="function"><span class="params">schedulerAlgorithmSource kubeschedulerconfig.SchedulerAlgorithmSource,</span></span></span><br><span class="line"><span class="function"><span class="params">stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">registry framework.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">plugins *kubeschedulerconfig.Plugins,</span></span></span><br><span class="line"><span class="function"><span class="params">pluginConfig []kubeschedulerconfig.PluginConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">         opts ...<span class="keyword">func</span>(o *schedulerOptions)</span>) <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set up the configurator which can create schedulers from configs.</span></span><br><span class="line">configurator := factory.NewConfigFactory(&amp;factory.ConfigFactoryArgs&#123;</span><br><span class="line">Client:                         client,</span><br><span class="line">NodeInformer:                   nodeInformer,</span><br><span class="line">PodInformer:                    podInformer,</span><br><span class="line">PvInformer:                     pvInformer,</span><br><span class="line">PvcInformer:                    pvcInformer,</span><br><span class="line">ReplicationControllerInformer:  replicationControllerInformer,</span><br><span class="line">ReplicaSetInformer:             replicaSetInformer,</span><br><span class="line">StatefulSetInformer:            statefulSetInformer,</span><br><span class="line">ServiceInformer:                serviceInformer,</span><br><span class="line">PdbInformer:                    pdbInformer,</span><br><span class="line">StorageClassInformer:           storageClassInformer,</span><br><span class="line">CSINodeInformer:                csiNodeInformer,</span><br><span class="line">HardPodAffinitySymmetricWeight: options.hardPodAffinitySymmetricWeight,</span><br><span class="line">DisablePreemption:              options.disablePreemption,</span><br><span class="line">PercentageOfNodesToScore:       options.percentageOfNodesToScore,</span><br><span class="line">BindTimeoutSeconds:             options.bindTimeoutSeconds,</span><br><span class="line">Registry:                       registry,</span><br><span class="line">Plugins:                        plugins,</span><br><span class="line">PluginConfig:                   pluginConfig,</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> config *factory.Config</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据不同的schedulerAlgorithmSource创建不同的config</span></span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">    config = configurator.CreateFromProvider(*source.Provider)</span><br><span class="line"><span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">    config = configurator.CreateFromConfig(*policy)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create the scheduler.</span></span><br><span class="line">sched := NewFromConfig(config)</span><br><span class="line">  </span><br><span class="line">  AddAllEventHandlers(sched, options.schedulerName, nodeInformer, podInformer, pvInformer, pvcInformer, serviceInformer, storageClassInformer, csiNodeInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigFactoryArgs是哪里来的？来自于命令行参数解析出来的。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigFactoryArgs is a set arguments passed to NewConfigFactory.</span></span><br><span class="line"><span class="keyword">type</span> ConfigFactoryArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Client                         clientset.Interface</span><br><span class="line">NodeInformer                   coreinformers.NodeInformer</span><br><span class="line">PodInformer                    coreinformers.PodInformer</span><br><span class="line">PvInformer                     coreinformers.PersistentVolumeInformer</span><br><span class="line">PvcInformer                    coreinformers.PersistentVolumeClaimInformer</span><br><span class="line">ReplicationControllerInformer  coreinformers.ReplicationControllerInformer</span><br><span class="line">ReplicaSetInformer             appsinformers.ReplicaSetInformer</span><br><span class="line">StatefulSetInformer            appsinformers.StatefulSetInformer</span><br><span class="line">ServiceInformer                coreinformers.ServiceInformer</span><br><span class="line">PdbInformer                    policyinformers.PodDisruptionBudgetInformer</span><br><span class="line">StorageClassInformer           storageinformersv1.StorageClassInformer</span><br><span class="line">CSINodeInformer                storageinformersv1beta1.CSINodeInformer</span><br><span class="line">HardPodAffinitySymmetricWeight <span class="keyword">int32</span></span><br><span class="line">DisablePreemption              <span class="keyword">bool</span></span><br><span class="line">PercentageOfNodesToScore       <span class="keyword">int32</span></span><br><span class="line">BindTimeoutSeconds             <span class="keyword">int64</span></span><br><span class="line">StopCh                         &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Registry                       framework.Registry</span><br><span class="line">Plugins                        *config.Plugins</span><br><span class="line">PluginConfig                   []config.PluginConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 ConfigFactoryArgs 构建 Configurator对象，在这个 <code>NewConfigFactory</code>函数里</p><ul><li>创建新的framework对象</li><li>创建新的SchedulingQueue：podQueue</li><li>创建新的SchedulerCache对象</li><li>创建新的VolumeBinder</li><li>…</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewConfigFactory initializes the default implementation of a Configurator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfigFactory</span><span class="params">(args *ConfigFactoryArgs)</span> *<span class="title">Configurator</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>当收到StopEverything的信号时，关闭podQueue。</p><p><code>CreateFromConfig</code> 用于注册Predicate函数、注册Prioritize函数、生成Extender列表</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateFromConfig creates a scheduler from the configuration file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">CreateFromConfig</span><span class="params">(policy schedulerapi.Policy)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler from configuration: %v"</span>, policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the policy configuration</span></span><br><span class="line"><span class="keyword">if</span> err := validation.ValidatePolicy(policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicateKeys := sets.NewString()</span><br><span class="line"><span class="keyword">if</span> policy.Predicates == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Using predicates from algorithm provider '%v'"</span>, DefaultProvider)</span><br><span class="line">provider, err := GetAlgorithmProvider(DefaultProvider)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">predicateKeys = provider.FitPredicateKeys</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, predicate := <span class="keyword">range</span> policy.Predicates &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering predicate: %s"</span>, predicate.Name)</span><br><span class="line">predicateKeys.Insert(RegisterCustomFitPredicate(predicate))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priorityKeys := sets.NewString()</span><br><span class="line"><span class="keyword">if</span> policy.Priorities == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Using priorities from algorithm provider '%v'"</span>, DefaultProvider)</span><br><span class="line">provider, err := GetAlgorithmProvider(DefaultProvider)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">priorityKeys = provider.PriorityFunctionKeys</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, priority := <span class="keyword">range</span> policy.Priorities &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering priority: %s"</span>, priority.Name)</span><br><span class="line">priorityKeys.Insert(RegisterCustomPriorityFunction(priority))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extenders []algorithm.SchedulerExtender</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(policy.ExtenderConfigs) != <span class="number">0</span> &#123;</span><br><span class="line">ignoredExtendedResources := sets.NewString()</span><br><span class="line"><span class="keyword">var</span> ignorableExtenders []algorithm.SchedulerExtender</span><br><span class="line"><span class="keyword">for</span> ii := <span class="keyword">range</span> policy.ExtenderConfigs &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating extender with config %+v"</span>, policy.ExtenderConfigs[ii])</span><br><span class="line">extender, err := core.NewHTTPExtender(&amp;policy.ExtenderConfigs[ii])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !extender.IsIgnorable() &#123;</span><br><span class="line">extenders = <span class="built_in">append</span>(extenders, extender)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ignorableExtenders = <span class="built_in">append</span>(ignorableExtenders, extender)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> policy.ExtenderConfigs[ii].ManagedResources &#123;</span><br><span class="line"><span class="keyword">if</span> r.IgnoredByScheduler &#123;</span><br><span class="line">ignoredExtendedResources.Insert(<span class="keyword">string</span>(r.Name))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// place ignorable extenders to the tail of extenders</span></span><br><span class="line">extenders = <span class="built_in">append</span>(extenders, ignorableExtenders...)</span><br><span class="line">predicates.RegisterPredicateMetadataProducerWithExtendedResourceOptions(ignoredExtendedResources)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Providing HardPodAffinitySymmetricWeight in the policy config is the new and preferred way of providing the value.</span></span><br><span class="line"><span class="comment">// Give it higher precedence than scheduler CLI configuration when it is provided.</span></span><br><span class="line"><span class="keyword">if</span> policy.HardPodAffinitySymmetricWeight != <span class="number">0</span> &#123;</span><br><span class="line">c.hardPodAffinitySymmetricWeight = policy.HardPodAffinitySymmetricWeight</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// When AlwaysCheckAllPredicates is set to true, scheduler checks all the configured</span></span><br><span class="line"><span class="comment">// predicates even after one or more of them fails.</span></span><br><span class="line"><span class="keyword">if</span> policy.AlwaysCheckAllPredicates &#123;</span><br><span class="line">c.alwaysCheckAllPredicates = policy.AlwaysCheckAllPredicates</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.CreateFromKeys(predicateKeys, priorityKeys, extenders)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CreateFromKeys</code> 基于刚才生成的<code>predicateKeys, priorityKeys, extenders</code> 得到PredicateFunc、PriorityFuncs，同时创建NewGenericScheduler，最后返回Config结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateFromKeys creates a scheduler from a set of registered fit predicate keys and priority keys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">CreateFromKeys</span><span class="params">(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler with fit predicates '%v' and priority functions '%v'"</span>, predicateKeys, priorityKeys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.GetHardPodAffinitySymmetricWeight() &lt; <span class="number">1</span> || c.GetHardPodAffinitySymmetricWeight() &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid hardPodAffinitySymmetricWeight: %d, must be in the range 1-100"</span>, c.GetHardPodAffinitySymmetricWeight())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicateFuncs, err := c.GetPredicates(predicateKeys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priorityConfigs, err := c.getPriorityFunctionConfigs(priorityKeys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priorityMetaProducer, err := c.getPriorityMetadataProducer()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicateMetaProducer, err := c.GetPredicateMetadataProducer()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">algo := core.NewGenericScheduler(</span><br><span class="line">c.schedulerCache,</span><br><span class="line">c.podQueue,</span><br><span class="line">predicateFuncs,</span><br><span class="line">predicateMetaProducer,</span><br><span class="line">priorityConfigs,</span><br><span class="line">priorityMetaProducer,</span><br><span class="line">c.framework,</span><br><span class="line">extenders,</span><br><span class="line">c.volumeBinder,</span><br><span class="line">c.pVCLister,</span><br><span class="line">c.pdbLister,</span><br><span class="line">c.alwaysCheckAllPredicates,</span><br><span class="line">c.disablePreemption,</span><br><span class="line">c.percentageOfNodesToScore,</span><br><span class="line">c.enableNonPreempting,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">SchedulerCache:      c.schedulerCache,</span><br><span class="line">Algorithm:           algo,</span><br><span class="line">GetBinder:           getBinderFunc(c.client, extenders),</span><br><span class="line">PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">Framework:           c.framework,</span><br><span class="line">WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">&#125;,</span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(c.podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, c.podQueue, c.schedulerCache, c.StopEverything),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">VolumeBinder:    c.volumeBinder,</span><br><span class="line">SchedulingQueue: c.podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件Informer回调handler绑定"><a href="#事件Informer回调handler绑定" class="headerlink" title="事件Informer回调handler绑定"></a>事件Informer回调handler绑定</h3><p>在 <code>pkg/scheduler/eventhandler.go</code>中，会将 informer 监听到的资源变更事件与对应的 handler绑定，绑定事件回调主要是通过AddAllEventHandlers主要是将各种资源数据通过SchedulerCache放入本地缓存中，同时针对未调度的pod(!assignedPod即没有绑定Node的pod)加入到调度队列中。主要的事件包括</p><ul><li>Scheduled Pod Cache<ul><li>增加：addPodToCache</li><li>更新：updatePodInCache</li><li>删除：deletePodFromCache</li></ul></li><li>Unscheduled Pod Queue<ul><li>增加：addPodToSchedulingQueue</li><li>更新：updatePodInSchedulingQueue</li><li>删除：deletePodFromSchedulingQueue</li></ul></li><li>Node资源变更：<ul><li>增加：addNodeToCache</li><li>更新：updateNodeInCache</li><li>删除：deleteNodeInCache</li></ul></li><li>PV资源变更<ul><li>增加：onPvAdd</li><li>更新：onPvUpdate</li></ul></li><li>PVC资源变更<ul><li>增加：onPvcAdd</li><li>更新：onPvcUpdate</li></ul></li><li>Service资源变更：这个主要是会影响 <code>ServiceAffinity</code><ul><li>增加：onServiceAdd</li><li>更新：onServiceUpdate</li><li>删除：onServiceDelete</li></ul></li><li>StorageClass资源变更<ul><li>增加：onStorageClassAdd</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAllEventHandlers is a helper function used in tests and in Scheduler</span></span><br><span class="line"><span class="comment">// to add event handlers for various informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">storageClassInformer storageinformersv1.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">csiNodeInformer storageinformersv1beta1.CSINodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>当集群资源发生变动时，比如service、volume等就会对unschedulableQ中的之前调度失败的pod进行重试，选择将其转移到activeQ或者backoffQ中，这时候会调用<code>MoveAllToActiveQueue</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// There is a chance of errors when adding pods to other queues,</span></span><br><span class="line"><span class="comment">// we make a temporary slice to store the pods,</span></span><br><span class="line"><span class="comment">// since the probability is low, we set its len to 0</span></span><br><span class="line">addErrorPods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">pod := pInfo.Pod</span><br><span class="line"><span class="keyword">if</span> p.isPodBackingOff(pod) &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the scheduling queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.unschedulableQ.clear()</span><br><span class="line"><span class="comment">// Adding pods that we could not move to Active queue or Backoff queue back to the Unschedulable queue</span></span><br><span class="line"><span class="keyword">for</span> _, podInfo := <span class="keyword">range</span> addErrorPods &#123;</span><br><span class="line">p.unschedulableQ.addOrUpdate(podInfo)</span><br><span class="line">&#125;</span><br><span class="line">p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h3><p>那么整个Scheduler是如何跑起来的呢？它的入口是Run函数，一直运行<code>scheduleOne</code>函数，进入一个 <code>control loop</code>，直到收到了StopEverything的信号。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !sched.WaitForCacheSync() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.StopEverything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SchedulingQueue-三级调度队列"><a href="#SchedulingQueue-三级调度队列" class="headerlink" title="SchedulingQueue 三级调度队列"></a>SchedulingQueue 三级调度队列</h2><p><code>SchedulingQueue</code> 是一个Interface，它提供了以下的方法实现对于Pod的入队出队操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SchedulingQueue <span class="keyword">interface</span> &#123;</span><br><span class="line">Add(pod *v1.Pod) error</span><br><span class="line">AddIfNotPresent(pod *v1.Pod) error</span><br><span class="line">AddUnschedulableIfNotPresent(pod *v1.Pod, podSchedulingCycle <span class="keyword">int64</span>) error</span><br><span class="line">SchedulingCycle() <span class="keyword">int64</span></span><br><span class="line">Pop() (*v1.Pod, error)</span><br><span class="line">Update(oldPod, newPod *v1.Pod) error</span><br><span class="line">Delete(pod *v1.Pod) error</span><br><span class="line">MoveAllToActiveQueue()</span><br><span class="line">AssignedPodAdded(pod *v1.Pod)</span><br><span class="line">AssignedPodUpdated(pod *v1.Pod)</span><br><span class="line">NominatedPodsForNode(nodeName <span class="keyword">string</span>) []*v1.Pod</span><br><span class="line">PendingPods() []*v1.Pod</span><br><span class="line">Close()</span><br><span class="line">UpdateNominatedPodForNode(pod *v1.Pod, nodeName <span class="keyword">string</span>)</span><br><span class="line">DeleteNominatedPodIfExists(pod *v1.Pod)</span><br><span class="line">NumUnschedulablePods() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是通过 <code>PriorityQueue</code> 来实现这个queue的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">stop  &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">clock util.Clock</span><br><span class="line">podBackoff *PodBackoffMap</span><br><span class="line"></span><br><span class="line">lock sync.RWMutex</span><br><span class="line">cond sync.Cond</span><br><span class="line"></span><br><span class="line">  activeQ *util.Heap</span><br><span class="line">podBackoffQ *util.Heap</span><br><span class="line">unschedulableQ *UnschedulablePodsMap</span><br><span class="line">nominatedPods *nominatedPodMap</span><br><span class="line">schedulingCycle <span class="keyword">int64</span></span><br><span class="line">moveRequestCycle <span class="keyword">int64</span></span><br><span class="line">closed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的优先级队列是一个三级调度队列，其主要包括：</p><ul><li>活动队列 activeQ：activeQ中存储当前系统中所有正在等待调度的Pod</li><li>不可调度队列 unschedulableQ：当Pod的资源在当前集群中不能被满足时，则会被加入到一个不可调度队列中，然后等待稍后再进行尝试</li><li>backoffQ 队列：backoff机制是并发编程中常见的一种机制，即如果任务反复执行依旧失败，则会按次增长等待调度时间，降低重试效率，从而避免反复失败浪费调度资源。针对调度失败的pod会优先存储在backoff队列中，等待后续重试。</li></ul><p>对于 <code>backoffQ</code> 和 <code>unschedulableQ</code>队列，我们需要定期从其中拿出Pod，放入到activeQ队列。</p><ul><li>每隔1秒执行 <code>flushBackoffQCompleted</code>，去找到backoffQ中等待到期的Pod，将其放入到activeQ中</li><li>每隔30秒执行 <code>flushUnschedulableQLeftover</code>，如果当前时间-pod的最后调度时间大于60s,就重新调度，转移到podBackoffQ或者activeQ中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(p.flushBackoffQCompleted, <span class="number">1.0</span>*time.Second, p.stop)</span><br><span class="line">    <span class="keyword">go</span> wait.Until(p.flushUnschedulableQLeftover, <span class="number">30</span>*time.Second, p.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="三级调度队列" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1578882056126-49b2a324-86dd-455e-b97b-bb9ba54fff5c.png"></p><h3 id="ActiveQ-队列"><a href="#ActiveQ-队列" class="headerlink" title="ActiveQ 队列"></a>ActiveQ 队列</h3><h4 id="当集群有新的Pod的时候"><a href="#当集群有新的Pod的时候" class="headerlink" title="当集群有新的Pod的时候"></a>当集群有新的Pod的时候</h4><p>什么时候会有新的Pod呢？也就是集群资源发生变更的时候：要么是创建了新的Pod，要么增加了PV，改变了Node等资源，导致原来不可调度的Pod可以调度了，这个时候会调用<code>SchedulingQueue.MoveAllToActiveQueue</code>（参见pkg/scheduler/eventhandler.go）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// There is a chance of errors when adding pods to other queues,</span></span><br><span class="line"><span class="comment">// we make a temporary slice to store the pods,</span></span><br><span class="line"><span class="comment">// since the probability is low, we set its len to 0</span></span><br><span class="line">addErrorPods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">pod := pInfo.Pod</span><br><span class="line"><span class="keyword">if</span> p.isPodBackingOff(pod) &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the scheduling queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.unschedulableQ.clear()</span><br><span class="line"><span class="comment">// Adding pods that we could not move to Active queue or Backoff queue back to the Unschedulable queue</span></span><br><span class="line"><span class="keyword">for</span> _, podInfo := <span class="keyword">range</span> addErrorPods &#123;</span><br><span class="line">p.unschedulableQ.addOrUpdate(podInfo)</span><br><span class="line">&#125;</span><br><span class="line">p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，会更新<code>moveRequestCycle</code>参数。</p><p>ActiveQ加入操作干了啥呢？</p><ul><li>会将Pod将入到activeQ，并且从backoffQ和 unschedulableQ中移除当前Pod</li><li>同时广播通知阻塞在Pop操作的scheduler获取新的Pod</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">Add</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">    pInfo := p.newPodInfo(pod)</span><br><span class="line">    <span class="comment">// 加入activeQ</span></span><br><span class="line">    <span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error adding pod %v/%v to the scheduling queue: %v"</span>, pod.Namespace, pod.Name, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从unschedulableQ删除</span></span><br><span class="line">    <span class="keyword">if</span> p.unschedulableQ.get(pod) != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error: pod %v/%v is already in the unschedulable queue."</span>, pod.Namespace, pod.Name)</span><br><span class="line">        p.unschedulableQ.<span class="built_in">delete</span>(pod)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete pod from backoffQ if it is backing off</span></span><br><span class="line">    <span class="comment">// 从podBackoffQ删除</span></span><br><span class="line">    <span class="keyword">if</span> err := p.podBackoffQ.Delete(pInfo); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error: pod %v/%v is already in the podBackoff queue."</span>, pod.Namespace, pod.Name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储pod和被提名的node</span></span><br><span class="line">    p.nominatedPods.add(pod, <span class="string">""</span>)</span><br><span class="line">    p.cond.Broadcast()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当Pod调度失败时"><a href="#当Pod调度失败时" class="headerlink" title="当Pod调度失败时"></a>当Pod调度失败时</h4><p>当调度失败的时候，scheduler会同时调用<code>scheduler&#39;s.Error</code>来调度之前失败的Pod</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">recordSchedulingFailure</span><span class="params">(pod *v1.Pod, err error, reason <span class="keyword">string</span>, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 错误回调</span></span><br><span class="line">    sched.Error(pod, err)</span><br><span class="line">    sched.Recorder.Eventf(pod, <span class="literal">nil</span>, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Scheduling"</span>, message)</span><br><span class="line">    <span class="keyword">if</span> err := sched.PodConditionUpdater.Update(pod, &amp;v1.PodCondition&#123;</span><br><span class="line">        Type:    v1.PodScheduled,</span><br><span class="line">        Status:  v1.ConditionFalse,</span><br><span class="line">        Reason:  reason,</span><br><span class="line">        Message: err.Error(),</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error updating the condition of the pod %s/%s: %v"</span>, pod.Namespace, pod.Name, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个错误处理函数到底干了啥呢？</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, err error)</span></span> &#123;</span><br><span class="line">    podSchedulingCycle := podQueue.SchedulingCycle()</span><br><span class="line">    <span class="comment">// 省略非核心代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//重新放回队列</span></span><br><span class="line">        <span class="keyword">if</span> err := podQueue.AddUnschedulableIfNotPresent(pod, podSchedulingCycle); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个Pod调度失败，一种选择是放入到 <code>backoffQ</code>中，另一种选择是放入到 <code>unschedulableQ</code> 中，到底如何选择呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">AddUnschedulableIfNotPresent</span><span class="params">(pod *v1.Pod, podSchedulingCycle <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Every unschedulable pod is subject to backoff timers.</span></span><br><span class="line">p.backoffPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a move request has been received, move it to the BackoffQ, otherwise move</span></span><br><span class="line"><span class="comment">// it to unschedulableQ.</span></span><br><span class="line"><span class="keyword">if</span> p.moveRequestCycle &gt;= podSchedulingCycle &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.unschedulableQ.addOrUpdate(pInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.nominatedPods.add(pod, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，当一个Pod不能够被调度的时候，它会被放到 unschedulableQ 中，但是如果收到了一个<code>Move Request</code>，那么就将这个Pod移到BackoffQ。这是因为最近集群资源发生了变更，如果放到 BackoffQ，会更快的进行尝试这个Pod，更快地使它得到调度。</p><h3 id="BackoffQ-队列"><a href="#BackoffQ-队列" class="headerlink" title="BackoffQ 队列"></a>BackoffQ 队列</h3><p>BackoffQ是一个堆，每次获取堆顶的元素，查看是否到期，如果到期则将其Pop出来，加入到activeQ中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">flushBackoffQCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 获取堆顶元素</span></span><br><span class="line">        rawPodInfo := p.podBackoffQ.Peek()</span><br><span class="line">        <span class="keyword">if</span> rawPodInfo == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pod := rawPodInfo.(*framework.PodInfo).Pod</span><br><span class="line">        <span class="comment">// 获取到期时间</span></span><br><span class="line">        boTime, found := p.podBackoff.GetBackoffTime(nsNameForPod(pod))</span><br><span class="line">        <span class="keyword">if</span> !found &#123;</span><br><span class="line">            <span class="comment">// 如果当前已经不在podBackoff中，则就pop出来然后放入到activeQ</span></span><br><span class="line">            klog.Errorf(<span class="string">"Unable to find backoff value for pod %v in backoffQ"</span>, nsNameForPod(pod))</span><br><span class="line">            p.podBackoffQ.Pop()</span><br><span class="line">            p.activeQ.Add(rawPodInfo)</span><br><span class="line">            <span class="keyword">defer</span> p.cond.Broadcast()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未超时</span></span><br><span class="line">        <span class="keyword">if</span> boTime.After(p.clock.Now()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超时就pop出来</span></span><br><span class="line">        _, err := p.podBackoffQ.Pop()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(<span class="string">"Unable to pop pod %v from backoffQ despite backoff completion."</span>, nsNameForPod(pod))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入到activeQ中</span></span><br><span class="line">        p.activeQ.Add(rawPodInfo)</span><br><span class="line">        <span class="keyword">defer</span> p.cond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnschedulableQ-队列"><a href="#UnschedulableQ-队列" class="headerlink" title="UnschedulableQ 队列"></a>UnschedulableQ 队列</h3><p>如果当前时间-pod的最后调度时间大于60s，就重新调度，转移到podBackoffQ或者activeQ中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">flushUnschedulableQLeftover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> podsToMove []*framework.PodInfo</span><br><span class="line">    currentTime := p.clock.Now()</span><br><span class="line">    <span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">        lastScheduleTime := pInfo.Timestamp</span><br><span class="line">        <span class="comment">// 如果该pod1分钟内没有被调度就加入到podsToMove</span></span><br><span class="line">        <span class="keyword">if</span> currentTime.Sub(lastScheduleTime) &gt; unschedulableQTimeInterval &#123;</span><br><span class="line">            podsToMove = <span class="built_in">append</span>(podsToMove, pInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(podsToMove) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// podsToMove将这些pod移动到activeQ</span></span><br><span class="line">        p.movePodsToActiveQueue(podsToMove)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NominatedPodMap"><a href="#NominatedPodMap" class="headerlink" title="NominatedPodMap"></a>NominatedPodMap</h3><p>优先级队列有一个<code>nominatedPods</code>用来保存那些被提议运行在特定Nodes上的Pods，其数据结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nominatedPodMap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// nominatedPods is a map keyed by a node name and the value is a list of</span></span><br><span class="line"><span class="comment">// pods which are nominated to run on the node. These are pods which can be in</span></span><br><span class="line"><span class="comment">// the activeQ or unschedulableQ.</span></span><br><span class="line">nominatedPods <span class="keyword">map</span>[<span class="keyword">string</span>][]*v1.Pod</span><br><span class="line"><span class="comment">// nominatedPodToNode is map keyed by a Pod UID to the node name where it is</span></span><br><span class="line"><span class="comment">// nominated.</span></span><br><span class="line">nominatedPodToNode <span class="keyword">map</span>[ktypes.UID]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NextPod"><a href="#NextPod" class="headerlink" title="NextPod()"></a>NextPod()</h3><p>获取下一个Pod的方法，本质上是一个出队操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeNextPodFunc returns a function to retrieve the next pod from a given</span></span><br><span class="line"><span class="comment">// scheduling queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">pod, err := queue.Pop()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">return</span> pod</span><br><span class="line">&#125;</span><br><span class="line">klog.Errorf(<span class="string">"Error while retrieving next pod from scheduling queue: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="Scheduler-Cache"><a href="#Scheduler-Cache" class="headerlink" title="Scheduler Cache"></a>Scheduler Cache</h2><p>为什么需要 Scheduler Cache ? 这里的Cache主要用来收集Pod和Node级别的信息，便于Generic Scheduler在调度时高效的查询。</p><blockquote><p>Cache collects pods’ information and provides node-level aggregated information.</p><p>It’s intended for <strong>generic scheduler</strong> to do efficient lookup.</p></blockquote><p>下面是 <code>schedulerCache</code>结构体的详细定义，关于每个字段的具体含义，将在后面具体阐述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedulerCache <span class="keyword">struct</span> &#123;</span><br><span class="line">stop   &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">ttl    time.Duration</span><br><span class="line">period time.Duration</span><br><span class="line"></span><br><span class="line">mu sync.RWMutex</span><br><span class="line">assumedPods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">podStates <span class="keyword">map</span>[<span class="keyword">string</span>]*podState</span><br><span class="line">nodes     <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeInfoListItem</span><br><span class="line">csiNodes  <span class="keyword">map</span>[<span class="keyword">string</span>]*storagev1beta1.CSINode</span><br><span class="line">headNode *nodeInfoListItem</span><br><span class="line">nodeTree *NodeTree</span><br><span class="line">imageStates <span class="keyword">map</span>[<span class="keyword">string</span>]*imageState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pod-状态"><a href="#Pod-状态" class="headerlink" title="Pod 状态"></a>Pod 状态</h3><p>Cache的操作都是以Pod为中心的，对于每次Pod Events，Cache会做递增式update，下面是Cache的状态机。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> State Machine of a pod's events in scheduler's cache</span><br><span class="line"><span class="string">//</span>   +<span class="params">-------------------------------------------</span>+  +<span class="params">----</span>+</span><br><span class="line"><span class="string">//</span>   |                            Add            |  |    |</span><br><span class="line"><span class="string">//</span>   |                                           |  |    | Update</span><br><span class="line"><span class="string">//</span>   +      Assume                Add            v  v    |</span><br><span class="line"><span class="string">//Initial</span> +<span class="params">--------</span>&gt; Assumed +<span class="params">------------</span>+<span class="params">---</span>&gt; Added &lt;--+</span><br><span class="line"><span class="string">//</span>   ^                +   +               |       +</span><br><span class="line"><span class="string">//</span>   |                |   |               |       |</span><br><span class="line"><span class="string">//</span>   |                |   |           Add |       | Remove</span><br><span class="line"><span class="string">//</span>   |                |   |               |       |</span><br><span class="line"><span class="string">//</span>   |                |   |               +       |</span><br><span class="line"><span class="string">//</span>   +<span class="params">----------------</span>+   +<span class="params">-----------</span>&gt; Expired   +<span class="params">----</span>&gt; Deleted</span><br><span class="line"><span class="string">//</span>         Forget             Expire</span><br></pre></td></tr></table></figure><p>这里有几个Event需要解释</p><ul><li>Assume：assumes a pod scheduled and aggregates the pod’s information into its node</li><li>Forget：removes an assumed pod from cache</li><li>Expire：After expiration, its information would be subtracted</li><li>Add：either confirms a pod if it’s assumed, or adds it back if it’s expired</li><li>Update：removes oldPod’s information and adds newPod’s information</li><li>Remove：removes a pod. The pod’s information would be subtracted from assigned node.</li></ul><p>与此同时还对应有Pod的几种状态，其中 <code>Initial</code>、<code>Expired</code>、<code>Deleted</code>这三种状态的Pod在Cache中实际上是不存在的，这里只是为了状态机的表示方便。关于这几个状态的改变，有一个具体的实现结构体，主要是通过 <code>podState</code> 和 <code>assumedPods</code> 这两个map的状态来实现的。</p><p><img alt="Scheduler Pod Cache State Machine" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_k8s-scheduler-cache.jpg"></p><p>在Cache的调度过程中，我们有以下几个假设</p><ul><li>Pod是不会被Assume两次的</li><li>一个Pod可能会直接被Add而不经过scheduler，这种情况下，我们只会看见Add Event而不会看见Assume Event</li><li>如果一个Pod没有被Add过，那么他不会被Remove或者Update</li><li><code>Expired</code>和<code>Deleted</code>都是有效的最终状态。</li></ul><h3 id="Node-状态"><a href="#Node-状态" class="headerlink" title="Node 状态"></a>Node 状态</h3><p>在Cache中，Node通过双向链表的形式保存信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeInfoListItem <span class="keyword">struct</span> &#123;</span><br><span class="line">info *schedulernodeinfo.NodeInfo</span><br><span class="line">next *nodeInfoListItem</span><br><span class="line">prev *nodeInfoListItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>NodeInfo</code>保存的信息如下所示，包含了和Node相关的一系列信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">node *v1.Node</span><br><span class="line"></span><br><span class="line">pods             []*v1.Pod</span><br><span class="line">podsWithAffinity []*v1.Pod</span><br><span class="line">usedPorts        HostPortInfo</span><br><span class="line"></span><br><span class="line">requestedResource *Resource</span><br><span class="line">nonzeroRequest *Resource</span><br><span class="line">allocatableResource *Resource</span><br><span class="line"></span><br><span class="line">taints    []v1.Taint</span><br><span class="line">taintsErr error</span><br><span class="line"></span><br><span class="line">imageStates <span class="keyword">map</span>[<span class="keyword">string</span>]*ImageStateSummary</span><br><span class="line"></span><br><span class="line">TransientInfo *TransientSchedulerInfo</span><br><span class="line"></span><br><span class="line">memoryPressureCondition v1.ConditionStatus</span><br><span class="line">diskPressureCondition   v1.ConditionStatus</span><br><span class="line">pidPressureCondition    v1.ConditionStatus</span><br><span class="line"></span><br><span class="line">generation <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 <code>schedulerCache</code> 中通过 <code>nodes</code> 这个 map 和 <code>headNode</code>这个指针可以很快的访问Node相关信息。</p><h4 id="NodeInfo-的更新"><a href="#NodeInfo-的更新" class="headerlink" title="NodeInfo 的更新"></a>NodeInfo 的更新</h4><p>当收到informer通知，知道集群Node信息发生改变时，会更新Cache中的Node信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nodeInformer.Informer().AddEventHandler(</span><br><span class="line">cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc:    sched.addNodeToCache,</span><br><span class="line">UpdateFunc: sched.updateNodeInCache,</span><br><span class="line">DeleteFunc: sched.deleteNodeFromCache,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里的<code>add</code>、<code>update</code>、<code>delete</code>会分别调用Cache的 <code>AddNode</code>、<code>UpdateNode</code>和 <code>RemoveNode</code>等函数。以 <code>AddNode</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">AddNode</span><span class="params">(node *v1.Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cache.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line"></span><br><span class="line">n, ok := cache.nodes[node.Name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">n = newNodeInfoListItem(schedulernodeinfo.NewNodeInfo())</span><br><span class="line">cache.nodes[node.Name] = n</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cache.removeNodeImageStates(n.info.Node())</span><br><span class="line">&#125;</span><br><span class="line">cache.moveNodeInfoToHead(node.Name)</span><br><span class="line"></span><br><span class="line">cache.nodeTree.AddNode(node)</span><br><span class="line">cache.addNodeImageStates(node, n.info)</span><br><span class="line"><span class="keyword">return</span> n.info.SetNode(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据需要可以创建新的 NodeInfo 结构体，并且插入到双向链表中。</li><li>每次更新Cache中的Node信息时，会将该Node移动到链表头。</li><li>同时会更新 <code>NodeTree</code> 和 <code>NodeImageStates</code>中的信息。</li></ul><h4 id="NodeTree-实现节点打散"><a href="#NodeTree-实现节点打散" class="headerlink" title="NodeTree 实现节点打散"></a>NodeTree 实现节点打散</h4><p>在Cache中还有一个<code>NodeTree</code>的指针用一个树形结构体保存Node的相关信息，目的是用于节点打散。节点打散主要是指的调度器调度的时候，在满足调度需求的情况下，为了保证pod均匀分配到所有的node节点上，通常会按照逐个zone逐个node节点进行分配，从而让pod节点打散在整个集群中。</p><p><code>NodeTree</code>的结构如下所示，NodeTree的tree是一个字典，key是zone的名字，value是一个nodeArray，通过这样可以把不同zone的Node分隔开。nodeArray负责存储一个zone下面的所有node节点，并且通过lastIndex记录当前zone分配的节点索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeTree <span class="keyword">struct</span> &#123;</span><br><span class="line">tree      <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeArray <span class="comment">// a map from zone (region-zone) to an array of nodes in the zone.</span></span><br><span class="line">zones     []<span class="keyword">string</span>              <span class="comment">// a list of all the zones in the tree (keys)</span></span><br><span class="line">zoneIndex <span class="keyword">int</span></span><br><span class="line">numNodes  <span class="keyword">int</span></span><br><span class="line">mu        sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeArray <span class="keyword">struct</span> &#123;</span><br><span class="line">nodes     []<span class="keyword">string</span></span><br><span class="line">lastIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把整个集群的Node看成二维数组，分别是<code>zoneIndex</code>和<code>nodeIndex</code></p><p><img alt="Scheduler Cache State Machine" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_node-tree.png"></p><p>每一次在 <code>findNodesThatFit</code> 函数中，通过调用 <code>nodeName := g.cache.NodeTree().Next()</code> 来获得下一个检查的Node，其具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nt *NodeTree)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">nt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> nt.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nt.zones) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">numExhaustedZones := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nt.zoneIndex &gt;= <span class="built_in">len</span>(nt.zones) &#123;</span><br><span class="line">nt.zoneIndex = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">zone := nt.zones[nt.zoneIndex]</span><br><span class="line">nt.zoneIndex++</span><br><span class="line"><span class="comment">// We do not check the exhausted zones before calling next() on the zone. This ensures</span></span><br><span class="line"><span class="comment">// that if more nodes are added to a zone after it is exhausted, we iterate over the new nodes.</span></span><br><span class="line">nodeName, exhausted := nt.tree[zone].next()</span><br><span class="line"><span class="keyword">if</span> exhausted &#123;</span><br><span class="line">numExhaustedZones++</span><br><span class="line"><span class="keyword">if</span> numExhaustedZones &gt;= <span class="built_in">len</span>(nt.zones) &#123; <span class="comment">// all zones are exhausted. we should reset.</span></span><br><span class="line">nt.resetExhausted()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nodeName</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次先从当前 <code>zoneIndex</code> 获取新的zone，然后更新 <code>zoneIndex</code>。在对应zone的 <code>NodeArray</code>中，调用其 <code>next</code> 方法，获得对应的Node，同时更新 <code>nodeIndex</code>。</p><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>当scheduler获取一个待调度的pod，则需要从Cache中获取当前集群中的快照数据(当前此时集群中node的统计信息)，用于后续调度流程中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">NodeInfoMap <span class="keyword">map</span>[<span class="keyword">string</span>]*NodeInfo</span><br><span class="line">Generation  <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Snapshot的创建与更新"><a href="#Snapshot的创建与更新" class="headerlink" title="Snapshot的创建与更新"></a>Snapshot的创建与更新</h4><p>创建主要位于kubernetes/pkg/scheduler/core/generic_scheduler.go，实际上就是创建一个空的snapshot对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeInfoSnapshot:         framework.NodeInfoSnapshot(),</span><br></pre></td></tr></table></figure><p>数据的更新则是通过snapshot方法来调用Cache的更新接口来进行更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">snapshot</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Used for all fit and priority funcs.</span></span><br><span class="line">    <span class="keyword">return</span> g.cache.UpdateNodeInfoSnapshot(g.nodeInfoSnapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="借助headNode实现增量标记"><a href="#借助headNode实现增量标记" class="headerlink" title="借助headNode实现增量标记"></a>借助headNode实现增量标记</h4><p>随着集群中node和pod的数量的增加，如果每次都全量获取snapshot则会严重影响调度器的调度效率，在Cache中通过一个双向链表和node的递增计数(etcd实现)来实现增量更新。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">UpdateNodeInfoSnapshot</span><span class="params">(nodeSnapshot *schedulernodeinfo.Snapshot)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cache.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line">    balancedVolumesEnabled := utilfeature.DefaultFeatureGate.Enabled(features.BalanceAttachedNodeVolumes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前snapshot的Genration</span></span><br><span class="line">    snapshotGeneration := nodeSnapshot.Generation</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表，更新snapshot信息</span></span><br><span class="line">    <span class="keyword">for</span> node := cache.headNode; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">        <span class="keyword">if</span> node.info.GetGeneration() &lt;= snapshotGeneration &#123;</span><br><span class="line">            <span class="comment">//所有node信息都更新完毕</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> balancedVolumesEnabled &amp;&amp; node.info.TransientInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Transient scheduler info is reset here.</span></span><br><span class="line">            node.info.TransientInfo.ResetTransientSchedulerInfo()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> np := node.info.Node(); np != <span class="literal">nil</span> &#123;</span><br><span class="line">            nodeSnapshot.NodeInfoMap[np.Name] = node.info.Clone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新snapshot的genration</span></span><br><span class="line">    <span class="keyword">if</span> cache.headNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        nodeSnapshot.Generation = cache.headNode.info.GetGeneration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果snapshot里面包含过期的pod信息则进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodeSnapshot.NodeInfoMap) &gt; <span class="built_in">len</span>(cache.nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> name := <span class="keyword">range</span> nodeSnapshot.NodeInfoMap &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := cache.nodes[name]; !ok &#123;</span><br><span class="line">                <span class="built_in">delete</span>(nodeSnapshot.NodeInfoMap, name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据过期清理"><a href="#数据过期清理" class="headerlink" title="数据过期清理"></a>数据过期清理</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>Cache要定时将之前在经过本地scheduler分配完成后的假设的pod的信息进行清理，如果这些pod在给定时间内仍然没有感知到对应的pod真正的添加事件则就这些pod删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assumedPods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h4 id="后台定时任务"><a href="#后台定时任务" class="headerlink" title="后台定时任务"></a>后台定时任务</h4><p>默认每1s进行清理一次，设定的 <code>ttl</code> 默认是30s。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(cache.cleanupExpiredAssumedPods, cache.period, cache.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清理逻辑"><a href="#清理逻辑" class="headerlink" title="清理逻辑"></a>清理逻辑</h4><p>清理逻辑主要是针对那些已经完成绑定的pod来进行，如果一个pod完成了在scheduler里面的所有操作后，会有一个过期时间，当前是30s，如果超过该时间即deadline小于当前的时间就删除该pod。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cleanupAssumedPods exists for making test deterministic by taking time as input argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">cleanupAssumedPods</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line">    cache.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The size of assumedPods should be small</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> cache.assumedPods &#123;</span><br><span class="line">        ps, ok := cache.podStates[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"Key found in assumed set but not in podStates. Potentially a logical error."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未完成绑定的pod不会被进行清理</span></span><br><span class="line">        <span class="keyword">if</span> !ps.bindingFinished &#123;</span><br><span class="line">            klog.V(<span class="number">3</span>).Infof(<span class="string">"Couldn't expire cache for pod %v/%v. Binding is still in progress."</span>,</span><br><span class="line">                ps.pod.Namespace, ps.pod.Name)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在完成bind之后会设定一个过期时间，目前是30s,如果deadline即bind时间+30s小于当前时间就过期删除</span></span><br><span class="line">        <span class="keyword">if</span> now.After(*ps.deadline) &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Pod %s/%s expired"</span>, ps.pod.Namespace, ps.pod.Name)</span><br><span class="line">            <span class="keyword">if</span> err := cache.expirePod(key, ps); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                klog.Errorf(<span class="string">"ExpirePod failed for %s: %v"</span>, key, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清理pod"><a href="#清理pod" class="headerlink" title="清理pod"></a>清理pod</h4><p>清理pod主要分为如下几个部分： </p><ol><li>对应pod假定分配node的信息 </li><li>清理映射的podState信息</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">expirePod</span><span class="params">(key <span class="keyword">string</span>, ps *podState)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := cache.removePod(ps.pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(cache.assumedPods, key)</span><br><span class="line">    <span class="built_in">delete</span>(cache.podStates, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Predicate-预选"><a href="#Predicate-预选" class="headerlink" title="Predicate 预选"></a>Predicate 预选</h2><p>调度器的目的就是将调度队列中的Pod合理地分配到具有匹配资源的Node上，在<code>Scheduling Framework</code>之前其算法步骤就是预选与优选。预选就是从当前集群中所有节点中，选择满足当前Pod资源和亲和性等要求Node节点，起的是过滤的作用。预选需要考虑的问题是，当集群中Node节点众多时，如何快速高效的过滤出这样的节点。</p><h3 id="Predicate-算法注册"><a href="#Predicate-算法注册" class="headerlink" title="Predicate 算法注册"></a>Predicate 算法注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Register functions that extract metadata used by predicates computations.</span></span><br><span class="line">factory.RegisterPredicateMetadataProducerFactory(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">PredicateMetadataProducer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewPredicateMetadataFactory(args.PodLister)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPORTANT NOTES for predicate developers:</span></span><br><span class="line"><span class="comment">// Registers predicates and priorities that are not enabled by default, but user can pick when creating their</span></span><br><span class="line"><span class="comment">// own set of priorities/predicates.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PodFitsPorts has been replaced by PodFitsHostPorts for better user understanding.</span></span><br><span class="line"><span class="comment">// For backwards compatibility with 1.0, PodFitsPorts is registered as well.</span></span><br><span class="line">factory.RegisterFitPredicate(<span class="string">"PodFitsPorts"</span>, predicates.PodFitsHostPorts)</span><br><span class="line"><span class="comment">// Fit is defined based on the absence of port conflicts.</span></span><br><span class="line"><span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line"><span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.PodFitsHostPortsPred, predicates.PodFitsHostPorts)</span><br><span class="line"><span class="comment">// Fit is determined by resource availability.</span></span><br><span class="line"><span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line"><span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.PodFitsResourcesPred, predicates.PodFitsResources)</span><br><span class="line"><span class="comment">// Fit is determined by the presence of the Host parameter and a string match</span></span><br><span class="line"><span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line"><span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.HostNamePred, predicates.PodFitsHost)</span><br><span class="line"><span class="comment">// Fit is determined by node selector query.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.MatchNodeSelectorPred, predicates.PodMatchNodeSelector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by volume zone requirements.</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.NoVolumeZoneConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewVolumeZonePredicate(args.PVInfo, args.PVCInfo, args.StorageClassInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Fit is determined by whether or not there would be too many AWS EBS volumes attached to the node</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxEBSVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.EBSVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Fit is determined by whether or not there would be too many GCE PD volumes attached to the node</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxGCEPDVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.GCEPDVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Fit is determined by whether or not there would be too many Azure Disk volumes attached to the node</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxAzureDiskVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.AzureDiskVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxCSIVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewCSIMaxVolumeLimitPredicate(args.CSINodeInfo, args.PVInfo, args.PVCInfo, args.StorageClassInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxCinderVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.CinderVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by inter-pod affinity.</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MatchInterPodAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewPodAffinityPredicate(args.NodeInfo, args.PodLister)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by non-conflicting disk volumes.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.NoDiskConflictPred, predicates.NoDiskConflict)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GeneralPredicates are the predicates that are enforced by all Kubernetes components</span></span><br><span class="line"><span class="comment">// (e.g. kubelet and all schedulers)</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.GeneralPred, predicates.GeneralPredicates)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node memory pressure condition.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.CheckNodeMemoryPressurePred, predicates.CheckNodeMemoryPressurePredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node disk pressure condition.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.CheckNodeDiskPressurePred, predicates.CheckNodeDiskPressurePredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node pid pressure condition.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.CheckNodePIDPressurePred, predicates.CheckNodePIDPressurePredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node conditions: not ready, network unavailable or out of disk.</span></span><br><span class="line">factory.RegisterMandatoryFitPredicate(predicates.CheckNodeConditionPred, predicates.CheckNodeConditionPredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined based on whether a pod can tolerate all of the node's taints</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.PodToleratesNodeTaintsPred, predicates.PodToleratesNodeTaints)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by volume topology requirements.</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.CheckVolumeBindingPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewVolumeBindingPredicate(args.VolumeBinder)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部最优"><a href="#局部最优" class="headerlink" title="局部最优"></a>局部最优</h3><p>预选流程需要从当前集群中选择一台符合要求的node。随着集群规模的增长，如果每次遍历所有集群node则会必然导致性能的下降，于是通过局部最优解的方式，缩小筛选节点的数量。具体来说，<code>genericScheduler</code>定义了 <code>minFeasibleNodesToFind</code> 和 <code>minFeasibleNodesPercentageToFind</code>这两个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">minFeasibleNodesToFind = <span class="number">100</span></span><br><span class="line">minFeasibleNodesPercentageToFind = <span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>minFeasibleNodesToFind：定义了在调度阶段参与打分的最小节点数，默认为100。</li><li>minFeasibleNodesPercentageToFind：定义了在调度阶段参与打分的最小百分比，默认为5%。</li></ul><p>通过<code>numFeasibleNodesToFind</code> 函数，结合当前集群中的Node数量，和默认的最小值来决定本次预选阶段需要获取的node节点数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">numFeasibleNodesToFind</span><span class="params">(numAllNodes <span class="keyword">int32</span>)</span> <span class="params">(numNodes <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点数量小于minFeasibleNodesToFind即小于100台node</span></span><br><span class="line">    <span class="comment">// 同理百分比如果大于100就是全量取样</span></span><br><span class="line">    <span class="comment">// 这两种情况都直接遍历整个集群中所有节点</span></span><br><span class="line">    <span class="keyword">if</span> numAllNodes &lt; minFeasibleNodesToFind || g.percentageOfNodesToScore &gt;= <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numAllNodes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedulerapi.DefaultPercentageOfNodesToScore = 50</span></span><br><span class="line">    adaptivePercentage := g.percentageOfNodesToScore</span><br><span class="line">    <span class="keyword">if</span> adaptivePercentage &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        adaptivePercentage = schedulerapi.DefaultPercentageOfNodesToScore - numAllNodes/<span class="number">125</span></span><br><span class="line">        <span class="keyword">if</span> adaptivePercentage &lt; minFeasibleNodesPercentageToFind &#123;</span><br><span class="line">            adaptivePercentage = minFeasibleNodesPercentageToFind</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常取样计算：比如numAllNodes为5000，而adaptivePercentage为50%</span></span><br><span class="line">    <span class="comment">// 则numNodes=50000*0.5/100=250</span></span><br><span class="line">    numNodes = numAllNodes * adaptivePercentage / <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> numNodes &lt; minFeasibleNodesToFind &#123; <span class="comment">// 如果小于最少取样则按照最少取样进行取样</span></span><br><span class="line">        <span class="keyword">return</span> minFeasibleNodesToFind</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行加速"><a href="#并行加速" class="headerlink" title="并行加速"></a>并行加速</h3><p>在当前k8s版本中，默认会启动16个goroutine来进行并行的预选，从而提高预选的性能</p><p>并行取样主要通过调用下面的函数来启动16个goroutine来进行并行取样，并通过ctx来协调退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workqueue.ParallelizeUntil(ctx, <span class="number">16</span>, <span class="keyword">int</span>(allNodes), checkNode)</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-047108dba71d6806c7fed091c15080e8_1440w.jpg"></p><p>通过channel来构建取样索引的管道，每个worker会负责从channel获取的指定索引取样node的填充</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParallelizeUntil</span><span class="params">(ctx context.Context, workers, pieces <span class="keyword">int</span>, doWorkPiece DoWorkPieceFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> ctx != <span class="literal">nil</span> &#123;</span><br><span class="line">        stop = ctx.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成指定数量索引，worker通过索引来进行预选成功节点的存储</span></span><br><span class="line">    toProcess := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, pieces)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pieces; i++ &#123;</span><br><span class="line">        toProcess &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(toProcess)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pieces &lt; workers &#123;</span><br><span class="line">        workers = pieces</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(workers)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">        <span class="comment">// 启动多个goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> piece := <span class="keyword">range</span> toProcess &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//获取索引，后续会通过该索引来进行结果的存储</span></span><br><span class="line">                    doWorkPiece(piece)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待退出</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体每个实际并发执行函数为，它通过在 <code>NodeTree</code> 获取下一个可用的Node，然后调用 <code>podFitsOnNode</code>来检查该Pod是否可以运行在对应的Node上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  nodeName := g.cache.NodeTree().Next()</span><br><span class="line"></span><br><span class="line">  fits, failedPredicates, status, err := g.podFitsOnNode(</span><br><span class="line">    pluginContext,</span><br><span class="line">    pod,</span><br><span class="line">    meta,</span><br><span class="line">    g.nodeInfoSnapshot.NodeInfoMap[nodeName],</span><br><span class="line">    g.predicates,</span><br><span class="line">    g.schedulingQueue,</span><br><span class="line">    g.alwaysCheckAllPredicates,</span><br><span class="line">  )</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两轮筛选"><a href="#两轮筛选" class="headerlink" title="两轮筛选"></a>两轮筛选</h3><p>为了检查一个Pod是否能够运行在给定的Node上，我们通过运行 <code>podFitsOnNode</code>来检查一系列的predicate函数。在这里我们会运行两轮筛选。</p><ul><li>面向未来调度的预选：<ul><li>如果在这个Node上有相同或者更高优先级的<code>Nominated Pods</code>，我们把这些pods加入到meta和nodeInfo中，然后运行predicate算法。之所以考虑更高优先级，是因为当前Pod抢占了低优先级Pod的资源是OK的，但是如果占有了更高优先级资源是不允许的。</li><li>如果在筛选的时候，没有<code>Nominated Pods</code>，或者第一轮筛选中没有通过，那么就不会运行第二轮筛选。</li></ul></li><li>面向当前资源的预选：<ul><li>在这一轮筛选中，如果通过了所有的算法，那么需要在这些pods不加入的情况下，再运行一轮筛选。</li></ul></li></ul><p>第二轮筛选必须存在的原因是，有些预选算法（比如Pod间的亲和性算法）在没有<code>Nominated Pods</code>的条件下可能不会通过筛选。本质上运行两次是一种保守的决策算法。如果我们把<code>nominated pod</code>视作正在运行，那么resource和Pod间anti-affinity算法更有可能失败；如果我们不把<code>nominated pod</code>视作正在运行，那么像pod间的亲和性算法更有可能失败。本质上我们不能假定 <code>Nominated Pods</code> 是否运行，因为它们现在没有运行，而且有可能被调度到另一个Node运行。</p><p>通过两轮筛选在无论那些优先级高的pod是否被调度到当前node上，都可以满足pod的调度需求，在调度的流程中只需要获取之前注册的调度算法，完成预选检测，如果发现有条件不通过则不会进行第二轮筛选，继续选择下一个节点。</p><p><img alt="两轮预选" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579167028012-6daee5fe-ee2d-4821-8650-5eb25a390626.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">podFitsOnNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pluginContext *framework.PluginContext,</span></span></span><br><span class="line"><span class="function"><span class="params">pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">meta predicates.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">info *schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">predicateFuncs <span class="keyword">map</span>[<span class="keyword">string</span>]predicates.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">queue internalqueue.SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">alwaysCheckAllPredicates <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">bool</span>, []predicates.PredicateFailureReason, *framework.Status, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">podsAdded := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">metaToUse := meta</span><br><span class="line">nodeInfoToUse := info</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">podsAdded, metaToUse, nodeInfoToUse = addNominatedPods(pod, meta, info, queue)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !podsAdded || <span class="built_in">len</span>(failedPredicates) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, predicateKey := <span class="keyword">range</span> predicates.Ordering() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(failedPredicates) == <span class="number">0</span> &amp;&amp; status.IsSuccess(), failedPredicates, status, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Priority-优选"><a href="#Priority-优选" class="headerlink" title="Priority 优选"></a>Priority 优选</h2><p>优选阶段主要是对通过了预选过滤的节点按照各种算法打分，打分的结果以 <code>HostPriority</code> 的形式记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostPriority represents the priority of scheduling to a particular host, higher priority is better.</span></span><br><span class="line"><span class="keyword">type</span> HostPriority <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Name of the host</span></span><br><span class="line">Host <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Score associated with the host</span></span><br><span class="line">Score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HostPriorityList declares a []HostPriority type.</span></span><br><span class="line"><span class="keyword">type</span> HostPriorityList []HostPriority</span><br></pre></td></tr></table></figure><p>为了提高优选过程中的计算速度，采用了 <code>Map/Reduce</code> 的方法对计算并行加速，结果存储在一个二维数组中。无锁计算结果的保存主要是通过下面的二维数组实现， 如果要存储一个算法针对某个node的结果，其实只需要通过两个索引即可：算法索引和节点索引。</p><p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579246857471-0d97105c-2a26-4237-bd7d-996e755f0fa1.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在计算的时候，会传入nodes []*v1.Node的数组，存储所有的节点，节点索引主要是指的该部分</span></span><br><span class="line">results := <span class="built_in">make</span>([]schedulerapi.HostPriorityList, <span class="built_in">len</span>(priorityConfigs), <span class="built_in">len</span>(priorityConfigs))</span><br></pre></td></tr></table></figure><h3 id="Priority算法注册"><a href="#Priority算法注册" class="headerlink" title="Priority算法注册"></a>Priority算法注册</h3><p>在优选过程中，每一种策略都以 <code>PriorityConfig</code> 结构表示，具体包含 <code>Map</code> 函数和 <code>Reduce</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Map    PriorityMapFunction</span><br><span class="line">Reduce PriorityReduceFunction</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove it after migrating all functions to</span></span><br><span class="line"><span class="comment">// Map-Reduce pattern.</span></span><br><span class="line">Function PriorityFunction</span><br><span class="line">Weight   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map：输入是(pod, meta, nodeInfo)，输出是该Pod根据该算法在该节点算出的得分</span></span><br><span class="line"><span class="keyword">type</span> PriorityMapFunction <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, meta <span class="keyword">interface</span>&#123;&#125;, nodeInfo *schedulernodeinfo.NodeInfo)</span> <span class="params">(schedulerapi.HostPriority, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce：输入是(pod, meta, map[string]*NodeInfo, result)</span></span><br><span class="line"><span class="keyword">type</span> PriorityReduceFunction <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, meta <span class="keyword">interface</span>&#123;&#125;, nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo, result schedulerapi.HostPriorityList)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>那么，这些算法是在哪里注册的呢？在factory目录下有注册函数，指定算法名和map/reduce函数以及权重，</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/plugins.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterPriorityMapReduceFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">name <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">mapFunction priorities.PriorityMapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">reduceFunction priorities.PriorityReduceFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">weight <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> RegisterPriorityConfigFactory(name, PriorityConfigFactory&#123;</span><br><span class="line">MapReduceFunction: <span class="function"><span class="keyword">func</span><span class="params">(PluginFactoryArgs)</span> <span class="params">(priorities.PriorityMapFunction, priorities.PriorityReduceFunction)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mapFunction, reduceFunction</span><br><span class="line">&#125;,</span><br><span class="line">Weight: weight,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>pkg/scheduler/algorithmprovider/defaults/register_priorities.go</code>中有 <code>init</code>函数来注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Register functions that extract metadata used by priorities computations.</span></span><br><span class="line">factory.RegisterPriorityMetadataProducerFactory(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">priorities</span>.<span class="title">PriorityMetadataProducer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> priorities.NewPriorityMetadataFactory(args.ServiceLister, args.ControllerLister, args.ReplicaSetLister, args.StatefulSetLister)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritize nodes by least requested utilization.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.LeastRequestedPriority, priorities.LeastRequestedPriorityMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritizes nodes to help achieve balanced resource usage</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.BalancedResourceAllocation, priorities.BalancedResourceAllocationMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set this weight large enough to override all other priority functions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Figure out a better way to do this, maybe at same time as fixing #24720.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.NodePreferAvoidPodsPriority, priorities.CalculateNodePreferAvoidPodsPriorityMap, <span class="literal">nil</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritizes nodes that have labels matching NodeAffinity</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.NodeAffinityPriority, priorities.CalculateNodeAffinityPriorityMap, priorities.CalculateNodeAffinityPriorityReduce, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritizes nodes that marked with taint which pod can tolerate.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.TaintTolerationPriority, priorities.ComputeTaintTolerationPriorityMap, priorities.ComputeTaintTolerationPriorityReduce, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageLocalityPriority prioritizes nodes that have images requested by the pod present.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.ImageLocalityPriority, priorities.ImageLocalityPriorityMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对每一个策略进行简单分析。</p><h3 id="基于节点索引的Map计算"><a href="#基于节点索引的Map计算" class="headerlink" title="基于节点索引的Map计算"></a>基于节点索引的Map计算</h3><p>Map算法将Node方向的计算并行化，对于每一个Node，循环计算该Node在各个算法上的得分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">workqueue.ParallelizeUntil(context.TODO(), <span class="number">16</span>, <span class="built_in">len</span>(nodes), <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">nodeInfo := nodeNameToInfo[nodes[index].Name]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line"><span class="keyword">if</span> priorityConfigs[i].Function != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">results[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">appendError(err)</span><br><span class="line">results[i][index].Host = nodes[index].Name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基于算法索引的Reduce计算"><a href="#基于算法索引的Reduce计算" class="headerlink" title="基于算法索引的Reduce计算"></a>基于算法索引的Reduce计算</h3><p>Reduce计算，则是为每个算法的计算都启动一个goroutine，每个goroutine通过算法索引来进行该算法的所有map阶段的结果的读取，并进行计算，后续结果仍然存储在对应的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line"><span class="keyword">if</span> priorityConfigs[i].Reduce == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := priorityConfigs[index].Reduce(pod, meta, nodeNameToInfo, results[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">appendError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> klog.V(<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, hostPriority := <span class="keyword">range</span> results[index] &#123;</span><br><span class="line">klog.Infof(<span class="string">"%v -&gt; %v: %v, Score: (%d)"</span>, util.GetPodFullName(pod), hostPriority.Host, priorityConfigs[index].Name, hostPriority.Score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上优选算法中有 <code>Reduce</code> 函数的并不多，只有 <code>NodeAffinity</code> 和 <code>TaintToleration</code>两个算有有Reduce函数，而且它们实质上都是调用的 <code>NormalizeReduce</code>。本质上就是将之前算出来的得分正则化，使其处于 <code>[0, maxPriority]</code>区间。因此，在Scheduling Framework框架下，这一部分被 <code>Normalize Scoring</code>阶段所取代。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NormalizeReduce</span><span class="params">(maxPriority <span class="keyword">int</span>, reverse <span class="keyword">bool</span>)</span> <span class="title">PriorityReduceFunction</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_ *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">_ <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">_ <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">result schedulerapi.HostPriorityList)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxCount <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="keyword">if</span> result[i].Score &gt; maxCount &#123;</span><br><span class="line">maxCount = result[i].Score</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> maxCount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reverse &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">result[i].Score = maxPriority</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">score := result[i].Score</span><br><span class="line"></span><br><span class="line">score = maxPriority * score / maxCount</span><br><span class="line"><span class="keyword">if</span> reverse &#123;</span><br><span class="line">score = maxPriority - score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result[i].Score = score</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Preempt-抢占"><a href="#Preempt-抢占" class="headerlink" title="Preempt 抢占"></a>Preempt 抢占</h2><p>抢占调度是分布式调度中一种常见的设计，其核心目标是当不能为高优先级的任务分配资源的时候，会通过抢占低优先级的任务来进行高优先级的调度。</p><h3 id="抢占核心流程"><a href="#抢占核心流程" class="headerlink" title="抢占核心流程"></a>抢占核心流程</h3><h3 id="抢占条件检测"><a href="#抢占条件检测" class="headerlink" title="抢占条件检测"></a>抢占条件检测</h3><p>如果发现需要执行抢占的pod有提名的node，并且对应node上面存在比自己优先级低的pod正在进行删除, 则不允许进行抢占。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">podEligibleToPreemptOthers</span><span class="params">(pod *v1.Pod, nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo, enableNonPreempting <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enableNonPreempting &amp;&amp; pod.Spec.PreemptionPolicy != <span class="literal">nil</span> &amp;&amp; *pod.Spec.PreemptionPolicy == v1.PreemptNever &#123;</span><br><span class="line">        klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v/%v is not eligible for preemption because it has a preemptionPolicy of %v"</span>, pod.Namespace, pod.Name, v1.PreemptNever)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    nomNodeName := pod.Status.NominatedNodeName</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nomNodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeInfo, found := nodeNameToInfo[nomNodeName]; found &#123;</span><br><span class="line">            podPriority := util.GetPodPriority(pod)</span><br><span class="line">            <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfo.Pods() &#123;</span><br><span class="line">                <span class="keyword">if</span> p.DeletionTimestamp != <span class="literal">nil</span> &amp;&amp; util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">                    <span class="comment">// 正在终止的优先级低于当前pod的pod就不会进行抢占</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛选潜在节点"><a href="#筛选潜在节点" class="headerlink" title="筛选潜在节点"></a>筛选潜在节点</h3><p>每个node在预选阶段都会进行一个标记，标记当前node执行预选失败的原因，筛选潜在节点主要是根据对应的错误来进行筛选，如果不是不可解决的预选错误，则该node节点就可以参与接下来的抢占阶段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nodesWherePreemptionMightHelp</span><span class="params">(nodes []*v1.Node, fitErr *FitError)</span> []*<span class="title">v1</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line">    potentialNodes := []*v1.Node&#123;&#125;</span><br><span class="line">    <span class="comment">// 根据预选阶段的错误原因，如果不存在无法解决的错误，则这些node可能在接下来的抢占流程中被使用</span></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> fitErr.FilteredNodesStatuses[node.Name].Code() == framework.UnschedulableAndUnresolvable &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        failedPredicates, _ := fitErr.FailedPredicates[node.Name]</span><br><span class="line">        <span class="keyword">if</span> !unresolvablePredicateExists(failedPredicates) &#123; </span><br><span class="line">            <span class="comment">// 如果我们发现并不是不可解决的调度错误的时候，就将这个节点加入到这里</span></span><br><span class="line">            <span class="comment">// 可能通过后续的调整会让这些node重新满足</span></span><br><span class="line">            klog.V(<span class="number">3</span>).Infof(<span class="string">"Node %v is a potential node for preemption."</span>, node.Name)</span><br><span class="line">            potentialNodes = <span class="built_in">append</span>(potentialNodes, node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> potentialNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行筛选节点"><a href="#并行筛选节点" class="headerlink" title="并行筛选节点"></a>并行筛选节点</h3><p>筛选抢占节点主要是并行对之前筛选潜在node进行尝试，通过驱逐低优先级pod满足高优先级pod调度，最终会筛选一批可以通过抢占来满足pod调度需要的节点， 其核心实现时通过selectVictimsOnNode来进行检测。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">selectNodesForPreemption</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    pluginContext *framework.PluginContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    potentialNodes []*v1.Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    fitPredicates <span class="keyword">map</span>[<span class="keyword">string</span>]predicates.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">    metadataProducer predicates.PredicateMetadataProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue internalqueue.SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    pdbs []*policy.PodDisruptionBudget,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims, error)</span></span> &#123;</span><br><span class="line">    nodeToVictims := <span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> resultLock sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can use the same metadata producer for all nodes.</span></span><br><span class="line">    meta := metadataProducer(pod, nodeNameToInfo)</span><br><span class="line">    checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nodeName := potentialNodes[i].Name</span><br><span class="line">        <span class="keyword">var</span> metaCopy predicates.PredicateMetadata</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            metaCopy = meta.ShallowCopy()</span><br><span class="line">        &#125;</span><br><span class="line">        pods, numPDBViolations, fits := g.selectVictimsOnNode(pluginContext, pod, metaCopy, nodeNameToInfo[nodeName], fitPredicates, queue, pdbs)</span><br><span class="line">        <span class="keyword">if</span> fits &#123;</span><br><span class="line">            resultLock.Lock()</span><br><span class="line">            victims := schedulerapi.Victims&#123;</span><br><span class="line">                Pods:             pods,</span><br><span class="line">                NumPDBViolations: numPDBViolations,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeToVictims[potentialNodes[i]] = &amp;victims</span><br><span class="line">            resultLock.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    workqueue.ParallelizeUntil(context.TODO(), <span class="number">16</span>, <span class="built_in">len</span>(potentialNodes), checkNode)</span><br><span class="line">    <span class="keyword">return</span> nodeToVictims, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点筛选节点"><a href="#单点筛选节点" class="headerlink" title="单点筛选节点"></a>单点筛选节点</h3><p><code>selectVictimsOnNode</code>即单点筛选流程是针对单个node来指向具体的驱逐抢占决策的流程, 其核心流程如下</p><p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579429019409-ea29afc8-b17d-410e-8bfc-531b00b49155.png"></p><h4 id="优先级筛选"><a href="#优先级筛选" class="headerlink" title="优先级筛选"></a>优先级筛选</h4><p>优先级筛选首先会对当前node上面的所有节点进行优先级排序，移除所有比当前pod低的pod</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">potentialVictims := util.SortableList&#123;CompFunc: util.MoreImportantPod&#125;</span><br><span class="line">    nodeInfoCopy := nodeInfo.Clone()</span><br><span class="line"></span><br><span class="line">    removePod := <span class="function"><span class="keyword">func</span><span class="params">(rp *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.RemovePod(rp)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.RemovePod(rp, nodeInfoCopy.Node())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addPod := <span class="function"><span class="keyword">func</span><span class="params">(ap *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.AddPod(ap)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.AddPod(ap, nodeInfoCopy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    podPriority := util.GetPodPriority(pod)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfoCopy.Pods() &#123;</span><br><span class="line">        <span class="keyword">if</span> util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">            <span class="comment">// 移除所有优先级比自己低的pod</span></span><br><span class="line">            potentialVictims.Items = <span class="built_in">append</span>(potentialVictims.Items, p)</span><br><span class="line">            removePod(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="预选判断"><a href="#预选判断" class="headerlink" title="预选判断"></a>预选判断</h4><p>对移除所有优先级比自己的pod之后，会尝试进行预选流程，如果发现预选流程失败，则当前node即使通过移除所有比自己优先级低的pod也不能满足调度需求,则就进行下一个node判断</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if fits, _, _, err := g.podFitsOnNode(pluginContext, pod, <span class="keyword">meta</span>, node<span class="literal">Inf</span>oCopy, fitPredicates, queue, <span class="literal">false</span>); !fits &#123;</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Encountered error while selecting victims on node %v: %v"</span>, node<span class="literal">Inf</span>o.<span class="keyword">Node</span><span class="title">().Name</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="PDB分组与分组算法"><a href="#PDB分组与分组算法" class="headerlink" title="PDB分组与分组算法"></a>PDB分组与分组算法</h4><p>PDB分组就是对当前节点上筛选出来的低优先级pod按照是否有PDB匹配来进行分组，分为违反PDB和未违反PDB的两组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">violatingVictims, nonViolatingVictims := filterPodsWithPDBViolation(potentialVictims.Items, pdbs)</span><br></pre></td></tr></table></figure><p>分组算法其实也不难，只需要遍历所有的pdb和pod就可以得到最终的分组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterPodsWithPDBViolation</span><span class="params">(pods []<span class="keyword">interface</span>&#123;&#125;, pdbs []*policy.PodDisruptionBudget)</span> <span class="params">(violatingPods, nonViolatingPods []*v1.Pod)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, obj := <span class="keyword">range</span> pods &#123;</span><br><span class="line">        pod := obj.(*v1.Pod)</span><br><span class="line">        pdbForPodIsViolated := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// A pod with no labels will not match any PDB. So, no need to check.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pod.Labels) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, pdb := <span class="keyword">range</span> pdbs &#123;</span><br><span class="line">                <span class="keyword">if</span> pdb.Namespace != pod.Namespace &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                selector, err := metav1.LabelSelectorAsSelector(pdb.Spec.Selector)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// A PDB with a nil or empty selector matches nothing.</span></span><br><span class="line">                <span class="keyword">if</span> selector.Empty() || !selector.Matches(labels.Set(pod.Labels)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We have found a matching PDB.</span></span><br><span class="line">                <span class="keyword">if</span> pdb.Status.PodDisruptionsAllowed &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                    pdbForPodIsViolated = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pdbForPodIsViolated &#123;</span><br><span class="line">            violatingPods = <span class="built_in">append</span>(violatingPods, pod)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonViolatingPods = <span class="built_in">append</span>(nonViolatingPods, pod)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> violatingPods, nonViolatingPods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="违反PDB计数与最少驱逐汇总"><a href="#违反PDB计数与最少驱逐汇总" class="headerlink" title="违反PDB计数与最少驱逐汇总"></a>违反PDB计数与最少驱逐汇总</h4><p>会分别对违反PDB和不违反的pod集合来进行reprievePod检测，如果加入当前pod后，不能满足预选筛选流程，则该pod则必须被进行移除加入到victims中， 同时如果是违反PDB的pod则需要进行违反pdb计数numViolatingVictim</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">reprievePod := <span class="function"><span class="keyword">func</span><span class="params">(p *v1.Pod)</span> <span class="title">bool</span></span> &#123; </span><br><span class="line">      <span class="comment">// 我们首先将pod加入到meta中</span></span><br><span class="line">      addPod(p)</span><br><span class="line">      fits, _, _, _ := g.podFitsOnNode(pluginContext, pod, meta, nodeInfoCopy, fitPredicates, queue, <span class="literal">false</span>)</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> !fits &#123;</span><br><span class="line">          <span class="comment">// 如果我们加入了pod然后导致了预选不成功，则这个pod必须给移除</span></span><br><span class="line">          removePod(p)</span><br><span class="line">          victims = <span class="built_in">append</span>(victims, p) <span class="comment">// 添加到我们需要移除的列表里面</span></span><br><span class="line">          klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v/%v is a potential preemption victim on node %v."</span>, p.Namespace, p.Name, nodeInfo.Node().Name)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fits</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> violatingVictims &#123;</span><br><span class="line">      <span class="keyword">if</span> !reprievePod(p) &#123;</span><br><span class="line">          numViolatingVictim++</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now we try to reprieve non-violating victims.</span></span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> nonViolatingVictims &#123;</span><br><span class="line">      <span class="comment">// 尝试移除未违反pdb的pod</span></span><br><span class="line">      reprievePod(p)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> victims, numViolatingVictim, <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="筛选最优抢占"><a href="#筛选最优抢占" class="headerlink" title="筛选最优抢占"></a>筛选最优抢占</h3><p>最优筛选主要是通过 <code>pickOneNodeForPreemption</code> 实现，其中筛选数据存储结构主要是通过重用minNodes1和minNodes2两段内存来进行实现，这两个node数组分别配有两个计数器lenNodes1和lenNodes2, 针对具有相同优先级、相同数量的node，每增加一个会进行一次计数器累加， 核心算法流程如下</p><p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579429125998-3ddcaf40-b47c-4234-81bc-fce652fe6f46.png"></p><h4 id="最少违反PDB"><a href="#最少违反PDB" class="headerlink" title="最少违反PDB"></a>最少违反PDB</h4><p>最少违反PDB是根据前面统计的违反PDB的计数统计，找到最少违反的node，如果是单个node则直接返回筛选结束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">minNumPDBViolatingPods := math.MaxInt32</span><br><span class="line"><span class="keyword">var</span> minNodes1 []*v1.Node</span><br><span class="line">lenNodes1 := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> node, victims := <span class="keyword">range</span> nodesToVictims &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(victims.Pods) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发现一个noed不需要任何抢占，则返回它</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    numPDBViolatingPods := victims.NumPDBViolations</span><br><span class="line">    <span class="keyword">if</span> numPDBViolatingPods &lt; minNumPDBViolatingPods &#123; </span><br><span class="line">        <span class="comment">// 如果小于最小pdb数量， 如果数量发生变化，就重置</span></span><br><span class="line">        minNumPDBViolatingPods = numPDBViolatingPods</span><br><span class="line">        minNodes1 = <span class="literal">nil</span></span><br><span class="line">        lenNodes1 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numPDBViolatingPods == minNumPDBViolatingPods &#123; </span><br><span class="line">        <span class="comment">// 多个相同的node会进行追加，并累加计数器 </span></span><br><span class="line">        minNodes1 = <span class="built_in">append</span>(minNodes1, node)</span><br><span class="line">        lenNodes1++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最高优先级最小优先"><a href="#最高优先级最小优先" class="headerlink" title="最高优先级最小优先"></a>最高优先级最小优先</h4><p>最高优先级最小优先是指通过对比多个node的最高优先级的pod，优先级最低的那个node被选中，如果多个则进行下一个算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">minHighestPriority := <span class="keyword">int32</span>(math.MaxInt32)</span><br><span class="line">    <span class="keyword">var</span> minNodes2 = <span class="built_in">make</span>([]*v1.Node, lenNodes1)</span><br><span class="line">    lenNodes2 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">        node := minNodes1[i]</span><br><span class="line">        victims := nodesToVictims[node]</span><br><span class="line">        <span class="comment">// highestPodPriority is the highest priority among the victims on this node.</span></span><br><span class="line">        <span class="comment">// 返回优先级最高的pod</span></span><br><span class="line">        highestPodPriority := util.GetPodPriority(victims.Pods[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> highestPodPriority &lt; minHighestPriority &#123;</span><br><span class="line">            <span class="comment">// 重置状态</span></span><br><span class="line">            minHighestPriority = highestPodPriority</span><br><span class="line">            lenNodes2 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> highestPodPriority == minHighestPriority &#123;</span><br><span class="line">            <span class="comment">// 如果优先级相等则加入进去</span></span><br><span class="line">            minNodes2[lenNodes2] = node</span><br><span class="line">            lenNodes2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="优先级总和最低优先"><a href="#优先级总和最低优先" class="headerlink" title="优先级总和最低优先"></a>优先级总和最低优先</h4><p>统计每个node上的所有被抢占的pod的优先级的总和，然后在多个node之间进行比较，优先级总和最低的节点被选中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">minSumPriorities := <span class="keyword">int64</span>(math.MaxInt64)</span><br><span class="line">    lenNodes1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> sumPriorities <span class="keyword">int64</span></span><br><span class="line">        node := minNodes2[i]</span><br><span class="line">        <span class="comment">// 统计所有优先级</span></span><br><span class="line">        <span class="keyword">for</span> _, pod := <span class="keyword">range</span> nodesToVictims[node].Pods &#123;</span><br><span class="line">            </span><br><span class="line">            sumPriorities += <span class="keyword">int64</span>(util.GetPodPriority(pod)) + <span class="keyword">int64</span>(math.MaxInt32+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities &lt; minSumPriorities &#123;</span><br><span class="line">            minSumPriorities = sumPriorities</span><br><span class="line">            lenNodes1 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities == minSumPriorities &#123;</span><br><span class="line">            minNodes1[lenNodes1] = node</span><br><span class="line">            lenNodes1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最少优先级的node</span></span><br><span class="line">    <span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="最少抢占数量优先"><a href="#最少抢占数量优先" class="headerlink" title="最少抢占数量优先"></a>最少抢占数量优先</h4><p>最少抢占数量优先即统计每个node被抢占的节点数量，数量最少得被选中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">minNumPods := math.MaxInt32</span><br><span class="line">lenNodes2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">    node := minNodes1[i]</span><br><span class="line">    numPods := <span class="built_in">len</span>(nodesToVictims[node].Pods)</span><br><span class="line">    <span class="keyword">if</span> numPods &lt; minNumPods &#123;</span><br><span class="line">        minNumPods = numPods</span><br><span class="line">        lenNodes2 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numPods == minNumPods &#123;</span><br><span class="line">        minNodes2[lenNodes2] = node</span><br><span class="line">        lenNodes2++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最少节点数量</span></span><br><span class="line"><span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最近更新节点优先"><a href="#最近更新节点优先" class="headerlink" title="最近更新节点优先"></a>最近更新节点优先</h4><p>该算法会筛选每个node驱逐的pod中优先级最高的pod的最早更新时间(其实就是说这个pod早就被创建了)，然后在多个node之间进行比较，如果谁上面的时间越新(即这个node上的pod可能是最近被调度上去的)，则就选中这个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">latestStartTime := util.GetEarliestPodStartTime(nodesToVictims[minNodes2[<span class="number">0</span>]])</span><br><span class="line">   <span class="keyword">if</span> latestStartTime == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// If the earliest start time of all pods on the 1st node is nil, just return it,</span></span><br><span class="line">       <span class="comment">// which is not expected to happen.</span></span><br><span class="line">       <span class="comment">// 如果第一个节点上所有pod的最早开始时间为零，那么返回它</span></span><br><span class="line">       klog.Errorf(<span class="string">"earliestStartTime is nil for node %s. Should not reach here."</span>, minNodes2[<span class="number">0</span>])</span><br><span class="line">       <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   nodeToReturn := minNodes2[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">       node := minNodes2[i]</span><br><span class="line">       <span class="comment">// Get earliest start time of all pods on the current node.</span></span><br><span class="line">       <span class="comment">// 获取当前node最早启动时间</span></span><br><span class="line">       earliestStartTimeOnNode := util.GetEarliestPodStartTime(nodesToVictims[node])</span><br><span class="line">       <span class="keyword">if</span> earliestStartTimeOnNode == <span class="literal">nil</span> &#123;</span><br><span class="line">           klog.Errorf(<span class="string">"earliestStartTime is nil for node %s. Should not reach here."</span>, node)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> earliestStartTimeOnNode.After(latestStartTime.Time) &#123;</span><br><span class="line">           latestStartTime = earliestStartTimeOnNode</span><br><span class="line">           nodeToReturn = node</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> nodeToReturn</span><br></pre></td></tr></table></figure><h2 id="Scheduler-Extender"><a href="#Scheduler-Extender" class="headerlink" title="Scheduler Extender"></a>Scheduler Extender</h2><p>社区最初提供的方案是通过 Extender 的形式来扩展 scheduler。Extender 是外部服务，支持 Filter、Preempt、Prioritize 和 Bind 的扩展，scheduler 运行到相应阶段时，通过调用 Extender 注册的 webhook 来运行扩展的逻辑，影响调度流程中各阶段的决策结果。</p><p>以 Filter 阶段举例，执行过程会经过 2 个阶段:</p><p>1、scheduler 会先执行内置的 Filter 策略，如果执行失败的话，会直接标识 Pod 调度失败。<br>2、如果内置的 Filter 策略执行成功的话，scheduler 通过 Http 调用 Extender 注册的 webhook, 将调度所需要的 Pod 和 Node 的信息发送到到 Extender，根据返回 filter 结果，作为最终结果。</p><p><img alt="Scheduler Extender" data-src="https://static001.infoq.cn/resource/image/ba/71/ba41b64474d1afffa4fa44fe7130c071.jpg"></p><p>我们可以发现 Extender 存在以下问题:</p><p>1、调用 Extender 的接口是 HTTP 请求，受到网络环境的影响，性能远低于本地的函数调用。同时每次调用都需要将 Pod 和 Node 的信息进行 marshaling 和 unmarshalling 的操作，会进一步降低性能。<br>2、用户可以扩展的点比较有限，位置比较固定，无法支持灵活的扩展，例如只能在执行完默认的 Filter 策略后才能调用。</p><p>基于以上介绍，Extender 的方式在集群规模较小，调度效率要求不高的情况下，是一个灵活可用的扩展方案，但是在正常生产环境的大型集群中，Extender 无法支持高吞吐量，性能较差。</p><h2 id="Multiple-Schedulers"><a href="#Multiple-Schedulers" class="headerlink" title="Multiple Schedulers"></a>Multiple Schedulers</h2><p>Scheduler 在 Kubernetes 集群中其实类似于一个特殊的 Controller，通过监听 Pod 和 Node 的信息，给 Pod 挑选最佳的节点，更新 Pod 的 spec.NodeName 的信息来将调度结果同步到节点。所以对于部分有特殊的调度需求的用户，有些开发者通过自研 Custom Scheduler 来完成以上的流程，然后通过和 default scheduler 同时部署的方式，来支持自己特殊的调度需求。</p><p><img alt="进击的Kubernetes调度系统（一）：Scheduling Framework" data-src="https://static001.infoq.cn/resource/image/98/de/982345178a76967d014yy05300ca59de.jpg"></p><p>Custom Scheduler 会存在一下问题：</p><p>1、如果与 default scheduler 同时部署，因为每个调度器所看到的资源视图都是全局的，所以在调度决策中可能会在同一时刻在同一个节点资源上调度不同的 Pod，导致节点资源冲突的问题。<br>2、有些用户将调度器所能调度的资源通过 Label 划分不同的池子，可以避免资源冲突的现象出现。但是这样又会导致整体集群资源利用率的下降。<br>3、有些用户选择通过完全自研的方式来替换 default scheduler，这种会带来比较高的研发成本，以及 Kubernetes 版本升级后可能存在的兼容性问题。</p><p>Scheduler Extender 的性能较差可是维护成本较小，Custom Scheduler 的研发和维护的成本特别高但是性能较好，这种情况是开发者面临这种两难处境。这时候 Kubernetes Scheduling Framework V2 横空出世，给我们带来鱼和熊掌可以兼得的方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调度器（Scheduler）是 Kubernetes 的核心组件，它的主要功能是为待运行的工作负载 Pod 绑定运行的节点 Node。从最早基于谓词和优先级（Predicates and Priorities）的调度器，到 V1.15基于调度框架（Scheduling Framework）的调度器，Kubernetes的调度器正在快速演进，以满足不同场景对于资源调度的需求。&lt;/p&gt;
&lt;p&gt;本文是「Kubernetes解读」的第二篇，本篇将首先介绍Kubernetes Scheduler的背景和它的演进过程，然后会通过 Kubernetes 1.16 版本分析基于谓词与优先级的调度器原理。在「Kubernetes解读」的第三篇 &lt;a href=&quot;../83a17de0/&quot;&gt;Scheduling Framework&lt;/a&gt; 中，我将通过 Kubernetes 1.18 版本分析基于Framwork的调度器原理。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-27_k8s-scheduler.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>再出发</title>
    <link href="http://houmin.cc/posts/4987aa35/"/>
    <id>http://houmin.cc/posts/4987aa35/</id>
    <published>2020-07-12T14:59:21.000Z</published>
    <updated>2020-07-20T01:30:36.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。</p><a id="more"></a><h2 id="饮食起居"><a href="#饮食起居" class="headerlink" title="饮食起居"></a>饮食起居</h2><p>这是我整理完毕的工作台，其中购置了墙布用于装饰墙面，购买了可组装的书桌（拼了将近两个小时才拼好），又自己买了ikbc c87的键盘，从姐姐家里带来的蓝牙音响，还有之前买的LAMY钢笔，皮皮送拇指琴，真的是很喜欢很舒适的工作台了。</p><p><img alt="整理完毕的工作台" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-06_settle-down.jpg"></p><p>在上学时曾经期待过工作之后的生活场景，想着是自己每天上能够自己准备早餐，晚上下班后能够自己在家安排自己的生活。但是一周的上班生活马上用现实教育了我，每天早上8.30点出门直接在公司吃早饭，工作到9点半后下班，到家就10点后了，基本上洗漱完后就可以直接睡觉了。做饭这种事情，只能发生在周末了。然而，在入职前我就反了一个错误，一口气买了好多菜，平时也不做，好些都给浪费了。而且，为了简单，平时做的最多的就是面了。不过，不管怎样，总算是开伙了。即使只是在周末下厨，也不能丧失了生活的乐趣了啊，趁这个机会好好学习做菜是一个不错的想法。为此，我特地创建了一个<a href="../../categories/吃顿好的/">「吃顿好的」</a>专栏，用于记录我周末下厨房的菜谱。在后续的工作生涯中，这个专栏会持续更新。</p><h2 id="追光计划"><a href="#追光计划" class="headerlink" title="追光计划"></a>追光计划</h2><p>「追光计划」源自我在微博上看到一个<a href="https://weibo.com/ttarticle/p/show?id=2309404521623347921078" target="_blank" rel="external nofollow noopener noreferrer">摄影师小姐姐</a>为自己在北京最后一段时间留下记录影像的规划，她这样说道</p><blockquote><p>不知道你是否也有过类似的感觉——越是长久的生活在一个城市，反而越少了了解它的冲动。</p><p>就好比在武汉生活的四五年里，我一次都没有去过黄鹤楼，也几乎不去武大。那些外地游客心心念念的美景，本地人好像都因为太过习惯而熟视无睹。</p><p>在北京我也一样。除了故宫外，其他大众或冷门的景点，我鲜少踏足，也很少抓紧特别的天气去拍点什么，总想着：“以后还有机会的”。我拍过很多日出日落，那些绝美的光影，几乎都来自旅途，却独独少了我生活的北京。</p><p>似乎人总是这样，偶尔难得旅行，就总想紧紧抓住异乡风景。会起早贪黑去追逐日出日落，也乐于打卡各种陌生的小众景点。而你生活的地方，却总忘了多看几眼。</p><p>故事的转机发生在我决定离开北京之后。</p></blockquote><p>小姐姐和我有着类似的生活坐标（武汉与北京），直到决定离开北京后才开始意识到好好拍摄北京的风景。我也是一样，本来决定在离校前好好拍摄北大的风光，却也最终没能够实现。在过去的一两周里，我一直在质疑自己，为什么要留在北京呢？在这里呆了都七年了，为什么不换一个地方生活呢？</p><p>想到这里，我给自已一个三年之期：如果在未来三年，我没能够找到留在北京的理由，或者是因为一个人，或者是因为一件事，三年到期之时也许就是我离开北京的日子。不管到时候是否离开，在这三年里，我也有自己的追光计划。我要好好记录在北京的日子，记录那些光影。作为最基本的示例，我开创了一个新的相册，<a href="../../album/知春里知春/">知春里知春</a>，用于记录我在知春里生活的时光。另外，随着追光计划的开展，我也会把那些美丽的景色放到另一个相册，<a href="../../album/Beijing">北京</a> 。</p><h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><p>我职业生涯的正式起点，开启于腾讯云的kubernetes团队。在过去的一周里，我开始阅读kubernetes源码，在阅读的过程中，我越来越感觉到自己积淀的欠缺。不仅是CNCF云原生的生态发展，还有kubernetes本身机制的原理，或者是Go语言的最佳实践，以及Linux操作系统的基础原理，自己都知之甚少。或者说有时候只是知道一些名词，但是对其原理，发展机制都不太了解。</p><p>作为一个工程师，这些技术点是我的立身之本，必须在接下来的一年内能够快速积淀，给自己的职业发展奠定一个扎实的基础。为此，我列出了在接下来两年我要去点亮的技能树，这只是最基础的专业内容。它涉及的范围很广泛，但是要戒骄戒躁，一步一步来。</p><p><img alt="Kubernetes技能树" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-12_kubernetes-skill-map.png"></p><h2 id="运动健身"><a href="#运动健身" class="headerlink" title="运动健身"></a>运动健身</h2><p>在年初的时候，我大言不惭的说：</p><blockquote><p>数据是最重忠实的记录者，每周 3 次跑步，每次 5 公里，期待明年能够达到 700 公里的跑步量。</p></blockquote><p>现在每一次的跑步都是通过Keep记录，翻开Keep，发现上半年的记录只有27公里，真的是完全不达标啊。也许你可以归因于疫情，但是如此懈怠真的太不自律了。下半年开始，发现在公司地下有免费健身房，正好可以每天中午午饭时间去跑一个小时的步。按照下半年25周，每周5次每次5公里的跑步记录，勉强可以达到625公里的目标。如果再加上周末的户外跑步，比如附近的人民大学，海淀黄庄一带，可以大体满足700公里的目标，加油呀！</p><h2 id="阅读观影"><a href="#阅读观影" class="headerlink" title="阅读观影"></a>阅读观影</h2><p>翻了翻豆瓣，上半年的阅读依旧还是颗粒无收。主要还是没有一个Read List，也没有一个阅读规划，匆匆半年过去，一本书也没读过很正常。预计下半年看书还是会很少，更多的看的是专业相关的技术文档的内容。</p><p>至于观影，上半年看了很多金融相关的电影和纪录片，比如大空头等，对金融与市场有了更多的认识。另外，还入坑了「Rick and Morty」，这个系列可以慢慢刷。不知道为什么，现在好像对刷新的剧没有了之前那么大的激情，更多的是看木鱼和电影最Top对电影的讲解，整体开始偏快餐。</p><h2 id="行万里路"><a href="#行万里路" class="headerlink" title="行万里路"></a>行万里路</h2><p>在年初的时候，我给自己计划了两场旅行：</p><ul><li>和家里的春节南国之旅</li><li>和鹏飞的节后湖南之行</li></ul><p>然而这场疫情改变了一切，上半年创造了上大学以后呆在家的最长纪录，从1.19到5.7的一百多天。之后，我去杭州呆了两个月，好好逛了逛杭州，见识了西湖之美。本来计划的毕业旅行也因为一再爆发的疫情而最终取消，残念。</p><p>今年下半年，有意去新疆走一趟，趁着国庆，看看壮美的新疆，期待最终能够成行。作为一个已经毕业的人，除了国庆之外，已经没有了出去玩的机会，想一想真是心酸。不管怎么样，国庆一定要出去走走，可不能浪费这次假期。</p><h2 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h2><p>去年年末给自己定了一个理财的小目标：</p><blockquote><p>给自己定一个小目标，期待自己明年在投资上至少能够有 20 个点的收入，最好能够到 40 个点的收入。</p></blockquote><p>截止到现在，得益于行情好，已经获得了40个点的收益，希望可以在后面半年继续努力：）整体来说，上半年还是偏保守，在2.3春节开盘千股跌停的那天，我几近满仓。然而后面行情低迷是多年不遇的打底没敢全仓进入，只是半仓观望。加上进入资金也不多，最后的收益其实了了。</p><p><img alt="2020上半年收益曲线" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-12_investment.jpg"></p><p>关于理论知识，上半年在疫情期间听了徐高老师的「宏观经济十六讲中国专题」，看了一些炒股的基础知识，但是一直没有落实成文本的形式积淀下来，下半年在空余时间要在落实层面做到更好。毕竟，现在的股票买卖还是没有任何理论依据，选股的原因，买入的时机，抛出的选择都十分无脑，有时候迷之自信，没有任何逻辑。构建自己的交易体系，长路漫漫。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>卡林巴琴停了很久，年初的规划仍在，今天又弹了段「青花瓷」，找回了感觉，下半年的音乐计划继续。</p><p>2020上半年继续单身，工作以后社交状态越发封闭，这段时间先好好调整自己的状态吧，期待在工作上更好的适应，做出自己的成绩。</p><p>这次的半年总结拖了两个星期，工作和生活开始慢慢进入状态，继续加油呀，努力做更好的自己：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-06_sunset.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="个人管理系统" scheme="http://houmin.cc/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="职场" scheme="http://houmin.cc/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="追光计划" scheme="http://houmin.cc/tags/%E8%BF%BD%E5%85%89%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】开篇</title>
    <link href="http://houmin.cc/posts/d8b96fe4/"/>
    <id>http://houmin.cc/posts/d8b96fe4/</id>
    <published>2020-07-07T12:47:00.000Z</published>
    <updated>2020-07-15T06:39:42.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>Kubernetes来源于希腊词汇<a href="https://en.wiktionary.org/wiki/κυβερνήτης" target="_blank" rel="external nofollow noopener noreferrer">κυβερνήτης</a>，意思是<a href="https://en.wikipedia.org/wiki/Helmsman" target="_blank" rel="external nofollow noopener noreferrer">helmsman</a>，也即是舵手的意思，也可引申为<code>pilot</code>或者<code>governor</code>的含义。与此同时，kubernetes也是<a href="https://en.wikipedia.org/wiki/Cybernetics" target="_blank" rel="external nofollow noopener noreferrer">cybernetics</a>的控制系统的意味。随着容器技术的广泛应用，特别是docker的流行，对于容器编排系统的需求导致了kubernetes的出现。docker具有集装箱的意思，而kubernetes就是管理运送集装箱的舵手。</p><p>2014年中，kubernetes首次被宣布，前期的主要开发人员来自于Google的 <a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager" target="_blank" rel="external nofollow noopener noreferrer">Borg</a>)系统，它的发展与设计也深受Borg影响。与Borg采用C++设计不同，kubernetes一开始就采用Go语言实现。</p><p>Kubernetes v1.0 was released on July 21, 2015.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-13" target="_blank" rel="external nofollow noopener noreferrer">[13]</a> Along with the Kubernetes v1.0 release, Google partnered with the <a href="https://en.wikipedia.org/wiki/Linux_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Linux Foundation</a> to form the <a href="https://en.wikipedia.org/wiki/Cloud_Native_Computing_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Cloud Native Computing Foundation</a> (CNCF)<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-14" target="_blank" rel="external nofollow noopener noreferrer">[14]</a> and offered Kubernetes as a seed technology. On March 6, 2018, Kubernetes Project reached ninth place in commits at GitHub, and second place in authors and issues to the <a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="external nofollow noopener noreferrer">Linux kernel</a>.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-15" target="_blank" rel="external nofollow noopener noreferrer">[15]</a></p><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p><p>这是一艘载着一堆集装箱的轮船，轮船在大海上运着集装箱奔波，把集装箱送到它们该去的地方。我们之前其实介绍过一个概念叫做 container，container 这个英文单词也有另外的一个意思就是“集装箱”。Kubernetes 也就借着这个寓意，希望成为运送集装箱的一个轮船，来帮助我们管理这些集装箱，也就是管理这些容器。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/1f/a7/1f5c9e99df79ea86ca5062fef22e21a7.png"></p><h3 id="应用部署演进"><a href="#应用部署演进" class="headerlink" title="应用部署演进"></a>应用部署演进</h3><ul><li>传统部署时代：直接在物理服务器上部署应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。<ul><li>如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。</li><li>一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li></ul></li><li>虚拟化部署时代：引入虚拟化功能，允许在单个物理服务器的 CPU 上运行多个虚拟机（VM）。<ul><li>虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。</li><li>因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。</li><li>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li></ul></li><li>容器化部署时代：容器是轻量级的虚拟化，相对于虚拟机，其具有更多的优势<ul><li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过快速简单的回滚(由于镜像不可变性)，提供可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像，从而将应用程序与基础架构分离。</li><li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li><li>云和操作系统分发的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、Google Kubernetes Engine 和其他任何地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li><li>资源隔离：可预测的应用程序性能。</li><li>资源利用：高效率和高密度。</li></ul></li></ul><p><img alt="Container Evolution" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_container-evolution.svg"></p><p>沿着虚拟化的路径，容器流行后需要有容器编排管理的服务，于是诞生了kubernetes。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><p><strong>服务发现与负载均衡</strong></p><p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>Kubernetes 允许自动挂载选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p><strong>自动二进制打包</strong><br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong><br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 </p></li></ul><h2 id="Kubernetes-Components"><a href="#Kubernetes-Components" class="headerlink" title="Kubernetes Components"></a>Kubernetes Components</h2><p>Kubernetes集群是由众多的Node组成，遵循主从架构，整个Kubernetes集群可以被划分为控制面和控制面管理的众多Node。</p><p><img alt="Kubernetes Components" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_components-of-kubernetes.png"></p><h3 id="Control-Plane-Components"><a href="#Control-Plane-Components" class="headerlink" title="Control Plane Components"></a>Control Plane Components</h3><p>Kubernetes 的控制面负责对集群作出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的Pod）。控制面的组建可以在集群中的任意节点中运行，但是通常会在同一个节点上启动所有控制面的组建，并且这个节点不再运行用户容器，此即称作Master节点。控制面的每一个组件都既可以运行在单master节点，也可以运行在多master节点以实现高可用。</p><p>Master节点包含四个主要的组件：API Server、Controller Manager、Scheduler 以及 Etcd，如下图所示。</p><p><img alt="Control Plane" data-src="https://platform9.com/wp-content/uploads/2019/05/kubernetes-constructs-concepts-architecture.jpg"></p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>kube-apiserver 是 Kubernetes 最重要的核心组件之一，暴露了Kubernetes API，是控制面的前端组件，它主要提供以下的功能：</p><ul><li>提供集群管理的 REST API 接口，实现了认证、授权、准入控制等安全校验功能，同时也负责集群状态的存储操作（通过 etcd）。</li><li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</li></ul><p><img alt="Kube Api Server" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_kube-apiserver.png"></p><p>在实际使用中，通常通过 <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/" target="_blank" rel="external nofollow noopener noreferrer">kubectl</a> 来访问 apiserver，也可以通过 Kubernetes 各个语言的 client 库来访问 apiserver。在使用 kubectl 时，打开调试日志也可以看到每个 API 调用的格式，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --v=8 get pods</span><br></pre></td></tr></table></figure><p>可通过 <code>kubectl api-versions</code> 和 <code>kubectl api-resources</code> 查询 Kubernetes API 支持的 API 版本以及资源对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-versions</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br><span class="line">apiextensions.k8s.io/v1beta1</span><br><span class="line">apiregistration.k8s.io/v1</span><br><span class="line">apiregistration.k8s.io/v1beta1</span><br><span class="line">apps/v1</span><br><span class="line">apps/v1beta1</span><br><span class="line">apps/v1beta2</span><br><span class="line">authentication.k8s.io/v1</span><br><span class="line">authentication.k8s.io/v1beta1</span><br><span class="line">authorization.k8s.io/v1</span><br><span class="line">authorization.k8s.io/v1beta1</span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">batch/v1</span><br><span class="line">batch/v1beta1</span><br><span class="line">certificates.k8s.io/v1beta1</span><br><span class="line">events.k8s.io/v1beta1</span><br><span class="line">extensions/v1beta1</span><br><span class="line">metrics.k8s.io/v1beta1</span><br><span class="line">networking.k8s.io/v1</span><br><span class="line">policy/v1beta1</span><br><span class="line">rbac.authorization.k8s.io/v1</span><br><span class="line">rbac.authorization.k8s.io/v1beta1</span><br><span class="line">scheduling.k8s.io/v1beta1</span><br><span class="line">storage.k8s.io/v1</span><br><span class="line">storage.k8s.io/v1beta1</span><br><span class="line">v1</span><br><span class="line"></span><br><span class="line">$ kubectl api-resources --api-group=storage.k8s.io</span><br><span class="line">NAME                SHORTNAMES   APIGROUP         NAMESPACED   KIND</span><br><span class="line">storageclasses      sc           storage.k8s.io   <span class="literal">false</span>        StorageClass</span><br><span class="line">volumeattachments                storage.k8s.io   <span class="literal">false</span>        VolumeAttachment</span><br></pre></td></tr></table></figure><h4 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h4><p>Etcd是一个分布式的键值数据库，兼具一致性和高可用性，API Server 中所需要的这些原信息都被放置在 etcd 中。Etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。</p><h4 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h4><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p><p><img alt="controller manager" data-src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/controller-manager.png"></p><p>每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。从逻辑上讲，每个<a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="external nofollow noopener noreferrer">控制器</a>都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><p>我们刚刚提到的 API Server，它本身在部署结构上是一个可以水平扩展的一个部署组件；Controller 是一个可以进行热备的一个部署组件，它只有一个 active，它的调度器也是相应的，虽然只有一个 active，但是可以进行热备。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>Scheduler是Master节点上的调度器组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><p>Scheduler在整个系统中起”承上启下”作用：</p><ul><li>承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node</li><li>启下：Node上的kubelet接管Pod的生命周期。</li></ul><p>Scheduler的主要工作：</p><ul><li><p>通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中</p></li><li><p>kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</p><p><img alt="Scheduler" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/scheduler.png"></p></li></ul><p>Scheduler的调度流程：</p><ul><li>预选调度过程，即遍历所有目标Node，筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择</li><li>确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。</li></ul><p>调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。</p><h3 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a><strong>Node Components</strong></h3><p>Kubernetes 的 Node 是真正运行业务负载的，每个业务负载会以 Pod 的形式运行。一个 Pod 中运行的一个或者多个容器，真正去运行这些 Pod 的组件的是叫做 <strong>kubelet</strong>，也就是 Node 上最为关键的组件，它通过 API Server 接收到所需要 Pod 运行的状态，然后提交到 Container Runtime 组件中。</p><p>在 OS 上去创建容器所需要运行的环境，最终把容器或者 Pod 运行起来，也需要对存储跟网络进行管理。Kubernetes 并不会直接进行网络存储的操作，他们会靠 Storage Plugin 或者是网络的 Plugin 来进行操作。用户自己或者云厂商都会去写相应的 <strong>Storage Plugin</strong> 或者 <strong>Network Plugin</strong>，去完成存储操作或网络操作。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/5c/f8/5c9fe50067821e9e86a74cae4cbdd9f8.png"></p><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>Kubelet是Node上的pod管家。在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。</p><h4 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h4><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="external nofollow noopener noreferrer">kube-proxy</a> 是集群中每个节点上运行的网络代理,实现 Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。</p><h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>Container Runtime（容器运行时）是负责容器运行的软件。</p><p>Kubernetes支持几种容器运行时环境：Docker、Containerd、CRI-O等。</p><h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a><strong>Addons</strong></h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>尽管并非严格要求其他附加组件，但所有示例都依赖<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="external nofollow noopener noreferrer">集群 DNS</a>，因此所有 Kubernetes 集群都应具有 DNS。</p><p>除了您环境中的其他 DNS 服务器之外，集群 DNS 还是一个 DNS 服务器，它为 Kubernetes 服务提供 DNS 记录。</p><p>Cluster DNS 是一个 DNS 服务器，和您部署环境中的其他 DNS 服务器一起工作，为 Kubernetes 服务提供DNS记录。</p><p>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中。</p><h4 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h4><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="external nofollow noopener noreferrer">Dashboard</a> 是 Kubernetes 集群的通用基于 Web 的 UI。它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="Container-Resource-Monitoring"><a href="#Container-Resource-Monitoring" class="headerlink" title="Container Resource Monitoring"></a>Container Resource Monitoring</h4><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="external nofollow noopener noreferrer">容器资源监控</a>将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p><h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="external nofollow noopener noreferrer">集群层面日志</a> 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面我们以一个例子再去看一下 Kubernetes 架构中的这些组件，是如何互相进行 interaction 的。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/04/9b/047e4723316d6424b26341de5007329b.png"></p><p>用户可以通过 UI 或者 CLI 提交一个 Pod 给 Kubernetes 进行部署，这个 Pod 请求首先会通过 CLI 或者 UI 提交给 Kubernetes API Server，下一步 API Server 会把这个信息写入到它的存储系统 etcd，之后 Scheduler 会通过 API Server 的 watch 或者叫做 notification 机制得到这个信息：有一个 Pod 需要被调度。</p><p>这个时候 Scheduler 会根据它的内存状态进行一次调度决策，在完成这次调度之后，它会向 API Server report 说：“OK！这个 Pod 需要被调度到某一个节点上。”</p><p>这个时候 API Server 接收到这次操作之后，会把这次的结果再次写到 etcd 中，然后 API Server 会通知相应的节点进行这次 Pod 真正的执行启动。相应节点的 kubelet 会得到这个通知，kubelet 就会去调 Container runtime 来真正去启动配置这个容器和这个容器的运行环境，去调度 Storage Plugin 来去配置存储，network Plugin 去配置网络。</p><p>这个例子我们可以看到：这些组件之间是如何相互沟通相互通信，协调来完成一次 Pod 的调度执行操作的。</p><h2 id="The-Kubernetes-API"><a href="#The-Kubernetes-API" class="headerlink" title="The Kubernetes API"></a>The Kubernetes API</h2><p>Kubernetes API 允许你查询和操作 Kubernetes 集群中对象的状态。Kubernetes集群控制面的核心是 Api Server 以及他暴露的 HTTP API。用户，集群中的其他部分，还有外部组件都是通过API Server进行通信。</p><h3 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h3><p>为了使删除字段或者重构资源表示更加容易，Kubernetes 支持 多个API版本。每一个版本都在不同API路径下，例如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1</code>。</p><p>我们选择在API级别进行版本化，而不是在资源或字段级别进行版本化，以确保API提供清晰，一致的系统资源和行为视图，并控制对已废止的API和/或实验性API的访问。 JSON和Protobuf序列化模式遵循架构更改的相同准则 - 下面的所有描述都同时适用于这两种格式。</p><p>请注意，API版本控制和软件版本控制只有间接相关性。 <a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md" target="_blank" rel="external nofollow noopener noreferrer">API和发行版本建议</a> 描述了API版本与软件版本之间的关系。</p><p>不同的API版本名称意味着不同级别的软件稳定性和支持程度。 每个级别的标准在<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions" target="_blank" rel="external nofollow noopener noreferrer">API变更文档</a>中有更详细的描述。 内容主要概括如下：</p><ul><li>Alpha 测试版本：<ul><li>版本名称包含了 <strong><code>alpha</code></strong> (例如：<strong><code>v1alpha1</code></strong>)。</li><li>可能是有缺陷的。启用该功能可能会带来隐含的问题，默认情况是关闭的。</li><li>支持的功能可能在没有通知的情况下随时删除。</li><li>API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知。</li><li>由于bugs风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</li></ul></li><li>Beta 测试版本：<ul><li>版本名称包含了 <strong><code>beta</code></strong> (例如: <strong><code>v2beta3</code></strong>)。</li><li>代码已经测试过。启用该功能被认为是安全的，功能默认已启用。</li><li>所有已支持的功能不会被删除，细节可能会发生变化。</li><li>对象的模式和/或语义可能会在后续的beta测试版或稳定版中以不兼容的方式进行更改。 发生这种情况时，我们将提供迁移到下一个版本的说明。 这可能需要删除、编辑和重新创建API对象。执行编辑操作时需要谨慎行事，这可能需要停用依赖该功能的应用程序。</li><li>建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。 如果您有多个可以独立升级的集群，则可以放宽此限制。</li><li><strong>请尝试我们的 beta 版本功能并且给出反馈！一旦他们退出 beta 测试版，我们可能不会做出更多的改变。</strong></li></ul></li><li>稳定版本：<ul><li>版本名称是 <strong><code>vX</code></strong>，其中 <strong><code>X</code></strong> 是整数。</li></ul></li></ul><h3 id="API-描述"><a href="#API-描述" class="headerlink" title="API 描述"></a>API 描述</h3><p>下面我们介绍一下 Kubernetes 的 API 的基础知识。从 high-level 上看，Kubernetes API 是由 <strong>HTTP+JSON </strong> 组成的：用户访问的方式是 HTTP，访问的 API 中 content 的内容是 JSON 格式的。</p><p>Kubernetes 的 kubectl 也就是 command tool，Kubernetes UI，或者有时候用 curl，直接与 Kubernetes 进行沟通，都是使用 HTTP + JSON 这种形式。</p><p>下面有个例子：比如说，对于这个 Pod 类型的资源，它的 HTTP 访问的路径，就是 API，然后是 apiVesion: V1, 之后是相应的 Namespaces，以及 Pods 资源，最终是 Podname，也就是 Pod 的名字。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/23/2e/23921b341e482ad31ce28fc15269ad2e.png"></p><p>如果我们去提交一个 Pod，或者 get 一个 Pod 的时候，它的 content 内容都是用 JSON 或者是 YAML 表达的。上图中有个 yaml 的例子，在这个 yaml file 中，对 Pod 资源的描述也分为几个部分。</p><p>第一个部分，一般来讲会是 API 的 <strong>version</strong>。比如在这个例子中是 V1，它也会描述我在操作哪个资源；比如说我的 <strong>kind</strong> 如果是 pod，在 Metadata 中，就写上这个 Pod 的名字；比如说 nginx，我们也会给它打一些 <strong>label</strong>，我们等下会讲到 label 的概念。在 Metadata 中，有时候也会去写 <strong>annotation</strong>，也就是对资源的额外的一些用户层次的描述。</p><h2 id="Kubernetes-Objects"><a href="#Kubernetes-Objects" class="headerlink" title="Kubernetes Objects"></a>Kubernetes Objects</h2><p>Kubernetes对象是Kubernetes集群中持久化的实体，通过这些实体可以代表集群的状态。具体的，它们可以描述以下内容：</p><ul><li>哪些容器化应用在运行（以及在哪个 Node 上）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p><p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>。比如，当使用 <code>kubectl</code> 命令行接口时，CLI 会执行必要的 Kubernetes API 调用，也可以在程序中使用 <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="external nofollow noopener noreferrer">客户端库</a> 直接调用 Kubernetes API。</p><h3 id="Object-Spec-and-Status"><a href="#Object-Spec-and-Status" class="headerlink" title="Object Spec and Status"></a>Object Spec and Status</h3><p>每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象 <em>spec</em> 和 对象 <em>status</em> 。 <em>spec</em> 是必需的，它描述了对象的 <em>期望状态（Desired State）</em> —— 希望对象所具有的特征。 <em>status</em> 描述了对象的 <em>实际状态（Actual State）</em> ，它是由 Kubernetes 系统提供和更新的。在任何时刻，Kubernetes 控制面一直努力地管理着对象的实际状态以与期望状态相匹配。</p><p>例如，Kubernetes Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能需要设置 Deployment 的规约，以指定该应用需要有 3 个副本在运行。 Kubernetes 系统读取 Deployment 规约，并启动我们所期望的该应用的 3 个实例 —— 更新状态以与规约相匹配。 如果那些实例中有失败的（一种状态变更），Kubernetes 系统通过修正来响应规约和状态之间的不一致 —— 这种情况，会启动一个新的实例来替换。</p><p>关于对象 spec、status 和 metadata 的更多信息，查看 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 约定</a>。</p><h3 id="Describing-a-Kubernetes-object"><a href="#Describing-a-Kubernetes-object" class="headerlink" title="Describing a Kubernetes object"></a>Describing a Kubernetes object</h3><p>当创建 Kubernetes 对象时，必须提供对象的Spec，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>），API 请求必须在请求体中包含 JSON 格式的信息。 <strong>大多数情况下，需要在 .yaml 文件中为 <code>kubectl</code> 提供这些信息</strong>。 <code>kubectl</code> 在发起 API 请求时，将这些信息转换成 JSON 格式。</p><p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：</p><figure class="highlight yaml"><figcaption><span>application/deployment.yaml </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="Required-Fields"><a href="#Required-Fields" class="headerlink" title="Required Fields"></a>Required Fields</h3><p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p><ul><li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li><li><code>kind</code> - 想要创建的对象的类型</li><li><code>metadata</code> - 帮助识别对象唯一性的数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li><li><code>spec</code> - 你对该对象期望的状态</li></ul><p>对象 <code>spec</code> 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 参考</a>能够帮助我们找到任何我们想创建的对象的 spec 格式。 例如，可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Pod</code> 的 <code>spec</code> 格式， 并且可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deploymentspec-v1-apps" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Deployment</code> 的 <code>spec</code> 格式。</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是 Kubernetes 应用程序的基本执行单元，是Kubernetes对象模型中创建的最小单元，Pod表示集群是运行的进程。</p><p>用户可以通过 Kubernetes 的 Pod API 生产一个 Pod，让 Kubernetes 对这个 Pod 进行调度，也就是把它放在某一个 Kubernetes 管理的节点上运行起来。一个 Pod 简单来说是对一组容器的抽象，它里面会包含一个或多个容器。</p><p>比如像下面的这幅图里面，它包含了两个容器，每个容器可以指定它所需要资源大小。比如说，一个核一个 G，或者说 0.5 个核，0.5 个 G。</p><p>当然在这个 Pod 中也可以包含一些其他所需要的资源：比如说我们所看到的 Volume 卷这个存储资源；比如说我们需要 100 个 GB 的存储或者 20GB 的另外一个存储。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/b2/9f/b246d174b3169a242ac5799bc962f69f.png"></p><p>在 Pod 里面，我们也可以去定义容器所需要运行的方式。比如说运行容器的 Command，以及运行容器的环境变量等等。Pod 这个抽象也给这些容器提供了一个共享的运行环境，它们会共享同一个网络环境，这些容器可以用 localhost 来进行直接的连接。而 Pod 与 Pod 之间，是互相有 isolation 隔离的。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume 就是卷的概念，它是用来管理 Kubernetes 存储的，是用来声明在 Pod 中的容器可以访问文件目录的，一个卷可以被挂载在 Pod 中一个或者多个容器的指定路径下面。</p><p>而 Volume 本身是一个抽象的概念，一个 Volume 可以去支持多种的后端的存储。比如说 Kubernetes 的 Volume 就支持了很多存储插件，它可以支持本地的存储，可以支持分布式的存储，比如说像 ceph，GlusterFS ；它也可以支持云存储，比如说阿里云上的云盘、AWS 上的云盘、Google 上的云盘等等。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/54/5b/542cf5c317c5e567ba63a720802ae85b.png"></p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 是在 Pod 这个抽象上更为上层的一个抽象，它可以定义一组 Pod 的副本数目、以及这个 Pod 的版本。一般大家用 Deployment 这个抽象来做应用的真正的管理，而 Pod 是组成 Deployment 最小的单元。</p><p>Kubernetes 是通过 Controller，也就是我们刚才提到的控制器去维护 Deployment 中 Pod 的数目，它也会去帮助 Deployment 自动恢复失败的 Pod。</p><p>比如说我可以定义一个 Deployment，这个 Deployment 里面需要两个 Pod，当一个 Pod 失败的时候，控制器就会监测到，它重新把 Deployment 中的 Pod 数目从一个恢复到两个，通过再去新生成一个 Pod。通过控制器，我们也会帮助完成发布的策略。比如说进行滚动升级，进行重新生成的升级，或者进行版本的回滚。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/4e/e2/4ea8feaad09e871bbca804e7f61738e2.png"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 提供了一个或者多个 Pod 实例的稳定访问地址。</p><p>比如在上面的例子中，我们看到：一个 Deployment 可能有两个甚至更多个完全相同的 Pod。对于一个外部的用户来讲，访问哪个 Pod 其实都是一样的，所以它希望做一次负载均衡，在做负载均衡的同时，我只想访问某一个固定的 VIP，也就是 Virtual IP 地址，而不希望得知每一个具体的 Pod 的 IP 地址。</p><p>我们刚才提到，这个 pod 本身可能 terminal go（终止），如果一个 Pod 失败了，可能会换成另外一个新的。</p><p>对一个外部用户来讲，提供了多个具体的 Pod 地址，这个用户要不停地去更新 Pod 地址，当这个 Pod 再失败重启之后，我们希望有一个抽象，把所有 Pod 的访问能力抽象成一个第三方的一个 IP 地址，实现这个的 Kubernetes 的抽象就叫 Service。</p><p>实现 Service 有多种方式，Kubernetes 支持 Cluster IP，上面我们讲过的 kuber-proxy 的组网，它也支持 nodePort、 LoadBalancer 等其他的一些访问的能力。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/bb/4a/bbcd5a617d228099f69ddc987ca18f4a.png"></p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace 是用来做一个集群内部的逻辑隔离的，它包括鉴权、资源管理等。Kubernetes 的每个资源，比如刚才讲的 Pod、Deployment、Service 都属于一个 Namespace，同一个 Namespace 中的资源需要命名的唯一性，不同的 Namespace 中的资源可以重名。</p><p>Namespace 一个用例，比如像在阿里巴巴，我们内部会有很多个 business units，在每一个 business units 之间，希望有一个视图上的隔离，并且在鉴权上也不一样，在 cuda 上面也不一样，我们就会用 Namespace 来去给每一个 BU 提供一个他所看到的这么一个看到的隔离的机制。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/a0/4d/a00719f494ae94a40be0be6012e5134d.png"></p><h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><p>参考 <a href="https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl</span></span><br><span class="line"><span class="comment">## 声明式资源管理</span></span><br><span class="line"><span class="comment"># kubectl apply</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令式资源管理</span></span><br><span class="line"><span class="comment"># kubectl create</span></span><br><span class="line"><span class="comment"># kubectl expose</span></span><br><span class="line"><span class="comment"># kubectl scale</span></span><br><span class="line"><span class="comment"># kubectl annotate</span></span><br><span class="line"><span class="comment"># kubectl label</span></span><br><span class="line"><span class="comment"># kubectl delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl get</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl get [(-o|--output=)](TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags] [options]</span><br><span class="line"><span class="comment"># Examples: </span></span><br><span class="line">kubectl get services                          <span class="comment"># 列出当前NS中所有service资源</span></span><br><span class="line">kubectl get pods --all-namespaces             <span class="comment"># 列出集群所有NS中所有的Pod</span></span><br><span class="line">kubectl get pods -o wide                      <span class="comment"># -o wide也比较常用，可以显示更多资源信息，比如pod的IP等</span></span><br><span class="line">kubectl get deployment my-dep                 <span class="comment"># 可以直接指定资源名查看</span></span><br><span class="line">kubectl get deployment my-dep --watch         <span class="comment"># --watch 参数可以监控资源的状态，在状态变换时输出。在跟踪服务部署情况时很有用</span></span><br><span class="line">kubectl get pod my-pod -o yaml                <span class="comment"># 查看yaml格式的资源配置，这里包括资实际的status，可以用--export排除</span></span><br><span class="line">kubectl get pod my-pod -l app=nginx           <span class="comment"># 查看所有带有标签app: nginx的pod</span></span><br><span class="line"><span class="comment"># kubectl describe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器管理</span></span><br><span class="line"><span class="comment"># kubectl log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl exec</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> POD [-c CONTAINER] -- COMMAND [args...] [options]</span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod ls                         <span class="comment"># 对my-pod执行ls命令</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -t -i nginx-78f5d695bd-czm8z bash <span class="comment"># 进入pod的shell，并打开伪终端和标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl cp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 集群管理</span></span><br><span class="line"><span class="comment"># kubectl cluster-info</span></span><br><span class="line"><span class="comment"># kubectl version</span></span><br><span class="line"><span class="comment"># kubectl cordon/uncordon</span></span><br><span class="line"><span class="comment"># kubectl drain</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_kubernetes.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="CNCF" scheme="http://houmin.cc/tags/CNCF/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="系统设计" scheme="http://houmin.cc/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业快乐</title>
    <link href="http://houmin.cc/posts/959c2cfa/"/>
    <id>http://houmin.cc/posts/959c2cfa/</id>
    <published>2020-07-05T14:58:46.000Z</published>
    <updated>2020-07-20T01:30:36.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。</p><a id="more"></a><h2 id="欢迎回家"><a href="#欢迎回家" class="headerlink" title="欢迎回家"></a>欢迎回家</h2><p>在 7 月 5 日，我得到一次毕业生返校机会，用于打包行李。在此之前，我已经委托 HT 和 CR 帮忙把行李寄了出来，事实上已经没有什么东西需要打包。但是我仍然申请了返校，为的是再以毕业生的身份看一看燕园。在去年冬天，刚开始迷上摄影的我在下雪的燕园拍了好些照片，当时的我还想着要好好利用这最后的半年，多拍一些学校的照片。没想到这次的疫情直接导致了这半年完全不能回来，真的很遗憾了。</p><p><img alt="欢迎回家，半年后再次回到燕园" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_welcome-back.jpg"></p><p>作为 <a href="../c924112f">对比</a>，我在去年冬天拍照的机位再次拍摄了夏天的景色，再见燕园已经是另一幅样子。</p><p><img alt="夏日翠影中的塞万提斯" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_cervantes.jpg"></p><p><img alt="大雅之堂" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_daya.jpg"></p><p><img alt="上次拍的这个视角，正是几个女孩子在这里堆雪人，今天的静园静悄悄的，只有偶尔几个毕业生过来拍照" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_green.jpg"></p><p><img alt="南北阁，夏天的味道" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_south-north.jpg"></p><p><img alt="二体，与冬天下雪时不同，这次回来正下着零星的小雨" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_roof.jpg"></p><p><img alt="夏日未名湖，没有冰场，没有雪花，只有满满的绿色" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_tower.jpg"></p><h2 id="毕业快乐"><a href="#毕业快乐" class="headerlink" title="毕业快乐"></a>毕业快乐</h2><p>2013年8月29日，我和大姐二姐第一次来到燕园，那天还没有正式开学，小雨迷蒙，绕着燕园转了好半天，当时觉得燕园很大，一切都很新，未来充满希望；2020年7月5日，我最后一次以学生的身份回到燕园，同样是小雨淅沥，时隔半年，燕园显得熟悉而又陌生。在2017年的夏天，我已经毕业过一次。只是那一次，从本专业本科保研到对应实验室，毕业的感觉并没有很强烈。但是这一次，是彻底结束了学生生涯，走向社会，走向独立。七年前，我对于未来会如何发展一无所知，不知道自己未来会去向何处；今天，我对于自己想做什么内心大致有了方向，但是不确定性仍然存在。在这七年间，我见到了很多很厉害，很努力，很有趣的同学，他们始终是我前进和奋斗的榜样。我一直会告诉自己，我永远可以变得更好。</p><p>当我坐着自如搬家师傅帮我把好几大箱的行李搬到租住的房间，看着行李我累得完全不想动，我清醒地意识到，从此刻开始，我的学生生涯永远不再。我甚至还不争气的流下了眼泪，仿佛是为了给自己一个正式的道别。毋庸置疑，毕业是人生中的一个重要节点，从社会意义上来讲你完成了你身份的转变。但是毕业真的是那么值得伤感的一件事情吗？看到一些师兄毕业后的生活状态，按照他们的话说，从此成为一名社畜，日常995，还得承受工作的压力。也许这就是现实，但是我还是愿意乐观一点。对我来说，毕业标志着我进入了人生新的一个阶段，你需要在这个阶段去做更有意义、有价值的事情。也许有时候会很辛苦，但是作为一个独立的人，你可以探索更多有意思的事情。</p><p>毕业快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-02_graduation.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="毕业" scheme="http://houmin.cc/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>西湖印象</title>
    <link href="http://houmin.cc/posts/2f653e3b/"/>
    <id>http://houmin.cc/posts/2f653e3b/</id>
    <published>2020-06-20T07:05:47.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。</p><p>这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。</p><a id="more"></a><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><img alt="这天去西湖的时候，天空的云彩特别好看，再加上山峦剪影，很有感觉" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-lake.jpg"></p><p><img alt="在这个地方拍了会延时，发现还是日落那会拍延时更好看，这里镜头应该往前推一点" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-tower.jpg"></p><p><img alt="厨师帽？" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-hat.jpg"></p><h2 id="湖"><a href="#湖" class="headerlink" title="湖"></a>湖</h2><p><img alt="集贤亭，走到这里看到很多大爷专业设备都准备好了，经典取景地" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_pavilion.jpg"></p><p><img alt="不是三潭印月，拍的晚霞时的小亭子" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_tower.jpg"></p><p><img alt="湖边的旅游警察" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_police.jpg"></p><h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p><img alt="湖边喂鸽子的小女孩，这个小男孩正在看着下一张图片的场景" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_dove.jpg"></p><p><img alt="对，一大堆人正在喂着小松鼠，西湖边的松鼠可真多" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_squirrel.jpg"></p><p><img alt="前一天过来转的时候，正好下雨，碰到一对在湖边看风景的情侣，很有感觉" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_lover.jpg"></p><h2 id="霞"><a href="#霞" class="headerlink" title="霞"></a>霞</h2><p>傍晚的时候又拍了会延时，没带三脚架，镜头有一些晃动，下次再弄弄</p><iframe src="//player.bilibili.com/player.html?aid=796036715&bvid=BV1CC4y1a7iw&cid=203569493&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。&lt;/p&gt;
&lt;p&gt;这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_pavilion.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="西湖" scheme="http://houmin.cc/tags/%E8%A5%BF%E6%B9%96/"/>
    
      <category term="杭州" scheme="http://houmin.cc/tags/%E6%9D%AD%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>【普鲁斯特问卷】2020</title>
    <link href="http://houmin.cc/posts/ab5f63d0/"/>
    <id>http://houmin.cc/posts/ab5f63d0/</id>
    <published>2020-05-25T12:23:33.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? </p><p>作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）</p><a id="more"></a><p>话不多说，我们开始。</p><h3 id="你认为最完美的快乐是怎样的？"><a href="#你认为最完美的快乐是怎样的？" class="headerlink" title="你认为最完美的快乐是怎样的？"></a><strong>你认为最完美的快乐是怎样的？</strong></h3><ul><li>做成一件事之后的满足感。</li><li>和好朋友一起无所忌惮的吐槽。</li><li>运动完之后多巴胺分泌的快感。</li></ul><h3 id="你最希望拥有哪种才华？"><a href="#你最希望拥有哪种才华？" class="headerlink" title="你最希望拥有哪种才华？"></a><strong>你最希望拥有哪种才华？</strong></h3><p>羡慕那些拥有绝对音感的人，希望自己能够拥有音乐方面的才华。</p><p>最近在玩卡林巴和尤克里里，记谱对我来说真的是一件困难的事情，心手协调更是需要训练。一直觉得那些音乐创作人是很厉害的存在，自己也想要学乐器词曲，期待有一天能够创作出在音乐上自己的作品。</p><h3 id="你最恐惧的是什么？"><a href="#你最恐惧的是什么？" class="headerlink" title="你最恐惧的是什么？"></a><strong>你最恐惧的是什么？</strong></h3><p>快节奏的都市生活，害怕自己陷入对升职加薪追求的焦虑，而忘了自己到底想要什么。</p><h3 id="你目前的心境怎样？"><a href="#你目前的心境怎样？" class="headerlink" title="你目前的心境怎样？"></a><strong>你目前的心境怎样？</strong></h3><p>现在的我，身处杭州，刚刚提交毕业论文，准备着毕业答辩。将近 20 年的学生生涯即将结束，期待着顺利完成答辩，开始职场的生活。希望能够回到北京，见到那些很久没有见到的朋友。马上就要工作，开始自己独立的生活，希望自己之后的生活忙碌而有节奏，有机会的话也许可以认识我喜欢的人。</p><h3 id="还在世的人中你最钦佩的是谁？"><a href="#还在世的人中你最钦佩的是谁？" class="headerlink" title="还在世的人中你最钦佩的是谁？"></a><strong>还在世的人中你最钦佩的是谁？</strong></h3><p>Linus，开源软件之神。</p><h3 id="你认为自己最伟大的成就是什么？"><a href="#你认为自己最伟大的成就是什么？" class="headerlink" title="你认为自己最伟大的成就是什么？"></a><strong>你认为自己最伟大的成就是什么？</strong></h3><p>距今为止，没有什么伟大的成就。</p><p>希望自己以后能够做出一些有意义，有价值的事情。</p><h3 id="你自己的哪个特点让你最觉得痛恨？"><a href="#你自己的哪个特点让你最觉得痛恨？" class="headerlink" title="你自己的哪个特点让你最觉得痛恨？"></a><strong>你自己的哪个特点让你最觉得痛恨？</strong></h3><p>不够勇敢，不能勇敢地说出自己的喜欢。</p><h3 id="你最喜欢的旅行是哪一次？"><a href="#你最喜欢的旅行是哪一次？" class="headerlink" title="你最喜欢的旅行是哪一次？"></a><strong>你最喜欢的旅行是哪一次？</strong></h3><p>去年找完工作后，<code>Four Sum</code>一起的云南之旅。</p><p>经历了春天的找实习与夏天的找工作，确定完工作去向后，精神一下子放松下来，实验室的四个同学一起说走就走，去了大理和丽江。大理风光很美，苍山洱海，分外惬意；丽江古镇差强人意，玉龙雪山蓝月谷令人惊异。除了美丽的自然风光，主要还是当时四个人都轻松自在，潇洒自得。</p><p>大西南可以去很多次，还有大西北，期望以后有机会可以和自己喜欢的人一起去旅行。</p><h3 id="你最痛恨别人的什么特点？"><a href="#你最痛恨别人的什么特点？" class="headerlink" title="你最痛恨别人的什么特点？"></a><strong>你最痛恨别人的什么特点？</strong></h3><p>虚伪。</p><p>讨厌虚伪的客套，对真诚、聪明、对世界有热情的人自带好感。</p><h3 id="你最珍惜的财产是什么？"><a href="#你最珍惜的财产是什么？" class="headerlink" title="你最珍惜的财产是什么？"></a><strong>你最珍惜的财产是什么？</strong></h3><p>宝贵的时间，自由的灵魂。</p><h3 id="你最奢侈的是什么？"><a href="#你最奢侈的是什么？" class="headerlink" title="你最奢侈的是什么？"></a><strong>你最奢侈的是什么？</strong></h3><p>爱与被爱。</p><h3 id="你认为程度最浅的痛苦是什么？"><a href="#你认为程度最浅的痛苦是什么？" class="headerlink" title="你认为程度最浅的痛苦是什么？"></a><strong>你认为程度最浅的痛苦是什么？</strong></h3><p>不了解万千世界的痛苦。</p><h3 id="你认为哪种美德是被过高的评估的？"><a href="#你认为哪种美德是被过高的评估的？" class="headerlink" title="你认为哪种美德是被过高的评估的？"></a><strong>你认为哪种美德是被过高的评估的？</strong></h3><p>艰苦朴素，无私奉献。</p><p>哪里有那么多的无私，更多的是无奈与不舍。不是很喜欢新闻里面那些对于无私奉献广泛的宣传，我更喜欢那些给这些人优厚的物质与精神回报，并宣传之，比如最近的海尔救人小哥奖房的宣传我就挺喜欢的。</p><h3 id="你最喜欢的职业是什么？"><a href="#你最喜欢的职业是什么？" class="headerlink" title="你最喜欢的职业是什么？"></a><strong>你最喜欢的职业是什么？</strong></h3><p>工程师。</p><p>用自己的双手构建自己的世界。</p><h3 id="你对自己的外表哪一点不满意？"><a href="#你对自己的外表哪一点不满意？" class="headerlink" title="你对自己的外表哪一点不满意？"></a><strong>你对自己的外表哪一点不满意？</strong></h3><p>整体上挺满意的，就是之前脸上的痘痘让我有些烦恼。</p><p>不过，经过最近一段时间的调养，痘痘已经基本消失啦，接下来就是消除痘印了。</p><h3 id="你最后悔的事情是什么？"><a href="#你最后悔的事情是什么？" class="headerlink" title="你最后悔的事情是什么？"></a><strong>你最后悔的事情是什么？</strong></h3><p>做过很多后悔的事情，最后悔的还是与人相关。在不懂事的时候，说过一些令人伤心的话，尤其是对那些爱自己的人。现在想起来那些场景，脸上依然会不由自主的发烫。</p><h3 id="还在世的人中你最鄙视的是谁？"><a href="#还在世的人中你最鄙视的是谁？" class="headerlink" title="还在世的人中你最鄙视的是谁？"></a><strong>还在世的人中你最鄙视的是谁？</strong></h3><p>不太好说鄙视谁，鄙视那些身在其位不谋其政的人。</p><h3 id="你最喜欢男性身上的什么品质？"><a href="#你最喜欢男性身上的什么品质？" class="headerlink" title="你最喜欢男性身上的什么品质？"></a><strong>你最喜欢男性身上的什么品质？</strong></h3><p>大气。</p><p>待人接物落落大方，不卑不亢；处理事情自信沉稳，界限分明；对个人专业熟稔明晰，对不是自己的专业充满好奇心，能够积极主动的去了解；对爱的人温柔体贴，以真心告以真心。</p><h3 id="你使用过的最多的单词或者是词语是什么？"><a href="#你使用过的最多的单词或者是词语是什么？" class="headerlink" title="你使用过的最多的单词或者是词语是什么？"></a><strong>你使用过的最多的单词或者是词语是什么？</strong></h3><p>哈哈哈。</p><h3 id="你最喜欢女性身上的什么品质？"><a href="#你最喜欢女性身上的什么品质？" class="headerlink" title="你最喜欢女性身上的什么品质？"></a><strong>你最喜欢女性身上的什么品质？</strong></h3><p>我最喜欢女性的品质，是温柔与活泼、有自己的思考、善于沟通、具有爱人与被爱的能力。</p><h3 id="你最伤痛的事是什么？"><a href="#你最伤痛的事是什么？" class="headerlink" title="你最伤痛的事是什么？"></a><strong>你最伤痛的事是什么？</strong></h3><p>最伤痛的事情，莫过于全然付出的真心不被对方珍视吧。</p><h3 id="你最看重朋友的什么特点？"><a href="#你最看重朋友的什么特点？" class="headerlink" title="你最看重朋友的什么特点？"></a><strong>你最看重朋友的什么特点？</strong></h3><p>真诚、靠谱、乐观。</p><p>不喜欢虚伪滑头的人，也不喜欢一直悲悲戚戚的人。</p><h3 id="你这一生中最爱的人或东西是什么？"><a href="#你这一生中最爱的人或东西是什么？" class="headerlink" title="你这一生中最爱的人或东西是什么？"></a><strong>你这一生中最爱的人或东西是什么？</strong></h3><p>或许是我自己？</p><p>我希望我自己永远能够变得更好，也希望自己能够给自己爱的人带来更多的欢乐。</p><h3 id="你希望以什么样的方式死去？"><a href="#你希望以什么样的方式死去？" class="headerlink" title="你希望以什么样的方式死去？"></a><strong>你希望以什么样的方式死去？</strong></h3><p>我希望自己能够平平静静的走，就像睡着了那样，不要拖累自己的孩子们，也不要因为化疗等让自己万分痛苦。</p><p>另外，如果年老的时候我心爱的人在我身边时，我希望她能够走在我的前面，不要留她一个人在后面。</p><h3 id="如果你可以改变你的家庭一件事，那会是什么？"><a href="#如果你可以改变你的家庭一件事，那会是什么？" class="headerlink" title="如果你可以改变你的家庭一件事，那会是什么？"></a><strong>如果你可以改变你的家庭一件事，那会是什么？</strong></h3><p>如果可以改变的话，希望小时候爷爷和妈妈的关系能够好一些吧。两个人都很爱我，但是却因为爷爷的一些难以改变的观念，导致他们两人关系一直很差。即使如此，妈妈在爷爷走的时候仍然贴心的照顾他，如果之前关系能够好一些，那么小时候的家庭可以说很完美吧。</p><p>不过这些都是已经过去的事情了，现在家里的孩子都已经长大，爷爷已经离去。虽然不是大富大贵之家，小康家庭倒也过的很好，还记得爸妈为了家里能够过的更好一些而辛苦地工作，朴素的家庭条件也给我们留下了勤恳踏实的作风。</p><h3 id="如果你能选择的话，你希望让什么重现？"><a href="#如果你能选择的话，你希望让什么重现？" class="headerlink" title="如果你能选择的话，你希望让什么重现？"></a><strong>如果你能选择的话，你希望让什么重现？</strong></h3><p>爱。</p><p>现在仍然单身一人，希望能够找到一个自己喜欢，并且她也喜欢我的人。</p><h3 id="你的座右铭是什么？"><a href="#你的座右铭是什么？" class="headerlink" title="你的座右铭是什么？"></a><strong>你的座右铭是什么？</strong></h3><blockquote><p>我将融入剧烈争斗的大人世界，要在那边孤军奋战，必须变得比任何人都坚不可摧。</p></blockquote><p>倒也不是座右铭，一直没有明确的座右铭，只是正好看到这句话比较符合当前的心境罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? &lt;/p&gt;
&lt;p&gt;作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-05-25_proustquestionnaire.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="价值观" scheme="http://houmin.cc/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"/>
    
      <category term="普鲁斯特问卷" scheme="http://houmin.cc/tags/%E6%99%AE%E9%B2%81%E6%96%AF%E7%89%B9%E9%97%AE%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>四月物语</title>
    <link href="http://houmin.cc/posts/43b91bee/"/>
    <id>http://houmin.cc/posts/43b91bee/</id>
    <published>2020-04-25T05:40:59.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。</p>    <div id="aplayer-mlLqGVYM" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="610725" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><p>最近在忙些啥？对，我在写论文，持续处于焦虑状态，期待能够早点写完，具体心情此处不表。夏天真的来了，眼见着窗外的杉树从冬日的灰冷，到春日的嫩绿，到现在的青翠。一转眼，已经在家呆了三个多月，冬日归来，到现在也不知何日返京。每天早上起来，听到窗外清脆的鸟叫声，会觉得这样每天在家的日子也很不错。但是，实际上这些天的状态并不是很好，毕业的焦虑，每天早上翻看着最新疫情的状况，期待着能够早点回到北京，早点回到正常的生活中。</p><p>然而，现实却告诉我，很有可能我们即将面临一种新常态了。在未来的一两年中，新冠可能将会持续潜伏在我们身边。这是一次真正引起全局性改变的疫情。作为毕业生，可以预见，北京应该会在五月份或者六月份让我们回去，可能只是收拾行李，毕业典礼之类的活动很可能都没了，真的是很难得的毕业季。</p><p>所有的这些，对我有什么影响？这些都是我所无力改变的现实，相比于父辈祖辈们所见识过的历史，这些都还只能算是开始。我能够做些什么呢？继续沉淀自己吧，好好的完成毕业论文，继续学习和总结。</p><p>等，春天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。&lt;/p&gt;

    &lt;div id=&quot;aplayer-mlLqGVYM&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;610725&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-25_beyond-the-window.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="春天" scheme="http://houmin.cc/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="新冠" scheme="http://houmin.cc/tags/%E6%96%B0%E5%86%A0/"/>
    
      <category term="新常态" scheme="http://houmin.cc/tags/%E6%96%B0%E5%B8%B8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>【备忘录】播客录</title>
    <link href="http://houmin.cc/posts/d7e805bd/"/>
    <id>http://houmin.cc/posts/d7e805bd/</id>
    <published>2020-04-18T12:30:31.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。</p><a id="more"></a><h2 id="收听工具"><a href="#收听工具" class="headerlink" title="收听工具"></a>收听工具</h2><p>下面是收听 PodCast 常见的一些工具，目前我选用的是 Moon FM。</p><h3 id="Pocket-Casts-全平台的播客老字号"><a href="#Pocket-Casts-全平台的播客老字号" class="headerlink" title="Pocket Casts - 全平台的播客老字号"></a>Pocket Casts - 全平台的播客老字号</h3><p>有条件科学上网、不介意英文界面的朋友，用它绝不会错！</p><p>👍优点：</p><ul><li>目前Android体验第一梯队选手，比较推荐。</li><li>主流的播放功能很全，前进后退30s/变速/跳过空白/人声加强/定时关闭都有，还有比较罕见的手动Skipping Intros，给开头废话比较多的节目用上还挺爽的。</li><li>有数据统计功能，如果作为主力App的话很适合定期回顾做记录。</li><li>全平台可用，即使换了设备也不用转移收听数据。</li><li>设计好看，配色可自选，无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>英文界面，需要爬梯收听。推荐页几乎见不到中文播客。</li></ul><h3 id="Castbox-主攻海外市场的国产播客App"><a href="#Castbox-主攻海外市场的国产播客App" class="headerlink" title="Castbox - 主攻海外市场的国产播客App"></a>Castbox - 主攻海外市场的国产播客App</h3><p>适合有条件科学上网，且不打算用英文App的朋友。</p><p>如果你恰好有多种兴趣，还有查收听数据的习惯，那用它再好不过了！</p><p>👍优点：</p><ul><li>体验第一梯队的选手，比较推荐。</li><li>主流功能很全，除了Skipping Intros，Pocket Casts有的它都有。</li><li>Castbox支持自建多个播放列表，非常适合兴趣纷杂，喜欢在老节目里寻宝的听众。单集添加到播放列表就会自动下载，听完自动删除，顺滑极了。</li><li>可视化的数据统计也是一个亮点。除了收听总时长，还能看到过去一周的每日收听时长</li></ul><p>🤦‍♂️缺点：</p><ul><li>需要爬梯收听。主阵地在海外，所以推荐内容里英文浓度高。页面广告略多。</li></ul><h3 id="Spotify-正版流媒体音乐服务平台"><a href="#Spotify-正版流媒体音乐服务平台" class="headerlink" title="Spotify - 正版流媒体音乐服务平台"></a>Spotify - 正版流媒体音乐服务平台</h3><p>适合正好用Spotify听音乐的朋友，为了听播客而单独下载就不太值。</p><p>👍优点：</p><ul><li>毕竟是老牌音乐App，音频的基本功能它都有。登录后无广告。</li><li>如果你正好会使用Spotify听音乐，那顺带用它听播客就不错。</li></ul><p>🤦‍♂️缺点：</p><h3 id="Moon-FM-全平台的国产播客App"><a href="#Moon-FM-全平台的国产播客App" class="headerlink" title="Moon FM - 全平台的国产播客App"></a>Moon FM - 全平台的国产播客App</h3><p>对App颜值有高要求的朋友请一定试试它！</p><p>👍优点：</p><ul><li>去年新诞生的一个播客App，也是目前中文播客应用的佼佼者，对中文用户很友好。</li><li>页面灵巧又清爽，设计上是费了心的。好看的App提名必须有它。</li><li>有一定的发现功能。基础收听功能虽然比不上老牌应用全面，但变速、睡眠定时都有。</li><li>全平台可用。无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>交互逻辑比较小众，需要接受时间。没有前进后退30s。</li><li>发现功能仅限于精选播客，个性化推荐有待完善。</li></ul><h3 id="海盗电台-快速生长的国产播客App新面孔"><a href="#海盗电台-快速生长的国产播客App新面孔" class="headerlink" title="海盗电台 - 快速生长的国产播客App新面孔"></a>海盗电台 - 快速生长的国产播客App新面孔</h3><ul><li>适合已有一些常听节目的爱好者，给“听”换上更干净纯粹的工具。</li></ul><p>👍优点：</p><ul><li>开发者更新很积极，功能不断完善中，DarkMode也有了。</li><li>基础播放功能不错，除了前进后退30s、变速、睡眠定时，跳过空白的功能也已经有了。</li><li>因为是国产App，所以对中文用户很友好。</li><li>设计简洁舒适。无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>暂无发现功能。一些基本功能也待完善，比如自动下载。</li></ul><h3 id="网易云-播客作为边角料"><a href="#网易云-播客作为边角料" class="headerlink" title="网易云 - 播客作为边角料"></a>网易云 - 播客作为边角料</h3><p>适合正好在用网易云听音乐，且固定只听几个播客节目的朋友。</p><p>👍优点：</p><ul><li>中文播客较全，播客主为了流量几乎都会上传。</li><li>沾了音乐区的光，播客的评论氛围还不错。</li><li>如果正好在用网易云听音乐，就不用多下一个app专门听播客了。</li></ul><p>🤦‍♂️缺点：</p><ul><li>我头一次听播客就是在网易云。当时是iOS的朋友锲而不舍推一档节目给我，而网易云给了我非常便利的起步。但在此之后很久，我都只听那一档播客。</li><li>原因很简单，网易云毕竟主业在音乐，播客作为非常边角的板块，甚至没有推荐功能，发现新节目纯靠搜索，也没有播客app的基础播放功能。</li></ul><h3 id="喜马拉雅-大而全的老牌泛音频平台"><a href="#喜马拉雅-大而全的老牌泛音频平台" class="headerlink" title="喜马拉雅 - 大而全的老牌泛音频平台"></a>喜马拉雅 - 大而全的老牌泛音频平台</h3><p>适合对界面简洁要求不高，希望多多发现中文播客节目的听众。</p><p>👍优点：</p><ul><li>中文播客较全，播客主为了流量几乎都会上传。</li><li>毕竟是老牌音频平台，应该是国产app中基础收听功能最全的，前进后退30s/变速/定时关闭/跳过头尾配齐了。</li><li>推荐功能对中文用户很友好，尤其发现相关播客的功能，对需要扩充收听列表的朋友来说很实用。</li><li>可以顺带听听有声书。</li></ul><p>🤦‍♂️缺点：</p><ul><li>页面真的有点繁杂。</li><li>不像别的平台广告只出现在屏幕上，喜马拉雅的片头片尾是有音频广告的，需要付费去除。</li><li>还有一点有些苛刻了，毕竟是目前播客app的通病：被推荐的来来回回就是几个头部节目，成长中的小众播客很难被发现。</li><li>荔枝、蜻蜓和喜马拉雅的情况非常相近。不再赘述。</li></ul><h2 id="收听栏目"><a href="#收听栏目" class="headerlink" title="收听栏目"></a>收听栏目</h2><p>正在尝试去探索一些比较知名的播客，等过段时间再来反馈。</p><h3 id="GQ-Talk"><a href="#GQ-Talk" class="headerlink" title="GQ Talk"></a>GQ Talk</h3><h3 id="忽左忽右"><a href="#忽左忽右" class="headerlink" title="忽左忽右"></a>忽左忽右</h3><h3 id="得意忘形"><a href="#得意忘形" class="headerlink" title="得意忘形"></a>得意忘形</h3><h3 id="内核恐慌"><a href="#内核恐慌" class="headerlink" title="内核恐慌"></a>内核恐慌</h3><h3 id="日谈公园"><a href="#日谈公园" class="headerlink" title="日谈公园"></a>日谈公园</h3><h3 id="面面相趣"><a href="#面面相趣" class="headerlink" title="面面相趣"></a>面面相趣</h3>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="好奇计划" scheme="http://houmin.cc/categories/%E5%A5%BD%E5%A5%87%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="podcast" scheme="http://houmin.cc/tags/podcast/"/>
    
      <category term="rss" scheme="http://houmin.cc/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>程序员王小波</title>
    <link href="http://houmin.cc/posts/c835f157/"/>
    <id>http://houmin.cc/posts/c835f157/</id>
    <published>2020-04-17T15:12:26.000Z</published>
    <updated>2020-07-14T11:57:25.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十四期，这一期我要聊一聊「王小波」。<code>20200411</code>是王小波逝世 23 周年祭日，我们对他的第一印象是他那奇妙诡谲的小说，是他那汪洋恣肆的杂文，是他和李银河的爱情故事。我依稀记得他写过自己的软件，直到今天我看到<a href="http://91biji.com/social/leon/framebook/notes/note/9174/" target="_blank" rel="external nofollow noopener noreferrer">这个</a>，我开始了对王小波的重新认识。他是一个真正的斜杠青年，比我上次说到的 <a href="https://www.linkedin.com/in/damienriehl" target="_blank" rel="external nofollow noopener noreferrer">Damien Riehl</a> 老哥还要厉害。</p><a id="more"></a><h2 id="斜杠青年"><a href="#斜杠青年" class="headerlink" title="斜杠青年"></a>斜杠青年</h2><p>这是我在维基百科上看到的他的经历：</p><blockquote><ul><li>1952年5月13日出生于北京一个知识分子家庭。</li><li>1968～1970年云南<strong>农场知青</strong>。这段经历成为他最著名的作品《黄金时代》的背景。</li><li>1971～1972年山东牟平插队；后作<strong>民办教师</strong>。</li><li>1972～1973年北京牛街<strong>教学仪器厂工人</strong>。</li><li>1974～1978年北京西城区<strong>半导体厂工人</strong>。工人生活是他《革命时期的爱情》等小说的写作背景。</li><li>1977年与当时在《光明日报》担任编辑的李银河相识相恋，后结合。</li><li>1980年王小波和李银河结婚，同年发表处女作《地久天长》。</li><li>1978～1982年<strong>中国人民大学贸易经济系本科学生</strong>。就读于贸易经济商品学专业。</li><li>1982～1984年中国人民大学一分校教师。开始写作《黄金时代》。</li><li>1984～1988年<strong>美国匹兹堡大学东亚研究中心研究生</strong>，获硕士学位。开始写作以唐传奇为蓝本的小说，其间得到许倬云先生的指点。</li><li>在美留学期间，游历了美国各地，并利用1986年暑假游历了西欧诸国。</li><li>1988～1991年<strong>北京大学社会学系讲师</strong>。</li><li>1991～1992年<strong>中国人民大学会计系讲师</strong>教授统计学。</li><li>1992～1997年自由撰稿人，他的唯一一部电影剧本《东宫西宫》获阿根廷国际电影节<strong>最佳编剧奖</strong>，并且入围1997年戛纳国际电影节。</li><li>1997年4月11日因心脏病逝世于北京。</li></ul></blockquote><p>是的，仅仅只是这些经历，就已经非常惊人了：<code>知青</code>、<code>民办教师</code>、<code>半导体厂工人</code>、<code>经济学</code>、<code>社会学</code>、<code>会计</code>、<code>编剧</code>、<code>小说家</code>。但是，神奇的王小波并不止步于此，看看他自己的描述：</p><blockquote><p>我现在既不是化学家，也不是数学家，更不是物理学家。我靠写文章为生，与科技绝缘——只是有时弄弄计算机。<strong>这个行当我会得不少，从最低等的汇编语言到最新潮的C++全会写，硬件知识也有一些。</strong>但从我自己的利益来看，我还不如一点都不会，省得整夜不睡，鼓捣我的电脑，删东加西，最后把整个系统弄垮，手头又没有软件备份。</p></blockquote><p>是的，他不仅仅在人文社科上作出了很多的成绩，还是一个理科 Geek，精通<strong>统计学</strong>，软硬兼修的程序员。为了写文章，他先是学会了FORTRAN，汇编，C等各种语言，接着又要学习数据结构，算法的相关知识，还有编译原理。在做出了自己的中文编辑器和输入法后，他觉得写软件可以赚钱，写小说同样也可以赚钱。</p><p>这是知乎上的一个评论：</p><blockquote><p>王小波可以算的上是个GEEK。大学学的贸易，后来又学化学，再后来转到了数学系。他的同学形容他解数学题就像杀猪一样，特别来劲，一道一道解决，那感觉可能就像打CS拿人头一样爽。不过解多了也觉得没意思。</p><p> 王小波小说里的男主角基本都是理工男，除了天天意淫还有一些奇怪的想法。其中一些还有自己的发明，比如《未来世界》里的王二是个工程师，整天想着和单位一起研制的永动机，还有《红拂夜奔》里的李靖发明过一个巨大的开跟号机器，在战场上，这台机器运转起来挥舞着杠杆边开跟攻击敌人，有的人死在根号3下，有的人倒在了根号5下。这些都只有GEEK才会想得出来。</p></blockquote><h2 id="程序员时间线"><a href="#程序员时间线" class="headerlink" title="程序员时间线"></a>程序员时间线</h2><p>下面是王小波和他朋友的书信中关于计算机内容的汇总。</p><h3 id="1988-12"><a href="#1988-12" class="headerlink" title="1988.12"></a>1988.12</h3><blockquote><p>回来之前我曾往人大一分校计算机站写过一封信，问他们可要带什么软件，主管的工程师回了封信，我没收到。回来之后人家还提到此事。现在国内软件一面混乱，又逐渐有形成市场之势。首先以年兄学统计这一事实来看，回来做事非有会用的软件不可。<strong>Macintosh根本就没打进中国市场</strong>，你非带几个可用的IBM微机软件回来不可。至于什么机器上能使倒不必太担心。我这个狗屁计算机室，IBMPS/2就有二台。AT机也不少。SAS SPSS Statistx都有，可代表国内上等一般统计微机房的水平，可就是少了一种宜于作统计的语言。年兄如有APL(A Programming Language)之IBM微机本，可给我寄copy来。我在美还有一个户头，连manual复印费一并写支票给你们。Glim我也没有，如年兄有便人可捎来。邮寄太贵，能省就省吧。</p></blockquote><ul><li><strong>Macintosh</strong> 在 1984 年1月24日发布，到 1988 年还没打开市场</li><li>那个时候，王小波用的还是 IBM PS/2 和 IBM PC/AT，AT机1984 年发布，他创造了 PC（Personal Computer）的概念</li><li>SPSS 是 IBM 1984 年推出的统计分析软件，迄今仍在被广泛使用。SAS，Statistx 也同样是那个时代推出的软件。</li><li>APL是哈佛大学的肯尼斯·艾佛于 1962 年设计开发，为此他获得了 1979 年的图灵奖。</li></ul><h3 id="1990-01"><a href="#1990-01" class="headerlink" title="1990.01"></a>1990.01</h3><blockquote><p>我现在正给北大社会学所做统计，手上除<strong>SPSS</strong>没有可用的软件，国内这方面很差。我现在会用<strong>FORTRAN</strong>，编统计程序不方便。闻兄谈起你们用S语言，不知是否好用。工具书也不知好找不。不管好歹，烦兄找个拷贝给我，要就算了。照我看只要能解决各种<strong>矩阵运算</strong>就够：当然也要有各种<strong>分布函数</strong>。反正也是瞎胡混，我就算努把力，少混点吧。</p></blockquote><ul><li>FORTRAN是世界上第一个被正式推广使用的高级语言，1954年被提出来。</li><li>S 语言是贝尔实验室的John Chambers等于1976年共同开发的一种用来进行统计分析的解释型语言，R 语言被认为是S 语言的一个分支。</li></ul><h3 id="1990-05"><a href="#1990-05" class="headerlink" title="1990.05"></a>1990.05</h3><blockquote><p>晓阳到底也加入了IBM的行列。照我看，苹果机还是买不得。因为IBM-PC的兼容机队伍庞大。INTEL又总能推出新一代CPU，将来还有大发展。买微机钱的投资是大事，时间、精力投资更为巨大，买<strong>386兼容机</strong>是明智之举。   我最近可能调入人大，投奔班长。最近胡思乱想想出了个理论来，还没认真推导，大抵是设立多个Dummy(两分变量)构成的<strong>联合分布</strong>，其合计样本点构成一球面，点到点的距离以总误差计算。所以一样本点的对点就是它的否，误差最大。其余的正在想。</p></blockquote><ul><li>1985年，Intel 386 CPU 推出</li><li>1989年，Intel 486 CPU 推出</li></ul><h3 id="1991-02"><a href="#1991-02" class="headerlink" title="1991.02"></a>1991.02</h3><blockquote><p>兄谈及IBM中文软件不可用，估计是图像版有问题，可至有Color Monitor之机器上一试。Mac机国内亦有，唯不及美国多也。</p></blockquote><h3 id="1991-03"><a href="#1991-03" class="headerlink" title="1991.03"></a>1991.03</h3><blockquote><p>你寄来的严氏2.0A我也收到，还没用。因为一者是3盘要倒，二者我自己写的WK也有重大进展。我也自做了词组功能，是棵<strong>B树</strong>，<strong>我觉得自写的软件自用，感觉是最好的</strong>。词组用处不是很大，主要用于定义人地名等专有名词，但是严氏软件对我还是有重大启示，拼音加四声是个极好的主意，写起东西来声韵铿锵，与其他软件大不一样。自写一遍，从分页到编辑键分配，都能合乎自家习惯，不是存心狗尾续貂也。如能见到严氏，可代为致意。</p></blockquote><ul><li>是的，B 树，你没看错，王小波将 B 树用于词组功能</li><li>1991 年就自己开发中文输入法软件，那年雷军刚刚毕业来到北京，认识求伯君</li></ul><h3 id="1991-05"><a href="#1991-05" class="headerlink" title="1991.05"></a>1991.05</h3><blockquote><p>前次寄来软件，上机一试发现<strong>非有浮点处理机</strong>不能运转。因为缺少软件，国内机器一般不装<strong>协处理机</strong>，冷不丁撞出您这一件来，搞得不大有办法。</p><p>闲着没事搞了个发明。原有中文软件是用线扫描方式出汉字。我做了一个用调整字模发生器方法出汉字的系统，自以为很优越，可惜还未找到用户。用此法可以很容易地在西文软件上出中文窗口，还在SPSS上加了几句骂娘的话。</p></blockquote><h3 id="1991-09"><a href="#1991-09" class="headerlink" title="1991.09"></a>1991.09</h3><blockquote><p>晓阳托人带来软件，周转很多日才到手里，软盘有些污损，坏一片烂一套，不可用矣。但是十分感念晓阳的好意。去年托人带来的中文软件(严氏By×)，我用着尚好，而且又用C语言仿编了一个，程序是我的，拼音字典是人家的，执此招摇撞骗，骗了一些钱。干这个事，熟悉了<strong>C语言</strong>，都是拜小阳所赐。</p><p><strong>不过现在我对微机已无兴趣，因为发现写小说也可赚到钱。</strong></p></blockquote><h3 id="1992-01"><a href="#1992-01" class="headerlink" title="1992.01"></a>1992.01</h3><blockquote><p><strong>编译程序</strong>一盘(有说明书，见shou)，<strong>源程序</strong>一盘。我的音典与严氏同名内容不同。功能上与严氏的近似，但是多了改进拼音字典的功能。按F4后可以把拼音重定义。也可加字，在拼音拣字时，按enter，就进入国标拣字，拣到的字加入字典。这个软件由五个c语言(另有两个头文件)和一个汇编语言文件组成，可用<strong>turboc</strong>编译，但是汇编部分不必重汇了，可以把<strong>汇编文件</strong>写成的部分形成的obj(我的磁盘上叫wk5.obj)放到硬盘上，与其它c语言文件分开，用turboc的<code>command line</code>编译器编一下，命令如下:  <code>tcc-mc-ewka:wk*.ca:wk5.obj graphics.lib</code>  形成wk.exe，但是必须有yindian，cclib，egavga.bgi三文件支持才工作。<em>.bgi是图象板参数表，可以包括到</em>.exe内的。但是要改改程序。你的机器好。我还用个老掉牙的XT机，简直落伍了。turbo.c你一定能找到。假如你用过其它c软件，有一点要提醒你，turbo.c有一种极讨厌的特性，就是你在一个函数内<strong>alloc</strong>的内存，退出该函数时不会<strong>自动释放</strong>；还有一点也很糟，就是模型问题，在大模型下写的程序，到了小模型上一概不能用，我的程序是在<strong>compact</strong>模型下写的，就不能用small来编译，这两条是可以气死人的。据说可以用<strong>far，near之类的前缀</strong>说明指针，其实是屁用不管。我干了一年多c，得到的结论是微机c还不能使人快乐，有时叫人怀念汇编。   f1是提示键。我的打印机有汉卡，F5你恐不能用。这个打印机是人家借给我的，性能非常之好，(美国amt-525)；但是不知能用多久。这个程序我还在修改中。与严氏的软件比，在硬的方面的优点是达到了很好的紧凑性，现在编译后是55k，扩展余地大。缺点是图象更新没他的快(在我的老爷机上可以看出区别)，不知他是怎么搞的，我很佩服。<strong>我的图像部分也是汇编写的，反复优化，也达不到他的水平，不得不承认技不如人。</strong>另外，<strong>磁盘文件的处理</strong>，我也写不好。还要请阳公指教。</p></blockquote><ul><li>Turbo C是美国Borland公司1987年推出的一款集成开发环境（IDE）</li></ul><h3 id="1992-07"><a href="#1992-07" class="headerlink" title="1992.07"></a>1992.07</h3><blockquote><p>小阳的信又用MAC机，看来你的机器不少，可喜可贺。<strong>我这一台老PC/ⅩT，用了六年换不下来，太惭愧，近来老想狠狠心，花几百块买个286主板换上，老婆又不同意，真是要命了。</strong>   我自编软件又有进展，把一部分程序<strong>递归化</strong>，出现了很新奇的特征。等我换了286，就需要能<strong>写虚址方式</strong>的C语言了，未知晓阳能否找到？</p></blockquote><h3 id="1992-09"><a href="#1992-09" class="headerlink" title="1992.09"></a>1992.09</h3><blockquote><p>你给我寄的软件因为是三寸盘，在这里很不通用，所以我也没用。盘上有什么，至今不知。我用C编的软件已经用熟，并做出了各种写小说的工具，别人的软件已不用了。现在主要是写书赚钱。从今年初开始写长篇，首先做了写长篇的专用软件，现在基本<strong>调通</strong>，开始写了。</p><p><strong>递归论</strong>我没学过。我哥哥大概懂一些。我和你说的大概是计算机内的<strong>递归算法</strong>。我在美国读的书都是关于机器的。有关<strong>算法</strong>、<strong>数据结</strong>构等等，全在国内看的，也不知英文叫什么。在C语言里是指在一个函数(相当于其他语言的subprocedure)内调用同一个函数。一般程序书里都能查到。   所谓保护方式，是指<strong>286 protected mode</strong>。因为一般的IBM机器，不管是386，486，只要是<strong>dos操作系统</strong>，实际能操作的内存只是640K，相当于一个较快的PC机。想要用到640K以外的<strong>extend memory</strong>，只有用protect mode才能用上，我打算换286，还是想用多于640K的内存。这就要有比现在的C更好的编程工具。当然，我也不一定要用到保护方式，有各种EMS软件，不过我还是想往多里捞摸，多留一手。MSC我只见过5.0版，7.0版的性能还不知道。不过我猜现在流行的C应该有这些手段，到这时候了。   我有一段时间很关心<strong>personal computer</strong>的发展，属于想玩玩不到过干瘾的那种。这路东西的发展都是由处理机片芯的发展开始。从8088到286，386看文献就知道快了很多。从实用的角度来看，286多了虚存保护，386又多了很<strong>多用户多任务</strong>手段。<strong>486据说把386，387，和64K的高速缓存集成到一个片子上，不但整数运算快，浮点也快多了。不过不做科学运算，意义就小了。</strong>586还不知道是个什么东西，想必有惊人之处。不过到了我手上用作文字处理，也是暴殄天物。我有个286用用就算行了。太好的东西我也使不出来。   听说美国微机多媒体搞得甚火，微机接电视，音响，video等等。这玩艺听上去倒是蛮有意思的。</p></blockquote><ul><li>微软的windows 95直到1995年发布以后，才成为了真正意义上的图形界面的操作系统，有了图形用户界面</li><li>Linux 的第一个版本在 1991 年发布</li><li>王小波那年用的还是 DOS 操作系统</li></ul><h3 id="1992-10"><a href="#1992-10" class="headerlink" title="1992.10"></a>1992.10</h3><blockquote><p>当时不知道你为什么这么干，原来是机器坏了。居然叫人敲去150dollars，老兄真是有钱。这种事叫我遇上，肯定自己修了。<strong>现在的微机修理都是换线换板，机器一坏，先找块表量量是不是电源坏了。</strong>只要不是电源坏，估摸是哪部分不好，就去买块版换上。送出去也是这么修，还要敲你手工钱。我看150什么板子都能买来。万一自己故障没找对，就说人家的板子不好，退给他。我的机器里什么牌子的板子都有了，都像你那样挨人敲，还玩得起吗？这么弄，还能有点乐趣。比方说，你爱486，就去买块486主机板，把自己的主机板换下来，这种搞法不怕杂牌水货，坏了再换，反正便宜。我的问题在于这么搞都搞不起。</p><p>我现在从我哥哥那里弄了一套<strong>TurboC++</strong>，软件方面暂时没有问题了。只是286还没买，因为听说中国要加入<strong>关贸总协定</strong>，这类东西要掉价；有钱先买家具。无论如何，我是用不到486的，因为要286也不是为了追求高速度，主要是要解决内存问题。<strong>我现在软件写得出神入化，大概8088上能做到的一切，我都做到了</strong>。自己觉得该告一段落，去写小说了。</p></blockquote><ul><li>是的，王小波对计算机硬件也有很多了解</li><li>C++ 90 年代才有了第一次标准化，王小波 92 年开始玩 C++了。</li></ul><h3 id="1992-11"><a href="#1992-11" class="headerlink" title="1992.11"></a>1992.11</h3><blockquote><p>先有朋友把你寄来的软盘倒了一下，看看是数字，就没动它。记得原来有一套干这种事的软件，是你给的，但是盘坏过，再也找不到了。今天写了个小程序倒出来，拜读了大作，甚是有趣。</p></blockquote><h3 id="1993-03"><a href="#1993-03" class="headerlink" title="1993.03"></a>1993.03</h3><blockquote><p>我终于下决心买了一台286，这些日子在改造软件，作了不少汇编工作。其核心是它在<strong>虚拟保护方式(virtual address protected)</strong>下工作，以便利<strong>扩展内存(expanded memory)</strong>。现在终于完全成功，我的软件现在可以编辑400K长的文件，可以把一部长篇小说全部调到内存里编写了。只可惜我这个机器还是低级，只有<strong>1M RAM</strong>，并且没有硬盘，所以也就到此为止了。这个程序的缺点是太低级，有大量对<strong>端口(port)</strong>的操作，虽然效率是高的，兼容性不会太好。我的XT机给山妻用了，算起来我用那台机器已经七年，就如一位老友，骤然割爱，如心头割肉。</p></blockquote><h3 id="年份不详"><a href="#年份不详" class="headerlink" title="年份不详"></a>年份不详</h3><blockquote><p><strong>我们的pc机还没有和Internet连上。本来中国有几个国内网发展得很快，现在又出了问题，谁要上Internet，必须到有关部门去登记，留个案底，以备当局监控，很有一点监狱的气味。</strong>我还不想找这份麻烦，再说，通过Chinanet联网，每月也要交七八百的月费，我也没有这么多的钱。既然×反对信息时代，我们就不进这个时代罢，有什么法子。所以还是写信好了。</p></blockquote><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>我是跪着一条一条读着一条有一条的书信的，里面出现了太多太多的熟悉的名词。涉及到基础的数据结构 B 树，涉及到基本的编程语言，涉及到从 8086 到 80286 兼容的保护模式，扩展内存，涉及到统计学分布知识。</p><p>这些，都是媒体上广为传播他和李银河美丽爱情同时发生的事情（为什么媒体就知道炒那些爱情故事呢，王小波这么多的传奇都不说一下）</p><p>本科的时候草草翻过他的杂文集，当时就觉得很有趣，但是小说没太看懂。我觉得，是时候重新认识王小波了，过段时间再把他的书找回来读一读。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://91biji.com/social/leon/framebook/notes/note/9174/" target="_blank" rel="external nofollow noopener noreferrer">http://91biji.com/social/leon/framebook/notes/note/9174/</a></li><li><a href="https://www.zhihu.com/question/20964366" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/20964366</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十四期，这一期我要聊一聊「王小波」。&lt;code&gt;20200411&lt;/code&gt;是王小波逝世 23 周年祭日，我们对他的第一印象是他那奇妙诡谲的小说，是他那汪洋恣肆的杂文，是他和李银河的爱情故事。我依稀记得他写过自己的软件，直到今天我看到&lt;a href=&quot;http://91biji.com/social/leon/framebook/notes/note/9174/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;这个&lt;/a&gt;，我开始了对王小波的重新认识。他是一个真正的斜杠青年，比我上次说到的 &lt;a href=&quot;https://www.linkedin.com/in/damienriehl&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Damien Riehl&lt;/a&gt; 老哥还要厉害。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-17_programmer-wxb.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="斜杠青年" scheme="http://houmin.cc/tags/%E6%96%9C%E6%9D%A0%E9%9D%92%E5%B9%B4/"/>
    
      <category term="王小波" scheme="http://houmin.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>政治坐标系</title>
    <link href="http://houmin.cc/posts/125bc0e5/"/>
    <id>http://houmin.cc/posts/125bc0e5/</id>
    <published>2020-04-09T09:16:26.000Z</published>
    <updated>2020-07-14T11:57:25.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><p>「政治坐标系」的概念来源于著名的<code>political compass</code>，用于表明一个人的政治倾向。这里是我的政治坐标测试，其中「中国政治坐标测试」最早是 2007 年北大未名 BBS 的同学们讨论制作的，并在后期根据中国实际情况进行了订正和修改，在 <a href="http://www.zuobiao.me/zuobiao2015/index.php/66331?lang=zh-Hans" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 可以看到目前的版本。令我感到惊讶的是，居然在这个<a href="https://bbs.pku.edu.cn/v2/post-read-single.php?bid=1004&amp;type=3&amp;postid=5656284" target="_blank" rel="external nofollow noopener noreferrer">帖子</a>下面看到了<a href="http://blog.farmostwood.net/" target="_blank" rel="external nofollow noopener noreferrer">木遥</a>的踪迹，世界真小。</p><blockquote><p>需要强调说明的是，<strong>这个测试初始并且唯一的目标在于给使用者提供一个自我思考和认同的提示器。</strong></p><p>「公共政治议题讨论的阙失和长期的无限夸大式的政治宣传方式，使得很多人几乎是凭着脑海中浮现的口号来作出自己的选择，而完全不曾在理性上真正确认过自己的立场。」这是我对现实的悲观理解。这个问卷如此流行，足以反过来说明政治观点的分歧和相关观点在意识层面上（而非政策层面上）的讨论和争锋如何构成了公众生活的禁忌。网上关于这个测试的很多评论都反映出<strong>很多人并不习惯于拥有自己的观点，更不用说是在如此广泛的层面上。我相信这并非出自天性，而只是长期的怠惰使然。</strong></p></blockquote><p>与此同时，我也附上了来自英文「<a href="https://www.politicalcompass.org/test" target="_blank" rel="external nofollow noopener noreferrer">政治指南针</a>」网站的西方政治坐标测试，这份测试系统建立于西方政治价值体系基础之上，<strong>某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。</strong> 不管怎样，倒也可以提供一个自我思考的提示器。</p><a id="more"></a><p><img alt="Political Compass" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Political_chart.svg/941px-Political_chart.svg.png"></p><h2 id="中国政治坐标"><a href="#中国政治坐标" class="headerlink" title="中国政治坐标"></a>中国政治坐标</h2><h3 id="测试试题"><a href="#测试试题" class="headerlink" title="测试试题"></a>测试试题</h3><p>整个测试有 50 道题，分别从政治、经济、文化三个方面界定。这里列出了我在今天的选择，具体打分可到原网页进行测试。</p><p><form id="chinese-questions">    <ol>        <li>如果人民没有受过民主教育，他们是不应该拥有普选权的。<br><input name="c1" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c1" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c1" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c1" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>人权高于主权。<br><input name="c2" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c2" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c2" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c2" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>西方的多党制不适合中国国情。<br><input name="c3" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c3" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c3" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c3" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>由高校自主考试招生比全国统一考试招生更好。<br><input name="c4" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c4" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c4" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c4" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>在中国照搬西方式的言论自由会导致社会失序。<br><input name="c5" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c5" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c5" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c5" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>应该容许宗教人士在非宗教场所公开传教。<br><input name="c6" type="radio" data-x="-2" data-y="0" data-z="0" checked>强烈反对<br><input name="c6" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c6" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c6" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>无论中小学生或大学生，都应参加由国家统一安排的军训。<br><input name="c7" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c7" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c7" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c7" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家的统一和领土完整是社会的最高利益。<br><input name="c8" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c8" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c8" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c8" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家没有义务进行对外援助。<br><input name="c9" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c9" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c9" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c9" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>哪怕经历了违反程序规定的审讯和取证过程，确实有罪的罪犯也应被处以死刑。<br><input name="c10" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c10" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c10" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c10" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家领导人及开国领袖的形象可以作为文艺作品的丑化对象。<br><input name="c11" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c11" type="radio" data-x="-1" data-y="0" data-z="0" checked>反对<br><input name="c11" type="radio" data-x="1" data-y="0" data-z="0">同意<br><input name="c11" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>当法律未能充分制止罪恶行为时，通过极端手段对犯罪进行制裁是可以容忍的。<br><input name="c12" type="radio" data-x="2" data-y="0" data-z="0" checked>强烈反对<br><input name="c12" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c12" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c12" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>应当允许媒体代表某一特定阶层或利益集团发言。<br><input name="c13" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c13" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c13" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c13" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>如果国家综合实力许可，那么中国有权为了维护自己的利益而采取任何行动。<br><input name="c14" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c14" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c14" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c14" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>条件允许的话应该武力统一台湾。<br><input name="c15" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c15" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c15" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c15" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>国家应当采取措施培养和支持体育健儿在各种国际比赛场合为国争光。<br><input name="c16" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c16" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c16" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c16" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>律师即使明知被辩护人的犯罪事实也应当尽力为其进行辩护。<br><input name="c17" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c17" type="radio" data-x="1" data-y="0" data-z="0">反对<br><input name="c17" type="radio" data-x="-1" data-y="0" data-z="0" checked>同意<br><input name="c17" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>以美国为首的西方国家不可能真正容许中国崛起成为一流强国。<br><input name="c18" type="radio" data-x="2" data-y="0" data-z="0">强烈反对<br><input name="c18" type="radio" data-x="1" data-y="0" data-z="0" checked>反对<br><input name="c18" type="radio" data-x="-1" data-y="0" data-z="0">同意<br><input name="c18" type="radio" data-x="-2" data-y="0" data-z="0">强烈同意<br></li>        <li>两个成年人之间自愿的性行为是其自由，无论其婚姻关系为何。<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c19" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>不应当公开谈论自己的长辈的缺点。<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="-1" checked>同意<br><input name="c20" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>现代中国社会需要儒家思想。<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="-1" checked>同意<br><input name="c21" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>判断艺术作品的价值的根本标准是看是不是受到人民大众喜爱。<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="-1" checked>反对<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="1">同意<br><input name="c22" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>即使有人口压力，国家和社会也无权干涉个人要不要孩子，要几个孩子。<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c23" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>周易八卦能够有效的解释很多事情。<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="2" checked>强烈反对<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c24" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>中国传统医学对人体健康的观念比现代主流医学更高明。<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="1" checked>反对<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c25" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>汉字无需人为推行简化。<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="2">强烈反对<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="1" checked>反对<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c26" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>应当将中国传统文化的经典作品作为儿童基础教育读物。<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="2" checked>强烈反对<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="1">反对<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="-1">同意<br><input name="c27" type="radio" data-x="0" data-y="0" data-z="-2">强烈同意<br></li>        <li>如果是出于自愿，我会认可我的孩子和同性结成伴侣关系。<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="-2">强烈反对<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="-1">反对<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="1" checked>同意<br><input name="c28" type="radio" data-x="0" data-y="0" data-z="2">强烈同意<br></li>        <li>最低工资应由国家规定。<br><input name="c29" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c29" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c29" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c29" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>中国改革开放以来经济发展的成果很多都被一小群人占有了，大多数人没得到什么好处。<br><input name="c30" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈反对<br><input name="c30" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c30" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c30" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>在重大工程项目的决策中，个人利益应该为社会利益让路。<br><input name="c31" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c31" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c31" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c31" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>浪费粮食也是个人的自由。<br><input name="c32" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c32" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c32" type="radio" data-x="0" data-y="1" data-z="0" checked>同意<br><input name="c32" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>        <li>如果猪肉价格过高，政府应当干预。<br><input name="c33" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c33" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c33" type="radio" data-x="0" data-y="1" data-z="0" checked>同意<br><input name="c33" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>        <li>应当对国外同类产品征收高额关税来保护国内民族工业。<br><input name="c34" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c34" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c34" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c34" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>国有企业的利益属于国家利益。<br><input name="c35" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c35" type="radio" data-x="0" data-y="-1" data-z="0">反对<br><input name="c35" type="radio" data-x="0" data-y="1" data-z="0">同意<br><input name="c35" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈同意<br></li>        <li>试图控制房地产价格会破坏经济发展。<br><input name="c36" type="radio" data-x="0" data-y="-2" data-z="0">强烈反对<br><input name="c36" type="radio" data-x="0" data-y="-1" data-z="0" checked>反对<br><input name="c36" type="radio" data-x="0" data-y="1" data-z="0">同意<br><input name="c36" type="radio" data-x="0" data-y="2" data-z="0">强烈同意<br></li>        <li>教育应当尽可能公立。<br><input name="c37" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c37" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c37" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c37" type="radio" data-x="0" data-y="-2" data-z="0" checked>强烈同意<br></li>        <li>改善低收入者生活的首要手段是国家给予财政补贴和扶持。<br><input name="c38" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c38" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c38" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c38" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>有钱人理应获得更好的医疗服务。<br><input name="c39" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c39" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c39" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c39" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>高收入者应该公开自己的经济来源。<br><input name="c40" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c40" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c40" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c40" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>与其让国有企业亏损破产，不如转卖给资本家。<br><input name="c41" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c41" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c41" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c41" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>那些关系到国家安全、以及其他重要国计民生的领域，必须全部由国有企业掌控。<br><input name="c42" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c42" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c42" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c42" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>市场竞争中自然形成的垄断地位是无害的。<br><input name="c43" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c43" type="radio" data-x="0" data-y="1" data-z="0" checked>反对<br><input name="c43" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c43" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>资本积累的过程总是伴随着对普通劳动人民利益的伤害。<br><input name="c44" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c44" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c44" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c44" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>应该允许中国公民同时具有外国国籍。<br><input name="c45" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c45" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c45" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c45" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>        <li>政府应当提高粮食收购价格以增加农民收入。<br><input name="c46" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c46" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c46" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c46" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>为保障社会公平，对富人征税应采用更高的税率。<br><input name="c47" type="radio" data-x="0" data-y="2" data-z="0" checked>强烈反对<br><input name="c47" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c47" type="radio" data-x="0" data-y="-1" data-z="0">同意<br><input name="c47" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>在华外国资本应享受和民族资本同样的待遇。<br><input name="c48" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c48" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c48" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c48" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>私人应当可以拥有和买卖土地。<br><input name="c49" type="radio" data-x="0" data-y="2" data-z="0">强烈反对<br><input name="c49" type="radio" data-x="0" data-y="1" data-z="0">反对<br><input name="c49" type="radio" data-x="0" data-y="-1" data-z="0" checked>同意<br><input name="c49" type="radio" data-x="0" data-y="-2" data-z="0">强烈同意<br></li>        <li>发生重大社会安全事件时，即使认为信息公开会导致骚乱的风险，政府仍应该开放信息传播。<br><input name="c50" type="radio" data-x="-2" data-y="0" data-z="0">强烈反对<br><input name="c50" type="radio" data-x="-1" data-y="0" data-z="0">反对<br><input name="c50" type="radio" data-x="1" data-y="0" data-z="0" checked>同意<br><input name="c50" type="radio" data-x="2" data-y="0" data-z="0">强烈同意<br></li>    </ol></form><br><div class="note info">            <ul><li>政治观念坐标，负值为左，即威权主义 (Authoritarianism)，正值为右，即自由主义 (Libertarianism)。</li><li>社会文化观念坐标，负值为保守与复古派 (Conservatism)，正值为自由与激进派 (Liberalism)。</li><li>经济观念坐标，负值为左，即集体主义与福利主义 (Welfarism, Collectivism)，正值为右，即新自由主义(Neoliberalism)。</li></ul><p>三个维度的最大区间均为 [-2,2]。</p><p>本测试系统建立于中国政治价值体系基础之上，试图充分反映中国的特殊国情与政治文化。请注意，很多问题反映的是中国现实语境中的「左与右」，而非严格意义上的西方政治语汇中的「左与右」。</p>          </div></p><h3 id="测试反思"><a href="#测试反思" class="headerlink" title="测试反思"></a>测试反思</h3><p>整个测试做完，我的得分如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">政治立场坐标: <span class="number">0.4</span></span><br><span class="line">文化立场坐标: <span class="number">0.6</span></span><br><span class="line">经济立场坐标: <span class="number">-0.3</span></span><br></pre></td></tr></table></figure><p>什么意思呢？也就是说，我政治观念偏自由主义，社会文化观念偏自由主义，经济观念偏集体主义。这个测试结果和我在 <a href="https://www.idrlabs.com/" target="_blank" rel="external nofollow noopener noreferrer">IDRlabs</a>上面的<a href="https://www.idrlabs.com/cn/political-coordinates/test.php" target="_blank" rel="external nofollow noopener noreferrer">政治观点测试</a>大体类似，整体上政治文化偏自由，但是很明显经济方面自己的不确定性太大，整体上属于温和中间派。</p><p><img alt="IDRlabs Political Coordinate" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-09_political-compass.png"></p><p>倒也不是说通过这个测试就对我的左右进行了划分，把我划分成左派或右派。左右意识形态的纠葛在过去一百多年给人类社会带来撕扯与分裂，以至于对于左和右的定义国内国外都不太一样。一直以来，我的观点就是搁置意识形态上的争论，踏踏实实的讨论实际问题。但是搁置争论并不等于没有自己的观点，并不等于不去思考这些问题，而这个测试恰恰提供了这样的机会。</p><p>关于这五十个问题，做的时候有的并不是百分百的确定，很多问题涉及到经济问题。经济基础决定上层建筑，经济问题是可以用数学来解释的，过段时间等对于经济问题有了更多的理解后，再来做这个测试，或许答案又不一样了。</p><ul><li>人权与主权。教科书告诉我们主权高于人权，真的是这样吗？</li><li>真的应该公开所有的信息吗？一直以来我认为公开信息是能够促进事情更加透明的，现在我有些犹豫。</li><li>关注自主招生，应该认识到，自主招生确实是招到优秀同学的一种重要方式。但是我们也会看到这里面有很多不公平的现象产生，我选择公平。</li><li>国家的统一和领土完整真的是社会的最高利益吗？人民的幸福不才应该是吗？犹豫。</li><li>国家真的没有义务对外援助吗？大国责任呢？犹豫。</li><li>有罪的罪犯，取证不规范，这是程序正义的问题。现在是坚决反对的，即使他确实有问题，我们取证不规范，那和他又有什么区别呢？</li><li>国家领导人和开国领袖可以作为丑化对象吗？不能，原因说不清楚，觉得这样不好。</li><li>媒体不应该是尽量公正客观的吗？所以直觉认为媒体当然不应该为某一特定利益集团发言，又一转念，这不正是当下的显示吗？哪家媒体不是代表的某些人的利益的呢？</li><li>国籍问题是知识盲区，这个不是很懂，到底双重国籍有什么具体的影响。 </li><li>武统台湾，我们已经有条件了，但是这是我们最不愿意看到的，难道就没有别的办法吗，中国人这么聪明。 </li><li>现代社会需要儒家思想，当然是需要，但是看是那部分，君君臣臣那套还是算了。</li><li>判断艺术作品的价值真的是是否受到人民大众喜欢吗？不一定吧。</li><li>关于最低工资，这点并不太懂其背后的经济学原理。</li><li>个人利益应当为社会利益让路吗？犹豫。</li><li>粮食浪费也是个人自由吗？自由应该如何界定？</li><li>猪肉价格过高，政府应该干预吗？经济学上怎么说？</li><li>应该试图控制房地产吗？经济学上怎么说？</li><li>教育应该完全公立吗？从我的角度来说，我是赞成的。</li><li>有钱人应该公开自己的收入来源吗？直观感受是应该的。</li><li>涉及到国计民生的领域，真的都应该由国企掌控吗？</li><li>资本积累的过程看起来确实都伴随着对普通劳动人民利益的伤害。</li><li>政府应该高价格收购粮食吗？</li><li>私人应该可以自由买卖土地吗？是否会再次出现土地兼并的问题？ </li></ul><h2 id="西方政治坐标"><a href="#西方政治坐标" class="headerlink" title="西方政治坐标"></a>西方政治坐标</h2><h3 id="测试试题-1"><a href="#测试试题-1" class="headerlink" title="测试试题"></a>测试试题</h3><p>下面是我的测试结果，经济上偏自由，政治上偏自由。</p><p><form id="western-questions">    <p><strong>第一部分</strong>：你如何看待国家与世界。</p>    <ol>        <li>如果全球化无法避免，应该首先为人服务而不是跨国公司的利益。<br><input name="c1" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c1" type="radio" data-x="0.25" data-y="0">反对<br><input name="c1" type="radio" data-x="-0.375" data-y="0" checked>同意<br><input name="c1" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>我会一直支持我的国家，无论它是对是错。<br><input name="c2" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c2" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c2" type="radio" data-x="0" data-y="0.15">同意<br><input name="c2" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>没有人可以选择祖国，因此为祖国自豪很愚蠢。<br><input name="c3" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c3" type="radio" data-x="0" data-y="0.13" checked>反对<br><input name="c3" type="radio" data-x="0" data-y="-0.13">同意<br><input name="c3" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>我的种族和其他种族相比有很多出众的优点。<br><input name="c4" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c4" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c4" type="radio" data-x="0" data-y="0.13">同意<br><input name="c4" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>敌人的敌人是朋友。<br><input name="c5" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c5" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c5" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c5" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>违反国际法的军事行动有时候是正当的。<br><input name="c6" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c6" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c6" type="radio" data-x="0" data-y="0.11">同意<br><input name="c6" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>现在信息和娱乐已经令人忧虑的交融在一起。<br><input name="c7" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c7" type="radio" data-x="0" data-y="0.13">反对<br><input name="c7" type="radio" data-x="0" data-y="-0.13">同意<br><input name="c7" type="radio" data-x="0" data-y="-0.23" checked>强烈同意<br></li>    </ol>    <p><strong>第二部分</strong>：经济问题。</p>    <ol>        <li>人民根本上说是通过阶级而不是国籍来区分的。<br><input name="c8" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c8" type="radio" data-x="0.25" data-y="0">反对<br><input name="c8" type="radio" data-x="-0.375" data-y="0" checked>同意<br><input name="c8" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>控制通货膨胀比控制失业要重要。<br><input name="c9" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c9" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c9" type="radio" data-x="0.375" data-y="0">同意<br><input name="c9" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>        <li>因为无法信任企业能够自觉保护环境，因此需要规章来规范它们。<br><input name="c10" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c10" type="radio" data-x="0.25" data-y="0">反对<br><input name="c10" type="radio" data-x="-0.25" data-y="0">同意<br><input name="c10" type="radio" data-x="-0.5" data-y="0" checked>强烈同意<br></li>        <li>“各尽所能，各取所需”从根本上说是个好的想法。<br><input name="c11" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c11" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c11" type="radio" data-x="-0.375" data-y="0">同意<br><input name="c11" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>令人沮丧的是在我们的社会中一些最基本的事物比如饮用水现在都成为了瓶装、注明商标的商品。<br><input name="c12" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c12" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c12" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c12" type="radio" data-x="-0.75" data-y="0">强烈同意<br></li>        <li>土地不应当被作为商品买卖。<br><input name="c13" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c13" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c13" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c13" type="radio" data-x="-0.75" data-y="0">强烈同意<br></li>        <li>靠运作资金赚钱的人对社会的贡献比不上靠劳动赚钱的人。<br><input name="c14" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c14" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c14" type="radio" data-x="-0.375" data-y="0">同意<br><input name="c14" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>保护主义对贸易来说有时候是必须的。<br><input name="c15" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c15" type="radio" data-x="0.25" data-y="0" checked>反对<br><input name="c15" type="radio" data-x="-0.5" data-y="0">同意<br><input name="c15" type="radio" data-x="-0.625" data-y="0">强烈同意<br></li>        <li>公司为它的股东赚取利润就是它仅有的社会职责。<br><input name="c16" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c16" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c16" type="radio" data-x="0.375" data-y="0">同意<br><input name="c16" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>        <li>对富人征的税太高了。<br><input name="c17" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c17" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c17" type="radio" data-x="0.375" data-y="0">同意<br><input name="c17" type="radio" data-x="0.5" data-y="0">强烈同意<br></li>        <li>那些付得起钱的人应该有权获得更好的医疗服务。<br><input name="c18" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c18" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c18" type="radio" data-x="0.25" data-y="0">同意<br><input name="c18" type="radio" data-x="0.5" data-y="0">强烈同意<br></li>        <li>政府应该惩罚误导公众的商业行为。<br><input name="c19" type="radio" data-x="0.5" data-y="0">强烈反对<br><input name="c19" type="radio" data-x="0.25" data-y="0">反对<br><input name="c19" type="radio" data-x="-0.25" data-y="0">同意<br><input name="c19" type="radio" data-x="-0.375" data-y="0" checked>强烈同意<br></li>        <li>一个真正的自由市场需要对跨国大公司的垄断进行限制。<br><input name="c20" type="radio" data-x="0" data-y="0">强烈反对<br><input name="c20" type="radio" data-x="0" data-y="0">反对<br><input name="c20" type="radio" data-x="0" data-y="0">同意<br><input name="c20" type="radio" data-x="0" data-y="0" checked>强烈同意<br></li>        <li>市场越自由，人民越自由。<br><input name="c21" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c21" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c21" type="radio" data-x="0.5" data-y="0">同意<br><input name="c21" type="radio" data-x="0.75" data-y="0">强烈同意<br></li>    </ol>    <p><strong>第三部分</strong>：社会价值观。</p>    <ol>        <li>除非妇女的生命受到危及，否则总应该禁止堕胎。<br><input name="c22" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c22" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c22" type="radio" data-x="0" data-y="0.11">同意<br><input name="c22" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>一切当权者都应该受到质询。<br><input name="c23" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c23" type="radio" data-x="0" data-y="0.175">反对<br><input name="c23" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c23" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>以眼还眼，以牙还牙。<br><input name="c24" type="radio" data-x="0" data-y="-0.18">强烈反对<br><input name="c24" type="radio" data-x="0" data-y="-0.125" checked>反对<br><input name="c24" type="radio" data-x="0" data-y="0.08">同意<br><input name="c24" type="radio" data-x="0" data-y="0.18">强烈同意<br></li>        <li>税收不应该支持那些没法靠商业手段活下去的剧院和博物馆。<br><input name="c25" type="radio" data-x="-0.5" data-y="0" checked>强烈反对<br><input name="c25" type="radio" data-x="-0.25" data-y="0">反对<br><input name="c25" type="radio" data-x="0.5" data-y="0">同意<br><input name="c25" type="radio" data-x="0.625" data-y="0">强烈同意<br></li>        <li>学校不应该强制学生签到。<br><input name="c26" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c26" type="radio" data-x="0" data-y="0.055">反对<br><input name="c26" type="radio" data-x="0" data-y="-0.15" checked>同意<br><input name="c26" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>        <li>所有人都有自己的权利，但让不同类型的人保持自己的个性对每个人来说都更好。<br><input name="c27" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c27" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c27" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c27" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>好父母有时候也不得不打孩子。<br><input name="c28" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c28" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c28" type="radio" data-x="0" data-y="0.1" checked>同意<br><input name="c28" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>孩子对父母有秘密很正常。<br><input name="c29" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c29" type="radio" data-x="0" data-y="0.13">反对<br><input name="c29" type="radio" data-x="0" data-y="-0.08" checked>同意<br><input name="c29" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>大麻应该合法。<br><input name="c30" type="radio" data-x="0" data-y="0.2">强烈反对<br><input name="c30" type="radio" data-x="0" data-y="0.045" checked>反对<br><input name="c30" type="radio" data-x="0" data-y="-0.11">同意<br><input name="c30" type="radio" data-x="0" data-y="-0.21">强烈同意<br></li>        <li>学校的首要职能是让下一代人能找到工作。<br><input name="c31" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c31" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c31" type="radio" data-x="0" data-y="0.1">同意<br><input name="c31" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>应当不允许有严重遗传疾病的残疾人生育。<br><input name="c32" type="radio" data-x="0" data-y="-0.29">强烈反对<br><input name="c32" type="radio" data-x="0" data-y="-0.185">反对<br><input name="c32" type="radio" data-x="0" data-y="0.17" checked>同意<br><input name="c32" type="radio" data-x="0" data-y="0.275">强烈同意<br></li>        <li>孩子最重要的事是学会遵守纪律。<br><input name="c33" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c33" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c33" type="radio" data-x="0" data-y="0.15">同意<br><input name="c33" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>没有野蛮人和文明人，只有不同的文化。<br><input name="c34" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c34" type="radio" data-x="0" data-y="0.175">反对<br><input name="c34" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c34" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>那些有能力工作却拒绝工作机会的人，不应该接受社会的资助。<br><input name="c35" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c35" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c35" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c35" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>当你遇到困难时，最好不要去想它，而是不断地做令人高兴的事。<br><input name="c36" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c36" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c36" type="radio" data-x="0" data-y="0.11">同意<br><input name="c36" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>第一代移民永远无法完全融入他们的新国家。<br><input name="c37" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c37" type="radio" data-x="0" data-y="-0.075">反对<br><input name="c37" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c37" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>有利于最成功的企业的事物，最终也总是有利于我们大家的。<br><input name="c38" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c38" type="radio" data-x="-0.25" data-y="0" checked>反对<br><input name="c38" type="radio" data-x="0.75" data-y="0">同意<br><input name="c38" type="radio" data-x="0.875" data-y="0">强烈同意<br></li>        <li>任何广播电视机构，无论它的内容有多独立，都不应该接受公共资金的支持。<br><input name="c39" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c39" type="radio" data-x="-0.375" data-y="0" checked>反对<br><input name="c39" type="radio" data-x="0.125" data-y="0">同意<br><input name="c39" type="radio" data-x="0.25" data-y="0">强烈同意<br></li>    </ol>    <p><strong>第四部分</strong>：你如何看待更广阔的社会。</p>    <p></p>    <ol>        <li>在反恐的名义下，公民自由被过度限制了。<br><input name="c40" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c40" type="radio" data-x="0" data-y="0.155" checked>反对<br><input name="c40" type="radio" data-x="0" data-y="-0.1">同意<br><input name="c40" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>        <li>一党制国家的一个显著优点是它避免了在民主政体中耽误发展的所有那些争论。<br><input name="c41" type="radio" data-x="0" data-y="-0.29">强烈反对<br><input name="c41" type="radio" data-x="0" data-y="-0.135">反对<br><input name="c41" type="radio" data-x="0" data-y="0.17" checked>同意<br><input name="c41" type="radio" data-x="0" data-y="0.275">强烈同意<br></li>        <li>尽管在电子时代官方的监听更容易了，但只有坏人才需要对此担忧。<br><input name="c42" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c42" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c42" type="radio" data-x="0" data-y="0.15" checked>同意<br><input name="c42" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>对罪大恶极的犯罪分子，死刑不失为一种选项。<br><input name="c43" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c43" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c43" type="radio" data-x="0" data-y="0.15" checked>同意<br><input name="c43" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>在一个文明社会，一个人必须遵从上级、命令下级。<br><input name="c44" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c44" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c44" type="radio" data-x="0" data-y="0.11">同意<br><input name="c44" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>那些什么也没有表达的抽象艺术根本就不应该被称为艺术。<br><input name="c45" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c45" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c45" type="radio" data-x="0" data-y="0.15">同意<br><input name="c45" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>在刑事审判中，惩罚比改造更重要。<br><input name="c46" type="radio" data-x="0" data-y="-0.23" checked>强烈反对<br><input name="c46" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c46" type="radio" data-x="0" data-y="0.13">同意<br><input name="c46" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>改造有些犯罪分子就是浪费时间。<br><input name="c47" type="radio" data-x="0" data-y="-0.26" checked>强烈反对<br><input name="c47" type="radio" data-x="0" data-y="-0.155">反对<br><input name="c47" type="radio" data-x="0" data-y="0.15">同意<br><input name="c47" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>商人和制造业者比作家和艺术家更重要。<br><input name="c48" type="radio" data-x="0" data-y="-0.18">强烈反对<br><input name="c48" type="radio" data-x="0" data-y="-0.08" checked>反对<br><input name="c48" type="radio" data-x="0" data-y="0.08">同意<br><input name="c48" type="radio" data-x="0" data-y="0.18">强烈同意<br></li>        <li>母亲们可以有职业，但她们的首要职责是家庭主妇。<br><input name="c49" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c49" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c49" type="radio" data-x="0" data-y="0.13">同意<br><input name="c49" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>跨国公司正在不道德地开发发展中国家的植物基因资源。<br><input name="c50" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c50" type="radio" data-x="0" data-y="0.13">反对<br><input name="c50" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c50" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>同现有体制和谐相处是成熟的重要一方面。<br><input name="c51" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c51" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c51" type="radio" data-x="0" data-y="0.11" checked>同意<br><input name="c51" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>    </ol>    <p></p>    <p><strong>第五部分</strong>：关于宗教。</p>    <p></p>    <ol>        <li>占星术精确地解释了很多东西。<br><input name="c52" type="radio" data-x="0" data-y="-0.23" checked>强烈反对<br><input name="c52" type="radio" data-x="0" data-y="-0.13">反对<br><input name="c52" type="radio" data-x="0" data-y="0.13">同意<br><input name="c52" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>你如果不信宗教就不可能道德。<br><input name="c53" type="radio" data-x="0" data-y="-0.2" checked>强烈反对<br><input name="c53" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c53" type="radio" data-x="0" data-y="0.11">同意<br><input name="c53" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>        <li>慈善捐助在帮助真正的弱势群体时做得比社会保障要好。<br><input name="c54" type="radio" data-x="-0.5" data-y="0">强烈反对<br><input name="c54" type="radio" data-x="-0.375" data-y="0" checked>反对<br><input name="c54" type="radio" data-x="0.625" data-y="0">同意<br><input name="c54" type="radio" data-x="0.75" data-y="0">强烈同意<br></li>        <li>有些人天生不走运。<br><input name="c55" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c55" type="radio" data-x="0" data-y="-0.13" checked>反对<br><input name="c55" type="radio" data-x="0" data-y="0.13">同意<br><input name="c55" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>我孩子的学校向他传授宗教价值观，这点非常重要。<br><input name="c56" type="radio" data-x="0" data-y="-0.2" checked>强烈反对<br><input name="c56" type="radio" data-x="0" data-y="-0.1">反对<br><input name="c56" type="radio" data-x="0" data-y="0.11">同意<br><input name="c56" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>    </ol>    <p></p>    <p><strong>第六部分</strong>：关于性。</p>    <ol>        <li>婚姻之外的性是不道德的。<br><input name="c57" type="radio" data-x="0" data-y="-0.23">强烈反对<br><input name="c57" type="radio" data-x="0" data-y="-0.175">反对<br><input name="c57" type="radio" data-x="0" data-y="0.13" checked>同意<br><input name="c57" type="radio" data-x="0" data-y="0.23">强烈同意<br></li>        <li>一对稳定、相爱的同性伴侣，应有收养孩子的权利。<br><input name="c58" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c58" type="radio" data-x="0" data-y="0.175">反对<br><input name="c58" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c58" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>由成年人自愿演出的色情影视应该对成人合法化。<br><input name="c59" type="radio" data-x="0" data-y="0.23">强烈反对<br><input name="c59" type="radio" data-x="0" data-y="0.13">反对<br><input name="c59" type="radio" data-x="0" data-y="-0.13" checked>同意<br><input name="c59" type="radio" data-x="0" data-y="-0.23">强烈同意<br></li>        <li>在私人卧室里两个成年人只见不管做什么，只要是自愿的，国家就管不着。<br><input name="c60" type="radio" data-x="0" data-y="0.26">强烈反对<br><input name="c60" type="radio" data-x="0" data-y="0.155">反对<br><input name="c60" type="radio" data-x="0" data-y="-0.15" checked>同意<br><input name="c60" type="radio" data-x="0" data-y="-0.255">强烈同意<br></li>        <li>没有人会天生同性恋。<br><input name="c61" type="radio" data-x="0" data-y="-0.26">强烈反对<br><input name="c61" type="radio" data-x="0" data-y="-0.155" checked>反对<br><input name="c61" type="radio" data-x="0" data-y="0.15">同意<br><input name="c61" type="radio" data-x="0" data-y="0.255">强烈同意<br></li>        <li>社会对性开放并没错，但现在已经开放的过分了。<br><input name="c62" type="radio" data-x="0" data-y="-0.2">强烈反对<br><input name="c62" type="radio" data-x="0" data-y="-0.1" checked>反对<br><input name="c62" type="radio" data-x="0" data-y="0.11">同意<br><input name="c62" type="radio" data-x="0" data-y="0.21">强烈同意<br></li>    </ol></form></p><div id="western-wrapper">    <button id="western-submit" type="button" class="button button-inverse button-rounded">提交</button>    <br>    <span id="western-answer" class="red">    政治立场坐标（左翼&lt;-&gt;右翼）-3.87，经济立场坐标（左翼&lt;-&gt;右翼）-2.42    </span></div><script type="text/javascript">  $(function() {    $("#western-submit").click(function(){      var t=0, a=0;      $('#western-questions input[name^="c"]:checked').each(function(){        t += parseFloat($(this).attr("data-x")),        a += parseFloat($(this).attr("data-y"))      }),      t = Math.round(100*t)/100,      a = Math.round(100*a)/100,      $("#western-answer").html("经济立场坐标（左翼<->右翼）"+ t + "，政治立场坐标（专制<->自由）" + a)    })  });</script><div class="note info">            <p>横坐标反映经济观念，负值为左（Communism, Collectivism），正值为右（Neo-Liberalism, Libertaranism）。纵坐标反映政治社会观念，负值为自由（Anarchism, Libertarian），正值为专制或保守（Facism, Authoritarian）。</p><p>本测试系统建立于西方政治价值体系基础之上，某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。根据周围人群的实验结果，中国人的测试结果普遍位于第三象限（即两坐标均为负值），平均值位于(-2,-2)附近。为了区分中国人习惯意义上的「左与右」，可以以(-2,-2)为坐标原点重新划分坐标平面，即经济坐标小于-2为左，反之为右。政治坐标小于-2为自由，反之为保守或专制。</p><p>下面是著名政治人物的坐标位置以供参考：</p><ul><li>第一象限（经济右，政治保守）：希特勒，撒切尔夫人，布什，布莱尔，希拉克。</li><li>第二象限（经济左，政治保守）：斯大林，萨达姆，教皇本笃十四世。</li><li>第三象限（经济左，政治自由）：甘地，达赖喇嘛，曼德拉。</li><li>第四象限（经济右，政治自由）：弗里德曼，哈耶克。</li></ul>          </div><h3 id="测试反思-1"><a href="#测试反思-1" class="headerlink" title="测试反思"></a>测试反思</h3><ul><li>我的种族和其他种族相比有很多出众的优点？我下意识想选择同意。但是真的是这样吗？</li><li>各尽所能，各取所需？人类的惰性</li><li>土地应该自由买卖吗？</li><li>以眼还眼以牙还牙，对吗？主观上会这么做。理性上为了更好的共处，应该放下。</li><li>学校应当强制学生签到吗？对于大学生，学不学是你的主观意愿。但是如果是义务教育，需要。</li><li>堕胎应当被允许吗？这应该是个人选择吧。 </li><li>大麻应该合法吗？介于毒品和香烟之间，但是更偏毒品，偏向于禁止大麻。</li><li>应当允许有严重遗传疾病的残疾人生育吗？不应该，遗传疾病生下来对于孩子也是痛苦，领养不好吗？</li><li>对于电子监听，我们需要担忧吗？ 对于绝大多数普通人，这应该不是问题。 </li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>还是原来的观点，这个测试结果并不一定代表什么，但是可以作为参考。最重要的是，给自己提供了一个思考的机会。很多问题选择不够坚决，说明很多时候对这方面的思考欠缺。这个测试不应该是一次性的测试，随着人的动态变化，观点也在发生改变。在以后的时间，可以回头再看这些问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;「政治坐标系」的概念来源于著名的&lt;code&gt;political compass&lt;/code&gt;，用于表明一个人的政治倾向。这里是我的政治坐标测试，其中「中国政治坐标测试」最早是 2007 年北大未名 BBS 的同学们讨论制作的，并在后期根据中国实际情况进行了订正和修改，在 &lt;a href=&quot;http://www.zuobiao.me/zuobiao2015/index.php/66331?lang=zh-Hans&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;这里&lt;/a&gt; 可以看到目前的版本。令我感到惊讶的是，居然在这个&lt;a href=&quot;https://bbs.pku.edu.cn/v2/post-read-single.php?bid=1004&amp;amp;type=3&amp;amp;postid=5656284&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;帖子&lt;/a&gt;下面看到了&lt;a href=&quot;http://blog.farmostwood.net/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;木遥&lt;/a&gt;的踪迹，世界真小。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要强调说明的是，&lt;strong&gt;这个测试初始并且唯一的目标在于给使用者提供一个自我思考和认同的提示器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「公共政治议题讨论的阙失和长期的无限夸大式的政治宣传方式，使得很多人几乎是凭着脑海中浮现的口号来作出自己的选择，而完全不曾在理性上真正确认过自己的立场。」这是我对现实的悲观理解。这个问卷如此流行，足以反过来说明政治观点的分歧和相关观点在意识层面上（而非政策层面上）的讨论和争锋如何构成了公众生活的禁忌。网上关于这个测试的很多评论都反映出&lt;strong&gt;很多人并不习惯于拥有自己的观点，更不用说是在如此广泛的层面上。我相信这并非出自天性，而只是长期的怠惰使然。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与此同时，我也附上了来自英文「&lt;a href=&quot;https://www.politicalcompass.org/test&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;政治指南针&lt;/a&gt;」网站的西方政治坐标测试，这份测试系统建立于西方政治价值体系基础之上，&lt;strong&gt;某些问题强烈的依赖于具体的西方社会环境，未必能够充分反映中国国情。&lt;/strong&gt; 不管怎样，倒也可以提供一个自我思考的提示器。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-09_political-compass.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="politics" scheme="http://houmin.cc/tags/politics/"/>
    
      <category term="价值观" scheme="http://houmin.cc/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"/>
    
  </entry>
  
  <entry>
    <title>自动抓取经济学人</title>
    <link href="http://houmin.cc/posts/d1848f4f/"/>
    <id>http://houmin.cc/posts/d1848f4f/</id>
    <published>2020-04-08T14:05:25.000Z</published>
    <updated>2020-07-14T08:24:44.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>作为信息源建设的一部分，最近突然想把「经济学人」阅读捡起来。为了能够固定获取「经济学人」文本，研究了一下其爬取过程，记录如下，希望能够有所帮助。</p><h2 id="经济学人是什么"><a href="#经济学人是什么" class="headerlink" title="经济学人是什么"></a>经济学人是什么</h2><p>经济学人是一份创办于 1843 年 9 月 2 日的英国杂志。这是一本涉及全球政治、经济、文化、科技等多方面事务的综合性新闻评论刊物，着重于对这些议题提供深入的分析和评论。它的社论持有<a href="https://zh.wikipedia.org/wiki/古典自由主義" target="_blank" rel="external nofollow noopener noreferrer">古典自由主义</a>与<a href="https://zh.wikipedia.org/wiki/經濟自由主義" target="_blank" rel="external nofollow noopener noreferrer">经济自由主义</a>的立场，倾向于支持<a href="https://zh.wikipedia.org/wiki/自由貿易" target="_blank" rel="external nofollow noopener noreferrer">自由贸易</a>、<a href="https://zh.wikipedia.org/wiki/全球化" target="_blank" rel="external nofollow noopener noreferrer">全球化</a>、<a href="https://zh.wikipedia.org/w/index.php?title=人口自由流動&amp;action=edit&amp;redlink=1" target="_blank" rel="external nofollow noopener noreferrer">人口自由流动</a>和<a href="https://zh.wikipedia.org/wiki/社會自由主義" target="_blank" rel="external nofollow noopener noreferrer">社会自由主义</a>。</p><a id="more"></a><ul><li>在创刊之初，其议题主要囊括英国及其殖民地的政治、经济及自由贸易等范围。</li><li>1941 年珍珠港事件后首次开辟美国专栏，这是其第一个专门报道某个国家的栏目。</li><li>2012年1月，首次开设了中国专栏，这是继1941年的美国栏目之后的首个国家栏目。</li></ul><h2 id="神奇的calibre"><a href="#神奇的calibre" class="headerlink" title="神奇的calibre"></a>神奇的calibre</h2><p><a href="https://calibre-ebook.com/" target="_blank" rel="external nofollow noopener noreferrer">calibre</a>是一个开源的多平台（支持 Linux，macOS，Windows）电子书管理工具，它支持以下功能：</p><ul><li>强大的电子书管理工具，支持从网络上下载电子书的元数据。</li><li>强大的电子书阅读工具，支持 ToC，搜索，复制等功能。</li><li>支持从网络上下载新闻杂志，比如 <code>The Economist</code>, <code>New York Times</code>等，甚至是 RSS源。</li><li>内置 web 服务器，可以更加方便的分享和备份图书库</li><li>支持编辑电子书，进行格式转换，包括 epub，mobi 等格式</li></ul><p>calibre 支持一种 <code>recipe</code>的概念，calibre 可以通过 <code>recipe</code>从网络上下载新闻，并且组织成电子书。</p><blockquote><p><strong>A recipe is a set of instructions that teach calibre how to convert an online news source</strong>, such as a magazine or a blog, into an e-book.</p></blockquote><p><code>recipe</code>本质上都是 Python 代码，最简单的时候他们只是一些变量，比如 URL，用来告诉 calibre 要从哪里下载新闻。</p><p>下面以 <a href="https://lwn.net/" target="_blank" rel="external nofollow noopener noreferrer">LWN</a> 为例（对的，calibre 也可以爬 LWN，但是我太穷了，还订不起）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env  python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> calibre.web.feeds.news <span class="keyword">import</span> BasicNewsRecipe</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LWN</span><span class="params">(BasicNewsRecipe)</span>:</span></span><br><span class="line">    title = <span class="string">u'lwn'</span></span><br><span class="line">    __author__ = <span class="string">'Oliver Niesner'</span></span><br><span class="line">    description = <span class="string">'Linux Weekly News'</span></span><br><span class="line">    oldest_article = <span class="number">54</span></span><br><span class="line">    language = _(<span class="string">'English'</span>)</span><br><span class="line">    max_articles_per_feed = <span class="number">100</span></span><br><span class="line">    needs_subscription = <span class="literal">True</span></span><br><span class="line">    language = <span class="string">'en'</span></span><br><span class="line">    remove_javascript = <span class="literal">True</span></span><br><span class="line">    simultaneous_downloads = <span class="number">1</span></span><br><span class="line">    delay = <span class="number">1</span></span><br><span class="line">    LOGIN = <span class="string">'https://lwn.net/login'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_browser</span><span class="params">(self)</span>:</span></span><br><span class="line">        br = BasicNewsRecipe.get_browser(self)</span><br><span class="line">        <span class="keyword">if</span> self.username <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.password <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            br.open(self.LOGIN)</span><br><span class="line">            br.select_form(name=<span class="string">'loginform'</span>)</span><br><span class="line">            br[<span class="string">'Username'</span>] = self.username</span><br><span class="line">            br[<span class="string">'Password'</span>] = self.password</span><br><span class="line">            br.submit()</span><br><span class="line">        <span class="keyword">return</span> br</span><br><span class="line"></span><br><span class="line">    remove_tags = [</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'LeftColumn'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'NavLink'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'FormattedComment'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'td'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'MCTopBanner'</span>&#125;),</span><br><span class="line">        dict(name=<span class="string">'div'</span>, attrs=&#123;<span class="string">'class'</span>: <span class="string">'CommentBox'</span>&#125;)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    feeds = [</span><br><span class="line">        (<span class="string">u'lwn'</span>, <span class="string">u'http://lwn.net/headlines/newrss'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postprocess_html</span><span class="params">(self, soup, first)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> tag <span class="keyword">in</span> soup.findAll(name=[<span class="string">'table'</span>, <span class="string">'tr'</span>, <span class="string">'td'</span>]):</span><br><span class="line">            tag.name = <span class="string">'div'</span></span><br><span class="line">        <span class="keyword">return</span> soup</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_version</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> url.replace(<span class="string">'rss'</span>, <span class="string">'?format=printable'</span>)</span><br></pre></td></tr></table></figure><p>首先我们看到 LWN 这个 recipe 继承自 <a href="https://manual.calibre-ebook.com/news_recipe.html" target="_blank" rel="external nofollow noopener noreferrer">BasicRecipe</a> 这个基本的类， <a href="https://manual.calibre-ebook.com/news_recipe.html" target="_blank" rel="external nofollow noopener noreferrer">BasicRecipe</a> 实现了所有 recipe 都会用到的逻辑，比如 <strong>get_browser</strong>、<strong>postprocess_html</strong> 等方法，LWN 只需要根据自己的逻辑去重载即可。</p><p>我们还可以看到，LWN 这个类下面也定义了很多的参数，这些参数都是根据自己的这次抓取的定制参数。比如最关键的 <code>feeds</code>，这是一个告诉 calibre 从哪下载的 list。</p><p>到现在应该明白 calibre 的工作原理了吧。所有下载的源文件都在互联网上以 HTML 的形式你存在，不论是订阅还是非订阅。calibre 通过将这些源文件（HTML 以及图片等）下载后，对 HTML 文本进行再组织，最常用的工具就是 BeautifulSoup。最后，根据 epub 或者 mobi 等格式的要求，进行格式转换即可。</p><p>在<a href="https://github.com/kovidgoyal/calibre/blob/master/recipes/economist.recipe" target="_blank" rel="external nofollow noopener noreferrer">这里</a>你可以看到经济学人的 recipe，比较复杂，主要是对 html文本的处理，有时间可以仔细研究。</p><p>在 <a href="https://manual.calibre-ebook.com/news.html" target="_blank" rel="external nofollow noopener noreferrer">calibre 的官方文档</a>可以看到关于下载新闻更加详细的教程，以后折腾 RSS 的时候可以再看看。</p><h2 id="自动定时抓取经济学人"><a href="#自动定时抓取经济学人" class="headerlink" title="自动定时抓取经济学人"></a>自动定时抓取经济学人</h2><h3 id="ebook-convert"><a href="#ebook-convert" class="headerlink" title="ebook-convert"></a>ebook-convert</h3><p>从 calibre manual 中可以看到，calibre 给我们提供了众多的命令行工具，但是如果只是下载经济学人的话，我们只需要用到 <code>ebook-convert</code>这一工具。其使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ebook-convert input_file output_file [options]</span><br></pre></td></tr></table></figure><p>一般情况下，这里的 <code>input_file</code>是需要进行格式转换的输入文件，<code>output_file</code>是格式转换的输出文件。比如我们把一个 epub 格式转换成 <code>mobi</code>格式。但是，calibre 也能够对于 <code>recipe</code>文件进行自动解析，去网络上下载对应的 HTML 文件，并将其输出成需要的格式。具体的，对于经济学人：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ebook-convert <span class="string">"The Economist.recipe"</span> <span class="string">"te2020-04-06.epub'</span></span><br></pre></td></tr></table></figure><p>在这里，calibre 会自动根据输出文件的后缀名，将输出文件转换成相应格式，真棒。</p><p>对于不同格式的输入输出文件，还有相应的options。</p><ul><li>对于 Recipe 的输入格式，有以下参数<ul><li><code>--username</code>和<code>--password</code>，如果需要用户名和密码的话，可以用于指定相关参数</li></ul></li><li><code>--output-profile</code>可以针对不同设备对输出文件进行优化，比如 <code>--output-profile=kindle_pw3</code></li></ul><h3 id="什么时候抓取"><a href="#什么时候抓取" class="headerlink" title="什么时候抓取"></a>什么时候抓取</h3><p>根据经济学人的recipe，我们可以看到，其实它每次是以 <a href="https://www.economist.com/printedition" target="_blank" rel="external nofollow noopener noreferrer">https://www.economist.com/printedition</a> 为根节点进行遍历，爬取下面所有的文章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Economist</span><span class="params">(BasicNewsRecipe)</span>:</span></span><br><span class="line"></span><br><span class="line">    title = <span class="string">'The Economist'</span></span><br><span class="line">    language = <span class="string">'en'</span></span><br><span class="line"></span><br><span class="line">    __author__ = <span class="string">"Kovid Goyal"</span></span><br><span class="line">    INDEX = <span class="string">'https://www.economist.com/printedition'</span></span><br><span class="line">    description = (</span><br><span class="line">        <span class="string">'Global news and current affairs from a European'</span></span><br><span class="line">        <span class="string">' perspective. Best downloaded on Friday mornings (GMT)'</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>什么时候爬取最合适呢，它也写了最好是在 GMT 时间的星期五上午，北京时间是 GMT + 8，所以我们设定自动定时就可以了。</p><h3 id="如何抓取音频"><a href="#如何抓取音频" class="headerlink" title="如何抓取音频"></a>如何抓取音频</h3><p>经济学人在官方已经开源了所有的音频文件，其文件地址格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>audiocdn.economist.com<span class="regexp">/sites/</span>default<span class="regexp">/files/</span>AudioArchive<span class="regexp">/2013/</span><span class="number">2013</span>MMDD<span class="regexp">/Issue_****_2013MMDD_The_Economist_Full_edition.zip</span></span><br></pre></td></tr></table></figure><ul><li>MMDD为每周发行日（周六）的月份与日期</li><li><code>****</code>为该周六距离1843年9月2日的周数，也就是其期数。</li></ul><p>为了便于计算，我们计算和查找 <code>2020-01-04</code>是其出版的第 <code>9175</code> 期，之后的期数以这一天为起点计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_date = <span class="string">'2020-01-04'</span></span><br><span class="line">end_date = <span class="string">'2020-04-04'</span></span><br><span class="line">week_start = <span class="number">9175</span></span><br><span class="line">start_sec = time.mktime(time.strptime(start_date,<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line">end_sec = time.mktime(time.strptime(end_date,<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line">week_delta = int((end_sec - start_sec)/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>))</span><br><span class="line">week_now = week_start + week_delta</span><br></pre></td></tr></table></figure><div class="note info">            <p>这里的期数应该不是严格按照每一周一期，因为我们发现 <code>20131109</code>这一期的期号为8861，而 <code>20200404</code>这一期的期号为 <code>9188</code>，其间周数间隔为334，而期数间隔为 327，应该是中间有几期没有音频。</p>          </div><h2 id="容器化主宰世界"><a href="#容器化主宰世界" class="headerlink" title="容器化主宰世界"></a>容器化主宰世界</h2><p>将 calibre 容器化，Dockerfile 如下，这里主要是在 alpine 系统上安装了 <code>calibre</code>，然后启动 crontab 定时调用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ljnelson/docker-calibre-alpine</span><br><span class="line"><span class="keyword">MAINTAINER</span> houmin &lt;houmin.wei@pku.edu.cn&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache python3 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="keyword">if</span> [ ! -e /usr/bin/python ]; <span class="keyword">then</span> ln -sf python3 /usr/bin/python ; <span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> crontab.txt /crontab.txt</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> main.py /main.py</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> entry.sh /entry.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /entry.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /usr/bin/crontab /crontab.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/entry.sh"</span>]</span></span><br></pre></td></tr></table></figure><p>为了让外界能够访问这些爬取到的数据，启动一个 FTP 服务器。整体的 <code>docker-compose.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vsftpd:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">vsftpd</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"fauria/vsftpd"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/calibre/data:/home/vsftpd</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"20:20"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"21:21"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"21100-21110:21100-21110"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FTP_USER=[user]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FTP_PASS=[passwd]</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_ADDRESS=127.0.0.1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_MIN_PORT=21100</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PASV_MAX_PORT=21110</span></span><br><span class="line">  <span class="attr">calibre:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">calibre</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"unicosmos/calibre"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/calibre/data/[user]:/data</span></span><br></pre></td></tr></table></figure><p>把这里的 <code>user</code> 和 <code>passwd</code> 改成自己服务器的就好了。</p><p>程序主函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime, time, os</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"></span><br><span class="line">mail_host = <span class="string">"smtp.163.com"</span></span><br><span class="line">mail_user = <span class="string">"houmin_wei@163.com"</span></span><br><span class="line">mail_pass = <span class="string">"********"</span></span><br><span class="line"></span><br><span class="line">sender = <span class="string">'houmin_wei@163.com'</span></span><br><span class="line">receivers = [<span class="string">'houmin.wei@pku.edu.cn'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_week</span><span class="params">(date)</span>:</span></span><br><span class="line">    start_date = <span class="string">'20200104'</span></span><br><span class="line">    week_start = <span class="number">9175</span></span><br><span class="line">    start_sec = time.mktime(time.strptime(start_date, <span class="string">'%Y%m%d'</span>))</span><br><span class="line">    date_sec = time.mktime(time.strptime(date, <span class="string">'%Y%m%d'</span>))</span><br><span class="line">    week_delta = int((date_sec - start_sec)/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>))</span><br><span class="line">    week_now = week_start + week_delta</span><br><span class="line">    <span class="keyword">return</span> week_now</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_audio</span><span class="params">(date, path)</span>:</span></span><br><span class="line">    week_now = cal_week(date)</span><br><span class="line">    url = <span class="string">"https://audiocdn.economist.com/sites/default/files/AudioArchive/&#123;year&#125;/&#123;date&#125;/Issue_&#123;week&#125;_&#123;date&#125;_The_Economist_Full_edition.zip"</span>.format(year=date[<span class="number">0</span>:<span class="number">4</span>], date=date, week=week_now)</span><br><span class="line">    print(url)</span><br><span class="line">    cmd = <span class="string">"cd &#123;path&#125;/audio &amp;&amp; wget &#123;url&#125; &amp;&amp; cd -;"</span>.format(path=path, url=url)</span><br><span class="line">    os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_book</span><span class="params">(date, path)</span>:</span></span><br><span class="line">    filename = path + <span class="string">"/ebook/te"</span> + date</span><br><span class="line">    <span class="comment">#cmd = 'ebook-convert \"The Economist.recipe\" ' + filename + '.mobi --output-profile=kindle'</span></span><br><span class="line">    cmd = <span class="string">'ebook-convert \"The Economist.recipe\" '</span> + filename + <span class="string">'.epub'</span></span><br><span class="line">    os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(date, path, sender, receivers)</span>:</span></span><br><span class="line">    epubFile = path + <span class="string">"/ebook/te"</span> + date + <span class="string">'.epub'</span></span><br><span class="line">    epubApart = MIMEApplication(open(epubFile, <span class="string">'rb'</span>).read())</span><br><span class="line">    epubApart.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=epubFile)</span><br><span class="line"></span><br><span class="line">    message = MIMEMultipart()</span><br><span class="line">    message.attach(epubApart)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = <span class="string">"The Economist "</span> + date</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP(mail_host, <span class="number">465</span>)</span><br><span class="line">        smtpObj.login(mail_user, mail_pass)</span><br><span class="line">        smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">        print(<span class="string">"sending mail success!"</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        print(<span class="string">"Error: cannot send mail"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operator</span><span class="params">(path)</span>:</span></span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    tomorrow = today + datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    date = tomorrow.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line">    print(<span class="string">"==============================================="</span>)</span><br><span class="line">    print(<span class="string">"Fetch The Economist &#123;date&#125; begin..."</span>.format(date=date))</span><br><span class="line">    get_book(date, path)</span><br><span class="line">    <span class="comment">#get_audio(date, path)</span></span><br><span class="line">    <span class="comment">#send_mail(date, path, sender, receivers)</span></span><br><span class="line">    print(<span class="string">"Fetch The Economist &#123;date&#125; end."</span>.format(date=date))</span><br><span class="line">    print(<span class="string">"===============================================\n\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    operator(<span class="string">"./data"</span>)</span><br></pre></td></tr></table></figure><p>更多具体的内容，可以参考我的 <a href="https://github.com/SimpCosm/calibre" target="_blank" rel="external nofollow noopener noreferrer">Github Repo</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://manual.calibre-ebook.com/" target="_blank" rel="external nofollow noopener noreferrer">calibre manual</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;作为信息源建设的一部分，最近突然想把「经济学人」阅读捡起来。为了能够固定获取「经济学人」文本，研究了一下其爬取过程，记录如下，希望能够有所帮助。&lt;/p&gt;&lt;h2 id=&quot;经济学人是什么&quot;&gt;&lt;a href=&quot;#经济学人是什么&quot; class=&quot;headerlink&quot; title=&quot;经济学人是什么&quot;&gt;&lt;/a&gt;经济学人是什么&lt;/h2&gt;&lt;p&gt;经济学人是一份创办于 1843 年 9 月 2 日的英国杂志。这是一本涉及全球政治、经济、文化、科技等多方面事务的综合性新闻评论刊物，着重于对这些议题提供深入的分析和评论。它的社论持有&lt;a href=&quot;https://zh.wikipedia.org/wiki/古典自由主義&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;古典自由主义&lt;/a&gt;与&lt;a href=&quot;https://zh.wikipedia.org/wiki/經濟自由主義&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;经济自由主义&lt;/a&gt;的立场，倾向于支持&lt;a href=&quot;https://zh.wikipedia.org/wiki/自由貿易&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;自由贸易&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/wiki/全球化&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;全球化&lt;/a&gt;、&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=人口自由流動&amp;amp;action=edit&amp;amp;redlink=1&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;人口自由流动&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/社會自由主義&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;社会自由主义&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://www.economist.com/sites/default/files/imagecache/400-width/print-covers/20200404_cuk1280.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="docker" scheme="http://houmin.cc/tags/docker/"/>
    
      <category term="calibre" scheme="http://houmin.cc/tags/calibre/"/>
    
      <category term="ebook" scheme="http://houmin.cc/tags/ebook/"/>
    
  </entry>
  
</feed>
