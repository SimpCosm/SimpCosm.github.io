<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-11-23T13:06:17.421Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Kubernetes】GPU 共享</title>
    <link href="http://houmin.cc/posts/cf391335/"/>
    <id>http://houmin.cc/posts/cf391335/</id>
    <published>2020-11-18T03:11:07.000Z</published>
    <updated>2020-11-23T13:06:17.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>原生的 k8s 基于 <code>Device Plugin</code> 和 <code>Extended Resource</code> 机制实现了在容器中使用GPU，但是只支持GPU的独占使用，不允许在Pod间共享GPU，这大大降低了对集群中GPU的利用率。为了在集群层面共享GPU，我们需要实现GPU资源的隔离与调度，本文将依次介绍阿里的 <a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender" target="_blank" rel="external nofollow noopener noreferrer">GPUShare</a> 与腾讯的 <a href="https://github.com/tkestack/gpu-manager" target="_blank" rel="external nofollow noopener noreferrer">GPUManager</a>，分析其实现机制。</p><a id="more"></a><h2 id="阿里GPUShare"><a href="#阿里GPUShare" class="headerlink" title="阿里GPUShare"></a>阿里GPUShare</h2><p>阿里的 <a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender" target="_blank" rel="external nofollow noopener noreferrer">GPUShare</a> 基于 <a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external nofollow noopener noreferrer">Nvidia Docker2</a> 和他们的 <a href="https://docs.google.com/document/d/1ZgKH_K4SEfdiE_OfxQ836s4yQWxZfSjS288Tq9YIWCA/edit#heading=h.r88v2xgacqr" target="_blank" rel="external nofollow noopener noreferrer">gpu sharing design</a> 设计而实现的，为了使用阿里的GPUShare，首先需要配置Node上的 Docker Runtime 并安装 <code>NVIDIA Docker 2</code>，具体过程可以参考 <a href="../574111db">在Docker中使用GPU</a>。</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>尽管GPU可以从 CUDA Cores 和 GPU Memory 两个维度来衡量GPU的能力，<strong>在推理的场景，我们可以假定CUDA core的数量和GPU  Memory的大小是成比例的</strong></li><li>设计仍然使用 Extended Resource，只是单位从 <code>number of GPUs</code> 变更为 <code>amount of GPU memory in MiB</code></li><li>在模型开发和推理的场景下，<strong>用户申请的GPU资源不超过1个GPU，也就是说 resource limit 是 一个GPU</strong></li><li>基于k8s原生的Scheduler Extender、Extended Resource、DevicePlugin机制来实现</li></ul><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>设计里定义了两种扩展资源：</p><ul><li><code>gpu-mem</code>： 对应于GPU Memory，如果一个Node有多个GPU设备，这里计算的是总的GPU Memory</li><li><code>gpu-count</code>：对应于GPU 设备的数目</li></ul><p>下图是整个设计的核心组件：</p><ul><li>GPU Share Scheduler Extender：基于k8s scheduler extender机制，作用于调度过程的<code>Filter</code>和<code>Bind</code>阶段，用于决定某个Node上的一个GPU设备是否可以提供足够的GPU Memory，并将GPU分配的结果记录到Pod Spec 的 Annotation中</li><li>GPU Share Device Plugin：基于k8s device plugin机制，根据GPU Share Scheduler Extender记录在Pod Spec的Annotation，实现GPU 设备的 Allocation。</li></ul><p><img alt="GPU Share Design" data-src="https://github.com/AliyunContainerService/gpushare-scheduler-extender/raw/master/docs/designs/arch.jpg"></p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="设备资源报告"><a href="#设备资源报告" class="headerlink" title="设备资源报告"></a>设备资源报告</h4><p><code>GPU Share Device Plugin</code> 基于 <code>nvml</code> 库来查询每个Node上GPU设备的数目和每个GPU设备的GPU Memory。</p><p>这些资源状况被通过 <code>ListAndWatch()</code> 汇报给 Kubelet，然后 kubelet 会上报给 APIServer，这时候执行 <code>kubectl get node</code> 可以看到在 <code>status</code> 看到相关的<code>Extended Resource</code>字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">gpushare:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">172.16</span><span class="number">.1</span><span class="number">.0</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.16</span><span class="number">.1</span><span class="number">.0</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">qcloud:///800002/ins-hsmsc4x9</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">allocatable:</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-count:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-mem:</span> <span class="string">"22"</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">5926m</span></span><br><span class="line">    <span class="attr">ephemeral-storage:</span> <span class="string">"47438316671"</span></span><br><span class="line">    <span class="attr">hugepages-2Mi:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">54222084Ki</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-count:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-mem:</span> <span class="string">"22"</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"6"</span></span><br><span class="line">    <span class="attr">ephemeral-storage:</span> <span class="string">51473868Ki</span></span><br><span class="line">    <span class="attr">hugepages-2Mi:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">57448708Ki</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>用户申请GPU的时候，在 Extended Resource 中只填写 <code>gpu-mem</code>，下面部署一个单机版的Tensorflow：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8888</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">            <span class="attr">aliyun.com/gpu-mem:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">jupyter-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8888</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br></pre></td></tr></table></figure><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><p>当kube-scheduler运行完所有的Filter函数后，就会调用 <code>GPU Share Extender</code> 的 Filter 函数。在原生的过滤中，kube-scheduler会计算是否有足够的Extended Resource（算的是总共的GPU Memory），但是不能知道是否某个GPU设备有足够的资源，这时候就需要调度器插件来实现。以下图为例：</p><ul><li>用户申请了8138MiB的GPU Memory，对于原生调度器，N1节点只剩下  (16276 * 2 - 16276 - 12207 = 4069) 的GPU资源，不满足 Extended Resource可用的条件，N1节点被过滤掉</li><li>接下来的N2节点和N3节点剩余的总的资源数都有8138MiB，那么该选择哪一个呢</li><li>在 <code>GPU Share Extender</code> 的过滤中，他需要找到有单个GPU能够满足用户申请的资源，当检查到N2节点的时候，发现虽然总的GPU Memory有8138MiB，但是每个GPU设备都只剩4096MiB了，不能满足单设备8138的需求，所以N2被过滤掉</li><li>扫描到N3节点，发现GPU0满足8138MiB的需求，符合要求</li></ul><p><img alt data-src="https://github.com/AliyunContainerService/gpushare-scheduler-extender/raw/master/docs/designs/filter.jpg"></p><blockquote><p><strong>这里有一个问题：当一个Node上有多张卡的时候，Scheduler Extender是如何知道每张卡当前可用的Capacity的呢？</strong></p></blockquote><p>我们看一下Extender在 Filter 阶段执行的函数，对于要创建的Pod，当前Node检查自己拥有的所有可用GPU，一旦有一个GPU的可用显存大于申请的显存，那么当前Node是可以被调度的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if the pod can be allocated on the node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">Assume</span><span class="params">(pod *v1.Pod)</span> <span class="params">(allocatable <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">allocatable = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">n.rwmu.RLock()</span><br><span class="line"><span class="keyword">defer</span> n.rwmu.RUnlock()</span><br><span class="line"></span><br><span class="line">availableGPUs := n.getAvailableGPUs()</span><br><span class="line">reqGPU := <span class="keyword">uint</span>(utils.GetGPUMemoryFromPodResource(pod))</span><br><span class="line">log.Printf(<span class="string">"debug: AvailableGPUs: %v in node %s"</span>, availableGPUs, n.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(availableGPUs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> devID := <span class="number">0</span>; devID &lt; <span class="built_in">len</span>(n.devs); devID++ &#123;</span><br><span class="line">availableGPU, ok := availableGPUs[devID]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">if</span> availableGPU &gt;= reqGPU &#123;</span><br><span class="line">allocatable = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> allocatable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的一个问题是，每个Node可用的GPU显存是如何得到的呢？我们进入到 <code>getAvailableGPUs</code> 继续看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">getAvailableGPUs</span><span class="params">()</span> <span class="params">(availableGPUs <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">allGPUs := n.getAllGPUs()</span><br><span class="line">usedGPUs := n.getUsedGPUs()</span><br><span class="line">unhealthyGPUs := n.getUnhealthyGPUs()</span><br><span class="line">availableGPUs = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> id, totalGPUMem := <span class="keyword">range</span> allGPUs &#123;</span><br><span class="line"><span class="keyword">if</span> usedGPUMem, found := usedGPUs[id]; found &#123;</span><br><span class="line">availableGPUs[id] = totalGPUMem - usedGPUMem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: available GPU list %v before removing unhealty GPUs"</span>, availableGPUs)</span><br><span class="line"><span class="keyword">for</span> id, _ := <span class="keyword">range</span> unhealthyGPUs &#123;</span><br><span class="line">log.Printf(<span class="string">"info: delete dev %d from availble GPU list"</span>, id)</span><br><span class="line"><span class="built_in">delete</span>(availableGPUs, id)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: available GPU list %v after removing unhealty GPUs"</span>, availableGPUs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> availableGPUs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Scheduler Extender</code> 内部维护了当前Node上所有的GPU显存状态和已经用了的GPU显存状态信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// device index: gpu memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">getUsedGPUs</span><span class="params">()</span> <span class="params">(usedGPUs <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">usedGPUs = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> n.devs &#123;</span><br><span class="line">usedGPUs[dev.idx] = dev.GetUsedGPUMemory()</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: getUsedGPUs: %v in node %s, and devs %v"</span>, usedGPUs, n.name, n.devs)</span><br><span class="line"><span class="keyword">return</span> usedGPUs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// device index: gpu memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">getAllGPUs</span><span class="params">()</span> <span class="params">(allGPUs <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">allGPUs = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> n.devs &#123;</span><br><span class="line">allGPUs[dev.idx] = dev.totalGPUMem</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: getAllGPUs: %v in node %s, and dev %v"</span>, allGPUs, n.name, n.devs)</span><br><span class="line"><span class="keyword">return</span> allGPUs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>GetUsedGPUMemory</code>，是<code>Scheduler Extender</code> 内部维护的 <code>DeviceInfo</code> 所记录的，这里的 <code>d.podMap</code> 会在每次Extender执行 <code>Bind</code> 的时候，将对应的Pod添加到对应的Node上的 <code>DeviceInfo</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DeviceInfo)</span> <span class="title">GetUsedGPUMemory</span><span class="params">()</span> <span class="params">(gpuMem <span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"debug: GetUsedGPUMemory() podMap %v, and its address is %p"</span>, d.podMap, d)</span><br><span class="line">d.rwmu.RLock()</span><br><span class="line"><span class="keyword">defer</span> d.rwmu.RUnlock()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> d.podMap &#123;</span><br><span class="line"><span class="keyword">if</span> pod.Status.Phase == v1.PodSucceeded || pod.Status.Phase == v1.PodFailed &#123;</span><br><span class="line">log.Printf(<span class="string">"debug: skip the pod %s in ns %s due to its status is %s"</span>, pod.Name, pod.Namespace, pod.Status.Phase)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gpuMem += utils.GetGPUMemoryFromPodEnv(pod)</span></span><br><span class="line">gpuMem += utils.GetGPUMemoryFromPodAnnotation(pod)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gpuMem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再总结总结，本质上是 <code>Scheduler Extender</code> 维护了一个 <code>devs</code> 这么一个数据结构，使得它可以知道当前Node上每个GPU设备的显存状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeInfo is node level aggregated information.</span></span><br><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">name           <span class="keyword">string</span></span><br><span class="line">node           *v1.Node</span><br><span class="line">devs           <span class="keyword">map</span>[<span class="keyword">int</span>]*DeviceInfo</span><br><span class="line">gpuCount       <span class="keyword">int</span></span><br><span class="line">gpuTotalMemory <span class="keyword">int</span></span><br><span class="line">rwmu           *sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，我们通过ApiServer，只能知道对应Node上的 <code>gpuCount</code> 和 <code>gpuTotalMemory</code>，而不知道每张卡各自的显存的。这个 <code>devs</code> 是怎么初始化得到每张卡的显存信息呢的呢？继续看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create Node Level</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNodeInfo</span><span class="params">(node *v1.Node)</span> *<span class="title">NodeInfo</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"debug: NewNodeInfo() creates nodeInfo for %s"</span>, node.Name)</span><br><span class="line"></span><br><span class="line">devMap := <span class="keyword">map</span>[<span class="keyword">int</span>]*DeviceInfo&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; utils.GetGPUCountInNode(node); i++ &#123;</span><br><span class="line">devMap[i] = newDeviceInfo(i, <span class="keyword">uint</span>(utils.GetTotalGPUMemory(node)/utils.GetGPUCountInNode(node)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(devMap) == <span class="number">0</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"warn: node %s with nodeinfo %v has no devices"</span>,</span><br><span class="line">node.Name,</span><br><span class="line">node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;NodeInfo&#123;</span><br><span class="line">name:           node.Name,</span><br><span class="line">node:           node,</span><br><span class="line">devs:           devMap,</span><br><span class="line">gpuCount:       utils.GetGPUCountInNode(node),</span><br><span class="line">gpuTotalMemory: utils.GetTotalGPUMemory(node),</span><br><span class="line">rwmu:           <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里在初始化的时候，默认设定每张GPU卡的显存大小一样，通过平均得到每张卡的心存信息。</p><h5 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h5><ul><li>当调度器发现有Node符合要求，这时候会把Pod和Node Bind到一起，<code>GPU Share Extender</code> 需要做两件事情：<ul><li>根据 <code>binpack</code> 原则找到Node上对应的GPU设备，并将 GPU Device ID记录到 Pod的 Annotation中 <code>ALIYUN_GPU_ID</code>。他也会将Pod使用的GPU Memory记录到Pod Annotation中：<code>ALIYUN_COM_GPU_MEM_POD</code> 和 <code>ALIYUN_COM_GPU_MEM_ASSUME_TIME</code></li><li>Bind the Node and Pod with kubernetes API</li></ul></li><li>如果没有找到合适的Node符合要求，那么就不会做Bind操作</li></ul><p>以下图为例，N1中有4个GPU，其中GPU0（12207），GPU1（8138）、GPU2（4069）和GPU3（16276）, GPU2因为资源不够被过滤掉，剩下的3个GPU根据 Binpack 原则，我们选用GPU1（图里面 Annotation错了，不是0，而是1）</p><p><img alt data-src="https://github.com/AliyunContainerService/gpushare-scheduler-extender/raw/master/docs/designs/bind.jpg"></p><p>我们看一看在找GPU设备的时候是如何操作的，可以看到这里通过 <code>candidateGPUMemory &gt; availableGPU</code> 这里实现了 <code>binpack</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate the GPU ID to the pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">allocateGPUID</span><span class="params">(pod *v1.Pod)</span> <span class="params">(candidateDevID <span class="keyword">int</span>, found <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">reqGPU := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line">found = <span class="literal">false</span></span><br><span class="line">candidateDevID = <span class="number">-1</span></span><br><span class="line">candidateGPUMemory := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line">availableGPUs := n.getAvailableGPUs()</span><br><span class="line"></span><br><span class="line">reqGPU = <span class="keyword">uint</span>(utils.GetGPUMemoryFromPodResource(pod))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reqGPU &gt; <span class="keyword">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">log.Printf(<span class="string">"info: reqGPU for pod %s in ns %s: %d"</span>, pod.Name, pod.Namespace, reqGPU)</span><br><span class="line">log.Printf(<span class="string">"info: AvailableGPUs: %v in node %s"</span>, availableGPUs, n.name)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(availableGPUs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> devID := <span class="number">0</span>; devID &lt; <span class="built_in">len</span>(n.devs); devID++ &#123;</span><br><span class="line">availableGPU, ok := availableGPUs[devID]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">if</span> availableGPU &gt;= reqGPU &#123;</span><br><span class="line"><span class="keyword">if</span> candidateDevID == <span class="number">-1</span> || candidateGPUMemory &gt; availableGPU &#123;</span><br><span class="line">candidateDevID = devID</span><br><span class="line">candidateGPUMemory = availableGPU</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">found = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line">log.Printf(<span class="string">"info: Find candidate dev id %d for pod %s in ns %s successfully."</span>,</span><br><span class="line">candidateDevID,</span><br><span class="line">pod.Name,</span><br><span class="line">pod.Namespace)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"warn: Failed to find available GPUs %d for the pod %s in the namespace %s"</span>,</span><br><span class="line">reqGPU,</span><br><span class="line">pod.Name,</span><br><span class="line">pod.Namespace)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> candidateDevID, found</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Node上运行Deployment"><a href="#在Node上运行Deployment" class="headerlink" title="在Node上运行Deployment"></a>在Node上运行Deployment</h4><p>接下来由Kubelet在创建container前调用 <code>GPU Share Device Plugin</code> 的 <code>Allocate</code> 函数，参数是申请的GPU Memory的数量。</p><p>Pod运行成功后，执行 <code>kubectl get pod</code> 可以看到：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_ASSIGNED:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_ASSUME_TIME:</span> <span class="string">"1606125285243248618"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_DEV:</span> <span class="string">"22"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_IDX:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_POD:</span> <span class="string">"3"</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><ul><li><p>Device Plugin 从 k8s apiserver 拿到所有Pending的Pod中属于GPU Share的Pod，并且按照 AssumedTimestamp排序</p></li><li><p>选择符合Allocation传入的GPU Memory的Pod，如果有多个，选择最早的那个Pod</p></li><li><p>标记 <code>ALIYUN_COM_GPU_MEM_ASSIGNED</code> 为 True</p></li><li><p>把 DeviceID 作为下NVIDIA_VISIBLE_DEVICES环境变量告诉 Nvidia Docker2，并且创建容器</p></li></ul><p><img alt data-src="https://github.com/AliyunContainerService/gpushare-scheduler-extender/raw/master/docs/designs/sequence.jpg"></p><blockquote><p><strong>这里问题是device plugin的allocate接口参数是什么，是否包含pod信息，是否包含pod annotation？</strong></p></blockquote><p>查看 Device Plugin 的代码，这一个申请的GPU Memory的数量让我很疑惑，为何要这么算？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line">podReqGPU += <span class="keyword">uint</span>(<span class="built_in">len</span>(req.DevicesIDs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>Device Plugin</code> 的 <code>DeviceIDs</code> 是如何生成的。这里调用了 <code>nvml library</code> 可以探测到本Node上拥有的GPU有多少个，每个显存是多少。接下来 <code>Device Plugin</code> 会创建一系列的 <code>FakeDeviceID</code>，并将这个DeviceIDs返回给 Kubelet，这就解释了为什么要通过上面的方法计算申请的 GPU Memory，这里的Memory以MiB为单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDevices</span><span class="params">()</span> <span class="params">([]*pluginapi.Device, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">n, err := nvml.GetDeviceCount()</span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> devs []*pluginapi.Device</span><br><span class="line">realDevNames := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uint</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">d, err := nvml.NewDevice(i)</span><br><span class="line">check(err)</span><br><span class="line"><span class="comment">// realDevNames = append(realDevNames, d.UUID)</span></span><br><span class="line"><span class="keyword">var</span> id <span class="keyword">uint</span></span><br><span class="line">log.Infof(<span class="string">"Deivce %s's Path is %s"</span>, d.UUID, d.Path)</span><br><span class="line">_, err = fmt.Sscanf(d.Path, <span class="string">"/dev/nvidia%d"</span>, &amp;id)</span><br><span class="line">check(err)</span><br><span class="line">realDevNames[d.UUID] = id</span><br><span class="line"><span class="comment">// var KiB uint64 = 1024</span></span><br><span class="line">log.Infof(<span class="string">"# device Memory: %d"</span>, <span class="keyword">uint</span>(*d.Memory))</span><br><span class="line"><span class="keyword">if</span> getGPUMemory() == <span class="keyword">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">setGPUMemory(<span class="keyword">uint</span>(*d.Memory))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">uint</span>(<span class="number">0</span>); j &lt; getGPUMemory(); j++ &#123;</span><br><span class="line">fakeID := generateFakeDeviceID(d.UUID, j)</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">log.Infoln(<span class="string">"# Add first device ID: "</span> + fakeID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j == getGPUMemory()<span class="number">-1</span> &#123;</span><br><span class="line">log.Infoln(<span class="string">"# Add last device ID: "</span> + fakeID)</span><br><span class="line">&#125;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     fakeID,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> devs, realDevNames</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下 <code>Device Plugin</code> 是如何找到对应的Pod的，可以看到一旦碰到有Pod申请的GPU显存与Kubelet传入的显存大小一致，那么则找到对应的Pod了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pods, err := getCandidatePods()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Infof(<span class="string">"invalid allocation requst: Failed to find candidate pods due to %v"</span>, err)</span><br><span class="line">   <span class="keyword">return</span> buildErrResponse(reqs, podReqGPU), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">   <span class="keyword">if</span> getGPUMemoryFromPodResource(pod) == podReqGPU &#123;</span><br><span class="line">      log.Infof(<span class="string">"Found Assumed GPU shared Pod %s in ns %s with GPU Memory %d"</span>,</span><br><span class="line">         pod.Name,</span><br><span class="line">         pod.Namespace,</span><br><span class="line">         podReqGPU)</span><br><span class="line">      assumePod = pod</span><br><span class="line">      found = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>getCandidatePods</code>就是List所有Pending的Pod中 Assume Memory的，并且按照时间排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pick up the gpushare pod with assigned status is false, and</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCandidatePods</span><span class="params">()</span> <span class="params">([]*v1.Pod, error)</span></span> &#123;</span><br><span class="line">candidatePods := []*v1.Pod&#123;&#125;</span><br><span class="line">allPods, err := getPendingPodsInNode()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> candidatePods, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> allPods &#123;</span><br><span class="line">current := pod</span><br><span class="line"><span class="keyword">if</span> isGPUMemoryAssumedPod(&amp;current) &#123;</span><br><span class="line">candidatePods = <span class="built_in">append</span>(candidatePods, &amp;current)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> makePodOrderdByAge(candidatePods), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="腾讯GPUManager"><a href="#腾讯GPUManager" class="headerlink" title="腾讯GPUManager"></a>腾讯GPUManager</h2><p>GPU Manager 提供一个 All-in-One 的 GPU 管理器，基于 Kubernetes DevicePlugin 插件系统实现，该管理器提供了分配并共享 GPU、GPU 指标查询、容器运行前的 GPU 相关设备准备等功能，支持用户在 Kubernetes 集群中使用 GPU 设备。</p><ul><li><strong>拓扑分配</strong>：提供基于 GPU 拓扑分配功能，当用户分配超过1张 GPU 卡的应用，可以选择拓扑连接最快的方式分配 GPU 设备。</li><li><strong>GPU 共享</strong>：允许用户提交小于1张卡资源的任务，并提供 QoS 保证。</li><li><strong>应用 GPU 指标的查询</strong>：用户可以访问主机端口（默认为 5678）的 <code>/metrics</code> 路径，可以为 Prometheus 提供 GPU 指标的收集功能，访问 <code>/usage</code> 路径可以进行可读性的容器状况查询。</li></ul><h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><h3 id="核心组件-1"><a href="#核心组件-1" class="headerlink" title="核心组件"></a>核心组件</h3><p>GPUManager 主要由两个部分组成：</p><ul><li><code>gpu-quota-admission</code> ：调度器插件，提供GPU的调度相关的增强功能</li><li><code>gpu-manager-daemonset</code> ： DevicePlugin 插件，提供容器使用GPU相关的功能</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-19_gpu-manager.png"></p><h4 id="gpu-quota-admission"><a href="#gpu-quota-admission" class="headerlink" title="gpu-quota-admission"></a>gpu-quota-admission</h4><p>该组件为调度器插件, 用于提供GPU的调度相关的增强功能. 增强功能包含:</p><ul><li>根据用户卡型号以及资源池的quota配置提供调度准入功能</li></ul><p>用户可以在原来的quota维度下划分更细致的调度准入维度, 例如用户有10张卡的配额, 那么在此基础上可以更细致的划分为P系列3张卡, M系列5张卡, K系列2张卡。通过用户配置一个Configmap, <code>card quota controller</code>就可以计算出每个namespace下使用了各种型号的GPU设备的数量, 在调度的时候就可以实现按照资源池及GPU型号进行策略调度. 例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"A"</span>: &#123;</span><br><span class="line">    <span class="attr">"pool"</span>: [</span><br><span class="line">      <span class="string">"public"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"quota"</span>: &#123;</span><br><span class="line">      <span class="attr">"M40"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"P100"</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"B"</span>: &#123;</span><br><span class="line">    <span class="attr">"pool"</span>: [</span><br><span class="line">      <span class="string">"wx"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"quota"</span>: &#123;</span><br><span class="line">      <span class="attr">"M40"</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"P100"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GPU共享的调度</li></ul><p>默认的Kubernetes的GPU使用最小粒度为1张卡, 配合GPU Manager组件, 可以为集群提供更小粒度的GPU资源使用调度策略。为此我们增加了GPU predicate controller来尽可能的降低系统默认调度策略带来的碎片化问题。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-19_gpu-manager-predicate.png"></p><h4 id><a href="#" class="headerlink" title=" "></a> </h4><h4 id="gpu-manager-daemonset"><a href="#gpu-manager-daemonset" class="headerlink" title="gpu-manager-daemonset"></a>gpu-manager-daemonset</h4><p>该组件为DevicePlugin的一种GPU插件, 提供容器使用GPU相关的功能：</p><ul><li><p>拓扑感知分配</p><p>拓扑感知分配, 用于用户单机多卡时, 分配通信代价最小的GPU卡, 避免由于通信开销导致的计算能力下降</p></li><li><p>多容器GPU共享</p><p>该功能用于提供多个容器在同一张卡运行的能力, 同时保证各个容器的QoS, 并且支持使用率的动态调整</p></li><li><p>容器内指标查询与收集</p><p>该功能提供Prometheus的GPU相关指标(利用率,显存使用大小), 方便用户指标展示以及使用基于指标的自动扩缩容功能</p></li><li><p>GPU相关的特殊设备使用(RDMA等)</p><p>该功能可以提供GPU容器使用RDMA等设备的挂载</p></li></ul><p>GPUManager使用了原生的<code>runc</code>，但是Nvidia使用了自己的<code>runc</code>。</p><h5 id="topology-awareness-allocator"><a href="#topology-awareness-allocator" class="headerlink" title="topology awareness allocator"></a>topology awareness allocator</h5><p>该模块提供基于GPU拓扑分配的一个功能, 因为GPU设备的特殊性, GPU之间的通信需要经过不同的switch或者socket-level link。不同的GPU选择会对单机多卡程序peer to peer的数据拷贝带来延迟, <code>Topology awareness allocator</code>通过2种不同的分配算法来尽可能的减少这种延迟。</p><h5 id="visualization-manager"><a href="#visualization-manager" class="headerlink" title="visualization manager"></a>visualization manager</h5><p>GaiaStack 的 GPU 共享提供的是不同于NVIDIA的vGPU(高隔离)和MPS(低隔离)的一种设计, 并且本身提供一个QoS保障, 因此需要一个特殊的管理器来管理使用共享功能的GPU容器。</p><h5 id="driver-volume-manager"><a href="#driver-volume-manager" class="headerlink" title="driver volume manager"></a>driver volume manager</h5><p>该管理器用来提供GPU容器运行时需要的底层CUDA Driver, 这个管理器我们借鉴的是<code>nvidia-docker</code> 1.0中的volume的设计. Kubernetes DevicePlugin的接口说明允许给容器增加可挂载的Volume和环境变量, 因此管理器通过在Allocate阶段给GPU容器配置一个volume挂载点来提供CUDA Driver以及配置环境变量LD_LIBRARY_PATH告诉应用哪里去search CUDA Driver</p><h4 id="vCUDA-controller"><a href="#vCUDA-controller" class="headerlink" title="vCUDA controller"></a>vCUDA controller</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender/blob/master/docs/designs/designs.md" target="_blank" rel="external nofollow noopener noreferrer">阿里GPUShare设计文档</a></li><li><a href="https://www.alibabacloud.com/help/zh/doc-detail/163994.htm" target="_blank" rel="external nofollow noopener noreferrer">阿里共享调度</a></li><li><a href="http://km.oa.com/group/597/articles/show/388457" target="_blank" rel="external nofollow noopener noreferrer">Gaia GPUManager介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生的 k8s 基于 &lt;code&gt;Device Plugin&lt;/code&gt; 和 &lt;code&gt;Extended Resource&lt;/code&gt; 机制实现了在容器中使用GPU，但是只支持GPU的独占使用，不允许在Pod间共享GPU，这大大降低了对集群中GPU的利用率。为了在集群层面共享GPU，我们需要实现GPU资源的隔离与调度，本文将依次介绍阿里的 &lt;a href=&quot;https://github.com/AliyunContainerService/gpushare-scheduler-extender&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GPUShare&lt;/a&gt; 与腾讯的 &lt;a href=&quot;https://github.com/tkestack/gpu-manager&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GPUManager&lt;/a&gt;，分析其实现机制。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://github.com/AliyunContainerService/gpushare-scheduler-extender/raw/master/docs/designs/arch.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="device plugin" scheme="http://houmin.cc/tags/device-plugin/"/>
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="资源隔离" scheme="http://houmin.cc/tags/%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/"/>
    
      <category term="scheduler extender" scheme="http://houmin.cc/tags/scheduler-extender/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】在Docker中使用GPU</title>
    <link href="http://houmin.cc/posts/574111db/"/>
    <id>http://houmin.cc/posts/574111db/</id>
    <published>2020-11-17T12:45:00.000Z</published>
    <updated>2020-11-23T05:29:01.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们在 <a href="https://houmin.cc/posts/5004f8e5/">GPU 与 CUDA 编程入门</a> 这篇博客中初步介绍了如何Linux上使用GPU的方法，随着容器和k8s的迅猛发展，人们对于在容器中使用GPU的需求越发强烈。本文将基于前文，继续介绍如何在容器中使用GPU，进一步地，介绍在Kubernetes中如何调度GPU，并以Tensorflow为例，介绍如何基于Docker搭建部署了GPU的深度学习开发环境。</p><a id="more"></a><h2 id="NVIDIA-Container-Toolkit"><a href="#NVIDIA-Container-Toolkit" class="headerlink" title="NVIDIA Container Toolkit"></a>NVIDIA Container Toolkit</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>容器最早是用于无缝部署基于CPU的应用，它们对于硬件和平台是无感知的，但是显然这种使用场景对于GPU并不适用。对于不同的GPU，需要机器安装不同的硬件驱动，这极大限制了在容器中使用GPU。为了解决这个问题，最早的一种使用方法是在容器中完全重新安装一次NVIDIA驱动，然后将在容器启动的时候将GPU以字符设备 <code>/dev/nvidia0</code> 的方式传递给容器。然而这种方法要求容器中安装的驱动版本与Host上的驱动版本完全一致，同一个Docker Image不能在各个机器上复用，这极大的限制了容器的扩展性。</p><p>为了解决上述问题，容器必须对于 NVIDIA 驱动是无感知的，基于此 NVIDIA 推出了 <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA Container Toolkit</a>：</p><p><img alt="nvidia-gpu-docker" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_nvidia-gpu-docker.png"></p><p>如上图所示， NVIDIA 将原来 CUDA 应用依赖的API环境划分为两个部分：</p><ul><li>驱动级API：由<code>libcuda.so.major.minor</code>动态库和内核module提供支持，图中表示为CUDA Driver<ul><li>驱动级API属于底层API，每当NVIDIA公司释放出某一个版本的驱动时，如果你要升级主机上的驱动，那么内核模块和<code>libcuda.so.major.minor</code>这2个文件就必须同时升级到同一个版本，这样原有的程序才能正常工作,</li><li>不同版本的驱动不能同时存在于宿主机上</li></ul></li><li>非驱动级API：由动态库<code>libcublas.so</code>等用户空间级别的API组成，图中表示为CUDA Toolkit<ul><li>非驱动级API的版本号是以Toolkit自身的版本号来管理, 比如cuda-10，cuda-11</li><li>不同版本的Toolkit可以同时运行在相同的宿主机上</li><li>非驱动级API算是对驱动级API的一种更高级的封装,最终还是要调用驱动级API来实现功能</li></ul></li></ul><p>为了让使用GPU的容器更具可扩展性，关于非驱动级的API被 NVIDIA 打包进了  <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA Container Toolkit</a>，因此在容器中使用GPU之前，每个机器需要先安装好NVIDIA驱动，之后配置好 NVIDIA Container Toolkit之后，就可以在容器中方便使用GPU了。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>NVIDIA 的容器工具包本质是使用一个<code>nvidia-runc</code>的方式来提供GPU容器的创建, 在用户创建出来的OCI spec上补上几个hook函数，来达到GPU设备运行的准备工作。具体包括以下几个组件，从上到下展示如图：</p><ul><li><code>nvidia-docker2</code></li><li><code>nvidia-container-runtime</code></li><li><code>nvidia-container-toolkit</code></li><li><code>libnvidia-container</code></li></ul><p><img alt data-src="https://docs.nvidia.com/datacenter/cloud-native/_images/nvidia-docker-arch.png"></p><p>下面对这几个组件依次介绍：</p><h4 id="libnvidia-container"><a href="#libnvidia-container" class="headerlink" title="libnvidia-container"></a><code>libnvidia-container</code></h4><p>This component provides a library and a simple CLI utility to automatically configure GNU/Linux containers leveraging NVIDIA GPUs. The implementation relies on kernel primitives and is designed to be agnostic of the container runtime.</p><p><code>libnvidia-container</code> provides a well-defined API and a wrapper CLI (called <code>nvidia-container-cli</code>) that different runtimes can invoke to inject NVIDIA GPU support into their containers.</p><h4 id="nvidia-container-toolkit"><a href="#nvidia-container-toolkit" class="headerlink" title="nvidia-container-toolkit"></a><code>nvidia-container-toolkit</code></h4><p>This component includes a script that implements the interface required by a <code>runC</code> <code>prestart</code> hook. This script is invoked by <code>runC</code> after a container has been created, but before it has been started, and is given access to the <code>config.json</code> associated with the container (e.g. this <a href="https://github.com/opencontainers/runtime-spec/blob/master/config.md#configuration-schema-example=" target="_blank" rel="external nofollow noopener noreferrer">config.json</a> ). It then takes information contained in the <code>config.json</code> and uses it to invoke the <code>libnvidia-container</code> CLI with an appropriate set of flags. One of the most important flags being which specific GPU devices should be injected into the container.</p><p>Note that the previous name of this component was <code>nvidia-container-runtime-hook</code>. <code>nvidia-container-runtime-hook</code> is now simply a symlink to <code>nvidia-container-toolkit</code> on the system.</p><h4 id="nvidia-container-runtime"><a href="#nvidia-container-runtime" class="headerlink" title="nvidia-container-runtime"></a><code>nvidia-container-runtime</code></h4><p>This component used to be a complete fork of <code>runC</code> with NVIDIA specific code injected into it. Since 2019, it is a thin wrapper around the native <code>runC</code> installed on the host system. <code>nvidia-container-runtime</code> takes a <code>runC</code> spec as input, injects the <code>nvidia-container-toolkit</code> script as a <code>prestart</code> hook into it, and then calls out to the native <code>runC</code>, passing it the modified <code>runC</code> spec with that hook set. It’s important to note that this component is not necessarily specific to docker (but it is specific to <code>runC</code>).</p><p>When the package is installed, the Docker <code>daemon.json</code> is updated to point to the binary as can be seen below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"default-runtime"</span>: <span class="string">"nvidia"</span>,</span><br><span class="line"><span class="string">"runtimes"</span>: &#123;</span><br><span class="line">    <span class="string">"nvidia"</span>: &#123;</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">        <span class="string">"runtimeArgs"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nvidia-docker2"><a href="#nvidia-docker2" class="headerlink" title="nvidia-docker2"></a><code>nvidia-docker2</code></h4><p>This package is the only docker-specific package of the hierarchy. It takes the script associated with the <code>nvidia-container-runtime</code> and installs it into docker’s <code>/etc/docker/daemon.json</code> file. This then allows you to run (for example) <code>docker run --runtime=nvidia ...</code> to automatically add GPU support to your containers. It also installs a wrapper script around the native docker CLI called <code>nvidia-docker</code> which lets you invoke docker without needing to specify <code>--runtime=nvidia</code> every single time. It also lets you set an environment variable on the host (<code>NV_GPU</code>) to specify which GPUs should be injected into a container.</p><h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><p>这里仍然基于腾讯云的 CentOS 7机器为例演示如何在安装配置 <code>NVIDIA Container Toolkit</code>，对于更多的平台可以参考其<a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>。</p><h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://get.docker.com | sh \</span><br><span class="line">  &amp;&amp; sudo systemctl start docker \</span><br><span class="line">  &amp;&amp; sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h4 id="安装-NVIDIA-Container-Toolkit"><a href="#安装-NVIDIA-Container-Toolkit" class="headerlink" title="安装 NVIDIA Container Toolkit"></a>安装 NVIDIA Container Toolkit</h4><p>Setup the <code>stable</code> repository and the GPG key:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br></pre></td></tr></table></figure><p>Install the <code>nvidia-docker2</code> package (and dependencies) after updating the package listing:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y nvidia-docker2</span><br></pre></td></tr></table></figure><p>Restart the Docker daemon to complete the installation after setting the default runtime:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>At this point, a working setup can be tested by running a base CUDA container:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure><p>This should result in a console output shown below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 450.51.06    Driver Version: 450.51.06    CUDA Version: 11.0     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla T4            On   | 00000000:00:1E.0 Off |                    0 |</span><br><span class="line">| N/A   34C    P8     9W /  70W |      0MiB / 15109MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h4 id="配置-NVIDIA-Runtime"><a href="#配置-NVIDIA-Runtime" class="headerlink" title="配置 NVIDIA Runtime"></a>配置 NVIDIA Runtime</h4><p>To register the <code>nvidia</code> runtime, use the method below that is best suited to your environment. You might need to merge the new argument with your existing configuration. Three options are available:</p><h4 id="Systemd-drop-in-file"><a href="#Systemd-drop-in-file" class="headerlink" title="Systemd drop-in file"></a>Systemd drop-in file</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>docker.service.d</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>docker.service.d/override.conf &lt;&lt;EOF</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=<span class="regexp">/usr/</span>bin<span class="regexp">/dockerd --host=fd:/</span><span class="regexp">/ --add-runtime=nvidia=/</span>usr<span class="regexp">/bin/</span>nvidia-container-runtime</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload \</span><br><span class="line">  &amp;&amp; sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="Daemon-configuration-file"><a href="#Daemon-configuration-file" class="headerlink" title="Daemon configuration file"></a>Daemon configuration file</h4><p>The <code>nvidia</code> runtime can also be registered with Docker using the <code>daemon.json</code> configuration file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="string">"nvidia"</span>: &#123;</span><br><span class="line">            <span class="string">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">            <span class="string">"runtimeArgs"</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -SIGHUP dockerd</span><br></pre></td></tr></table></figure><p>You can optionally reconfigure the default runtime by adding the following to <code>/etc/docker/daemon.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"default-runtime"</span>: <span class="string">"nvidia"</span></span><br></pre></td></tr></table></figure><h4 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h4><p>Use <code>dockerd</code> to add the <code>nvidia</code> runtime:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime [...]</span><br></pre></td></tr></table></figure><h2 id="在k8s中管理GPU"><a href="#在k8s中管理GPU" class="headerlink" title="在k8s中管理GPU"></a>在k8s中管理GPU</h2><p>为了在 k8s 中管理和使用GPU，我们除了需要配置 <code>NVIDIA Container Toolkit</code>，还需要安装NVIDIA推出的 <a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA/k8s-device-plugin</a>，具体安装可以参考 <a href="../3f069334">我的这篇博文</a>。上面的步骤加起来显得还是有些繁琐，如果你直接使用腾讯云 TKE 的话，在集群添加装有GPU的Node时候，就会自动帮你安装配置好  <code>NVIDIA Container Toolkit</code> 和  <code>NVIDIA/k8s-device-plugin</code>，十分方便。接下来我们以Tensorflow为例，演示在 k8s 环境运行有GPU的Tensorflow。</p><h3 id="单机版Tensorflow"><a href="#单机版Tensorflow" class="headerlink" title="单机版Tensorflow"></a>单机版Tensorflow</h3><p>首先是单机版的Tensorflow，执行 <code>kubectl apply -f tensorflow.yaml</code>来运行 <code>Jupiter Notebook</code>。</p><figure class="highlight yaml"><figcaption><span>tensorflow.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8888</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">jupyter-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8888</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br></pre></td></tr></table></figure><p>我们看到容器很快运行起来，根据 <code>http:&lt;nodeIP&gt;:&lt;nodePort&gt;</code> 可以访问到 <code>Jupiter Notebook</code>，但是显示需要token：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_tensorflow-jupiter.png"></p><p>查看 <code>Tensorflow</code> 日志，可以获得 token：<code>aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos single]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">tensorflow-6cbc85744b-c567p   1/1     Running   0          7m37s</span><br><span class="line">[root@VM-1-14-centos single]<span class="comment"># kubectl logs tensorflow-6cbc85744b-c567p</span></span><br><span class="line"></span><br><span class="line">________                               _______________</span><br><span class="line">___  __/__________________________________  ____/__  /________      __</span><br><span class="line">__  /  _  _ \_  __ \_  ___/  __ \_  ___/_  /_   __  /_  __ \_ | /| / /</span><br><span class="line">_  /   /  __/  / / /(__  )/ /_/ /  /   _  __/   _  / / /_/ /_ |/ |/ /</span><br><span class="line">/_/    \___//_/ /_//____/ \____//_/    /_/      /_/  \____/____/|__/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WARNING: You are running this container as root, <span class="built_in">which</span> can cause new files <span class="keyword">in</span></span><br><span class="line">mounted volumes to be created as the root user on your host machine.</span><br><span class="line"></span><br><span class="line">To avoid this, run the container by specifying your user<span class="string">'s userid:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ docker run -u $(id -u):$(id -g) args...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[I 04:47:52.083 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] Serving notebooks from local directory: /tf</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] Jupyter Notebook 6.1.4 is running at:</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] http://tensorflow-6cbc85744b-c567p:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp]  or http://127.0.0.1:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span></span><br><span class="line"><span class="string">[C 04:47:52.319 NotebookApp]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To access the notebook, open this file in a browser:</span></span><br><span class="line"><span class="string">        file:///root/.local/share/jupyter/runtime/nbserver-1-open.html</span></span><br><span class="line"><span class="string">    Or copy and paste one of these URLs:</span></span><br><span class="line"><span class="string">        http://tensorflow-6cbc85744b-c567p:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">     or http://127.0.0.1:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">[I 04:49:28.692 NotebookApp] 302 GET / (172.16.0.193) 0.57ms</span></span><br><span class="line"><span class="string">[I 04:49:28.700 NotebookApp] 302 GET /tree? (172.16.0.193) 0.67ms</span></span><br></pre></td></tr></table></figure><p>登陆之后即可看到 <code>Jupiter Notebook</code>：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_tensorflow-jupiter.png"></p><p>新建Notebook，运行命令如下：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_tensorflow-gpu.png"></p><p>可以看到，TensorFlow 支持在GPU上的运算</p><ul><li><code>&quot;/device:GPU:0&quot;</code>：TensorFlow 可见的机器上第一个 GPU 的速记表示法。</li><li><code>&quot;/job:localhost/replica:0/task:0/device:GPU:0&quot;</code>：TensorFlow 可见的机器上第一个 GPU 的完全限定名称。</li></ul><h3 id="分布式Tensorflow"><a href="#分布式Tensorflow" class="headerlink" title="分布式Tensorflow"></a>分布式Tensorflow</h3><p>整体架构：</p><p>这个架构图是分布式tensorflow的实战图，其中有</p><ul><li>两个参数服务</li><li>多个worker服务</li><li>还有个shuffle和抽样的服务</li></ul><p>shuffle就是对样根据其标签进行混排，然后对外提供batch抽样服务（可以是有放回和无放回，抽样是一门科学，详情可以参考抽样技术一书），每个batch的抽样是由每个worker去触发，worker拿到抽样的数据样本ID后就去基于kubernetes构建的分布式数据库里边提取该batchSize的样本数据，进行训练计算，由于分布式的tensorflow能够保证异步梯度下降算法，所以每次训练batch数据的时候都会基于最新的参数迭代，然而，更新参数操作就是两个参数服务做的，架构中模型（参数）的存储在NFS中，这样以来，参数服务与worker就可以共享参数了，最后说明一下，我们训练的所有数据都是存储在分布式数据库中（数据库的选型可以根据具体的场景而定）。为什么需要一个shuffle和抽样的服务，因为当数据量很大的时候，我们如果对所有的样本数据进行shuffle和抽样计算的话会浪费很大的资源，因此需要一个这样的服务专门提取数据的（id，label）来进行混排和抽样，这里如果（id, label）的数据量也很大的时候我们可以考虑基于spark 来分布式的进行shuffle和抽样，目前spark2.3已经原生支持kubernetes调度</p><p><img alt data-src="https://upload-images.jianshu.io/upload_images/3521279-7ab3727232db8073.png"></p><p>首先是 <code>Parameter Server</code>：</p><figure class="highlight yaml"><figcaption><span>tf-ps.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">ps</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ps</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2222</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/datanfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">nfs:</span></span><br><span class="line">          <span class="attr">server:</span> <span class="string">你的nfs服务地址</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">"/data/nfs"</span>   </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-ps-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2222</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">2222</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br></pre></td></tr></table></figure><p>然后是 <code>Worker</code>：</p><figure class="highlight yaml"><figcaption><span>tf-worker.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">worker</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">worker</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2222</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/datanfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">nfs:</span></span><br><span class="line">          <span class="attr">server:</span> <span class="string">你的nfs服务地址</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">"/data/nfs"</span>   </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-wk-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2222</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">2222</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1005137" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1005137</a></li><li><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA Container Toolkit</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在 &lt;a href=&quot;https://houmin.cc/posts/5004f8e5/&quot;&gt;GPU 与 CUDA 编程入门&lt;/a&gt; 这篇博客中初步介绍了如何Linux上使用GPU的方法，随着容器和k8s的迅猛发展，人们对于在容器中使用GPU的需求越发强烈。本文将基于前文，继续介绍如何在容器中使用GPU，进一步地，介绍在Kubernetes中如何调度GPU，并以Tensorflow为例，介绍如何基于Docker搭建部署了GPU的深度学习开发环境。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_nvidia-gpu-docker.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="container" scheme="http://houmin.cc/tags/container/"/>
    
      <category term="docker" scheme="http://houmin.cc/tags/docker/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="Nvidia" scheme="http://houmin.cc/tags/Nvidia/"/>
    
      <category term="tensorflow" scheme="http://houmin.cc/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】Device Plugin</title>
    <link href="http://houmin.cc/posts/3f069334/"/>
    <id>http://houmin.cc/posts/3f069334/</id>
    <published>2020-11-16T07:31:42.000Z</published>
    <updated>2020-11-23T12:30:39.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes 原生支持对于CPU和内存资源的发现，但是有很多其他的设备 kubelet不能原生处理，比如GPU、FPGA、RDMA、存储设备和其他类似的异构计算资源设备。为了能够使用这些设备资源，我们需要进行各个设备的初始化和设置。按照 Kubernetes 的 <code>OutOfTree</code> 的哲学理念，我们不应该把各个厂商的设备初始化设置相关代码与 Kubernetes 核心代码放在一起。与之相反，我们需要一种机制能够让各个设备厂商向 Kubelet 上报设备资源，而不需要修改 Kubernetes 核心代码。这即是 <code>Device Plugin</code> 这一机制的来源，本文将介绍 Device Plugin 的实现原理，并介绍其使用。</p><a id="more"></a><h2 id="Device-插件原理"><a href="#Device-插件原理" class="headerlink" title="Device 插件原理"></a>Device 插件原理</h2><p>Device Plugin 实际上是一个 gPRC server，Device 插件一般推荐使用 DaemonSet 的方式部署，并将 <code>/var/lib/kubelet/device-plugins</code> 以 Volume 的形式挂载到容器中。当然，也可以手动运行的方式来部署，但这样就没有失败自动恢复的功能了。</p><p>为了能够使用某个厂商的特定设备，一般有两步：</p><ul><li><code>kubectl create -f http://vendor.com/device-plugin-daemonset.yaml</code></li><li>执行 <code>kubectl describe nodes</code>的时候，相关设备会出现在node status中：<code>vendor-domain/vendor-device</code></li></ul><p>当 Device Plugin 向 kubelet 注册后，kubelet 就通过 RPC 与 Device Plugin 交互：</p><ul><li><code>ListAndWatch()</code> ：让 kubelet 发现设备资源和对应属性，并且在设备资源发生变动的时候接收通知</li><li><code>Allocate()</code> ：kubelet 在创建容器前通过 Allocate来申请相关设备资源</li></ul><p><img alt="Process" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_k8s-device-plugin.png"></p><h3 id="Registration"><a href="#Registration" class="headerlink" title="Registration"></a>Registration</h3><p>为了向 kubelet 告知 Device Plugin 的存在，Device Plugin 必须向 kubelet 发出注册请求，这之后 kubelet 才会和 Device Plugin 通过g RPC交互，具体过程如下：</p><ul><li>Device Plugin 向 Kubelet 发送一个 <code>RegisterRequest</code>的请求</li><li>Kubelet 收到 <code>RegisterRequest</code> 请求后，返回一个 <code>RegisterResponse</code>，如果Kubelet碰到任何错误，会把错误附在Response中</li><li>如果 Device Plugin 没有收到任何错误，则启动他的 gRPC server</li></ul><p>插件启动后要持续监控 Kubelet 的状态，并在 Kubelet 重启后重新注册自己。比如，Kubelet 刚启动后会清空 <code>/var/lib/kubelet/device-plugins/</code> 目录，所以插件作者可以监控自己监听的 unix socket 是否被删除了，并根据此事件重新注册自己</p><h3 id="Unix-Socket"><a href="#Unix-Socket" class="headerlink" title="Unix Socket"></a>Unix Socket</h3><p>Device Plugin 和 Kubelet 通过在一个 Unix Socket上使用 gRPC 交互，当启动 gRPC server的时候，Device Plugin 将会在 <code>/var/lib/kubelet/device-plugins/</code>  这个 HostPath 创建一个 UnixSocket，比如 <code>/var/lib/kubelet/device-plugins/nvidiaGPU.sock</code>。</p><p>在实现 Device 插件时需要注意</p><ul><li>插件启动时，需要通过 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 向 Kubelet 注册，同时提供插件的 Unix Socket 名称、API 的版本号和插件名称（格式为 <code>vendor-domain/resource</code>，如 <code>nvidia.com/gpu</code>）。Kubelet 会将这些设备暴露到 Node 状态中，方便后续调度器使用</li><li>插件启动后向 Kubelet 发送插件列表、按需分配设备并持续监控设备的实时状态</li></ul><h3 id="Protocol-Overview"><a href="#Protocol-Overview" class="headerlink" title="Protocol Overview"></a>Protocol Overview</h3><p><img alt="Protocol Overview" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_k8s-device-plugin-protocol.png"></p><h3 id="API-specification"><a href="#API-specification" class="headerlink" title="API specification"></a>API specification</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Registration is the service advertised by the Kubelet</span></span><br><span class="line"><span class="comment">// Only when Kubelet answers with a success code to a Register Request</span></span><br><span class="line"><span class="comment">// may Device Plugins start their service</span></span><br><span class="line"><span class="comment">// Registration may fail when device plugin version is not supported by</span></span><br><span class="line"><span class="comment">// Kubelet or the registered resourceName is already taken by another</span></span><br><span class="line"><span class="comment">// active device plugin. Device plugin is expected to terminate upon registration failure</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Registration</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Register(RegisterRequest) <span class="keyword">returns</span> (Empty) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// DevicePlugin is the service advertised by Device Plugins</span></span><br><span class="line"><span class="function">service DevicePlugin &#123;</span></span><br><span class="line"><span class="function">// ListAndWatch <span class="keyword">returns</span> a stream of List of Devices</span></span><br><span class="line"><span class="function">// Whenever a Device state change or a Device disappears, ListAndWatch</span></span><br><span class="line"><span class="function">// <span class="keyword">returns</span> the new list</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ListAndWatch(Empty) <span class="keyword">returns</span> (stream ListAndWatchResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// Allocate is called during container creation so that the Device</span></span><br><span class="line"><span class="function">// Plugin can run device specific operations and instruct Kubelet</span></span><br><span class="line"><span class="function">// of the steps to make the Device available in the container</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Allocate(AllocateRequest) <span class="keyword">returns</span> (AllocateResponse) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message RegisterRequest &#123;</span></span><br><span class="line"><span class="function">// Version of the API the Device Plugin was built against</span></span><br><span class="line"><span class="function">string version = 1</span>;</span><br><span class="line"><span class="comment">// Name of the unix socket the device plugin is listening on</span></span><br><span class="line"><span class="comment">// PATH = path.Join(DevicePluginPath, endpoint)</span></span><br><span class="line"><span class="built_in">string</span> endpoint = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Schedulable resource name</span></span><br><span class="line"><span class="built_in">string</span> resource_name = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - Allocate is expected to be called during pod creation since allocation</span></span><br><span class="line"><span class="comment">//   failures for any container would result in pod startup failure.</span></span><br><span class="line"><span class="comment">// - Allocate allows kubelet to exposes additional artifacts in a pod's</span></span><br><span class="line"><span class="comment">//   environment as directed by the plugin.</span></span><br><span class="line"><span class="comment">// - Allocate allows Device Plugin to run device specific operations on</span></span><br><span class="line"><span class="comment">//   the Devices requested</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AllocateRequest</span> </span>&#123;</span><br><span class="line"><span class="keyword">repeated</span> <span class="built_in">string</span> devicesIDs = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Failure Handling:</span></span><br><span class="line"><span class="comment">// if Kubelet sends an allocation request for dev1 and dev2.</span></span><br><span class="line"><span class="comment">// Allocation on dev1 succeeds but allocation on dev2 fails.</span></span><br><span class="line"><span class="comment">// The Device plugin should send a ListAndWatch update and fail the</span></span><br><span class="line"><span class="comment">// Allocation request</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AllocateResponse</span> </span>&#123;</span><br><span class="line"><span class="keyword">repeated</span> DeviceRuntimeSpec spec = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListAndWatch returns a stream of List of Devices</span></span><br><span class="line"><span class="comment">// Whenever a Device state change or a Device disappears, ListAndWatch</span></span><br><span class="line"><span class="comment">// returns the new list</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ListAndWatchResponse</span> </span>&#123;</span><br><span class="line"><span class="keyword">repeated</span> Device devices = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list to be added to the CRI spec</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">DeviceRuntimeSpec</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> ID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of environment variable to set in the container.</span></span><br><span class="line">map&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; envs = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Mounts for the container.</span></span><br><span class="line"><span class="keyword">repeated</span> Mount mounts = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Devices for the container</span></span><br><span class="line"><span class="keyword">repeated</span> DeviceSpec devices = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeviceSpec specifies a host device to mount into a container.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">DeviceSpec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Path of the device within the container.</span></span><br><span class="line">    <span class="built_in">string</span> container_path = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Path of the device on the host.</span></span><br><span class="line">    <span class="built_in">string</span> host_path = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Cgroups permissions of the device, candidates are one or more of</span></span><br><span class="line">    <span class="comment">// * r - allows container to read from the specified device.</span></span><br><span class="line">    <span class="comment">// * w - allows container to write to the specified device.</span></span><br><span class="line">    <span class="comment">// * m - allows container to create device files that do not yet exist.</span></span><br><span class="line">    <span class="built_in">string</span> permissions = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount specifies a host volume to mount into a container.</span></span><br><span class="line"><span class="comment">// where device library or tools are installed on host and container</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Mount</span> </span>&#123;</span><br><span class="line"><span class="comment">// Path of the mount on the host.</span></span><br><span class="line"><span class="built_in">string</span> host_path = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Path of the mount within the container.</span></span><br><span class="line"><span class="built_in">string</span> mount_path = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// If set, the mount is read-only.</span></span><br><span class="line"><span class="built_in">bool</span> read_only = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g:</span></span><br><span class="line"><span class="comment">// struct Device &#123;</span></span><br><span class="line"><span class="comment">//    ID: "GPU-fef8089b-4820-abfc-e83e-94318197576e",</span></span><br><span class="line"><span class="comment">//    State: "Healthy",</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> ID = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> health = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件生命周期管理"><a href="#插件生命周期管理" class="headerlink" title="插件生命周期管理"></a>插件生命周期管理</h3><p>插件启动时，以grpc的形式通过/var/lib/kubelet/device-plugins/kubelet.sock向Kubelet注册，同时提供插件的监听Unix Socket，API版本号和设备名称（比如nvidia.com/gpu）。Kubelet将会把这些设备暴露到Node状态中，以Extended Resource的要求发送到API server中，后续Scheduler会根据这些信息进行调度。</p><p>插件启动后，Kubelet会建立一个到插件的listAndWatch长连接，当插件检测到某个设备不健康的时候，就会主动通知Kubelet。此时如果这个设备处于空闲状态，Kubelet就会将其挪出可分配列表；如果该设备已经被某个pod使用，Kubelet就会将该Pod杀掉</p><p>插件启动后可以利用Kubelet的socket持续检查Kubelet的状态，如果Kubelet重启，插件也会相应的重启，并且重新向Kubelet注册自己</p><h2 id="NVIDIA-Device-Plugin"><a href="#NVIDIA-Device-Plugin" class="headerlink" title="NVIDIA Device Plugin"></a>NVIDIA Device Plugin</h2><p>NVIDIA 提供了一个基于 Device Plugins 接口的 GPU 设备插件 <a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA/k8s-device-plugin</a>。</p><p>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NVIDIA/k8s-device-plugin</span><br><span class="line"><span class="built_in">cd</span> k8s-device-plugin</span><br><span class="line">docker build -t nvidia-device-plugin:1.0.0 .</span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/master/nvidia-device-plugin.yml</span><br></pre></td></tr></table></figure><p>创建 Pod 时请求 GPU 资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nvidia/cuda</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod1-ctr</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["sleep"]</span></span><br><span class="line">    <span class="attr">args:</span> <span class="string">["100000"]</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意：<strong>使用该插件时需要配置 <a href="https://github.com/NVIDIA/nvidia-docker/" target="_blank" rel="external nofollow noopener noreferrer">nvidia-docker 2.0</a>，并配置 <code>nvidia</code> 为默认运行时 （即配置 docker daemon 的选项 <code>--default-runtime=nvidia</code>）</strong>。nvidia-docker 2.0 的安装方法为（以 Ubuntu Xenial 为例，其他系统的安装方法可以参考 <a href="http://nvidia.github.io/nvidia-docker/" target="_blank" rel="external nofollow noopener noreferrer">这里</a>）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Configure repository</span></span><br><span class="line">curl -L https://nvidia.github.io/nvidia-docker/gpgkey | \</span><br><span class="line">sudo apt-key add -</span><br><span class="line">sudo tee /etc/apt/sources.list.d/nvidia-docker.list &lt;&lt;&lt; \</span><br><span class="line"><span class="string">"deb https://nvidia.github.io/libnvidia-container/ubuntu16.04/amd64 /</span></span><br><span class="line"><span class="string">deb https://nvidia.github.io/nvidia-container-runtime/ubuntu16.04/amd64 /</span></span><br><span class="line"><span class="string">deb https://nvidia.github.io/nvidia-docker/ubuntu16.04/amd64 /"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install nvidia-docker 2.0</span></span><br><span class="line">sudo apt-get install nvidia-docker2</span><br><span class="line">sudo pkill -SIGHUP dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check installation</span></span><br><span class="line">docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Allocate 接口只做了一件事情，就是给容器加上 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量。 <a href="https://github.com/NVIDIA/k8s-device-plugin/blob/v1.11/server.go#L153" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/NVIDIA/k8s-device-plugin/blob/v1.11/server.go#L153</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate which return list of devices.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">Allocate</span><span class="params">(ctx context.Context, reqs *pluginapi.AllocateRequest)</span> <span class="params">(*pluginapi.AllocateResponse, error)</span></span> &#123;</span><br><span class="line">    devs := m.devs</span><br><span class="line">    responses := pluginapi.AllocateResponse&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line">        response := pluginapi.ContainerAllocateResponse&#123;</span><br><span class="line">            Envs: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">                <span class="string">"NVIDIA_VISIBLE_DEVICES"</span>: strings.Join(req.DevicesIDs, <span class="string">","</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, id := <span class="keyword">range</span> req.DevicesIDs &#123;</span><br><span class="line">            <span class="keyword">if</span> !deviceExists(devs, id) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid allocation request: unknown device: %s"</span>, id)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responses.ContainerResponses = <span class="built_in">append</span>(responses.ContainerResponses, &amp;response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;responses, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到， Nvidia的 <code>gpu-container-runtime</code> 根据容器的 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，会决定这个容器是否为GPU容器，并且可以使用哪些GPU设备。 而Nvidia GPU device plugin做的事情，就是根据kubelet 请求中的GPU DeviceId， 转换为 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量返回给kubelet， kubelet收到返回内容后，会自动将返回的环境变量注入到容器中。当容器中包含环境变量，启动时 <code>gpu-container-runtime</code> 会根据 <code>NVIDIA_VISIBLE_DEVICES</code> 里声明的设备信息，将设备映射到容器中，并将对应的Nvidia Driver Lib 也映射到容器中。</p><p><strong>总体流程</strong></p><p>整个Kubernetes调度GPU的过程如下：</p><ul><li>GPU Device plugin 部署到GPU节点上，通过 <code>ListAndWatch</code> 接口，上报注册节点的GPU信息和对应的DeviceID。 </li><li>当有声明 <code>nvidia.com/gpu</code> 的GPU Pod创建出现，调度器会综合考虑GPU设备的空闲情况，将Pod调度到有充足GPU设备的节点上。</li><li>节点上的kubelet 启动Pod时，根据request中的声明调用各个Device plugin 的 allocate接口， 由于容器声明了GPU。 kubelet 根据之前 <code>ListAndWatch</code> 接口收到的Device信息，选取合适的设备，DeviceID 作为参数，调用GPU DevicePlugin的 <code>Allocate</code> 接口</li><li>GPU DevicePlugin ，接收到调用，将DeviceID 转换为 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，返回kubelet</li><li>kubelet将环境变量注入到Pod， 启动容器</li><li>容器启动时， <code>gpu-container-runtime</code> 调用 <code>gpu-containers-runtime-hook</code> </li><li><code>gpu-containers-runtime-hook</code> 根据容器的 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，转换为 <code>--devices</code> 参数，调用 <code>nvidia-container-cli prestart</code> </li><li><code>nvidia-container-cli</code> 根据 <code>--devices</code> ，将GPU设备映射到容器中。 并且将宿主机的Nvidia Driver Lib 的so文件也映射到容器中。 此时容器可以通过这些so文件，调用宿主机的Nvidia Driver。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes device plugin design proposal</a></li><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/plugin-watcher.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes plugin watcher design proposal</a></li><li><a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">Nvidia Device Plugin</a></li><li><a href="https://cloud.tencent.com/developer/article/1592800" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1592800</a></li><li><a href="https://cloud.tencent.com/developer/article/1496699" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1496699</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 原生支持对于CPU和内存资源的发现，但是有很多其他的设备 kubelet不能原生处理，比如GPU、FPGA、RDMA、存储设备和其他类似的异构计算资源设备。为了能够使用这些设备资源，我们需要进行各个设备的初始化和设置。按照 Kubernetes 的 &lt;code&gt;OutOfTree&lt;/code&gt; 的哲学理念，我们不应该把各个厂商的设备初始化设置相关代码与 Kubernetes 核心代码放在一起。与之相反，我们需要一种机制能够让各个设备厂商向 Kubelet 上报设备资源，而不需要修改 Kubernetes 核心代码。这即是 &lt;code&gt;Device Plugin&lt;/code&gt; 这一机制的来源，本文将介绍 Device Plugin 的实现原理，并介绍其使用。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_k8s-device-plugin.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="device plugin" scheme="http://houmin.cc/tags/device-plugin/"/>
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="RDMA" scheme="http://houmin.cc/tags/RDMA/"/>
    
      <category term="FPGA" scheme="http://houmin.cc/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>GPU 与 CUDA 编程入门</title>
    <link href="http://houmin.cc/posts/5004f8e5/"/>
    <id>http://houmin.cc/posts/5004f8e5/</id>
    <published>2020-11-15T05:16:10.000Z</published>
    <updated>2020-11-21T16:41:14.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>随着近年来深度学习的爆发，原来被用于图形渲染的GPU被大量用于并行加速深度学习的模型训练中，在这个过程中 CUDA 作为 NVIDIA 推出的基于GPU的一个通用并行计算平台和编程模型也得到了广泛的使用。或许你已经十分了解 <a href="../b893097a/">现代CPU的体系架构</a>，但是对于GPU还不甚清晰，GPU的体系架构到底和CPU有何区别，CUDA模型是什么，我们该如何使用 CUDA实现并行计算，本文将为你扫盲祛魅，本文中使用到的所有代码可以在我的 <a href="https://github.com/SimpCosm/cuda-tutorial" target="_blank" rel="external nofollow noopener noreferrer">Github</a> 中找到。</p><a id="more"></a><h2 id="GPU-体系架构"><a href="#GPU-体系架构" class="headerlink" title="GPU 体系架构"></a>GPU 体系架构</h2><h3 id="为什么我们需要-GPU"><a href="#为什么我们需要-GPU" class="headerlink" title="为什么我们需要 GPU"></a>为什么我们需要 GPU</h3><p>如前所述，GPU （Graphics Processing Unit）最开始只是用于游戏、视频中的图形渲染，而现在最热门的一个应用领域是在深度学习的加速计算上。为什么需要 GPU 来加速计算呢？我们知道，随着摩尔定律的发展，在过去五十年间CPU的性能获得了巨大的提升，不论是从芯片上晶体管数目，还是时钟频率，到后来的从单核处理器发展到后来的多核多处理器。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-18_moores-law-develop.jpg"></p><p>下图是过去五十年间各款CPU处理器上晶体管数目的变化，基本上满足每18个月提升一倍的规律，虽然现在看起来50十年后摩尔定律对CPU来说有停滞的迹象（这是另一个话题，此处不表）</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-18_moores-law.png"></p><p>在 CPU 算力快速提升的这五十年，人们需要的计算量也同时在迅猛发展着，从最开始的桌面互联网，到后来的移动互联网，以及5年前爆发的深度学习，无一不需要庞大的计算力。在这个过程中，仅仅依靠CPU的算力开始力有不逮，这个过程中像GPU、FPGA、DSP等异构计算单元开始得到广泛的应用。下面，我回归计算的本质，以GPU为例来分析为什么我们需要这些异构计算单元。</p><p>无论是 CPU 还是 GPU，我们可以把计算模型抽象为下面这张图，这也是典型的冯诺伊曼体系架构。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_computing.png"></p><p>影响计算能力的4个主要因素如下：</p><ul><li><strong>Parallel Processing</strong>：Amount of data processed at one time</li><li><strong>Clock Frequency</strong>：Processing speed on each data element</li><li><strong>Memory Bandwidth</strong>：Amount of data transferred at one time</li><li><strong>Memory Lantency</strong>：Time for each data element to be transferred</li></ul><p>对于CPU，依次分析这几个因素：</p><ul><li>为了提供并行处理能力，我们从单核单处理器发展到多核多处理器，每个时钟周期CPU也能够处理多条指令</li><li>因为CPU时钟频率和功率的关系  $ Power = k <em> ClockFrequency </em> Voltage^2 $ ，在CPU过去的发展历史中，通过提高CPU时钟频率可以变得更快，与此同时为了保持CPU功耗的正常，也需要不断降低电压。但是当主频逐渐逼近到 4GHz 时，电压已经不能再降低了，因为这已经到达了晶体管高低电平反转的极限，关于这部分的更多内容可以参考 <a href="../">摩尔定律</a> 。</li><li>现在CPU用的是常规的DDR内存，明显存在着内存带宽限制</li><li>从CPU到DDR内存的延时很高，2020年的时候大概有100ns，具体可以参考 <a href="../fb3d782a/">Key Numbers Every Programmer Should Know</a>。CPU通过其他的方式隐藏了这个问题：<ul><li>Large On-Chip Low-Latency Cache，大概1ns</li><li>MultiThreading</li><li>Out-of-order execution</li></ul></li></ul><p><img alt="Credit to https://queue.acm.org/detail.cfm?id=2181798" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_processor-frequency-scaling.png"></p><p>尽管现在CPU的能力还在发展，但是以上的问题极大的限制了其算力的提高，当前仅靠CPU已经不能够满足人们对庞大算力的需求了。因此我们需要其他的专用芯片来帮助CPU一起计算，这就是异构计算的来源。GPU等专用计算单元虽然工作频率较低，但具有更多的内核数和并行计算能力，总体性能/芯片面积比和性能/功耗比都很高。随着人工智能时代的降临，GPU从游戏走进了人们的视野。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cpu-vs-gpu.png"></p><p>无论是CPU还是GPU，在进行计算时都需要用核心（Core）来做算术逻辑运算。核心中有ALU（逻辑运算单元）和寄存器等电路。在进行计算时，一个核心只能顺序执行某项任务。CPU作为通用计算芯片，不仅仅做算术逻辑计算，其很重要的一部分功能是做复杂的逻辑控制，一般而言CPU上的Core数目相对较少，数据中心的服务器一般也就40左右个CPU核心。但是GPU动辄有上千个核心，这些核心可以独立的进行算术逻辑计算，大大提高了并行计算处理能力。</p><p>GPU时代的最大获益者是NVIDIA，当然AMD他们家也有GPU产品，但是因为AMD并没有形成CUDA这样的软件生态导致深度学习中主要用的都是NVIDIA的GPU，后面的分析都将基于NVIDIA的GPU产品。NVIDIA 不同时代产品的芯片设计不同，每代产品背后有一个架构代号，架构均以著名的物理学家为名，以向先贤致敬，对于消费者而言，英伟达主要有两条产品线：</p><ul><li>消费级产品 GeForce系列：GeForce 2080 Ti…</li><li>高性能计算产品 Telsa系列：Telsa V100、Telsa P100、Telsa P40…</li></ul><p><img alt="NVIDIA GPU产品体系" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-gpu.png"></p><h3 id="GPU-硬件模型"><a href="#GPU-硬件模型" class="headerlink" title="GPU 硬件模型"></a>GPU 硬件模型</h3><h4 id="Host-and-Device"><a href="#Host-and-Device" class="headerlink" title="Host and Device"></a>Host and Device</h4><p>GPU并不是一个独立运行的计算平台，而是需要与CPU的协同工作，可以看作是CPU的协处理器，因此当我们说GPU并行计算的时候，实质上是指的 <code>CPU+GPU</code> 的异构计算架构。由于CPU和GPU是分开的，在NVIDIA的设计理念里，CPU和主存被称为 <strong>Host</strong>，GPU和显存被称为 <strong>Device</strong>。Host 和 Device 概念会贯穿整个NVIDIA GPU编程。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cpu-and-gpu.png"></p><p>基于 CPU + GPU 的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。CUDA 程序中既包含 <strong>Host</strong> 程序，又包含 <strong>Device</strong> 程序，它们分别在CPU和GPU上运行。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cuda-application.jpg"></p><p>同时， <strong>Host</strong> 与 <strong>Device</strong> 之间通过PCIe总线交互进行数据拷贝，典型的 CUDA 程序的执行流程如下：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cuda-flow.jpg"></p><ol><li>初始化后，将数据从 Main Memory 拷贝到 GPU Memory</li><li>CPU 调用 CUDA 的核函数</li><li>GPU 的 CUDA Core 并行执行核函数</li><li>将 <strong>Device</strong> 上的运算结果拷贝到 <strong>Host</strong> 上</li></ol><p>GPU核心在做计算时，只能直接从显存中读写数据，程序员需要在代码中指明哪些数据需要从内存和显存之间相互拷贝。这些数据传输都是在总线上，因此总线的传输速度和带宽成了部分计算任务的瓶颈。当前最新的总线技术是NVLink，IBM的 Power CPU 和 NVIDIA 的高端显卡可以通过NVLink直接通信，Intel 的 CPU目前不支持NVLink，只能使用PCIe技术。同时，单台机器上的多张英伟达显卡也可以使用NVLink相互通信，适合多GPU卡并行计算的场景。</p><p><img alt="NVLink可以连接CPU和GPU" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvlink.png"></p><h4 id="Streaming-Multiprocessor"><a href="#Streaming-Multiprocessor" class="headerlink" title="Streaming Multiprocessor"></a>Streaming Multiprocessor</h4><p>在 NVIDIA 的设计里，一张GPU卡有多个Streaming Multiprocessor（<strong>SM</strong>），每个 SM 中有多个计算核心，SM 是运算和调度的基本单元。下图为当前计算力最强的显卡Tesla V100，密密麻麻的绿色小格子就是GPU小核心，多个小核心一起组成了一个SM。</p><p><img alt="Tesla V100 with 84 SM Units" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-tesla-v100.png"></p><p>将 SM 放大，单个SM的结构如图所示：</p><p><img alt="Tesla V100 Streaming Multiprocessor(SM)" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-tesla-v100-sm.png"></p><p>可以看到一个SM中包含了计算核心和存储部分，SM的核心组件包括CUDA核心，共享内存，寄存器等，SM可以并发地执行数百个线程，并发能力就取决于SM所拥有的资源数。</p><ul><li>针对不同计算的小核心（绿色小格子），包括优化深度学习的TENSOR CORE，32个64位浮点核心（FP64），64个整型核心(INT)，64个32位浮点核心(FP32)</li><li>计算核心直接从寄存器（Register）中读写数据</li><li>调度和分发器（Scheduler和Dispatch Unit）</li><li>L0和L1级缓存</li></ul><p>具体而言，SM中的FP32进行32位浮点加乘运算，INT进行整型加乘运算，SFU（Special Functional Unit）执行一些倒数和三角函数等运算。Tensor Core是 NVIDIA 新的微架构中提出的一种混合精度的计算核心。我们知道，当前深度神经网络中使用到最频繁的矩阵运算是： $ D = A \times B + C $。Tensor Core可以对 $ 4 \times 4  $ 的矩阵做上述运算。其中：</p><ul><li>涉及乘法的 A 和 B 使用FP16的16位浮点运算，精度较低</li><li>涉及加法的 C 和 D 使用FP16或FP32精度</li></ul><p>Tensor Core是在 Volta 架构开始提出的，使用Volta架构的V100在深度学习上的性能远超Pascal架构的P100。</p><p><img alt="Tensor Core是一种为优化深度学习计算核心" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_tensor-core.png"></p><h2 id="CUDA-编程模型"><a href="#CUDA-编程模型" class="headerlink" title="CUDA 编程模型"></a>CUDA 编程模型</h2><p>前面提到，NVIDIA 相对于 AMD 的一个巨大优势是它的 CUDA 软件生态，下图是 NVIDIA GPU 编程的软件栈，从底层的GPU驱动和CUDA 工具包，上面还提供了科学计算所必需的cuBLAS线性代数库，cuFFT快速傅里叶变换库以及cuDNN深度神经网络加速库，当前常见的 TensorFlow 和 PyTorch 深度学习框架底层大多都基于 cuDNN 库。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_gpu-software-stack.png"></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>在进一步学习 CUDA 编程模型之前，我们首先配置好 CUDA 的运行环境，跑通 <code>Hello World</code> 从而对 CUDA 编程有一个直观的认识，这里使用的是腾讯云的 GPU 服务器，机器安装的是 CentOS 7 系统，CUDA 环境配置可以参考 <a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html" target="_blank" rel="external nofollow noopener noreferrer">CUDA Installation Guide Linux</a> 。</p><p>根据上图的 NVIDIA GPU 软件栈，有了一个插上了 GPU 的服务器之后，我们首先查看机器上的 GPU，可以看到当前机器上装GPU是 <code>Tesla P40</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lspci | grep -i nvidia</span><br><span class="line">00:08.0 3D controller: NVIDIA Corporation GP102GL [Tesla P40] (rev a1)</span><br></pre></td></tr></table></figure><p>接下来在 <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载 CUDA Toolkit，这里选择的是 <code>rpm local</code> 的安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://developer.download.nvidia.com/compute/cuda/11.1.1/local_installers/cuda-repo-rhel7-11-1-local-11.1.1_455.32.00-1.x86_64.rpm</span><br><span class="line">$ sudo rpm -i cuda-repo-rhel7-11-1-local-11.1.1_455.32.00-1.x86_64.rpm</span><br><span class="line">$ sudo yum clean all</span><br><span class="line">$ sudo yum -y install nvidia-driver-latest-dkms cuda</span><br><span class="line">$ sudo yum -y install cuda-drivers</span><br></pre></td></tr></table></figure><p>执行上面的安装操作之后，我们可以看到在 <code>/usr/lib64/</code> 看到 <code>libcuda.so</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls /usr/lib64 -al | grep cuda</span><br><span class="line">lrwxrwxrwx   1 root root        20 Nov 21 15:05 libcuda.so -&gt; libcuda.so.455.32.00</span><br><span class="line">lrwxrwxrwx   1 root root        20 Nov 21 15:05 libcuda.so.1 -&gt; libcuda.so.455.32.00</span><br><span class="line">-rwxr-xr-x   1 root root  21074296 Oct 15 06:58 libcuda.so.455.32.00</span><br></pre></td></tr></table></figure><p>下面是一些我们会经常用到的 CUDA 工具，你需要通过配置环境变量来使用他们：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">编译器：nvcc</span> <span class="comment">(C/C</span>++<span class="comment">)</span></span><br><span class="line"><span class="comment">调试器：nvcc</span><span class="literal">-</span><span class="comment">gdb</span></span><br><span class="line"><span class="comment">性能分析：nsight</span><span class="string">,</span> <span class="comment">nvprof</span></span><br><span class="line"><span class="comment">函数库：cublas</span><span class="string">,</span> <span class="comment">nvblas</span><span class="string">,</span> <span class="comment">cusolver</span><span class="string">,</span> <span class="comment">cufftw</span><span class="string">,</span> <span class="comment">cusparse</span><span class="string">,</span> <span class="comment">nvgraph</span></span><br></pre></td></tr></table></figure><p>设置环境变量如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-11.1/bin<span class="variable">$&#123;PATH:+:$&#123;PATH&#125;</span>&#125;</span><br><span class="line">$ nvcc --version</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2020 NVIDIA Corporation</span><br><span class="line">Built on Mon_Oct_12_20:09:46_PDT_2020</span><br><span class="line">Cuda compilation tools, release 11.1, V11.1.105</span><br><span class="line">Build cuda_11.1.TC455_06.29190527_0</span><br></pre></td></tr></table></figure><p>除此之外，对于 64 位系统，需要设置 <code>LD_LIBRARY_PATH</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-11.1/lib64<span class="variable">$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span><br></pre></td></tr></table></figure><p>这个时候可以确认驱动的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/driver/nvidia/version</span><br><span class="line">NVRM version: NVIDIA UNIX x86_64 Kernel Module  455.32.00  Wed Oct 14 22:46:18 UTC 2020</span><br><span class="line">GCC version:  gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)</span><br></pre></td></tr></table></figure><p>可以使用<code>nvidia-smi</code>命令查看显卡情况，比如这台机器上几张显卡，CUDA版本，显卡上运行的进程等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br><span class="line">Sat Nov 21 17:09:13 2020</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 455.32.00    Driver Version: 455.32.00    CUDA Version: 11.1     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla P40           Off  | 00000000:00:08.0 Off |                    0 |</span><br><span class="line">| N/A   27C    P0    49W / 250W |      0MiB / 22919MiB |      3%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p><code>CUDA</code> 自己提供了一系列的代码示例，可以通过下面的方法安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cuda-install-samples-11.1.sh &lt;dir&gt;</span><br></pre></td></tr></table></figure><p>在对应目录下，我们可以看到 <code>CUDA</code> 提供的源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls NVIDIA_CUDA-11.1_Samples</span><br><span class="line">0_Simple     2_Graphics  4_Finance      6_Advanced       bin     EULA.txt  Makefile</span><br><span class="line">1_Utilities  3_Imaging   5_Simulations  7_CUDALibraries  common  LICENSE</span><br></pre></td></tr></table></figure><p>直接在这个目录下执行 <code>make</code>，可以在 <code>bin</code>目录下得到所有代码的二进制程序，选择其中的 <code>deviceQuery</code> 执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ ./deviceQuery</span><br><span class="line">./deviceQuery Starting...</span><br><span class="line"></span><br><span class="line"> CUDA Device Query (Runtime API) version (CUDART static linking)</span><br><span class="line"></span><br><span class="line">Detected 1 CUDA Capable device(s)</span><br><span class="line"></span><br><span class="line">Device 0: <span class="string">"Tesla P40"</span></span><br><span class="line">  CUDA Driver Version / Runtime Version          11.1 / 11.1</span><br><span class="line">  CUDA Capability Major/Minor version number:    6.1</span><br><span class="line">  Total amount of global memory:                 22919 MBytes (24032378880 bytes)</span><br><span class="line">  (30) Multiprocessors, (128) CUDA Cores/MP:     3840 CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            1531 MHz (1.53 GHz)</span><br><span class="line">  Memory Clock rate:                             3615 Mhz</span><br><span class="line">  Memory Bus Width:                              384-bit</span><br><span class="line">  L2 Cache Size:                                 3145728 bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)</span><br><span class="line">  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers</span><br><span class="line">  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers</span><br><span class="line">  Total amount of constant memory:               65536 bytes</span><br><span class="line">  Total amount of shared memory per block:       49152 bytes</span><br><span class="line">  Total shared memory per multiprocessor:        98304 bytes</span><br><span class="line">  Total number of registers available per block: 65536</span><br><span class="line">  Warp size:                                     32</span><br><span class="line">  Maximum number of threads per multiprocessor:  2048</span><br><span class="line">  Maximum number of threads per block:           1024</span><br><span class="line">  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)</span><br><span class="line">  Maximum memory pitch:                          2147483647 bytes</span><br><span class="line">  Texture alignment:                             512 bytes</span><br><span class="line">  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)</span><br><span class="line">  Run time <span class="built_in">limit</span> on kernels:                     No</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page-locked memory mapping:       Yes</span><br><span class="line">  Alignment requirement <span class="keyword">for</span> Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Enabled</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Device supports Managed Memory:                Yes</span><br><span class="line">  Device supports Compute Preemption:            Yes</span><br><span class="line">  Supports Cooperative Kernel Launch:            Yes</span><br><span class="line">  Supports MultiDevice Co-op Kernel Launch:      Yes</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   0 / 0 / 8</span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 11.1, CUDA Runtime Version = 11.1, NumDevs = 1</span><br><span class="line">Result = PASS</span><br></pre></td></tr></table></figure><p>到现在，<code>CUDA Toolkit</code> 安装完毕，接下来通过编写一个简单的 <code>hello world</code> 来直观感受 CUDA 编程：</p><figure class="highlight c"><figcaption><span>hello.cu</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">hello_from_gpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\"Hello, world!\", says the GPU.\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_from_cpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\"Hello, world!\", says the CPU.\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// host code entrance</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello_from_cpu();</span><br><span class="line">    hello_from_gpu &lt;&lt;&lt; <span class="number">2</span>, <span class="number">4</span>&gt;&gt;&gt;();</span><br><span class="line">    cudaDeviceReset();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，CUDA 程序基本上和标准 C 语言程序一样，主要的区别在于 <code>__global__</code> 限定词 和 <code>&lt;&lt;&lt;... &gt;&gt;&gt;</code> 符号。其中 <code>__global__</code> 标记用来告诉编译器这段代码会运行在 <strong>Device</strong>  （GPU）上，它会被运行在 <strong>Host</strong> 上的代码调用，也被称作是在 <strong>Device</strong> 上线程中并行执行的核函数（Kernel），是在 <strong>Device</strong> 上线程中并行执行的函数。</p><p>当一个核函数被调用时，需要通过 <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code> 符号 来设置核函数执行时的配置，在 CUDA 的术语中，这称作 <code>kernel lauch</code>，在后面我们将深入介绍这部分。</p><p><code>hello world</code> 程序写完，我们以 <code>hello.cu</code> 这样的后缀名来保存，接下来使用 <code>nvcc</code> 来编译，整体上用法与 <code>gcc</code> 几乎一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ nvcc hello.cu -o hello</span><br><span class="line">$./hello</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the CPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br></pre></td></tr></table></figure><p>可以看到，来自 CPU 的 <code>Hello World</code> 执行了一次，来自 GPU 的 <code>Hello World</code> 执行了8次。</p><h3 id="核函数与线程模型"><a href="#核函数与线程模型" class="headerlink" title="核函数与线程模型"></a>核函数与线程模型</h3><p>上文提到，为了实现 GPU 并行加速计算，我们需要在 <strong>Host</strong> 上执行 <code>kernel launch</code>，让 核函数 在 <strong>Device</strong> 上的多个线程并发执行。具体的方式就是在调用核函数的时候通过 <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code> 来指定核函数要执行的线程数量N，之后GPU上的N个Core会并行执行核函数，并且每个线程会分配一个唯一的线程号threadID，这个ID值可以通过核函数的内置变量<code>threadIdx</code>来获得。</p><p>CUDA将核函数所定义的运算称为<strong>线程（Thread）</strong>，多个线程组成一个<strong>块（Block）</strong>，多个块组成<strong>网格（Grid）</strong>。这样一个Grid可以定义成千上万个线程，也就解决了并行执行上万次操作的问题。 <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code> 中括号中第一个数字表示整个Grid有多少个Block，括号中第二个数字表示一个Block有多少个Thread。前面 <code>Hello World</code> 用 2 个Block，每个Block中有4个Thread，所以总共执行了8次。</p><p><img alt="Grid of Thread Blocks" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-thread-hierarchy.png"></p><p>实际上，线程（Thread）是一个编程上的软件概念。从硬件来看，Thread运行在一个CUDA核心上，多个Thread组成的Block运行在Streaming Multiprocessor（SM），多个Block组成的Grid运行在一个GPU显卡上。当一个 <code>kernel</code> 被执行时，它的gird中的线程块被分配到SM上，<strong>一个线程块只能在一个SM上被调度</strong>。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个 <code>kernel</code> 的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-software-hardware-view.png"></p><p><code>grid</code> 和 <code>block</code>都是定义为<code>dim3</code>类型的变量，<code>dim3</code>可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此 <code>grid</code> 和 <code>block</code> 可以灵活地定义为 <code>1-dim</code>，<code>2-dim</code> 以及<code>3-dim</code> 结构，对于上图中结构（主要水平方向为x轴），定义的 <code>grid</code>和 <code>block</code> 如下所示， <code>kernel</code> 在调用时也必须通过<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#execution-configuration" target="_blank" rel="external nofollow noopener noreferrer">执行配置</a><code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定 <code>kernel</code> 所使用的线程数及结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure><p>所以，一个线程需要两个内置的坐标变量<code>（blockIdx，threadIdx）</code>来唯一标识，它们都是<code>dim3</code>类型变量，其中blockIdx指明线程所在grid中的位置，而threaIdx指明线程所在block中的位置，如图中的 <code>Thread (1,1)</code> 满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadIdx.x &#x3D; 1</span><br><span class="line">threadIdx.y &#x3D; 1</span><br><span class="line">blockIdx.x &#x3D; 1</span><br><span class="line">blockIdx.y &#x3D; 1</span><br></pre></td></tr></table></figure><p>不同的执行配置会影响GPU程序的速度，一般需要多次调试才能找到较好的执行配置，在实际编程中，执行配置<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>应参考下面的方法：</p><ul><li>Block运行在SM上，不同硬件架构（Turing、Volta、Pascal…）的CUDA核心数不同，一般需要根据当前硬件来设置Block的大小<code>block</code>（执行配置中第二个参数）。一个Block中的Thread数最好是32、128、256的倍数。注意，限于当前硬件的设计，Block大小不能超过1024。</li><li>Grid的大小<code>grid</code>（执行配置中第一个参数），即一个Grid中Block的个数可以由总次数<code>N</code>除以<code>block</code>，并向上取整。</li></ul><p>例如，我们想并行启动1000个Thread，可以将blockDim设置为128，<code>1000 ÷ 128 = 7.8</code>，向上取整为8。使用时，执行配置可以写成<code>gpuWork&lt;&lt;&lt;8, 128&gt;&gt;&gt;()</code>，CUDA共启动<code>8 * 128 = 1024</code>个Thread，实际计算时只使用前1000个Thread，多余的24个Thread不进行计算。</p> <div class="note info">            <p>这几个变量比较容易混淆，再次明确一下：<code>block</code>是Block中Thread的个数，一个Block中的<code>threadIdx</code>最大不超过<code>block</code>；<code>grid</code>是Grid中Block的个数，一个Grid中的<code>blockIdx</code>最大不超过<code>grid</code>。</p>          </div><p>这几个变量比较容易混淆，再次明确一下：<code>block</code>是Block中Thread的个数，一个Block中的<code>threadIdx</code>最大不超过<code>block</code>；<code>grid</code>是Grid中Block的个数，一个Grid中的<code>blockIdx</code>最大不超过<code>grid</code>。</p><p> <code>kernel</code> 的这种线程组织结构天然适合vector，matrix等运算，我们将在后面实现向量加法和矩阵乘法。如我们将利用上图2-dim结构实现两个矩阵的加法，每个线程负责处理每个位置的两个元素相加，代码如下所示。线程块大小为(16, 16)，然后将 $ N*N $ 大小的矩阵均分为不同的线程块来执行加法运算。</p><p>SM采用的是<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#simt-architecture" target="_blank" rel="external nofollow noopener noreferrer">SIMT</a> (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是 <strong>线程束（wraps)</strong>，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。</p><p>当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。<code>(16, 16)</code>的二维Block是一个常用的配置，共256个线程。之前也曾提到过，每个Block的Thread个数最好是128、256或512，这与GPU的硬件架构高度相关。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kernel定义</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; j &lt; N) </span><br><span class="line">        C[i][j] = A[i][j] + B[i][j]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Kernel 线程配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>; </span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span><br><span class="line">    <span class="comment">// kernel调用</span></span><br><span class="line">    MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程块中的线程数是有限制的，现代GPUs的线程块可支持的线程数可达1024个。有时候，我们要知道一个线程在 <code>blcok</code> 中的全局ID，此时就必须还要知道 <code>block</code> 的组织结构，这是通过线程的内置变量 <code>blockDim</code>来获得。它获取线程块各个维度的大小。</p><ul><li>对于一个 <code>2-dim</code> 的block $ (D_x, D_y) $ ，线程  $ (x, y) $ 的ID值为 $ (x + y * D_x) $ </li><li>对于一个<code>3-dim</code> 的block  $ (D_x, D_y, D_z) $，线程 $(x, y, z)$  的ID值为 $ (x + y <em> D_z + z </em> D_z * D_y) $  </li></ul><p>另外线程还有内置变量 <code>gridDim</code>，用于获得网格块各个维度的大小。</p><h3 id="内存模型与管理"><a href="#内存模型与管理" class="headerlink" title="内存模型与管理"></a>内存模型与管理</h3><p>此外这里简单介绍一下CUDA的内存模型，如下图所示。可以看到，</p><ul><li>每个 <strong>Thread</strong> 有自己的私有本地内存（Local Memory）</li><li>每个 <strong>Block</strong> 有包含共享内存（Shared Memory），可以被线程块中所有线程共享，其生命周期与线程块一致</li><li>所有的 <strong>Thread</strong>  都可以访问全局内存（Global Memory）</li><li>访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）</li><li>L1 Cache，L2 Cache</li></ul><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-memory-sm.png"></div><div class="group-picture-column" style="width: 50%;"><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-memory-model.jpg"></div></div></div></div><p>下面简单介绍一下CUDA编程中内存管理常用的API。首先是在 <strong>Device</strong> 上分配内存的 <code>cudaMalloc</code> 、<code>cudaFree</code> 和 <code>cudaMemcpy</code>函数，分别对应C语言中的 <code>malloc</code>、<code>free</code>和 <code>memcpy</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Device 上申请一定字节大小的显存，其中 `devPtr` 是指向所分配内存的指针</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="keyword">void</span>** devPtr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Device 上释放一定大小的现存， `devPtr` 是指向所释放内存的指针</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaFree</span><span class="params">(<span class="keyword">void</span>* devPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责 Host 和 Device 之间数据通信，src指向数据源，dst是目标区域，count是复制的字节数，kind控制复制的方向</span></span><br><span class="line"><span class="comment">// 这里的 kind 有四种类型：</span></span><br><span class="line"><span class="comment">// - cudaMemcpyHostToHost</span></span><br><span class="line"><span class="comment">// - cudaMemcpyHostToDevice</span></span><br><span class="line"><span class="comment">// - cudaMemcpyDeviceToHost</span></span><br><span class="line"><span class="comment">// - cudaMemcpyDeviceToDevice</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count, cudaMemcpyKind kind)</span></span></span><br></pre></td></tr></table></figure><h2 id="CUDA-编程实战"><a href="#CUDA-编程实战" class="headerlink" title="CUDA 编程实战"></a>CUDA 编程实战</h2><p>知道了CUDA编程基础，接下来我们以两个向量的加法为例，介绍如何利用CUDA编程来实现GPU加速计算。</p><h3 id="CPU-向量加法：传统计算方法"><a href="#CPU-向量加法：传统计算方法" class="headerlink" title="CPU 向量加法：传统计算方法"></a>CPU 向量加法：传统计算方法</h3><p>我们首先来看利用 CPU 来计算向量加法该如何编程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize array</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main function</span></span><br><span class="line">    vector_add(out, a, b, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out[0] = %f\n"</span>, out[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-向量加法：一个Block一个Thread"><a href="#GPU-向量加法：一个Block一个Thread" class="headerlink" title="GPU 向量加法：一个Block一个Thread"></a>GPU 向量加法：一个Block一个Thread</h3><p>我们将 CPU 的向量加法转换成 CUDA 程序，使用 GPU 来计算，下面这段代码演示了如何使用 CUDA 编程规范来编写程序。实际上仍然只是使用一个 <code>core</code> 来进行计算，不仅没有提高并行度，反而还增加了数据拷贝的成本，显然相比原来的计算是会更慢的，这里主要作为演示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out;</span><br><span class="line">    <span class="keyword">float</span> *d_a, *d_b, *d_out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate host memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device memory</span></span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer data from host to device memory</span></span><br><span class="line">    cudaMemcpy(d_a, a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_b, b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    vector_add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer data back to host memory</span></span><br><span class="line">    cudaMemcpy(out, d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate device memory</span></span><br><span class="line">    cudaFree(d_a);</span><br><span class="line">    cudaFree(d_b);</span><br><span class="line">    cudaFree(d_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate host memory</span></span><br><span class="line">    <span class="built_in">free</span>(a); </span><br><span class="line">    <span class="built_in">free</span>(b); </span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-向量加法：一个Block多个Thread"><a href="#GPU-向量加法：一个Block多个Thread" class="headerlink" title="GPU 向量加法：一个Block多个Thread"></a>GPU 向量加法：一个Block多个Thread</h3><p>为了提高并行度，我们设置一个 <code>Block</code> 多个 <code>Thread</code> 同时进行计算，如下图所示总共有256个<code>Thread</code>，每个 Thread 负责处理 Vector 中的一部分。每一次迭代中，256个Thread分别计算 Vector 的这256个数，然后在下一次迭代中每个Thread往后推进256个数，继续计算。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-parallel_thread.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = threadIdx.x;</span><br><span class="line">    <span class="keyword">int</span> stride = blockDim.x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; n; i += stride)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out;</span><br><span class="line">    <span class="keyword">float</span> *d_a, *d_b, *d_out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate host memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device memory </span></span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer data from host to device memory</span></span><br><span class="line">    cudaMemcpy(d_a, a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_b, b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    vector_add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">256</span>&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer data back to host memory</span></span><br><span class="line">    cudaMemcpy(out, d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate device memory</span></span><br><span class="line">    cudaFree(d_a);</span><br><span class="line">    cudaFree(d_b);</span><br><span class="line">    cudaFree(d_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate host memory</span></span><br><span class="line">    <span class="built_in">free</span>(a); </span><br><span class="line">    <span class="built_in">free</span>(b); </span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 CPU 程序，这里的并行度显著提高，GPU 计算的时间也大大减小。</p><h3 id="GPU-向量加法：多个Block多个Thread"><a href="#GPU-向量加法：多个Block多个Thread" class="headerlink" title="GPU 向量加法：多个Block多个Thread"></a>GPU 向量加法：多个Block多个Thread</h3><p>在上一个方案中，我们的256个Thread仍然需要计算多个数字，如果我们将并行度继续扩大，让每个Thread只需要计算Vector中的一个数，那么计算消耗时间将会更短。如下图所示，我们使用多个Block多个Thread，其中每个Block还是256个Thread，但是我们现在的Grid有多个Block，Block数字由Vector的长度除以BlockSize得到。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-parallel_block.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handling arbitrary vector size</span></span><br><span class="line">    <span class="keyword">if</span> (tid &lt; n)&#123;</span><br><span class="line">        out[tid] = a[tid] + b[tid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out;</span><br><span class="line">    <span class="keyword">float</span> *d_a, *d_b, *d_out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate host memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device memory </span></span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer data from host to device memory</span></span><br><span class="line">    cudaMemcpy(d_a, a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_b, b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    <span class="keyword">int</span> block_size = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> grid_size = ((N + block_size - <span class="number">1</span>) / block_size);</span><br><span class="line">    vector_add&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer data back to host memory</span></span><br><span class="line">    cudaMemcpy(out, d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate device memory</span></span><br><span class="line">    cudaFree(d_a);</span><br><span class="line">    cudaFree(d_b);</span><br><span class="line">    cudaFree(d_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate host memory</span></span><br><span class="line">    <span class="built_in">free</span>(a); </span><br><span class="line">    <span class="built_in">free</span>(b); </span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-向量加法：Unified-Memory"><a href="#GPU-向量加法：Unified-Memory" class="headerlink" title="GPU 向量加法：Unified Memory"></a>GPU 向量加法：Unified Memory</h3><p>在上面的实现中，我们需要单独在 <strong>Host</strong> 和 <strong>Device</strong> 上进行内存分配，并且要进行数据拷贝，这是很容易出错的。好在CUDA 6.0引入统一内存（<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-unified-memory-programming-hd" target="_blank" rel="external nofollow noopener noreferrer">Unified Memory</a>）来避免这种麻烦，简单来说就是统一内存使用一个托管内存来共同管理 <strong>Host</strong> 和 <strong>Device</strong> 中的内存，并且自动在 <strong>Host</strong> 和 <strong>Device</strong> 中进行数据传输。CUDA中使用cudaMallocManaged函数分配托管内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocManaged</span><span class="params">(<span class="keyword">void</span> **devPtr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>利用统一内存，可以将上面的程序简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handling arbitrary vector size</span></span><br><span class="line">    <span class="keyword">if</span> (tid &lt; n)&#123;</span><br><span class="line">        out[tid] = a[tid] + b[tid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Allocate managed memory</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;y, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;z, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        x[i] = <span class="number">1.0f</span>;</span><br><span class="line">        y[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    <span class="keyword">int</span> block_size = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> grid_size = ((N + block_size - <span class="number">1</span>) / block_size);</span><br><span class="line">    vector_add&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;(z, x, y, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步 Device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate managed memory</span></span><br><span class="line">    cudaFree(x);</span><br><span class="line">    cudaFree(y);</span><br><span class="line">    cudaFree(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之前的代码，使用统一内存更简洁了，值得注意的是 <code>kernel</code> 执行是与 <strong>Host</strong> 异步的，由于托管内存自动进行数据传输，这里要用<code>cudaDeviceSynchronize()</code> 函数保证 <strong>Device</strong> 和 <strong>Host</strong> 同步，这样后面才可以正确访问 <code>kernel</code> 计算的结果。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://download.nvidia.com/developer/cuda/seminar/TDCI_Arch.pdf" target="_blank" rel="external nofollow noopener noreferrer">An Introduction to Modern GPU Architecture</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA CUDA 编程模型官方文档</a></li><li><a href="https://github.com/huiscliu/Tutorials/tree/master/CUDA编程入门" target="_blank" rel="external nofollow noopener noreferrer">CUDA编程入门</a></li><li><a href="http://www.mat.unimi.it/users/sansotte/cuda/CUDA_by_Example.pdf" target="_blank" rel="external nofollow noopener noreferrer">CUDA By Example</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着近年来深度学习的爆发，原来被用于图形渲染的GPU被大量用于并行加速深度学习的模型训练中，在这个过程中 CUDA 作为 NVIDIA 推出的基于GPU的一个通用并行计算平台和编程模型也得到了广泛的使用。或许你已经十分了解 &lt;a href=&quot;../b893097a/&quot;&gt;现代CPU的体系架构&lt;/a&gt;，但是对于GPU还不甚清晰，GPU的体系架构到底和CPU有何区别，CUDA模型是什么，我们该如何使用 CUDA实现并行计算，本文将为你扫盲祛魅，本文中使用到的所有代码可以在我的 &lt;a href=&quot;https://github.com/SimpCosm/cuda-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Github&lt;/a&gt; 中找到。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-tesla-v100.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="CUDA" scheme="http://houmin.cc/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>The Social Dilemma</title>
    <link href="http://houmin.cc/posts/b86144be/"/>
    <id>http://houmin.cc/posts/b86144be/</id>
    <published>2020-11-14T10:39:02.000Z</published>
    <updated>2020-11-16T06:22:56.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Back on track，本周继续「朝花夕拾」的定期发布，这里是今年的第二十四期「The Social Dilemma」，标题来自最新 Netflix 推出的一个剧情式纪录片。本期会简单聊聊社交困境，除了纪录片所涵盖的内容，还包括自己从字面上对其的漫无边际的延伸思考。</p>    <div id="aplayer-VwHhmILQ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="446874778" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>这周末出去和高中同学KM一起吃了顿饭，跟进了同学间的动态，最大的感慨就是，班上有几个同学自从高中毕业之后就如同人间蒸发了一半，再也没有消息。北京有雾霾了，没有太出去拍照，自己在家做饭看剧。嗯，我越来越喜欢吃意大利面了，真香。</p><p>继续看数据，首先是Rescue Time：</p><ul><li>工作日的ScreenTime依旧是9个小时左右，其中周三因为公司消防演练降低了很多，周五因为一些事情走的比较早，此处不表</li><li>具体到实际每个应用，可以看到企业微信是软件开发以外占据时间最多的，这个感觉可以具体到某个时间来处理，避免每次进入到状态的时候被打断</li><li>周末的时间就很分散，现在对于周末的一个感觉就是时间太短，本来很多想做的事情都没有做完（比如这次的朝花夕拾）</li></ul><p><img alt="Rescue Time" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-15_rescue-time.png"></p><p>还是希望自己的时间使用能够更专注更有效，不喜欢那种漫无目的的刷，下周继续观察。</p><p>时间方面谷歌日历已经可以做到每天具体的时间分配在什么事项上，但是每天的总结还是欠缺，下周开始补上。接下来是Forest专注时间观察，</p><p><img alt="Forest - Nov 8 ~ Nov 14, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_forest.jpg"></p><p>这周加入一个新的观察纬度，那就是健身数据，目前我的健身行为比较单一，就暂且以跑步的数字作为衡量。是的，在年初的时候，我给自己定下的目标是700公里，今年实际完成度很低。以年为单位总是会让人松懈，本周开始加入每周的跑步数据观察：</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Running Records" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_year-running.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Running - Nov 8 ~ Nov 14, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_running.jpg"></div></div></div></div><p>这里还希望加入的一个观察数据是睡眠时间，前一周看每天的上班时间，经常性的9点才出门，早上不想起来，晚上也睡的很晚。为了改善这个方面，继续立Flag。</p><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h4 id="反垄断法"><a href="#反垄断法" class="headerlink" title="反垄断法"></a>反垄断法</h4><p>背景：11月10日上午，国家市场监管总局发布《关于平台经济领域的反垄断指南（征求意见稿）》公开征求意见，目的是为预防和制止平台经济领域垄断行为，加强和改进平台经济领域反垄断监管，保护市场公平竞争，维护消费者利益和社会公共利益。指南发布后，阿里、美团、腾讯、京东等企业股价大跌。</p><p>分析：中国互联网野蛮生长了二十年，终于发展到现在足以影响到每一个人的体量。互联网企业作为平台型企业，做大之后开始从各个环节抽佣。另一方面，电商平台的二选一，社交平台的链接封杀，都引起了众多争议。这一次的反垄断指南，从某个方面反映了政府监管部门对于大平台问题的重视。但是，毕竟是平台型企业，反垄断指南能够执行到何种程度仍然值得观望，股价该回来还是会回来的。</p><h4 id="荣耀拆分出售"><a href="#荣耀拆分出售" class="headerlink" title="荣耀拆分出售"></a>荣耀拆分出售</h4><p>背景：荣耀拆分出售从最早的传闻到现越来越像真的了。本次传闻：根据去年荣耀60亿元利润，16倍PE来定，约为1000亿人民币，<strong>收购方包括神州数码、三家国资机构，以及TCL等公司组成的小股东阵营</strong>。拆分的缘由还是美国封杀，若华为分拆或出售荣耀手机，荣耀手机的采购零部件不受美国的华为禁令限制，将有助荣耀手机业务与供货商增长，这对荣耀品牌、供货商以及大陆电子业都是多赢局面。</p><p>分析：拜登当选，美国封杀令是否仍会继续？如果不再继续，华为是否能够凤凰涅槃，继续关注。</p><h4 id="Mac换芯"><a href="#Mac换芯" class="headerlink" title="Mac换芯"></a>Mac换芯</h4><p>背景：苹果发布M1芯片，宣布笔记本等产品线将从Intel芯片切换到基于ARM自研的M1芯片。</p><p>分析：从最早的PowerPC，到现在的M1，苹果软硬件一体的初心依然不变。这当然得益于其开创的软硬件生态，也是因为牙膏厂最年来牙膏越来越难挤了。关于M1具体细节尚未研究，不过毕竟是新体系下的第一款芯片，仍然需要时间打磨，现在的主要卖点应该还是功耗。</p><h4 id="辉瑞疫苗"><a href="#辉瑞疫苗" class="headerlink" title="辉瑞疫苗"></a>辉瑞疫苗</h4><p>背景：美国辉瑞制药和德国BioNTech在美股盘前宣布了其合作新冠疫苗的三期临床实验的首批结果，显示其有效性超过90%。受这一消息影响，欧美股市突然暴涨，道指期货涨逾5%，欧洲三大股指全线拉升，与此同时，随着全球风险偏好回升，美元、黄金等避险资产大幅下挫。</p><p>分析：疫苗才是真正的群体免疫。但是疫苗是否能够应对新冠病毒变异，是否最后真正有效，还需要继续观察，至少这个冬天应该还用不了。</p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>本期主题是「The Social Dilemma」，主题就是讲述了互联网公司通过获取用户数据，通过社交媒体来影响用户的事情。</p><p>这并不是一个新话题，早在年初的时候我就在 <a href="../3e030bdb/">Carpe Diem</a> 里面简单讨论过这个话题。正如那句话，羊毛出在猪身上，互联网用户享受的免费便捷的互联网产品是由广告厂商们为之付费的。互联网用户并不是大厂们的客户，广告商才是。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Back on track，本周继续「朝花夕拾」的定期发布，这里是今年的第二十四期「The Social Dilemma」，标题来自最新 Netflix 推出的一个剧情式纪录片。本期会简单聊聊社交困境，除了纪录片所涵盖的内容，还包括自己从字面上对其的漫无边际的延伸思考。&lt;/p&gt;

    &lt;div id=&quot;aplayer-VwHhmILQ&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;446874778&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-07_winter-bulrush.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="反垄断" scheme="http://houmin.cc/tags/%E5%8F%8D%E5%9E%84%E6%96%AD/"/>
    
      <category term="surveillance capitalism" scheme="http://houmin.cc/tags/surveillance-capitalism/"/>
    
      <category term="平台" scheme="http://houmin.cc/tags/%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>生活不止五险一金</title>
    <link href="http://houmin.cc/posts/c39a52c0/"/>
    <id>http://houmin.cc/posts/c39a52c0/</id>
    <published>2020-11-07T04:48:32.000Z</published>
    <updated>2020-11-17T03:55:38.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>又逢周末，上期的 <a href>「生日快乐」</a> 告诉自己要恢复「朝花夕拾」的更新，隔了一周，从今天开始。本期「朝花夕拾」的题目来自于前两天听「贤者时间」的一期播客，本文内容与播客内容基本无关，仅仅作为飘飞思绪的引子。恰逢立冬，白昼渐短，宵寒渐长，开始切身的感受到了节气的变化。凛冬将至，蛰伏开始。</p><blockquote><p>秋风吹尽旧庭柯，黄叶丹枫客里过。 </p><p>一点禅灯半轮月，今宵寒较昨宵多。</p></blockquote>    <div id="aplayer-rqIUrLde" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1331892086" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="秋天"><a href="#秋天" class="headerlink" title="秋天"></a>秋天</h3><p>上个星期又回了一次学校，和实验室的老师同学们打了一下午羽毛球，一起吃了顿饭。午饭间隙简单到未名湖转了一圈，补上了未名湖美丽的秋景。</p><p><img alt="同样的角度，今年年初冬天和夏天都拍过一次，这次补上了秋天的美丽" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-31_lake.png"></p><p><img alt="年初的时候，还记得这里有同学在打冰球" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-31_lake_1.png"></p><h3 id="立冬"><a href="#立冬" class="headerlink" title="立冬"></a>立冬</h3><p>豆瓣上 <a href="https://www.douban.com/people/zhoujie221/" target="_blank" rel="external nofollow noopener noreferrer">青简</a> 有一个 <a href="https://www.douban.com/photos/album/61629667/" target="_blank" rel="external nofollow noopener noreferrer">二十四节气</a>，记录了一年二十四节气中的各个美丽瞬间，正是这个相册让我有了拍出自己的一套二十四节气的想法。在以前，我基本上每年冬天都会走一趟颐和园，或者自己一个人，或者和ZY、和PT他们走过。今天立冬，在节气上冬天的开始，适逢 Feng 来北京，完成了今年的颐和园之行。想起来，自从初中毕业就很少见面，这次在北京两个人一起胡乱的聊起了身边的种种变化，忽的有一种中年人的感觉，此处略去不表。</p><p>尽管是立冬，北京的这个时候还是美丽的深秋，截取了这一天的美丽瞬间，算是我 「二十四节气」相册的开始：</p><p><img alt="下午时分，金色的阳光打在棕黄的芦苇身上，分外美丽" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-07_winter-bulrush.png"></p><p><img alt="这天的风很大，湖畔的柳带飘飞，对面的长堤已经染成了金色，远处的玉峰塔烟雾迷蒙" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-07_beginning-of-winter.png"></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>关于数据记录的意义我曾经在 <a href="../3e030bdb/">Carpe Diem</a> 这期专门讨论过这个问题，当时列出来几个工具用于记录自己的生活。因为种种原因（或者是因为你懒，或者是因为你没有时间，或者是因为你把宝贵的时间耗在了别处），数据记录的很多部分已经不再启用。没有做到这一步，也是因为定期总结的缺失。随着工作后生活走入固定节奏，我在这里再次重启（希望没有下一次重启），分析数据并修正自己的行为模式。</p><p>Resue Time记录一周的时间消耗，可以看到在工作日，每天的ScreenTime大概是9到10个小时，基本约等于自己的工作时间，这很合理（每天在班时间早上9点到晚上9点，减去中间休息的3个小时，剩下来的时间基本上都在看屏幕）。具体到每天的时间，除了软件开发使用 iTerm2 和 Goland，另外的时间就是企业微信。</p><p><img alt="Rescue Time" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-08_rescue-time.png"></p><p>总的来说，感觉自己每天工作的时候还是不够专注。日常会被企业微信的各种消息打扰，最近一个月以来积累的技术笔记也渐渐减少，更多的时间在做业务相关的实现，这很不好。一方面可以提高自己工作写码调试的效率，另一方面可以集中时间处理一些琐碎的事情，这是一个可以持续改进的问题。为了改进自己的工作状态，继续用Forest使用番茄工作法记录专注时间。另外一个令人开心的结果是，我现在已经形成了用日历来记录每天时间的习惯，虽然固定的每日总结有时候会鸽掉，至少现在在往好的方向走。</p><p><img alt="Forest - Nov 1 ~ Nov 7, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-08_forest.png"></p><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><p>「世界」是我在「朝花夕拾」中新开的栏目，用于关注我周围的世界正在发生的事情，想法来自于 <a href="https://github.com/ruanyf/weekly" target="_blank" rel="external nofollow noopener noreferrer">阮一峰的科技爱好者周刊</a>。与之前简单的通过刷微博来获取新闻信息源并吃瓜关注的效果不同，我希望这里会对过去一周发生的那些大事件进行深度阅读，理出自己的思绪，给出自己的分析与预测。此外，还会积极关注科技和商业领域那些新出现的有意思的东西，保持对新鲜事物的好奇心和敏感度。</p><h3 id="大事件"><a href="#大事件" class="headerlink" title="大事件"></a>大事件</h3><h4 id="美国大选"><a href="#美国大选" class="headerlink" title="美国大选"></a>美国大选</h4><ul><li>背景：大选前期民调显示拜登领先川普，然而在出票过程中经过了几轮反转，在最开始拜登领先的情况下，川普拿下了佛州，其他几个摇摆州的选票也逐渐开始反超，像极了2016年。然而随着邮寄选票的逐步计票，拜登开始抢回宾州、威斯康辛州等的选票，并最终获得超过270张选票。</li><li>现状：美国各大媒体已经宣布拜登胜选，欧洲英法德等国也积极向拜登表示祝贺。然而到现在(2020.11.09)川普仍然没有承认败选，反而鼓吹民主党选举舞弊，黑天鹅仍然存在。</li><li>分析：选举前的想法是，2020年全球疫情的背景下，川普在美国的疫情管理一塌糊涂（当然欧洲也是难兄难弟），种族矛盾爆发（BLM运动如火如荼），如此混乱的情况下，我们对于大选的预期大致是这么混乱满嘴胡话的川普应该是不太可能连任吧。然而，虽然最终却是是拜登胜选，但是选情能够胶着到这种情况着实是没有预料到的。这证明了川普在美国民众是有一大票民众真心支持他的，即使在这种情况下他们也仍然会选择川普。他们是些什么人？在全球化背景下，美国实体产业流失，原有的大批工人失业，从中产阶级坠落，生活状况急剧降低，与之相反，跨国公司的资本家在全球化的浪潮中获得了巨大收益。巨大的反差是特朗普各种操作下仍能够获得众多支持的重要原因，而且这种支持是长久的支持。</li><li>不论最后拜登是否能够顺利就任，美国社会的撕裂是仍将继续存在的。对于中国，应该做的仍然是做好自己的事情。拜登就任，也许将不再采用川普这种粗暴的贸易战做法，而是像之前一直以来的做法一样（典型的例子是操作系统、芯片等构建自己的生态，凭借高额的利润，以恰到好处的产品价格让你没有动力去研发自己系统下的市场产品），这才是最难受的，这也是我们大部分企业会放弃研发无法进阶高端产业的原因。</li><li>未来四年（2020-2024），全球化仍将继续，我们的实力会继续增长。前面还有很多困难，我们内部也还有很多问题，我们要继续努力，稳扎稳打，未来终将属于中国。</li></ul><h4 id="蚂蚁风波"><a href="#蚂蚁风波" class="headerlink" title="蚂蚁风波"></a>蚂蚁风波</h4><ul><li>背景<ul><li>10月24日，马云在上海外滩金融峰会抨击中国金融没有系统，监管太严、巴塞尔协议是老年俱乐部引发争议</li><li>11月2日，中国人民银行、中国银保监会、中国证监会、国家外汇管理局对蚂蚁集团实际控制人马云、董事长井贤栋、总裁胡晓明进行了监管约谈</li><li>11月2日，中国银保监会和中国人民银行对关于《网络小额贷款业务管理暂行办法（征求意见稿）》公开征求意见</li><li>11月3日，上海证券交易所致函蚂蚁科技集团股份有限公司《关于暂缓蚂蚁科技集团股份有限公司科创板上市的决定》</li><li>11月5日，蚂蚁集团原定于上海和香港同步挂牌上市，暂缓上市</li><li>11月6日，蚂蚁集团启动退款程序，投资人认购股份将注销</li></ul></li><li>分析<ul><li>什么是巴塞尔协议？巴塞尔协议是银行业为了维持资本市场稳定、降低银行系统信用风险和市场风险提出的资本充足率的要求。</li><li>我国银行给出的标准是10%左右，也就是说银行顶多只能有10倍杠杆，银行有1块钱，顶多只能借出去10块。</li><li>蚂蚁金服在重庆的两家小额贷款公司花呗和借呗，注册资金30亿，以1：2杠杆从银行借来60亿，凑足90亿资本金。</li><li>之后利用这90资本金开始放贷，获得大批的贷款合同，然后将这些贷款合同打包成资产卖给别人收回本金。这里的打包成资产，金融里称作ABS(Assets Backed Securities，资产抵押债券)。对没错，这就是在2008年次贷危机中发生巨大作用的金融产品。收回本金后，蚂蚁继续放贷，反复循环四十多次，形成3000亿多的贷款规模。本金只有30亿，杠杆率超过100。</li><li>按照蚂蚁集团的上市财报，其放贷规模目前已经达到了1.8万亿，但本金仅360亿，本金率约2%。换句话说，杠杆率高达50倍。自己只有1块钱，蚂蚁集团可以借出去50块钱，其他的49块钱银行出。这49块钱，银行收取5~6%的融资利息，但花呗和借呗放出去的利率，高达14~18%，中间的息差达到8~9%，全部归蚂蚁集团所有。要注意，你的利润是49块钱的8~9%，但你的本金只有1块钱。</li><li>11月2日中国银保监会和中国人民银行提出的网络小贷监管意见主要包括：<ul><li>放出去的贷款中，小贷公司自己的出资比例不得低于30%。</li><li>小贷公司通过银行借款、股东借款等非标融资形式，融入资金不得超过其净资产的1倍。</li><li>通过发行债券，资产证券化（ABS）等形式融资的金额，不得超过净资产的4倍。</li></ul></li><li>对比蚂蚁集团的上市招股书，可以看到网络小贷监管对于蚂蚁集团义务影响巨大。按照监管要求，蚂蚁的杠杆率将由50压缩到16倍以内，这对其市盈率将是巨大的打击。这也是为什么蚂蚁一直号称自己是科技公司，而不是金融公司。金融公司由于监管政策的限制，银行业的市盈率一般在10左右。蚂蚁原定上市计划中市值2万亿，大约3000亿美金，动态市盈率是47倍，显然大幅超过了一般的金融公司。</li><li>自己的观点，支持银行监管，毕竟有次贷危机的前车之鉴。但是蚂蚁作为新型公司，在大数据和互联网科技上肯定是有积淀的，肯定也可以在监管下发挥自己的作用，毕竟他们做的还是金融。这玩意儿不能松，不然出问题就是大问题。</li></ul></li></ul><h3 id="新东西"><a href="#新东西" class="headerlink" title="新东西"></a>新东西</h3><p>本期「朝花夕拾」对新东西、新概念的积累较浅，这次仅仅提一提最近在各个地方看到的DeFi（DecentralizedFinance），DeFi是区块链领域最近很火的一个概念，具体相关的内容以后要写一期来专门扫盲。</p><p>之前一直说要保持对于新科技、新创造的追踪，要做到这个，首先需要有一个各个行业的Overview扫盲贴，后续才能够持续的追踪。其实按照二八原则成本并不算太大，需要自己一点一点的积累。</p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>本期的主题是「生活不止五险一金」，最开始写这个题目是想借这个机会好好了解下五险一金与我具体相关的事情。是的，这些规则细碎而繁琐，但是你作为活在当前中国社会不得不接触的东西，从这里你可以了解到影响上亿人生活的规则。这些东西，确定了中国社会的最最基本的形态。</p><h2 id="附录：五险一金"><a href="#附录：五险一金" class="headerlink" title="附录：五险一金"></a>附录：五险一金</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>五险一金，就是指<strong>“养老保险、医疗保险、生育保险、工伤保险、失业保险和住房公积金”</strong></p><h4 id="覆盖人群"><a href="#覆盖人群" class="headerlink" title="覆盖人群"></a>覆盖人群</h4><ul><li>五险一金是有工作的人交的，因此上班族、自由职业者都可以参与。自由职业者可以自己选择缴费基数，但公司纳的一部分也要承担。</li><li>没有工作的人，比如家庭主妇，儿童及学生只能参加养老保险和医疗保险。<ul><li>其中，没有进城务工的农民参加的是<strong>新农保</strong>（新型农村养老保险）、<strong>城乡医保</strong>（城乡居民医疗保险）。</li><li>其他城镇居民则参加<strong>城居保</strong>（城镇居民养老保险）、<strong>城乡医保，</strong>大学生参加就读当地的城乡医保。</li></ul></li></ul><h4 id="缴费规则"><a href="#缴费规则" class="headerlink" title="缴费规则"></a>缴费规则</h4><p>五险一金分为公司缴费和个人缴费，公司缴费进入统筹账户，个人缴费进入个人账户（社保卡/医保卡）。</p><p>五险一金交多少取决于两个因素：<strong>缴费基数和缴费比率</strong></p><p><strong>缴费基数</strong>是你<strong>上个年度月均工资</strong>，但不能超过当地平均工资的<strong>三倍</strong>，也不会低于当地平均工资的<strong>60%</strong>。</p><p><strong>缴费比率</strong>全国各统筹地规定不同，但一般如下：</p><p><img alt="五险一金缴费比例" data-src="https://pic1.zhimg.com/80/v2-9774cb8f17777a3702d4827a13669a00_720w.jpg"></p><p>五险一金费用交下来，<strong>个人缴费</strong>占到你工资的<strong>11%</strong>左右，<strong>公司缴费</strong>占到你工资的<strong>25%</strong>左右。</p><h4 id="好处概述"><a href="#好处概述" class="headerlink" title="好处概述"></a>好处概述</h4><p><strong>总的来说：五险一金让我们能在大城市安家落户</strong></p><p><strong>分开来说：五险一金能在我们养老和生病，生孩子买房子这些事情上带给我们保障。</strong></p><h3 id="分述"><a href="#分述" class="headerlink" title="分述"></a>分述</h3><h4 id="医疗保险"><a href="#医疗保险" class="headerlink" title="医疗保险"></a>医疗保险</h4><h5 id="报销规则"><a href="#报销规则" class="headerlink" title="报销规则"></a>报销规则</h5><p>医保报销限定在“<strong>两定点，三目录</strong>”内——<strong>定点医院</strong>、<strong>定点药费</strong>和国家规定的医保可以报销的<strong>药品目录、诊疗项目目录、服务设施目录。</strong></p><p>在“两定点、三目录”内，还设置了<strong>起付线和封顶线</strong>，在两线之间，不同等级的医院，不同的人群，报销比率不一样：</p><p>医保报销分为门急诊报销和住院报销，</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-a4540ce83307f8482722dd9cee78d189_720w.jpg"></p><p>门急诊报销少，住院报销多；医院等级越低报销越多，反之报销越少；在职人员报销少，退休人员报销多。</p><p>至于具体的报销比率，各统筹地有自己的规定，</p><p>拿上海举例：</p><p>上海在职人员走医保门急诊，刷完医保卡当年计入账户部分后，自掏1500元便可开始报销，几万块的门诊费用医保能报销50%-65%。</p><p><img alt="上海在职人员门急诊医保报销" data-src="https://pic4.zhimg.com/80/v2-cb9646eb2f3219736b98746343cd0b77_720w.jpg"></p><p>如果是住院报销，先用医保卡刷掉1500元以后，在53万元以下的住院费用都可以报销85%，超过53万元的附加基金再报销80%。</p><p><img alt data-src="https://pic4.zhimg.com/80/v2-299c5c19d8528b004b44350e69ffc7bf_720w.jpg"></p><p><strong>我举个门急诊报销的例子：</strong></p><p><img alt data-src="https://pic1.zhimg.com/80/v2-a75aeefd82d4a41b29dce0e8c9313b24_720w.jpg"></p><p><strong>5万块的支付顺序是：</strong></p><p><img alt data-src="https://pic1.zhimg.com/80/v2-d77fad0b4a3c2ad66aabf62aaa24a660_720w.jpg"></p><p><strong>于是这次生病，</strong></p><p><strong>5万元的支付结构为：</strong></p><p><img alt data-src="https://pic2.zhimg.com/80/v2-9188ee739dad6985ff39bd1dd830ca49_720w.jpg"></p><p>生病花了5万，自己只掏了13250元，算下来医保报销了73.5%！</p><p>为患者减轻了很大的负担。</p><p>但现实中一些人的医保卡额度积攒得并不多，再加上报销上限只有两万块，</p><p>一旦遭遇大点的疾病或手术，一下子花个十几二十万，</p><p>还有很多能极大提高治愈率的技术不在报销范围内，比如癌症的质子重离子技术。</p><p>医保的作用就只能算是铺底了，真正能扛住大病风险的还是百万医疗险和重疾险。</p><h5 id="享受标准"><a href="#享受标准" class="headerlink" title="享受标准"></a>享受标准</h5><p>一般来说，医保今天交，<strong>次月</strong>就可以用<strong>统筹账户</strong>报销，<strong>半年</strong>或<strong>一年后</strong>可以用<strong>个人账户</strong>刷卡报销。</p><p>在退休前<strong>男性交满25-30年</strong>，<strong>女性退休前交满20-25年</strong>，退休后可以免费享受。</p><p>如果退休时缴费年限不够，可以一次性补缴剩余费用，然后才可以免费享受。</p><p>此外，也有不能享受的标准，主要为以下四方面：</p><ul><li><strong>应该由工伤保险基金支付的，比如尘肺病；</strong></li><li><strong>境外就医的；</strong></li><li><strong>应该由第三人（单位和个人）负担的，比如车祸；</strong></li><li><strong>应该由公共卫生负担的，比如新冠肺炎。</strong></li></ul><h5 id="异地就医"><a href="#异地就医" class="headerlink" title="异地就医"></a>异地就医</h5><p>医保不是全国通，是各省各地统筹，各统筹地的政策不一样，如果跨统筹地就医，就涉及到异地就医医保如何报销的问题。</p><p>在进行异地医保报销前，可以到先到<strong><a href="https://link.zhihu.com/?target=http%3A//si.12333.gov.cn/120692.jhtml" rel="external nofollow noopener noreferrer" target="_blank">国家社会保险公共服务平台</a></strong>查询<strong>支持异地医保直接结算</strong>的医保定点医院，再去就诊。</p><p><img alt data-src="https://pic4.zhimg.com/80/v2-00db9805efaa55c20380076736eeb9db_720w.jpg"></p><p>异地就医，分三种情况：</p><ul><li><strong>长期异地就诊</strong>——如在上海参保，但却在北京长期居住，居住期间生病就医；</li><li><strong>临时异地转院</strong>——如在上海参保，但上海治不了转到北京去医治；</li><li><strong>临时异地就诊</strong>——如在上海参保，但去北京旅游，出差，见亲人等生病就医。</li></ul><p><strong>三种情况处理方式不同</strong>，具体参见下图：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-1e14254c44d7d3d18b3ea92a8c98fec4_720w.jpg"></p><p><strong>异地医保报销需要特别注意的三点：</strong></p><ol><li><p>医保卡异地<strong>报销只限住院，门急诊部分城市才有。</strong></p></li><li><p>医保卡异地报销能<strong>报销的范围取决于就诊地医保政策</strong>，但能<strong>报销多少钱取决于你的参保地政策</strong>；</p></li><li><p>如果你办理了异地就医备案，回到原参保地之后，医保报销资格可能被取消，也可能还能用，也有可能取消备案之后才能用，这需要你咨询参保地医保局。</p></li></ol><p>所以，有什么问题一定不要忘记拨打<strong>12333</strong>的电话问清楚，因为各地的规定都不相同。</p><p>关于更详细的医保报销操作细节，也可以参考我这篇按照就医看病过程写的医保报销指南：</p><h4 id="养老保险"><a href="#养老保险" class="headerlink" title="养老保险"></a>养老保险</h4><p>养老保险简单理解就像我们每个月往银行存一笔钱一样，退休之后每个月往外取钱用。不同的地方是这钱存到了养老保险基金那里，由国家指派的专家组进行运作保值增值。</p><h5 id="养老金计算"><a href="#养老金计算" class="headerlink" title="养老金计算"></a>养老金计算</h5><p>养老金能拿到多少跟个人<strong>累计缴费年限、缴费工资、当地职工平均工资、个人账户金额、城镇人口平均预期寿命</strong>等因素有关，但一定是<strong>“长缴多得，多缴多得”。</strong></p><p><strong>公司交的钱进入基础账户，个人交的钱进入个人账户</strong>，退休后，两个账户都可以拿钱。</p><p>个人账户简单，就是每个月你存起来的钱，按照8%左右的年利增长（当年缴入按单利，历年累计按复利）。最后假设你60岁退休就将累积的这笔钱分成139个月发给你。</p><p>基础账户能拿到的钱由一个复杂的公式确定，计算比较复杂，，但可以肯定的是，你退休前的工资越高，当地工资越高，交的年限越久，你能从统筹账户拿到的退休工资就越多。</p><p>举个例子：王华，23岁，上海工作，2020年工资8600，从今年交社保交37年后60岁在上海退休，未来他的工资假设如下：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-ed6f8aba8f8ebc1f05c948c5affc3184_720w.jpg"></p><h5 id="领取资格"><a href="#领取资格" class="headerlink" title="领取资格"></a>领取资格</h5><p>领取养老金要满足三个条件：</p><ul><li><strong>至少缴满15年；</strong></li><li><strong>第二必须到退休年龄；</strong></li><li><strong>办理完退休证明。</strong></li></ul><p>退休时还没有交满15年的<strong>必须补满15年才能领，</strong></p><p>但按照上面的公式，如果我们只交15年养老金就不交的话，<strong>最后只能拿到社会平均工资的15%</strong>，这是非常少的。</p><p>如果是工伤导致退休，这笔钱由企业补满，自然退休则是自己补满。</p><p>退休年龄为国家规定的退休年龄，如下表：</p><p>其他关于养老金断缴，领取地以及是否能拿回来的问题，参见后面<strong>番外篇详述部分</strong>。</p><h4 id="生育保险"><a href="#生育保险" class="headerlink" title="生育保险"></a>生育保险</h4><p>生育保险也是五险一金中非常重要的一个，待遇丰厚，与其他四险一金绑定在一起缴纳。</p><p>而且是企业为我们缴纳，职工不用缴纳。</p><p><strong>第一：生育险的待遇有哪些？</strong></p><p>生育保险的待遇有三项：<strong>产假、生育津贴、生育医疗费用报销。</strong></p><p>参保的女职工不仅能修超长产假，在休假期间还有生育津贴（产假工资），生孩子的医疗费也可以报销一部分。</p><p><strong>产假</strong>：分为<strong>基本产假、产前检查、产前工间休息、授乳时间。</strong></p><p>基本产假如下表：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-feeb1f582ed895f246d2a695fc6eb46c_1440w.jpg"></p><p>其他与产假相关的假期各地规定不一，具体参考当地女职工劳动保护办法。</p><p>以上海为例：</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-eef4e6ae24e32a05c4ac4c3f6ae33e85_1440w.jpg"></p><p>另外，女职工还可以因为生育而请的假如下：</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-2c8b95fd6beaee3cd821f9e63e71c9d5_1440w.jpg"></p><p><strong>生育津贴：</strong></p><p>生育津贴又叫产假工资，由生育保险基金支付，可以自己去社保网点领取，也可以拨给公司，由公司代付。</p><p>发放生育津贴的时间主要是<strong>产假期间</strong>和计划<strong>生育手术休假期间</strong>，计算如下：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-e82255a792f032755bc110e87e6c62fc_1440w.jpg"></p><p>举个例子：</p><p>花花生孩子时休息了98天，后来去上环又休息了15天，她单位上年度月均工资是6500，则她可以领到（6500/30）*（98+15）=24483元。</p><p><strong>特别注意：</strong>如果公司的缴费基数高于职工的缴费基数，<strong>不足的部分由公司补足。</strong></p><p><strong>生育医疗费用报销：</strong></p><p>生育医疗费用报销的项目有：因怀孕、生育而发生的<strong>检查费、接生费、手术费、住院费、药费、计划生育医疗费用</strong>。</p><p>至于报销限额，<strong>各地规定不一样</strong>，以上海市为例：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-fb1732dd90d143fb9d544e1367adc9ac_1440w.jpg"></p><p>上海市采取固定额度报销的方法（有的地方是按比率报销）。</p><p>只要符合生育金缴纳标准，正常生育报销3600，</p><p>自然流产的，大于4个月的报销600，小于4个月的报销400，超出的地方自费。</p><p><strong>第二：生育险待遇领取的标准</strong></p><p>各地规定不一，以上海市为例：</p><p>要么是某公司为职工<strong>连续缴纳至少9个月，</strong>或者不同公司已经为职工<strong>累计缴纳至少12个月。</strong></p><p><strong>生育期间千万别断交，不然报不了。</strong></p><p>如果是<strong>未婚先孕</strong>，则<strong>不能享受</strong>生育险待遇，因为不符合计划生育政策，</p><p>只能先跟另一位把证领了才能报销。</p><h4 id="工伤保险"><a href="#工伤保险" class="headerlink" title="工伤保险"></a>工伤保险</h4><p>工伤保险是用来在职工因为工作相关的事情受伤或者罹患职业病之后给职工提供医疗和补偿的，用以保障职工往后的生活，待遇非常丰厚，由企业为职工缴纳，职工不用掏一分钱。</p><p><strong>第一：工伤保险有哪些待遇？</strong></p><p>工伤保险赔付丰厚，既报销，又给钱。</p><p>具体包括：</p><p><strong>医疗费、住院伙食补助费、交通费、食宿费、康复治疗费、辅助器具费</strong>，这些都<strong>报销</strong>；<strong>停工留薪、护理费、伤残待遇、工亡待遇</strong>，这些都<strong>给钱</strong>。</p><p>其中最重要的是<strong>医疗费、停工留薪、伤残待遇和工亡待遇。</strong></p><ul><li><strong>医疗费：</strong>遭遇工伤或者职业病时治疗所必须的医疗费<strong>全部报销</strong>；</li><li><strong>停工留薪：</strong>遭遇工伤或者职业病时不能工作期间的工资和福利由工伤基金按照正常上班的标准给付；</li><li><strong>伤残待遇：</strong>遭遇工伤或者职业病造成不同程度的残疾，工伤基金按照不同伤残等级(1-10级)给付伤残待遇；</li><li><strong>工亡待遇：</strong>遭遇工伤或者职业病之后死亡了，工伤基金会赔给你的家人<strong>一笔钱</strong>，还有<strong>丧葬补贴</strong>等。</li></ul><p>具体规定见下表：</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-9d7e1f36a65e927e228e07916bb2c766_1440w.jpg"></p><h5 id="工伤认定的流程"><a href="#工伤认定的流程" class="headerlink" title="工伤认定的流程"></a>工伤认定的流程</h5><p>当我们不幸在工作中出现事故，导致伤残时，我们就成了弱势群体，这个时候必须得保持<strong>头脑清醒</strong>，<strong>主动维权。</strong></p><p>大致描述一下情形，当我们因为工作出事故后，会经历的过程如下：</p><p><strong>紧急送医→企业为员工申请认定工伤→进行工伤认定→伤残者进行伤残等级鉴定（劳动能力鉴定）→死亡者发死亡补助</strong></p><p><img alt="工伤认定环节流程图" data-src="https://pic2.zhimg.com/80/v2-6947d490b41330a7751732694e65c8a5_1440w.jpg"></p><p>我们需要注意到的是：<strong>工伤认定属于行政行为，不申请，不认定</strong>。</p><p>如果企业不给我们认定，我们<strong>一定要自己或者叫近亲属或者找工会帮忙认定</strong>。</p><p>并且，<strong>超过一年，不予认定。</strong></p><h5 id="可以认定为工伤的情形"><a href="#可以认定为工伤的情形" class="headerlink" title="可以认定为工伤的情形"></a>可以认定为工伤的情形</h5><p>两种情况，一个是<strong>得病</strong>，一个就是<strong>受伤</strong>。</p><p><strong>得病，指的是得了法定的职业病­</strong>——即劳动者在职业活动中因<strong>接触粉尘</strong>、<strong>放射性物质</strong>、和<strong>其他有毒有害物质</strong>因素而引起的疾病，包括十大类，具体如下表：</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-45946ea860e8995ba7fce2ee62737d2a_1440w.jpg"></p><p>可以看到，职业病主要时跟有毒有害的物质有关，而<strong>“996”加班</strong>，<strong>积劳成疾的码农等，每日空调、WiFi、零食相伴，就算累成狗累出心脏病也不算职业病。</strong></p><p><strong>受伤，就是受到身体伤害或者是暴力伤害</strong>，具体可以认定为工伤的情形如下：</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-8b40ee81808920a4695902e01655a72a_1440w.jpg"></p><p>特别需要注意的是：</p><p><strong>上班期间救火等负伤也算工伤，还有当兵回来旧伤复发的也算工伤。</strong></p><p><strong>还有，上班期间收到暴力伤害，也算工伤，比如执行本职工作时被人打击报复受伤，可以认定为工伤。</strong></p><p><strong>第三：如何进行工伤等级鉴定（劳动能力鉴定）？</strong></p><p>工伤认定和工伤等级鉴定是有区别的，</p><p>小伤小病进行工伤认定之后，如果医治一段时间还没有好，并且影响工作和生活自理，就需要申请工伤等级鉴定。</p><p>但工伤等级鉴定需要满足一定的<strong>医疗期规定</strong>，具体如下表：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-eb4f259cac7b29a4a51c351e515a3664_1440w.jpg"></p><h5 id="工伤等级鉴定"><a href="#工伤等级鉴定" class="headerlink" title="工伤等级鉴定"></a>工伤等级鉴定</h5><p>工伤等级鉴定的大致流程如下图所示：</p><p><img alt data-src="https://pic4.zhimg.com/80/v2-68648fbc1e68dad56cf4a69a373f71d7_1440w.jpg"></p><h5 id="工伤等级鉴定需要准备的材料"><a href="#工伤等级鉴定需要准备的材料" class="headerlink" title="工伤等级鉴定需要准备的材料"></a>工伤等级鉴定需要准备的材料</h5><p>工伤等级鉴定需要准备的材料如下表：</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-d7ccd19609b4633c0f1953ff90573a7e_1440w.jpg"></p><p>特别需要注意的是，<strong>进行工伤等级鉴定前，需要先进行工伤认定</strong>，只有工伤认定书出来后才能进行工伤等级鉴定。</p><p><strong>第四：工伤鉴定中“上下班途中”是如何规定的？</strong></p><p>《工伤保险条例》中规定，<strong>上下班途中遇到自己非主责的交通意外可以认定工伤。</strong></p><p><strong>但什么才叫上下班途中？</strong>几点到几点？还是从哪儿到哪儿？</p><p>最高院在《最高人民法院关于审理工伤保险 行政案件若干问题的规定》中，对“上下班途中”进行了明确的定义：</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-164ec28aeadc16a5dc14ad4c2419422e_1440w.jpg"></p><p><strong>第五：工伤保险待遇的领取标准</strong></p><p>企业给你交，只要交上，当月就可以报销，</p><p>但也不能断，断了的话可以走仲裁，仲裁不过走司法程序。</p><p>记住这句话就行了。</p><h4 id="失业保险"><a href="#失业保险" class="headerlink" title="失业保险"></a>失业保险</h4><p>失业保险，顾名思义，就是在我们失业的时候给我们补贴和培训，帮助我们尽快上岗的保险。</p><p>其中，失业是指被辞退，一定企业方解除合同，并不是我们主动辞职。</p><p><strong>第一：失业保险都有哪些待遇？</strong></p><p>参保失业保险的人，失业了可以拿到的补助有<strong>失业保险金</strong>、<strong>医疗补助金</strong>、<strong>死亡后的丧葬补助金</strong>和<strong>抚恤金</strong>，</p><p>还有一定的<strong>职业培训和工作介绍</strong>。</p><p>一般而言，失业保险金<strong>只能拿到当地最低工资的一部分，缴纳时间越长，可领时间也越长。</strong></p><p>但<strong>只能领取12-24个月</strong>。具体能领多少个月，由当地<strong>省级政府规定</strong>。</p><p>以上海市为例：</p><p><strong>缴纳期限</strong></p><p><img alt data-src="https://pic4.zhimg.com/80/v2-178ecad9000541bd3cdc3de96c409fbb_1440w.jpg"></p><p><strong>领取标准</strong></p><p><img alt data-src="https://pic1.zhimg.com/80/v2-214e336f7e4e42779d79d873fd3823d8_1440w.jpg"></p><p>在上海，<strong>非本地户口也不能领取</strong>，</p><p>如果失业了，<strong>只能把失业保险账户转到户籍地去按照户籍地的标准领</strong>。</p><p><strong>第二：失业保险待遇的领取标准</strong></p><p>至少缴满<strong>一年</strong>才能领取。</p><p>如果连续两次失业，第二次领取失业金时，之前的缴费年限清零计算，所以两次失业必须间隔一年以上才能领取。</p><p>但你之前如果没领满12个月，可以累加到下一次，两次累加不能超过24个月。</p><p>小时候，我妈常对我说“<strong>晴带雨伞，饱带饥粮</strong>”，做人一定要有危机感，不能躺在功劳簿上睡大觉，止步不前。</p><p>活得太过安逸，为人所耻，在国家给的失业保险金上面就能看得出来。</p><h4 id="住房公积金"><a href="#住房公积金" class="headerlink" title="住房公积金"></a>住房公积金</h4><p>住房公积金就是国家强制你和企业每个月拿出一点钱，存到一个账户里，然后把所有人的账户里的钱汇集到一起形成一个基金，以后你买房子就可以从这个基金里面贷款，拿到的利率全国最低，没有之一。</p><p>从我们贷款买房者的角度去讲讲最需要关注的这几个点：</p><h5 id="住房公积金的利率有多低？"><a href="#住房公积金的利率有多低？" class="headerlink" title="住房公积金的利率有多低？"></a>住房公积金的利率有多低？</h5><p>公积金存贷利率都由国家统一规定，各地一样，普遍比商业贷款利率低。目前是5年以上按3.25%年利算，5年（含5年）以下按2.75%年利算，贷一年的话不分期，一年以后连本带利一起还。同期商贷1年是4.35%，2-5年是4.75%，5年以上4.9%。这个利率是非常低了，工商银行5年期定期存款利率也才正好是2.75%。和公积金贷款5年以下的一样，5年以上的和它相比，利差只有0.5%，某些专给小微企业贷款的融资租赁平台，实际贷款利率高达20%多，连我们常见的支付宝借呗年利都是18.25%。</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-c7a8dd0ea94d3d54de0d39a5c76ae66a_1440w.jpg"></p><h5 id="住房公积金能贷多久？"><a href="#住房公积金能贷多久？" class="headerlink" title="住房公积金能贷多久？"></a>住房公积金能贷多久？</h5><p>最长不能超过30年，以夫妻双方年龄大的为准，男性贷款年龄加上房贷时间不能超过65岁，女性不能超过60岁。</p><p>与楼龄也有关系，砖混结构的楼龄加上贷款年限不能超过47，钢混结构的楼龄加上贷款年限不能超过57。</p><h5 id="住房公积金能贷多少？"><a href="#住房公积金能贷多少？" class="headerlink" title="住房公积金能贷多少？"></a>住房公积金能贷多少？</h5><p>额度计算比较复杂，有四种计算额度的方法，取<strong>四种方法里面最低的结果</strong>作为我们<strong>可以拿到的贷款额度</strong>。</p><p>举个例子：</p><p>王华，工资8000，单位和个人按照 7% 的比例缴纳住房公积金，交了10年，目前无负债。</p><p>现在看中一套90平的房子，付完3成首付还要再贷款100万才能买下来，他打算贷款30年。</p><p><strong>问：王华用公积金贷款能贷多少钱？</strong></p><p><img alt data-src="https://pic1.zhimg.com/80/v2-b7fef69873e6253baf002429c68bdfa4_1440w.jpg"></p><p>计算公式为：</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-92b63b4e2464967ca85c001944b378d5_1440w.jpg"></p><p>还款能力系数是扣掉当地最低消费水平后收入剩余部分占总收入的比重。</p><p>按公式计算王华的可贷额度为：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-b55880b574fcd47787f1be31985f7e38_1440w.jpg"></p><p>如果夫妻一起贷，并且妻子跟王华财务状况一样，那么贷款额度可以翻倍——<strong>男女结婚后共同努力可以住更大的房子！</strong></p><p><img alt data-src="https://pic2.zhimg.com/80/v2-710fd739fab35405189f1486d35ffa75_1440w.jpg"></p><p>计算公式为：</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-c892f6debd2e54853a1d1eaec33c6b44_1440w.jpg"></p><p>上海的政策来说，90平以下的首套房，首付20%，可贷比率为80%，</p><p>90平以上的首付30%，可贷比例为70%。</p><p>前面王华已经付了三成首付，想要贷款的100万已经是70%了。</p><p>所以额度就只有100万。</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-43a638d5140c2bff14e966cd25a71baa_1440w.jpg"></p><p>各地对住房公积金购房贷款额度有限制，上海的政策如下：</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-eccba2f8b3089fce7235cb8cd27919c6_1440w.jpg"></p><p>那么，如果王华<strong>一个人买</strong>，<strong>最高只能</strong>用公积金贷款<strong>50万</strong>，<strong>夫妻一起买，最高可以用公积金贷款100万。</strong></p><p><img alt data-src="https://pic2.zhimg.com/80/v2-20635855ac97ae932d55c79b9ecfd3e9_1440w.jpg"></p><p>此方法是指公积金贷款额度最高不能超过个人公积金账户存储额的n倍，这里的n，各地规定不一，上海目前是15倍。</p><p>每年进入王华公积金账户的钱，当年的按照0.35%年利按月复利计息，往年留存下来的本息和按照1.35%的年利按一年期定存计息。</p><p>最后计算出来王华10年后公积金账户余额为14.3万，余额的15倍为214.7万。</p><p><img alt data-src="https://pic1.zhimg.com/80/v2-f57569d54fe65706ad77e34a21ee71d4_1440w.jpg"></p><p>四种方法比较下来，<strong>最高贷款限额算法 &lt; 还款能力算法 &lt; 可贷比例算法 &lt; 账户存储额倍数算法</strong></p><p>那么，如果此次买房，王华一个人用公积金贷款的话，只能贷款50万，夫妻可贷100万。</p><h5 id="住房公积金该不该取出来？"><a href="#住房公积金该不该取出来？" class="headerlink" title="住房公积金该不该取出来？"></a>住房公积金该不该取出来？</h5><p>大家都知道，公积金可以取出来，但如果取出太多，可能账户余额的15倍会低于上海贷款最高限额。所以，如果王华要取出来公积金，也得保证余额的15倍至少高于当地最高限额50万。剩下的，能取就取出来吧。</p><h5 id="住房公积金和商贷比例控制在多少比较合适？"><a href="#住房公积金和商贷比例控制在多少比较合适？" class="headerlink" title="住房公积金和商贷比例控制在多少比较合适？"></a>住房公积金和商贷比例控制在多少比较合适？</h5><p>当公积金贷款不能满足我们时，我们一般都选择商贷和公积金组合贷。但是比例控制在多少比较合适呢？</p><p>一张图说明白：</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-6229d29b923d774a5226168aa5d698b5_1440w.jpg"></p><p>可以看出，商贷用得越多，总还款额越多，月供也越多，所以能全用公积金贷款的额度就用公积金贷款的额度，不够再用商贷。</p><h5 id="住房公积金贷多少年比较合适？"><a href="#住房公积金贷多少年比较合适？" class="headerlink" title="住房公积金贷多少年比较合适？"></a>住房公积金贷多少年比较合适？</h5><p>公积金最长贷30年，也可以不贷那么多年。</p><p>具体贷多少年，由个人的资金状况和还款计划决定，从纯金融的角度来说，存在一个合理的答案如下：</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-29649d064765def05bb1bcaa1eb00e91_1440w.jpg"></p><p>可以看出，前期月供压力很大，但是到15年的时候已经下降到7000左右，夫妻二人承担压力就小很多了，时间再长一点月供下降不多，但是还款总额就要增加几十万了。</p><p>所以，贷款时间控制在15年最合适。</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="养老金能否拿回来"><a href="#养老金能否拿回来" class="headerlink" title="养老金能否拿回来"></a>养老金能否拿回来</h4><p>我们国家养老金实行的是“现收现付”制，现在的年轻人交钱给现在的老年人用，但老龄化越来越严重，年轻人养老负担越来越大。</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-8f21164249323eb72cd36699141174c1_1440w.jpg"></p><p>个人账户养老金的利率也从原来的2/3%一下子提高到现在的8%左右，前面王华的养老金也计算到了6万多，远比他退休前的工资要高很多。于是有的人就担心，老年人那么多，我交这么多年，<strong>轮到我的时候还能领得了养老金吗？</strong></p><p><strong>结论是：肯定能领到，只是没有我们计算的那么多。</strong></p><p>因为国家采用了几大措施用来保障大家退休之后能够拿到因该得的养老金：</p><p><strong>第一个措施：控制养老金替代率</strong></p><p><img alt data-src="https://pic3.zhimg.com/80/v2-c273b879a65514a34c9703be126e811a_1440w.jpg"></p><p>养老金替代率就是我们领到的养老金占退休时当地平均工资的比例，越高越能保障我们的晚年生活。</p><p>根据劳动和社会保障部《关于完善企业职工基本养老保险制度宣传提纲》的总体思路，未来基本养老金目标替代率为59.2%。</p><p>所以，我们不会领到6万多的养老金，也不会领到过低的养老金，而是在当地工资的6成左右。</p><p><strong>第二个措施：养老金记账利率盯住工资增长率</strong></p><p>很多人都抱怨养老金个人账户收益率太低。确实，原来的养老金的利率普遍在2/3%左右，但是工资水平却每年以10%左右的水平增长，如此增长下去，几十年以后养老金相比于工资就会少得可怜。于是国家将养老金记账利率调高到8%，远远超过很多市场上的理财产品收益。</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-5a758f9218a5c177153c85ee6372c405_1440w.jpg"></p><p>用来盯住工资增长率，换句话说，也就是养老金增长跟随通胀走，这样才能保证以后我们拿到的养老金能够扛住通胀，不会贬值幅度过大。</p><p><strong>第三个措施：多方筹款，保证有钱给大家养老</strong></p><p>工资水平年年在涨，养老金水平也每个月都在增加。</p><p><img alt data-src="https://pic3.zhimg.com/80/v2-3bf8abd1624ecfe7fbf175c7e3bebe46_1440w.jpg"></p><p>再加上公务员养老和职工养老并轨，全部参保人员的养老金计息一下子提高了很多，这样养老金基金的负债压力越来越大，已经产生了巨大的缺口。于是国家<strong>采取多方筹款</strong>的方式用来解决现在老人的养老金支付问题</p><ul><li><strong>第一是成立全国社保基金用来在老龄化高峰之时弥补和调剂养老金统筹基金的缺口。</strong>全国社保基金的资金来源于<strong>中央财政预算拨款，国有资产划转，个人账户基金并入、地方政府委托基金</strong>。2018年末，社保基金资产总额22,353.78亿元，并且社保基金自成立以来的年均投资收益率7.82％，累计投资收益额9,552.16亿元。</li><li>第二就是<strong>全国企业缴纳的基本养老金统筹基金，企业缴纳本人工资的16%用来支付养老金。</strong>2018年末，基本养老保险基金资产总额7,032.82亿元。自2016年12月受托运营以来，累计投资收益额186.83亿元，实现的收益率在4%左右。</li></ul><p>所以，国家通过各种方式筹集资金，为我们的养老大事做足准备，虽然压力很大，年年都有窟窿，但只要国家在的一天，我们就有养老的一天。只是，养老金的水平要照顾到目标替代率和工资上涨速度，可能未来会增长趋缓，最坏的情况也就是下降到目标替代率。</p><p><strong>因此，养老金肯定能拿回来，只是不像我们计算的那样多。</strong></p><h4 id="高工资低公积金现象"><a href="#高工资低公积金现象" class="headerlink" title="高工资低公积金现象"></a>高工资低公积金现象</h4><p>很多人都会发现，为什么自己每个月到手一两万，但是住房公积金怎么只有几百块？相比别人，为什么他的工资才五六千，公积金每个月都有一两千？实际上，不仅是公积金，整个社保都一样，我们缴费多少，取决于两个因素：<strong>缴费基数和缴费比率，</strong></p><p>本质上来说，缴费比率国家已经定死了，可以自由选择的那一两个百分点在基数相同的情况下差别不大，真正导致缴费差别大的是缴费基数——<strong>有的公司会偷偷给你把缴费基数降低！</strong></p><p>常见的手段主要有两种：</p><ul><li><strong>公司用好几张银行卡给你发工资</strong></li><li><strong>公司给你的工资底薪很低，绩效很高。</strong></li></ul><p>如何操作呢？</p><p>比如王华的工资是10000，但是公司要求他用四张银行卡来发工资，于是王华提交了他自己、姐姐、妹妹、老婆的银行卡。然后公司将10000块分成四份转到四张卡里，只有王华的2500走的是工资账户，其他三张则是网转。这样王华的账上工资一下子变成了2500，那自然同样的缴费比率，10000和2500相比，差了好几级。</p><p>或者是公司将王华的10000工资分成5000的工资和5000的绩效，每次就只按照5000的工资来缴纳社保，5000绩效则通过网络转账的方式。</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-d61469a45920762049d00ba7b45902a1_1440w.jpg"></p><p>但实际上，我们前面说了，社保缴纳基数也包括绩效工资，奖金，等等，所以，公司这样做是违法的，如果你想告，一告一个准。虽然，到手的工资高了，但是几十年下来，这么一大个福利你就拿得少了，公司少给你缴纳的社保也是多发给你工资的几倍，最终吃亏的是你自己。</p><h4 id="北漂一族养老金领取问题"><a href="#北漂一族养老金领取问题" class="headerlink" title="北漂一族养老金领取问题"></a>北漂一族养老金领取问题</h4><p>对于北上广深的“漂一族”来说，去往大城市就业，机会多，资源多，福利好。但总有一个问题避免不开，那就是在哪里退休的问题——养老保险对与退休金的领取地有特别的规定：国家规定：养老金的领取，遵循<strong>“户籍地优先，从长从后”</strong>的原则。</p><p>用王华举例子：</p><ul><li>王华<strong>户籍在湖南</strong>老家，在<strong>湖南交</strong>的养老保险，最后也在<strong>湖南退休</strong>，退休后养老保险肯定在湖南老家<strong>按照湖南</strong>老家的标准领取。</li><li>王华<strong>户籍在湖南</strong>，但<strong>在上海缴了</strong>至少<strong>10年</strong>的社保，最后在<strong>上海退休</strong>，退休后养老金<strong>按照上海标准</strong>发放。</li><li>王华<strong>户籍在湖南</strong>，<strong>在上海缴满了十年</strong>的养老保险，然后他<strong>转到北京</strong>工作，<strong>缴纳五年</strong>社保后退休（退休地不满十年），那王华的养老保险<strong>关系</strong>将会被<strong>转回上海</strong>，然后<strong>按照上海的标准</strong>领取养老保险金。</li><li>王华<strong>户籍在湖南</strong>，在<strong>上海</strong>干了<strong>5年</strong>，在<strong>北京</strong>干了<strong>7年</strong>，在<strong>深圳</strong>干了<strong>6年</strong>，然后<strong>退休</strong>（退休前每个地方<strong>都没有缴满十年</strong>），那王华的养老保险账户将被<strong>转到湖南老家</strong>，<strong>按照湖南的标准</strong>领取养老金。</li><li>王华<strong>户籍在湖南</strong>，全国各地转来转去，最后<strong>退休了</strong>，但是养老保险<strong>还没缴满15年</strong>，可以按照规定确定一个补缴地，<strong>在补缴地缴满并领取</strong>养老金。</li></ul><p><img alt data-src="https://pic3.zhimg.com/80/v2-3e251ef64a26b699fd48945517796f7e_1440w.jpg"></p><p>从上面的政策规定，我们最好的选择是在上海缴纳满10年，或者在上海退休又或者有上海户籍，才能拿到上海的养老金。</p><p>但假设王华从23岁毕业来上海，缴满10年的话，到33岁了，这个时候应该是结婚的年龄了，（有数据显示，大城市结婚年龄普遍在31岁左右）。假设王华10年内工资平均下来每月1.3万。</p><p>那么，在上海郊区买一套普普通通的商住楼，需要不吃不喝<strong>89个月（7.5年），</strong>如果节省得好，每个月剩下来4000攒首付，需要<strong>290个月（24年），况且这24年中房价得涨到多高？</strong></p><p><img alt="上海青浦区——乡下某套房价格" data-src="https://pic1.zhimg.com/80/v2-e526070fd97e70b55ba5bc071234a44c_1440w.jpg"></p><p><strong>年龄已经快要被剩下了，但首付还没攒到一半。</strong></p><p>面对买不起的房子和娶不起的新娘，我相信很多人都会撑不到10年就离开了。那我们就再也没希望拿到上海的养老金了。如果你不是实力非凡，其实大部分人在北上广呆个几年就各回各家了。这点从上海常住总人口的增长就可以看出来。</p><p><img alt data-src="https://pic4.zhimg.com/80/v2-fcf77c552e7199dc5e5edd9ce8e711cf_1440w.jpg"></p><p>这几年，上海总人口不仅没有增长，还大有负增长的趋势。可悲的是“<strong>融不进的城市，买不起的房，拿不了的户口，娶不起的新娘</strong>”是当代绝大部分“漂一族”的真实状况；但更可悲的是，年轻人在大城市工作的那么些年，缴纳的五险一金有80%的人群公司都没有给他们足额缴纳；但更更可悲的是，就算企业为你正常缴纳社保，你也不一定能用上。<strong>企业给你交得再多，也不过是养那些有当地户口，在当地买房的人罢了。</strong></p><h4 id="离职后社保的处理"><a href="#离职后社保的处理" class="headerlink" title="离职后社保的处理"></a>离职后社保的处理</h4><p><strong>第一：社保断缴后的影响？</strong></p><p>不管什么原因，我相信大家离职一定有大家的道理，离职后社保就会断缴，但社保一旦断缴，损失惨重。</p><p><strong>1. 买房落户、买车拍牌等会受影响</strong>。</p><p>以上海为例：</p><p>想拿到上海户籍，在社保缴纳方面每正常缴纳满一年积累3分，中间断缴后再补缴的部分不能计入积分。</p><p>想要在上海买房，社保方面需要<strong>连续</strong>缴纳满5年，中间断缴，或再补缴都不行。</p><p>想要拿到沪牌竞拍资格，需要本市户籍或者有居住证的前提下还要已经<strong>连续</strong>缴满3年社会保险，断缴或者补缴都不行。</p><p><strong>2.医保待遇会受到影响。</strong></p><p>以上海为例：</p><p>断缴之后，有3个月缓冲期，缓冲期内不享受医保。如果断缴超过3个月，缴费年限直接清零重算，</p><p>而上海医保必须至少要缴满15年，退休之后才能享受免费的医保待遇。所以一旦断缴超过3个月，之前的年限就浪费了。</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-4cff339ab8c6f34c560164446610d515_1440w.jpg"></p><p><strong>3.生孩子报销也会受到影响。</strong></p><p>根据规定，生育保险只有单位<strong>连续</strong>为你缴纳9个月或者累计缴纳12个月才可以享受生育保险。</p><p>就算累计缴纳12个月了，一旦不缴纳，次月一日起就不能享受生育保险了。</p><p><img alt data-src="https://pic2.zhimg.com/80/v2-4ebdb2d83363ee0cc583434cf0798979_1440w.jpg"></p><p><strong>4.对养老金的影响。</strong></p><p>国家规定至少缴满15年，退休之后才能领取养老金。</p><p>如果中间有断缴的，断缴时间不能计入缴费年限，只有员工足额补齐所欠保费和利息之后，才开始继续计算缴费年限。并且，存在中断养老金缴费情况的人，退休后领取养老金数额要比没有断缴的人一个月少几十块。</p><p><strong>第二：社保断缴后怎么处理？</strong></p><p>社保断缴有好几种原因：</p><p><strong>第一个，公司故意不给你缴。</strong></p><p>这个简单，留好证据，举报就行。如果我们<strong>不知道具体的怎么搜集证据、怎么在进行维权等事宜</strong>，我们可以<strong>打电话询问的机构</strong>是：<strong>人力资源和社会保障局咨询服务中心——</strong>承担劳动保障监察、医疗保险、人事人才等电话举报的受理工作。</p><p>我们可以进行举报投诉的机构是：<strong>劳动保障监察总队——</strong>受理举报投诉和平日里监督各用人单位是否遵守劳动保障法律法规的。</p><p><strong>第二个：离职后断缴。</strong></p><p>第一个方法就是尽快找到下家，在15号上家公司交完社保后再离职，在下一个15号前找到下家入职就行。</p><p>第二个方法也可以跟上家或者开公司的朋友谈一谈，把自己的社保挂在别人的公司上缴纳，但成功率由个人决定。</p><p>第三个方法就是花点钱（平均50-60一个月）找一家靠谱的社保代缴机构帮你缴纳。</p><p>如果已经断了，要赶快打电话（12333）问社保机构该怎么补缴，失业险影响不大，但养老和医保影响巨大，一定要赶快行动。</p><p><strong>第三：换工作城市社保怎么转移？</strong></p><p>如果在同一个统筹区内换工作，比如王华在上海换到上海，唯一需要做的就是把社保账号和公积金账号记住，交给下一加的人事部门就可以了，你可以登录当地社保局和住房公积金管理中心查到你的账号。</p><p>如果从上海换到北京，那就跨了统筹区，这个时候，个人账户里的全部储蓄额都将转走，而统筹账户则按照你缴纳工资总额的12%进行转移。但跨区转移有年龄限制：</p><ul><li>如果王华从上海转回湖南老家，多大年龄都可以转，</li><li>如果王华从上海转到北京，50岁以下（女性40岁以下）可以转；50岁以上则只能办理临时账户缴纳社保，社保关系还保留在上海。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又逢周末，上期的 &lt;a href&gt;「生日快乐」&lt;/a&gt; 告诉自己要恢复「朝花夕拾」的更新，隔了一周，从今天开始。本期「朝花夕拾」的题目来自于前两天听「贤者时间」的一期播客，本文内容与播客内容基本无关，仅仅作为飘飞思绪的引子。恰逢立冬，白昼渐短，宵寒渐长，开始切身的感受到了节气的变化。凛冬将至，蛰伏开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;秋风吹尽旧庭柯，黄叶丹枫客里过。 &lt;/p&gt;
&lt;p&gt;一点禅灯半轮月，今宵寒较昨宵多。&lt;/p&gt;
&lt;/blockquote&gt;

    &lt;div id=&quot;aplayer-rqIUrLde&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;1331892086&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-01_sunset.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="生活" scheme="http://houmin.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="保险" scheme="http://houmin.cc/tags/%E4%BF%9D%E9%99%A9/"/>
    
      <category term="立冬" scheme="http://houmin.cc/tags/%E7%AB%8B%E5%86%AC/"/>
    
      <category term="五险一金" scheme="http://houmin.cc/tags/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91/"/>
    
      <category term="二十四节气" scheme="http://houmin.cc/tags/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>26：一个人的北京</title>
    <link href="http://houmin.cc/posts/2561fdfd/"/>
    <id>http://houmin.cc/posts/2561fdfd/</id>
    <published>2020-10-18T12:58:40.000Z</published>
    <updated>2020-11-05T06:50:58.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>像是配上了加速马达，生活的时针走的越来越快。就感觉我还是两个月前写下的 <a href="../fa1a82ad/">25岁生日快乐</a>，今天我又开始这一年一度的仪式。</p>    <div id="aplayer-ZHEPQAbe" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="26427662" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="密度曲线"><a href="#密度曲线" class="headerlink" title="密度曲线"></a>密度曲线</h2><p>不知道是因为2020年这个特殊的年份，还是因为我的年龄越来越大，会觉得我的25岁走的特别的快。如果以在博客上发布个人动态的频率作为我生活密度的衡量指标的话（这里的生活动态不包括各种专业内容的笔记），将会得到下面这样的一个时间曲线：</p><p><img alt="25岁的生活密度曲线" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_life-density.png"></p><p>是的，在去年的这个时候，我刚刚秋招结束，整体上还算顺利，也拿到了一些还可以的Offer。之后就开始了浪浪浪的生活节奏，也正是在那个时候，我重新把这个站捡起来，开始想要在这个站点上记录自己的生活。那是一段异常放松自由的时光，刚经历了秋招的繁忙生活，就像一个紧绷的弹簧一下子放松了下来。我和很好的朋友们一起去了云南，一起恢复了在学校的健身，时不时出去喝酒闲聊，时不时出去采风摄影。到年底的时候，我还规划了下一年的旅行，制定了下一年的目标。</p><p>然而，就在寒假回到武汉家中的第二天，一场突如其来的新冠疫情就整个地改变了2020年。那段时间的我失去了自己的生活节奏，每天的时间除了关注疫情动态，就是进入了一个在家好吃懒做的状态，完全不务正业，看各种经济金融相关杂七杂八的内容。等疫情稍微好转些，就自己出去拍照，记录下生活的时光。</p><p>后来，我去了杭州，更加专心的做毕设。忙完毕设之后，没太停歇就回到了北京，第一次租房，然后正式入职。在那之后，我原来许诺的每周更新的「朝花夕拾」开始不定期发布。工作的生活日渐繁忙，博客上开始发布了大量的涉及到工作相关的学习笔记，生活动态的比重越来越少。</p><p>但是曾经的Flag就在那里，不声不响的扇着我的耳光。周更没能坚持，年更怎可断绝，尽管当我在写这篇博客的时候距离生日已经过去4天，在这个公司午休的时间，我用曲线画下了过去的一岁，用文字记录过去的生活。</p><h2 id="朝花夕拾"><a href="#朝花夕拾" class="headerlink" title="朝花夕拾"></a>朝花夕拾</h2><p>翻了一下，上一期<a href="../47d0d3b/">「朝花夕拾」</a>还是在两个月多个月前，那个周末我难得出门转了一圈，从日常单调的上班生活暂时脱离，感受到了人间生活。如果不出门的话，我会在家里自己做饭，为了给提高自己的厨艺，还特地在手机上创建了一个「下厨房」的目录，到现在也算在厨艺上有一些的积累：</p><p><img alt="我的下厨房相册" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_cooking.jpg"></p><p>不过说起来，我的这套厨艺本质上还是继承自老妈的手法，秉承着「什么都可以炒」的理念，找些荤素搭配起来就可以完成一道炒菜。本心而论，也就是这套方法论摸的很熟，但是 <em>烹炒煎炸煮</em> 等其他手法我目前基本毫无涉猎，也许在以后的生活里可以继续摸索。尽管厨艺粗糙，我自己却还是吃的挺开心的，每次都吃的特别的饱。</p><p><img alt="每一顿自己都吃的很饱" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_cooking-beef.jpg"></p><p>毕竟是一人食，每次对于分量的把控都很艰难。好不容易做好了一顿饭，吃完之后还要自己刷锅刷碗，如果只做一点总觉得不甘心，而一旦做多了就会让自己吃的非常饱。每次这个时候，都会觉得如果有个女朋友一起该多好，那个时候就可以多做一点大家一起分享。</p><p>除了下厨，在家的另一项活动就是拍窗外的夕阳🌇。因为住的楼层比较高，可以直接看到远处的西山，真的好看。</p><p><img alt="最开始用Sony的套头拍，细节还是不够" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-05_sunset.png"></p><p><img alt="套头拍摄的蓝调时刻，直接让我决定升级镜头" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-18_sunset.png"></p><p><img alt="入手了腾龙70-180，感觉画质细腻了好多" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-02_sunset.png"></p><p>除了周末拍夕阳，也会在每天拍楼下的海淀黄庄，我在豆瓣相册上给自己创建了一个相册<a href="https://www.douban.com/photos/album/1877579563/" target="_blank" rel="external nofollow noopener noreferrer">「知春里知春里」</a> 。因为第一次租房并不能算的很满意，所以计划在一年后换一个地方。尽管房间不算很满意，十六楼的风景让我很开心，就在人大附对面，宇宙教育中心海淀黄庄。随着四季更替，看楼下车辆来来往往，看人大附高中生们进进出出，看路边银杏黄了又落，也算是一段不错的体验吧。因为国庆外出，暂定了三周的拍摄，叶儿黄了，继续开始吧！</p><p><img alt="知春里拍摄" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_gallery.png"></p><p>毕业之后，本来预计的活动安排里，除了四处拍照外，应该还有的活动回学校打羽毛球。然而，因为北京的疫情，学校迟迟不开放，自己也还没有找到球友，所以这项活动暂时停歇。羽毛球停了，卡林巴琴练习也停了，摄影在生活中占据的时间越来越多。</p><p><img alt="我记得香八拉路上的山景，记得鬼笑石上看到的北京城" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-19_mountain.png"></p><p><img alt="我记得早上5点爬起来，只为在木樨地拍到秋分时的长安街悬日，可惜今年起晚了，只能明年春分再战了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-26_sunrise.png"></p><p><img alt="我记得中秋和国庆节那天晚上长安街的车流与执勤工作人员" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-01_forbidden-city.png"></p><p><img alt="我记得那天明朗的月" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-01_moon.png"></p><p><img alt="我记得那天城内车流的显著减少，拍下的光晕里好多酸柠檬" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-01_color.png"></p><p>我还记得Ansel Adam的那句话：</p><blockquote><p>我们不只是用相机拍照，我们带到摄影中去的是所有我们读过的书、看过的电影、听过的音乐、走过的路、爱过的人。</p></blockquote><p>我用相机记录生活，用生活记录自己，愿自己能够永远不给自己设限，愿自己永远敢于探索，愿自己永远在路上，愿自己找到爱的人。</p><h2 id="行万里路"><a href="#行万里路" class="headerlink" title="行万里路"></a>行万里路</h2><p>年初的我给自己规划了两场旅行，到最后都未能如愿。令人开心的是，随着国内疫情防控稳定下来，政府也大幅放开了国内旅行限制。于是在这个难得的双节里，我和姐姐还有表弟他们一起自驾走了趟青甘大环线，这里有表弟编辑的Vlog（我的视频还没剪出来，或许会有吧，啥时候我来把这段经历补充道「行万里路」的专栏里：）</p><iframe src="//player.bilibili.com/player.html?aid=669952705&bvid=BV1ta4y1L73r&cid=246085415&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>虽然没有视频，但是一路上的风景真的美不胜收，走过山川与沙漠，走过草原与戈壁，最美的风景永远在路上。</p><p><img alt="在青海湖的那个晚上，跑出来第一次拍星空，虽然冻得发抖，但是美丽的银河值了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_sky.png"></p><p><img alt="除了星星外，还拍到了气晕" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_halo.png"></p><p><img alt="除青海湖真的是海" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-10_seagull.png"></p><p><img alt="在门源没有看到油菜花，在青海湖旁边突然看到近处满眼的黄，配合远处海一般的蓝 ，真的美极了" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-10_rape-flower.png"></p><p><img alt="同一段路上，草已泛黄，油菜花正艳" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_yellow-grass.png"></p><p><img alt="穿过高山与草原，我们在路上" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_on-the-way.png"></p><p><img alt="本来想再鸣沙山拍日落，可惜等我爬上去的时候太阳已经下山，后来才知道鸣沙山的票可以玩三天，其实可以第二天去拍日出的" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_sand.png"></p><p><img alt="路上的飞烟与戈壁" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_cold-flame.png"></p><p><img alt="不过令人开心的是，我在茶卡盐湖拍到了日落，真的美，还拍了延时，虽然还没剪出来：）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_sunset.png"></p><p><img alt="当然如果你想要看天空之境的话，相比茶卡盐湖，我还是推荐翡翠湖，我也拍了日出延时（还没剪出来），（目前）不收门票而且比茶卡盐湖更美）" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_green-lake.png"></p><p><img alt="在穿越祁连山山脉的时候，我们看到山上还有在收割辛劳的人们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-03_moutain-farmers.png"></p><p><img alt="山与草原，分外的层次感" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-03_mountain.png"></p><p><img alt="最令人惊喜的，莫过于在赶往大柴旦镇路上偶遇的小柴旦湖，它有另一个名字，叫做神秘之湖" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-07_lake.png"></p><p><img alt="我们看见湖的时候正好是日落的时候，阳光直接打在湖对面的山上，蓝色的湖水，黄色的草，整个车上的人都震惊了，不能下车，我只能在车上抓拍了几张" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-07_lake2.png"></p><p><img alt="除了这些自然景观外，还去了塔尔寺、莫高窟、榆林窟等文化景观，自是另一种体验" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-08_temple.png"></p><p>写到这里，感觉「行万里路」专栏也不用写了，到时候把两个延时视频补起来叭！</p><h2 id="生日快乐"><a href="#生日快乐" class="headerlink" title="生日快乐"></a>生日快乐</h2><p>上一次生日，是和实验室的几个很好的朋友一起过的，这一次也是。本来，PT已经远走广州，平时想要再见一面已经不易。终于，一直说的回北京喝酒的愿望得以在这个周末实现，真的开心。</p><p>在晚上和PT见面之前，我和PT先回学校走了一圈。当然，学校现在是不让进的，但是翻墙可以：）本来两个人也没有很确定，毕竟翻墙可不算什么光彩事，但是两个人互相鼓动，居然一气呵成翻进了学校。总的来说，翻墙的技术难度并不大，重要的是突破心理障碍。最后我们一致总结到，这次翻墙很值，很刺激。</p><p>进学校之后，感觉到了属于学校满满的活力，听说Y老师在球场和师弟们打球，赶紧过去蹭了两个小时的场。好久没打了，真的开心：）<br><img alt="邱德拔打球的老师和师弟们" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_badminton.png"></p><p><img alt="继续在学校闲逛，看到了疫情期间专供的快餐车" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-17_back-school.png"></p><p>到了晚上，一行四人去了聚点，喝酒叙旧，很自在，上次这样四个人还是去年秋招完后。可惜在聚点忘了拍张合照，四个人一起走在中关村的大街上，继续拍照，直接跨过了凌晨。可惜这次时间太短，如果还能更久一点该多好。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street1.png"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street2.jpg"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street.jpg"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-18_street3.jpg"></p><h2 id="一个人"><a href="#一个人" class="headerlink" title="一个人"></a>一个人</h2><p>二十六啦，我毕业了，一个人在北京。</p><p>来北京已经七年啦，未来还会在这个城市呆三年，希望不再是一个人。</p><p>生日快乐！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像是配上了加速马达，生活的时针走的越来越快。就感觉我还是两个月前写下的 &lt;a href=&quot;../fa1a82ad/&quot;&gt;25岁生日快乐&lt;/a&gt;，今天我又开始这一年一度的仪式。&lt;/p&gt;

    &lt;div id=&quot;aplayer-ZHEPQAbe&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;26427662&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-10-17_back-school.png" type="image" />
    
    
      <category term="生日快乐" scheme="http://houmin.cc/categories/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    
    
      <category term="birthday" scheme="http://houmin.cc/tags/birthday/"/>
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】时序数据库 InfluxDB</title>
    <link href="http://houmin.cc/posts/c57001b4/"/>
    <id>http://houmin.cc/posts/c57001b4/</id>
    <published>2020-09-16T04:16:58.000Z</published>
    <updated>2020-11-18T12:13:32.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>InfluxDB 是使用 Go 编写的基于时间序列的数据库，用于存储大量带有时间戳的数据，报错 DevOps 监控，日志数据，应用程序的指标、数据分析数据等等。通过 InfluxDB 自动保存数据，你不需要删除和清理，只需要定义一段时间 DB 会帮你自动清理。</p><a id="more"></a><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>InfluxDB 和传统数据库（如：MySQL）的一些区别</p><div class="table-container"><table><thead><tr><th style="text-align:center">InfluxDB</th><th style="text-align:center">传统数据库中的概念</th></tr></thead><tbody><tr><td style="text-align:center">database</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">measurement</td><td style="text-align:center">数据库中的表</td></tr><tr><td style="text-align:center">points</td><td style="text-align:center">表里面的一行数据</td></tr></tbody></table></div><h3 id="特有概念"><a href="#特有概念" class="headerlink" title="特有概念"></a>特有概念</h3><ol><li><p>tag–标签，在 InfluxDB 中，tag 是一个非常重要的部分，表名+tag 一起作为数据库的索引，是“key-value”的形式</p></li><li><p>field–数据，field 主要是用来存放数据的部分，也是“key-value”的形式</p></li><li><p>timestamp–时间戳，作为时序型数据库，时间戳是 InfluxDB 中最重要的部分，在插入数据时可以自己指定也可留空让系统指定</p><p><strong>说明</strong>：<em>在插入新数据时，tag、field 和 timestamp 之间用空格分隔</em></p></li><li><p>series–序列，所有在数据库中的数据，都需要通过图表来展示，而这个 series 表示这个表里面的数据，可以在图表上画成几条线。具体可以通过 <code>SHOW SERIES FROM &quot;表名&quot;</code> 进行查询</p></li><li><p>Retention policy–数据保留策略，可以定义数据保留的时长，每个数据库可以有多个数据保留策略，但只能有一个默认策略</p></li><li><p>Point–点，表示每个表里某个时刻的某个条件下的一个 field 的数据，因为体现在图表上就是一个点，于是将其称为 point。Point 由时间戳（time）、数据（field）、标签（tags）组成</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">Point 属性</th><th style="text-align:center">传统数据库中的概念</th></tr></thead><tbody><tr><td style="text-align:center">time</td><td style="text-align:center">每个数据记录时间，是数据库中的主索引 (会自动生成)</td></tr><tr><td style="text-align:center">fields</td><td style="text-align:center">表中的列（没有索引的属性）也就是记录的值：温度， 湿度</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">表中的索引：地区，海拔</td></tr></tbody></table></div><h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><ul><li>8083：Web admin 管理服务的端口, <a href="http://localhost:8083/" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:8083</a></li><li>8086：HTTP API 的端口</li><li>8088：集群端口 (目前还不是很清楚, 配置在全局的 bind-address，默认不配置就是开启的)</li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">influxdb:1.7.4</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30004</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f influx.yaml</span><br><span class="line">$ kubectl get pod -n monitoring</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">influxdb-685854ccf7-mlr4g   1/1     Running   0          11m</span><br><span class="line">$ kubectl get svc -n monitoring</span><br><span class="line">NAME       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">influxdb   NodePort   172.18.253.93   &lt;none&gt;        8086:30004/TCP   11m</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it influxdb-685854ccf7-mlr4g bash -n monitoring</span><br><span class="line">root@influxdb-685854ccf7-mlr4g:/<span class="comment"># influx</span></span><br><span class="line">Connected to http://localhost:8086 version 1.7.4</span><br><span class="line">InfluxDB shell version: 1.7.4</span><br><span class="line">Enter an InfluxQL query</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="客户端命令操作"><a href="#客户端命令操作" class="headerlink" title="客户端命令操作"></a>客户端命令操作</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>CREATE DATABASE {NAME};</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; create database houmin</span><br><span class="line">&gt; show databases</span><br><span class="line">name: databases</span><br><span class="line">name</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">_internal</span><br><span class="line">houmin</span><br></pre></td></tr></table></figure><ul><li>这时候我们发现数据库有一个表“_internal”，其实这个表是 influxdb 数据库的一些指标存储库。有点类似 mysql 数据库的 mysql 库。</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>DROP DATABASE {NAME};</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; drop database houmin</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>USE {DB}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use houmin</span><br><span class="line">Using database houmin</span><br></pre></td></tr></table></figure><h3 id="数据表和数据操作"><a href="#数据表和数据操作" class="headerlink" title="数据表和数据操作"></a>数据表和数据操作</h3><p>建库的操作可以发现非常类似于 MySQL 下的操作。而在 InfluxDB 下没有细分的表的概念，InfluxDB 下的表在插入数据库的时候自动会创建。可以通过 <code>show measurements</code> 命令查看所有的表，这个类似于 MySQL 下的<code>show tables</code></p><h4 id="显示所有表"><a href="#显示所有表" class="headerlink" title="显示所有表"></a>显示所有表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show measurements</span><br><span class="line">name: measurements</span><br><span class="line">name</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">cpu</span><br><span class="line">temperature</span><br></pre></td></tr></table></figure><h4 id="新建表（写数据）"><a href="#新建表（写数据）" class="headerlink" title="新建表（写数据）"></a>新建表（写数据）</h4><p>标准格式，注意在写数据的时候如果不添加时间戳，系统会默认添加一个时间。InfluxDB 中没有显式的新建表的语句，只能通过 insert 数据的方式来建立新表。</p><ul><li>语法格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> &lt;measurement&gt;[,&lt;tag-<span class="keyword">key</span>&gt;=&lt;tag-<span class="keyword">value</span>&gt;...] &lt;<span class="keyword">field</span>-<span class="keyword">key</span>&gt;=&lt;<span class="keyword">field</span>-<span class="keyword">value</span>&gt;[,&lt;field2-<span class="keyword">key</span>&gt;=&lt;field2-<span class="keyword">value</span>&gt;...] [unix-nano-<span class="built_in">timestamp</span>]</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT cpu,host=serverA,region=us_west value=0.64</span><br><span class="line"></span><br><span class="line">&gt; INSERT temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; drop measurement disk_free</span><br><span class="line">&gt; show measurements</span><br><span class="line">name: measurements</span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line">name</span><br><span class="line">weather</span><br></pre></td></tr></table></figure><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>查询语句与 SQL 一样，不用过多的学习</p><ul><li>查询数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT "host", "region", "value" FROM "cpu"</span><br><span class="line">name: cpu</span><br><span class="line">time                host    region  value</span><br><span class="line"><span class="comment">----                ----    ------  -----</span></span><br><span class="line">1600221790602821979 serverA us_west 0.64</span><br></pre></td></tr></table></figure><ul><li>每个表输出一行（支持 Go 语言的正则表达式、支持类似于 MySQL 中的 limit 语句）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM /.*/ LIMIT 1</span><br><span class="line">name: cpu</span><br><span class="line">time                external host    internal machine region  type value</span><br><span class="line"><span class="comment">----                -------- ----    -------- ------- ------  ---- -----</span></span><br><span class="line">1563895618490964877          serverA                  us_west      0.64</span><br><span class="line"></span><br><span class="line">name: temperature</span><br><span class="line">time                external host internal machine region type     value</span><br><span class="line"><span class="comment">----                -------- ---- -------- ------- ------ ----     -----</span></span><br><span class="line">1434067467000000000 25            37       unit42         assembly</span><br></pre></td></tr></table></figure><h4 id="修改和删除数据"><a href="#修改和删除数据" class="headerlink" title="修改和删除数据"></a>修改和删除数据</h4><p>InfluxDB 属于时序数据库，没有提供修改和删除数据的方法。</p><p>但是删除可以通过 InfluxDB 的数据保存策略（Retention Policies）来实现</p><p>update 更新语句没有，不过有 alter 命令，在 influxdb 中，删除操作用和更新基本不用到 。在针对数据保存策略方面，有一个特殊的删除方式，这个后面再提。</p><h3 id="series-操作"><a href="#series-操作" class="headerlink" title="series 操作"></a>series 操作</h3><p>series 表示这个表里面的数据，可以在图表上画成几条线，series 主要通过 tags 排列组合算出来。</p><p>我们可以查询表的 series，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; show series from cpu</span><br><span class="line">key</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">cpu,host=serverA,region=us_east</span><br><span class="line">cpu,host=serverA,region=us_west</span><br><span class="line">cpu,host=serverX,region=us_east</span><br><span class="line">cpu,host=serverX,region=us_west</span><br></pre></td></tr></table></figure><h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示用户</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">USERS</span></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">"username"</span> <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'password'</span></span><br><span class="line"><span class="comment"># 创建管理员权限的用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">"username"</span> <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'password'</span> <span class="keyword">WITH</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">"username"</span></span><br></pre></td></tr></table></figure><p>influxdb 的权限设置比较简单，只有读、写、ALL 几种。</p><h2 id="HTTP-API-操作"><a href="#HTTP-API-操作" class="headerlink" title="HTTP API 操作"></a>HTTP API 操作</h2><h3 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h3><div class="table-container"><table><thead><tr><th>接口路径</th><th>描述</th></tr></thead><tbody><tr><td>/debug/pprof</td><td>debug 排查问题使用</td></tr><tr><td>/debug/requests</td><td>使用这个请求监听最近是否有请求</td></tr><tr><td>/debug/vars</td><td>查询 influxdb 收集到静态信息</td></tr><tr><td>/ping</td><td>检测 influxdb 状态</td></tr><tr><td>/query</td><td>查询数据接口（同时可以创建库）</td></tr><tr><td>/write</td><td>写入数据接口（一个已存在数据库）</td></tr></tbody></table></div><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>2xx：服务请求正常</li><li>4xx：代表请求语法有问题</li><li>5xx：服务端出问题，导致超时等故障</li></ul><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -XPOST http://localhost:8086/query --data-urlencode <span class="string">"q=CREATE DATABASE mydb"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 5edd88a8-ef90-11e8-83cd-a0999b0f94e3</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.0~n201811230800</span><br><span class="line">X-Request-Id: 5edd88a8-ef90-11e8-83cd-a0999b0f94e3</span><br><span class="line">Date: Sat, 24 Nov 2018 02:26:38 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">&#123;<span class="string">"results"</span>:[&#123;<span class="string">"statement_id"</span>:0&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i  -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary <span class="string">'cpu_load_short,host=server01,region=us-west value=0.65 1434055564000000000'</span></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 1ae386c4-ef91-11e8-83d8-a0999b0f94e3</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.0~n201811230800</span><br><span class="line">X-Request-Id: 1ae386c4-ef91-11e8-83d8-a0999b0f94e3</span><br><span class="line">Date: Sat, 24 Nov 2018 02:31:53 GMT</span><br></pre></td></tr></table></figure><h3 id="写入多个数据点"><a href="#写入多个数据点" class="headerlink" title="写入多个数据点"></a>写入多个数据点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary <span class="string">'cpu_load_short,host=server02 value=0.67</span></span><br><span class="line"><span class="string">HTTP/1.1 204 No Content</span></span><br><span class="line"><span class="string">Content-Type: application/json</span></span><br><span class="line"><span class="string">Request-Id: 086bd107-f7c3-11ea-803c-3a3192636d64</span></span><br><span class="line"><span class="string">X-Influxdb-Build: OSS</span></span><br><span class="line"><span class="string">X-Influxdb-Version: 1.7.4</span></span><br><span class="line"><span class="string">X-Request-Id: 086bd107-f7c3-11ea-803c-3a3192636d64</span></span><br><span class="line"><span class="string">Date: Wed, 16 Sep 2020 02:19:22 GMT</span></span><br></pre></td></tr></table></figure><h3 id="从文件导入数据库"><a href="#从文件导入数据库" class="headerlink" title="从文件导入数据库"></a>从文件导入数据库</h3><p>从文件导入时候建议不要超过 5000 条，如果超过请对文件进行切割，因为 http api 的接口 5s 会超时，请求数据过多会导致数据无法确认是否成功。<br>文件 cpu_data.txt 内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu_data.txt</span><br><span class="line">cpu_load_short,host=server02 value=111</span><br><span class="line">cpu_load_short,host=server02,region=us-west value=0.222 1543027130702900257</span><br><span class="line">cpu_load_short,direction=<span class="keyword">in</span>,host=server01,region=us-west value=111.222 1543027129702900257</span><br><span class="line">$ curl -i -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary @cpu_data.txt</span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 40022e79-f7c3-11ea-803d-3a3192636d64</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.4</span><br><span class="line">X-Request-Id: 40022e79-f7c3-11ea-803d-3a3192636d64</span><br><span class="line">Date: Wed, 16 Sep 2020 02:20:55 GMT</span><br></pre></td></tr></table></figure><h2 id="数据保存策略（Retention-Policies）"><a href="#数据保存策略（Retention-Policies）" class="headerlink" title="数据保存策略（Retention Policies）"></a>数据保存策略（Retention Policies）</h2><p>InfluxDB 每秒可以处理成千上万条数据，要将这些数据全部保存下来会占用大量的存储空间，有时我们可能并不需要将所有历史数据进行存储。InfluxDB 没有提供直接删除 Points 的方法，但是它提供了 Retention Policies，用来让我们自定义数据的保留时间。</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">RETENTION</span> POLICIES <span class="keyword">ON</span> <span class="string">"testDB"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">show</span> <span class="keyword">retention</span> policies <span class="keyword">on</span> <span class="string">"mydb"</span></span><br><span class="line"><span class="keyword">name</span>    <span class="keyword">duration</span> shardGroupDuration replicaN <span class="keyword">default</span></span><br><span class="line"><span class="comment">----    -------- ------------------ -------- -------</span></span><br><span class="line">autogen <span class="number">0</span>s       <span class="number">168</span>h0m0s           <span class="number">1</span>        <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RETENTION</span> <span class="keyword">POLICY</span> <span class="string">"rp_name"</span> <span class="keyword">ON</span> <span class="string">"db_name"</span> <span class="keyword">DURATION</span> <span class="number">30</span>d <span class="keyword">REPLICATION</span> <span class="number">1</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>rp_name：策略名</li><li>db_name：具体的数据库名</li><li>30d：保存 30 天，30 天之前的数据将被删除<br>它具有各种时间参数，比如：h（小时），w（星期）</li><li>REPLICATION 1：副本个数，这里填 1 就可以了</li><li>DEFAULT 设为默认的策略</li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER RETENTION<span class="built_in"> POLICY </span><span class="string">"rp_name"</span> ON db_name<span class="string">" DURATION 3w DEFAULT</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP RETENTION<span class="built_in"> POLICY </span><span class="string">"rp_name"</span> ON <span class="string">"db_name"</span></span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>InfluxDB 提供了很多的有用的函数，这里列举了常用的三个维度函数，Use InfluxQL functions to aggregate, select, and transform data.</p><div class="table-container"><table><thead><tr><th>Aggregations</th><th>Selectors</th><th>Transformations</th></tr></thead><tbody><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#count" target="_blank" rel="external nofollow noopener noreferrer">COUNT()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#bottom" target="_blank" rel="external nofollow noopener noreferrer">BOTTOM()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#ceiling" target="_blank" rel="external nofollow noopener noreferrer">CEILING()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#distinct" target="_blank" rel="external nofollow noopener noreferrer">DISTINCT()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#first" target="_blank" rel="external nofollow noopener noreferrer">FIRST()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="external nofollow noopener noreferrer">DERIVATIVE()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#integral" target="_blank" rel="external nofollow noopener noreferrer">INTEGRAL()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#last" target="_blank" rel="external nofollow noopener noreferrer">LAST()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#difference" target="_blank" rel="external nofollow noopener noreferrer">DIFFERENCE()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#mean" target="_blank" rel="external nofollow noopener noreferrer">MEAN()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#max" target="_blank" rel="external nofollow noopener noreferrer">MAX()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#elapsed" target="_blank" rel="external nofollow noopener noreferrer">ELAPSED()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#median" target="_blank" rel="external nofollow noopener noreferrer">MEDIAN()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#min" target="_blank" rel="external nofollow noopener noreferrer">MIN()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#floor" target="_blank" rel="external nofollow noopener noreferrer">FLOOR()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#spread" target="_blank" rel="external nofollow noopener noreferrer">SPREAD()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#percentile" target="_blank" rel="external nofollow noopener noreferrer">PERCENTILE()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#histogram" target="_blank" rel="external nofollow noopener noreferrer">HISTOGRAM()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#sum" target="_blank" rel="external nofollow noopener noreferrer">SUM()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#top" target="_blank" rel="external nofollow noopener noreferrer">TOP()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#moving-average" target="_blank" rel="external nofollow noopener noreferrer">MOVING_AVERAGE()</a></td></tr><tr><td></td><td></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#non-negative-derivative" target="_blank" rel="external nofollow noopener noreferrer">NON_NEGATIVE_DERIVATIVE()</a></td></tr><tr><td></td><td></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#stddev" target="_blank" rel="external nofollow noopener noreferrer">STDDEV()</a></td></tr></tbody></table></div><h3 id="聚合类函数"><a href="#聚合类函数" class="headerlink" title="聚合类函数"></a>聚合类函数</h3><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT() 函数"></a>COUNT() 函数</h4><p>返回一个（field）字段中的非空值的数量。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(water<span class="emphasis">_level) FROM h2o_</span>feet</span><br><span class="line">name: h2o<span class="emphasis">_feet</span></span><br><span class="line"><span class="emphasis">--------------</span></span><br><span class="line"><span class="emphasis">time                           count</span></span><br><span class="line"><span class="emphasis">1970-01-01T00:00:00Z     15258</span></span><br></pre></td></tr></table></figure><p>说明 water_level 这个字段在 h2o_feet 表中共有 15258 条数据。</p><p>注意：InfluxDB 中的函数如果没有指定时间的话，会默认以 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间。</p><p>可以在 where 中加入时间条件，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(water_level) FROM h2o_feet WHERE time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-09-18T17:00:00Z' GROUP BY time(4d)</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           count</span><br><span class="line">2015-08-17T00:00:00Z     1440</span><br><span class="line">2015-08-21T00:00:00Z     1920</span><br><span class="line">2015-08-25T00:00:00Z     1920</span><br><span class="line">2015-08-29T00:00:00Z     1920</span><br><span class="line">2015-09-02T00:00:00Z     1915</span><br><span class="line">2015-09-06T00:00:00Z     1920</span><br><span class="line">2015-09-10T00:00:00Z     1920</span><br><span class="line">2015-09-14T00:00:00Z     1920</span><br><span class="line">2015-09-18T00:00:00Z     335</span><br></pre></td></tr></table></figure><h4 id="DISTINCT-函数"><a href="#DISTINCT-函数" class="headerlink" title="DISTINCT() 函数"></a>DISTINCT() 函数</h4><p>返回一个字段（field）的唯一值。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DISTINCT("level description") FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           distinct</span><br><span class="line">1970-01-01T00:00:00Z     between 6 and 9 feet</span><br><span class="line">1970-01-01T00:00:00Z     below 3 feet</span><br><span class="line">1970-01-01T00:00:00Z     between 3 and 6 feet</span><br><span class="line">1970-01-01T00:00:00Z     at or greater than 9 feet</span><br></pre></td></tr></table></figure><p>这个例子显示 level description 这个字段共有四个值，然后将其显示了出来，时间为默认时间。</p><h4 id="MEAN-函数"><a href="#MEAN-函数" class="headerlink" title="MEAN() 函数"></a>MEAN() 函数</h4><p>返回一个字段（field）中的值的算术平均值（平均值）。字段类型必须是长整型或 float64。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MEAN(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEAN(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           mean</span><br><span class="line">1970-01-01T00:00:00Z     4.286791371454075</span><br></pre></td></tr></table></figure><p>说明 water_level 字段的平均值为<code>4.286791371454075</code>，时间为默认时间，当然，你也可以加入 where 条件。</p><h4 id="MEDIAN-函数"><a href="#MEDIAN-函数" class="headerlink" title="MEDIAN() 函数"></a>MEDIAN() 函数</h4><p>从单个字段（field）中的排序值返回中间值（中位数）。字段值的类型必须是长整型或 float64 格式。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MEDIAN</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEDIAN(water_level) from h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           median</span><br><span class="line">1970-01-01T00:00:00Z     4.124</span><br></pre></td></tr></table></figure><p>说明表中 water_level 字段的中位数是 4.124</p><h4 id="SPREAD-函数"><a href="#SPREAD-函数" class="headerlink" title="SPREAD() 函数"></a>SPREAD() 函数</h4><p>返回字段的最小值和最大值之间的差值。数据的类型必须是长整型或 float64。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SPREAD(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT SPREAD(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            spread</span><br><span class="line">1970-01-01T00:00:00Z      10.574</span><br></pre></td></tr></table></figure><h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM() 函数"></a>SUM() 函数</h4><p>返回一个字段中的所有值的和。字段的类型必须是长整型或 float64。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT SUM(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           sum</span><br><span class="line">1970-01-01T00:00:00Z     67777.66900000002</span><br></pre></td></tr></table></figure><p>此语句计算出了 h2o_feet 表中 所有 water_level 字段的和。</p><h3 id="选择类函数"><a href="#选择类函数" class="headerlink" title="选择类函数"></a>选择类函数</h3><h4 id="TOP-函数"><a href="#TOP-函数" class="headerlink" title="TOP() 函数"></a>TOP() 函数</h4><p>作用：返回一个字段中最大的 N 个值，字段类型必须是长整型或 float64 类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT TOP("water_level",3) FROM "h2o_feet"</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">time                   top</span><br><span class="line"><span class="comment">----                   ---</span></span><br><span class="line">2015-08-29T07:18:00Z   9.957</span><br><span class="line">2015-08-29T07:24:00Z   9.964</span><br><span class="line">2015-08-29T07:30:00Z   9.954</span><br></pre></td></tr></table></figure><p>这个例子返回表中 water_level 字段中最大的三个值。</p><h4 id="BOTTOM-函数"><a href="#BOTTOM-函数" class="headerlink" title="BOTTOM() 函数"></a>BOTTOM() 函数</h4><p>作用：返回一个字段中最小的 N 个值。字段类型必须是长整型或 float64 类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BOTTOM(&lt;field_key&gt;[,&lt;tag_keys&gt;],&lt;N&gt;)[,&lt;tag_keys&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           bottom</span><br><span class="line">2015-08-29T14:30:00Z     -0.61</span><br><span class="line">2015-08-29T14:36:00Z     -0.591</span><br><span class="line">2015-08-30T15:18:00Z     -0.594</span><br></pre></td></tr></table></figure><p>这个例子返回表中 water_level 字段中最小的三个值。</p><p>也可将关联 tag 放在一起查询，但如果 tag 值少于 N 的值，则返回的值的个数只会取 tag 中字段值少的那个。</p><p>如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,location,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           bottom     location</span><br><span class="line">2015-08-29T10:36:00Z     -0.243     santa_monica</span><br><span class="line">2015-08-29T14:30:00Z     -0.61      coyote_creek</span><br></pre></td></tr></table></figure><p>语句取最小的三个值，然而结果只返回了 2 个值，因为 location 这个 tag 只有 两个取值。</p><h4 id="FIRST-函数"><a href="#FIRST-函数" class="headerlink" title="FIRST() 函数"></a>FIRST() 函数</h4><p>作用：返回一个字段中最老的取值。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT FIRST(water_level) FROM h2o_feet WHERE location = 'santa_monica'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           first</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br></pre></td></tr></table></figure><p>这个语句返回了 在 location 为 santa_monica 条件下，最旧的那个 water_level 字段的取值和时间。</p><h4 id="LAST-函数"><a href="#LAST-函数" class="headerlink" title="LAST() 函数"></a>LAST() 函数</h4><p>作用：返回一个字段中最新的取值。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT LAST(water_level),location FROM h2o_feet WHERE time &gt;= '2015-08-18T00:42:00Z' and time &lt;= '2015-08-18T00:54:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           last      location</span><br><span class="line">2015-08-18T00:54:00Z     6.982     coyote_creek</span><br></pre></td></tr></table></figure><h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX() 函数"></a>MAX() 函数</h4><p>作用：返回一个字段中的最大值。该字段类型必须是长整型，float64，或布尔类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MAX(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           max       location</span><br><span class="line">2015-08-29T07:24:00Z     9.964     coyote_creek</span><br></pre></td></tr></table></figure><h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN() 函数"></a>MIN() 函数</h4><p>作用：返回一个字段中的最小值。该字段类型必须是长整型，float64，或布尔类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MIN(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                          min       location</span><br><span class="line">2015-08-29T14:30:00Z    -0.61     coyote_creek</span><br></pre></td></tr></table></figure><h4 id="PERCENTILE-函数"><a href="#PERCENTILE-函数" class="headerlink" title="PERCENTILE() 函数"></a>PERCENTILE() 函数</h4><p>作用：返回排序值排位为 N 的百分值。字段的类型必须是长整型或 float64。</p><p>百分值是介于 100 到 0 之间的整数或浮点数，包括 100。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT PERCENTILE(water_level,5),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                      percentile     location</span><br><span class="line">2015-08-28T12:06:00Z      1.122             santa_monica</span><br></pre></td></tr></table></figure><p>就是将 water_level 字段按照不同的 location 求百分比，然后取第五位数据。</p><h3 id="变换类函数"><a href="#变换类函数" class="headerlink" title="变换类函数"></a>变换类函数</h3><h4 id="DERIVATIVE-函数"><a href="#DERIVATIVE-函数" class="headerlink" title="DERIVATIVE() 函数"></a>DERIVATIVE() 函数</h4><p>作用：返回一个字段在一个 series 中的变化率。</p><p>InfluxDB 会计算按照时间进行排序的字段值之间的差异，并将这些结果转化为单位变化率。其中，单位可以指定，默认为 1s。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>其中，<code>unit</code>取值可以为以下几种：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u <span class="comment">--microseconds</span></span><br><span class="line">s <span class="comment">--seconds</span></span><br><span class="line">m <span class="comment">--minutes</span></span><br><span class="line">h <span class="comment">--hours</span></span><br><span class="line">d <span class="comment">--days</span></span><br><span class="line">w <span class="comment">--weeks</span></span><br></pre></td></tr></table></figure><p>DERIVATIVE() 函数还可以在 GROUP BY time() 的条件下与聚合函数嵌套使用，格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设 location = santa_monica 条件下数据有以下几条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           water_level</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br><span class="line">2015-08-18T00:06:00Z     2.116</span><br><span class="line">2015-08-18T00:12:00Z     2.028</span><br><span class="line">2015-08-18T00:18:00Z     2.126</span><br><span class="line">2015-08-18T00:24:00Z     2.041</span><br><span class="line">2015-08-18T00:30:00Z     2.051</span><br></pre></td></tr></table></figure><p>计算每一秒的变化率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.00014444444444444457</span><br><span class="line">2015-08-18T00:12:00Z     -0.00024444444444444465</span><br><span class="line">2015-08-18T00:18:00Z     0.0002722222222222218</span><br><span class="line">2015-08-18T00:24:00Z     -0.000236111111111111</span><br><span class="line">2015-08-18T00:30:00Z     2.777777777777842e-05</span><br></pre></td></tr></table></figure><p>第一行数据的计算公式为<code>(2.116 - 2.064) / (360s / 1s)</code></p><p>计算每六分钟的变化率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,6m) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z     -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z     0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z     -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z     0.010000000000000231</span><br></pre></td></tr></table></figure><p>第一行数据的计算过程如下：<code>(2.116 - 2.064) / (6m / 6m)</code></p><p>计算每 12 分钟的变化率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,12m) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.10400000000000009</span><br><span class="line">2015-08-18T00:12:00Z     -0.17600000000000016</span><br><span class="line">2015-08-18T00:18:00Z     0.19599999999999973</span><br><span class="line">2015-08-18T00:24:00Z     -0.16999999999999993</span><br><span class="line">2015-08-18T00:30:00Z     0.020000000000000462</span><br></pre></td></tr></table></figure><p>第一行数据计算过程为：<code>(2.116 - 2.064 / (6m / 12m)</code></p><p>计算每 12 分钟最大值的变化率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(MAX(water_level)) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-08-18T00:36:00Z' GROUP BY time(12m)</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:12:00Z     0.009999999999999787</span><br><span class="line">2015-08-18T00:24:00Z     -0.07499999999999973</span><br></pre></td></tr></table></figure><p>这个函数功能非常多，也非常复杂，更多对于此功能的详细解释请看官网：<a href="https://www.linuxdaxue.com/wp-content/themes/template/inc/go.php?url=https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="external nofollow noopener noreferrer">https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative</a></p><h4 id="DIFFERENCE-函数"><a href="#DIFFERENCE-函数" class="headerlink" title="DIFFERENCE() 函数"></a>DIFFERENCE() 函数</h4><p>作用：返回一个字段中连续的时间值之间的差异。字段类型必须是长整型或 float64。</p><p>最基本的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DIFFERENCE</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>与 GROUP BY time() 以及其他嵌套函数一起使用的语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DIFFERENCE</span>(&lt;<span class="keyword">function</span>&gt;(&lt;field_key&gt;)) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure><p>其中，函数可以包含以下几个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(), MEAN(), MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), 和 PERCENTILE()</span><br></pre></td></tr></table></figure><p>使用示例</p><p>例子中使用的源数据如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location='santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure><p>计算<code>water_level</code>间的差异：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DIFFERENCE(water_level) FROM h2o_feet WHERE location='santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            difference</span><br><span class="line">2015-08-18T00:06:00Z      0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z      -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z      0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z      -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z      0.010000000000000231</span><br><span class="line">2015-08-18T00:36:00Z      0.016000000000000014</span><br></pre></td></tr></table></figure><p>数据类型都为 float 类型。</p><h4 id="ELAPSED-函数"><a href="#ELAPSED-函数" class="headerlink" title="ELAPSED() 函数"></a>ELAPSED() 函数</h4><p>作用：返回一个字段在连续的时间间隔间的差异，间隔单位可选，默认为 1 纳秒。</p><p>单位可选项如下：</p><div class="table-container"><table><thead><tr><th>Units</th><th>Meaning</th></tr></thead><tbody><tr><td>ns</td><td>nanoseconds (1 billionth of a second)</td></tr><tr><td>u or µ</td><td>microseconds (1 millionth of a second)</td></tr><tr><td>ms</td><td>milliseconds (1 thousandth of a second)</td></tr><tr><td>s</td><td>second</td></tr><tr><td>m</td><td>minute</td></tr><tr><td>h</td><td>hour</td></tr><tr><td>d</td><td>day</td></tr><tr><td>w</td><td>week</td></tr></tbody></table></div><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ELAPSED(&lt;field_key&gt;, &lt;unit&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><p>计算 h2o_feet 字段在纳秒间隔下的差异。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      360000000000</span><br><span class="line">2015-08-18T00:12:00Z      360000000000</span><br><span class="line">2015-08-18T00:18:00Z      360000000000</span><br><span class="line">2015-08-18T00:24:00Z      360000000000</span><br></pre></td></tr></table></figure><p>在一分钟间隔下的差异率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1m) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      6</span><br><span class="line">2015-08-18T00:12:00Z      6</span><br><span class="line">2015-08-18T00:18:00Z      6</span><br><span class="line">2015-08-18T00:24:00Z      6</span><br></pre></td></tr></table></figure><p>注意：如果设置的时间间隔比字段数据间的时间间隔更大时，则函数会返回 0，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1h) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      0</span><br><span class="line">2015-08-18T00:12:00Z      0</span><br><span class="line">2015-08-18T00:18:00Z      0</span><br><span class="line">2015-08-18T00:24:00Z      0</span><br></pre></td></tr></table></figure><h4 id="MOVING-AVERAGE-函数"><a href="#MOVING-AVERAGE-函数" class="headerlink" title="MOVING_AVERAGE() 函数"></a>MOVING_AVERAGE() 函数</h4><p>作用：返回一个连续字段值的移动平均值，字段类型必须是长整形或者 float64 类型。</p><p>语法：</p><p>基本语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOVING_AVERAGE(&lt;field_key&gt;,&lt;<span class="keyword">window</span>&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>与其他函数和 GROUP BY time() 语句一起使用时的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOVING_AVERAGE(&lt;<span class="keyword">function</span>&gt;(&lt;field_key&gt;),&lt;<span class="keyword">window</span>&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure><p>此函数可以和以下函数一起使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(), MEAN(),MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), and PERCENTILE().</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure><h4 id="NON-NEGATIVE-DERIVATIVE-函数"><a href="#NON-NEGATIVE-DERIVATIVE-函数" class="headerlink" title="NON_NEGATIVE_DERIVATIVE() 函数"></a>NON_NEGATIVE_DERIVATIVE() 函数</h4><p>作用：返回在一个 series 中的一个字段中值的变化的非负速率。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NON_NEGATIVE_DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>其中 unit 取值可以为以下几个：</p><p>Valid time specifications for <code>unit</code> are:</p><ul><li><code>u</code> microseconds</li><li><code>s</code> seconds</li><li><code>m</code> minutes</li><li><code>h</code> hours</li><li><code>d</code> days</li><li><code>w</code> weeks</li></ul><p>与聚合类函数放在一起使用时的语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NON_NEGATIVE_DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure><p>此函数示例请参阅：<a href="https://www.linuxdaxue.com/influxdb-study-influxdb-transformations-funcitons.html#title-0" target="_blank" rel="external nofollow noopener noreferrer">DERIVATIVE()</a>``函数</p><h4 id="STDDEV-函数"><a href="#STDDEV-函数" class="headerlink" title="STDDEV() 函数"></a>STDDEV() 函数</h4><p>作用：返回一个字段中的值的标准偏差。值的类型必须是长整型或 float64 类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STDDEV</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           stddev</span><br><span class="line">1970-01-01T00:00:00Z     2.279144584196145</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet WHERE time &gt;= '2015-08-18T00:00:00Z' and time &lt; '2015-09-18T12:06:00Z' GROUP BY time(1w), location</span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = coyote_creek</span><br><span class="line">time                           stddev</span><br><span class="line"><span class="comment">----                           ------</span></span><br><span class="line">2015-08-13T00:00:00Z     2.2437263080193985</span><br><span class="line">2015-08-20T00:00:00Z     2.121276150144719</span><br><span class="line">2015-08-27T00:00:00Z     3.0416122170786215</span><br><span class="line">2015-09-03T00:00:00Z     2.5348065025435207</span><br><span class="line">2015-09-10T00:00:00Z     2.584003954882673</span><br><span class="line">2015-09-17T00:00:00Z     2.2587514836274414</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = santa_monica</span><br><span class="line">time                           stddev</span><br><span class="line"><span class="comment">----                           ------</span></span><br><span class="line">2015-08-13T00:00:00Z     1.11156344587553</span><br><span class="line">2015-08-20T00:00:00Z     1.0909849279082366</span><br><span class="line">2015-08-27T00:00:00Z     1.9870116180096962</span><br><span class="line">2015-09-03T00:00:00Z     1.3516778450902067</span><br><span class="line">2015-09-10T00:00:00Z     1.4960573811500588</span><br><span class="line">2015-09-17T00:00:00Z     1.075701669442093</span><br></pre></td></tr></table></figure><h2 id="连续查询"><a href="#连续查询" class="headerlink" title="连续查询"></a>连续查询</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>InfluxDB 的连续查询是在数据库中自动定时启动的一组语句，语句中必须包含 <code>SELECT</code>关键词和<code>GROUP BY time()</code>关键词。</p><p>InfluxDB 会将查询结果放在指定的数据表中。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>使用连续查询是最优的降低采样率的方式，连续查询和存储策略搭配使用将会大大降低 InfluxDB 的系统占用量。</p><p>而且使用连续查询后，数据会存放到指定的数据表中，这样就为以后统计不同精度的数据提供了方便。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>只有管理员用户可以操作连续查询。</p><p>1）新建连续查询</p><p>新建连续查询的语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt; </span><br><span class="line">[RESAMPLE [EVERY &lt;<span class="built_in">interval</span>&gt;] [<span class="keyword">FOR</span> &lt;<span class="built_in">interval</span>&gt;]] </span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)] <span class="keyword">INTO</span> &lt;different_measurement&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;current_measurement&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;<span class="built_in">interval</span>&gt;)[,&lt;<span class="keyword">stuff</span>&gt;] </span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>查询部分被 CREATE CONTINUOUS QUERY […] BEGIN 和 END 所包含，主要的逻辑代码也是在这一部分。</p><p>使用示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">CREATE</span> CONTINUOUS QUERY cq_30m <span class="keyword">ON</span> telegraf <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> mean(used) <span class="keyword">INTO</span> mem_used_30m <span class="keyword">FROM</span> mem <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br><span class="line">&gt; <span class="keyword">SHOW</span> CONTINUOUS QUERIES</span><br><span class="line"><span class="type">name</span>: telegraf</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="type">name</span>    query</span><br><span class="line">cq_30m    <span class="keyword">CREATE</span> CONTINUOUS QUERY cq_30m <span class="keyword">ON</span> telegraf <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> mean(used) <span class="keyword">INTO</span> telegraf."default".mem_used_30m <span class="keyword">FROM</span> telegraf."default".mem </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">name</span>: _internal</span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"><span class="type">name</span>    query</span><br></pre></td></tr></table></figure><p>示例在 telegraf 库中新建了一个名为 cq_30m 的连续查询，每三十分钟取一个 used 字段的平均值，加入 mem_used_30m 表中。使用的数据保留策略都是 default。</p><p>2）显示所有已存在的连续查询</p><p>查询所有连续查询可以使用如下语句：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SHOW CONTINUOUS QUERIES</span><br><span class="line">name: telegraf</span><br><span class="line">--------------</span><br><span class="line">name    query</span><br><span class="line">cq<span class="emphasis">_30m    CREATE CONTINUOUS QUERY cq_</span>30m ON telegraf </span><br><span class="line">BEGIN SELECT mean(used) INTO telegraf."default".mem<span class="emphasis">_used_</span>30m FROM telegraf."default".mem </span><br><span class="line">GROUP BY time(30m) END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name: <span class="emphasis">_internal</span></span><br><span class="line"><span class="emphasis">---------------</span></span><br><span class="line"><span class="emphasis">name    query</span></span><br></pre></td></tr></table></figure><p>可以看到其连续查询的名称以及 语句等信息。</p><p>3）删除 Continuous Queries</p><p>删除连续查询的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt;</span><br></pre></td></tr></table></figure><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>在 InfluxDB 中，将连续查询与数据存储策略一起使用会达到最好的效果。</p><p>比如，将精度高的表的存储策略定为一个周，然后将精度底的表存储策略定的时间久一点，这要就可以实现高低搭配，以满足不同的工作需要。</p><h2 id="再谈连续查询"><a href="#再谈连续查询" class="headerlink" title="再谈连续查询"></a>再谈连续查询</h2><h3 id="连续查询语法"><a href="#连续查询语法" class="headerlink" title="连续查询语法"></a>连续查询语法</h3><p>连续查询的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt; [RESAMPLE [EVERY &lt;<span class="built_in">interval</span>&gt;] [<span class="keyword">FOR</span> &lt;<span class="built_in">interval</span>&gt;]] <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)] <span class="keyword">INTO</span> &lt;different_measurement&gt; <span class="keyword">FROM</span> &lt;current_measurement&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;<span class="built_in">interval</span>&gt;)[,&lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="指定连续查询的时间范围"><a href="#指定连续查询的时间范围" class="headerlink" title="指定连续查询的时间范围"></a>指定连续查询的时间范围</h3><p>可以使用 <code>RESAMPLE FOR</code> 关键词来指定连续查询的时间范围，比如，每次执行都对 1 小时内的数据进行连续查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires_1 <span class="keyword">ON</span> transylvania RESAMPLE <span class="keyword">FOR</span> <span class="number">60</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations_1 <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这个语句每次会将 1 小时的数据执行连续查询，也就是说，每次执行时，会将 now() 到 now()-30m 和 now()-30m 到 now()-60m 分别做连续查询，这样我们就可以手动指定连续查询的时间范围了。</p><h3 id="指定连续查询的执行频次"><a href="#指定连续查询的执行频次" class="headerlink" title="指定连续查询的执行频次"></a>指定连续查询的执行频次</h3><p>可以使用 <code>RESAMPLE EVERY</code> 关键词来指定连续查询的执行频次，比如，指定连续查询的执行频次为每 15m 执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires <span class="keyword">ON</span> transylvania RESAMPLE EVERY <span class="number">15</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这样，连续查询会每隔 15m 执行一次。</p><h3 id="同时指定连续查询的范围和频次"><a href="#同时指定连续查询的范围和频次" class="headerlink" title="同时指定连续查询的范围和频次"></a>同时指定连续查询的范围和频次</h3><p>将 RESAMPLE FOR 和 EVERY 关键词同时使用，可以同时指定连续查询的范围和频次，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires_2 <span class="keyword">ON</span> transylvania RESAMPLE EVERY <span class="number">15</span>m <span class="keyword">FOR</span> <span class="number">60</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations_2 <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这个语句指定连续查询每 15m 执行一次，每次执行的范围为 60m。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>基础教程文档：<a href="https://www.linuxdaxue.com/series/influxdb-series/" target="_blank" rel="external nofollow noopener noreferrer">InfluxDB 系列教程 | Linux 大学</a></li><li><a href="https://blog.51cto.com/nginxs/2321857" target="_blank" rel="external nofollow noopener noreferrer">00-InfluxDB 入门介绍-我的运维历程-51CTO 博客</a></li><li><a href="http://www.361way.com/influxdb-user/5291.html" target="_blank" rel="external nofollow noopener noreferrer">influxdb 的简单使用 - 运维之路</a></li><li><a href="https://segmentfault.com/a/1190000012385313" target="_blank" rel="external nofollow noopener noreferrer">influxdb 语法 - 个人文章 - SegmentFault 思否</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InfluxDB 是使用 Go 编写的基于时间序列的数据库，用于存储大量带有时间戳的数据，报错 DevOps 监控，日志数据，应用程序的指标、数据分析数据等等。通过 InfluxDB 自动保存数据，你不需要删除和清理，只需要定义一段时间 DB 会帮你自动清理。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_influxdb.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="数据库" scheme="http://houmin.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="influxdb" scheme="http://houmin.cc/tags/influxdb/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】Grafana 入门</title>
    <link href="http://houmin.cc/posts/588dbd28/"/>
    <id>http://houmin.cc/posts/588dbd28/</id>
    <published>2020-09-16T02:13:33.000Z</published>
    <updated>2020-11-18T12:13:20.662Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Grafana是一个开源的度量分析与可视化套件。经常被用作基础设施的时间序列数据和应用程序分析的可视化，它在其他领域也被广泛的使用包括工业传感器、家庭自动化、天气和过程控制等。</p><a id="more"></a><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">grafana/grafana:7.0.5</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_USER</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">admin321</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">472</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">472</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>这里设置了环境变量<code>GF_SECURITY_ADMIN_USER</code>和<code>GF_SECURITY_ADMIN_PASSWORD</code>，用来配置 grafana 的管理员用户和密码的。由于 grafana 将 dashboard、插件这些数据保存在<code>/var/lib/grafana</code>这个目录下面的，所以我们这里如果需要做数据持久化的话，就需要针对这个目录进行 volume 挂载声明。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">grafana.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">grafana</span></span><br></pre></td></tr></table></figure><p>创建 <code>Deployment</code> 和 <code>Service</code> 之后，即可在浏览器访问 Grafana 对应的服务。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_grafana.png"></p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>Grafana默认支持的数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch。Grafana支持同时绑定多套数据源，根据自己需求管理即可，下面以 Prometheus 数据源为基准作为示例。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-23_grafana-data-source.png"></p><p>这里需要配置的主要参数如下：</p><div class="table-container"><table><thead><tr><th>配置项</th><th>配置解释</th></tr></thead><tbody><tr><td>Name</td><td>数据源名称，建议以数据源类型+用途命名</td></tr><tr><td>Type</td><td>数据源类型，选择对应的InfluxDB、Prometheus等即可</td></tr><tr><td>URL</td><td>填写Prometheus对应的API地址即可，如果Grafana跟Prometheus在同一个Namespace，可以直接ServiceName：<code>http://prometheus:9090</code></td></tr><tr><td>Access</td><td>API访问方式，一共有 Server 和 Browser 两个选项，建议选择 Server</td></tr><tr><td>Access-Browser</td><td>浏览器直连数据源API，然后由Grafana解析返回的数据</td></tr><tr><td>Access-Server</td><td>Grafana后端通过API访问数据源，然后返回给浏览器展示</td></tr></tbody></table></div><p>数据源添加/更新成功后会有如下提示：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-23_grafana-data-source2.png"></p><h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p>仪表盘（Dashboard），顾名思义，就是管理各种图表的地方，主要由行（Row）+图表面板（Panel）组成。你可以根据自己的需求手动新建一个Dashboard，也可以从 Grafana 的官方网站导入。</p><h3 id="导入-Dashboard"><a href="#导入-Dashboard" class="headerlink" title="导入 Dashboard"></a>导入 Dashboard</h3><p>这里从选择倒入<a href="https://grafana.com/grafana/dashboards/8919" target="_blank" rel="external nofollow noopener noreferrer"><em>Node Exporter for Prometheus Dashboard CN</em></a>：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-23_grafana-import.png"></p><p>导入之后，显示统计数据如下所示：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p><h3 id="添加-Dashboard"><a href="#添加-Dashboard" class="headerlink" title="添加 Dashboard"></a>添加 Dashboard</h3><p>我们也可以完全手动创建 Dashboard，添加面板（Panel）</p><p>Panel主要支持：Graph，Singlestat，Dashlist，Table和Text。这里我们以曲线图（Graph）为例</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-22_grafana-add-panel.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.qikqiak.com/post/grafana-usage-in-k8s" target="_blank" rel="external nofollow noopener noreferrer">https://www.qikqiak.com/post/grafana-usage-in-k8s</a></li><li><a href="https://ken.io/note/grafana-quickstart-influxdb-datasource-graph" target="_blank" rel="external nofollow noopener noreferrer">https://ken.io/note/grafana-quickstart-influxdb-datasource-graph</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Grafana是一个开源的度量分析与可视化套件。经常被用作基础设施的时间序列数据和应用程序分析的可视化，它在其他领域也被广泛的使用包括工业传感器、家庭自动化、天气和过程控制等。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="可观测性" scheme="http://houmin.cc/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
      <category term="grafana" scheme="http://houmin.cc/tags/grafana/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】Prometheus</title>
    <link href="http://houmin.cc/posts/18c039ab/"/>
    <id>http://houmin.cc/posts/18c039ab/</id>
    <published>2020-09-15T07:53:18.000Z</published>
    <updated>2020-11-18T12:13:12.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Prometheus是一套开源的监控、报警、时间序列数据库的组合，起始是由SoundCloud公司开发的。从2016年加入CNCF，2016年6月正式发布1.0版本，2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合，到2018年8月毕业，现在已经成为Kubernetes的官方监控方案，社区活跃，第三方集成非常丰富。</p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Prometheus是一个开源的完整监控解决方案，其对传统监控系统的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统Prometheus具有以下优点：</p><ul><li><strong>易于管理</strong>：只有一个单独的二进制文件，不存在任何的第三方依赖，采用Pull的方式拉取数据</li><li><strong>强大的数据模型</strong>：每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识</li><li><strong>强大的查询语言PromQL</strong>：内置了一个强大的数据查询语言PromQL，可以实现多种查询、聚合</li><li><strong>高性能</strong>：单实例可以处理数以百万的监控指标、每秒处理数十万的数据点</li><li><strong>易扩展</strong>：支持sharding和联邦集群，实现多数据中心</li><li><strong>易集成</strong>：支持多种语言的SDK进行应用程序数据埋点，社区有丰富插件</li><li><strong>可视化</strong>：自带Prometheus UI，可以进行查询与展示，Grafana也完整支持Prometheus。</li><li><strong>开放性</strong>：使用sdk采集的数据可以被其他监控系统使用，不一定非要用Prometheus</li></ul><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>Prometheus从exporter拉取数据，或者间接地通过网关gateway拉取数据（如果在k8s内部署，可以使用服务发现的方式），它默认本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中，采集到的数据有两个去向，一个是报警，另一个是可视化。PromQL和其他API可视化地展示收集的数据，并通过Alertmanager提供报警能力。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-architecture.png"></p><h3 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h3><ul><li><p>Prometheus Server 负责从 Exporter 拉取和存储监控数据,并提供一套灵活的查询语言（PromQL）</p><ul><li>Retrieval: 采样模块</li><li>TSDB: 存储模块默认本地存储为tsdb</li><li>HTTP Server: 提供http接口查询和面板，默认端口为9090</li></ul></li><li><p>Exporters/Jobs 负责收集目标对象（host, container…）的性能数据，并通过 HTTP 接口供 Prometheus Server 获取。支持数据库、硬件、消息中间件、存储系统、http服务器、jmx等。只要符合接口格式，就可以被采集。</p></li><li><p>Short-lived jobs 瞬时任务的场景，无法通过pull方式拉取，需要使用push方式，与PushGateway搭配使用</p></li><li><p>PushGateway 可选组件，主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。</p></li><li><p>客户端sdk 官方提供的客户端类库有go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持nodejs、php、erlang等</p></li><li><p>Alertmanager 从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。</p></li><li><p>Service Discovery</p><p>服务发现，Prometheus支持多种服务发现机制：文件，DNS，Consul,Kubernetes,OpenStack,EC2等等。基于服务发现的过程并不复杂，通过第三方提供的接口，Prometheus查询到需要监控的Target列表，然后轮训这些Target获取监控数据。</p></li></ul><p>其大概的工作流程是：</p><ul><li>Prometheus server 定期从配置好的 jobs 或者 exporters 中拉 metrics，或者从 Pushgateway 拉取 metrics，或者从其他的 Prometheus server 中拉 metrics。</li><li>Prometheus server 在本地存储收集到的 metrics，并运行已定义好的 alert.rules，记录新的时间序列或者向 Alertmanager 推送警报。</li><li>Alertmanager 根据配置文件，对接收到的警报进行处理，发出告警。</li><li>在图形界面中，可视化采集数据。</li></ul><h3 id="Push与Pull"><a href="#Push与Pull" class="headerlink" title="Push与Pull"></a>Push与Pull</h3><p>Prometheus采集数据是用的pull也就是拉模型,通过HTTP协议去采集指标，只要应用系统能够提供HTTP接口就可以接入监控系统，相比于私有协议或二进制协议来说开发、简单。优点主要是：</p><ul><li>开发任何新功能，你甚至可以在电脑上查看你的监控</li><li>如果目标实例挂掉，你可以很快知道</li><li>你可以手动指定目标实例，并且在浏览器中查看他的健康状态</li></ul><p>总体来说，Pull模式比Push模式更好一些，在监控系统中这也不是一个很重要的点。 如果要使用push的方式，可以使用<a href="https://prometheus.io/docs/instrumenting/pushing/" target="_blank" rel="external nofollow noopener noreferrer">Pushgateway</a>的方式，如定时任务的采集。</p><p>对于定时任务这种短周期的指标采集，如果采用pull模式，可能造成任务结束了，Prometheus还没有来得及采集，这个时候可以使用加一个中转层，客户端推数据到Push Gateway缓存一下，由Prometheus从push gateway pull指标过来。(需要额外搭建Push Gateway，同时需要新增job去从gateway采数据)</p><p>推的代表有 ElasticSearch，InfluxDB，OpenTSDB 等，需要你从程序中将指标使用 TCP，UDP 等方式推送至相关监控应用，只是使用 TCP 的话，一旦监控应用挂掉或存在瓶颈，容易对应用本身产生影响，而使用 UDP 的话，虽然不用担心监控应用，但是容易丢数据。</p><p>拉的代表，主要代表就是 Prometheus，让我们不用担心监控应用本身的状态。而且，可以利用 DNS-SRV 或者 Consul 等服务发现功能就可以自动添加监控。</p><p>当然，InfluxDB 加上 collector，或者 ES 加上 metricbeat 也可以变为 『拉』，而 Prometheus 加上 Push Gateway 也可以变为 『推』。</p><p>更多区别可以参考下图：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/03/15502975113235.jpg"></p><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>Prometheus有着非常高效的时间序列数据存储方法，每个采样数据仅仅占用3.5byte左右空间，上百万条时间序列，30秒间隔，保留60天，大概花了200多G（引用官方PPT）。</p><p>Prometheus内部主要分为三大块，Retrieval是负责定时去暴露的目标页面上去抓取采样指标数据，Storage是负责将采样数据写磁盘，PromQL是Prometheus提供的查询语言模块。</p><p>Prometheus内置了一个基于本地存储的时间序列数据库。在Prometheus设计上，使用本地存储可以降低Prometheus部署和管理的复杂度同时减少高可用（HA）带来的复杂性。 在默认情况下，用户只需要部署多套Prometheus，采集相同的Targets即可实现基本的HA。同时由于Promethus高效的数据处理能力，单个Prometheus Server基本上能够应对大部分用户监控规模的需求。</p><p>同时为了适应数据持久化的问题，Prometheus提供了remote_write和remote_read的特性，支持将数据存储到远端和从远端读取数据。通过将监控与数据分离，Prometheus能够更好地进行弹性扩展。</p><h2 id="部署使用"><a href="#部署使用" class="headerlink" title="部署使用"></a>部署使用</h2><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>当使用Deployment管理和部署应用程序时，用户可以方便了对应用进行扩容或者缩容，从而产生多个Pod实例。为了能够统一管理这些Pod的配置信息，在Kubernetes中可以使用ConfigMaps资源定义和管理这些配置，并且通过环境变量或者文件系统挂载的方式让容器使用这些配置。</p><p>这里将使用ConfigMaps管理Prometheus的配置文件，创建prometheus-config.yml文件，并写入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span> </span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>当ConfigMap资源创建成功后，我们就可以通过Volume挂载的方式，将Prometheus的配置文件挂载到容器中。 这里我们通过Deployment部署Prometheus Server实例，创建prometheus-deployment.yml文件，并写入以下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">prom/prometheus:v2.19.0</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/prometheus</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--config.file=/etc/config/prometheus.yml</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9090</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>由于之前配置了 <code>Traefik</code>，所以这里的 Prometheus 服务不使用 <code>NodePort</code> 方式暴露，在本地设置好 <code>prometheus.houmin</code> 的 host之后，在浏览器中访问：<code>http://prometheus.houmin:&lt;TraefikPort&gt;/</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">prometheus.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">prometheus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure><h2 id="PromQL查询"><a href="#PromQL查询" class="headerlink" title="PromQL查询"></a>PromQL查询</h2><p>Prometheus除了存储数据外，还提供了一种强大的功能表达式语言 PromQL，允许用户实时选择和汇聚时间序列数据。</p><p>表达式的结果可以在浏览器中显示为图形，也可以显示为表格数据，或者由外部系统通过 HTTP API 调用。通过PromQL用户可以非常方便地查询监控数据，或者利用表达式进行告警配置。比如集群中网络使用：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by (<span class="name">name</span>) (<span class="name">rate</span>(<span class="name">container_network_receive_bytes_total</span>&#123;image!=<span class="string">""</span>&#125;[<span class="number">1</span>m]))</span><br></pre></td></tr></table></figure><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-network.png"></p><h3 id="Metric类型"><a href="#Metric类型" class="headerlink" title="Metric类型"></a>Metric类型</h3><p>关于时间序列存储，可以参考：<a href="https://www.infoq.cn/article/database-timestamp-01" target="_blank" rel="external nofollow noopener noreferrer">https://www.infoq.cn/article/database-timestamp-01</a></p><p>Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库TSDB中，并且定时保存到硬盘上。time-series是按照时间戳和值的序列顺序存放的，我们称之为向量(vector)。每条time-series通过指标名称(metrics name)和一组标签集(labelset)命名。</p><p>在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：</p><ul><li>指标(metric)：metric name和描述当前样本特征的labelsets;</li><li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li><li>样本值(value)： 一个folat64的浮点型数据表示当前样本的值。</li></ul><p>如某一时刻的node_cpu指标为459.71</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_cpu&#123;app=<span class="string">"node-exporter"</span>,cpu=<span class="string">"cpu0"</span>,<span class="keyword">instance</span>=<span class="string">"192.168.0.4:9100"</span>,job=<span class="string">"kubernetes-service-endpoints"</span>,kubernetes_name=<span class="string">"node-exporter"</span>,kubernetes_namespace=<span class="string">"kube-system"</span>,mode=<span class="string">"guest"</span>&#125;     <span class="number">459.71</span></span><br></pre></td></tr></table></figure><p>Prometheus定义了4中不同的指标类型(metric type):</p><ul><li>Counter 计数器</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计数器，只增不减，如http_requests_total请求总数</span><br><span class="line"></span><br><span class="line">例如，通过rate()函数获取HTTP请求量的增长率：</span><br><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total[<span class="number">5</span>m])</span></span></span><br></pre></td></tr></table></figure><ul><li>Gauge 仪表盘</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前状态，可增可减。如kube_pod_status_ready当前pod可用数</span><br><span class="line">可以获取样本在一段时间返回内的变化情况,如：</span><br><span class="line"><span class="function"><span class="title">delta</span><span class="params">(kube_pod_status_ready[<span class="number">2</span>h])</span></span></span><br></pre></td></tr></table></figure><ul><li>Histogram 直方图</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Histogram 由 &lt;basename&gt;_bucket&#123;<span class="attribute">le</span>=<span class="string">"&lt;upper inclusive bound&gt;"</span>&#125;，&lt;basename&gt;_bucket&#123;<span class="attribute">le</span>=<span class="string">"+Inf"</span>&#125;, &lt;basename&gt;_sum，&lt;basename&gt;_count 组成，主要用于表示一段时间范围内对数据进行采样（通常是请求持续时间或响应大小），并能够对其指定区间以及总数进行统计，通常它采集的数据展示为直方图。</span><br><span class="line"></span><br><span class="line">例如 Prometheus<span class="built_in"> server </span>中 prometheus_local_storage_series_chunks_persisted, 表示 Prometheus 中每个时序需要存储的 chunks 数量，我们可以用它计算待持久化的数据的分位数。</span><br></pre></td></tr></table></figure><ul><li>Summary 摘要</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Summary 和 Histogram 类似，由 &lt;basename&gt;&#123;<span class="attribute">quantile</span>=<span class="string">"&lt;φ&gt;"</span>&#125;，&lt;basename&gt;_sum，&lt;basename&gt;_count 组成，主要用于表示一段时间内数据采样结果（通常是请求持续时间或响应大小），它直接存储了 quantile 数据，而不是根据统计区间计算出来的。</span><br><span class="line"></span><br><span class="line">例如 Prometheus<span class="built_in"> server </span>中 prometheus_target_interval_length_seconds。</span><br><span class="line"></span><br><span class="line">Histogram 需要通过 &lt;basename&gt;_bucket 计算 quantile, 而 Summary 直接存储了 quantile 的值。</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>PromQL是Prometheus内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。如http_requests_total指标，你可以通过附加一组标签，并用{}括起来，来进一步筛选这些时间序列。下面这个例子只选择有http_requests_total名称的、有prometheus工作标签的、有canary组标签的时间序列：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">"prometheus"</span>,<span class="keyword">group</span>=<span class="string">"canary"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果条件为空，可以写为：http_requests_total{}</p><p>另外，也可以也可以将标签值反向匹配，或者对正则表达式匹配标签值。如操作符：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=：选择正好相等的字符串标签</span><br><span class="line">!=：选择不相等的字符串标签</span><br><span class="line">=~：选择匹配正则表达式的标签（或子标签）</span><br><span class="line">!=：选择不匹配正则表达式的标签（或子标签）</span><br></pre></td></tr></table></figure><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>类似<code>http_requests_total{job=&quot;prometheus&quot;,group=&quot;canary&quot;}</code>的方式，得到的是瞬时值，如果想得到一定范围内的值，可以使用范围查询。</p><p>时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据，如：http_request_total{}[5m]。除了分钟，支持的单位有：</p><ul><li>s - 秒</li><li>m - 分钟</li><li>h - 小时</li><li>d - 天</li><li>w - 周</li><li>y - 年</li></ul><h3 id="偏移查询"><a href="#偏移查询" class="headerlink" title="偏移查询"></a>偏移查询</h3><p>如：查询http_requests_total在当前时刻的一周的速率：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total&#123;&#125; offset <span class="number">1</span>w)</span></span></span><br></pre></td></tr></table></figure><p>偏移修饰符允许更改查询中单个即时向量和范围向量的时间偏移量，例如，以下表达式返回相对于当前查询时间5分钟前的http_requests_total值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total offset <span class="number">5</span>m</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;<span class="keyword">job</span>=<span class="string">"prometheus"</span>&#125;[<span class="number">5</span>m]</span><br></pre></td></tr></table></figure><p>请注意，偏移量修饰符始终需要跟随选择器，即以下是正确的：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=<span class="string">"<span class="keyword">GET</span>"</span>&#125; offset 5m) // GOOD.</span><br></pre></td></tr></table></figure><p>下面是错误的:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=<span class="string">"<span class="keyword">GET</span>"</span>&#125;) offset 5m // INVALID.</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Prometheus 的查询语言支持基本的逻辑运算和算术运算</p><h4 id="二元算术运算："><a href="#二元算术运算：" class="headerlink" title="二元算术运算："></a>二元算术运算：</h4><ul><li>+加法</li><li>-减法</li><li>*乘法</li><li>/ 除法</li><li>% 模</li><li>^ 幂等</li></ul><p>运算中用到的基础数据类型：</p><ul><li>瞬时向量（Instant vector） - 一组时间序列，每个时间序列包含单个样本，它们共享相同的时间戳。也就是说，表达式的返回值中只会包含该时间序列中的最新的一个样本值。而相应的这样的表达式称之为瞬时向量表达式。</li><li>区间向量（Range vector） - 一组时间序列，每个时间序列包含一段时间范围内的样本数据。</li><li>标量（Scalar） - 一个浮点型的数据值。</li><li>字符串（String） - 一个简单的字符串值。</li></ul><p>二元运算操作符支持 scalar/scalar(标量/标量)、vector/scalar(向量/标量)、和 vector/vector(向量/向量) 之间的操作。</p><p>在两个标量之间进行数学运算，得到的结果也是标量。</p><p>例如，如果我们想根据 node_disk_bytes_written 和 node_disk_bytes_read 获取主机磁盘IO的总量，可以使用如下表达式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">node_disk_bytes_written</span> + node_disk_bytes_read</span><br></pre></td></tr></table></figure><p>或者node的内存数GB</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total / (<span class="number">1024</span> * <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><ul><li>== (相等)</li><li>!= (不相等)</li><li><code>&gt;</code> (大于)</li><li>&lt; (小于)</li><li><code>&gt;=</code>  (大于等于)</li><li>&lt;=  (小于等于)</li></ul><p>如：获取http_requests_total请求总数是否超过10000，返回0和1，1则报警</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total &gt; <span class="number">10000</span> # 结果为 <span class="literal">true</span> 或 <span class="literal">false</span></span><br><span class="line">http_requests_total &gt; <span class="built_in">bool</span> <span class="number">10000</span> # 结果为 <span class="number">1</span> 或 <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ul><li>and (并且)</li><li>or (或者)</li><li>unless (排除)</li></ul><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>四则运算有优先级，promql的复杂运算也有优先级</p><p>例如，查询主机的CPU使用率，可以使用表达式：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span>* (<span class="number">1</span> - avg (irate(node_cpu&#123;mode=<span class="comment">'idle'&#125;[5m])) by(job) )</span></span><br></pre></td></tr></table></figure><p>其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率 在PromQL操作符中优先级由高到低依次为：</p><ol><li>^</li><li>*, /, %</li><li>+, -</li><li>==, !=, &lt;=, &lt;, &gt;=, &gt;</li><li>and, unless</li><li>or</li></ol><h4 id="匹配模式（联合查询）"><a href="#匹配模式（联合查询）" class="headerlink" title="匹配模式（联合查询）"></a>匹配模式（联合查询）</h4><p>与数据库中的join类似，promsql有两种典型的匹配查询：</p><ul><li>一对一（one-to-one）</li><li>多对一（many-to-one）或一对多（one-to-many）</li></ul><p>例如当存在样本：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"500"</span>&#125;  <span class="number">24</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"404"</span>&#125;  <span class="number">30</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"put"</span>, code=<span class="string">"501"</span>&#125;  <span class="number">3</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"500"</span>&#125; <span class="number">6</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"404"</span>&#125; <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>&#125;  <span class="number">600</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"del"</span>&#125;  <span class="number">34</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>&#125; <span class="number">120</span></span><br></pre></td></tr></table></figure><p>使用 PromQL 表达式：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m<span class="comment">&#123;code="500"&#125;</span> / ignoring(code) <span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m</span><br></pre></td></tr></table></figure><p>该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p><p>因此结果如下：</p><p>{method=”get”} 0.04 // 24 / 600 {method=”post”} 0.05 // 6 / 120</p><p>同时由于 method 为 put 和 del 的样本找不到匹配项，因此不会出现在结果当中。</p><p><strong>多对一模式</strong></p><p>例如，使用表达式：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left <span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m</span><br></pre></td></tr></table></figure><p>该表达式中，左向量 method_code:http_errors:rate5m 包含两个标签 method 和 code。而右向量 method:http_requests:rate5m 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 code。</p><p>在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group 修饰符 group_left 指定左向量具有更好的基数。</p><p>最终的运算结果如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"500"</span>&#125; <span class="number">0.04</span> // <span class="number">24</span> / <span class="number">600</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"404"</span>&#125; <span class="number">0.05</span> // <span class="number">30</span> / <span class="number">600</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"500"</span>&#125; <span class="number">0.05</span> // <span class="number">6</span> / <span class="number">120</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"404"</span>&#125; <span class="number">0.175</span> // <span class="number">21</span> / <span class="number">120</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提醒：<span class="keyword">group</span> <span class="title">修饰符只能在比较和数学运算符中使用。在逻辑运算 and</span>，unless 和 <span class="keyword">or</span> 操作中默认与右向量中的所有元素进行匹配。</span><br></pre></td></tr></table></figure><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个具有较少样本值的新的时间序列。</p><ul><li>sum (求和)</li><li>min (最小值)</li><li>max (最大值)</li><li>avg (平均值)</li><li>stddev (标准差)</li><li>stdvar (标准差异)</li><li>count (计数)</li><li>count_values (对 value 进行计数)</li><li>bottomk (样本值最小的 k 个元素)</li><li>topk (样本值最大的k个元素)</li><li>quantile (分布统计)</li></ul><p>这些操作符被用于聚合所有标签维度，或者通过 without 或者 by 子语句来保留不同的维度。</p><ul><li>without 用于从计算结果中移除列举的标签，而保留其它标签。</li><li>by 则正好相反，结果向量中只保留列出的标签，其余标签则移除。</li></ul><p>通过 without 和 by 可以按照样本的问题对数据进行聚合。</p><p>例如：如果指标 http_requests_total 的时间序列的标签集为 application, instance, 和 group，我们可以通过以下方式计算所有 instance 中每个 application 和 group 的请求总量：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">http_requests_total</span>) without (<span class="name">instance</span>)</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">http_requests_total</span>) by (<span class="name">application</span>, group)</span><br></pre></td></tr></table></figure><p>如果只需要计算整个应用的 HTTP 请求总量，可以直接使用表达式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sum</span><span class="params">(http_requests_total)</span></span></span><br></pre></td></tr></table></figure><p>count_values 用于时间序列中每一个样本值出现的次数。count_values 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p><p>这个标签的名字由聚合参数指定，同时这个标签值是唯一的样本值。</p><p>例如要计算运行每个构建版本的二进制文件的数量：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count_values(<span class="string">"version"</span>, <span class="keyword">build_version)</span></span><br><span class="line"><span class="keyword">返回结果如下：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">&#123;count="641"&#125; </span>  <span class="number">1</span></span><br><span class="line">&#123;<span class="built_in">count</span>=<span class="string">"3226"</span>&#125;  <span class="number">2</span></span><br><span class="line">&#123;<span class="built_in">count</span>=<span class="string">"644"</span>&#125;   <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>topk 和 bottomk</strong> </p><p>则用于对样本值进行排序，返回当前样本值前 n 位，或者后 n 位的时间序列。</p><p>获取 HTTP 请求数前 5 位的时序样本数据，可以使用表达式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">topk</span><span class="params">(<span class="number">5</span>, http_requests_total)</span></span></span><br></pre></td></tr></table></figure><p>quantile 用于计算当前样本数据值的分布情况 quantile(φ, express) ，其中 0 ≤ φ ≤ 1</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如，当 φ 为 <span class="number">0.5</span> 时，即表示找到当前样本数据中的中位数：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">quantile(<span class="number">0.5</span>, http_requests_total)</span><br><span class="line">返回结果如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#125;   <span class="number">656</span></span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。如上文提到的irate</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span>* (<span class="number">1</span> - avg (irate(node_cpu&#123;mode=<span class="comment">'idle'&#125;[5m])) by(job) )</span></span><br></pre></td></tr></table></figure><p>常用的有：</p><p>两分钟内的平均CPU使用率：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rate</span><span class="params">(node_cpu[<span class="number">2</span>m])</span></span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">irate</span><span class="params">(node_cpu[<span class="number">2</span>m])</span></span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，</span><br><span class="line">其无法反应在时间窗口内样本数据的突发变化。</span><br><span class="line">例如，对于主机而言在<span class="number">2</span>分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用<span class="number">100</span>%的情况，</span><br><span class="line">但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</span><br><span class="line"></span><br><span class="line">为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-<span class="type">vector</span>)。</span><br><span class="line"></span><br><span class="line">irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。</span><br><span class="line"></span><br><span class="line">irate函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率。</span><br><span class="line">这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</span><br></pre></td></tr></table></figure><p>irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。</p><p>因此在长期趋势分析或者告警中更推荐使用rate函数。</p><p>完整的函数列表为：</p><ul><li>abs()</li><li>absent()</li><li>ceil()</li><li>changes()</li><li>clamp_max()</li><li>clamp_min()</li><li>day_of_month()</li><li>day_of_week()</li><li>days_in_month()</li><li>delta()</li><li>deriv()</li><li>exp()</li><li>floor()</li><li>histogram_quantile()</li><li>holt_winters()</li><li>hour()</li><li>idelta()</li><li>increase()</li><li>irate()</li><li>label_join()</li><li>label_replace()</li><li>ln()</li><li>log2()</li><li>log10()</li><li>minute()</li><li>month()</li><li>predict_linear()</li><li>rate()</li><li>resets()</li><li>round()</li><li>scalar()</li><li>sort()</li><li>sort_desc()</li><li>sqrt()</li><li>time()</li><li>timestamp()</li><li>vector()</li><li>year()</li><li>_over_time()</li></ul><h3 id="API访问"><a href="#API访问" class="headerlink" title="API访问"></a>API访问</h3><p>Prometheus当前稳定的HTTP API可以通过/api/v1访问</p><p>错误状态码：</p><ul><li>404 Bad Request：当参数错误或者缺失时。</li><li>422 Unprocessable Entity 当表达式无法执行时。</li><li>503 Service Unavailiable 当请求超时或者被中断时。</li></ul><p>所有的API请求均使用以下的JSON格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"success"</span> | <span class="string">"error"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &lt;data&gt;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为error时，有如下报错信息</span></span><br><span class="line">  <span class="attr">"errorType"</span>: <span class="string">"&lt;string&gt;"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"&lt;string&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过HTTP API我们可以分别通过/api/v1/query和/api/v1/query_range查询PromQL表达式当前或者一定时间范围内的计算结果。</p><h4 id="瞬时数据查询"><a href="#瞬时数据查询" class="headerlink" title="瞬时数据查询"></a>瞬时数据查询</h4><p>URL请求参数：</p><ul><li>query=：PromQL表达式。</li><li>time=：用于指定用于计算PromQL的时间戳。可选参数，默认情况下使用当前系统时间。</li><li>timeout=：超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 'http://localhost:<span class="number">9090</span>/api/v1/query?query=up&amp;time=<span class="number">2015-07-01</span>T20:10:51.781Z'</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line">   <span class="attr">"data"</span> : &#123;</span><br><span class="line">      <span class="attr">"resultType"</span> : <span class="string">"vector"</span>,</span><br><span class="line">      <span class="attr">"result"</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"prometheus"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9090"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"value"</span>: [ <span class="number">1435781451.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"node"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9100"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"value"</span> : [ <span class="number">1435781451.781</span>, <span class="string">"0"</span> ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>URL请求参数：</p><ul><li>query=: PromQL表达式。</li><li>start=: 起始时间。</li><li>end=: 结束时间。</li><li>step=: 查询步长。</li><li>timeout=: 超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 'http://localhost:<span class="number">9090</span>/api/v1/query_range?query=up&amp;start=<span class="number">2015-07-01</span>T20:10:30.781Z&amp;end=<span class="number">2015-07-01</span>T20:11:00.781Z&amp;step=15s'</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line">   <span class="attr">"data"</span> : &#123;</span><br><span class="line">      <span class="attr">"resultType"</span> : <span class="string">"matrix"</span>,</span><br><span class="line">      <span class="attr">"result"</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"prometheus"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9090"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"values"</span> : [</span><br><span class="line">               [ <span class="number">1435781430.781</span>, <span class="string">"1"</span> ],</span><br><span class="line">               [ <span class="number">1435781445.781</span>, <span class="string">"1"</span> ],</span><br><span class="line">               [ <span class="number">1435781460.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"node"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9091"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"values"</span> : [</span><br><span class="line">               [ <span class="number">1435781430.781</span>, <span class="string">"0"</span> ],</span><br><span class="line">               [ <span class="number">1435781445.781</span>, <span class="string">"0"</span> ],</span><br><span class="line">               [ <span class="number">1435781460.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prometheus配置"><a href="#Prometheus配置" class="headerlink" title="Prometheus配置"></a>Prometheus配置</h2><p>Prometheus可以通过命令行参数和配置文件来配置，其中命令行参数主要用于配置一些不可变的系统参数（比如存储位置、需要保存在内存和磁盘数据的数量），配置文件用于配置所有和 <a href="https://prometheus.io/docs/concepts/jobs_instances/" target="_blank" rel="external nofollow noopener noreferrer">scrape jobs and instances</a> 相关的参数。本小节讲的Prometheus配置，是指的命令行配置的 <code>--config.file=/etc/config/prometheus.yml</code>内容，这是所有配置的入口，更多内容可以参考 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a></p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>Prometheus 配置文件主要分为以下几个部分，下面将依次介绍。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># How frequently to scrape targets by default.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># How long until a scrape request times out.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">10s</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># How frequently to evaluate rules.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">evaluation_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The labels to add to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># File to which PromQL queries are logged.</span></span><br><span class="line">  <span class="comment"># Reloading the configuration will reopen the file.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">query_log_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rule files specifies a list of globs. Rules and alerts are read from</span></span><br><span class="line"><span class="comment"># all matching files.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A list of scrape configurations.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;scrape_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alerting specifies settings related to the Alertmanager.</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;alertmanager_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote write feature.</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_write&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote read feature.</span></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_read&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><h3 id="rule-files"><a href="#rule-files" class="headerlink" title="rule_files"></a>rule_files</h3><h3 id="scrape-config"><a href="#scrape-config" class="headerlink" title="scrape_config"></a>scrape_config</h3><p><code>scrape_config</code> 部分指定了一系列需要抓取的Target和参数，一般来说，一个scrape配置指定了一个Job，这部分多个<code>scrape_config</code> 以一个列表的形式呈现。Target可以通过 <code>static_configs</code> 来静态配置，也可以通过Prometheus支持的各种服务发现机制来动态配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The job name assigned to scraped metrics by default.</span></span><br><span class="line"><span class="attr">job_name:</span> <span class="string">&lt;job_name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How frequently to scrape targets from this job.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">&lt;global_config.scrape_interval&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-scrape timeout when scraping this job.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scrape_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">&lt;global_config.scrape_timeout&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The HTTP resource path on which to fetch metrics from targets.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">metrics_path:</span> <span class="string">&lt;path&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">/metrics</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># honor_labels controls how Prometheus handles conflicts between labels that are</span></span><br><span class="line"><span class="comment"># already present in scraped data and labels that Prometheus would attach</span></span><br><span class="line"><span class="comment"># server-side ("job" and "instance" labels, manually configured target</span></span><br><span class="line"><span class="comment"># labels, and labels generated by service discovery implementations).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_labels is set to "true", label conflicts are resolved by keeping label</span></span><br><span class="line"><span class="comment"># values from the scraped data and ignoring the conflicting server-side labels.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_labels is set to "false", label conflicts are resolved by renaming</span></span><br><span class="line"><span class="comment"># conflicting labels in the scraped data to "exported_&lt;original-label&gt;" (for</span></span><br><span class="line"><span class="comment"># example "exported_instance", "exported_job") and then attaching server-side</span></span><br><span class="line"><span class="comment"># labels.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting honor_labels to "true" is useful for use cases such as federation and</span></span><br><span class="line"><span class="comment"># scraping the Pushgateway, where all labels specified in the target should be</span></span><br><span class="line"><span class="comment"># preserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that any globally configured "external_labels" are unaffected by this</span></span><br><span class="line"><span class="comment"># setting. In communication with external systems, they are always applied only</span></span><br><span class="line"><span class="comment"># when a time series does not have a given label yet and are ignored otherwise.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">honor_labels:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="literal">false</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># honor_timestamps controls whether Prometheus respects the timestamps present</span></span><br><span class="line"><span class="comment"># in scraped data.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_timestamps is set to "true", the timestamps of the metrics exposed</span></span><br><span class="line"><span class="comment"># by the target will be used.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If honor_timestamps is set to "false", the timestamps of the metrics exposed</span></span><br><span class="line"><span class="comment"># by the target will be ignored.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">honor_timestamps:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="literal">true</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configures the protocol scheme used for requests.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scheme:</span> <span class="string">&lt;scheme&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">http</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional HTTP URL parameters.</span></span><br><span class="line"><span class="attr">params:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;string&gt;:</span> <span class="string">[&lt;string&gt;,</span> <span class="string">...]</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the `Authorization` header on every scrape request with the</span></span><br><span class="line"><span class="comment"># configured username and password.</span></span><br><span class="line"><span class="comment"># password and password_file are mutually exclusive.</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the `Authorization` header on every scrape request with</span></span><br><span class="line"><span class="comment"># the configured bearer token. It is mutually exclusive with `bearer_token_file`.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the `Authorization` header on every scrape request with the bearer token</span></span><br><span class="line"><span class="comment"># read from the configured file. It is mutually exclusive with `bearer_token`.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configures the scrape request's TLS settings.</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional proxy URL.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Azure service discovery configurations.</span></span><br><span class="line"><span class="attr">azure_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;azure_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Consul service discovery configurations.</span></span><br><span class="line"><span class="attr">consul_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;consul_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of DigitalOcean service discovery configurations.</span></span><br><span class="line"><span class="attr">digitalocean_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;digitalocean_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Docker Swarm service discovery configurations.</span></span><br><span class="line"><span class="attr">dockerswarm_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;dockerswarm_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of DNS service discovery configurations.</span></span><br><span class="line"><span class="attr">dns_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;dns_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of EC2 service discovery configurations.</span></span><br><span class="line"><span class="attr">ec2_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;ec2_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Eureka service discovery configurations.</span></span><br><span class="line"><span class="attr">eureka_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;eureka_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of file service discovery configurations.</span></span><br><span class="line"><span class="attr">file_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;file_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of GCE service discovery configurations.</span></span><br><span class="line"><span class="attr">gce_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;gce_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Hetzner service discovery configurations.</span></span><br><span class="line"><span class="attr">hetzner_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;hetzner_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Kubernetes service discovery configurations.</span></span><br><span class="line"><span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;kubernetes_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Marathon service discovery configurations.</span></span><br><span class="line"><span class="attr">marathon_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;marathon_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of AirBnB's Nerve service discovery configurations.</span></span><br><span class="line"><span class="attr">nerve_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;nerve_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of OpenStack service discovery configurations.</span></span><br><span class="line"><span class="attr">openstack_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;openstack_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Zookeeper Serverset service discovery configurations.</span></span><br><span class="line"><span class="attr">serverset_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;serverset_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Triton service discovery configurations.</span></span><br><span class="line"><span class="attr">triton_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;triton_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of labeled statically configured targets for this job.</span></span><br><span class="line"><span class="attr">static_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;static_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of target relabel configurations.</span></span><br><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of metric relabel configurations.</span></span><br><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-scrape limit on number of scraped samples that will be accepted.</span></span><br><span class="line"><span class="comment"># If more than this number of samples are present after metric relabeling</span></span><br><span class="line"><span class="comment"># the entire scrape will be treated as failed. 0 means no limit.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">sample_limit:</span> <span class="string">&lt;int&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="number">0</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-scrape config limit on number of unique targets that will be</span></span><br><span class="line"><span class="comment"># accepted. If more than this number of targets are present after target</span></span><br><span class="line"><span class="comment"># relabeling, Prometheus will mark the targets as failed without scraping them.</span></span><br><span class="line"><span class="comment"># 0 means no limit. This is an experimental feature, this behaviour could</span></span><br><span class="line"><span class="comment"># change in the future.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">target_limit:</span> <span class="string">&lt;int&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="number">0</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h4 id="static-config"><a href="#static-config" class="headerlink" title="static_config"></a>static_config</h4><h4 id="kubernetes-sd-config"><a href="#kubernetes-sd-config" class="headerlink" title="kubernetes_sd_config"></a>kubernetes_sd_config</h4><p><code>Kubernetes SD configurations</code> 允许从 Kubernetes 的 REST API 来抓取目标，并且保持与集群状态同步。</p><p>Role 的类型可以被配置为以下几种：</p><h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><h5 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h5><h5 id="endpoints"><a href="#endpoints" class="headerlink" title="endpoints"></a>endpoints</h5><h5 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The information to access the Kubernetes API.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The API server addresses. If left empty, Prometheus is assumed to run inside</span></span><br><span class="line"><span class="comment"># of the cluster and will discover API servers automatically and use the pod's</span></span><br><span class="line"><span class="comment"># CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">api_server:</span> <span class="string">&lt;host&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Kubernetes role of entities that should be discovered.</span></span><br><span class="line"><span class="comment"># One of endpoints, service, pod, node, or ingress.</span></span><br><span class="line"><span class="attr">role:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional authentication information used to authenticate to the API server.</span></span><br><span class="line"><span class="comment"># Note that `basic_auth`, `bearer_token` and `bearer_token_file` options are</span></span><br><span class="line"><span class="comment"># mutually exclusive.</span></span><br><span class="line"><span class="comment"># password and password_file are mutually exclusive.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional HTTP basic authentication information.</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional bearer token authentication information.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional bearer token file authentication information.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional proxy URL.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TLS configuration.</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional namespace discovery. If omitted, all namespaces are used.</span></span><br><span class="line"><span class="attr">namespaces:</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional label and field selectors to limit the discovery process to a subset of available resources. </span></span><br><span class="line"><span class="comment"># See https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/</span></span><br><span class="line"><span class="comment"># and https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ to learn more about the possible </span></span><br><span class="line"><span class="comment"># filters that can be used. Endpoints role supports pod, service and endpoints selectors, other roles</span></span><br><span class="line"><span class="comment"># only support selectors matching the role itself (e.g. node role can only contain node selectors).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> When making decision about using field/label selector make sure that this </span></span><br><span class="line"><span class="comment"># is the best approach - it will prevent Prometheus from reusing single list/watch</span></span><br><span class="line"><span class="comment"># for all scrape configs. This might result in a bigger load on the Kubernetes API,</span></span><br><span class="line"><span class="comment"># because per each selector combination there will be additional LIST/WATCH. On the other hand,</span></span><br><span class="line"><span class="comment"># if you just want to monitor small subset of pods in large cluster it's recommended to use selectors.</span></span><br><span class="line"><span class="comment"># Decision, if selectors should be used or not depends on the particular situation.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">selectors:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="string">[</span> <span class="attr">label:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">    <span class="string">[</span> <span class="attr">field:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span> <span class="string">]]</span></span><br></pre></td></tr></table></figure><h4 id="relabel-config"><a href="#relabel-config" class="headerlink" title="relabel_config"></a>relabel_config</h4><p><code>Relabeling</code> 是一个可以在数据被抓取之前动态重写target里面label的强大工具。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The source labels select values from existing labels. Their content is concatenated</span></span><br><span class="line"><span class="comment"># using the configured separator and matched against the configured regular expression</span></span><br><span class="line"><span class="comment"># for the replace, keep, and drop actions.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">source_labels:</span> <span class="string">'['</span> <span class="string">&lt;labelname&gt;</span> <span class="string">[,</span> <span class="string">...]</span> <span class="string">']'</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Separator placed between concatenated source label values.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">separator:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Label to which the resulting value is written in a replace action.</span></span><br><span class="line"><span class="comment"># It is mandatory for replace actions. Regex capture groups are available.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">target_label:</span> <span class="string">&lt;labelname&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Regular expression against which the extracted value is matched.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">regex:</span> <span class="string">&lt;regex&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">(.*)</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modulus to take of the hash of the source label values.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">modulus:</span> <span class="string">&lt;int&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replacement value against which a regex replace is performed if the</span></span><br><span class="line"><span class="comment"># regular expression matches. Regex capture groups are available.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">replacement:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">$1</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Action to perform based on regex matching.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">action:</span> <span class="string">&lt;relabel_action&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">replace</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p><code>&lt;relabel_action&gt;</code> 决定了relabel时候采取的动作：</p><ul><li><code>replace</code>: Match <code>regex</code> against the concatenated <code>source_labels</code>. Then, set <code>target_label</code> to <code>replacement</code>, with match group references (<code>${1}</code>, <code>${2}</code>, …) in <code>replacement</code> substituted by their value. If <code>regex</code> does not match, no replacement takes place.</li><li><code>keep</code>: Drop targets for which <code>regex</code> does not match the concatenated <code>source_labels</code>.</li><li><code>drop</code>: Drop targets for which <code>regex</code> matches the concatenated <code>source_labels</code>.</li><li><code>hashmod</code>: Set <code>target_label</code> to the <code>modulus</code> of a hash of the concatenated <code>source_labels</code>.</li><li><code>labelmap</code>: Match <code>regex</code> against all label names. Then copy the values of the matching labels to label names given by <code>replacement</code> with match group references (<code>${1}</code>, <code>${2}</code>, …) in <code>replacement</code> substituted by their value.</li><li><code>labeldrop</code>: Match <code>regex</code> against all label names. Any label that matches will be removed from the set of labels.</li><li><code>labelkeep</code>: Match <code>regex</code> against all label names. Any label that does not match will be removed from the set of labels.</li></ul><h3 id="alerting"><a href="#alerting" class="headerlink" title="alerting"></a>alerting</h3><h3 id="remote-write"><a href="#remote-write" class="headerlink" title="remote_write"></a>remote_write</h3><h3 id="remote-read"><a href="#remote-read" class="headerlink" title="remote_read"></a>remote_read</h3><h2 id="Alert-Rules"><a href="#Alert-Rules" class="headerlink" title="Alert Rules"></a>Alert Rules</h2><p>Prometheus中的告警规则允许你基于PromQL表达式定义告警触发条件，Prometheus后端对这些触发规则进行周期性计算，当满足触发条件后则会触发告警通知。默认情况下，用户可以通过Prometheus的Web界面查看这些告警规则以及告警的触发状态。当Promthues与Alertmanager关联之后，可以将告警发送到外部服务如Alertmanager中并通过Alertmanager可以对这些告警进行进一步的处理。</p><h3 id="定义告警规则"><a href="#定义告警规则" class="headerlink" title="定义告警规则"></a>定义告警规则</h3><p>一条典型的告警规则如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">HighErrorRate</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">job:request_latency_seconds:mean5m&#123;job="myjob"&#125;</span> <span class="string">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">High</span> <span class="string">request</span> <span class="string">latency</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">description</span> <span class="string">info</span></span><br></pre></td></tr></table></figure><p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：</p><ul><li>alert：告警规则的名称。</li><li>expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。</li><li>for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。</li><li>labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。</li><li>annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。</li></ul><p>为了能够让Prometheus能够启用定义的告警规则，我们需要在Prometheus全局配置文件中通过<strong>rule_files</strong>指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>默认情况下Prometheus会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过<code>evaluation_interval</code>来覆盖默认的计算周期：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">evaluation_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h3><p>一般来说，在告警规则文件的annotations中使用<code>summary</code>描述告警的概要信息，<code>description</code>用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations的中标签的值。</p><p>通过<code>$labels.&lt;labelname&gt;</code>变量可以访问当前告警实例中指定标签的值。$value则可以获取当前PromQL表达式计算的样本值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To insert a firing element's label values:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$labels.&lt;labelname&gt;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="comment"># To insert the numeric expression value of the firing element:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$value</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>例如，可以通过模板化优化summary以及description的内容的可读性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes."</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that has a median request latency &gt;1s.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">APIHighRequestLatency</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">api_http_request_latencies_second&#123;quantile="0.5"&#125;</span> <span class="string">&gt;</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"High request latency on <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> has a median request latency above 1s (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>s)"</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>配置 Alert Rules，修改 Prometheus 配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span></span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">rule_files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/recording_rules.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/alerting_rules.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/rules</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/alerts</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['node-exporter:9100']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'container'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['cadvisor:8080']</span></span><br><span class="line">  <span class="attr">alerting_rules.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hostStatsAlert</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">hostMemUsageAlert</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">(sum(node_memory_MemTotal_bytes)</span> <span class="bullet">-</span> <span class="string">sum(node_memory_MemFree_bytes</span> <span class="string">+</span> <span class="string">node_memory_Buffers_bytes+node_memory_Cached_bytes))</span> <span class="string">/</span> <span class="string">sum(node_memory_MemTotal_bytes)</span> <span class="string">&gt;</span> <span class="number">0.55</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">        <span class="attr">annotations:</span></span><br><span class="line">            <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usgae high"</span></span><br><span class="line">            <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usage above 85% (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>)"</span></span><br><span class="line">  <span class="attr">alerts:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">recording_rules.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">rules:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>重启Prometheus后访问Prometheus UI 可以查看当前以加载的规则文件：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-rules.png"></p><p>切换到Alerts标签可以查看当前告警的活动状态。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-alerts.png"></p><p>现在只是在 Prometheus Web 页面查看警告，通过配置 <code>Alert Manager</code> 可以实现连接钉钉/Slack等平台报警。</p><h2 id="Recording-Rules"><a href="#Recording-Rules" class="headerlink" title="Recording Rules"></a>Recording Rules</h2><p>通过PromQL可以实时对Prometheus中采集到的样本数据进行查询，聚合以及其它各种运算操作。而在某些PromQL较为复杂且计算量较大时，直接使用PromQL可能会导致Prometheus响应超时的情况。这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。Prometheus通过Recoding Rule规则支持这种后台计算的方式，可以实现对复杂查询的性能优化，提高查询效率。</p><p>在Prometheus配置文件中，通过rule_files定义recoding rule规则文件的访问路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>每一个规则文件通过以下格式进行定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule_group&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>一个简单的规则文件可能是这个样子的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">record:</span> <span class="string">job:http_inprogress_requests:sum</span></span><br><span class="line">      <span class="attr">expr:</span> <span class="string">sum(http_inprogress_requests)</span> <span class="string">by</span> <span class="string">(job)</span></span><br></pre></td></tr></table></figure><p>rule_group的具体配置项如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the group. Must be unique within a file.</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often rules in the group are evaluated.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.evaluation_interval</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>与告警规则一致，一个group下可以包含多条规则rule。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the time series to output to. Must be a valid metric name.</span></span><br><span class="line"><span class="attr">record:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The PromQL expression to evaluate. Every evaluation cycle this is</span></span><br><span class="line"><span class="comment"># evaluated at the current time, and the result recorded as a new set of</span></span><br><span class="line"><span class="comment"># time series with the metric name as given by 'record'.</span></span><br><span class="line"><span class="attr">expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Labels to add or overwrite before storing the result.</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>根据规则中的定义，Prometheus会在后台完成expr中定义的PromQL表达式计算，并且将计算结果保存到新的时间序列record中。同时还可以通过labels为这些样本添加额外的标签。</p><p>这些规则文件的计算频率与告警规则计算频率一致，都通过global.evaluation_interval定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  [ evaluation_interval: &lt;duration&gt; |<span class="built_in"> default </span>= 1m ]</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/vovlie/p/7709312.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/vovlie/p/7709312.html</a></li><li><a href="https://www.infoq.cn/article/Prometheus-theory-source-code" target="_blank" rel="external nofollow noopener noreferrer">https://www.infoq.cn/article/Prometheus-theory-source-code</a></li><li><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="external nofollow noopener noreferrer">https://yunlzheng.gitbook.io/prometheus-book/</a></li><li><a href="https://yasongxu.gitbook.io/container-monitor/" target="_blank" rel="external nofollow noopener noreferrer">https://yasongxu.gitbook.io/container-monitor/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prometheus是一套开源的监控、报警、时间序列数据库的组合，起始是由SoundCloud公司开发的。从2016年加入CNCF，2016年6月正式发布1.0版本，2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合，到2018年8月毕业，现在已经成为Kubernetes的官方监控方案，社区活跃，第三方集成非常丰富。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-architecture.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="可观测性" scheme="http://houmin.cc/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
      <category term="prometheus" scheme="http://houmin.cc/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】Node Exporter</title>
    <link href="http://houmin.cc/posts/dd1e183c/"/>
    <id>http://houmin.cc/posts/dd1e183c/</id>
    <published>2020-09-15T06:51:03.000Z</published>
    <updated>2020-11-18T12:13:06.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Exporter 是Prometheus的一类数据采集组件的总称，负责从目标处搜集数据，并将其转化为Prometheus支持的格式。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取，默认的抓取地址为 <code>http://current_ip:9100/metrics</code>。Node Exporter 用于采集服务器层面的运行指标，包括机器的 loadavg、filesystem、meminfo等基础监控，类似于传统主机监控维度的zabbix-agent。<code>Node Export</code> 由prometheus官方提供、维护，不会捆绑安装，但基本上是必备的exporter。</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>node-exporter用于提供*NIX内核的硬件以及系统指标。</p><ul><li>如果是windows系统，可以使用<a href="https://github.com/martinlindhe/wmi_exporter" target="_blank" rel="external nofollow noopener noreferrer">WMI exporter</a></li><li>如果是采集NVIDIA的GPU指标，可以使用<a href="https://github.com/NVIDIA/gpu-monitoring-tools/tree/master/exporters/prometheus-dcgm" target="_blank" rel="external nofollow noopener noreferrer">prometheus-dcgm </a></li></ul><p>根据不同的*NIX操作系统，node-exporter采集指标的支持也是不一样的，如：</p><ul><li>diskstats 支持    Darwin, Linux</li><li>cpu 支持Darwin, Dragonfly, FreeBSD, Linux, Solaris等，</li></ul><p>详细信息参考：<a href="https://github.com/prometheus/node_exporter" target="_blank" rel="external nofollow noopener noreferrer">node_exporter</a></p><p>我们可以使用 —collectors.enabled参数指定node_exporter收集的功能模块,或者用—no-collector指定不需要的模块，如果不指定，将使用默认配置。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">'true'</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scrape</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9100</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/node-exporter:v1.0.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">scrape</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>得到一个daemonset和一个service对象，部署后，为了能够让Prometheus能够从当前node exporter获取到监控数据，这里需要修改Prometheus配置文件。编辑 <code>prometheus.yml</code> 并在scrape_configs节点下添加以下内容:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">scrape_configs</span>:</span><br><span class="line">  # 采集node exporter监控数据</span><br><span class="line">  - <span class="attribute">job_name</span>: <span class="string">'node'</span></span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'localhost:9100'</span>]</span><br></pre></td></tr></table></figure><p>也可以使用<code>prometheus.io/scrape: &#39;true&#39;</code>标识来自动获取service的metric接口</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>source<span class="emphasis">_labels: [_</span><span class="emphasis">_meta_</span>kubernetes<span class="emphasis">_service_</span>annotation<span class="emphasis">_prometheus_</span>io<span class="emphasis">_scrape]</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启prometheus就能看到对应的指标</p><p><strong>直接查看：</strong></p><p>如果是二进制或者docker部署，部署成功后可以访问：<a href="http:///${IP}:9100/metrics">http://${IP}:9100/metrics</a></p><p>会输出下面格式的内容，包含了node-exporter暴露的所有指标：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0"</span>&#125; 6.1872e-05</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.25"</span>&#125; 0.000119463</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.5"</span>&#125; 0.000151156</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.75"</span>&#125; 0.000198764</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"1"</span>&#125; 0.009889647</span><br><span class="line">go_gc_duration_seconds_sum 0.257232201</span><br><span class="line">go_gc_duration_seconds_count 1187</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP node_cpu Seconds the cpus spent in each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu counter</span></span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="guest"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="guest_nice"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="idle"&#125; 68859.19</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="iowait"&#125; 167.22</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="irq"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="nice"&#125; 19.92</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="softirq"&#125; 17.05</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="steal"&#125; 28.1</span><br></pre></td></tr></table></figure><p><strong>Prometheus查看：</strong></p><p>类似go_gc_duration_seconds和node_cpu就是metric的名称，如果使用了Prometheus,则可以在<code>http://${IP}:9090/</code> 页面的指标中搜索到以上的指标：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_node-exporter-metrics.png"></p><p>常用指标类型有：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_cpu：系统CPU使用量</span><br><span class="line">node_disk*：磁盘IO</span><br><span class="line">node_filesystem*：文件系统用量</span><br><span class="line">node_load1：系统负载</span><br><span class="line">node_memeory*：内存使用量</span><br><span class="line">node_network*：网络带宽</span><br><span class="line">node_time：当前系统时间</span><br><span class="line">go_*：<span class="keyword">node</span> <span class="title">exporter</span>中go相关指标</span><br><span class="line">process_*：<span class="keyword">node</span> <span class="title">exporter</span>自身进程相关运行指标</span><br></pre></td></tr></table></figure><p><strong>Grafana查看：</strong></p><p>Prometheus虽然自带了web页面，但一般会和更专业的Grafana配套做指标的可视化，Grafana有很多模板，用于更友好地展示出指标的情况，如<a href="https://grafana.com/dashboards/8919" target="_blank" rel="external nofollow noopener noreferrer">Node Exporter for Prometheus</a></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p><p>在grafana中配置好变量、导入模板就会有上图的效果。</p><h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><p>node-exporter是Prometheus官方推荐的exporter，类似的还有</p><ul><li><a href="https://github.com/prometheus/haproxy_exporter" target="_blank" rel="external nofollow noopener noreferrer">HAProxy exporter</a></li><li><a href="https://github.com/prometheus/collectd_exporter" target="_blank" rel="external nofollow noopener noreferrer">Collectd exporter</a></li><li><a href="https://github.com/prometheus/snmp_exporter" target="_blank" rel="external nofollow noopener noreferrer">SNMP exporter</a></li><li><a href="https://github.com/prometheus/mysqld_exporter" target="_blank" rel="external nofollow noopener noreferrer">MySQL server exporter</a></li><li>….</li></ul><p>官方推荐的都会在<a href="https://github.com/prometheus下，在[exporter推荐页](https://prometheus.io/docs/instrumenting/exporters/)，也会有很多第三方的exporter，由个人或者组织开发上传，如果有自定义的采集需求，可以自己编写[exporter](https://prometheus.io/docs/instrumenting/writing_exporters/)。" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/prometheus下，在[exporter推荐页](https://prometheus.io/docs/instrumenting/exporters/)，也会有很多第三方的exporter，由个人或者组织开发上传，如果有自定义的采集需求，可以自己编写[exporter](https://prometheus.io/docs/instrumenting/writing_exporters/)。</a></p><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p>node-exporter的主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package collector includes all individual collectors to gather and export system metrics.</span></span><br><span class="line"><span class="keyword">package</span> collector</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/common/log"</span></span><br><span class="line">    <span class="string">"gopkg.in/alecthomas/kingpin.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Namespace defines the common namespace to be used by all metrics.</span></span><br><span class="line"><span class="keyword">const</span> namespace = <span class="string">"node"</span></span><br></pre></td></tr></table></figure><p>可以看到exporter的实现需要引入github.com/prometheus/client_golang/prometheus库，client_golang是prometheus的官方go库，既可以用于集成现有应用，也可以作为连接Prometheus HTTP API的基础库。</p><p>比如定义了基础的数据类型以及对应的方法：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter：收集事件次数等单调递增的数据</span><br><span class="line">Gauge：收集当前的状态，比如数据库连接数</span><br><span class="line"><span class="keyword">Histogram</span>：收集随机正态分布数据，比如响应延迟</span><br><span class="line">Summary：收集随机正态分布数据，和 <span class="keyword">Histogram</span> 是类似的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Exporter 是Prometheus的一类数据采集组件的总称，负责从目标处搜集数据，并将其转化为Prometheus支持的格式。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取，默认的抓取地址为 &lt;code&gt;http://current_ip:9100/metrics&lt;/code&gt;。Node Exporter 用于采集服务器层面的运行指标，包括机器的 loadavg、filesystem、meminfo等基础监控，类似于传统主机监控维度的zabbix-agent。&lt;code&gt;Node Export&lt;/code&gt; 由prometheus官方提供、维护，不会捆绑安装，但基本上是必备的exporter。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_node-exporter.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="可观测性" scheme="http://houmin.cc/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】kube-state-metrics</title>
    <link href="http://houmin.cc/posts/9bd76ed5/"/>
    <id>http://houmin.cc/posts/9bd76ed5/</id>
    <published>2020-09-15T05:40:21.000Z</published>
    <updated>2020-11-18T12:12:54.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>已经有了cadvisor、heapster、metric-server，几乎容器运行的所有指标都能拿到，但是下面这种情况却无能为力：</p><ul><li>我调度了多少个replicas？现在可用的有几个？</li><li>多少个Pod是running/stopped/terminated状态？</li><li>Pod重启了多少次？</li><li>我有多少job在运行中</li></ul><p>而这些则是kube-state-metrics提供的内容，它基于client-go开发，轮询Kubernetes API，并将Kubernetes的结构化信息转换为metrics。</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>kube-state-metrics提供的指标，按照阶段分为三种类别：</p><ul><li>1.实验性质的：k8s api中alpha阶段的或者spec的字段。</li><li>2.稳定版本的：k8s中不向后兼容的主要版本的更新</li><li>3.被废弃的：已经不在维护的。</li></ul><p>指标类别包括：</p><ul><li>CronJob Metrics</li><li>DaemonSet Metrics</li><li>Deployment Metrics</li><li>Job Metrics</li><li>LimitRange Metrics</li><li>Node Metrics</li><li>PersistentVolume Metrics</li><li>PersistentVolumeClaim Metrics</li><li>Pod Metrics</li><li>Pod Disruption Budget Metrics</li><li>ReplicaSet Metrics</li><li>ReplicationController Metrics</li><li>ResourceQuota Metrics</li><li>Service Metrics</li><li>StatefulSet Metrics</li><li>Namespace Metrics</li><li>Horizontal Pod Autoscaler Metrics</li><li>Endpoint Metrics</li><li>Secret Metrics</li><li>ConfigMap Metrics</li></ul><p>以pod为例：</p><ul><li>kube_pod_info</li><li>kube_pod_owner</li><li>kube_pod_status_phase</li><li>kube_pod_status_ready</li><li>kube_pod_status_scheduled</li><li>kube_pod_container_status_waiting</li><li>kube_pod_container_status_terminated_reason</li><li>…</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://github.com/kubernetes/kube-state-metrics/tree/master/examples/standard" target="_blank" rel="external nofollow noopener noreferrer">部署清单</a>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kube-<span class="section">state</span>-metrics/</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-cluster-role-binding.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-cluster-role.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-deployment.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-role-binding.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-role.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-service-account.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-service.yaml</span><br></pre></td></tr></table></figure><p>主要镜像有： image: quay.io/coreos/kube-state-metrics:v1.5.0 image: k8s.gcr.io/addon-resizer:1.8.3（参考metric-server文章，用于扩缩容）</p><p>对于pod的资源限制，一般情况下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>MiB memory <span class="number">0.1</span> cores</span><br></pre></td></tr></table></figure><p>超过100节点的集群：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2M</span>iB memory per <span class="keyword">node</span> <span class="title">0</span>.<span class="number">001</span> cores per <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure><p>kube-state-metrics做过一次性能优化，具体内容参考下文</p><p>部署成功后，prometheus的target会出现如下标志</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/d3c663e527607ecc3eab922ca13a8f44.png"></p><p>因为kube-state-metrics-service.yaml中有<code>prometheus.io/scrape: &#39;true&#39;</code>标识，因此会将metric暴露给prometheus，而Prometheus会在kubernetes-service-endpoints这个job下自动发现kube-state-metrics，并开始拉取metrics，无需其他配置。</p><p>使用kube-state-metrics后的常用场景有：</p><ul><li>存在执行失败的Job: kube_job_status_failed{job=”kubernetes-service-endpoints”,k8s_app=”kube-state-metrics”}==1</li><li>集群节点状态错误: kube_node_status_condition{condition=”Ready”,status!=”true”}==1</li><li>集群中存在启动失败的Pod：kube_pod_status_phase{phase=~”Failed|Unknown”}==1</li><li>最近30分钟内有Pod容器重启: changes(kube_pod_container_status_restarts[30m])&gt;0</li></ul><p>配合报警可以更好地监控集群的运行</p><h2 id="与metric-server的对比"><a href="#与metric-server的对比" class="headerlink" title="与metric-server的对比"></a>与metric-server的对比</h2><ul><li>metric-server（或heapster）是从api-server中获取cpu、内存使用率这种监控指标，并把他们发送给存储后端，如influxdb或云厂商，他当前的核心作用是：为HPA等组件提供决策指标支持。</li><li>kube-state-metrics关注于获取k8s各种资源的最新状态，如deployment或者daemonset，之所以没有把kube-state-metrics纳入到metric-server的能力中，是因为他们的关注点本质上是不一样的。metric-server仅仅是获取、格式化现有数据，写入特定的存储，实质上是一个监控系统。而kube-state-metrics是将k8s的运行状况在内存中做了个快照，并且获取新的指标，但他没有能力导出这些指标</li><li>换个角度讲，kube-state-metrics本身是metric-server的一种数据来源，虽然现在没有这么做。</li><li>另外，像Prometheus这种监控系统，并不会去用metric-server中的数据，他都是自己做指标收集、集成的（Prometheus包含了metric-server的能力），但Prometheus可以监控metric-server本身组件的监控状态并适时报警，这里的监控就可以通过kube-state-metrics来实现，如metric-serverpod的运行状态。</li></ul><h2 id="深入解析"><a href="#深入解析" class="headerlink" title="深入解析"></a>深入解析</h2><p>kube-state-metrics本质上是不断轮询api-server，代码结构也很简单 主要代码目录</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── collectors</span><br><span class="line">│   ├── builder.<span class="keyword">go</span></span><br><span class="line">│   ├── collectors.<span class="keyword">go</span></span><br><span class="line">│   ├── configmap.<span class="keyword">go</span></span><br><span class="line">│   ......</span><br><span class="line">│   ├── testutils.<span class="keyword">go</span></span><br><span class="line">│   ├── testutils_test.<span class="keyword">go</span></span><br><span class="line">│   └── utils.<span class="keyword">go</span></span><br><span class="line">├── constant</span><br><span class="line">│   └── resource_unit.<span class="keyword">go</span></span><br><span class="line">├── metrics</span><br><span class="line">│   ├── metrics.<span class="keyword">go</span></span><br><span class="line">│   └── metrics_test.<span class="keyword">go</span></span><br><span class="line">├── metrics_store</span><br><span class="line">│   ├── metrics_store.<span class="keyword">go</span></span><br><span class="line">│   └── metrics_store_test.<span class="keyword">go</span></span><br><span class="line">├── <span class="keyword">options</span></span><br><span class="line">│   ├── collector.<span class="keyword">go</span></span><br><span class="line">│   ├── <span class="keyword">options</span>.<span class="keyword">go</span></span><br><span class="line">│   ├── options_test.<span class="keyword">go</span></span><br><span class="line">│   ├── types.<span class="keyword">go</span></span><br><span class="line">│   └── types_test.<span class="keyword">go</span></span><br><span class="line">├── <span class="keyword">version</span></span><br><span class="line">│   └── <span class="keyword">version</span>.<span class="keyword">go</span></span><br><span class="line">└── whiteblacklist</span><br><span class="line">    ├── whiteblacklist.<span class="keyword">go</span></span><br><span class="line">    └── whiteblacklist_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>所有类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    DefaultNamespaces = NamespaceList&#123;metav1.NamespaceAll&#125;</span><br><span class="line">    DefaultCollectors = CollectorSet&#123;</span><br><span class="line">        <span class="string">"daemonsets"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"deployments"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"limitranges"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"nodes"</span>:                    <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"pods"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"poddisruptionbudgets"</span>:     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"replicasets"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"replicationcontrollers"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"resourcequotas"</span>:           <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"services"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"jobs"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"cronjobs"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"statefulsets"</span>:             <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"persistentvolumes"</span>:        <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"persistentvolumeclaims"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"namespaces"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"horizontalpodautoscalers"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"endpoints"</span>:                <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"secrets"</span>:                  <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"configmaps"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>构建对应的收集器</p><p>Family即一个类型的资源集合，如job下的kube_job_info、kube_job_created，都是一个FamilyGenerator实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">metrics.FamilyGenerator&#123;</span><br><span class="line">            Name: <span class="string">"kube_job_info"</span>,</span><br><span class="line">            Type: metrics.MetricTypeGauge,</span><br><span class="line">            Help: <span class="string">"Information about job."</span>,</span><br><span class="line">            GenerateFunc: wrapJobFunc(<span class="function"><span class="keyword">func</span><span class="params">(j *v1batch.Job)</span> <span class="title">metrics</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">                <span class="keyword">return</span> metrics.Family&#123;&amp;metrics.Metric&#123;</span><br><span class="line">                    Name:  <span class="string">"kube_job_info"</span>,</span><br><span class="line">                    Value: <span class="number">1</span>,</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">buildCronJobCollector</span><span class="params">()</span> *<span class="title">Collector</span></span> &#123;</span><br><span class="line">   <span class="comment">// 过滤传入的白名单</span></span><br><span class="line">    filteredMetricFamilies := filterMetricFamilies(b.whiteBlackList, cronJobMetricFamilies)</span><br><span class="line">    composedMetricGenFuncs := composeMetricGenFuncs(filteredMetricFamilies)</span><br><span class="line">  <span class="comment">// 将参数写到header中</span></span><br><span class="line">    familyHeaders := extractMetricFamilyHeaders(filteredMetricFamilies)</span><br><span class="line">  <span class="comment">// NewMetricsStore实现了client-go的cache.Store接口，实现本地缓存。</span></span><br><span class="line">    store := metricsstore.NewMetricsStore(</span><br><span class="line">        familyHeaders,</span><br><span class="line">        composedMetricGenFuncs,</span><br><span class="line">    )</span><br><span class="line">  <span class="comment">// 按namespace构建Reflector，监听变化</span></span><br><span class="line">    reflectorPerNamespace(b.ctx, b.kubeClient, &amp;batchv1beta1.CronJob&#123;&#125;, store, b.namespaces, createCronJobListWatch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewCollector(store)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能优化：</p><p>kube-state-metrics在之前的版本中暴露出两个问题：</p><ul><li><ol><li>/metrics接口响应慢(10-20s)</li></ol></li><li><ol><li>内存消耗太大，导致超出limit被杀掉</li></ol></li></ul><p>问题一的方案就是基于client-go的cache tool实现本地缓存，具体结构为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cache = map[<span class="string">uuid</span>][<span class="symbol"></span>]byte&#123;&#125;</span><br></pre></td></tr></table></figure><p>问题二的的方案是：对于时间序列的字符串，是存在很多重复字符的（如namespace等前缀筛选），可以用指针或者结构化这些重复字符。</p><h2 id="优化点和问题"><a href="#优化点和问题" class="headerlink" title="优化点和问题"></a>优化点和问题</h2><ul><li>因为kube-state-metrics是监听资源的add、delete、update事件，那么在kube-state-metrics部署之前已经运行的资源，岂不是拿不到数据？kube-state-metric利用client-go可以初始化所有已经存在的资源对象，确保没有任何遗漏</li><li>kube-state-metrics当前不会输出metadata信息(如help和description）</li><li>缓存实现是基于golang的map，解决并发读问题当期是用了一个简单的互斥锁，应该可以解决问题，后续会考虑golang的sync.Map安全map。</li><li>kube-state-metrics通过比较resource version来保证event的顺序</li><li>kube-state-metrics并不保证包含所有资源</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/kube-state-metrics" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kube-state-metrics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经有了cadvisor、heapster、metric-server，几乎容器运行的所有指标都能拿到，但是下面这种情况却无能为力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我调度了多少个replicas？现在可用的有几个？&lt;/li&gt;
&lt;li&gt;多少个Pod是running/stopped/terminated状态？&lt;/li&gt;
&lt;li&gt;Pod重启了多少次？&lt;/li&gt;
&lt;li&gt;我有多少job在运行中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些则是kube-state-metrics提供的内容，它基于client-go开发，轮询Kubernetes API，并将Kubernetes的结构化信息转换为metrics。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-15_kube-state-metrics.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】Metrics Server</title>
    <link href="http://houmin.cc/posts/913a8837/"/>
    <id>http://houmin.cc/posts/913a8837/</id>
    <published>2020-09-15T03:39:59.000Z</published>
    <updated>2020-11-18T12:12:58.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>从 v1.8 开始，资源使用情况的监控可以通过 Metrics API的形式获取，具体的组件为Metrics Server，用来替换之前的 heapster，heapster从1.11开始逐渐被废弃。</p><p>Metrics-Server是集群核心监控数据的聚合器，从 Kubernetes1.8 开始，它作为一个 Deployment对象默认部署在由kube-up.sh脚本创建的集群中，如果是其他部署方式需要单独安装，或者咨询对应的云厂商。</p><a id="more"></a><h2 id="Metrics-API"><a href="#Metrics-API" class="headerlink" title="Metrics API"></a>Metrics API</h2><p>介绍Metrics-Server之前，必须要提一下Metrics API的概念</p><p>Metrics API相比于之前的监控采集方式(hepaster)是一种新的思路，官方希望核心指标的监控应该是稳定的，版本可控的，且可以直接被用户访问(例如通过使用 kubectl top 命令)，或由集群中的控制器使用(如HPA)，和其他的Kubernetes APIs一样。</p><p>官方废弃heapster项目，就是为了将核心资源监控作为一等公民对待，即像pod、service那样直接通过api-server或者client直接访问，不再是安装一个hepater来汇聚且由heapster单独管理。</p><p>假设每个pod和node我们收集10个指标，从k8s的1.6开始，支持5000节点，每个节点30个pod，假设采集粒度为1分钟一次，则：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">10 </span>x <span class="number">5000</span> x <span class="number">30</span> / <span class="number">60</span> = <span class="number">25000</span> 平均每分钟<span class="number">2</span>万多个采集指标</span><br></pre></td></tr></table></figure><p>因为k8s的api-server将所有的数据持久化到了etcd中，显然k8s本身不能处理这种频率的采集，而且这种监控数据变化快且都是临时数据，因此需要有一个组件单独处理他们，k8s版本只存放部分在内存中，于是metric-server的概念诞生了。</p><p>其实hepaster已经有暴露了api，但是用户和Kubernetes的其他组件必须通过master proxy的方式才能访问到，且heapster的接口不像api-server一样，有完整的鉴权以及client集成。这个api现在还在alpha阶段（18年8月），希望能到GA阶段。类api-server风格的写法：<a href="https://github.com/kubernetes/apiserver" target="_blank" rel="external nofollow noopener noreferrer">generic apiserver</a></p><p>有了Metrics Server组件，也采集到了该有的数据，也暴露了api，但因为api要统一，如何将请求到api-server的<code>/apis/metrics</code>请求转发给Metrics Server呢，解决方案就是：<a href="https://github.com/kubernetes/kube-aggregator" target="_blank" rel="external nofollow noopener noreferrer">kube-aggregator</a>,在k8s的1.7中已经完成，之前Metrics Server一直没有面世，就是耽误在了kube-aggregator这一步。</p><p>kube-aggregator（聚合api）主要提供：</p><ul><li>Provide an API for registering API servers.</li><li>Summarize discovery information from all the servers.</li><li>Proxy client requests to individual servers.</li></ul><p>详细设计文档：<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p>metric api的使用：</p><ul><li>Metrics API 只可以查询当前的度量数据，并不保存历史数据</li><li>Metrics API URI 为 /apis/metrics.k8s.io/，在 k8s.io/metrics 维护</li><li>必须部署 metrics-server 才能使用该 API，metrics-server 通过调用 Kubelet Summary API 获取数据</li></ul><p>如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/nodes</span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/nodes/&lt;node-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/namespace/&lt;namespace-name&gt;<span class="regexp">/pods/</span>&lt;pod-name&gt;</span><br></pre></td></tr></table></figure><h2 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics-Server"></a>Metrics-Server</h2><p>Metrics server定时从Kubelet的Summary API(类似/ap1/v1/nodes/nodename/stats/summary)采集指标信息，这些聚合过的数据将存储在内存中，且以metric-api的形式暴露出去。</p><p>Metrics server复用了api-server的库来实现自己的功能，比如鉴权、版本等，为了实现将数据存放在内存中吗，去掉了默认的etcd存储，引入了内存存储（即实现<a href="https://github.com/kubernetes/apiserver/blob/master/pkg/registry/rest/rest.go" target="_blank" rel="external nofollow noopener noreferrer">Storage interface</a>)。因为存放在内存中，因此监控数据是没有持久化的，可以通过第三方存储来拓展，这个和heapster是一致的。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png"></p><p>Metrics server出现后，新的Kubernetes 监控架构将变成上图的样子</p><ul><li>核心流程（黑色部分）：这是 Kubernetes正常工作所需要的核心度量，从 Kubelet、cAdvisor 等获取度量数据，再由metrics-server提供给 Dashboard、HPA 控制器等使用。</li><li>监控流程（蓝色部分）：基于核心度量构建的监控流程，比如 Prometheus 可以从 metrics-server 获取核心度量，从其他数据源（如 Node Exporter 等）获取非核心度量，再基于它们构建监控告警系统。</li></ul><p>官方地址：<a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/metrics-server</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如上文提到的，metric-server是扩展的apiserver，依赖于kube-aggregator，因此需要在apiserver中开启相关参数。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--requestheader-client-ca-file</span>=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line"><span class="attr">--proxy-client-cert-file</span>=/etc/kubernetes/certs/proxy.crt</span><br><span class="line"><span class="attr">--proxy-client-key-file</span>=/etc/kubernetes/certs/proxy.key</span><br><span class="line"><span class="attr">--requestheader-allowed-names</span>=aggregator</span><br><span class="line"><span class="attr">--requestheader-extra-headers-prefix</span>=X-Remote-Extra-</span><br><span class="line"><span class="attr">--requestheader-group-headers</span>=X-Remote-Group</span><br><span class="line"><span class="attr">--requestheader-username-headers</span>=X-Remote-User</span><br></pre></td></tr></table></figure><p>安装文件下载地址：<a href="https://github.com/kubernetes-incubator/metrics-server/tree/master/deploy/1.8%2B" target="_blank" rel="external nofollow noopener noreferrer">1.8+</a>，注意更换镜像地址为国内镜像</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> -f metric-<span class="keyword">server</span>/</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/15473067971765.jpg"></p><p>安装成功后，访问地址api地址为：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/15473069387068.jpg"></p><p>Metrics Server的资源占用量会随着集群中的Pod数量的不断增长而不断上升，因此需要 addon-resizer垂直扩缩这个容器。addon-resizer依据集群中节点的数量线性地扩展Metrics Server，以保证其能够有能力提供完整的metrics API服务。具体参考：<a href="https://github.com/kubernetes/autoscaler/tree/master/addon-resizer" target="_blank" rel="external nofollow noopener noreferrer">链接</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>基于Metrics Server的HPA：<a href="http://blog.51cto.com/ylw6006/2115087" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p>kubernetes的新监控体系中，metrics-server属于Core metrics(核心指标)，提供API metrics.k8s.io，仅提供Node和Pod的CPU和内存使用情况。而其他Custom Metrics(自定义指标)由Prometheus等组件来完成，后续文章将对自定义指标进行解析。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/metrics-server</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 v1.8 开始，资源使用情况的监控可以通过 Metrics API的形式获取，具体的组件为Metrics Server，用来替换之前的 heapster，heapster从1.11开始逐渐被废弃。&lt;/p&gt;
&lt;p&gt;Metrics-Server是集群核心监控数据的聚合器，从 Kubernetes1.8 开始，它作为一个 Deployment对象默认部署在由kube-up.sh脚本创建的集群中，如果是其他部署方式需要单独安装，或者咨询对应的云厂商。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>【系统监控】cAdvisor</title>
    <link href="http://houmin.cc/posts/703a5727/"/>
    <id>http://houmin.cc/posts/703a5727/</id>
    <published>2020-09-15T02:10:58.000Z</published>
    <updated>2020-11-18T12:12:47.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>cAdvisor</code>即 <code>container advisor</code>，是Google为了对Node机器上的资源及容器进行实时监控和性能数据采集提出的开源解决方还提供基础查询界面和http接口，方便其他组件如Prometheus进行数据抓取，或者cadvisor + influxdb + grafna搭配使用。cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。cAdvisor使用Go语言开发，利用Linux的cgroups获取容器的资源使用信息，在 kubernetes 中集成在 kubelet 里作为默认启动项。</p><a id="more"></a><h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cadvisor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">google/cadvisor:v0.33.0</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rootfs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/rootfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/sys</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--housekeeping_interval=10s</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--disable_metrics=disk</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rootfs</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var-run</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/sys</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker</span></span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cadvisor.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">cadvisor</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">cadvisor</span></span><br></pre></td></tr></table></figure><p>在本地设置好 hosts 之后，访问 <code>http://cadvisor.houmin:&lt;TraefikNode&gt;/</code> 即可看到 <code>cAdvisor</code> 的界面。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_cadvisor.png"></p><h3 id="与-Prometheus-集成"><a href="#与-Prometheus-集成" class="headerlink" title="与 Prometheus 集成"></a>与 Prometheus 集成</h3><p>Step1: 修改 Prometheus 配置信息，添加 cadvisor 访问地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prometheus.yml</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['node-exporter:9100']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'container'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['cadvisor:8080']</span>  <span class="comment"># 本地 cadvisor 访问地址</span></span><br></pre></td></tr></table></figure><p>重新加载 Prometheus 配置，访问 <code>http://prometheus.houmin:30869/targets</code> 可以看到新加的 cAdvisor 已经生效。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor.png"></p><p>此时访问 Prometheus 的 graph 页面 <code>http://prometheus.houmin:30869/graph</code>，搜索 <code>container</code> 你将看到容器相关数据。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-graph.png"></p><p>在 Prometheus 中查看集群内存使用量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by (name)(container_memory_usage_bytes&#123;image!=""&#125;)</span><br></pre></td></tr></table></figure><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-memory.png"></p><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><div class="table-container"><table><thead><tr><th>分类</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>cpu</td><td>cpu_usage_total</td><td></td></tr><tr><td></td><td>cpu_usage_system</td><td></td></tr><tr><td></td><td>cpu_usage_user</td><td></td></tr><tr><td></td><td>cpu_usage_per_cpu</td><td></td></tr><tr><td></td><td>load_average</td><td>Smoothed average of number of runnable threads x 1000</td></tr><tr><td>memory</td><td>memory_usage</td><td>Memory Usage</td></tr><tr><td></td><td>memory_working_set</td><td>Working set size</td></tr><tr><td>network</td><td>rx_bytes</td><td>Cumulative count of bytes received</td></tr><tr><td></td><td>rx_errors</td><td>Cumulative count of receive errors encountered</td></tr><tr><td></td><td>tx_bytes</td><td>Cumulative count of bytes transmitted</td></tr><tr><td></td><td>tx_errors</td><td>Cumulative count of transmit errors encountered</td></tr><tr><td>filesystem</td><td>fs_device</td><td>Filesystem device</td></tr><tr><td></td><td>fs_limit</td><td>Filesystem limit</td></tr><tr><td></td><td>fs_usage</td><td>Filesystem usage</td></tr></tbody></table></div><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/5a577e4d0a5da14b7b634b5c62264f72.png"></p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> glog.Flush()</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> *versionFlag &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"cAdvisor version %s (%s)/n"</span>, version.Info[<span class="string">"version"</span>], version.Info[<span class="string">"revision"</span>])</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    setMaxProcs()</span><br><span class="line">    memoryStorage, err := NewMemoryStorage()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to initialize storage driver: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    sysFs, err := sysfs.NewRealSysFs()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to create a system interface: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)</span><br><span class="line">    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to create a Container Manager: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    <span class="keyword">if</span> *enableProfiling &#123;</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register all HTTP handlers.</span></span><br><span class="line">    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to register HTTP handlers: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// Start the manager.</span></span><br><span class="line">    <span class="keyword">if</span> err := containerManager.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to start container manager: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Install signal handler.</span></span><br><span class="line">    installSignalHandler(containerManager)</span><br><span class="line">    glog.Infof(<span class="string">"Starting cAdvisor version: %s-%s on port %d"</span>, version.Info[<span class="string">"version"</span>], version.Info[<span class="string">"revision"</span>], *argPort)</span><br><span class="line">    addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, *argIp, *argPort)</span><br><span class="line">    glog.Fatal(http.ListenAndServe(addr, mux))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过new出来的memoryStorage以及sysfs实例，创建一个manager实例，manager的interface中定义了许多用于获取容器和machine信息的函数。核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memoryStorage, err := NewMemoryStorage()</span><br><span class="line">sysFs, err := sysfs.NewRealSysFs()</span><br><span class="line">#创建containerManager</span><br><span class="line">containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</span><br><span class="line">#启动containerManager</span><br><span class="line">err := containerManager.Start()</span><br></pre></td></tr></table></figure><p>核心函数：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/9c27a63d31346f4e6dc592e71977d568.png"></p><p>生成manager实例的时候，还需要传递两个额外的参数，分别是</p><ul><li>maxHousekeepingInterval：存在内存的时间，默认60s</li><li>allowDynamicHousekeeping：是否允许动态配置housekeeping，也就是下一次开始搜集容器信息的时间，默认true</li></ul><p>因为需要暴露服务，所以在handler文件中，将上面生成的containerManager注册进去（cadvisor/http/handler.go)，之后就是启动manager，运行其Start方法，开始搜集信息，存储信息的循环操作。</p><p>以memory采集为例：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/197e5adaba371a4000ef9fd087dbf987.png"></p><p>具体的信息还是通过runc/libcontainer获得，libcontainer是对cgroup的封装。在/sys/fs/cgroup/memory中包含大量的了memory相关的信息（参考docker原生监控文章）</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/8d1b0d821546002af20648d131858457.png"></p><p>Prometheus的收集器（cadvisor/metrics/prometheus.go）</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/10f40e80b299ff5df8a99acca63c2644.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优缺点：</p><ul><li>优点：谷歌开源产品，监控指标齐全，部署方便，而且有官方的docker镜像。</li><li>缺点：是集成度不高，默认只在本地保存1分钟数据，但可以集成InfluxDB等存储</li></ul><p>备注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">爱奇艺参照cadvisor开发的dadvisor，数据写入graphite，</span><br><span class="line">等同于cadvisor+influxdb，但dadvisor并没有开源</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://luoji.live/categories/cadvisor/" target="_blank" rel="external nofollow noopener noreferrer">https://luoji.live/categories/cadvisor/</a></li><li><a href="https://github.com/google/cadvisor" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/google/cadvisor</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;cAdvisor&lt;/code&gt;即 &lt;code&gt;container advisor&lt;/code&gt;，是Google为了对Node机器上的资源及容器进行实时监控和性能数据采集提出的开源解决方还提供基础查询界面和http接口，方便其他组件如Prometheus进行数据抓取，或者cadvisor + influxdb + grafna搭配使用。cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。cAdvisor使用Go语言开发，利用Linux的cgroups获取容器的资源使用信息，在 kubernetes 中集成在 kubelet 里作为默认启动项。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-15_cadvisor.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="cadvisor" scheme="http://houmin.cc/tags/cadvisor/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】监控的可观测性</title>
    <link href="http://houmin.cc/posts/58272b06/"/>
    <id>http://houmin.cc/posts/58272b06/</id>
    <published>2020-09-15T01:15:58.000Z</published>
    <updated>2020-09-17T07:57:02.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>监控是大型分布式系统的重要基础设施，可以帮助开发者查看系统的运行状态。</p><a id="more"></a><h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><h3 id="监控类型"><a href="#监控类型" class="headerlink" title="监控类型"></a>监控类型</h3><ul><li>资源监控：监控CPU、内存、网络等资源的指标</li><li>性能监控：APM（Application Performance Monitoring）监控</li><li>安全监控：对越权管理、安全漏洞扫描等监控</li><li>事件监控：对k8s中的事件监控</li></ul><h3 id="资源指标"><a href="#资源指标" class="headerlink" title="资源指标"></a>资源指标</h3><p>对于kubernetes集群进行监控，主要可以分为两类：</p><ul><li>监控集群本身</li><li>监控Pod对象</li></ul><p>对于集群本身的监控主要包括：</p><ul><li>节点资源状态：主要包括网络带宽、磁盘空间、CPU和内存使用率</li><li>节点的数量：即时性了解集群的可用节点数量可以为用户计算服务器使用的费用支出提供参考</li><li>运行的Pod对象：正在运行的Pod对象数量可以评估可用节点数量是否足够，以及节点故障时是否能平衡负载。</li></ul><p>对于Pod资源的监控主要分为以下三类：</p><ul><li>Kubernetes指标：监测特定应用相关的Pod对象的部署过程、副本数量、状态信息、健康状态、网络使用等</li><li>容器级指标：容器的Resource Request、Resource Limit、CPU、内存、磁盘空间、网络带宽的实际占用情况</li><li>应用级指标：应用自身的内建指标，和业务规则相关</li></ul><h2 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h2><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="Docker-Stats"><a href="#Docker-Stats" class="headerlink" title="Docker Stats"></a>Docker Stats</h3><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_cadvisor.png"></p><h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><h3 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png"></p><h3 id="Kube-State-Metrics"><a href="#Kube-State-Metrics" class="headerlink" title="Kube-State-Metrics"></a>Kube-State-Metrics</h3><h3 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node-Exporter"></a>Node-Exporter</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p><img alt="Prometheus" data-src="https://cdn.nlark.com/lark/0/2018/png/25353/1537426329901-660f59fd-12eb-441c-a637-28467b6447ff.png"></p><h2 id="展示与报警"><a href="#展示与报警" class="headerlink" title="展示与报警"></a>展示与报警</h2><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><h3 id="Zabbix-Dashboard"><a href="#Zabbix-Dashboard" class="headerlink" title="Zabbix Dashboard"></a>Zabbix Dashboard</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/monitoring_architecture.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes monitoring architecture</a></li><li><a href="https://yasongxu.gitbook.io/container-monitor" target="_blank" rel="external nofollow noopener noreferrer">https://yasongxu.gitbook.io/container-monitor</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监控是大型分布式系统的重要基础设施，可以帮助开发者查看系统的运行状态。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="container" scheme="http://houmin.cc/tags/container/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="cAdvisor" scheme="http://houmin.cc/tags/cAdvisor/"/>
    
      <category term="Prometheus" scheme="http://houmin.cc/tags/Prometheus/"/>
    
      <category term="metrics" scheme="http://houmin.cc/tags/metrics/"/>
    
      <category term="observability" scheme="http://houmin.cc/tags/observability/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】CRD</title>
    <link href="http://houmin.cc/posts/c57d800c/"/>
    <id>http://houmin.cc/posts/c57d800c/</id>
    <published>2020-09-12T06:23:18.000Z</published>
    <updated>2020-11-06T03:06:46.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在 <a href="https://houmin.cc/tags/controller">Controller Manager 的系列文章</a> 中我们看到，Kubernetes 内置的各种 Controller 通过ApiServer监控 <a href="https://houmin.cc">Deployment</a>、<a href="https://houmin.cc">DaemonSet</a>、<a href="https://houmin.cc">StatefulSet </a>等内部资源对象，在一个控制循环中通过各种操作将系统维持在我们期望的一个状态中，这即是其经典的 <code>声明式API设计</code>。然而，内置的API资源大多仅代表相对底层和通用概念的对象，已经不能够满足越来越复杂的业务场景需求。随着Kubernetes生态系统的持续发展，我们将需要更多高层次的面向专门的场景的对象。在声明式API的原则下，设计自定义资源API，开发者将不需要逐一进行 Deployment、Service、ConfigMap 等步骤，而是创建并关联一些用于表述整个应用程序或者软件服务的对象。在当前，CoreOS推出的各种 <a href="https://coreos.com/operators/" target="_blank" rel="external nofollow noopener noreferrer">Operator</a> 即是这一思想的广泛利用。为了实现 Operator，你需要了解 <code>CRD（CustomResourceDefinitions）</code>。本文所有实现的代码，可以参考我的 <a href="https://github.com/SimpCosm/crddemo" target="_blank" rel="external nofollow noopener noreferrer">Github</a>。</p><a id="more"></a><h2 id="CRD使用方法"><a href="#CRD使用方法" class="headerlink" title="CRD使用方法"></a>CRD使用方法</h2><p>在 <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="external nofollow noopener noreferrer">Extend the Kubernetes API with CustomResourceDefinitions</a> 中介绍了使用CRD扩展Kubernetes API的详细用法，简单来说可以分为两步：</p><ul><li>利用CRD API声明自定义的资源API</li><li>根据刚才声明的资源API，创建自定义的资源对象</li></ul><h3 id="Create-CustomResourceDefinition"><a href="#Create-CustomResourceDefinition" class="headerlink" title="Create CustomResourceDefinition"></a>Create CustomResourceDefinition</h3><p>首先我们可以使用 <code>CustomResourceDefinition</code> 声明自定义的资源API，这里也可以将我们自定义的资源API理解为  <code>CustomResourceDefinition</code> 这个API的对象，我们可以指定它的 <code>metadata.name</code>。这里没有 <code>metadata.namespace</code>字段，是因为<code>CustomResourceDefinition</code> 适用于所有命名空间。</p><p>CRD定义中的关键字段如下：</p><ul><li>group：设置API所属的组，将其映射为API URL中的 “/apis/” 下一级目录。它是逻辑上相关的Kinds集合</li><li>scope：该API的生效范围，可选项为Namespaced和Cluster。</li><li>version：每个 Group 可以存在多个版本。例如，v1alpha1，然后升为 v1beta1，最后稳定为 v1 版本。</li><li>names：CRD的名称，包括单数、复数、kind、所属组等名称定义</li></ul><p><img alt="api url" data-src="https://lihaoquan.me/media/2020/202003081.png"></p><p>在下面的示例中，我们定义资源的Group是<code>example.houmin.cc</code>，version是v1，kind是Foo。这里的version是一个list，可以指定多个服务的版本，这里只是简单声明了v1这个版本，具体可以参考 <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="external nofollow noopener noreferrer">Extend the Kubernetes API with CustomResourceDefinitions</a> 和 <a href="https://github.com/kubernetes/apiextensions-apiserver/blob/cec7d1c927364a42e97ab2b400d5f15a953ab84d/pkg/apis/apiextensions/v1/types.go#L59" target="_blank" rel="external nofollow noopener noreferrer">源代码</a>。</p><figure class="highlight yaml"><figcaption><span>crd.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foos.example.houmin.cc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">example.houmin.cc</span></span><br><span class="line">  <span class="comment"># list of versions supported by this CustomResourceDefinition</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="comment"># kind is normally the CamelCased singular type. Your resource manifests use this.</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line">    <span class="comment"># plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</span></span><br><span class="line">    <span class="attr">plural:</span> <span class="string">foos</span></span><br><span class="line">    <span class="comment"># singular name to be used as an alias on the CLI and for display</span></span><br><span class="line">    <span class="attr">singular:</span> <span class="string">foo</span></span><br><span class="line">    <span class="comment"># shortNames allow shorter string to match your resource on the CLI</span></span><br><span class="line">    <span class="attr">shortNames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">fo</span></span><br><span class="line">  <span class="comment"># either Namespaced or Cluster</span></span><br><span class="line">  <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br></pre></td></tr></table></figure><p>根据上面的manifest文件，即可创建CRD。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl create -f crd.yaml</span></span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/foos.example.houmin.cc created</span><br></pre></td></tr></table></figure><h3 id="Create-custom-objects"><a href="#Create-custom-objects" class="headerlink" title="Create custom objects"></a>Create custom objects</h3><p>在声明了自定义资源后，就可以编辑下面这样的manifest文件，创建用户自定义资源的对象，就像 <code>Pod</code>等原生资源一样。</p><figure class="highlight yaml"><figcaption><span>example-foo.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.houmin.cc/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">deploymentName:</span> <span class="string">example-foo</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这里的 <code>deploymentName</code> 和 <code>replicas</code> 都是我们自定义资源API的字段，在后面会详细介绍。使用kubectl创建资源后，我们发现CRD的使用和原生API资源毫无区别。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f example-foo.yaml</span></span><br><span class="line"><span class="string">foo.example.houmin.cc/example-foo</span> <span class="string">created</span></span><br><span class="line"><span class="comment"># kubectl get foo</span></span><br><span class="line"><span class="string">NAME</span>          <span class="string">AGE</span></span><br><span class="line"><span class="string">example-foo</span>   <span class="string">8s</span></span><br><span class="line"><span class="comment"># kubectl get foo -o yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">example.houmin.cc/v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">creationTimestamp:</span> <span class="string">"2020-10-27T13:32:15Z"</span></span><br><span class="line">    <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">example-foo</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">resourceVersion:</span> <span class="string">"294744500"</span></span><br><span class="line">    <span class="attr">selfLink:</span> <span class="string">/apis/example.houmin.cc/v1/namespaces/default/foos/example-foo</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">ece2daac-5510-4de1-b924-c8b1a5e178fd</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">deploymentName:</span> <span class="string">example-foo</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">List</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p>经过上面的两步操作，我们已经能够自定义资源API并且使用它了。但是，在第一步和第二步之间还需要做一些工作，不然直接创建自定义资源对象是不会成功的。为什么呢？想一想，对于原生的资源API，比如Deployment，我们都有对应的Controller在 ApiServer 监听每一个Deployment 资源的创建，并随之创建对应的Pod和维护其状态。对于我们创建的CRD资源，我们也需要有对应的Controller做类似的工作。</p><p>另外，刚才提到我们创建的 <code>Foo</code>资源具有两个字段 <code>deploymentName</code> 和 <code>replicas</code>，这个都是我们自定义的，你也可以根据你的需要定义你自己的字段。每次创建 <code>Foo</code> 对象后，我们实现的 Controller 就会根据自己的逻辑去做自己的事情，比如这里就是维护 <code>replicas</code> 个 <code>deployment</code>，具体的工作流程如下图所示。</p><p><img alt="crd arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p><p>CRD控制器的工作流，可分为监听、同步、触发三个步骤：</p><ul><li>Controller 首先会通过 Informer 从 API Server中获取它所关心的对象，这里就是上面的Foo对象。<ul><li>值得注意的是Informer在构建之前，会使用我们生成的client（下面编码阶段会提到）,再透过Reflector的ListAndWatch机制跟API Server建立连接，不断地监听 Foo 对象实例的变化。</li><li>在 ListAndWatch 机制下，一旦 APIServer 端有新的 Foo 实例被创建、删除或者更新，Reflector 都会收到 <strong>事件通知</strong>。</li><li>该事件及它对应的 API 对象会被放进一个 Delta FIFO Queue中。</li></ul></li><li>Local Store 此时完成同步缓存操作</li><li>Informer 根据这些事件的类型，触发我们编写并注册好的ResourceEventHandler，完成业务动作的触发。</li></ul><p>上面图中的 Control Loop 实际上可以通过code-generator生成，下面也会提到。总之Control Loop中我们只关心如何拿到 <strong>Current State</strong>，并与 <strong>Desired State</strong> 对比，从而具体的差异处理逻辑，只需要开发者自行编写即可。</p><h2 id="定义CRD资源"><a href="#定义CRD资源" class="headerlink" title="定义CRD资源"></a>定义CRD资源</h2><p>首先，kubernetes涉及的代码生成对项目目录结构是有要求的，所以我们先创建一个结构如下的项目，可见关键在于pkg目录就是API组的URL结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── artifacts</span><br><span class="line">│   └── examples</span><br><span class="line">│       ├── crd.yaml</span><br><span class="line">│       └── example-foo.yaml</span><br><span class="line">├── controller.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">├── main.go</span><br><span class="line">└── pkg</span><br><span class="line">    └── apis</span><br><span class="line">        └── example</span><br><span class="line">            ├── register.go</span><br><span class="line">            └── v1</span><br><span class="line">                ├── doc.go</span><br><span class="line">                ├── register.go</span><br><span class="line">                └── types.go</span><br></pre></td></tr></table></figure><ol><li>我们首先开看 <code>pkg/apis/example/register.go</code>，这个文件主要用来存放全局变量，如下：</li></ol><figure class="highlight go"><figcaption><span>pkg/apis/example/register.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">GroupName = <span class="string">"example.houmin.cc"</span></span><br><span class="line">Version   = <span class="string">"v1"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><code>pkg/apis/example/v1/doc.go</code>  主要是 <code>global tags</code>，起到的是全局的代码生成控制的作用，详见代码生成解释。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"><span class="comment">// +groupName=example.houmin.cc</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure><ol><li><code>pkg/apis/example/v1/types</code> 的作用就是定义一个 Foo 类型到底有哪些字段（比如，spec 字段里的内容）。这个文件的主要内容如下所示：</li></ol><figure class="highlight go"><figcaption><span>pkg/apis/example/v1/types</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">Spec   FooSpec   <span class="string">`json:"spec"`</span></span><br><span class="line">Status FooStatus <span class="string">`json:"status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooSpec is the spec for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">DeploymentName <span class="keyword">string</span> <span class="string">`json:"deploymentName"`</span></span><br><span class="line">Replicas       *<span class="keyword">int32</span> <span class="string">`json:"replicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooStatus is the status for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">AvailableReplicas <span class="keyword">int32</span> <span class="string">`json:"availableReplicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooList <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">metav1.ListMeta <span class="string">`json:"metadata"`</span></span><br><span class="line"></span><br><span class="line">Items []Foo <span class="string">`json:"items"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，可以看到我们的<code>Foo</code>定义方法跟k8s对象一样，都包含了 <code>TypeMeta</code> 和 <code>ObjectMeta</code>字段，而其中比较重要的是 <code>Spec</code> 字段和 <code>Status</code> 字段，这个可以根据用户需要自定义。</p><p>此外，除了定义 <code>Foo</code> 类型，你还需要定义一个 <code>FooList</code> 类型，用来描述一组 <code>Foo</code> 对象应该包括哪些字段。之所以需要这样一个类型，是因为在 Kubernetes 中，获取所有某对象的 List() 方法，返回值都是List 类型，而不是某类型的数组。所以代码上一定要做区分</p><p>除此之外，还有几个作为 <code>local tags</code> 存在的注释，主要用于控制代码生成，详见下一小节。</p><ol><li><code>pkg/apis/example/register.go</code> 作用就是注册一个类型（Type）给 APIServer。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/SimpCosm/crddemo/pkg/apis/example"</span></span><br><span class="line"></span><br><span class="line">metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line"><span class="string">"k8s.io/apimachinery/pkg/runtime"</span></span><br><span class="line"><span class="string">"k8s.io/apimachinery/pkg/runtime/schema"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;</span><br><span class="line">Group:   example.GroupName,</span><br><span class="line">Version: example.Version,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">AddToScheme   = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupResource</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Kind</span><span class="params">(kind <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupKind</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">scheme.AddKnownTypes(</span><br><span class="line">SchemeGroupVersion,</span><br><span class="line">&amp;Foo&#123;&#125;,</span><br><span class="line">&amp;FooList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the type in the scheme</span></span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>addKnownTypes</code> 这个方法，Kubernetes 就能够在后面生成客户端的时候，知道 <code>Foo</code> 以及<code>FooList</code> 类型的定义了。</p><p>好了，到这里为止，我们有关定义的代码已经写好了，正如controller原理图所示，接下来我们需要通过kubernetes提供的代码生成工具，为上面的<code>Foo</code>资源类型生成clientset、informer 和 lister。</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>kubernetes社区有一个<a href="https://github.com/kubernetes/code-generator" target="_blank" rel="external nofollow noopener noreferrer">k8s.io/code-generator</a> 仓库，在里面提供了一系列代码生成工具：</p><ul><li><code>deepcopy-gen</code>：为每个类型T创建了 <code>func (t *T) DeepCopy() *T</code>方法</li><li><code>client-gen</code>：为CustomeResource APIGroups 创建 typed clientsets</li><li><code>informer-gen</code>：为CustomResource创建informers，能够监听到服务端CustomResource发生变化的事件</li><li><code>lister-gen</code>：为CustomResource创建listers，能够为GET/LIST请求提供一个read only的Caching Layer</li></ul><p>其中生成的 informer 和 lister 是创建Controller的基础，通过这四个generator就可以创建一个 <code>full-featured, producation-ready</code>的controller。除此之外，<code>code-generator</code>还提供了其他的生成工具，比如 <code>conversion-gen</code> 提供了API内部版本和外部版本的转换函数，<code>defaulter-gen</code>提供了产生默认的字段的工具。</p><p>所有的这些code-generator都是基于<a href="https://github.com/kubernetes/gengo" target="_blank" rel="external nofollow noopener noreferrer">k8s.io/gengo</a>实现的，他们有一些共同的命令行参数，比如 <code>--input-dirs</code> 获得input package，<code>--output-package</code> 指定生成的package的目录。但是我们不需要去一个一个指定各个命令行参数， <a href="https://github.com/kubernetes/code-generator" target="_blank" rel="external nofollow noopener noreferrer">k8s.io/code-generator</a> 提供了一个Shell脚本 <a href="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh" target="_blank" rel="external nofollow noopener noreferrer">generator-group.sh</a> 来便于在CRD开发过程中的代码生成。只需一行代码，通常在 <code>hack/update-codegen.sh</code>中即可调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vendor/k8s.io/code-generator/generate-groups.sh all \ <span class="comment"># GENS="$1"</span></span><br><span class="line">github.com/SimpCosm/crddemo/pkg/client \ <span class="comment"># OUTPUT_PKG="$2"</span></span><br><span class="line">github.com/SimpCosm/crddemo/pkg/apis \   <span class="comment"># APIS_PKG="$3"</span></span><br><span class="line">example.houmin.cc:v1 <span class="comment"># GROUPS_WITH_VERSIONS="$4"</span></span><br></pre></td></tr></table></figure><p>执行命令后，可以看到 <code>pkg</code> 下代码生成如下，在 <code>pkg/apis</code>目录下，除了原有的代码，生成了 <code>zz_generated_deepcopy.go</code> 的代码， <code>pkg/client</code> 目录则是完全生成的，包括 <code>clientset</code>、<code>informers</code>、<code>listers</code>等代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pkg</span><br><span class="line">├── apis</span><br><span class="line">│   └── example</span><br><span class="line">│       ├── register.go</span><br><span class="line">│       └── v1</span><br><span class="line">│           ├── doc.go</span><br><span class="line">│           ├── register.go</span><br><span class="line">│           ├── types.go</span><br><span class="line">│           └── zz_generated.deepcopy.go</span><br><span class="line">└── client</span><br><span class="line">    ├── clientset</span><br><span class="line">    │   └── versioned</span><br><span class="line">    │       ├── clientset.go</span><br><span class="line">    │       ├── doc.go</span><br><span class="line">    │       ├── fake</span><br><span class="line">    │       ├── scheme</span><br><span class="line">    │       └── typed</span><br><span class="line">    ├── informers</span><br><span class="line">    │   └── externalversions</span><br><span class="line">    │       ├── example</span><br><span class="line">    │       ├── factory.go</span><br><span class="line">    │       ├── generic.go</span><br><span class="line">    │       └── internalinterfaces</span><br><span class="line">    └── listers</span><br><span class="line">        └── example</span><br><span class="line">            └── v1</span><br></pre></td></tr></table></figure><p>这些生成的代码都是不允许手动修改的，一般你需要修改 <code>pkg/apis</code>下面的源码后，再去通过执行 <code>hack/update-codegen.sh</code> 来生成新的代码。</p><p>我们可以通过 <code>code-generator</code> 来控制代码生成的一些参数，但是代码生成更多的属性是通过Go代码中的Tags来控制。这里有两种类型的Tag：</p><ul><li>Global Tags：全局Tags，在 <code>doc.go</code> 中位于 <code>package</code>之上</li><li>Local Tags：局部Tags</li></ul><p>Tags一般的形式是 <code>// +tag-name</code> 或者 <code>// +tag-name=value</code>，以注释的形式存在。一般来说，Tags存在的位置很重要，有些tag必须直接在type之上，有些tag必须和type间隔一行，具体可以参见pull request <a href="https://github.com/kubernetes/kubernetes/pull/53579" target="_blank" rel="external nofollow noopener noreferrer">#53579</a> and issue <a href="https://github.com/kubernetes/kubernetes/issues/53893" target="_blank" rel="external nofollow noopener noreferrer">#53893</a>。</p><h3 id="Global-Tags"><a href="#Global-Tags" class="headerlink" title="Global Tags"></a>Global Tags</h3><p> <code>Global Tags</code> 是定义在 doc.go 文件的注释，起到的是全局的代码生成控制的作用，具体如下所示，在这个文件中，你会看到 <code>+k8s:deepcopy-gen=package</code> 和 <code>+groupName=crddemo.k8s.io</code>，这就是 Kubernetes 进行代码生成要用的 Annotation 风格的注释。</p><figure class="highlight go"><figcaption><span>pkg/apis/crddemo/v1/doc.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"><span class="comment">// +groupName=example.houmin.cc</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure><ul><li><code>+k8s:deepcopy-gen=package</code> 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；</li><li><code>+groupName=example.houmin.cc</code>，则定义了这个包对应的crddemo API 组的名字，注意这个注释必须就在package之上 (see <a href="https://github.com/kubernetes/kubernetes/issues/53893" target="_blank" rel="external nofollow noopener noreferrer">Issue #53893</a>).</li></ul><p>如果你有一些Type不需要 <code>deepcopy</code>，那么你可以通过一个 Local Tag <code>// +k8s:deepcopy-gen=false</code> 来为这个 Typo 不生成 <code>deep copy</code>。如果没有打开package全局生成 <code>deepcopy</code>的开关，你可以对每个你想要的Type使用Local Tag <code>// +k8s:deepcopy-gen=true</code> 为它生成 <code>deepcopy</code>。</p><h3 id="Local-Tags"><a href="#Local-Tags" class="headerlink" title="Local Tags"></a>Local Tags</h3><p>Local Tags 是直接写在 API Types 之上的注释，下面是一个例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">Spec   FooSpec   <span class="string">`json:"spec"`</span></span><br><span class="line">Status FooStatus <span class="string">`json:"status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooSpec is the spec for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">DeploymentName <span class="keyword">string</span> <span class="string">`json:"deploymentName"`</span></span><br><span class="line">Replicas       *<span class="keyword">int32</span> <span class="string">`json:"replicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooStatus is the status for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">AvailableReplicas <span class="keyword">int32</span> <span class="string">`json:"availableReplicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooList <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">metav1.ListMeta <span class="string">`json:"metadata"`</span></span><br><span class="line"></span><br><span class="line">Items []Foo <span class="string">`json:"items"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个 <code>deepcopy</code> tag解释如下：</p><ul><li><code>+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code> 的意思是，请在生成 DeepCopy 的时候，实现 Kubernetes 提供的 runtime.Object 接口。否则，在某些版本的 Kubernetes 里，你的这个类型定义会出现编译错误。</li></ul><p>在上面的示例中，有部分tag用于控制 <code>client-gen</code>，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br></pre></td></tr></table></figure><ul><li><code>+genclient</code> 这段注解的意思是：请为下面资源类型生成对应的 Client 代码。因为Foo才是主类型，所以 +genclient 要写在Mydemo之上，不用写在 <code>FooList</code> 之上，这是要细心注意的。</li><li><code>+genclient:noStatus</code> 的意思是：这个 API 资源类型定义里，没有 Status 字段，这个tag告诉 <code>client-gen</code> 不要生成 <code>UpdateStatus</code>方法，一般用于使用子资源分离的例如/status分离的，用来避免更新到status资源(当然代码的struct中也没有status)</li></ul><p>对于 <code>cluster-wide</code>的资源，你需要使用下面的tag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +genclient:nonNamespaced</span></span><br></pre></td></tr></table></figure><p>有时候你想控制client提供的HTTP方法，你可以使用类似于下面的tag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +genclient:noVerbs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient:onlyVerbs=create,delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient:skipVerbs=get,list,create,update,patch,delete,deleteCollection,watch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient:method=Create,verb=create,result=k8s.io/apimachinery/pkg/apis/meta/v1.Status</span></span><br></pre></td></tr></table></figure><p>前三个很好理解，指定了client可以使用的verb。对于第四个tag，这里对应的Type只能是 create-only，并且不会返回 API Type本身，而是返回了 <code>metav1.Status</code>。</p><h2 id="Controller开发"><a href="#Controller开发" class="headerlink" title="Controller开发"></a>Controller开发</h2><p>在代码生成 <code>informers</code>、<code>clients</code>、<code>listers</code>等代码后，我们就可以用这些API编写Controller的代码了。</p><h3 id="主函数实现"><a href="#主函数实现" class="headerlink" title="主函数实现"></a>主函数实现</h3><p>我们可以像使用原生 kubernetes client一样，使用我们生成的client，如下所示：</p><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">kubeinformers <span class="string">"k8s.io/client-go/informers"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/tools/clientcmd"</span></span><br><span class="line"><span class="string">"k8s.io/klog/v2"</span></span><br><span class="line"></span><br><span class="line">clientset <span class="string">"github.com/SimpCosm/crddemo/pkg/client/clientset/versioned"</span></span><br><span class="line">informers <span class="string">"github.com/SimpCosm/crddemo/pkg/client/informers/externalversions"</span></span><br><span class="line"><span class="string">"github.com/SimpCosm/crddemo/pkg/signals"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">masterURL  <span class="keyword">string</span></span><br><span class="line">kubeconfig <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up signals so we handle the first shutdown signal gracefully</span></span><br><span class="line">stopCh := signals.SetupSignalHandler()</span><br><span class="line"></span><br><span class="line">cfg, err := clientcmd.BuildConfigFromFlags(masterURL, kubeconfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"Error building kubeconfig: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kubeClient, err := kubernetes.NewForConfig(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"Error building kubernetes clientset: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exampleClient, err := clientset.NewForConfig(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"Error building example clientset: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Second*<span class="number">30</span>)</span><br><span class="line">exampleInformerFactory := informers.NewSharedInformerFactory(exampleClient, time.Second*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">controller := NewController(kubeClient, exampleClient,</span><br><span class="line">kubeInformerFactory.Apps().V1().Deployments(),</span><br><span class="line">exampleInformerFactory.Example().V1().Foos())</span><br><span class="line"></span><br><span class="line"><span class="comment">// notice that there is no need to run Start methods in a separate goroutine. (i.e. go kubeInformerFactory.Start(stopCh)</span></span><br><span class="line"><span class="comment">// Start method is non-blocking and runs all registered informers in a dedicated goroutine.</span></span><br><span class="line">kubeInformerFactory.Start(stopCh)</span><br><span class="line">exampleInformerFactory.Start(stopCh)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = controller.Run(<span class="number">2</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"Error running controller: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.StringVar(&amp;kubeconfig, <span class="string">"kubeconfig"</span>, <span class="string">""</span>, <span class="string">"Path to a kubeconfig. Only required if out-of-cluster."</span>)</span><br><span class="line">flag.StringVar(&amp;masterURL, <span class="string">"master"</span>, <span class="string">""</span>, <span class="string">"The address of the Kubernetes API server. Overrides any value in kubeconfig. Only required if out-of-cluster."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller定义"><a href="#Controller定义" class="headerlink" title="Controller定义"></a>Controller定义</h3><p>这里我们定义了自己的Controller：</p><ul><li>分别有原生的kubernetes clientset和自定义API group的clientset。</li><li>因为我们会监听原生的 <code>Deployment</code>和自己的 <code>Foo</code>，所以分别加上了各自的lister。</li><li>每次资源发生改变时，会将其放入到workqueue等待处理在Control Loop中处理。</li></ul><figure class="highlight go"><figcaption><span>controller.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller is the controller implementation for Foo resources</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// kubeclientset is a standard kubernetes clientset</span></span><br><span class="line">kubeclientset kubernetes.Interface</span><br><span class="line"><span class="comment">// sampleclientset is a clientset for our own API group</span></span><br><span class="line">sampleclientset clientset.Interface</span><br><span class="line"></span><br><span class="line">deploymentsLister appslisters.DeploymentLister</span><br><span class="line">deploymentsSynced cache.InformerSynced</span><br><span class="line">foosLister        listers.FooLister</span><br><span class="line">foosSynced        cache.InformerSynced</span><br><span class="line"></span><br><span class="line"><span class="comment">// workqueue is a rate limited work queue. This is used to queue work to be</span></span><br><span class="line"><span class="comment">// processed instead of performing it as soon as a change happens. This</span></span><br><span class="line"><span class="comment">// means we can ensure we only process a fixed amount of resources at a</span></span><br><span class="line"><span class="comment">// time, and makes it easy to ensure we are never processing the same item</span></span><br><span class="line"><span class="comment">// simultaneously in two different workers.</span></span><br><span class="line">workqueue workqueue.RateLimitingInterface</span><br><span class="line"><span class="comment">// recorder is an event recorder for recording Event resources to the</span></span><br><span class="line"><span class="comment">// Kubernetes API.</span></span><br><span class="line">recorder record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller创建"><a href="#Controller创建" class="headerlink" title="Controller创建"></a>Controller创建</h3><p>接下来，我们来看跟业务最紧密的控制器Controller的编写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewController returns a new sample controller</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">kubeclientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">sampleclientset clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">deploymentInformer appsinformers.DeploymentInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">fooInformer informers.FooInformer)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create event broadcaster</span></span><br><span class="line"><span class="comment">// Add example types to the default Kubernetes Scheme so Events can be</span></span><br><span class="line"><span class="comment">// logged for example types.</span></span><br><span class="line">utilruntime.Must(samplescheme.AddToScheme(scheme.Scheme))</span><br><span class="line">klog.V(<span class="number">4</span>).Info(<span class="string">"Creating event broadcaster"</span>)</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl&#123;Interface: kubeclientset.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: controllerAgentName&#125;)</span><br><span class="line"></span><br><span class="line">controller := &amp;Controller&#123;</span><br><span class="line">kubeclientset:     kubeclientset,</span><br><span class="line">sampleclientset:   sampleclientset,</span><br><span class="line">deploymentsLister: deploymentInformer.Lister(),</span><br><span class="line">deploymentsSynced: deploymentInformer.Informer().HasSynced,</span><br><span class="line">foosLister:        fooInformer.Lister(),</span><br><span class="line">foosSynced:        fooInformer.Informer().HasSynced,</span><br><span class="line">workqueue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"Foos"</span>),</span><br><span class="line">recorder:          recorder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.Info(<span class="string">"Setting up event handlers"</span>)</span><br><span class="line"><span class="comment">// Set up an event handler for when Foo resources change</span></span><br><span class="line">fooInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: controller.enqueueFoo,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">controller.enqueueFoo(<span class="built_in">new</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: controller.handleObject,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">newDepl := <span class="built_in">new</span>.(*appsv1.Deployment)</span><br><span class="line">oldDepl := old.(*appsv1.Deployment)</span><br><span class="line"><span class="keyword">if</span> newDepl.ResourceVersion == oldDepl.ResourceVersion &#123;</span><br><span class="line"><span class="comment">// Periodic resync will send update events for all known Deployments.</span></span><br><span class="line"><span class="comment">// Two different versions of the same Deployment will always have different RVs.</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">controller.handleObject(<span class="built_in">new</span>)</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: controller.handleObject,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面Controller的代码实现，我们基本实现了控制器ListAndWatch的事件注册逻辑：通过 APIServer 的 LIST API获取所有最新版本的 API 对象；然后，再通过 WATCH-API 来监听所有这些API对象的变化。通过监听到的事件变化，Informer 就可以实时地更新本地缓存，并且调用这些事件对应的 EventHandler了。</p><h3 id="Control-Loop"><a href="#Control-Loop" class="headerlink" title="Control Loop"></a>Control Loop</h3><p>下面，我们再来看原理图中的Control Loop的部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(threadiness <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> c.workqueue.ShutDown()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the informer factories to begin populating the informer caches</span></span><br><span class="line">klog.Info(<span class="string">"Starting Foo controller"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the caches to be synced before starting workers</span></span><br><span class="line">klog.Info(<span class="string">"Waiting for informer caches to sync"</span>)</span><br><span class="line"><span class="keyword">if</span> ok := cache.WaitForCacheSync(stopCh, c.deploymentsSynced, c.foosSynced); !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to wait for caches to sync"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.Info(<span class="string">"Starting workers"</span>)</span><br><span class="line"><span class="comment">// Launch two workers to process Foo resources</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threadiness; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.Info(<span class="string">"Started workers"</span>)</span><br><span class="line">&lt;-stopCh</span><br><span class="line">klog.Info(<span class="string">"Shutting down workers"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，启动控制循环的逻辑非常简单，就是同步+循环监听任务。而这个循环监听任务就是我们真正的业务实现部分了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runWorker is a long-running function that will continually call the</span></span><br><span class="line"><span class="comment">// processNextWorkItem function in order to read and process a message on the</span></span><br><span class="line"><span class="comment">// workqueue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> c.processNextWorkItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processNextWorkItem will read a single work item off the workqueue and</span></span><br><span class="line"><span class="comment">// attempt to process it, by calling the syncHandler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">obj, shutdown := c.workqueue.Get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shutdown &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We wrap this block in a func so we can defer c.workqueue.Done.</span></span><br><span class="line">err := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// We call Done here so the workqueue knows we have finished</span></span><br><span class="line"><span class="comment">// processing this item. We also must remember to call Forget if we</span></span><br><span class="line"><span class="comment">// do not want this work item being re-queued. For example, we do</span></span><br><span class="line"><span class="comment">// not call Forget if a transient error occurs, instead the item is</span></span><br><span class="line"><span class="comment">// put back on the workqueue and attempted again after a back-off</span></span><br><span class="line"><span class="comment">// period.</span></span><br><span class="line"><span class="keyword">defer</span> c.workqueue.Done(obj)</span><br><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// We expect strings to come off the workqueue. These are of the</span></span><br><span class="line"><span class="comment">// form namespace/name. We do this as the delayed nature of the</span></span><br><span class="line"><span class="comment">// workqueue means the items in the informer cache may actually be</span></span><br><span class="line"><span class="comment">// more up to date that when the item was initially put onto the</span></span><br><span class="line"><span class="comment">// workqueue.</span></span><br><span class="line"><span class="keyword">if</span> key, ok = obj.(<span class="keyword">string</span>); !ok &#123;</span><br><span class="line"><span class="comment">// As the item in the workqueue is actually invalid, we call</span></span><br><span class="line"><span class="comment">// Forget here else we'd go into a loop of attempting to</span></span><br><span class="line"><span class="comment">// process a work item that is invalid.</span></span><br><span class="line">c.workqueue.Forget(obj)</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"expected string in workqueue but got %#v"</span>, obj))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Run the syncHandler, passing it the namespace/name string of the</span></span><br><span class="line"><span class="comment">// Foo resource to be synced.</span></span><br><span class="line"><span class="keyword">if</span> err := c.syncHandler(key); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Put the item back on the workqueue to handle any transient errors.</span></span><br><span class="line">c.workqueue.AddRateLimited(key)</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error syncing '%s': %s, requeuing"</span>, key, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finally, if no error occurs we Forget this item so it does not</span></span><br><span class="line"><span class="comment">// get queued again until another change happens.</span></span><br><span class="line">c.workqueue.Forget(obj)</span><br><span class="line">klog.Infof(<span class="string">"Successfully synced '%s'"</span>, key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 <code>fooInformer</code>，从namespace中通过key获取 <code>Foo</code> 对象这个操作，其实就是在访问本地缓存的索引，实际上，在 Kubernetes 的源码中，你会经常看到控制器从各种 Lister 里获取对象，比如：podLister、nodeLister 等等，它们使用的都是 Informer 和缓存机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncHandler compares the actual state with the desired, and attempts to</span></span><br><span class="line"><span class="comment">// converge the two. It then updates the Status block of the Foo resource</span></span><br><span class="line"><span class="comment">// with the current status of the resource.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">syncHandler</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Convert the namespace/name string into a distinct namespace and name</span></span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"invalid resource key: %s"</span>, key))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Foo resource with this namespace/name</span></span><br><span class="line">foo, err := c.foosLister.Foos(namespace).Get(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// The Foo resource may no longer exist, in which case we stop</span></span><br><span class="line"><span class="comment">// processing.</span></span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"foo '%s' in work queue no longer exists"</span>, key))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deploymentName := foo.Spec.DeploymentName</span><br><span class="line"><span class="keyword">if</span> deploymentName == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// We choose to absorb the error here as the worker would requeue the</span></span><br><span class="line"><span class="comment">// resource otherwise. Instead, the next time the resource is updated</span></span><br><span class="line"><span class="comment">// the resource will be queued again.</span></span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: deployment name must be specified"</span>, key))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the deployment with the name specified in Foo.spec</span></span><br><span class="line">deployment, err := c.deploymentsLister.Deployments(foo.Namespace).Get(deploymentName)</span><br><span class="line"><span class="comment">// If the resource doesn't exist, we'll create it</span></span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">deployment, err = c.kubeclientset.AppsV1().Deployments(foo.Namespace).Create(context.TODO(), newDeployment(foo), metav1.CreateOptions&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If an error occurs during Get/Create, we'll requeue the item so we can</span></span><br><span class="line"><span class="comment">// attempt processing again later. This could have been caused by a</span></span><br><span class="line"><span class="comment">// temporary network failure, or any other transient reason.</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the Deployment is not controlled by this Foo resource, we should log</span></span><br><span class="line"><span class="comment">// a warning to the event recorder and return error msg.</span></span><br><span class="line"><span class="keyword">if</span> !metav1.IsControlledBy(deployment, foo) &#123;</span><br><span class="line">msg := fmt.Sprintf(MessageResourceExists, deployment.Name)</span><br><span class="line">c.recorder.Event(foo, corev1.EventTypeWarning, ErrResourceExists, msg)</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this number of the replicas on the Foo resource is specified, and the</span></span><br><span class="line"><span class="comment">// number does not equal the current desired replicas on the Deployment, we</span></span><br><span class="line"><span class="comment">// should update the Deployment resource.</span></span><br><span class="line"><span class="keyword">if</span> foo.Spec.Replicas != <span class="literal">nil</span> &amp;&amp; *foo.Spec.Replicas != *deployment.Spec.Replicas &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"Foo %s replicas: %d, deployment replicas: %d"</span>, name, *foo.Spec.Replicas, *deployment.Spec.Replicas)</span><br><span class="line">deployment, err = c.kubeclientset.AppsV1().Deployments(foo.Namespace).Update(context.TODO(), newDeployment(foo), metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If an error occurs during Update, we'll requeue the item so we can</span></span><br><span class="line"><span class="comment">// attempt processing again later. This could have been caused by a</span></span><br><span class="line"><span class="comment">// temporary network failure, or any other transient reason.</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, we update the status block of the Foo resource to reflect the</span></span><br><span class="line"><span class="comment">// current state of the world</span></span><br><span class="line">err = c.updateFooStatus(foo, deployment)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.recorder.Event(foo, corev1.EventTypeNormal, SuccessSynced, MessageResourceSynced)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果控制循环从缓存中拿不到这个对象（<code>fooInformer</code> 返回了 IsNotFound 错误），那就意味着这个 <code>Foo</code>  对象的 Key 是通过前面的“删除”事件添加进工作队列的。所以，尽管队列里有这个 Key，但是对应的 <code>Foo</code>  对象已经被删除了。而如果能够获取到对应的 <code>Foo</code>  对象，就可以执行控制器模式里的对比 <code>Desired State</code> 和 <code>CurrentState</code> 的功能逻辑了。</p><p>至此，一个完整的自定义 API 对象和它所对应的自定义控制器，就编写完毕了。</p><h2 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h2><p>编译完成后，会生成 <em>crddemo</em> 的二进制文件，我们要做把crddemo放到kubernetes集群中，或者本地也行，只要能访问到 <code>apiserver</code> 和具备<code>kubeconfig</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./crddemo --kubeconfig=.kube/config</span></span><br><span class="line">I1106 10:47:59.055510   11946 controller.go:115] Setting up event handlers</span><br><span class="line">I1106 10:47:59.055608   11946 controller.go:156] Starting Foo controller</span><br><span class="line">I1106 10:47:59.055620   11946 controller.go:159] Waiting <span class="keyword">for</span> informer caches to sync</span><br><span class="line">E1106 10:47:59.079342   11946 reflector.go:138] pkg/client/informers/externalversions/factory.go:116: Failed to watch *v1.Foo: failed to list *v1.Foo: the server could not find the requested resource (get foos.example.houmin.cc)</span><br><span class="line">E1106 10:48:00.369747   11946 reflector.go:138] pkg/client/informers/externalversions/factory.go:116: Failed to watch *v1.Foo: failed to list *v1.Foo: the server could not find the requested resource (get foos.example.houmin.cc)</span><br><span class="line">E1106 10:48:03.038137   11946 reflector.go:138] pkg/client/informers/externalversions/factory.go:116: Failed to watch *v1.Foo: failed to list *v1.Foo: the server could not find the requested resource (get foos.example.houmin.cc)</span><br></pre></td></tr></table></figure><p>可以看到，程序运行的时候，一开始会报错。这是因为，此时 Mydemo 对象的 CRD 还没有被创建出来，所以 Informer 去 APIServer 里获取 Mydemos 对象时，并不能找到 Mydemo 这个 API 资源类型的定义</p><p>接下来，我们执行我们自定义资源的定义文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl apply -f artifacts/examples/crd.yaml </span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/foos.example.houmin.cc created</span><br></pre></td></tr></table></figure><p>此时，观察crddemo的日志输出，可以看到Controller的日志恢复了正常，控制循环启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I0308 12:30:29.956263   28282 controller.go:113] Starting workers</span><br><span class="line">I0308 12:30:29.956307   28282 controller.go:118] Started workers</span><br></pre></td></tr></table></figure><p>然后，我们可以对我们的Mydemo对象进行增删改查操作了。</p><p>提交我们的自定义资源对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f artifacts/examples/example-foo.yaml </span></span><br><span class="line">foo.example.houmin.cc/example-foo created</span><br></pre></td></tr></table></figure><p>创建成功够，看k8s集群是否成功存储起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get foo</span></span><br><span class="line">NAME          AGE</span><br><span class="line">example-foo   8s</span><br></pre></td></tr></table></figure><p>这时候，查看一下控制器的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./crddemo --kubeconfig=.kube/config</span></span><br><span class="line">I1106 10:50:36.627136   12768 controller.go:115] Setting up event handlers</span><br><span class="line">I1106 10:50:36.627225   12768 controller.go:156] Starting Foo controller</span><br><span class="line">I1106 10:50:36.627235   12768 controller.go:159] Waiting <span class="keyword">for</span> informer caches to sync</span><br><span class="line">I1106 10:50:36.727340   12768 controller.go:164] Starting workers</span><br><span class="line">I1106 10:50:36.727364   12768 controller.go:170] Started workers</span><br><span class="line">I1106 10:51:27.596870   12768 controller.go:228] Successfully synced <span class="string">'default/example-foo'</span></span><br><span class="line">I1106 10:51:27.597113   12768 event.go:291] <span class="string">"Event occurred"</span> object=<span class="string">"default/example-foo"</span> kind=<span class="string">"Foo"</span> apiVersion=<span class="string">"example.houmin.cc/v1"</span> <span class="built_in">type</span>=<span class="string">"Normal"</span> reason=<span class="string">"Synced"</span> message=<span class="string">"Foo synced successfully"</span></span><br><span class="line">I1106 10:51:27.612272   12768 controller.go:228] Successfully synced <span class="string">'default/example-foo'</span></span><br><span class="line">I1106 10:51:27.612393   12768 event.go:291] <span class="string">"Event occurred"</span> object=<span class="string">"default/example-foo"</span> kind=<span class="string">"Foo"</span> apiVersion=<span class="string">"example.houmin.cc/v1"</span> <span class="built_in">type</span>=<span class="string">"Normal"</span> reason=<span class="string">"Synced"</span> message=<span class="string">"Foo synced successfully"</span></span><br></pre></td></tr></table></figure><p>可以看到，我们上面创建 example-mydemo.yaml 的操作，触发了 EventHandler 的添加事件，从而被放进了工作队列。紧接着，控制循环就从队列里拿到了这个对象，并且打印出了正在处理这个 Foo 对象的日志。</p><p>同时我们可以看到，与Foo相关的Deployment也同时被创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get deployment</span></span><br><span class="line">NAME          READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">example-foo   1/1     1            1           76s</span><br></pre></td></tr></table></figure><p>我们这时候，尝试修改资源，对对应的replicas属性进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.houmin.cc/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Foo</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">deploymentName:</span> <span class="string">example-foo</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>手动执行修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl apply -f artifacts/examples/example-foo.yaml</span></span><br></pre></td></tr></table></figure><p>同时我们可以看到，与Foo相关的Deployment的副本数也同时增加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get deployment</span></span><br><span class="line">NAME          READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">example-foo   3/3     3            3           2m34s</span><br></pre></td></tr></table></figure><p>我们这时候，尝试修改资源，对对应的replicas属性进行修改</p><p>可以看到，这一次，Informer 注册的更新事件被触发，更新后的 Foo 对象的 Key 被添加到了工作队列之中。</p><p>所以，接下来控制循环从工作队列里拿到的 Foo 对象，与前一个对象是不同的：它的<code>ResourceVersion</code>的值发生了改变；而 Spec 里的Replicas 字段，则变成了3。最后，我再把这个对象删除掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl delete -f artifacts/examples/example-foo.yaml </span><br><span class="line">foo.example.houmin.cc <span class="string">"example-foo"</span> deleted</span><br></pre></td></tr></table></figure><p>然后，k8s集群的资源也被清除了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  kubectl get foo                    </span><br><span class="line">No resources found <span class="keyword">in</span> default namespace.</span><br></pre></td></tr></table></figure><p>以上就是使用自定义控制器的基本开发流程</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lihaoquan.me/2020/3/8/k8s-crd-develop.html" target="_blank" rel="external nofollow noopener noreferrer">https://lihaoquan.me/2020/3/8/k8s-crd-develop.html</a></li><li><a href="https://blog.openshift.com/kubernetes-deep-dive-code-generation-customresources/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes Deep Dive: Code Generation for CustomResources</a></li><li><a href="https://github.com/kubernetes/code-generator" target="_blank" rel="external nofollow noopener noreferrer">code-generator</a></li><li><a href="https://github.com/kubernetes/sample-controller" target="_blank" rel="external nofollow noopener noreferrer">sample controller</a></li><li><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">API Conventions</a></li><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/customresources-versioning.md" target="_blank" rel="external nofollow noopener noreferrer">CustomReourcesVersioning</a></li><li><a href="https://github.com/kubernetes/community/blob/8cafef897a22026d42f5e5bb3f104febe7e29830/contributors/devel/controllers.md" target="_blank" rel="external nofollow noopener noreferrer">Writing Controllers</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://houmin.cc/tags/controller&quot;&gt;Controller Manager 的系列文章&lt;/a&gt; 中我们看到，Kubernetes 内置的各种 Controller 通过ApiServer监控 &lt;a href=&quot;https://houmin.cc&quot;&gt;Deployment&lt;/a&gt;、&lt;a href=&quot;https://houmin.cc&quot;&gt;DaemonSet&lt;/a&gt;、&lt;a href=&quot;https://houmin.cc&quot;&gt;StatefulSet &lt;/a&gt;等内部资源对象，在一个控制循环中通过各种操作将系统维持在我们期望的一个状态中，这即是其经典的 &lt;code&gt;声明式API设计&lt;/code&gt;。然而，内置的API资源大多仅代表相对底层和通用概念的对象，已经不能够满足越来越复杂的业务场景需求。随着Kubernetes生态系统的持续发展，我们将需要更多高层次的面向专门的场景的对象。在声明式API的原则下，设计自定义资源API，开发者将不需要逐一进行 Deployment、Service、ConfigMap 等步骤，而是创建并关联一些用于表述整个应用程序或者软件服务的对象。在当前，CoreOS推出的各种 &lt;a href=&quot;https://coreos.com/operators/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Operator&lt;/a&gt; 即是这一思想的广泛利用。为了实现 Operator，你需要了解 &lt;code&gt;CRD（CustomResourceDefinitions）&lt;/code&gt;。本文所有实现的代码，可以参考我的 &lt;a href=&quot;https://github.com/SimpCosm/crddemo&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-20_client-go-controller-interaction.jpeg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="controller" scheme="http://houmin.cc/tags/controller/"/>
    
      <category term="crd" scheme="http://houmin.cc/tags/crd/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Envoy 入门</title>
    <link href="http://houmin.cc/posts/7beb34d2/"/>
    <id>http://houmin.cc/posts/7beb34d2/</id>
    <published>2020-09-11T11:15:08.000Z</published>
    <updated>2020-09-11T12:26:23.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Envoy</code> 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 <code>Envoy</code>没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，<code>Envoy</code>也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。</p><a id="more"></a><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img alt="Envoy Architecture" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p><p>首先介绍Envoy中的一些基本概念：</p><ul><li>Downstream：下游主机，指连接到Envoy的主机，这些主机用来发送请求并接受响应。</li><li>Upstream：上游主机，指接收来自Envoy连接和请求的主机，并返回响应。</li><li>Listener：服务或程序的监听器， Envoy暴露一个或多个监听器监听下游主机的请求，当监听到请求时，通过Filter Chain把对请求的处理全部抽象为Filter， 例如ReadFilter、WriteFilter、HttpFilter等。</li><li>Cluster：服务提供集群，指Envoy连接的一组逻辑相同的上游主机。Envoy通过服务发现功能来发现集群内的成员，通过负载均衡功能将流量路由到集群的各个成员。</li><li>xDS：xDS中的x是一个代词，类似云计算里的XaaS可以指代IaaS、PaaS、SaaS等。DS为Discovery Service，即发现服务的意思。xDS包括CDS（cluster discovery service）、RDS（route discovery service）、EDS（endpoint discovery service）、ADS（aggregated discovery service），其中ADS称为聚合的发现服务，是对CDS、RDS、LDS、EDS服务的统一封装，解决CDS、RDS、LDS、EDS信息更新顺序依赖的问题，从而保证以一定的顺序同步各类配置信息。以上Endpoint、Cluster、Route的概念介绍如下：<ul><li>Endpoint：一个具体的“应用实例”，类似于Kubernetes中的一个Pod；</li><li>Cluster：可以理解“应用集群”，对应提供相同服务的一个或多个Endpoint， 类似Kubernetes中Service概念，即一个Service提供多个相同服务的Pod；</li><li>Route：当我们做金丝雀发布部署时，同一个服务会有多个版本，这时需要Route规则规定请求如何路由到其中的某个版本上。</li></ul></li></ul><p>xDS模块的功能是通过Envoy API V1（基于HTTP）或V2（基于gRPC）实现一个服务端将配置信息暴露给上游主机，等待上游主机的拉取。</p><p>Envoy正常的工作流程为Host A（下游主机）发送请求至上游主机（Host B、Host C、Host D等），Envoy通过Listener监听到有下游主机的请求，收到请求后的Envoy将所有请求流量劫持至Envoy内部，并将请求内容抽象为Filter Chains路由至某个上游主机中从而实现路由转发及负载均衡能力。</p><p>Envoy为了实现流量代理能力通常需要一个统一的配置文件来记录信息以便启动时加载，在Envoy中启动配置文件有静态配置和动态配置两种方式。静态配置是将配置信息写入文件中，启动时直接加载，动态配置通过xDS实现一个Envoy的服务端（可以理解为以API接口对外实现服务发现能力）。</p><h3 id="Network-Topology"><a href="#Network-Topology" class="headerlink" title="Network Topology"></a>Network Topology</h3><p>Envoy作为Service Mesh中的 sidecar 代理，请求可以通过 ingress 或者 egress listener 到达 envoy。</p><ul><li>Ingress Listener 负责从服务网格中其他节点接受请求，并将请求转发到本地应用。本地应用的响应之后通过 Envoy 转发到 downstream。</li><li>Egress Listener 负责从本地应用接受请求，并将请求转发到服务网格中的其他节点。</li></ul><p><img alt="Service Mesh" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-service-mesh.svg"></p><p>除了服务网格外，Envoy还可以用作很多其他的请求，比如作为内部的负载均衡器：</p><p><img alt="Internal Load Balancer" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-ilb.svg"></p><p>或者作为网络边缘的 <code>ingress/egress</code> 代理：</p><p><img alt="Ingress/Egress Proxy on Network Edge" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-edge.svg"></p><p>在实际应用中，Envoy一般会发挥上述多种功能，一个网络请求路径中可能会通过多个Envoy：</p><p><img alt="Hybrid Envoy" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-hybrid.svg"></p><p>为了可靠性和可扩充性，Envoy可能会被配置成多层拓扑的形式：</p><p><img alt="Envoy Tiered" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-tiered.svg"></p><h3 id="High-Level-Architecture"><a href="#High-Level-Architecture" class="headerlink" title="High Level Architecture"></a>High Level Architecture</h3><p>Envoy中服务请求处理过程可以大致分为两个部分：</p><ul><li>Listener 子系统：处理来自 downstream 的请求。</li><li>Cluster 子系统：负责选择和配置 upstream 连接。</li></ul><p><img alt="High Level Architecture" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-architecture.svg"></p><p>Envoy采用了基于事件的线程模型：</p><ul><li>一个主线程负责server的生命周期，配置处理，统计等</li><li>多个worker线程负责处理请求。</li></ul><p>所有的线程都运行在一个基于 <a href="https://libevent.org/" target="_blank" rel="external nofollow noopener noreferrer">libevent</a> 的事件循环中，任何 downstream 的 TCP连接都会被分配一个 work 线程来处理</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Envoy 进程中运行着一系列 <code>Inbound/Outbound</code> 监听器（Listener），<code>Inbound</code> 代理入站流量，<code>Outbound</code> 代理出站流量。Listener 的核心就是过滤器链（FilterChain），链中每个过滤器都能够控制流量的处理流程。过滤器链中的过滤器分为两个类别：</p><ul><li><strong>网络过滤器</strong>（Network Filters）: 工作在 <code>L3/L4</code>，是 Envoy 网络连接处理的核心，处理的是原始字节，分为 <code>Read</code>、<code>Write</code> 和 <code>Read/Write</code> 三类。</li><li><strong>HTTP 过滤器</strong>（HTTP Filters）: 工作在 <code>L7</code>，由特殊的网络过滤器 <code>HTTP connection manager</code> 管理，专门处理 <code>HTTP1/HTTP2/gRPC</code> 请求。它将原始字节转换成 <code>HTTP</code> 格式，从而可以对 <code>HTTP</code> 协议进行精确控制。</li></ul><p>除了 <code>HTTP connection manager</code> 之外，还有一种特别的网络过滤器叫 <code>Thrift Proxy</code>。<code>Thrift</code> 是一套包含序列化功能和支持服务通信的 RPC 框架，详情参考<a href="https://zh.wikipedia.org/wiki/Thrift" target="_blank" rel="external nofollow noopener noreferrer">维基百科</a>。Thrift Proxy 管理了两个 Filter：<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/router_filter" target="_blank" rel="external nofollow noopener noreferrer">Router</a> 和 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/rate_limit_filter" target="_blank" rel="external nofollow noopener noreferrer">Rate Limit</a>。</p><p>除了过滤器链之外，还有一种过滤器叫<strong>监听器过滤器</strong>（Listener Filters），它会在过滤器链之前执行，用于操纵连接的<strong>元数据</strong>。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 <code>UDP</code> 时，就可以指定 UDP 监听器过滤器。根据上面的分类，Envoy 过滤器的架构如下图所示：</p><p><img alt="img" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504224710.png"></p><h2 id="Request-Flow"><a href="#Request-Flow" class="headerlink" title="Request Flow"></a>Request Flow</h2><h3 id="Listener-TCP-Accept"><a href="#Listener-TCP-Accept" class="headerlink" title="Listener TCP Accept"></a>Listener TCP Accept</h3><p><img alt="Listener TCP Accept" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listeners.svg"></p><h3 id="Listener-filter-chains-and-network-filter-chain-matching"><a href="#Listener-filter-chains-and-network-filter-chain-matching" class="headerlink" title="Listener filter chains and network filter chain matching"></a>Listener filter chains and network filter chain matching</h3><p><img alt="Listener Filter Chains" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listener-filters.svg"></p><p><img alt="../_images/lor-filter-chain-match.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-filter-chain-match.svg"></p><h3 id="TLS-transport-socket-decryption"><a href="#TLS-transport-socket-decryption" class="headerlink" title="TLS transport socket decryption"></a>TLS transport socket decryption</h3><p><img alt="../_images/lor-transport-socket.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-transport-socket.svg"></p><h3 id="Network-filter-chain-processing"><a href="#Network-filter-chain-processing" class="headerlink" title="Network filter chain processing"></a>Network filter chain processing</h3><p><img alt="../_images/lor-network-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-filters.svg"></p><p><img alt="../_images/lor-network-read.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-read.svg"></p><p><img alt="../_images/lor-network-write.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-write.svg"></p><h3 id="HTTP-2-codec-encoding"><a href="#HTTP-2-codec-encoding" class="headerlink" title="HTTP/2 codec encoding"></a>HTTP/2 codec encoding</h3><h3 id="TLS-transport-socket-encryption"><a href="#TLS-transport-socket-encryption" class="headerlink" title="TLS transport socket encryption"></a>TLS transport socket encryption</h3><p><img alt="../_images/lor-http-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-filters.svg"></p><p><img alt="../_images/lor-http.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http.svg"></p><p><img alt="../_images/lor-http-decode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-decode.svg"></p><p><img alt="../_images/lor-http-encode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-encode.svg"></p><p><img alt="../_images/lor-route-config.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-route-config.svg"></p><h3 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h3><p><img alt="../_images/lor-lb.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-lb.svg"></p><h3 id="Response-path-and-HTTP-lifecycle"><a href="#Response-path-and-HTTP-lifecycle" class="headerlink" title="Response path and HTTP lifecycle"></a>Response path and HTTP lifecycle</h3><p><img alt="../_images/lor-client.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-client.svg"></p><h3 id="Post-request-processing"><a href="#Post-request-processing" class="headerlink" title="Post-request processing"></a>Post-request processing</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.aliyun.com/article/606655" target="_blank" rel="external nofollow noopener noreferrer">https://developer.aliyun.com/article/606655</a></li><li><a href="https://www.cnblogs.com/popsuper1982/p/9841978.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/popsuper1982/p/9841978.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 &lt;code&gt;Envoy&lt;/code&gt;没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，&lt;code&gt;Envoy&lt;/code&gt;也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio 流量控制</title>
    <link href="http://houmin.cc/posts/151719f0/"/>
    <id>http://houmin.cc/posts/151719f0/</id>
    <published>2020-09-10T08:47:28.000Z</published>
    <updated>2020-09-11T12:16:08.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 <a href="../22cae0b8">Istio 入门</a> 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。</p><a id="more"></a><p><img alt="Istio Architecture" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h2 id="路由和流量转移"><a href="#路由和流量转移" class="headerlink" title="路由和流量转移"></a>路由和流量转移</h2><p>Istio 为了控制服务请求，引入了服务版本（version）的概念，可以通过版本这一标签将服务进行区分。版本的设置是非常灵活的，以下是几种典型的设置方式：</p><ul><li>根据服务的迭代编号进行定义（如 v1、v2 版本）</li><li>根据部署环境进行定义（比如 dev、staging、production）</li><li>自定义的任何用于区分服务的某种标记</li></ul><p>通过版本标签，Istio 就可以定义灵活的路由规则来控制流量，上面提到的金丝雀发布这类应用场景就很容易实现了。</p><p>下图展示了使用服务版本实现路由分配的例子。服务版本定义了版本号（v1.5、v2.0-alpha）和环境（us-prod、us-staging）两种信息。服务 B 包含了 4 个 Pod，其中 3 个是部署在生产环境的 v1.5 版本，而 Pod4 是部署在预生产环境的 v2.0-alpha 版本。运维人员可以根据服务版本来指定路由规则，使 99% 的流量流向 v1.5 版本，而 1% 的流量进入 v2.0-alpha 版本。</p><p><img alt="路由" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/concept-feature-routing.png"></p><p>除了上面介绍的服务间流量控制外，还能控制与网格边界交互的流量。可以在系统的入口和出口处部署 Sidecar 代理，让所有流入和流出的流量都由代理进行转发。负责入和出的代理就叫做入口网关和出口网关，它们把守着进入和流出网格的流量。下图展示了 Ingress 和 Egress 在请求流中的位置，有了他们俩，也就可以控制出入网格的流量了。</p><p><img alt="入口和出口网关" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/concept-feature-gateway.png"></p><p>Istio 还能设置流量策略。比如可以对连接池相关的属性进行设置，通过修改最大连接等参数，实现对请求负载的控制。还可以对负载均衡策略进行设置，在轮询、随机、最少访问等方式之间进行切换。还能设置异常探测策略，将满足异常条件的实例从负载均衡池中摘除，以保证服务的稳定性。</p><hr><p>Istio 的流量路由规则可以让您很容易的控制服务之间的流量和 API 调用。Istio 在服务层面提供了断路器，超时，重试等功能，通过这些功能可以简单地实现 A/B 测试，金丝雀发布，基于百分比的流量分割等，此外还提供了开箱即用的故障恢复功能，用于增加应用的健壮性，以应对服务故障或网络故障。这些功能都可以通过 Istio 的流量管理 API 添加流量配置来实现。</p><p>跟其他 Istio 配置一样，流量管理 API 也使用 CRD 指定。本小节主要介绍下面几个典型的流量管理 API 资源，以及这些 API 的功能和使用示例。</p><h3 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h3><p>VirtualService 由一组 <strong>路由规则</strong> 组成，描述了 <strong>用户请求的目标地址</strong> 到 <strong>服务网格中实际工作负载</strong> 之间的映射。在这个映射中，VirtualService提供了丰富的配置方式，可以为发送到这些 Workloads 的流量指定不同的路由规则。对应于具体的配置，用户请求的目标地址用 <code>hosts</code> 字段来表示，网格内的实际负载由每个 <code>route</code> 配置项中的 <code>destination</code> 字段指定。</p><pre class="mermaid">graph LRsubgraph VirtualServiceClientRequests -- DifferentTrafficRoutingRules --> DestinationWorkloadsHosts -- DifferentTrafficRoutingRules --> RouteDestinationend</pre><p>VirtualService 通过解耦 <strong>用户请求的目标地址</strong> 和 <strong>真实响应请求的目标工作负载</strong>，为服务提供了合适的统一抽象层，而由此演化设计的配置模型为管理这方面提供了一致的环境。对于原生 Kubernetes 而言，只有在 Ingress 处有这种路由规则的定义，对于集群内部不同Service的不同版本之间，并没有类似 VirtualService 的定义。</p><p>使用 VirtualService，可以为一个或多个主机名指定流量行为。在 VirtualService 中使用路由规则，告诉 Envoy如何发送 VirtualService 的流量到适当的目标。路由目标可以是相同服务的不同版本，或者是完全不同的服务。</p><p>一个典型的应用场景是将流量发送到被指定为服务子集的服务的不同版本。客户端将 VirtualService 视为一个单一实体，将请求发送至 VirtualService 主机，然后 Envoy 根据 VirtualService 规则把流量路由到不同的版本中。</p><p>这种方式可以方便地创建一种金丝雀的发布策略实现新版本流量的平滑比重升级。流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。相比之下，类似 Kubernetes 的容器调度平台仅支持基于部署中实例扩缩容比重的流量分发，那样会日趋复杂化。关于使用VirtualService实现金丝雀部署，可以参考 <a href="https://istio.io/latest/blog/2017/0.1-canary/" target="_blank" rel="external nofollow noopener noreferrer">Canary</a> 。</p><p>VirtualService 也提供了如下功能。</p><ul><li>通过单个 VirtualService 处理多个应用程序服务。例如，如果您的服务网格使用是 Kubernetes，您可以配置一个 VirtualService 来处理一个特定命名空间的所有服务。将单一的 VirtualService 映射为多个“真实”的服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。您的路由规则可以指定“请求到 <code>monolith.com</code> 的 URLs 跳转至 <code>microservice A</code> 中”。</li><li>和 Gateway  一起配置流量规则来控制入口和出口流量。</li></ul><p>在一些应用场景中，由于指定服务子集，需要配置 DestinationRule 来使用这些功能。在不同的对象中指定服务子集以及其他特定的目标策略可以帮助您在不同的 VirtualService 中清晰地复用这些功能。</p><p>下面的 VirtualService 根据是否来自于特定用户路由请求到不同的服务版本中（如果请求来自用户 <code>jason</code> ，则访问 <code>v2</code> 版本的 <code>reviews</code>，否则访问 <code>v3</code> 版本）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>下面对这些字段依次解释：</p><h4 id="Hosts"><a href="#Hosts" class="headerlink" title="Hosts"></a>Hosts</h4><p>用来配置 Downstream 访问的可寻址地址，也就是用户请求的目标地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">reviews</span></span><br></pre></td></tr></table></figure><ul><li>VirtualService 主机名可以是 IP 地址、 DNS 域名、完全限定域名（FQDN)</li><li>也可以是 依赖于平台的一个简称（例如 Kubernetes 服务的短名称）</li><li>也可以使用通配符 <code>*</code>前缀，创建一组匹配所有服务的路由规则</li><li>VirtualService 的 <code>hosts</code> 实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址。这可以为没有路由到网格内部的虚拟主机建模。</li></ul><h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><p><code>http</code> 字段用来配置路由规则，通常情况下配置一组路由规则，当请求到来时，自上而下依次进行匹配，直到匹配成功后跳出匹配。它可以对请求的 uri、method、authority、headers、port、queryParams 以及是否对 uri 大小写敏感等进行配置。</p><blockquote><p>除了HTTP协议，也可以使用 <code>tcp</code> 和 <code>tls</code> 片段为 <a href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#TCPRoute" target="_blank" rel="external nofollow noopener noreferrer">TCP</a> 和未终止的 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#TLSRoute" target="_blank" rel="external nofollow noopener noreferrer">TLS</a> 流量设置路由规则</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">end-user:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>我们推荐在每个 VirtualService 中配置一条默认「无条件的」或者基于权重的规则以确保 VirtualService 至少有一条匹配的路由。</p><h5 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h5><p>路由片段的 <code>destination</code> 字段指定符合匹配条件的流量目标地址。这里不像 VirtualService 的 <code>hosts</code>，Destination 的 <code>host</code> 必须是存在于 Istio 服务注册中心的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。这个目标地址可以是代理的网格服务或者作为服务入口加入的非网格服务。下面的场景中我们运行在 Kubernetes 平台上，主机名是 Kubernetes 的服务名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">subset:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">*Note for Kubernetes users*: When short names are used (e.g. "reviews" instead of "reviews.default.svc.cluster.local"), Istio will interpret the short name based on the namespace of the rule, not the service. A rule in the "default" namespace containing a host "reviews will be interpreted as "reviews.default.svc.cluster.local", irrespective of the actual namespace associated with the reviews service. To avoid potential misconfiguration, it is recommended to always use fully qualified domain names over short names.</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>路由规则是将特定流量子集路由到特定目标地址的强大工具。可以在流量端口、<code>header</code> 字段、 URL 等内容上设置匹配条件。例如，下面的VirtualService 使用户发送流量到两个独立的服务，ratings and reviews， 就好像它们是 <code>http://bookinfo.com/</code> 这个更大的 VirtualService 的一部分。VirtualService 规则根据请求的 URL 和指向适当服务的请求匹配流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bookinfo.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/ratings</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br></pre></td></tr></table></figure><p>对于匹配条件，您可以使用确定的值，一条前缀、或者一条正则表达式。</p><p>您可以使用 <code>AND</code> 向同一个 <code>match</code> 块添加多个匹配条件， 或者使用 <code>OR</code> 向同一个规则添加多个 <code>match</code> 块。对于任意给定的 VirtualService ，您可以配置多条路由规则。这可以使您的路由条件在一个单独的 VirtualService 中基于业务场景的复杂度来进行相应的配置。可以在 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPMatchRequest" target="_blank" rel="external nofollow noopener noreferrer">HTTPMatchRequest 参考</a>中查看匹配条件字段和他们可能的值。</p><p>再者进一步使用匹配条件，您可以使用基于“权重”百分比分发流量。这在 A/B 测试和金丝雀部署中非常有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">75</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>您也可以使用路由规则在流量上执行一些操作，例如</p><ul><li>扩展或者删除 <code>headers</code></li><li>重写 URL</li><li>为调用这个目标地址设置重试策略</li></ul><h3 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h3><p><code>DestinationRule</code> 是 Istio 流量路由功能的重要组成部分。一个 <code>VirtualService</code> 可以看作是如何将流量分发到给定的目标地址，然后调用 <code>DestinationRule</code> 来配置分发到该目标地址的流量。<code>DestinationRule</code> 在 <code>VirtualService</code> 的路由规则之后起作用(即在 <code>VirtualService</code> 的 <code>match</code> -&gt; <code>route</code> -&gt; <code>destination</code> 之后起作用，此时流量已经分发到真实的 <code>Service</code> 上)，应用于真实的目标地址。</p><p>特别地，可以使用 <code>DestinationRule</code> 来指定命名的服务子集，例如根据版本对服务的实例进行分组，然后通过 <code>VirtualService</code> 的路由规则中的服务子集将控制流量分发到不同服务的实例中。</p><p><code>DestinationRule</code> 允许在调用完整的目标服务或特定的服务子集(如倾向使用的负载均衡模型，TLS 安全模型或断路器)时自定义 Envoy流量策略。Istio 默认会使用轮询策略，此外 Istio 也支持如下负载均衡模型，可以在 <code>DestinationRule</code> 中使用这些模型，将请求分发到特定的服务或服务子集。</p><ul><li>Random：将请求转发到一个随机的实例上</li><li>Weighted：按照指定的百分比将请求转发到实例上</li><li>Least requests：将请求转发到具有最少请求数目的实例上</li></ul><p>下面的 <code>DestinationRule</code> 使用不同的负载均衡策略为 my-svc 目的服务配置了3个不同的 Subset</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-destination-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">my-svc</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span>     <span class="comment">#默认的负载均衡策略模型为随机</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">RANDOM</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  <span class="comment">#subset1，将流量转发到具有标签 version:v1 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  <span class="comment">#subset2，将流量转发到具有标签 version:v2 的 deployment 对应的服务上,指定负载均衡为轮询</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span>   <span class="comment">#subset3，将流量转发到具有标签 version:v3 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>每个子集由一个或多个 <code>labels</code> 定义，对应 Kubernetes 中的对象(如 <code>Pod</code> )的 key/value 对。这些标签定义在 Kubernetes 服务的 deployment 的 metadata 中，用于标识不同的版本。</p><p>除了定义子集外，<code>DestinationRule</code> 还定义了该目的地中所有子集的默认流量策略，以及仅覆盖该子集的特定策略。默认的策略定义在 <code>subset</code> 字段之上，为 <code>v1</code> 和 <code>v3</code> 子集设置了随机负载均衡策略，在 <code>v2</code> 策略中使用了轮询负载均衡。</p><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Gateway 用于管理进出网格的流量，指定可以进入或离开网格的流量。Gateway 配置应用于网格边缘的独立的 Envoy代理上，而不是服务负载的 Envoy 代理上。</p><p>与其他控制进入系统的流量的机制(如 Kubernetes Ingress API)不同，Istio gateway 允许利用 Istio 的流量路由的强大功能和灵活性。Istio 的 gateway 资源仅允许配置 4-6 层的负载属性，如暴露的端口，TLS 配置等等，但结合 Istio 的 <code>VirtualService</code>，就可以像管理 Istio 网格中的其他数据面流量一样管理 Gateway 的流量。</p><p>Gateway 主要用于管理 Ingress 流量，但也可以配置 Egress Gateway。通过 Egress Gateway 可以配置流量离开网格的特定节点，限制哪些服务可以访问外部网络，或通过 Egress 安全控制来提高网格的安全性。Gateway 可以用于配置为一个纯粹的内部代理。</p><p>Istio (通过 <code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code> 参数)提供了一些预配置的 Gateway 代理，<code>default</code> profile 下仅会部署 Ingress Gateway。Gateway 可以通过部署文件进行部署，也可以单独部署。</p><p>下面是 <code>default</code> profile 默认安装的 Ingress</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get gw</span><br><span class="line">NAME               AGE</span><br><span class="line">bookinfo-gateway   28h</span><br></pre></td></tr></table></figure><p>可以看到该 ingress 就是一个普通的 <code>Pod</code>，该 <code>Pod</code> 仅包含一个 Istio-proxy 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n istio-system |grep ingress</span><br><span class="line">istio-ingressgateway-64f6f9d5c6-qrnw2 1/1 Running 0 4d20h</span><br></pre></td></tr></table></figure><p>下面是一个 Gateway 的例子，用于配置外部 HTTPS 的 ingress 流量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-host-gwy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>              <span class="comment">#指定 gateway 配置下发的代理，如具有标签 app: my-gateway-controller 的 pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-gateway-controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span>                <span class="comment">#gateway pod 暴露的端口信息</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span>                <span class="comment">#外部流量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/tmp/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/tmp/tls.key</span></span><br></pre></td></tr></table></figure><p>上述 Gateway 配置允许来自 <code>ext-host.example.com</code> 流量进入网格的 443 端口，但没有指定该流量的路由。(此时流量只能进入网格，但没有指定处理该流量的服务，因此需要与 <code>VirtualService</code> 进行绑定)</p><p>为了为 Gateway 指定路由，需要通过 <code>VirtualService</code> 的 <code>Gateway</code> 字段，将 <code>Gateway</code> 绑定到一个 <code>VirtualService</code> 上，将来自 <code>ext-host.example.com</code> 流量引入一个 <code>VirtualService</code>，<code>hosts</code> 可以是通配符，表示引入匹配到的流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">virtual-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">  <span class="attr">gateways:</span>        <span class="comment">#将 gateway "ext-host-gwy" 绑定到 virtual service "virtual-svc"上</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host-gwy</span></span><br></pre></td></tr></table></figure><p>Egress Gateway 提供了对网格的出口流量进行统一管控的功能，在安装 Istio 时默认是不开启的。可以使用以下命令查看是否开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod -l istio=egressgateway -n istio-system</span></span><br></pre></td></tr></table></figure><p>若没有开启，使用以下命令添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl manifest apply --<span class="built_in">set</span> values.global.istioNamespace=istio-system \</span><br><span class="line">    --<span class="built_in">set</span> values.gateways.istio-egressgateway.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Egress Gateway 的一个简单示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-egressgateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">egressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">edition.cnn.com</span></span><br></pre></td></tr></table></figure><p>可以看出，与 Ingress Gateway 不同，Egress Gateway 使用有 <code>istio: egressgateway</code> 标签的 Pod 来代理流量，实际上这也是一个 Envoy 代理。当网格内部需要访问 <code>edition.cnn.com</code> 这个地址时，流量将会统一先转发到 Egress Gateway 上，再由 Egress Gateway 将流量转发到 <code>edition.cnn.com</code> 上。</p><h3 id="ServiceEntry"><a href="#ServiceEntry" class="headerlink" title="ServiceEntry"></a>ServiceEntry</h3><p>Istio 支持对接 Kubernetes、Consul 等多种不同的注册中心，控制平面<code>Pilot</code>启动时，会从指定的注册中心获取 <code>Service Mesh</code> 集群的服务信息和实例列表，并将这些信息进行处理和转换，然后通过 xDS 下发给对应的数据平面，保证服务之间可以互相发现并正常访问。</p><p>同时，由于这些服务和实例信息都来源于服务网格内部，Istio 无法从注册中心直接获取网格外的服务，导致不利于网格内部与外部服务之间的通信和流量管理。为此，Istio 引入 ServiceEntry 实现对外通信和管理。</p><p>使用 ServiceEntry 可以将外部的服务条目添加到 Istio 内部的服务注册表中，以便让网格中的服务能够访问并路由到这些手动指定的服务。ServiceEntry 描述了服务的属性（DNS 名称、VIP、端口、协议、端点）。这些服务可能是位于网格外部（如，web APIs），也可能是处于网格内部但不属于平台服务注册表中的条目（如，需要和 Kubernetes 服务交互的一组虚拟机服务）。</p><h4 id="ServiceEntry-示例和属性介绍"><a href="#ServiceEntry-示例和属性介绍" class="headerlink" title="ServiceEntry 示例和属性介绍"></a>ServiceEntry 示例和属性介绍</h4><p>对于网格外部的服务，下面的 ServiceEntry 示例表示网格内部的应用通过 https 访问外部的 API。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.google.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure><p>对于在网格内部但不属于平台服务注册表的服务，使用下面的示例可以将一组在非托管 VM 上运行的 MongoDB 实例添加到 Istio 的注册中心，以便可以将这些服务视为网格中的任何其他服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-svc-mongocluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mymongodb.somedomain</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.192</span><span class="number">.192</span><span class="number">.192</span><span class="string">/24</span> <span class="comment"># VIPs</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">27018</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">MONGO</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_INTERNAL</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">STATIC</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p>结合上面给出的示例，这里对 ServiceEntry 涉及的关键属性解释如下：</p><ul><li><code>hosts</code>: 表示与该 ServiceEntry 相关的主机名，可以是带有通配符前缀的 DNS 名称。</li><li><code>address</code>: 与服务相关的虚拟 IP 地址，可以是 CIDR 前缀的形式。</li><li><code>ports</code>: 和外部服务相关的端口，如果外部服务的 endpoints 是 Unix socket 地址，这里必须只有一个端口。</li><li><code>location</code>: 用于指定该服务属于网格内部（MESH_INTERNAL）还是外部（MESH_EXTERNAL）。</li><li><code>resolution</code>: 主机的服务发现模式，可以是 NONE、STATIC、DNS。</li><li><code>endpoints</code>: 与服务相关的一个或多个端点。</li><li><code>exportTo</code>: 用于控制 ServiceEntry 跨命名空间的可见性，这样就可以控制在一个命名空间下定义的资源对象是否可以被其他命名空间下的 <code>Sidecar</code>、Gateway 和 VirtualService 使用。目前支持两种选项，”.” 表示仅应用到当前命名空间，”*” 表示应用到所有命名空间。</li></ul><h4 id="使用-ServiceEntry-访问外部服务"><a href="#使用-ServiceEntry-访问外部服务" class="headerlink" title="使用 ServiceEntry 访问外部服务"></a>使用 ServiceEntry 访问外部服务</h4><p>Istio 提供了三种访问外部服务的方法：</p><ol><li>允许 <code>Sidecar</code> 将请求传递到未在网格内配置过的任何外部服务。使用这种方法时，无法监控对外部服务的访问，也不能利用 Istio 的流量控制功能。</li><li>配置 ServiceEntry 以提供对外部服务的受控访问。这是 Istio 官方推荐使用的方法。</li><li>对于特定范围的 IP，完全绕过 <code>Sidecar</code>。仅当出于性能或其他原因无法使用 <code>Sidecar</code> 配置外部访问时，才建议使用该配置方法。</li></ol><p>这里，我们重点讨论第 2 种方式，也就是使用 ServiceEntry 完成对网格外部服务的受控访问。</p><p>对于 <code>Sidecar</code> 对外部服务的处理方式，Istio 提供了两种选项:</p><ul><li><code>ALLOW_ANY</code>：默认值，表示 Istio 代理允许调用未知的外部服务。上面的第一种方法就使用了该配置项。</li><li><code>REGISTRY_ONLY</code>：Istio 代理会阻止任何没有在网格中定义的 HTTP 服务或 ServiceEntry 的主机。</li></ul><p>可以使用下面的命令查看当前所使用的模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | grep -o <span class="string">"mode: ALLOW_ANY"</span></span><br><span class="line">mode: ALLOW_ANY</span><br></pre></td></tr></table></figure><p>如果当前使用的是 <code>ALLOW_ANY</code> 模式，可以使用下面的命令切换为 <code>REGISTRY_ONLY</code> 模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | sed <span class="string">'s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g'</span> | kubectl replace -n istio-system -f -</span><br><span class="line">configmap <span class="string">"istio"</span> replaced</span><br></pre></td></tr></table></figure><p>在 <code>REGISTRY_ONLY</code> 模式下，需要使用 ServiceEntry 才能完成对外部服务的访问。当创建如下的 ServiceEntry 时，服务网格内部的应用就可以正常访问 httpbin.org 服务了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure><h4 id="管理外部流量"><a href="#管理外部流量" class="headerlink" title="管理外部流量"></a>管理外部流量</h4><p>使用 ServiceEntry 可以使网格内部服务发现并访问外部服务，除此之外，还可以对这些到外部服务的流量进行管理。结合 VirtualService 为对应的 ServiceEntry 配置外部服务访问规则，如请求超时、故障注入等，实现对指定服务的受控访问。</p><p>下面的示例就是为外部服务 httpbin.org 设置了超时时间，当请求时间超过 3s 时，请求就会直接中断，避免因外部服务访问时延过高而影响内部服务的正常运行。由于外部服务的稳定性通常无法管控和监测，这种超时机制对内部服务的正常运行具有重要意义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>同样的，我们也可以为 ServiceEntry 设置故障注入规则，为系统测试提供基础。下面的示例表示为所有访问 <code>httpbin.org</code> 服务的请求注入一个403错误。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">httpbin-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line"> <span class="attr">http:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">       <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">   <span class="attr">fault:</span></span><br><span class="line">     <span class="attr">abort:</span></span><br><span class="line">       <span class="attr">percent:</span> <span class="number">100</span></span><br><span class="line">       <span class="attr">httpStatus:</span> <span class="number">403</span></span><br></pre></td></tr></table></figure><h3 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h3><p>在默认的情况下，Istio 中所有 Pod 中的 Envoy 代理都是可以被寻址的。然而在某些场景下，我们为了做资源隔离，希望只访问某些 Namespace 下的资源。这个时候，我们就可以使用 Sidecar配置来实现。下面是一个简单的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sidecar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"./*"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"istio-system/*"</span></span><br></pre></td></tr></table></figure><p>该示例就规定了在命名空间为 bookinfo 下的所有服务仅可以访问本命名空间下的服务以及 <code>istio-system</code> 命名空间下的服务。</p><h2 id="弹性功能"><a href="#弹性功能" class="headerlink" title="弹性功能"></a>弹性功能</h2><p>除了最核心的路由和流量转移功能外，Istio 还提供了一定的弹性功能，目前支持超时、重试和熔断。</p><h3 id="Request-Timeouts"><a href="#Request-Timeouts" class="headerlink" title="Request Timeouts"></a>Request Timeouts</h3><p>如果程序请求长时间无法返回结果，则需要设置超时机制，超过设置的时间则返回错误信息。这样做既可以节约等待时消耗的资源，也可以避免由于级联错误引起的一系列问题。</p><p>设置超时的方式也有很多种，比如通过修改代码在应用程序侧设置请求超时时间，但是这样很不灵活，也容易出现遗漏的现象，而 Istio 则可以在基础设施层解决这一问题。在 Istio 里添加超时非常简单，只需要在路由配置里添加 <code>timeout</code> 这个关键字就可以实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><h3 id="Retries"><a href="#Retries" class="headerlink" title="Retries"></a>Retries</h3><p>在网络环境不稳定的情况下，会出现暂时的网络不可达现象，这时需要重试机制，通过多次尝试来获取正确的返回信息。重试逻辑可以写业务代码中，比如 Bookinfo 应用中的<code>productpage</code>服务就存在硬编码重试，而 Istio 可以通过简单的配置来实现重试功能，让开发人员无需关注重试部分的代码实现，专心实现业务代码。在 Istio 里添加超时和重试都非常简单，只需要在路由配置里添 <code>retry</code> 这个关键字就可以实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">2s</span></span><br></pre></td></tr></table></figure><h3 id="Circuit-Breaking"><a href="#Circuit-Breaking" class="headerlink" title="Circuit Breaking"></a>Circuit Breaking</h3><p>熔断是一种非常有用的过载保护手段，可以避免服务的级联失败。在熔断器中，设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。熔断适用于在负载均衡池中的“真实”网格目标地址，可以在 DestinationRule 中配置熔断器阈值，让配置适用于服务中的每个主机。</p><p>Istio 里面的熔断需要在自定义资源 <code>DestinationRule</code> 的 <code>TrafficPolicy</code> 里进行设置。下面的示例将 v1 子集的<code>reviews</code>服务工作负载的并发连接数限制为 100：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">connectionPool:</span></span><br><span class="line">        <span class="attr">tcp:</span></span><br><span class="line">          <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Istio 还提供了对流量进行调试的能力，包括故障注入和流量镜像。对流量进行调试可以让系统具有更好的容错能力，也方便我们在问题排查时通过调试来快速定位原因所在。</p><h3 id="Fault-Injection"><a href="#Fault-Injection" class="headerlink" title="Fault Injection"></a>Fault Injection</h3><p>在一个微服务架构的系统中，为了让系统达到较高的健壮性要求，通常需要对系统做定向错误测试。比如电商中的订单系统、支付系统等若出现故障那将是非常严重的生产事故，因此必须在系统设计前期就需要考虑多样性的异常故障并对每一种异常设计完善的恢复策略或优雅的回退策略，尽全力规避类似事故的发生，使得当系统发生故障时依然可以正常运作。而在这个过程中，服务故障模拟一直以来是一个非常繁杂的工作，于是在这样的背景下就衍生出了故障注入技术手段，故障注入是用来模拟上游服务请求响应异常行为的一种手段。通过人为模拟上游服务请求的一些故障信息来检测下游服务的故障策略是否能够承受这些故障并进行自我恢复。</p><p>Istio 提供了一种无侵入式的故障注入机制，让开发测试人员在不用调整服务程序的前提下，通过配置即可完成对服务的异常模拟。Istio 1.5 仅支持网络层的故障模拟，即支持模拟上游服务的处理时长、服务异常状态、自定义响应状态码等故障信息，暂不支持对于服务主机内存、CPU 等信息故障的模拟。他们都是通过配置上游主机的 VirtualService 来实现的。当我们在 VirtualService 中配置了故障注入时，上游服务的 Envoy代理在拦截到请求之后就会做出相应的响应。</p><p>目前，Istio 提供两种类型的故障注入，abort 类型与 delay 类型。</p><ul><li><strong>abort</strong>：非必配项，配置一个 Abort 类型的对象。用来注入请求异常类故障。简单的说，就是用来模拟上游服务对请求返回指定异常码时，当前的服务是否具备处理能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-faultabort" target="_blank" rel="external nofollow noopener noreferrer">config.filter.http.fault.v2.FaultAbort</a> 配置项，当 VirtualService 资源应用时，Envoy将会该配置加载到过滤器中并处理接收到的流量。</li><li><strong>delay</strong>：非必配项，配置一个 Delay 类型的对象。用来注入延时类故障。通俗一点讲，就是人为模拟上游服务的响应时间，测试在高延迟的情况下，当前的服务是否具备容错容灾的能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/fault/v2/fault.proto#envoy-api-msg-config-filter-fault-v2-faultdelay" target="_blank" rel="external nofollow noopener noreferrer">config.filter.fault.v2.FaultDelay</a> 配置型，同样也是在应用 Istio 的 VirtualService 资源时，Envoy将该配置加入到过滤器中。</li></ul><p>实际上，Istio 的故障注入正是基于 Envoy的 config.filter.http.fault.v2.HTTPFault 过滤器实现的，它的局限性也来自于 Envoy故障注入机制的局限性。对于 Envoy的 HttpFault 的详细介绍请参考 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-httpfault" target="_blank" rel="external nofollow noopener noreferrer">Envoy 文档</a>。对比 Istio 故障注入的配置项与 Envoy故障注入的配置项，不难发现，Istio 简化了对于故障控制的手段，去掉了 Envoy中通过 HTTP header 控制故障注入的配置。</p><h4 id="HTTPFaultInjection-Abort"><a href="#HTTPFaultInjection-Abort" class="headerlink" title="HTTPFaultInjection.Abort"></a>HTTPFaultInjection.Abort</h4><ul><li><strong>httpStatus</strong>：必配项，是一个整型的值。表示注入 HTTP 请求的故障状态码。</li><li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li><li><strong>percent</strong>：已经废弃的一个配置，与 percentage 配置功能一样，已经被 percentage 代替。</li></ul><p>如下的配置表示对 <code>v1</code> 版本的 <code>ratings.prod.svc.cluster.local</code> 服务访问的时候进行故障注入，<code>0.1</code>表示有千分之一的请求被注入故障， <code>400</code> 表示故障为该请求的 HTTP 响应码为 <code>400</code> 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">abort:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">httpStatus:</span> <span class="number">400</span></span><br></pre></td></tr></table></figure><h4 id="HTTPFaultInjection-Delay"><a href="#HTTPFaultInjection-Delay" class="headerlink" title="HTTPFaultInjection.Delay"></a>HTTPFaultInjection.Delay</h4><ul><li><strong>fixedDelay</strong>：必配项，表示请求响应的模拟处理时间。格式为：<code>1h/1m/1s/1ms</code>， 不能小于 <code>1ms</code>。</li><li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li><li><strong>percent</strong>：已经废弃的一个配置，与 <code>percentage</code> 配置功能一样，已经被 <code>percentage</code> 代替。</li></ul><p>如下的配置表示对 <code>v1</code> 版本的 <code>reviews.prod.svc.cluster.local</code> 服务访问的时候进行延时故障注入，<code>0.1</code> 表示有千分之一的请求被注入故障，<code>5s</code> 表示<code>reviews.prod.svc.cluster.local</code> 延时 <code>5s</code>返回。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure><h3 id="Mirroring"><a href="#Mirroring" class="headerlink" title="Mirroring"></a>Mirroring</h3><p>流量镜像（Mirroring / traffic-shadow），也叫作影子流量，就是通过复制一份请求并把它发送到镜像服务，从而实现流量的复制功能。流量镜像的主要应用场景有以下几种：最主要的就是进行<strong>线上问题排查</strong>。</p><p>一般情况下，因为系统环境，特别是数据环境、用户使用习惯等问题，我们很难在开发环境中模拟出真实的生产环境中出现的棘手问题，同时生产环境也不能记录太过详细的日志，因此很难定位到问题。有了流量镜像，我们就可以把真实的请求发送到镜像服务，再打开 debug 日志来查看详细的信息。除此以外，还可以通过它来观察生产环境的请求处理能力，比如在镜像服务进行压力测试。也可以将复制的请求信息用于数据分析。流量镜像在 Istio 里实现起来也非常简单，只需要在路由配置中通添加<code>mirror</code>关键字即可。</p><h4 id="流量镜像能够为我们带来什么"><a href="#流量镜像能够为我们带来什么" class="headerlink" title="流量镜像能够为我们带来什么"></a>流量镜像能够为我们带来什么</h4><p>很多情况下，当我们对服务做了重构，或者我们对项目做了重大优化时，怎么样保证服务是健壮的呢？在传统的服务里，我们只能通过大量的测试，模拟在各种情况下服务的响应情况。虽然也有手工测试、自动化测试、压力测试等一系列手段去检测它，但是测试本身就是一个样本化的行为，即使测试人员再完善它的测试样例，无法全面的表现出线上服务的一个真实流量形态。往往当项目发布之后，总会出现一些意外，比如你服务里收到客户使用的某些数据库不认识的特殊符号，再比如用户在本该输入日期的输入框中输入了 “—” 字样的字符，又比如用户使用乱码替换你的 token 值批量恶意攻击服务等等，这样的情况屡见不鲜。数据的多样性，复杂性决定了开发人员在开发阶段根本是无法考虑周全的。</p><p>而流量镜像的设计，让这类问题得到了最大限度的解决。流量镜像讲究的不再是使用少量样本去评估一个服务的健壮性，而是在不影响线上坏境的前提下将线上流量持续的镜像到我们的预发布坏境中去，让重构后的服务在上线之前就结结实实地接受一波真实流量的冲击与考验，让所有的风险全部暴露在上线前夕，通过不断的暴露问题，解决问题让服务在上线前夕就拥有跟线上服务一样的健壮性。由于测试坏境使用的是真实流量，所以不管从流量的多样性，真实性，还是复杂性上都将能够得以展现，同时预发布服务也将表现出其最真实的处理能力和对异常的处理能力。运用这种模式，一方面，我们将不会再跟以前一样在发布服务前夕内心始终忐忑不安，只能祈祷上线之后不会出现问题。另一方面，当大量的流量流入重构服务之后，开发过程中难以评估的性能问题也将完完整整的暴露出来，此时开发人员将会考虑它服务的性能，测试人员将会更加完善他们的测试样例。通过暴露问题，解决问题，再暴露问题，再解决问题的方式循序渐进地完善预发布服务来增加我们上线的成功率。同时也变相的促进我们开发测试人员技能水平的提高。</p><p>当然，流量镜像的作用不仅仅只是解决上面这样的场景问题，我们可以根据它的特性，解决更多的问题。比如，假如我们在上线后突然发现一个线上问题，而这个问题在测试坏境中始终不能复现。那么这个时候我们就能利用它将异常流量镜像到一个分支服务中去，然后我们可以随意在这个分支服务上进行分析调试，这里所说的分支服务，可以是原服务的只用于问题分析而不处理正式业务的副本服务，也可以是一个只收集镜像流量的组件类服务。又比如突然需要收集某个时间段某些流量的特征数据做分析，像这种临时性的需求，使用流量镜像来处理非常合适，既不影响线上服务的正常运转，也达到了收集分析的目的。</p><h4 id="流量镜像的实现原理"><a href="#流量镜像的实现原理" class="headerlink" title="流量镜像的实现原理"></a>流量镜像的实现原理</h4><p>实际上在 Istio 中，服务间的通讯都是被 Envoy代理拦截并处理的， Istio 流量镜像的设计也是基于 Envoy特性实现的。它的流量转发如下图所示。可以看到，当流量进入到<code>Service A</code>时，因为在<code>Service A</code>的 Envoy代理上配置了流量镜像规则，那么它首先会将原始流量转发到<code>v1</code>版本的 <code>Service B</code>服务子集中去 。同时也会将相同的流量复制一份，异步地发送给<code>v2</code>版本的<code>Service B</code> 服务子集中去，可以明显的看到，<code>Service A</code> 发送完镜像流量之后并不关心它的响应情况。</p><p>在很多情况下，我们需要将真实的流量数据与镜像流量数据进行收集并分析，那么当我们收集完成后应该怎样区分哪些是真实流量，哪些是镜像流量呢？ 实际上，Envoy团队早就考虑到了这样的场景，他们为了区分镜像流量与真实流量，在镜像流量中修改了请求标头中 <code>host</code> 值来标识，它的修改规则是：在原始流量请求标头中的 <code>host</code> 属性值拼接上<code>“-shadow”</code> 字样作为镜像流量的 <code>host</code> 请求标头。</p><p>为了能够更清晰的对比出原始流量与镜像流量的区别，我们使用以下的一个示例来说明：</p><p>如下图所示，我们发起一个<code>http://istio.gateway.xxxx.tech/serviceB/request/info</code>的请求，请求首先进入了<code>istio-ingressgateway</code> ，它是一个 Istio 的 Gateway 资源类型的服务，它本身就是一个 Envoy代理。在这个例子里，就是它对流量进行了镜像处理。可以看到，它将流量转发给<code>v1</code>版本<code>Service B</code>服务子集的同时也复制了一份流量发送到了<code>v2</code>版本的<code>Service B</code>服务子集中去。</p><p><img alt="concepts-traffic-shadow-request" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-request.png"></p><p>在上面的请求链中，请求标头数据有什么变化呢？下图收集了它们请求标头中的所有信息，可以明显的对比出正式流量与镜像流量请求标头中<code>host</code>属性的区别（部分相同的属性值过长，这里只截取了前半段）。从图中我们可以看出，首先就是host属性值的不同，而区别就是多了一个<code>“-shadow”</code>的后缀。再者发现<code>x-forwarded-for</code>属性也不相同，<code>x-forwarded-for</code>协议头的格式是：<code>x-forwarded-for: client1, proxy1, proxy2</code>， 当流量经过 Envoy代理时这个协议头将会把代理服务的 IP 添加进去。实例中<code>10.10.2.151</code>是我们云主机的 IP，而<code>10.10.2.121</code>是<code>isito-ingressgateway</code>所对应<code>Pod</code>的 IP 。从这里也能看到，镜像流量是由<code>istio-ingressgatway</code>发起的。除了这两个请求标头的不同，其他配置项是完全一样的。</p><p><img alt="concepts-traffic-shadow-header" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-header.png"></p><h4 id="流量镜像的配置"><a href="#流量镜像的配置" class="headerlink" title="流量镜像的配置"></a>流量镜像的配置</h4><p>上面我们介绍了流量镜像的原理及使用场景，接下来我们再介绍下流量的镜像如何配置才能生效。在 Istio 架构里，镜像流量是借助于 VirtualService 这个资源中的 <code>HTTPRoute</code> 配置项的<code>mirror</code>与<code>mirrorPercent</code>这两项子配置项来实现的，这两个配置项的定义也是非常的简单。</p><ul><li><strong>mirror</strong>：配置一个 Destination 类型的对象，这里就是我们镜像流量转发的服务地址。具体的 <strong>VirtualService</strong> 配置与<strong>DestinationRule</strong> 对象配置属性请参考相关介绍页。</li><li><strong>mirrorPercent</strong>：配置一个数值，这个配置项用来指定有多少的原始流量将被转发到镜像流量服务中去，它的有效值为<code>0~100</code>，如果配置成<code>0</code>则表示不发送镜像流量。</li></ul><p>下面的例子就是我们在示例中使用到的<code>Service B</code>的镜像流量配置，其中，<code>mirror.host</code>配置项是配置一个域名或者在Istio 注册表中注册过的服务名称，可以看到，该配置指定了镜像流量需要发送的目标服务地址为<code>serviceB</code>。<code>mirror.subset</code>配置项配置一个<code>Service B</code>服务的服务子集名称 ，指定了要将镜像流量镜像到<code>v2</code>版本的<code>Service B</code>服务子集中去。<code>mirror_percent</code>配置将<code>100%</code>的真实流量进行镜像发送。所以下面的配置整体表示当流量到来时，将请求转发到<code>v1</code>版本的<code>service B</code>服务子集中，再以镜像的方式发送到<code>v2</code>版本的<code>service B</code>服务上一份，并将真实流量全部镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio.gateway.xxxx.tech</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingressgateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/serviceB</span></span><br><span class="line">    <span class="attr">rewrite:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">mirror:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">mirror_percent:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p><code>service B</code> 服务对应的 DestinationRule 配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 &lt;a href=&quot;../22cae0b8&quot;&gt;Istio 入门&lt;/a&gt; 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio 入门</title>
    <link href="http://houmin.cc/posts/22cae0b8/"/>
    <id>http://houmin.cc/posts/22cae0b8/</id>
    <published>2020-09-09T02:44:08.000Z</published>
    <updated>2020-09-11T07:17:06.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p><a id="more"></a><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>微服务应用最大的痛点就是处理服务间的通信，而这一问题的核心其实就是流量管理。首先我们来看看传统的微服务应用在没有 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#service-mesh" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh</a> 介入的情况下，是如何完成诸如金丝雀发布这样的路由功能的。我们假设不借助任何现成的第三方框架，一个最简单的实现方法，就是在服务间添加一个负载均衡（比如 Nginx）做代理，通过修改配置的权重来分配流量。这种方式使得对流量的管理和基础设施绑定在了一起，难以维护。</p><p>而使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 就可以轻松的实现各种维度的流量控制。下图是典型的金丝雀发布策略：根据权重把 5% 的流量路由给新版本，如果服务正常，再逐渐转移更多的流量到新版本。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的流量控制功能主要分为三个方面：</p><ul><li>请求路由和流量转移</li><li>弹性功能，包括熔断、超时、重试</li><li>调试能力，包括故障注入和流量镜像</li></ul><p>关于流量控制的更多内容，参考 <a href="../151719f0">Istio流量控制</a></p><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>安全对于微服务这样的分布式系统来说至关重要。与单体应用在进程内进行通信不同，网络成为了服务间通信的纽带，这使得它对安全有了更迫切的需求。比如为了抵御外来攻击，我们需要对流量进行加密；为保证服务间通信的可靠性，需要使用mTLS的方式进行交互；为控制不同身份的访问，需要设置不同粒度的授权策略。作为一个服务网格，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 提供了一整套完整的安全解决方案。它可以以透明的方式，为我们的微服务应用添加安全策略。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的安全架构是由多个组件协同完成的。Citadel 是负责安全的主要组件，用于密钥和证书的管理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 会将安全策略配置分发给 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 代理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 执行安全策略来实现访问控制。下图展示了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的安全架构和运作流程。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-secure-arch.svg"></p><p>关于安全管理的更多内容，参考 <a href="../">Istio安全管理</a></p><h3 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h3><p>面对复杂的应用环境和不断扩展的业务需求，即使再完备的测试也难以覆盖所有场景，无法保证服务不会出现故障。正因为如此，才需要“可观察性”来对服务的运行时状态进行监控、上报、分析，以提高服务可靠性。具有可观察性的系统，可以在服务出现故障时大大降低问题定位的难度，甚至可以在出现问题之前及时发现问题以降低风险。具体来说，可观察性可以：</p><ul><li>及时反馈异常或者风险使得开发人员可以及时关注、修复和解决问题（告警）；</li><li>出现问题时，能够帮助快速定位问题根源并解决问题，以减少服务损失（减损）；</li><li>收集并分析数据，以帮助开发人员不断调整和改善服务（持续优化）。</li></ul><p>而在微服务治理之中，随着服务数量大大增加，服务拓扑不断复杂化，可观察性更是至关重要。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 自然也不可能缺少对可观察性的支持。它会为所有的服务间通信生成详细的遥测数据，使得网格中每个服务请求都可以被观察和跟踪。开发人员可以凭此定位故障，维护和优化相关服务。而且，这一特性的引入无需侵入被观察的服务。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 一共提供了三种不同类型的数据从不同的角度支撑起其可观察性：</p><ul><li>指标（Metrics）</li><li>日志（Access Logs）</li><li>分布式追踪（Distributed Traces）</li></ul><p>关于可观测行的更多内容，参考 <a href="../">Istio可观测性</a></p><h2 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h2><p>Istio的架构由<strong>控制平面</strong>和<strong>数据平面</strong>两个部分组成。</p><ul><li>数据平面：由整个网格内的sidecar代理组成，每个sidecar代理会接管流入和流出服务的流量，并配合控制平面完成流量控制等方面的内容。</li><li>控制平面：负责控制和管理数据平面的sidecar代理，完成配置的分发、服务发现和授权鉴权等功能。</li></ul><p>控制平面是 Istio 在原有服务网格产品上，首次提出的架构，实现了对于数据平面的统一管理。</p><p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><h4 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h4><p><code>Pilot</code> 组件的主要功能是将路由规则等配置信息转换为 sidecar 可以识别的信息，并下发给数据平面。可以把它简单的理解为是一个<strong>配置分发器</strong>（dispatcher），并辅助 sidecar 完成流量控制相关的功能。它管理sidecar代理之间的路由流量规则，并配置故障恢复功能，如超时、重试和熔断。</p><p><img alt="Istio Pilot Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot-arch.svg"></p><p>上图显示了Pilot的基本架构，它主要由以下几个部分组成：</p><h5 id="Abstract-Model"><a href="#Abstract-Model" class="headerlink" title="Abstract Model"></a>Abstract Model</h5><p>为了实现对不同服务注册中心 （Kubernetes、consul） 的支持，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 需要对不同的输入来源的数据有一个统一的存储格式，也就是抽象模型。抽象模型中定义的关键成员包括 HostName（Service名称）、Ports（Service端口）、Address（Service ClusterIP）、Resolution （负载均衡策略） 等。</p><h5 id="Platform-Adapters"><a href="#Platform-Adapters" class="headerlink" title="Platform Adapters"></a>Platform Adapters</h5><p>借助平台适配器 Pilot 可以实现服务注册中心数据到抽象模型之间的数据转换。例如 Pilot 中的 Kubernetes 适配器通过 Kubernetes API 服务器得到 Kubernetes 中 Service 和 Pod 的相关信息，然后翻译为抽象模型提供给 Pilot 使用。通过平台适配器模式，Pilot 还可以从 Consul 等平台中获取服务信息，还可以开发适配器将其他提供服务发现的组件集成到 Pilot 中。</p><h5 id="xDS-API"><a href="#xDS-API" class="headerlink" title="xDS API"></a>xDS API</h5><p>Pilot 使用了一套起源于 Envoy 项目的标准数据面 API 来将服务信息和流量规则下发到数据面的 sidecar 中。这套标准数据面 API，也叫 xDS。Sidecar 通过 xDS API 可以动态获取 Listener （监听器）、Route （路由）、<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#cluster" target="_blank" rel="external nofollow noopener noreferrer">Cluster</a> （集群）及 Endpoint （集群成员）配置：</p><ul><li>LDS，Listener 发现服务：Listener 监听器控制 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 启动端口监听（目前只支持 TCP 协议），并配置 L3/L4 层过滤器，当网络连接达到后，配置好的网络过滤器堆栈开始处理后续事件。</li><li>RDS，Router 发现服务：用于 HTTP 连接管理过滤器动态获取路由配置，路由配置包含 HTTP 头部修改（增加、删除 HTTP 头部键值），virtual hosts （虚拟主机），以及 virtual hosts 定义的各个路由条目。</li><li>CDS，Cluster发现服务：用于动态获取 Cluster 信息。</li><li>EDS，Endpoint 发现服务：用于动态维护端点信息，端点信息中还包括负载均衡权重、金丝雀状态等，基于这些信息，Sidecar 可以做出智能的负载均衡决策。</li></ul><h5 id="User-API"><a href="#User-API" class="headerlink" title="User API"></a>User API</h5><p>Pilot 还定义了一套用户 API， 用户 API 提供了面向业务的高层抽象，可以被运维人员理解和使用。</p><p>运维人员使用该 API 定义流量规则并下发到 Pilot，这些规则被 Pilot 翻译成数据面的配置，再通过标准数据面 API 分发到 sidecar 实例，可以在运行期对微服务的流量进行控制和调整。</p><p>通过运用不同的流量规则，可以对网格中微服务进行精细化的流量控制，如按版本分流、断路器、故障注入、灰度发布等。</p><p>关于 Pilot 的具体实现，可以参考 <a href="../">Istio Pilot 模块分析</a></p><h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><p><code>Citadel</code> 是 Istio 中专门负责安全的组件，内置有身份和证书管理功能，可以实现较为强大的授权和认证等操作，在1.5 版本之后取消了独立进程，作为一个模块被整合在 istiod 中。</p><p>总体来说，Istio 在安全架构方面主要包括以下内容：</p><ul><li>证书签发机构（CA）负责密钥和证书管理</li><li>API 服务器将安全配置分发给数据平面</li><li>客户端、服务端通过代理安全通信</li><li>Envoy 代理管理遥测和审计</li></ul><p>Istio 的身份标识模型使用一级服务标识来确定请求的来源，它可以灵活的标识终端用户、工作负载等。在平台层面，Istio 可以使用类似于服务名称来标识身份，或直接使用平台提供的服务标识。比如 Kubernetes 的 ServiceAccount，AWS IAM 用户、角色账户等。</p><p>在身份和证书管理方面，Istio 使用 X.509 证书，并支持密钥和证书的自动轮换。从 1.1 版本开始，Istio 开始支持安全发现服务器（SDS），随着不断的完善和增强，1.5 版本 SDS 已经成为默认开启的组件。Citadel 以前有两个功能：将证书以 Secret 的方式挂载到命名空间里；通过 SDS gRPC 接口与 nodeagent（已废弃）通信。目前 Citadel 只需要完成与 SDS 相关的工作，其他功能被移动到了 istiod 中。</p><p>关于Citadel的更多内容，参考 <a href="../">Istio安全管理</a></p><h4 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h4><p><code>Galley</code> 是 Istio 1.1 版本中新增加的组件，其目的是将 <code>Pilot</code> 和底层平台（如 Kubernetes）进行解耦。它分担了原本 <code>Pilot</code> 的一部分功能，主要负责配置的验证、提取和处理等功能。</p><h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><p>Istio 数据平面核心是以 sidecar 模式运行的智能代理。Sidecar 模式将数据平面核心组件部署到单独的流程或容器中，以提供隔离和封装。Sidecar 应用与父应用程序共享相同的生命周期，与父应用程序一起创建和退出。Sidecar 应用附加到父应用程序，并为应用程序提供额外的特性支持。</p><p>如下图所示，数据平面的 sidecar 代理可以调节和控制微服务之间所有的网络通信，每个服务 Pod 启动时会伴随启动 <code>istio-init</code> 和 proxy 容器。 </p><ul><li><code>istio-init</code> 容器主要功能是初始化 Pod 网络和对 Pod设置 iptable 规则，设置完成后自动结束。</li><li>Proxy 容器会启动两个服务：<code>istio-agent</code> 以及网络代理组件<ul><li><code>istio-agent</code>  的作用是同步管理数据，启动并管理网络代理服务进程，上报遥测数据</li><li>网络代理组件则根据管理策略完成流量管控、生成遥测数据。</li></ul></li></ul><p>数据平面真正触及到对网络数据包的相关操作，是上层控制平面策略的具体执行者。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-data-plane-arch.png"></p><p>Envoy 是 Istio 中默认的数据平面 Sidecar 代理，关于 Sidecar 是如何实现自动注入和流量劫持，以及Sidecar的流量路由机制如何实现，更多可参考 <a href="../">Envoy系列文章</a> 。</p><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>这里介绍在 Kubernetes 环境下安装 Istio，在开始之前，你需要有一个 Kubernetes 运行环境。</p><p>从 Istio v1.7 版本开始，Istio官方推荐使用 istioctl 安装。下面是安装步骤：</p><ul><li>在 <a href="https://github.com/istio/istio/releases" target="_blank" rel="external nofollow noopener noreferrer">Istio release</a> 页面下载与操作系统匹配的安装包，并将其解压。这里可以直接用Istio提供的脚本：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/istio/istio/release-1.7/release/downloadIstioCandidate.sh | sh -</span><br><span class="line">$  [root@VM-1-28-centos istio]<span class="comment"># ls </span></span><br><span class="line">istio-1.7.0  istio-1.7.0-linux-amd64.tar.gz</span><br><span class="line">$ [root@VM-1-28-centos istio]<span class="built_in">cd</span> istio-1.7.0</span><br><span class="line">$ [root@VM-1-28-centos istio-1.7.0]<span class="comment"># tree -L 2</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── istioctl</span><br><span class="line">├── LICENSE</span><br><span class="line">├── manifests</span><br><span class="line">│   ├── charts</span><br><span class="line">│   ├── deploy</span><br><span class="line">│   ├── examples</span><br><span class="line">│   └── profiles</span><br><span class="line">├── manifest.yaml</span><br><span class="line">├── README.md</span><br><span class="line">├── samples</span><br><span class="line">│   ├── addons</span><br><span class="line">│   ├── bookinfo</span><br><span class="line">│   ├── certs</span><br><span class="line">│   ├── cross-network-gateway</span><br><span class="line">│   ├── custom-bootstrap</span><br><span class="line">│   ├── external</span><br><span class="line">│   ├── fortio</span><br><span class="line">│   ├── health-check</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   ├── httpbin</span><br><span class="line">│   ├── https</span><br><span class="line">│   ├── kubernetes-blog</span><br><span class="line">│   ├── operator</span><br><span class="line">│   ├── rawvm</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── security</span><br><span class="line">│   ├── sleep</span><br><span class="line">│   ├── tcp-echo</span><br><span class="line">│   └── websockets</span><br><span class="line">└── tools</span><br><span class="line">    ├── certs</span><br><span class="line">    ├── convert_RbacConfig_to_ClusterRbacConfig.sh</span><br><span class="line">    ├── dump_kubernetes.sh</span><br><span class="line">    ├── _istioctl</span><br><span class="line">    └── istioctl.bash</span><br><span class="line"></span><br><span class="line">27 directories, 9 files</span><br></pre></td></tr></table></figure><p>安装目录内容： </p><div class="table-container"><table><thead><tr><th>目录</th><th>包含内容</th></tr></thead><tbody><tr><td><code>bin</code></td><td>包含 istioctl 的客户端文件</td></tr><tr><td><code>manifests</code></td><td>包含 各种部署的 manifests</td></tr><tr><td><code>samples</code></td><td>包含示例应用程序</td></tr><tr><td><code>tools</code></td><td>包含用于性能测试和在本地机器上进行测试的脚本</td></tr></tbody></table></div><ul><li>将<code>istioctl</code>客户端路径加入 <code>$PATH</code> 中，从而可以使用 istioctl 命令行工具</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(<span class="built_in">pwd</span>)/bin</span><br></pre></td></tr></table></figure><ul><li>安装 <code>demo</code> 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo</span><br><span class="line">✔ Istio core installed</span><br><span class="line">✔ Istiod installed</span><br><span class="line">✔ Egress gateways installed</span><br><span class="line">✔ Ingress gateways installed</span><br><span class="line">✔ Installation complete</span><br></pre></td></tr></table></figure><ul><li>添加一个Namespace Label，使得之后在部署你的应用的时候，istio会自动注入Envoy sidecar 代理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label namespace default istio-injection=enabled</span><br></pre></td></tr></table></figure><h3 id="部署-Bookinfo"><a href="#部署-Bookinfo" class="headerlink" title="部署 Bookinfo"></a>部署 Bookinfo</h3><p>Bookinfo 是 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 社区官方推荐的示例应用之一。它可以用来演示多种 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的特性，并且它是一个异构的微服务应用。该应用由四个单独的微服务构成。 这个应用模仿了在线书店，可以展示书店中书籍的信息。例如页面上会显示一本书的描述，书籍的细节（ ISBN、页数等），以及关于这本书的一些评论。</p><p>Bookinfo 应用分为四个单独的微服务， 这些服务对 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个不同语言编写的服务构成，并且其中有一个应用会包含多个版本。</p><ul><li><code>productpage</code> 会调用 <code>details</code> 和 <code>reviews</code> 两个微服务，用来生成页面。</li><li><code>details</code> 中包含了书籍的信息。</li><li><code>reviews</code> 中包含了书籍相关的评论。它还会调用 <code>ratings</code> 微服务。</li><li><code>ratings</code> 中包含了由书籍评价组成的评级信息。</li></ul><p><code>reviews</code> 微服务有 3 个版本，可用来展示各服务之间的不同的调用链路：</p><ul><li>v1 版本不会调用 <code>ratings</code> 服务。</li><li>v2 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul><p>下图展示了这个应用的端到端架构：</p><p><img alt="Bookinfo Application without Istio" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo-noistio.svg"></p><ul><li>部署示例应用程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details unchanged</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings unchanged</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews unchanged</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage unchanged</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure><ul><li>之后应用起来，当每个Pod状态变为Ready的时候，sidecar也部署成功。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   172.18.252.45    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">kubernetes    ClusterIP   172.18.252.1     &lt;none&gt;        443/TCP    51d</span><br><span class="line">productpage   ClusterIP   172.18.253.238   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">ratings       ClusterIP   172.18.254.131   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">reviews       ClusterIP   172.18.255.63    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5974b67c8-z67st        2/2     Running   0          2m8s</span><br><span class="line">productpage-v1-797898bc54-frzdz   2/2     Running   0          2m8s</span><br><span class="line">ratings-v1-c6cdf8d98-xmhz8        2/2     Running   0          2m8s</span><br><span class="line">reviews-v1-8bdc65f7b-mjktx        2/2     Running   0          2m8s</span><br><span class="line">reviews-v2-868d77d678-4dzmn       2/2     Running   0          2m8s</span><br><span class="line">reviews-v3-6c9b646cb4-5tp9q       2/2     Running   0          2m8s</span><br></pre></td></tr></table></figure><ul><li>查看应用是否成功运行，通过给productpage发送请求，查看其返回</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> <span class="string">"<span class="variable">$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')</span>"</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">"&lt;title&gt;.*&lt;/title&gt;"</span></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><h3 id="集群外部访问应用"><a href="#集群外部访问应用" class="headerlink" title="集群外部访问应用"></a>集群外部访问应用</h3><p>到现在，Bookinfo 应用已经成功部署，我们在集群内部也已经可以访问，但是在集群外部还不能够访问。为了使得外部能够访问应用程序，我们需要创建一个<a href="https://istio.io/latest/docs/concepts/traffic-management/#gateways" target="_blank" rel="external nofollow noopener noreferrer">Istio Ingress Gateway</a>。</p><ul><li>将应用于istio gateway关联</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure><ul><li>确保配置上没有问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl analyze</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure><ul><li>确定Ingress的IP和Ports</li></ul><p>通过下面的命令来设置 <code>INGRESS_HOST</code> 和 <code>INGRESS_PORT</code>环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   172.18.252.12   49.233.242.233   15021:32663/TCP,80:31968/TCP,443:31588/TCP,31400:32002/TCP,15443:30652/TCP   18m</span><br></pre></td></tr></table></figure><p>这里显示 <code>EXTERNAL_IP</code> 已经变设置，表明当前环境下有一个可以使用的外部负载均衡器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="http2")].port&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="https")].port&#125;'</span>)</span><br></pre></td></tr></table></figure><ul><li>设定GATEWAY_URL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GATEWAY_URL</span></span><br><span class="line">49.233.242.233:80</span><br></pre></td></tr></table></figure><ul><li>确认外部访问是否成功：在浏览器直接访问 <code>http://&lt;GATE_WAYURL&gt;/productpage</code> 来访问Bookinfo应用</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-external-access.png"></p><h3 id="查看Dashboard"><a href="#查看Dashboard" class="headerlink" title="查看Dashboard"></a>查看Dashboard</h3><p>Istio集成了 <a href="https://istio.io/latest/docs/ops/integrations/" target="_blank" rel="external nofollow noopener noreferrer">一些</a> 遥测应用，他们可以帮助你对你的服务网格有直观的认识、展示网格的拓扑、分析网格的健康状态</p><ul><li>安装Kiali </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/addons</span><br><span class="line">$ <span class="keyword">while</span> ! kubectl <span class="built_in">wait</span> --<span class="keyword">for</span>=condition=available --timeout=600s deployment/kiali -n istio-system; <span class="keyword">do</span> sleep 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>访问Kiali</li></ul><p>官方教程指示使用 <code>istioctl dashboard kiali</code> 命令来打开浏览器访问 Kiali服务，但是我的 Kubernetes 集群在服务器上，这样显然不行，不要将 Kiali 服务暴露给外部。因为之前集群已经安装了 Traefik ，所以可以使用 Ingress来暴露。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kiali</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/kiali</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kiali</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">20001</span></span><br></pre></td></tr></table></figure><p>在命令行创建Ingress，打开浏览器访问 <code>http://&lt;NodeIP&gt;:&lt;TraefikWebNodePort&gt;/kiali</code> 即可访问Kiali</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-kiali.png"></p><p>在左侧导航栏点击Graph，选择default的命名空间，可以看到 <code>Bookinfo</code> 应用中各个服务间的关系：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-kiali.png"></p><p>到此为止，你的Istio和相关的服务已经在集群中完好的部署，关于其具体功能演示，参照 <a href="../151719f0">Istio流量控制</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://istio.io/latest/docs/setup/getting-started" target="_blank" rel="external nofollow noopener noreferrer">https://istio.io/latest/docs/setup/getting-started</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】开篇</title>
    <link href="http://houmin.cc/posts/ac3e3d15/"/>
    <id>http://houmin.cc/posts/ac3e3d15/</id>
    <published>2020-09-08T06:24:34.000Z</published>
    <updated>2020-09-14T04:13:40.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>Service Mesh 是一个<strong>基础设施层</strong>，用于处理<strong>服务到服务间</strong>的网络通信。<strong>云原生应用</strong>有着复杂的服务拓扑，Service Mesh负责在这些<strong>网络拓扑中实现请求的可靠传递</strong>。在实践中，Service Mesh通常实现为一组轻量级的<strong>网络代理</strong>，它们与应用程序部署在一起，但是<strong>对应用保持透明</strong>。</p></blockquote><p>本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。</p><a id="more"></a><h2 id="历史演进"><a href="#历史演进" class="headerlink" title="历史演进"></a>历史演进</h2><p>随着行业需求的推动，互联网服务从最早的仅有少数几台的大型服务器演变到成百上千的小型服务，服务架构也从最早期的单体式（Monolithic）到分布式（Distributed），再到微服务（Microservices）、容器化（Containerization）、容器编排（Container Orchestration），最后到服务网格（Service Mesh）、无服务器（Serverless）。</p><p>总结分布式系统的演进过程，我们可以看到一种通用的发展规律：</p><ul><li>首先是对每种情况提出临时解决方案</li><li>然后是更复杂的解决方案，类似于 library 以实现统一复用</li><li>随着对问题有更多的了解，开始将这些解决方案落实到 platform</li></ul><p>接下来我们会回顾从早期TCP/IP协议栈的广泛应用，到微服务时代从容器编排到服务网格的演进过程，并再次体会上述规律。</p><h3 id="计算机网络系统的演进"><a href="#计算机网络系统的演进" class="headerlink" title="计算机网络系统的演进"></a>计算机网络系统的演进</h3><p>从多台计算机开始通信以来，服务间通信是应用最为广泛的模式。以下图为例，ServiceA 和 ServiceB 可以是我们提供应用的服务端与客户端。在开发者开发这些服务的时候，需要借助底层的网络硬件和协议进行通信。这张图只是一个简化的师徒，省略了在代码操作的数据和通过线路发送接收的电信号之间转换的很多层。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc.png"></p><p>更加具体一点，把底层的网络协议栈加入，我们会看到下图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc-stack.png"></p><p>从上世纪50年代起，上述的模型就一直在使用。最开始，由于计算机系统规模相对较小，每个节点之间的链路协议都是经过专门设计和维护的。随着计算机规模的迅速扩大，很多个小的网络系统开始连接起来。在这个过程中，不同主机间如何找到彼此，跨网络间如何路由转发，如何实现流量控制等问题，成了摆在网络系统设计人员面前亟需解决的难题。</p><p>为了实现各个网络节点的路由转发，屏蔽链路层协议，人们发明了IP网络协议。然而，IP网络协议还不能够解决流量控制的问题。这里的流量控制，值得是防止一台服务器发送过多的数据包，超出下游服务器的处理能力。在最开始，编写网络服务和应用程序的开发者来负责处理上述流量控制的问题。这就意味着在编写应用程序过程中，网络处理的逻辑和应用自身的业务逻辑被耦合在一起，如下图所示。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-flow-control.png"></p><p>然而，这种每个开发人员都要去考虑流量处理等传输层的问题太过复杂，程序开发的成本太高。随着技术的快速发展，流量处理和其他网络问题相关的解决方案被整合到网络协议栈，TCP/IP席卷了世界，成为互联网事实上的协议标准。流量控制等网络问题的代码仍在，但是你不再需要自己去开发与维护这段代码，而是直接调用系统提供的网络协议栈。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-tcp.png"></p><h3 id="微服务架构的演进"><a href="#微服务架构的演进" class="headerlink" title="微服务架构的演进"></a>微服务架构的演进</h3><p>确定于上世界80年代的TCP/IP网络协议栈和通用的网络模型对于互联网的发展发挥了巨大的作用，极大了促进了互联网应用的繁荣。网络应用的功能逐渐复杂起来，人们把所有的组件都集中在一个应用当中，这即是<code>单体应用 Monolithic</code>。单体应用基于相同技术栈开发、访问共享的数据库、共同部署运维和扩容。同时，组件之间的通信也趋于频繁和耦合，所有的交互都是以函数调用的形式来实现。</p><p>然而，随着互联网的迅猛发展，网络应用中需要添加越来越多的功能，应用的复杂度不断提升，参与软件开发的协作人数也越来越多，单体应用开始爆发出其固有局限性。在这种背景下，微服务的思潮降临，让软件开发重新变得小而美：</p><ul><li>单⼀职责：拆分后的单个微服务，通常只负责单个高内聚自闭环功能，因此很易于开发、理解和维护。</li><li>架构灵活：不同微服务应用之间在技术选型层面几乎是独立的，可以⾃由选择最适合的技术栈。</li><li>部署隔离：相比巨无霸单体应用，单个微服务应用的代码和产物体积大大减少，更容易持续集成和快速部署；同时，通过进程级别的隔离，也不再像单体应用一样只能同生共死，故障隔离效果显著提升。</li><li>独⽴扩展：单体应用时代，某个模块如果存在资源瓶颈（e.g. CPU/内存），只能跟随整个应用一起扩容，白白浪费很多资源。微服务化后，扩展的粒度细化到了微服务级别，可以更精确地按需独立扩展。</li></ul><p>然而，微服务也不是银弹，在微服务落地的过程中，也产生了很多的问题，其中主要的问题就是服务间通信：</p><ul><li><p><strong>如何找到服务的提供⽅？</strong></p><p>微服务通讯必须走远程过程调用（HTTP/REST本质上也属于RPC），当其中一个应用需要消费另一个应用的服务时，无法再像单体应用一样通过简单的进程内机制（e.g. Spring的依赖注入）就能获取到服务实例；你甚至都不知道有没有这个服务方。</p></li><li><p><strong>如何保证远程调⽤的可靠性?</strong></p><p>既然是RPC，那必然要走IP网络，而我们都知道网络（相比计算和存储）是软件世界里最不可靠的东西。虽然有TCP这种可靠传输协议，但频繁丢包、交换机故障甚至电缆被挖断也常有发生；即使网络是好的，如果对方机器宕机了，或者进程负载过高不响应呢？</p></li><li><p><strong>如何降低服务调⽤的延迟？</strong></p><p>网络不只是不可靠，还有延迟的问题。虽然相同系统内的微服务应用通常都部署在一起，同机房内调用延迟很小；但对于较复杂的业务链路，很可能一次业务访问就会包括数十次RPC调用，累积起来的延迟就很可观了。</p></li><li><p><strong>如何保证服务调⽤的安全性？</strong></p><p>网络不只是不可靠和有延迟，还是不安全的。互联网时代，你永远不知道屏幕对面坐的是人还是狗；同样，微服务间通讯时，如果直接走裸的通讯协议，你也永远不知道对端是否真的就是自己人，或者传输的机密信息是否有被中间人偷听。</p></li></ul><h4 id="服务通信：耦合业务逻辑"><a href="#服务通信：耦合业务逻辑" class="headerlink" title="服务通信：耦合业务逻辑"></a>服务通信：耦合业务逻辑</h4><p>就像历史总是会重演，为了解决上述微服务引入的问题，最早需要工程师独立去完成对应的服务，在业务逻辑中实现下列逻辑：</p><ul><li>服务发现（Service Discovery）：解决“我想调用你，如何找到你”的问题。</li><li>服务熔断（Circuit Breaker）：缓解服务之间依赖的不可靠问题。</li><li>负载均衡（Load Balancing）：通过均匀分配流量，让请求处理更加及时。</li><li>安全通讯：包括协议加密（TLS）、身份认证（证书/签名）、访问鉴权（RBAC）等</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service.png"></p><p>然而，随着分布式程度的增加，这些服务的复杂度也越来越高，一些问题不得不考虑：</p><ul><li>重复造轮子：需要编写和维护⼤量非功能性代码，如何集中精力专注业务创新?</li><li>与业务耦合：服务通讯逻辑与业务代码逻辑混在一起，动不动还会遇到点匪夷所思的分布式bug。</li></ul><h4 id="服务通信：独立Library"><a href="#服务通信：独立Library" class="headerlink" title="服务通信：独立Library"></a>服务通信：独立Library</h4><p>为了解决重复造轮子的问题，集成了服务通信中各种问题的Library开始变得十分流行，包括 Apache Dubbo（手动置顶）、Spring Cloud、Netflix OSS、gRPC 等等。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service-lib.png"></p><p>这些可复用的类库和框架，确确实实带来了质量和效率上的大幅提升，但是也存在着下列问题：</p><ul><li>并非完全透明：程序员们仍然需要正确理解和使⽤这些库，上手成本和出错概率依然很高。</li><li>限制技术选择：使用这些技术后，应用很容易就会被对应的语⾔和框架强绑定（vendor-lock）。</li><li>维护成本高：库版本升级，需要牵连应⽤一起重新构建和部署；麻烦不说，还要祈祷别出故障。</li></ul><h4 id="服务通信：Sidecar"><a href="#服务通信：Sidecar" class="headerlink" title="服务通信：Sidecar"></a>服务通信：Sidecar</h4><p>像网络协议栈发展的过程一样，将大规模分布式服务所需要的功能剥离出来集成到底层平台是一个众望所归的选择。人们通过应用层的协议(例如HTTP)写出了很多复杂的应用程序和服务，甚至不用考虑TCP是如何控制数据包在网络上传输的。这就是我们微服务所需要的，从事服务开发的工程师们可以专注于业务逻辑的开发，避免浪费时间去编写服务基础设施代码或者管理这些库和框架。</p><p>在这个想法下，我们可以得到类似于如下的图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-protocol.png"></p><p>不幸的是，更改协议栈来增加微服务的功能不是一个可行的方案，许多开发者是通过一组代理来实现此功能。这里的设计思想是<strong>服务不需要和下游服务直连，所有的流量都通过该代理透明的来实现对应的功能</strong>。这里的透明代理，通过一种叫做 <code>Sidecar</code> 的模式来运行，Sidecar将上述类库和框架要干的事情从应用中彻底剥离了出来，并统一下沉到了基础设施层，这其中的典型代表就是 Linkerd 和 Envoy。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-sidecar.png"></p><h4 id="服务通信：Service-Mesh"><a href="#服务通信：Service-Mesh" class="headerlink" title="服务通信：Service Mesh"></a>服务通信：Service Mesh</h4><p>在这种模型中，每个服务都会有一个配套的代理SideCar。考虑到服务之间的通信仅仅通过SideCar代理，我们最终得到如下的部署图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data.png"></p><p>Buoyant的CEO William Morgan ，发现了各个SideCar代理之间互联组成了一个网状网络，<strong>2017初，William为这个网状的平台起了一个<a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/" target="_blank" rel="external nofollow noopener noreferrer">“Service Mesh”的定义</a></strong>。</p><blockquote><p>Service Mesh是一个用于服务和服务之间通信的专用基础设施层。它负责服务请求能够在复杂的服务拓扑(组成了云原生应用)中可靠的进行投递。在实践中，Serivce Mesh的典型实现是作为轻量级网络代理阵列，部署在应用程序旁边，不需要业务进程感知到。</p></blockquote><p>William关于Service Mesh的定义中，最有说服力的一点是，他不再将SideCar代理视为一个独立组件，而是承认了<strong>它们组成的网络像它们自身一样是有价值的</strong></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data2.png"></p><p>随着很多公司将它们的微服务部署到更复杂的系统运行环境中，例如Kubernetes和Mesos，人们开始使用这些平台提供的工具来实现合适的Serivce Mesh的想法。它们将独立的SideCar代理从独立的工作环境中转移到一个适当的，有集中的控制面。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control.png"></p><p>看下我们的鸟瞰图，服务之间的流量仍然是通过SideCar代理来进行转发，但是控制平面知道每个SideCar实例。控制平面能够让代理实现例如访问控制，指标收集等需要协作完成的事情。Istio是这个模型的典型实现。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control2.png"> </p><h2 id="主流实现"><a href="#主流实现" class="headerlink" title="主流实现"></a>主流实现</h2><p>Service Mesh 的主流实现包括：</p><ul><li>Linkerd：背后公司是Buoyant，开发语⾔使用Scala，2016年1⽉15日初次发布，2017年1⽉23日加入CNCF。</li><li>Envoy：背后公司是Lyft，开发语言使用C++ 11，2016年9月13日初次发布，2017年9⽉14日加⼊CNCF。</li><li>Istio：背后公司是Google和IBM，开发语言使用Go，2017年5⽉月10日初次发布。</li><li>Conduit：背后公司也是Buoyant，开发语言使用Rust和Go，2017年12月5日初次发布，现在已经加入了 <code>Linkerd</code> 项目。</li></ul><h3 id="Linkerd"><a href="#Linkerd" class="headerlink" title="Linkerd"></a>Linkerd</h3><p>现在（2020.09.08） <code>Linkerd</code> 已经发展到 2.8 版本，由控制面和数据面组成，详情可以参考 <a href="https://linkerd.io/2/reference/architecture/" target="_blank" rel="external nofollow noopener noreferrer">这里</a></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_linkerd-control-plane.png"></p><h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p>Envoy是一个高性能的Service Mesh软件，现在主要被用于数据面作为 Sidecar 代理，详情可以参考 <a href="../7beb34d2/">这里</a></p><p><img alt data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Istio是第二代 Service Mesh，第一次提出控制面的概念，详情可以参考 <a href="../22cae0b8/">这里</a></p><p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h3 id="NginMesh"><a href="#NginMesh" class="headerlink" title="NginMesh"></a>NginMesh</h3><p>Service Mesh 最基础的功能毕竟是 sidecar proxy. 提到 proxy 怎么能够少了 nginx? 我想nginx自己也是这么想的吧 毫不意外，nginx也推出了其 service mesh 的开源实现：nginMesh.</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_nginx-sidecar.png"></p><p>不过，与 William Morgan 的死磕策略不同，nginMesh 从一开始就没有想过要做一套完整的第二代Service Mesh 开源方案，而是直接宣布兼容Istio, 作为Istio的 sidecar proxy. 由于 nginx 在反向代理方面广泛的使用，以及运维技术的相对成熟，nginMesh在sidecar proxy领域应该会有一席之地。</p><h2 id="对比Kubernetes原生架构"><a href="#对比Kubernetes原生架构" class="headerlink" title="对比Kubernetes原生架构"></a>对比Kubernetes原生架构</h2><h3 id="Kube-proxy-vs-Sidecar"><a href="#Kube-proxy-vs-Sidecar" class="headerlink" title="Kube-proxy vs Sidecar"></a>Kube-proxy vs Sidecar</h3><p>下图展示的是 Kubernetes 与 Service Mesh 中的的服务访问关系：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_k8s-vs-service-mesh.png"></p><ul><li>Kubernetes 集群的每个节点都部署了一个 <code>kube-proxy</code> 组件，该组件会与 Kubernetes API Server 通信，获取集群中的 <code>Service</code> 信息，然后设置 iptables 规则，直接将对某个 <code>Service</code> 的请求发送到对应的 Endpoint（属于同一组 <code>Service</code> 的 <code>Pod</code>）上。</li><li>Kube-proxy 实现了流量在 Kubernetes <code>Service</code> 多个 <code>Pod</code> 实例间的负载均衡，但是如何对这些 <code>Service</code> 间的流量做细粒度的控制，比如按照百分比划分流量到不同的应用版本（这些应用都属于同一个 <code>Service</code>，但位于不同的 deployment 上），做金丝雀发布（灰度发布）和蓝绿发布？Kubernetes 社区给出了 <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="external nofollow noopener noreferrer">使用 Deployment 做金丝雀发布的方法</a>，该方法本质上就是通过修改 <code>Pod</code> 的 label 来将不同的 <code>Pod</code> 划归到 Deployment 的 <code>Service</code> 上。</li></ul><p><code>kube-proxy</code> 的设置都是全局生效的，无法对每个服务做细粒度的控制，而 <code>Service Mesh</code> 通过 <code>Sidecar</code> proxy 的方式将 Kubernetes 中对流量的控制从 <code>Service</code> 一层抽离出来，可以做更多的扩展。</p><h3 id="Ingress-vs-Gateway"><a href="#Ingress-vs-Gateway" class="headerlink" title="Ingress vs Gateway"></a>Ingress vs Gateway</h3><p> <code>kube-proxy</code> 只能路由 Kubernetes 集群内部的流量，而我们知道 Kubernetes 集群的 <code>Pod</code> 位于 CNI 创建的外网络中，集群外部是无法直接与其通信的，因此 Kubernetes 中创建了 Ingress 这个资源对象，它由位于 Kubernetes 边缘节点（这样的节点可以是很多个也可以是一组）的 Ingress controller 驱动，负责管理 <strong>南北向流量</strong>，Ingress 必须对接各种 Ingress Controller 才能使用，比如 <a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>、<a href="https://traefik.io/" target="_blank" rel="external nofollow noopener noreferrer">traefik</a>。</p><ul><li>Ingress 只适用于 HTTP 流量，使用方式也很简单，只能对 <code>Service</code>、port、HTTP 路径等有限字段匹配来路由流量，这导致它无法路由如 MySQL、Redis 和各种私有 RPC 等 TCP 流量。</li><li>要想直接路由南北向的流量，只能使用 <code>Service</code> 的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要进行额外的端口管理。</li><li>有些 Ingress controller 支持暴露 TCP 和 UDP 服务，但是只能使用 <code>Service</code> 来暴露，Ingress 本身是不支持的，例如 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>，服务暴露的端口是通过创建 ConfigMap 的方式来配置的。</li></ul><p><code>Istio</code> Gateway 的功能与 Kubernetes Ingress 类似，都是负责集群的南北向流量。<code>Istio</code> <code>Gateway</code> 描述的负载均衡器用于承载进出网格边缘的连接。该规范中描述了一系列开放端口和这些端口所使用的协议、负载均衡的 SNI 配置等内容。Gateway 是一种 CRD 扩展，它同时复用了 <code>Sidecar</code> proxy 的能力，详细配置请参考 <a href="https://istio.io/docs/reference/config/networking/gateway/" target="_blank" rel="external nofollow noopener noreferrer">Istio 官网</a>。</p><h2 id="落地问题"><a href="#落地问题" class="headerlink" title="落地问题"></a>落地问题</h2><p>服务网格的出现带来的变革：</p><p>第一，<strong>微服务治理与业务逻辑的解耦</strong>。服务网格把 SDK 中的<strong>大部分</strong>能力从应用中剥离出来，拆解为独立进程，以 Sidecar 的模式进行部署。服务网格通过将服务通信及相关管控功能从业务程序中分离并下沉到基础设施层，使其和业务系统完全解耦，使开发人员更加专注于业务本身。</p><blockquote><p>注意，这里提到了一个词“大部分”，SDK 中往往还需要保留<strong>协议编解码</strong>的逻辑，甚至在某些场景下还需要一个轻量级的 SDK 来实现细粒度的治理与监控策略。例如，要想实现方法级别的调用链追踪，服务网格则需要业务应用实现 trace ID 的传递，而这部分实现逻辑也可以通过轻量级的 SDK 实现。因此，从代码层面来讲，服务网格并非是零侵入的。</p></blockquote><p>第二，<strong>异构系统的统一治理</strong>。随着新技术的发展和人员更替，在同一家公司中往往会出现不同语言、不同框架的应用和服务，为了能够统一管控这些服务，以往的做法是为每种语言、每种框架都开发一套完整的 SDK，维护成本非常之高，而且给公司的中间件团队带来了很大的挑战。有了服务网格之后，通过将主体的服务治理能力下沉到基础设施，多语言的支持就轻松很多了。只需要提供一个非常轻量级的 SDK，甚至很多情况下都不需要一个单独的 SDK，就可以方便地实现多语言、多协议的统一流量管控、监控等需求。</p><p>此外，服务网格相对于传统微服务框架，还拥有三大技术优势：</p><ul><li>可观察性。因为服务网格是一个专用的基础设施层，所有的服务间通信都要通过它，所以它在技术堆栈中处于独特的位置，以便在服务调用级别上提供统一的遥测指标。这意味着，所有服务都被监控为“黑盒”。服务网格捕获诸如来源、目的地、协议、URL、状态码、延迟、持续时间等线路数据。这本质上等同于 web 服务器日志可以提供的数据，但是服务网格可以为所有服务捕获这些数据，而不仅仅是单个服务的 web 层。需要指出的是，收集数据仅仅是解决微服务应用程序中可观察性问题的一部分。存储与分析这些数据则需要额外能力的机制的补充，然后作用于警报或实例自动伸缩等。</li><li>流量控制。通过 <code>Service Mesh</code>，可以为服务提供智能路由（蓝绿部署、金丝雀发布、A/B test）、超时重试、熔断、故障注入、流量镜像等各种控制能力。而以上这些往往是传统微服务框架不具备，但是对系统来说至关重要的功能。例如，服务网格承载了微服务之间的通信流量，因此可以在网格中通过规则进行故障注入，模拟部分微服务出现故障的情况，对整个应用的健壮性进行测试。由于服务网格的设计目的是有效地将来源请求调用连接到其最优目标服务实例，所以这些流量控制特性是“面向目的地的”。这正是服务网格流量控制能力的一大特点。</li><li>安全。在某种程度上，单体架构应用受其单地址空间的保护。然而，一旦单体架构应用被分解为多个微服务，网络就会成为一个重要的攻击面。更多的服务意味着更多的网络流量，这对黑客来说意味着更多的机会来攻击信息流。而服务网格恰恰提供了保护网络调用的能力和基础设施。服务网格的安全相关的好处主要体现在以下三个核心领域：服务的认证、服务间通讯的加密、安全相关策略的强制执行。</li></ul><p>服务网格带来了巨大变革并且拥有其强大的技术优势，被称为第二代“微服务架构”。然而就像之前说的软件开发没有银弹，传统微服务架构有许多痛点，而服务网格也不例外，也有它的局限性。</p><ul><li>增加了复杂度。服务网格将 <code>Sidecar</code> 代理和其它组件引入到已经很复杂的分布式环境中，会极大地增加整体链路和操作运维的复杂性。</li><li>运维人员需要更专业。在容器编排器（如 Kubernetes）上添加 <code>Istio</code> 之类的服务网格，通常需要运维人员成为这两种技术的专家，以便充分使用二者的功能以及定位环境中遇到的问题。</li><li>延迟。从链路层面来讲，服务网格是一种侵入性的、复杂的技术，可以为系统调用增加显著的延迟。这个延迟是毫秒级别的，但是在特殊业务场景下，这个延迟可能也是难以容忍的。</li><li>平台的适配。服务网格的侵入性迫使开发人员和运维人员适应高度自治的平台并遵守平台的规则。</li></ul><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>展望未来，Kubernetes 正在爆炸式发展，它已经成为企业绿地应用的容器编排的首选。如果说 Kubernetes 已经彻底赢得了市场，并且基于 Kubernetes 的应用程序的规模和复杂性持续增加，那么就会有一个临界点，而服务网格则将是有效管理这些应用程序所必需的。随着服务网格技术的持续发展，其实现产品（如 <code>Istio</code>）的架构与功能的不断优化，服务网格将完全取代传统微服务架构，成为大小企业微服务化和上云改造的首选架构。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="external nofollow noopener noreferrer">https://philcalcado.com/2017/08/03/pattern_service_mesh.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Service Mesh 是一个&lt;strong&gt;基础设施层&lt;/strong&gt;，用于处理&lt;strong&gt;服务到服务间&lt;/strong&gt;的网络通信。&lt;strong&gt;云原生应用&lt;/strong&gt;有着复杂的服务拓扑，Service Mesh负责在这些&lt;strong&gt;网络拓扑中实现请求的可靠传递&lt;/strong&gt;。在实践中，Service Mesh通常实现为一组轻量级的&lt;strong&gt;网络代理&lt;/strong&gt;，它们与应用程序部署在一起，但是&lt;strong&gt;对应用保持透明&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="sidecar" scheme="http://houmin.cc/tags/sidecar/"/>
    
  </entry>
  
</feed>
