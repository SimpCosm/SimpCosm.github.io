<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-08-10T02:10:54.866Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>所谓生活</title>
    <link href="http://houmin.cc/posts/47d0d3b/"/>
    <id>http://houmin.cc/posts/47d0d3b/</id>
    <published>2020-08-09T14:20:20.000Z</published>
    <updated>2020-08-10T02:10:54.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。</p><a id="more"></a><h2 id="所见"><a href="#所见" class="headerlink" title="所见"></a>所见</h2><p>一直说要拍拍夏天的荷花，入职一个月以来，周末却一直呆在家里，没有出门。一来是外面太热，二来一直没有把自己的时间安排好，迟迟没有出门。下周要去房山参加一个星期的封闭培训，等到回来时，北京的夏天就过去了。想到这里，立马敲定晚上出门，带着相机，坐地铁到达什刹海公园。</p><p>走出地铁第一感受是，外面人好多。这不是我第一次来这里了，从烟袋斜街进去，转后海一条街，已经成了我的惯常路线。然而我们想到的是，即使国内仍然被疫情阴影笼罩，什刹海这里已经摩肩接踵，除了口罩已经不太能够看出疫情的痕迹了。</p><p><img alt="夏天，荷花" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_lily.png"></p><p><img alt="夏天，荷花" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_lily2.png"></p><p><img alt="夏天，荷花" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_lily3.png"></p><p>第二个让我感触比较大的是人们的生活状态。踢毽子、抽陀螺、跳舞、遛狗、打球、跑步，大家的状态都很放松，可以自在的玩自己的爱好。</p><p><img alt="荷花市坊抽陀螺的大爷" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_pick.png"></p><p><img alt="地安门两个人一起跳舞的叔叔阿姨" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_dance.png"></p><p><img alt="走到景山后街，见证了两个导盲犬的相遇与分离" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_dogs1.png"></p><p><img alt="他们两个明天应该还会相遇吧" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_forbidden-dogs2.png"></p><p><img alt="狗狗主人还热情地给我看了他平时拍到的狗狗照片" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_dogs3.png"></p><p>这与我在办公室的状态很不一样。在平常的日子里，每天除了上下班就没有其他的生活了。周末自己宅在家里，也不是这种惬意。总觉得有事情要做，总觉得有事情没有做完。这种状态，只有在找完工作之后的那半年才有吧。</p><h2 id="所闻"><a href="#所闻" class="headerlink" title="所闻"></a>所闻</h2><p>继续往景山走，却不想景区已经关门，只好往故宫走。</p><p><img alt="在角楼，一边也在拍角楼的素不相识的大哥主动提出借给我三脚架，于是才有了这张照片" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_forbidden-city.png"></p><p>拍角楼的时候，一个大爷主动跟我说话，推荐我拍拍景山前面的灯。本以为是一个简单的搭话，没想到我们两个聊了一个多小时的庄子、道与术、中西方哲学。这可能是这段时间里我交流密度最多的一个小时了。真的很奇妙，本是互不相识的人，却可以因为一方的主动聊起来，聊完之后也拂袖而去。与之相反，在办公室中，虽然也是每天都见面，但是实际上却说不上什么话。</p><h2 id="所想"><a href="#所想" class="headerlink" title="所想"></a>所想</h2><p>总的来说，这次外出让我感到很开心，让我感觉到城市中人与人的连接性，让我感到了北京的可爱。这些都是实实在在存在的人，他们都有着自己的生活。就是这样，你是可以变得更加主动一些的，没准你就可以发现难得的惊喜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-08-08_forbidden-city.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="夏天" scheme="http://houmin.cc/tags/%E5%A4%8F%E5%A4%A9/"/>
    
      <category term="故宫" scheme="http://houmin.cc/tags/%E6%95%85%E5%AE%AB/"/>
    
      <category term="什刹海" scheme="http://houmin.cc/tags/%E4%BB%80%E5%88%B9%E6%B5%B7/"/>
    
      <category term="生活" scheme="http://houmin.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】ApiServer之初识API</title>
    <link href="http://houmin.cc/posts/3bc1a603/"/>
    <id>http://houmin.cc/posts/3bc1a603/</id>
    <published>2020-08-07T12:46:14.000Z</published>
    <updated>2020-08-14T07:30:53.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>ApiServer</code>作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。</p><p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：</p><ul><li>提供 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用</li><li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；</li><li>允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd</li><li>资源在不同版本之间的转换</li></ul><a id="more"></a><h2 id="API-Overview"><a href="#API-Overview" class="headerlink" title="API Overview"></a>API Overview</h2><p>ApiServer 主要通过对外提供HTTP API 的方式与其他组件进行交互。API首选的序列化方案是JSON，但是也支持Protobuf协议。API主要有下面三种类型：</p><ul><li>core group：主要在 <code>/api/v1</code> 下；</li><li>named groups：其 path 为 <code>/apis/$NAME/$VERSION</code>；</li><li>暴露系统状态的一些 API：如<code>/metrics</code> 、<code>/healthz</code> 等；</li></ul><p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-space-1.png"></p><h3 id="GVK-GVR"><a href="#GVK-GVR" class="headerlink" title="GVK/GVR"></a>GVK/GVR</h3><p><img alt="Terminology" data-src="https://www.openshift.com/hs-fs/hubfs/Imported_Blog_Media/API-server-gvr.png?width=400&amp;height=152&amp;name=API-server-gvr.png"></p><p>在Kubernetes中，要想定位一个对象，我们需要指定GVK或者GVR。比如这里声明了 apiVersion 是 <code>apps/v1</code>，其实就是隐含了 <code>Group</code> 是 apps，<code>Version</code> 是 v1，<code>Kind</code> 就是定义的 DaemonSet，而 kubectl 接收到这个声明之后，就可以根据这个声明去调用 API Server 对应的 URL 去获取信息，例如这个就是 <code>/api/apps/v1/daemonset</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br></pre></td></tr></table></figure><p>对应到实际的URI的请求组织形式，如下图所示：</p><p><img alt="GVR" data-src="http://images.liuliqiang.info/2019/11/24/02/25/56/d14b874da710/"></p><p>通过结构体字段可以发现，它们其实就是Group、Version、Kind、Resource的不同组合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Kind    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">Group    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Resource <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Kind  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><p>Kubernetes中的每个对象都有一个字段 <code>Kind</code> 表明其类型，以Pod为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><code>Kubernetes</code> 中 Kind 有三种类型：</p><ul><li>系统中持久的实体对象，比如 <code>Pod</code> , <code>Namespace</code></li><li>一系列有某些共同特征的实体列表，比如 <code>PodLists</code>，<code>NodeLists</code></li><li>用于某些特定应用的一些非持久的实体，比如 <code>APIGroup</code>，<code>APIResource</code>, <code>Status</code></li></ul><p>Kind就是一个资源对象对应的种类 kind是通过<code>Kind=reflector.TypeOf(&amp;Pod{}).Elem().Name()</code>进行取值，取得的就是Pod这个结构体的名字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> PodList <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> NodeList <span class="keyword">struct</span></span><br></pre></td></tr></table></figure><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p><code>API Group</code> 是一些有关系的Kinds的集合，比如所有的批处理对象，<code>Job</code> 或者 <code>ScheduledJob</code> 都在 <code>batch</code>这个API Group。</p><p>各个Group是相互独立的，发展速度也不同，所有每个Group都会有不同的Version，而kubernetes是通过插件的方式来使用各个Group的，可以根据需求决定使用哪个Group。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Group="core"</span></span><br><span class="line"><span class="string">Version=v1</span></span><br><span class="line"></span><br><span class="line"><span class="string">Group="apps"</span></span><br><span class="line"><span class="string">Version=v1beta1</span></span><br></pre></td></tr></table></figure><p><code>GroupMeta</code>主要包括Group的元信息，里面的成员RESTMapper，与APIGroupVersion一样，其实APIGroupVersion的RESTMapper直接取值于GroupMeta的RESTMapper。一个Group可能包含多个版本，存储在 GroupVersions 中，而 GroupVersion 是默认存储在etcd中的版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupMeta <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// GroupVersion represents the preferred version of the group.</span></span><br><span class="line"><span class="comment">// 该group的默认版本</span></span><br><span class="line">GroupVersion unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupVersions is Group + all versions in that group.</span></span><br><span class="line"><span class="comment">// 该Group中可能会有多个版本，该字段就包含了所有的versions</span></span><br><span class="line">GroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// Codec is the default codec for serializing output that should use</span></span><br><span class="line"><span class="comment">// the preferred version.  Use this Codec when writing to</span></span><br><span class="line"><span class="comment">// disk, a data store that is not dynamically versioned, or in tests.</span></span><br><span class="line"><span class="comment">// This codec can decode any object that the schema is aware of.</span></span><br><span class="line"><span class="comment">// 用于编解码</span></span><br><span class="line">Codec runtime.Codec</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelfLinker can set or get the SelfLink field of all API types.</span></span><br><span class="line"><span class="comment">// to go through the InterfacesFor method below.</span></span><br><span class="line">SelfLinker runtime.SelfLinker</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known</span></span><br><span class="line"><span class="comment">// versions.</span></span><br><span class="line"><span class="comment">// RESTMapper提供 REST路径 与 那些在api.Scheme和所有已知版本中声明的对象之间的默认映射。用于类型，对象之间的转换</span></span><br><span class="line"></span><br><span class="line">RESTMapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesFor returns the default Codec and ResourceVersioner for a given version</span></span><br><span class="line"><span class="comment">// string, or an error if the version is not known.</span></span><br><span class="line"><span class="comment">// function provided below once every place that populates this field has been changed.</span></span><br><span class="line">InterfacesFor <span class="function"><span class="keyword">func</span><span class="params">(version unversioned.GroupVersion)</span> <span class="params">(*meta.VersionInterfaces, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesByVersion stores the per-version interfaces.</span></span><br><span class="line">InterfacesByVersion <span class="keyword">map</span>[unversioned.GroupVersion]*meta.VersionInterfaces</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>每个 API Group 下面都能存在有多个 version 版本。为了扩展性，Kubernetes支持多版本的API路径，比如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1/</code>， 不同版本的API意味着不同程度的稳定性和支持度。比如在一个 group 群组中最早有第一个 v1alpha1 版本，后来中间发展到了 v1beta1 版本，最终发展到 v1 的稳定版本。 如果在系统创建了一个 v1beta1 版本的对象，那么它能过被 Group 任一支持的版本（ 比如v1 ）检索到， 这是由于 API server 能够支持不同版本对象之间的无损耗转换。</p><p><strong>type GroupVersion struct</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GroupVersion</code>中就是两个string类型，<code>Group</code>和<code>Version</code>，分别对应了api所处的分组和版本，这也是kubernetes实现多版本的基础。</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Resource 代表以 JSON 格式通过 HTTP 发送或检索的资源实体。 它既可以使一个单独的resource资源（比如…/namespaces/default，也可以是一组resource 资源（比如…/jobs）。 这里说明一下 Reource 和 Kind 的区别： 其实基本上都是一个概念，只是 Kind 表示一个种类，在实际中它是首字母大写的； Resource 表示资源，在实际中它是全部小写的，并且有单数和复数之分。我们可以把Kind和Resource的关系理解成面向对象编程中类与对象的关系，Kind 其实就是一个类，用于描述对象的；而 Resource 就是具体的 Kind，可以理解成类已经实例化成对象。</p><p>Resource就是指定了一个名字和kind的资源对象，不管它有没有namespace。 resource是通过<code>plural, singular := KindToResource(kind)</code>取值，singular是将Kind转换为小写字母，而plural是变为复数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// name is the name of the resource.</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"><span class="comment">// namespaced indicates if a resource is namespaced or not.</span></span><br><span class="line">Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line"><span class="comment">// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')</span></span><br><span class="line">Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reousrce := unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"nodes"</span>, </span><br><span class="line">Namespaced: <span class="literal">false</span>,</span><br><span class="line">Kind:       <span class="string">"Node"</span>, </span><br><span class="line">&#125;</span><br><span class="line">reousrce = unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"pods"</span>,</span><br><span class="line">Namespaced: <span class="literal">true</span>,</span><br><span class="line">Kind:       <span class="string">"Pod"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源外部版本与内部版本"><a href="#资源外部版本与内部版本" class="headerlink" title="资源外部版本与内部版本"></a>资源外部版本与内部版本</h4><h4 id="资源代码定义"><a href="#资源代码定义" class="headerlink" title="资源代码定义"></a>资源代码定义</h4><h4 id="将资源注册到资源注册表"><a href="#将资源注册到资源注册表" class="headerlink" title="将资源注册到资源注册表"></a>将资源注册到资源注册表</h4><h4 id="资源首选版本"><a href="#资源首选版本" class="headerlink" title="资源首选版本"></a>资源首选版本</h4><h4 id="资源操作方法"><a href="#资源操作方法" class="headerlink" title="资源操作方法"></a>资源操作方法</h4><h4 id="资源与命名空间"><a href="#资源与命名空间" class="headerlink" title="资源与命名空间"></a>资源与命名空间</h4><h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><h4 id="资源对象描述文件定义"><a href="#资源对象描述文件定义" class="headerlink" title="资源对象描述文件定义"></a>资源对象描述文件定义</h4><h3 id="Kubernetes内置资源全图"><a href="#Kubernetes内置资源全图" class="headerlink" title="Kubernetes内置资源全图"></a>Kubernetes内置资源全图</h3><h3 id="runtime-Object-类型基石"><a href="#runtime-Object-类型基石" class="headerlink" title="runtime.Object 类型基石"></a>runtime.Object 类型基石</h3><h3 id="Unstructured数据"><a href="#Unstructured数据" class="headerlink" title="Unstructured数据"></a>Unstructured数据</h3><h3 id="Scheme资源注册表"><a href="#Scheme资源注册表" class="headerlink" title="Scheme资源注册表"></a>Scheme资源注册表</h3><h4 id="Scheme资源注册表数据结构"><a href="#Scheme资源注册表数据结构" class="headerlink" title="Scheme资源注册表数据结构"></a>Scheme资源注册表数据结构</h4><h4 id="资源注册表注册方法"><a href="#资源注册表注册方法" class="headerlink" title="资源注册表注册方法"></a>资源注册表注册方法</h4><h4 id="资源注册表查询方法"><a href="#资源注册表查询方法" class="headerlink" title="资源注册表查询方法"></a>资源注册表查询方法</h4><h3 id="Codec编解码器"><a href="#Codec编解码器" class="headerlink" title="Codec编解码器"></a>Codec编解码器</h3><h4 id="Codec编解码实例化"><a href="#Codec编解码实例化" class="headerlink" title="Codec编解码实例化"></a>Codec编解码实例化</h4><h4 id="jsonSerializer-与-yamlSerializer序列化器"><a href="#jsonSerializer-与-yamlSerializer序列化器" class="headerlink" title="jsonSerializer 与 yamlSerializer序列化器"></a>jsonSerializer 与 yamlSerializer序列化器</h4><h4 id="protobufSerializer序列化器"><a href="#protobufSerializer序列化器" class="headerlink" title="protobufSerializer序列化器"></a>protobufSerializer序列化器</h4><h3 id="Converter-资源版本转换器"><a href="#Converter-资源版本转换器" class="headerlink" title="Converter 资源版本转换器"></a>Converter 资源版本转换器</h3><h4 id="Converter-转换器数据结构"><a href="#Converter-转换器数据结构" class="headerlink" title="Converter 转换器数据结构"></a>Converter 转换器数据结构</h4><h4 id="Converter注册转换函数"><a href="#Converter注册转换函数" class="headerlink" title="Converter注册转换函数"></a>Converter注册转换函数</h4><h4 id="Converter-资源版本转换原理"><a href="#Converter-资源版本转换原理" class="headerlink" title="Converter 资源版本转换原理"></a>Converter 资源版本转换原理</h4><h2 id="API-Request-Flow"><a href="#API-Request-Flow" class="headerlink" title="API Request Flow"></a>API Request Flow</h2><p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</p><p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-flow-2.png"></p><p>关于 API 的处理代码都在 <code>k8s.io/pkg/api</code> 包中，会处理来自集群内部和集群外部的API请求。</p><p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链。该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互。</p><h3 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h3><p>一个HTTP Request首先会被 <code>DefaultBuildHandlerChain</code>注册的 filter chain处理，每一个filter会传递各自的info到 <code>ctx.RequestInfo</code>上。</p><ul><li><code>WithRequestInfo()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/requestinfo.go" target="_blank" rel="external nofollow noopener noreferrer">requestinfo.go</a> attaches a <code>RequestInfo</code> to the context</li><li><code>WithMaxInFlightLimit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/maxinflight.go" target="_blank" rel="external nofollow noopener noreferrer">maxinflight.go</a> limits the number of in-flight requests</li><li><code>WithTimeoutForNonLongRunningRequests()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/timeout.go" target="_blank" rel="external nofollow noopener noreferrer">timeout.go</a> times out non-long-running requests like most <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code> requests in contrast to long-running requests like watches and proxy requests</li><li><code>WithPanicRecovery()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/wrap.go" target="_blank" rel="external nofollow noopener noreferrer">wrap.go</a> wraps an handler to recover and log panics</li><li><code>WithCORS()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/cors.go" target="_blank" rel="external nofollow noopener noreferrer">cors.go</a> provides a CORS implementation; CORS stands for Cross-Origin Resource Sharing and is a mechanism that allows JavaScript embedded in a HTML page to make XMLHttpRequests to a domain different from the one the JavaScript originated from.</li><li><code>WithAuthentication()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authentication.go" target="_blank" rel="external nofollow noopener noreferrer">authentication.go</a> tries to authenticate the given request as a user and stores the user info in the provided context. On success, the <code>Authorization</code> HTTP header is removed from the request.</li><li><code>WithAudit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/audit.go" target="_blank" rel="external nofollow noopener noreferrer">audit.go</a> decorates the handler with audit logging information for all incoming requests The audit log entries contain infos such as source IP of the request, user invoking the operation, and namespace of the request.</li><li><code>WithImpersonation()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/impersonation.go" target="_blank" rel="external nofollow noopener noreferrer">impersonation.go</a> handles user impersonation, by checking requests that attempt to change the user (similar to sudo).</li><li><code>WithAuthorization()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authorization.go" target="_blank" rel="external nofollow noopener noreferrer">authorization.go</a> passes all authorized requests on to multiplexer which dispatched the request to the right handler, and returns a forbidden error otherwise.</li></ul><ul><li>WithRequestInfo：</li><li>MaxInflightLimit</li><li>TimeoutForNonLongRunningRequests</li><li>Panic Recovery</li><li>CORS</li><li>Authentication</li><li>Audit</li><li>Impersonation</li><li>Authorization</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line"><span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)</span><br><span class="line">&#125;</span><br><span class="line">handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">failedHandler := genericapifilters.Unauthorized(c.Serializer)</span><br><span class="line">failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)</span><br><span class="line">handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"true"</span>)</span><br><span class="line">handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)</span><br><span class="line">handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)</span><br><span class="line"><span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &amp;&amp; !c.SecureServing.DisableHTTP2 &amp;&amp; c.GoawayChance &gt; <span class="number">0</span> &#123;</span><br><span class="line">handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)</span><br><span class="line">&#125;</span><br><span class="line">handler = genericapifilters.WithAuditAnnotations(handler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">handler = genericapifilters.WithWarningRecorder(handler)</span><br><span class="line">handler = genericapifilters.WithCacheControl(handler)</span><br><span class="line">handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler-Operation"><a href="#Handler-Operation" class="headerlink" title="Handler Operation"></a>Handler Operation</h3><p>当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：</p><p><img alt="API-server-storage-flow-2" data-src="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png"></p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a><strong>Decoder</strong></h3><p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。</p><h3 id="Admission"><a href="#Admission" class="headerlink" title="Admission"></a><strong>Admission</strong></h3><p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 <code>k8s.io/kubernetes/plugin/pkg/admission</code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 <code>--enable-admission-plugins</code> 参数来开启需要使用的插件，通过 <code>ValidatingAdmissionWebhook</code> 或 <code>MutatingAdmissionWebhook</code> 添加的插件也都会在此处进行工作。</p><h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a><strong>Validation</strong></h3><p>主要检查 object 中字段的合法性。</p><p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |<span class="string">    ⇒       </span>|<span class="string">    ⇒  v1  ⇒ json/yaml ⇒ etcd</span></span><br><span class="line"><span class="string">                     admission    validation</span></span><br></pre></td></tr></table></figure><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img alt="apiserver diagram" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png"></p><ul><li>Scheme：定义了资源序列化和反序列化的方法，以及资源类型和版本的对应关系</li><li>Storage：是对资源的完整封装，实现了资源创建、删除、watch等操作</li><li>APIGroupInfo：是同一个group下所有资源的集合</li></ul><p>每个资源对应着两个版本：</p><ul><li>External Object：这个版本是对外给用户访问创建的接口对象，比如使用yaml或json创建对象时，都要使用External Object</li><li>Internal Object：这个版本是核心对象，实现了资源的创建和删除，对应了在ETCD中持久化的版本</li></ul><p>这两个版本的资源是需要相互转换的，而转换的函数就需要事先初始化到Scheme中， 多个external version版本之间的资源进行相互转换，都是需要通过internal version进行中转。所以在ETCD中存储的资源是带版本的，这也是kubernetes能实现多版本转换的关键。</p><h2 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h2><p>ApiServer 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：</p><ul><li><strong>Aggregator</strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；</li><li><strong>KubeAPIServer</strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；</li><li><strong>APIExtensionServer</strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。</li></ul><p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。</p><h3 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h3><p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 <code>GenericAPIServer</code> 和维护自身状态的 Controller。其中 <code>GenericAPIServer</code> 主要处理 <code>apiregistration.k8s.io</code> 组下的 APIService 资源请求。</p><p><strong>Aggregator 除了处理资源请求外还包含几个 controller：</strong></p><ul><li><code>apiserviceRegistrationController</code>：负责 APIServices 中资源的注册与删除；</li><li><code>availableConditionController</code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；</li><li><code>autoRegistrationController</code>：用于保持 API 中存在的一组特定的 APIServices；</li><li><code>crdRegistrationController</code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；</li><li><code>openAPIAggregationController</code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；</li></ul><p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="external nofollow noopener noreferrer">apiserver-builder</a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。</p><h4 id="启用-API-Aggregation"><a href="#启用-API-Aggregation" class="headerlink" title="启用 API Aggregation"></a>启用 API Aggregation</h4><p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--proxy-client-cert-file=/etc/kubernetes/certs/proxy.crt</span><br><span class="line">--proxy-client-key-file=/etc/kubernetes/certs/proxy.key</span><br><span class="line">--requestheader-client-ca-file=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line">--requestheader-allowed-names=aggregator</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra-</span><br><span class="line">--requestheader-group-headers=X-Remote-Group</span><br><span class="line">--requestheader-username-headers=X-Remote-User</span><br></pre></td></tr></table></figure><h3 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h3><p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。</p><h3 id="APIExtensionServer"><a href="#APIExtensionServer" class="headerlink" title="APIExtensionServer"></a>APIExtensionServer</h3><p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。</p><p>其中包含的 controller 以及功能如下所示：</p><ul><li><code>openapiController</code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 <code>/openapi/v2</code> 进行查看；</li><li><code>crdController</code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 <code>$ kubectl api-versions</code> 和 <code>$ kubectl api-resources</code> 查看；</li><li><code>namingController</code>：检查 crd obj 中是否有命名冲突，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>establishingController</code>：检查 crd 是否处于正常状态，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>nonStructuralSchemaController</code>：检查 crd obj 结构是否正常，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>apiApprovalController</code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>finalizingController</code>：类似于 finalizes 的功能，与 CRs 的删除有关；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ApiServer&lt;/code&gt;作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。&lt;/p&gt;
&lt;p&gt;kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/kubernetes-api/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Kubernetes API&lt;/a&gt;，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用&lt;/li&gt;
&lt;li&gt;代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；&lt;/li&gt;
&lt;li&gt;允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd&lt;/li&gt;
&lt;li&gt;资源在不同版本之间的转换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="apiserver" scheme="http://houmin.cc/tags/apiserver/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】调度策略</title>
    <link href="http://houmin.cc/posts/b130e91a/"/>
    <id>http://houmin.cc/posts/b130e91a/</id>
    <published>2020-08-03T06:39:15.000Z</published>
    <updated>2020-08-06T03:52:39.532Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文分析了Kubernetes内置的各种调度策略。</p><a id="more"></a><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><h3 id="整体梳理"><a href="#整体梳理" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container"><table><thead><tr><th>策略名称</th><th>策略算法</th><th>备注</th></tr></thead><tbody><tr><td>CheckNodeUnschedulable</td><td>在 Node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了</td><td></td></tr><tr><td>CheckVolumeBinding</td><td>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验</td><td></td></tr><tr><td>GeneralPredicates</td><td>是 PodFitsHostPorts，PodFitsResources，HostName，MatchNodeSelector这四个的组合</td><td></td></tr><tr><td>MatchInterPodAffinity</td><td>亲和性检查，当Node上所有正在运行的Pod与待调度的Pod不互相排斥时，则可调度</td><td></td></tr><tr><td>MaxAzureDiskVolumeCount</td><td>当Node上被挂载的Azure Disk Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>MaxCSIVolumeCountPred</td><td>当Node上被挂载的CSI Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>MaxEBSVolumeCount</td><td>当Node上被挂载的AWS EBS Volume超过默认限制39，该Node不可调度</td><td></td></tr><tr><td>MaxGCEPDVolumeCount</td><td>当Node上被挂载的GCD Persistent Disk超过默认限制16，该Node不可调度</td><td></td></tr><tr><td>MaxQcloudCbsVolumeCount</td><td>当Node上被挂载的Qcloud CBS Volume超过默认限制，该Node不可调度</td><td></td></tr><tr><td>NoDiskConflict</td><td>当Node上所有Pod使用的卷和待调度Pod使用的卷存在冲突，该Node不可调度</td><td></td></tr><tr><td>NoVolumeZoneConflict</td><td>当Node上的zone-lable包含Pod中PV卷下的zone-label时，可以调度。当Node上没有zone-label，表示没有zone限制，也可调度</td><td></td></tr><tr><td>PodToleratesNodeTaints</td><td>当Pod可以容忍Node上所有的taint时，该Node才可以调度</td><td></td></tr><tr><td>PodFitsHostPorts</td><td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td><td></td></tr><tr><td>PodFitsResources</td><td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td><td></td></tr><tr><td>HostName</td><td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td><td></td></tr><tr><td>MatchNodeSelector</td><td>校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配</td><td></td></tr><tr><td>CheckNodeMemoryPressure</td><td>当Node剩余内存紧张时，BestEffort类型的Pod无法调度到该主机</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>CheckNodeDiskPressure</td><td>当Node剩余磁盘空间紧张时，无法调度到该主机</td><td></td></tr><tr><td>PodFitsHostPorts</td><td>当待调度Pod中所有容器所用到的HostPort与Node上已使用的Port存在冲突，则无法调度</td><td></td></tr><tr><td>PodFitsResources</td><td>当总资源-Node中所有Pod对资源的request总量 &lt; 待调度的Pod request总量，则无法调度</td><td></td></tr><tr><td>HostName</td><td>如果待调度的Pod制定了pod.Spec.Host，则调度到该主机上</td><td></td></tr><tr><td>EvenPodsSpread</td><td>在1.18版本默认启动，符合条件的一组 Pod 在指定 TopologyKey 上的打散要求</td><td></td></tr><tr><td>CheckNodeLabelPresence</td><td>主要用于检查指定的Label是否在Node上存在</td><td></td></tr><tr><td>CheckServiceAffinityPred</td><td>根据当前POD对象所属的service已有的其他POD对象所运行的节点进行调度，其目的在于将相同service的POD 对象放置与同一个或同一类节点上以提高效率，此预选此类试图将那些在其节点选择器中带有特定标签的POD资源调度至拥有同样标签的节点上，具体的标签则取决于用户的定义。</td></tr></tbody></table></div><h3 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h3><h4 id="NoVolumeZoneConflictPred"><a href="#NoVolumeZoneConflictPred" class="headerlink" title="NoVolumeZoneConflictPred"></a>NoVolumeZoneConflictPred</h4><p>当在 k8s 集群中使用 zone 时，所有的Node都会被标记上 zone label，下面四种是常见的lable的key：</p><figure class="highlight go"><figcaption><span>k8s.io/api/core/v1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LabelZoneFailureDomain       = <span class="string">"failure-domain.beta.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegion              = <span class="string">"failure-domain.beta.kubernetes.io/region"</span></span><br><span class="line">LabelZoneFailureDomainStable = <span class="string">"topology.kubernetes.io/zone"</span></span><br><span class="line">LabelZoneRegionStable        = <span class="string">"topology.kubernetes.io/region"</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">node.alpha.kubernetes.io/ttl:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">volumes.kubernetes.io/controller-managed-attach-detach:</span> <span class="string">"true"</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2020-07-20T12:11:34Z"</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"334106446"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/nodes/10.0.1.28</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">5943d3fc-0841-43f2-b519-c32af755c1c5</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/instance-type:</span> <span class="string">QCLOUD</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">cloud.tencent.com/node-instance-id:</span> <span class="string">ins-r3gy6izp</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">failure-domain.beta.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/region:</span> <span class="string">bj</span></span><br><span class="line">    <span class="attr">topology.kubernetes.io/zone:</span> <span class="string">"800002"</span></span><br><span class="line">    <span class="attr">kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.28</span></span><br><span class="line">    <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.128</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">qcloud:///800002/ins-r3gy6izp</span></span><br></pre></td></tr></table></figure><p>当一个Pod有存储卷要求时，需要检查该存储卷的zone调度约束是否与Node的zone限制存在冲突。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/volumezone/volume_zone.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> pv.ObjectMeta.Labels &#123;</span><br><span class="line"><span class="keyword">if</span> !volumeZoneLabels.Has(k) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">nodeV, _ := nodeConstraints[k]</span><br><span class="line">volumeVSet, err := volumehelpers.LabelZonesToSet(v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Failed to parse label for %q: %q. Ignoring the label. err=%v. "</span>, k, v, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !volumeVSet.Has(nodeV) &#123;</span><br><span class="line">klog.V(<span class="number">10</span>).Infof(<span class="string">"Won't schedule pod %q onto node %q due to volume %q (mismatch on %q)"</span>, pod.Name, node.Name, pvName, k)</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonConflict)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检查的条件是：属于该Pod的所有volumes都必须与Node上的zone label完全匹配。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoVolumeZoneConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumezone.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckVolumeBindingPred"><a href="#CheckVolumeBindingPred" class="headerlink" title="CheckVolumeBindingPred"></a>CheckVolumeBindingPred</h4><p>在 pvc 和 pv 的 binding 过程中对其进行逻辑校验，里头的逻辑写的比较复杂，主要都是如何复用 pv；</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckVolumeBindingPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Reserve = appendToPluginSet(plugins.Reserve, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreBind = appendToPluginSet(plugins.PreBind, volumebinding.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NoDiskConflictPred"><a href="#NoDiskConflictPred" class="headerlink" title="NoDiskConflictPred"></a>NoDiskConflictPred</h4><p>SCSI 存储不会被重复的 volume, 检查在此主机上是否存在卷冲突。如果这个主机已经挂载了卷，其它同样使用这个卷的Pod不能调度到这个主机上，不同的存储后端具体规则不同</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(NoDiskConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, volumerestrictions.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MaxCSIVolumeCountPred"><a href="#MaxCSIVolumeCountPred" class="headerlink" title="MaxCSIVolumeCountPred"></a>MaxCSIVolumeCountPred</h4><p>一个Pod请求Volumes的时候，节点上可能已经有Volumes，需要检查加上这个Pod之后的Volumes是否超过Node最大允许的Volumes限制。MaxCSIVolumeCountPred 用来校验 pvc 上指定的 Provision 在 CSI plugin 上的单机最大 pv 数限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> volumeLimitKey, count := <span class="keyword">range</span> newVolumeCount &#123;</span><br><span class="line">maxVolumeLimit, ok := nodeVolumeLimits[v1.ResourceName(volumeLimitKey)]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">currentVolumeCount := attachedVolumeCount[volumeLimitKey]</span><br><span class="line"><span class="keyword">if</span> currentVolumeCount+count &gt; <span class="keyword">int</span>(maxVolumeLimit) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCSIVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CSIName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MaxNonCSIVolumeCountPred"><a href="#MaxNonCSIVolumeCountPred" class="headerlink" title="MaxNonCSIVolumeCountPred"></a>MaxNonCSIVolumeCountPred</h4><p>对于不是CSI标准的存储插件，也需要满足最大PV数限制，整体逻辑类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> numExistingVolumes+numNewVolumes &gt; maxAttachLimit &#123;</span><br><span class="line"><span class="comment">// violates MaxEBSVolumeCount or MaxGCEPDVolumeCount</span></span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReasonMaxVolumeCountExceeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MaxEBSVolumeCountPred"><a href="#MaxEBSVolumeCountPred" class="headerlink" title="MaxEBSVolumeCountPred"></a>MaxEBSVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxEBSVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.EBSName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxGCEPDVolumeCountPred"><a href="#MaxGCEPDVolumeCountPred" class="headerlink" title="MaxGCEPDVolumeCountPred"></a>MaxGCEPDVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxGCEPDVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.GCEPDName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxAzureDiskVolumeCountPred"><a href="#MaxAzureDiskVolumeCountPred" class="headerlink" title="MaxAzureDiskVolumeCountPred"></a>MaxAzureDiskVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxAzureDiskVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.AzureDiskName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MaxCinderVolumeCountPred"><a href="#MaxCinderVolumeCountPred" class="headerlink" title="MaxCinderVolumeCountPred"></a>MaxCinderVolumeCountPred</h5><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MaxCinderVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodevolumelimits.CinderName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-与-Node-匹配相关"><a href="#Pod-与-Node-匹配相关" class="headerlink" title="Pod 与 Node 匹配相关"></a>Pod 与 Node 匹配相关</h3><ul><li>CheckNodeCondition：校验节点是否准备好被调度，校验node.condition的condition type ：Ready为true和NetworkUnavailable为false以及Node.Spec.Unschedulable为false；</li><li></li><li>PodFitsHostPorts：校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用；</li><li>MatchNodeSelector: 校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配。</li></ul><h4 id="PodFitsHostPortsPred"><a href="#PodFitsHostPortsPred" class="headerlink" title="PodFitsHostPortsPred"></a>PodFitsHostPortsPred</h4><p><code>PodFitsHostPorts</code>策略主要用于校验 Pod 上的 Container 声明的 Ports 是否正在被 Node 上已经分配的 Pod 使用。</p><p>在 PreFilter 阶段，获取当前 Pod 对应的所有容器的Port，并且写入cycleState。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreFilter invoked at the prefilter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">PreFilter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">s := getContainerPorts(pod)</span><br><span class="line">cycleState.Write(preFilterStateKey, preFilterState(s))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Filter 阶段，从Cycle拿到当前Pod请求的Port，对比当前系统中已使用的 Port，看是否会发生冲突。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePorts)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">wantPorts, err := getPreFilterState(cycleState)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fits := fitsPorts(wantPorts, nodeInfo)</span><br><span class="line"><span class="keyword">if</span> !fits &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Unschedulable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsHostPortsPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="PodFitsResourcesPred"><a href="#PodFitsResourcesPred" class="headerlink" title="PodFitsResourcesPred"></a>PodFitsResourcesPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodFitsResourcesPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="PodToleratesNodeTaintsPred"><a href="#PodToleratesNodeTaintsPred" class="headerlink" title="PodToleratesNodeTaintsPred"></a>PodToleratesNodeTaintsPred</h4><p><code>PodToleratesNodeTaints</code>策略校验 Node 的 Taints 是否被 Pod Tolerates 包含。这里主要检查 <code>NoSchedule</code> 和 <code>NoExecute</code> 这两个 taint，如果不容忍，那么返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"invalid nodeInfo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filterPredicate := <span class="function"><span class="keyword">func</span><span class="params">(t *v1.Taint)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// PodToleratesNodeTaints is only interested in NoSchedule and NoExecute taints.</span></span><br><span class="line"><span class="keyword">return</span> t.Effect == v1.TaintEffectNoSchedule || t.Effect == v1.TaintEffectNoExecute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taint, isUntolerated := v1helper.FindMatchingUntoleratedTaint(nodeInfo.Node().Spec.Taints, pod.Spec.Tolerations, filterPredicate)</span><br><span class="line"><span class="keyword">if</span> !isUntolerated &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errReason := fmt.Sprintf(<span class="string">"node(s) had taint &#123;%s: %s&#125;, that the pod didn't tolerate"</span>,</span><br><span class="line">taint.Key, taint.Value)</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, errReason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(PodToleratesNodeTaintsPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="HostNamePred"><a href="#HostNamePred" class="headerlink" title="HostNamePred"></a>HostNamePred</h4><p><code>NodeNamePred</code>策略主要用于检查Pod Spec声明的Node Name是否与Node实际的Name匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filter invoked at the filter extension point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeName)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !Fits(pod, nodeInfo) &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReason)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fits actually checks if the pod fits the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fits</span><span class="params">(pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> || pod.Spec.NodeName == nodeInfo.Node().Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(HostNamePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MatchNodeSelectorPred"><a href="#MatchNodeSelectorPred" class="headerlink" title="MatchNodeSelectorPred"></a>MatchNodeSelectorPred</h4><p><code>MatchNodeSelectorPred</code>策略用于校验 Pod.Spec.Affinity.NodeAffinity 和 Pod.Spec.NodeSelector 是否与 Node 的 Labels 匹配 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PodMatchesNodeSelectorAndAffinityTerms</span><span class="params">(pod *v1.Pod, node *v1.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Check if node.Labels match pod.Spec.NodeSelector.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeSelector) &gt; <span class="number">0</span> &#123;</span><br><span class="line">selector := labels.SelectorFromSet(pod.Spec.NodeSelector)</span><br><span class="line"><span class="keyword">if</span> !selector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. nil NodeSelector matches all nodes (i.e. does not filter out any nodes)</span></span><br><span class="line"><span class="comment">// 2. nil []NodeSelectorTerm (equivalent to non-nil empty NodeSelector) matches no nodes</span></span><br><span class="line"><span class="comment">// 3. zero-length non-nil []NodeSelectorTerm matches no nodes also, just for simplicity</span></span><br><span class="line"><span class="comment">// 4. nil []NodeSelectorRequirement (equivalent to non-nil empty NodeSelectorTerm) matches no nodes</span></span><br><span class="line"><span class="comment">// 5. zero-length non-nil []NodeSelectorRequirement matches no nodes also, just for simplicity</span></span><br><span class="line"><span class="comment">// 6. non-nil empty NodeSelectorRequirement is not allowed</span></span><br><span class="line">nodeAffinityMatches := <span class="literal">true</span></span><br><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &#123;</span><br><span class="line">nodeAffinity := affinity.NodeAffinity</span><br><span class="line"><span class="comment">// if no required NodeAffinity requirements, will do no-op, means select all nodes.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Replace next line with subsequent commented-out line when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution == nil &amp;&amp; nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution == nil &#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match node selector for requiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Uncomment this block when implement RequiredDuringSchedulingRequiredDuringExecution.</span></span><br><span class="line"><span class="comment">// if nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution != nil &#123;</span></span><br><span class="line"><span class="comment">// nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingRequiredDuringExecution.NodeSelectorTerms</span></span><br><span class="line"><span class="comment">// klog.V(10).Infof("Match for RequiredDuringSchedulingRequiredDuringExecution node selector terms %+v", nodeSelectorTerms)</span></span><br><span class="line"><span class="comment">// nodeAffinityMatches = nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Match node selector for requiredDuringSchedulingIgnoredDuringExecution.</span></span><br><span class="line"><span class="keyword">if</span> nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line">nodeSelectorTerms := nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms</span><br><span class="line">nodeAffinityMatches = nodeAffinityMatches &amp;&amp; nodeMatchesNodeSelectorTerms(node, nodeSelectorTerms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodeAffinityMatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个典型的Node亲和性示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">pod: &amp;v1.Pod&#123;</span><br><span class="line">Spec: v1.PodSpec&#123;</span><br><span class="line">Affinity: &amp;v1.Affinity&#123;</span><br><span class="line">NodeAffinity: &amp;v1.NodeAffinity&#123;</span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution: &amp;v1.NodeSelector&#123;</span><br><span class="line">NodeSelectorTerms: []v1.NodeSelectorTerm&#123;</span><br><span class="line">&#123;</span><br><span class="line">MatchExpressions: []v1.NodeSelectorRequirement&#123;</span><br><span class="line">&#123;</span><br><span class="line">Key:      <span class="string">"kernel-version"</span>,</span><br><span class="line">Operator: v1.NodeSelectorOpGt,</span><br><span class="line">Values:   []<span class="keyword">string</span>&#123;<span class="string">"0204"</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="comment">// We use two digit to denote major version and two digit for minor version.</span></span><br><span class="line"><span class="string">"kernel-version"</span>: <span class="string">"0206"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">name: <span class="string">"Pod with matchExpressions using Gt operator that matches the existing node"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchNodeSelectorPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="GeneralPred"><a href="#GeneralPred" class="headerlink" title="GeneralPred"></a>GeneralPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(GeneralPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// GeneralPredicate is a combination of predicates.</span></span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, noderesources.FitName, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeResourcesFitArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.FitName, Args: args.NodeResourcesFitArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodename.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, nodeports.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckNodeUnschedulablePred"><a href="#CheckNodeUnschedulablePred" class="headerlink" title="CheckNodeUnschedulablePred"></a>CheckNodeUnschedulablePred</h4><p><code>CheckNodeUnschedulable</code> 在 node 节点上有一个 NodeUnschedulable 的标记，那这个节点就不会被调度了，形如这种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node: &amp;v1.Node&#123;</span><br><span class="line">   Spec: v1.NodeSpec&#123;</span><br><span class="line">     Unschedulable: <span class="literal">true</span>,</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>在 1.16 的版本里，这个 Unschedulable 已经变成了一个 Taints。也就是说需要校验一下 Pod 上打上的 Tolerates 是不是可以容忍这个 Taints。如果容忍了这个不可调度的taint，那么它也可以容忍 NodeSpec的不可调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeUnschedulable)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nodeInfo == <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnknownCondition)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If pod tolerate unschedulable taint, it's also tolerate `node.Spec.Unschedulable`.</span></span><br><span class="line">podToleratesUnschedulable := v1helper.TolerationsTolerateTaint(pod.Spec.Tolerations, &amp;v1.Taint&#123;</span><br><span class="line">Key:    v1.TaintNodeUnschedulable,</span><br><span class="line">Effect: v1.TaintEffectNoSchedule,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TODO (k82cn): deprecates `node.Spec.Unschedulable` in 1.13.</span></span><br><span class="line"><span class="keyword">if</span> nodeInfo.Node().Spec.Unschedulable &amp;&amp; !podToleratesUnschedulable &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonUnschedulable)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeUnschedulablePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodeunschedulable.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckNodeLabelPresencePred"><a href="#CheckNodeLabelPresencePred" class="headerlink" title="CheckNodeLabelPresencePred"></a>CheckNodeLabelPresencePred</h4><p><code>CheckNodeLablePresencePred</code>策略主要用于检查指定的Label是否在Node上存在。这里检查的是两种情况：</p><ul><li>一种检查Node上面是否有指定Label。比如有时候通过 <code>region/zone/racks</code> 这种label来划分空间，想要把Pod调度到有特定region/zone/racks的Node。</li><li>一种是检查Node上面是否没有指定的Label。比如有的Node被打上 <code>retiring</code> 的 label，想要制定Pod不调度到这些Node上。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Filter</span><span class="params">(ctx context.Context, _ *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nodeLabels := labels.Set(node.Labels)</span><br><span class="line">check := <span class="function"><span class="keyword">func</span><span class="params">(labels []<span class="keyword">string</span>, presence <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> labels &#123;</span><br><span class="line">exists := nodeLabels.Has(label)</span><br><span class="line"><span class="keyword">if</span> (exists &amp;&amp; !presence) || (!exists &amp;&amp; presence) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> check(pl.args.PresentLabels, <span class="literal">true</span>) &amp;&amp; check(pl.args.AbsentLabels, <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonPresenceViolated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个策略，需要在注册的时候设定策略插件的参数。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-与-Pod-匹配相关"><a href="#Pod-与-Pod-匹配相关" class="headerlink" title="Pod 与 Pod 匹配相关"></a>Pod 与 Pod 匹配相关</h3><h4 id="MatchInterPodAffinityPred"><a href="#MatchInterPodAffinityPred" class="headerlink" title="MatchInterPodAffinityPred"></a>MatchInterPodAffinityPred</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(MatchInterPodAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br><span class="line">registry.registerPredicateConfigProducer(CheckNodeLabelPresencePred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, nodelabel.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-服务打散相关"><a href="#Pod-服务打散相关" class="headerlink" title="Pod 服务打散相关"></a>Pod 服务打散相关</h3><h4 id="EvenPodsSpread"><a href="#EvenPodsSpread" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckServiceAffinity"><a href="#CheckServiceAffinity" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(CheckServiceAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, serviceaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h2><h3 id="整体梳理-1"><a href="#整体梳理-1" class="headerlink" title="整体梳理"></a>整体梳理</h3><div class="table-container"><table><thead><tr><th>策略名称</th><th>策略算法</th><th>权重</th></tr></thead><tbody><tr><td>BalancedResourceAllocation</td><td>CPU和内存利用率越接近，得分越高</td><td>1</td></tr><tr><td>ImageLocalityPriority</td><td>待调度的Pod会使用一些镜像，拥有这些镜像越多的节点，得分越高</td><td>1</td></tr><tr><td>InterPodAffinityPriority</td><td>Pod与Node上正运行的其他Pod亲和性匹配度越高，得分越高</td><td>1</td></tr><tr><td>LeastRequestedPriority</td><td>剩余资源越多，得分越高</td><td>1</td></tr><tr><td>NodeAffinityPriority</td><td>Pod与Node亲和性匹配度越高，得分越高</td><td>1</td></tr><tr><td>NodePreferAvoidPodsPriority</td><td>该Node的annotation scheduler.alpha.kubernetes.io/preferAvoidPods被设置时，说明该Node不希望被调度，得分低。</td><td>10000</td></tr><tr><td>SelectorSpreadPriority</td><td>相同service/rc的Pods越分散，得分越高</td><td>1</td></tr><tr><td>TaintTolerationPriority</td><td>Pod对Node的taint容忍度越高，得分越高</td><td>1</td></tr><tr><td>ServiceSpreadingPriority</td><td>相同Service的Pods越分散，得分越高，被 SelectorSpreadPriority取代，保留在系统中并不使用</td><td>1</td></tr><tr><td>EqualPriority</td><td>所有机器得分一样</td><td>1</td></tr><tr><td>MostRequestPriority</td><td>Request资源越多，得分越高，与LeastRequestPriority相反</td><td>1</td></tr><tr><td>EvenPodsSpreadPriority</td><td>在1.18版本默认启动，用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式</td><td>2</td></tr><tr><td>RequestedToCapacityRatioName</td><td>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing</td><td></td></tr><tr><td>NodeLabel</td><td>主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</td><td></td></tr><tr><td>ServiceAffinity</td><td>是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。</td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><p>打分算法主要解决的问题就是集群的碎片、容灾、水位、亲和、反亲和等，可以分为以下四个大类。</p><h3 id="资源水位"><a href="#资源水位" class="headerlink" title="资源水位"></a>资源水位</h3><ul><li>资源水位公式的概念：Request：Node 已经分配的资源；Allocatable：Node 的可调度的资源。</li><li>优先打散：把 Pod 分到资源空闲率最高的节点上，而非空闲资源最大的节点，公式：资源空闲率 = (Allocatable - Request) / Allocatable，当这个值越大，表示分数越高，优先分配到高分数的节点。其中 (Allocatable - Request) 表示为 Pod 分配到这个节点之后空闲的资源数。</li><li>优先堆叠：把 Pod 分配到资源使用率最高的节点上，公式:资源使用率 = Request / Allocatable ，资源使用率越高，表示得分越高，会优先分配到高分数的节点。</li><li>碎片率：是指 Node 上的多种资源之间的资源使用率的差值，目前支持 CPU/Mem/Disk 三类资源, 假如仅考虑 CPU/Mem，那么碎片率的公式 = Abs[CPU(Request / Allocatable) - Mem(Request / Allocatable)] 。举一个例子，当 CPU 的分配率是 99%，内存的分配率是 50%，那么碎片率 = 99% - 50% = 50%，那么这个例子中剩余 1% CPU, 50% Mem，很难有这类规格的容器能用完 Mem。得分 = 1 - 碎片率，碎片率越高得分低。</li><li>指定比率：可以在 Scheduler 启动的时候，为每一个资源使用率设置得分，从而实现控制集群上 node 资源分配分布曲线。</li></ul><h4 id="LeastRequestedPriority"><a href="#LeastRequestedPriority" class="headerlink" title="LeastRequestedPriority"></a>LeastRequestedPriority</h4><p><code>LeastRequestedPriority</code> 策略对于那些使用率越低的Node的优先级越高。通过这种算法，可以使得各个节点的资源得到均衡利用。</p><p>计算公式如下：</p><script type="math/tex; mode=display">(cpu((capacity-sum(requested))*MaxNodeScore/capacity) + memory((capacity-sum(requested))*MaxNodeScore/capacity))/weightSum</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(LeastRequestedPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.LeastAllocatedName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="MostRequestedPriority"><a href="#MostRequestedPriority" class="headerlink" title="MostRequestedPriority"></a>MostRequestedPriority</h4><p><code>MostRequestedPriority</code> 策略对于那些使用率更高的Node的优先级更高。这种算法在动态伸缩集群环境比较适用，会优先调度pod到使用率最高的主机节点，这样在伸缩集群时，就会腾出空闲机器，从而进行停机处理。</p><p>其计算公式如下：</p><script type="math/tex; mode=display">(cpu(MaxNodeScore * sum(requested) / capacity) + memory(MaxNodeScore * sum(requested) / capacity)) / weightSum</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(MostRequestedPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.MostAllocatedName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="BalancedResourceAllocation"><a href="#BalancedResourceAllocation" class="headerlink" title="BalancedResourceAllocation"></a>BalancedResourceAllocation</h4><p>BalancedResourceAllocation：尽量选择在部署Pod后各项资源更均衡的机器。BalancedResourceAllocation不能单独使用，而且必须和LeastRequestedPriority同时使用，它分别计算主机上的cpu和memory的比重，主机的分值由cpu比重和memory比重的“距离”决定。</p><p>计算公式如下：</p><script type="math/tex; mode=display">score = (1 - variance(cpuFraction,memoryFraction,volumeFraction)) * MaxNodeScore</script><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(BalancedResourceAllocation,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.BalancedAllocationName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="RequestedToCapacityRatioPriority"><a href="#RequestedToCapacityRatioPriority" class="headerlink" title="RequestedToCapacityRatioPriority"></a>RequestedToCapacityRatioPriority</h4><p><code>RequestedToCapacityRatioPriority</code>允许用户对于CPU、内存和扩展加速卡等资源实现bin packing。</p><p>所谓 <a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="external nofollow noopener noreferrer">Bin Packing</a> ，又称装箱问题，是运筹学中的一个经典问题。问题的背景是，现有若干个小盒子，想要把它们装进有限个给定大小的箱子中，如何既能够装的多油装的快，使得尽可能每个箱子都装满，从而减少箱子的使用数目。BinPack问题有很多变种，当限制箱子的数目为1，每个盒子给定value和weight，binpack问题就变成了背包问题。</p><p>Kubernetes默认开启的资源调度策略是Spread的策略，资源尽量打散，但是会导致较多的资源碎片，使得整体资源利用率下降。通过RequestedToCapacityRatioPriority配置支持CPU、内存和GPU等扩展卡的权重，在打分阶段计算对应资源的利用率，通过利用率进行排序，优先打满一个节点后再向后调度，从而实现bin packing。</p><p><code>RequestedToCapacityRatioResourceAllocation</code> 优先级函数的行为可以通过名为 <code>requestedToCapacityRatioArguments</code> 的配置选项进行控制。 该标志由两个参数 <code>shape</code> 和 <code>resources</code> 组成。 shape 允许用户根据 <code>utilization</code> 和 <code>score</code> 值将函数调整为最少请求（least requested）或 最多请求（most requested）计算。 resources 由 <code>name</code> 和 <code>weight</code> 组成，<code>name</code> 指定评分时要考虑的资源，<code>weight</code> 指定每种资源的权重。</p><p>以下是一个配置示例，该配置将 <code>requestedToCapacityRatioArguments</code> 设置为对扩展资源 <code>intel.com/foo</code> 和 <code>intel.com/bar</code> 的装箱行为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span> : <span class="string">"Policy"</span>,</span><br><span class="line">    <span class="attr">"apiVersion"</span> : <span class="string">"v1"</span>,</span><br><span class="line">    ...</span><br><span class="line">    "priorities" : [</span><br><span class="line">       ...</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"RequestedToCapacityRatioPriority"</span>,</span><br><span class="line">        <span class="attr">"weight"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"argument"</span>: &#123;</span><br><span class="line">          <span class="attr">"requestedToCapacityRatioArguments"</span>: &#123;</span><br><span class="line">            <span class="attr">"shape"</span>: [</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">0</span>, <span class="attr">"score"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"utilization"</span>: <span class="number">100</span>, <span class="attr">"score"</span>: <span class="number">10</span>&#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"resources"</span>: [</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/foo"</span>, <span class="attr">"weight"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              &#123;<span class="attr">"name"</span>: <span class="string">"intel.com/bar"</span>, <span class="attr">"weight"</span>: <span class="number">5</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际上，这里的shape参数定义的是不同utilization下对应的得分，是对 <code>LeastRequestedPriority</code> 和 <code>MostRequestedPriority</code> 的进一步抽象。</p><p>这种配置对应的是<code>LeastRequestedPriority</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这种配置对应的是<code>MostRequestedPriority</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">0</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">0</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"utilization":</span> <span class="number">100</span><span class="string">,</span> <span class="attr">"score":</span> <span class="number">10</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(noderesources.RequestedToCapacityRatioName,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, noderesources.RequestedToCapacityRatioName, &amp;args.Weight)</span><br><span class="line"><span class="keyword">if</span> args.RequestedToCapacityRatioArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: noderesources.RequestedToCapacityRatioName, Args: args.RequestedToCapacityRatioArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-打散"><a href="#Pod-打散" class="headerlink" title="Pod 打散"></a>Pod 打散</h3><p>Pod打散目的是支持符合条件的一组 Pod 在不同 topology 上部署的 spread 需求。</p><h4 id="ServiceSpreadingPriority"><a href="#ServiceSpreadingPriority" class="headerlink" title="ServiceSpreadingPriority"></a>ServiceSpreadingPriority</h4><p>ServiceSpreadingPriority：官方注释上说大概率会用来替换 SelectorSpreadPriority，为什么呢？我个人理解：Service 代表一组服务，我们只要能做到服务的打散分配就足够了。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPredicateConfigProducer(EvenPodsSpreadPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreFilter = appendToPluginSet(plugins.PreFilter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Filter = appendToPluginSet(plugins.Filter, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="EvenPodsSpread-1"><a href="#EvenPodsSpread-1" class="headerlink" title="EvenPodsSpread"></a>EvenPodsSpread</h4><p>EvenPodsSpreadPriority：用来指定一组符合条件的 Pod 在某个拓扑结构上的打散需求，这样是比较灵活、比较定制化的一种方式，使用起来也是比较复杂的一种方式。因为这个使用方式可能会一直变化，我们假设这个拓扑结构是这样的：Spec 是要求在 node 上进行分布的，我们就可以按照上图中的计算公式，计算一下在这个 node 上满足 Spec 指定 labelSelector 条件的 pod 数量，然后计算一下最大的差值，接着计算一下 Node 分配的权重，如果说这个值越大，表示这个值越优先。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(EvenPodsSpreadPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, podtopologyspread.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, podtopologyspread.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CheckServiceAffinity-1"><a href="#CheckServiceAffinity-1" class="headerlink" title="CheckServiceAffinity"></a>CheckServiceAffinity</h4><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(serviceaffinity.Name,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are n ServiceAffinity priorities in the policy, the weight for the corresponding</span></span><br><span class="line"><span class="comment">// score plugin is n*weight (note that the validation logic verifies that all ServiceAffinity</span></span><br><span class="line"><span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.ServiceAffinityArgs.AntiAffinityLabelsPreference))</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, serviceaffinity.Name, &amp;weight)</span><br><span class="line"><span class="keyword">if</span> args.ServiceAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: serviceaffinity.Name, Args: args.ServiceAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="SelectorSpreadPriority"><a href="#SelectorSpreadPriority" class="headerlink" title="SelectorSpreadPriority"></a>SelectorSpreadPriority</h4><p>SelectorSpreadPriority：用于实现 Pod 所属的 Controller 下所有的 Pod 在 Node 上打散的要求。实现方式是这样的：它会依据待分配的 Pod 所属的 controller，计算该 controller 下的所有 Pod,假设总数为 T，对这些 Pod 按照所在的 Node 分组统计；假设为 N (表示为某个 Node 上的统计值)，那么对 Node上的分数统计为  (T-N)/T 的分数，值越大表示这个节点的 controller 部署的越少，分数越高，从而达到 workload 的 pod 打散需求。</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(SelectorSpreadPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, selectorspread.Name, &amp;args.Weight)</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, selectorspread.Name, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pod-亲和-反亲和"><a href="#Pod-亲和-反亲和" class="headerlink" title="Pod 亲和/反亲和"></a>Pod 亲和/反亲和</h3><h4 id="InterPodAffinityPriority"><a href="#InterPodAffinityPriority" class="headerlink" title="InterPodAffinityPriority"></a>InterPodAffinityPriority</h4><p>InterPodAffinityPriority：先介绍一下使用场景：第一个例子，比如说应用 A 提供数据，应用 B 提供服务，A 和 B 部署在一起可以走本地网络，优化网络传输；第二个例子，如果应用 A 和应用 B 之间都是 CPU 密集型应用，而且证明它们之间是会互相干扰的，那么可以通过这个规则设置尽量让它们不在一个节点上。pod亲和性选择策略，类似NodeAffinityPriority，提供两种选择器支持：requiredDuringSchedulingIgnoredDuringExecution（保证所选的主机必须满足所有Pod对主机的规则要求）、preferresDuringSchedulingIgnoredDuringExecution（调度器会尽量但不保证满足NodeSelector的所有要求），两个子策略：podAffinity和podAntiAffinity</p><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(InterPodAffinityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, interpodaffinity.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, interpodaffinity.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">if</span> args.InterPodAffinityArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: interpodaffinity.Name, Args: args.InterPodAffinityArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Node-亲和-反亲和"><a href="#Node-亲和-反亲和" class="headerlink" title="Node 亲和/反亲和"></a>Node 亲和/反亲和</h3><ul><li>NodeAffinityPriority，这个是为了满足 Pod 和 Node 的亲和 &amp; 反亲和；</li><li>ServiceAntiAffinity，是为了支持 Service 下的 Pod 的分布要按照 Node 的某个 label 的值进行均衡。比如：集群的节点有云上也有云下两组节点，我们要求服务在云上云下均衡去分布，假设 Node 上有某个 label，那我们就可以用这个 ServiceAntiAffinity 进行打散分布；</li><li>NodeLabelPrioritizer，主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配;</li><li>ImageLocalityPriority，节点亲和主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</li></ul><h4 id="NodePreferAvoidPodsPriority"><a href="#NodePreferAvoidPodsPriority" class="headerlink" title="NodePreferAvoidPodsPriority"></a>NodePreferAvoidPodsPriority</h4><p><code>NodePreferAvoidPodsPriority</code>策略用于实现某些 controller 尽量不分配到某些节点上的能力；通过在 node 上加 annotation 声明哪些 controller 不要分配到 Node 上，如果不满足就优先。</p><p>具体实现就是会在Node上加上Annotation，形如这种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">annotations1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">v1.PreferAvoidPodsAnnotationKey: <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "preferAvoidPods": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "podSignature": &#123;</span></span><br><span class="line"><span class="string">                "podController": &#123;</span></span><br><span class="line"><span class="string">                    "apiVersion": "v1",</span></span><br><span class="line"><span class="string">                    "kind": "ReplicationController",</span></span><br><span class="line"><span class="string">                    "name": "foo",</span></span><br><span class="line"><span class="string">                    "uid": "abcdef123456",</span></span><br><span class="line"><span class="string">                    "controller": true</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "reason": "some reason",</span></span><br><span class="line"><span class="string">            "message": "some message"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检查的时候，对于那些不被 <code>ReplicaSet</code> 和 <code>ReplicationController</code> 拥有的 Pod，直接跳过，给予最高分。如果和 <code>annotation</code> 中标记的相同，那么给予最低分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodePreferAvoidPods)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, <span class="string">"node not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">controllerRef := metav1.GetControllerOf(pod)</span><br><span class="line"><span class="keyword">if</span> controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Ignore pods that are owned by other controller than ReplicationController</span></span><br><span class="line"><span class="comment">// or ReplicaSet.</span></span><br><span class="line"><span class="keyword">if</span> controllerRef.Kind != <span class="string">"ReplicationController"</span> &amp;&amp; controllerRef.Kind != <span class="string">"ReplicaSet"</span> &#123;</span><br><span class="line">controllerRef = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avoids, err := v1helper.GetAvoidPodsFromNodeAnnotations(node.Annotations)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If we cannot get annotation, assume it's schedulable there.</span></span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> avoids.PreferAvoidPods &#123;</span><br><span class="line">avoid := &amp;avoids.PreferAvoidPods[i]</span><br><span class="line"><span class="keyword">if</span> avoid.PodSignature.PodController.Kind == controllerRef.Kind &amp;&amp; avoid.PodSignature.PodController.UID == controllerRef.UID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> framework.MaxNodeScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodePreferAvoidPodsPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodepreferavoidpods.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NodeAffinityPriority"><a href="#NodeAffinityPriority" class="headerlink" title="NodeAffinityPriority"></a>NodeAffinityPriority</h4><p><code>NodeAffinityPriority</code>策略用于满足Pod与Node之间的亲和与反亲和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">affinity := pod.Spec.Affinity</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="comment">// A nil element of PreferredDuringSchedulingIgnoredDuringExecution matches no objects.</span></span><br><span class="line"><span class="comment">// An element of PreferredDuringSchedulingIgnoredDuringExecution that refers to an</span></span><br><span class="line"><span class="comment">// empty PreferredSchedulingTerm matches all objects.</span></span><br><span class="line"><span class="keyword">if</span> affinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity != <span class="literal">nil</span> &amp;&amp; affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Match PreferredDuringSchedulingIgnoredDuringExecution term by term.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution &#123;</span><br><span class="line">preferredSchedulingTerm := &amp;affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution[i]</span><br><span class="line"><span class="keyword">if</span> preferredSchedulingTerm.Weight == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Avoid computing it for all nodes if this becomes a performance problem.</span></span><br><span class="line">nodeSelector, err := v1helper.NodeSelectorRequirementsAsSelector(preferredSchedulingTerm.Preference.MatchExpressions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nodeSelector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line">count += <span class="keyword">int64</span>(preferredSchedulingTerm.Weight)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(NodeAffinityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodeaffinity.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="TaintTolerationPriority"><a href="#TaintTolerationPriority" class="headerlink" title="TaintTolerationPriority"></a>TaintTolerationPriority</h4><p><code>TaintTolerationPriority</code> 策略，Pod 对 Node 的 taint 容忍程度越高，优先级越大。</p><p>在 <code>PreScore</code> 阶段，拿到所有 <code>all Tolerations with Effect PreferNoSchedule or with no effect</code>，并将其写到cycleState。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">PreScore</span><span class="params">(ctx context.Context, cycleState *framework.CycleState, pod *v1.Pod, nodes []*v1.Node)</span> *<span class="title">framework</span>.<span class="title">Status</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">tolerationsPreferNoSchedule := getAllTolerationPreferNoSchedule(pod.Spec.Tolerations)</span><br><span class="line">state := &amp;preScoreState&#123;</span><br><span class="line">tolerationsPreferNoSchedule: tolerationsPreferNoSchedule,</span><br><span class="line">&#125;</span><br><span class="line">cycleState.Write(preScoreStateKey, state)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在 <code>Score</code> 阶段，具体算法就是Pod不能容忍的taint越多，那么得分就越高（之后会在Normalize处正则化，将得分逆序），也就是其优先级越低。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *TaintToleration)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v"</span>, nodeName, err))</span><br><span class="line">&#125;</span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line"></span><br><span class="line">s, err := getPreScoreState(state)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">score := <span class="keyword">int64</span>(countIntolerableTaintsPreferNoSchedule(node.Spec.Taints, s.tolerationsPreferNoSchedule))</span><br><span class="line"><span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(TaintTolerationPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.PreScore = appendToPluginSet(plugins.PreScore, tainttoleration.Name, <span class="literal">nil</span>)</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, tainttoleration.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ImageLocalityPriority"><a href="#ImageLocalityPriority" class="headerlink" title="ImageLocalityPriority"></a>ImageLocalityPriority</h4><p><code>ImageLocalityPriority</code>策略主要考虑的是镜像下载的速度。如果节点里面存在镜像的话，优先把 Pod 调度到这个节点上，这里还会去考虑镜像的大小，比如这个 Pod 有好几个镜像，镜像越大下载速度越慢，它会按照节点上已经存在的镜像大小优先级亲和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumImageScores</span><span class="params">(nodeInfo *framework.NodeInfo, containers []v1.Container, totalNumNodes <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> containers &#123;</span><br><span class="line"><span class="keyword">if</span> state, ok := nodeInfo.ImageStates[normalizedImageName(container.Image)]; ok &#123;</span><br><span class="line">sum += scaledImageScore(state, totalNumNodes)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(ImageLocalityPriority,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, imagelocality.Name, &amp;args.Weight)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="NodeLabel"><a href="#NodeLabel" class="headerlink" title="NodeLabel"></a>NodeLabel</h4><p><code>NodeLabel</code>策略主要是为了实现对某些特定 label 的 Node 优先分配，算法很简单，启动时候依据调度策略 (SchedulerPolicy）配置的 label 值，判断 Node 上是否满足这个label条件，如果满足条件的节点优先分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pl *NodeLabel)</span> <span class="title">Score</span><span class="params">(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">nodeInfo, err := pl.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || nodeInfo.Node() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, framework.NewStatus(framework.Error, fmt.Sprintf(<span class="string">"getting node %q from Snapshot: %v, node is nil: %v"</span>, nodeName, err, nodeInfo.Node() == <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := nodeInfo.Node()</span><br><span class="line">score := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.PresentLabelsPreference &#123;</span><br><span class="line"><span class="keyword">if</span> labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">score += framework.MaxNodeScore</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, label := <span class="keyword">range</span> pl.args.AbsentLabelsPreference &#123;</span><br><span class="line"><span class="keyword">if</span> !labels.Set(node.Labels).Has(label) &#123;</span><br><span class="line">score += framework.MaxNodeScore</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Take average score for each label to ensure the score doesn't exceed MaxNodeScore.</span></span><br><span class="line">score /= <span class="keyword">int64</span>(<span class="built_in">len</span>(pl.args.PresentLabelsPreference) + <span class="built_in">len</span>(pl.args.AbsentLabelsPreference))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> score, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法注册逻辑：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/legacy_registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry.registerPriorityConfigProducer(nodelabel.Name,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args ConfigProducerArgs)</span> <span class="params">(plugins config.Plugins, pluginConfig []config.PluginConfig)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are n LabelPreference priorities in the policy, the weight for the corresponding</span></span><br><span class="line"><span class="comment">// score plugin is n*weight (note that the validation logic verifies that all LabelPreference</span></span><br><span class="line"><span class="comment">// priorities specified in Policy have the same weight).</span></span><br><span class="line">weight := args.Weight * <span class="keyword">int32</span>(<span class="built_in">len</span>(args.NodeLabelArgs.PresentLabelsPreference)+<span class="built_in">len</span>(args.NodeLabelArgs.AbsentLabelsPreference))</span><br><span class="line">plugins.Score = appendToPluginSet(plugins.Score, nodelabel.Name, &amp;weight)</span><br><span class="line"><span class="keyword">if</span> args.NodeLabelArgs != <span class="literal">nil</span> &#123;</span><br><span class="line">pluginConfig = <span class="built_in">append</span>(pluginConfig,</span><br><span class="line">config.PluginConfig&#123;Name: nodelabel.Name, Args: args.NodeLabelArgs&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分析了Kubernetes内置的各种调度策略。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>【下厨房】电饭锅焖鸡腿</title>
    <link href="http://houmin.cc/posts/45418583/"/>
    <id>http://houmin.cc/posts/45418583/</id>
    <published>2020-07-26T14:23:43.000Z</published>
    <updated>2020-07-26T12:51:54.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。</p><a id="more"></a><h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><div class="table-container"><table><thead><tr><th>原料</th><th>分量</th></tr></thead><tbody><tr><td>鸡腿</td><td>5只</td></tr><tr><td>洋葱</td><td>半只</td></tr><tr><td>姜</td><td>3片</td></tr><tr><td>水</td><td>3汤匙</td></tr></tbody></table></div><p>腌料</p><div class="table-container"><table><thead><tr><th>配料</th><th>分量</th></tr></thead><tbody><tr><td>老抽</td><td>1汤匙</td></tr><tr><td>生抽</td><td>1汤匙</td></tr><tr><td>料酒</td><td>1汤匙</td></tr><tr><td>糖</td><td>2汤匙</td></tr><tr><td>芝麻香油</td><td>1茶匙</td></tr><tr><td>盐</td><td>1/4茶匙</td></tr><tr><td>胡椒粉</td><td>适量</td></tr></tbody></table></div><blockquote><p>汤匙：15mL，茶匙：5mL</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>鸡腿洗净切几刀，便于入味</li><li>腌料拌匀，研制入味，冷藏半天或者一夜</li><li>电饭锅底铺上洋葱丝、小葱、姜片，水</li><li>放入腌制好的鸡腿，倒入腌制的汁</li><li>铺均匀后按下煮饭按钮，40分钟</li><li>中间20分钟翻动一次</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>倒入腌鸡腿的汁后不用加水了，因为洋葱也会出很多的水</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「吃顿好的」第一道菜，【快手菜】电饭锅焖鸡腿。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="吃顿好的" scheme="http://houmin.cc/categories/%E5%90%83%E9%A1%BF%E5%A5%BD%E7%9A%84/"/>
    
    
      <category term="下厨房" scheme="http://houmin.cc/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>Project Ocean</title>
    <link href="http://houmin.cc/posts/f7bd8265/"/>
    <id>http://houmin.cc/posts/f7bd8265/</id>
    <published>2020-07-26T13:10:19.000Z</published>
    <updated>2020-07-26T14:58:00.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。</p><p>然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。</p><a id="more"></a><h2 id="雄心勃勃的计划"><a href="#雄心勃勃的计划" class="headerlink" title="雄心勃勃的计划"></a>雄心勃勃的计划</h2><p>从工程师的角度来说，这个计划毋庸置疑是一个雄心勃勃的伟大的计划。如果这件事情做成了，这将是留给人类的一个伟大礼物。2000年后出版的图书是可以直接电子化的，问题在于将之前存在的纸质的图书电子化。人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。</p><p>然而，这么多的知识中，很大的一部分都深藏在世界上各大图书馆深深的房间中，很少有人能够访问。设想一下，如果这些积累了千年的知识电子化后，人们通过浏览器就可以搜索到对应的知识，这将有多么的大的裨益。</p><h2 id="技术的问题"><a href="#技术的问题" class="headerlink" title="技术的问题"></a>技术的问题</h2><ul><li>首先我们需要知道，有多少本书需要电子化。在2010年8月，也就是10年前，谷歌在博客中发了一条消息，说全世界总共有<code>129864880</code>册图书。这里主要是英文图书，如果算上其他文字的，还是在亿这个量级。</li><li>第二个问题，如何电子化。Google给的方法是扫描，他们研发了一套专门的扫描系统，每台仪器一小时可以数字化1000页左右的图书。</li></ul><blockquote><p>待扫描的书会被放在一个特别设计的自动支架上，支架可以适应不同的书脊，并且将图书固定。仪器上方有一排灯，还有价值至少1000美元的光学器材，包括四个摄像头，两个分别照着摊开的书的左右两半，还有一个负责确定扫描范围的光学雷达，它会在图书表面生成一层激光网格，从而捕捉到纸页的曲度。操作员负责手动翻页，因为也没有机器能比得上人手的快捷和轻柔了，然后脚踩踏板来触发相机进行拍照，一系列动作仿佛是在弹一架奇怪的钢琴。</p></blockquote><ul><li>是的，这个系统还是需要人来翻页的，因为也没有机器能比得上人手的快捷和轻柔了。</li><li>第三个问题，扫描后如何将这些扫描的照片转化为文字，识别书籍中的插图和图表、提取页码、把脚注转化为引用、将所有的书籍形成网络，形成一个知识库。这个就更多的是OCR和NLP等研究的领域。</li></ul><p>其实，Google并不是第一个产生这个想法，密歇根大学早就开始了其700万册图书馆藏数字化的计划。按照他们的计划，700万册图书需要1000年，而Google告诉他们，同样的事情，他们只需要六年。</p><blockquote><p>Google给密歇根大学图书馆提议：图书馆将所有的书借给谷歌，谷歌来替对方完成全部的扫描。最后你能得到你的全部馆藏的电子版，而谷歌将获得海量的还不曾被人问津的数据资源。布林如此描述谷歌对图书馆藏的渴望，“人类的知识有几千年的历史，而书籍中承载的可能是其中质量最高的部分。”试想如果所有被尘封在纸页间的知识能够进入搜索引擎？</p><p>早在2004年之前，谷歌就开始了扫描工作。之后，谷歌和密歇根大学、哈佛、斯坦福、牛津、纽约公共图书馆和许多其他图书馆系统都订立了合约，并且以超过佩吉预言的速度，在十年多一点的时间里扫描了大约<strong>2500万册图书</strong>。图书扫描工作花掉了谷歌大约4亿美元。这项工作不仅仅依靠技术，还依靠强大的物流支持。</p></blockquote><ul><li>因为有的图书比较古老，在扫描过程中可能会出现错误。谷歌提出了一个机智的<a href="https://en.wikipedia.org/wiki/ReCAPTCHA" target="_blank" rel="external nofollow noopener noreferrer">ReCAPTCHA</a>计划用于解决在扫描中发现的错误。其基本思路是，为了验证人类所输入的文字是正确的，而不是随意输入，有两个字会被显示出来；一个是光学文字识别软件无法辨别的字，另一个是一个已经知道正确答案的字。如果用户正确的回答出已知正确答案的字，那么就假设所输入的另一个光学识别软件无法识别的字是认真的查看后被输入而非随便输入。</li></ul><h2 id="人的问题"><a href="#人的问题" class="headerlink" title="人的问题"></a>人的问题</h2><p>经过10年的时间，Google已经扫描了2500万册的图书，这是他们之前预计的图书总量五分之一。然而，在这个过程中，逐渐出现了很多反对的声音，并最终导致了这个项目的终止。</p><ul><li><p>美国作家协会和出版商对Google提出了集体诉讼，<strong>指控谷歌大规模侵犯知识产权</strong>，毕竟他们才有图书的版权。</p></li><li><p>Google则认为他们的目标是为了让用户能够检索图书，对于那些有版权的书，谷歌只能显示图书的片段，搜索结果中只能显示你搜索到的条目前后的几句话。Google认为他们只是制作了图书的副本，属于对于图书的合理使用。</p></li><li><p>事实上，这种版权问题早就发生在唱片、广播、有线电视等传统出版商身上，并不是版权所有者想要打压新技术，相反他们是想从新技术中分一杯羹。</p></li><li><p>随着诉讼的进展，出版商发现，他们实际上并不想阻止Google扫描绝版图书，甚至鼓励这种行为。</p></li><li><p>于是在这个过程中，Google，作家，出版商，图书馆四方进行了妥协，形成了「谷歌图书搜索修正协议」</p><ul><li>协议要求谷歌支付1亿2500万美元，其中包括一次性支付给它已经扫描过的图书的版权方的4500万美元（大约按每本书60美元计算），分别向出版商和作者支付的1550万美元和3000万美元诉讼费，以及用来创立图书版权登记处的3450万美元。</li><li>这项协议中也规定了到底应该如何展示和出售这些重获新生的绝版图书。按照协议，谷歌可以展示该书至多20%的部分来诱使用户购买，谷歌可以出售可下载的电子版，价格则由算法或者版权所有者来确定，由1.99美元到29.99美元不等。所有绝版书都会被打包存进一个“机构订阅数据库”，大学可以买下这个数据库，供全校师生免费搜索和阅读里面的全部书籍。</li><li>这个解决方案像是一个三赢——图书馆可以得到成千上万的图书，谷歌在图书搜索服务上的投资没有白费，作者和出版商能够从已经毫无商业价值的书中获得一笔新的收入来源。</li></ul></li><li><p>但是这个「谷歌图书搜索修正协议」引起了更大的争议</p><ul><li><p>学校的教授们担心发生在学术期刊市场的事情会在谷歌图书的数据库上重演，一旦图书馆和学校对订购谷歌的数据库产生依赖，订购价格将会像高利贷一样暴涨，最终涨的和各路学术期刊一样高</p></li><li><p>Google的竞争对手也觉得收到了这份协议的威胁。</p><ul><li><blockquote><p>微软公司就不出所料地声称，如果谷歌是唯一一个可以合法地检索绝版图书的搜索引擎，这无疑会强化谷歌在全世界作为搜索引擎霸主的地位。如果谷歌利用这些绝版图书来满足用户的长尾需求，这将是一个对于其他公司来说很不公平的竞争优势。</p></blockquote></li></ul></li></ul></li></ul><pre><code>- &gt;   &gt;  &gt; 亚马逊公司则担心这项协议会让谷歌建立一个无可匹敌的图书商店。亚马逊认为，任何想要出售绝版图书的人，都必须要一本一本地确认图书版权，这是最好的，但是集体诉讼的协议却让谷歌一次性获得了所有图书的授权。</code></pre><p>  随着一轮又一轮的诉讼与协议，现在的状态是，Google基本尘封了这个计划。之前扫描的这2500万册图书以50PB的大小的文件存在于硬盘上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.thepaper.cn/newsDetail_forward_1679335" target="_blank" rel="external nofollow noopener noreferrer">https://www.thepaper.cn/newsDetail_forward_1679335</a></li><li><a href="https://www.theatlantic.com/technology/archive/2017/04/the-tragedy-of-google-books/523320/" target="_blank" rel="external nofollow noopener noreferrer">Torching the Modern-Day Library of Alexandria</a></li><li>Blow Your Mind</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千年以来人们一直梦想有一个世界级的图书馆，在这个图书馆里能够存放世界上所有出版过的印刷在纸上的知识。可以预见，如果是实体的图书馆这种想法将很难实现。但是，随着信息化时代的到来，全世界所有知识的电子化是可以实现的。Google在2002年就启动了一个「Project Ocean」计划，用以扫描所有的图书，建立一个统一的世界数字图书馆。&lt;/p&gt;
&lt;p&gt;然而，经过十年的发展，这个计划却最终在一阵喧嚣中戛然而止。这里是「朝花夕拾」第二十一期，本期话题来自于最近听的「Blow Your Mind」的一期播客。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-26_google-books.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="google" scheme="http://houmin.cc/tags/google/"/>
    
      <category term="图书" scheme="http://houmin.cc/tags/%E5%9B%BE%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Slice</title>
    <link href="http://houmin.cc/posts/251346e5/"/>
    <id>http://houmin.cc/posts/251346e5/</id>
    <published>2020-07-24T04:10:32.000Z</published>
    <updated>2020-08-14T13:58:28.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>相对于最基本的 Array 数据结构，在 Go 语言中，使用的更多的是 Slice（切片）。Slice 实质上就是动态数组，类似于C++ STL中的 Vector。Slice 的长度并不固定，可以随意向 Slice 中 Append 元素，Slice 在容量不足时会自动扩容。本篇会首先介绍 Slice 的基本使用，然后介绍 Slice 实现的内部原理。</p><a id="more"></a><h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><p>在 Go 语言中，切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过以下方式声明 Slice：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">letters := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br></pre></td></tr></table></figure><p>或者也可以使用内置的 <code>make</code> 函数来创建一个 Slice，这里可以指定切片的长度和容量，其中容量可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func make([]T, len, cap) []T</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">byte</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// s == []byte&#123;0, 0, 0, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 cap 参数省略时，默认等同于制定的 len</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>我们可以通过对现有切片再切片来获得新的切片，通过 <code>s[1:4]</code> 这种使用下标的方式来实现，这是一个前闭后开区间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b := []<span class="keyword">byte</span>&#123;<span class="string">'g'</span>, <span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>&#125;</span><br><span class="line"><span class="comment">// b[1:4] == []byte&#123;'o', 'l', 'a'&#125;, sharing the same storage as b</span></span><br><span class="line"><span class="comment">// b[:2] == []byte&#123;'g', 'o'&#125;</span></span><br><span class="line"><span class="comment">// b[2:] == []byte&#123;'l', 'a', 'n', 'g'&#125;</span></span><br><span class="line"><span class="comment">// b[:] == b</span></span><br></pre></td></tr></table></figure><p>我们也可以基于同样的Syntax来从Array生成新的Slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"Лайка"</span>, <span class="string">"Белка"</span>, <span class="string">"Стрелка"</span>&#125;</span><br><span class="line">s := x[:] <span class="comment">// a slice referencing the storage of x</span></span><br></pre></td></tr></table></figure><p>可以对切片执行 append 操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func append(s []T, x ...T) []T</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// a == []int&#123;0&#125;</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// a == []int&#123;0, 1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p>以可以执行 copy 操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func copy(dst, src []T) int</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br></pre></td></tr></table></figure><p>下面是对 Slice 的常见用法汇总：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">"emp:"</span>, s)</span><br><span class="line"></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">"b"</span></span><br><span class="line">    s[<span class="number">2</span>] = <span class="string">"c"</span></span><br><span class="line">    fmt.Println(<span class="string">"set:"</span>, s)</span><br><span class="line">    fmt.Println(<span class="string">"get:"</span>, s[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"d"</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">"e"</span>, <span class="string">"f"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"apd:"</span>, s)</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(c, s)</span><br><span class="line">    fmt.Println(<span class="string">"cpy:"</span>, c)</span><br><span class="line"></span><br><span class="line">    l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">"sl1:"</span>, l)</span><br><span class="line"></span><br><span class="line">    l = s[:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">"sl2:"</span>, l)</span><br><span class="line"></span><br><span class="line">    l = s[<span class="number">2</span>:]</span><br><span class="line">    fmt.Println(<span class="string">"sl3:"</span>, l)</span><br><span class="line"></span><br><span class="line">    t := []<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"dcl:"</span>, t)</span><br><span class="line"></span><br><span class="line">    twoD := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        innerLen := i + <span class="number">1</span></span><br><span class="line">        twoD[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, innerLen)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">            twoD[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go run slices.go</span><br><span class="line">emp: [  ]</span><br><span class="line"><span class="built_in">set</span>: [a b c]</span><br><span class="line">get: c</span><br><span class="line">len: 3</span><br><span class="line">apd: [a b c d e f]</span><br><span class="line">cpy: [a b c d e f]</span><br><span class="line">sl1: [c d e]</span><br><span class="line">sl2: [a b c d e]</span><br><span class="line">sl3: [c d e f]</span><br><span class="line">dcl: [g h i]</span><br><span class="line">2d:  [[0] [1 2] [2 3 4]]</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>编译期间的切片是 <code>Slice</code> 类型的，但是在运行时切片由如下的 <code>SliceHeader</code> 结构体表示，其中 <code>Data</code> <strong>字段是指向数组的指针</strong>，<code>Len</code> 表示当前切片的长度，而 <code>Cap</code> 表示当前切片的容量，也就是 <code>Data</code> 数组的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Data</code> 作为一个指针指向的数组是一片连续的内存空间，这片内存空间可以用于存储切片中保存的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p><p><img alt="golang-slice-struct" data-src="https://img.draveness.me/2019-02-20-golang-slice-struct.png"></p><p>从上图我们会发现切片与数组的关系非常密切，切片引入了一个抽象层，提供了对数组中部分片段的引用，作为数组的引用，我们可以在运行区间可以修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。</p><p>我们在上一节介绍过，获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化，由于数组的内存固定且连续，很多操作都会变成对内存的直接读写。但是切片是运行时才会确定内容的结构，所有的操作还需要依赖 Go 语言的运行时来完成，我们接下来就会介绍切片一些常见操作的实现原理。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Go 语言中的切片有三种初始化的方式：</p><ol><li>通过下标的方式获得数组或者切片的一部分；</li><li>使用字面量初始化新的切片；</li><li>使用关键字 <code>make</code> 创建切片：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h3><p>使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，<code>arr[0:3]</code> 或者 <code>slice[0:3]</code> 这些操作会由编译器转换成 <code>OpSliceMake</code> 操作，我们可以通过下面的代码来验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> opslicemake</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := arr[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>GOSSAFUNC</code> 变量编译上述代码可以得到如下所示的 SSA 中间代码，在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>的 <code>decompose builtin</code> 阶段，<code>slice := arr[0:1]</code> 对应的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v27 (+<span class="number">5</span>) = SliceMake &lt;[]<span class="keyword">int</span>&gt; v11 v14 v17</span><br><span class="line"></span><br><span class="line">name &amp;arr[*[<span class="number">3</span>]<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.ptr[*<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.<span class="built_in">len</span>[<span class="keyword">int</span>]: v14</span><br><span class="line">name slice.<span class="built_in">cap</span>[<span class="keyword">int</span>]: v17</span><br></pre></td></tr></table></figure><p><code>SliceMake</code> 这个操作会接受三个参数创建新的切片，元素类型、数组指针、切片大小和容量，这也就是我们在数据结构一节中提到的切片的几个字段。</p><p>也就是说，通过下标的方式，并不会复制切片实际的数据，只是创建了一个新的切片，将其数据指向原来的数组。所以，修改新生成的切片后，原来数组的数据也会改变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d := []<span class="keyword">byte</span>&#123;<span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line">e := d[<span class="number">2</span>:]</span><br><span class="line"><span class="comment">// e == []byte&#123;'a', 'd'&#125;</span></span><br><span class="line">e[<span class="number">1</span>] = <span class="string">'m'</span></span><br><span class="line"><span class="comment">// e == []byte&#123;'a', 'm'&#125;</span></span><br><span class="line"><span class="comment">// d == []byte&#123;'r', 'o', 'a', 'm'&#125;</span></span><br></pre></td></tr></table></figure><p>一个切片可以通过下标方式扩展不能超过其容量，否则会产生 <code>runtime panic</code>，就像在数组越界的时候一样。</p><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>当我们使用字面量 <code>[]int{1, 2, 3}</code> 创建新的切片时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L595-L766" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">3</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:]</span><br></pre></td></tr></table></figure><ol><li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li><li>将这些字面量元素存储到初始化的数组中；</li><li>创建一个同样指向 <code>[3]int</code> 类型的数组指针；</li><li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li><li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li></ol><p>第 5 步中的 <code>[:]</code> 就是使用下标创建切片的方法，从这一点我们也能看出 <code>[:]</code> 操作是创建切片最底层的一种方法。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量，<a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2126" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheck1</code></a> 会对参数进行校验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> OMAKE:</span><br><span class="line">args := n.List.Slice()</span><br><span class="line"></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line"><span class="keyword">case</span> TSLICE:</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">yyerror(<span class="string">"missing len argument to make(%v)"</span>, t)</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = args[i]</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">var</span> r *Node</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">r = args[i]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">yyerror(<span class="string">"len larger than cap in make(%v)"</span>, t)</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.Left = l</span><br><span class="line">n.Right = r</span><br><span class="line">n.Op = OMAKESLICE</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>，除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，随后的中间代码生成阶段在 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1315" target="_blank" rel="external nofollow noopener noreferrer"><code>OMAKESLICE</code></a> 分支依据两个重要条件对这里的 <code>OMAKESLICE</code> 进行转换：</p><ol><li>切片的大小和容量是否足够小；</li><li>切片是否发生了逃逸，最终在堆上初始化</li></ol><p>当切片发生逃逸或者非常大时，我们需要 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a> 函数在堆上初始化，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>上述代码会初始化数组并且直接通过下标 <code>[:3]</code> 来得到数组的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组，<code>[:3]</code> 会被转换成上一节提到的 <code>OpSliceMake</code> 操作。</p><p>分析了主要由编译器处理的分支之后，我们回到用于创建切片的运行时函数 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a>，这个函数的实现非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">panicmakeslicelen()</span><br><span class="line">&#125;</span><br><span class="line">panicmakeslicecap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的主要工作就是计算当前切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">内存空间 </span>=<span class="string"> 切片中元素大小 x 切片容量</span></span><br></pre></td></tr></table></figure><p>虽然大多的错误都可以在编译期间被检查出来，但是在创建切片的过程中如果发生了以下错误就会直接导致程序触发运行时错误并崩溃：</p><ol><li>内存空间的大小发生了溢出；</li><li>申请的内存大于最大可分配的内存；</li><li>传入的长度小于 0 或者长度大于容量；</li></ol><p><code>mallocgc</code> 就是用于申请内存的函数，这个函数的实现还是比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的一些对象会在堆上初始化，我们会在后面的章节中详细介绍 Go 语言的内存分配器，在这里就不展开分析了。</p><p>目前的 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a> 会返回指向底层数组的指针，之前版本的 Go 语言中，数组指针、长度和容量会被合成一个 <code>slice</code> 结构并返回，但是从 <a href="https://github.com/golang/go/commit/020a18c545bf49ffc087ca93cd238195d8dcc411#diff-d9238ca551e72b3a80da9e0da10586a4" target="_blank" rel="external nofollow noopener noreferrer">cmd/compile: move slice construction to callers of makeslice</a> 这次提交之后，构建结构体 <code>SliceHeader</code> 的工作就都交给 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L34-L50" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.makeslice</code></a> 的调用方处理了，这些调用方会在编译期间构建切片结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> OSLICEHEADER:</span><br><span class="line"><span class="keyword">switch</span> </span><br><span class="line">t := n.Type</span><br><span class="line">n.Left = typecheck(n.Left, ctxExpr)</span><br><span class="line">l := typecheck(n.List.First(), ctxExpr)</span><br><span class="line">c := typecheck(n.List.Second(), ctxExpr)</span><br><span class="line">l = defaultlit(l, types.Types[TINT])</span><br><span class="line">c = defaultlit(c, types.Types[TINT])</span><br><span class="line"></span><br><span class="line">n.List.SetFirst(l)</span><br><span class="line">n.List.SetSecond(c)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OSLICEHEADER</code> 操作会创建我们在上面介绍过的结构体 <code>SliceHeader</code>，其中包含数组指针、切片长度和容量，它也是切片在运行时的表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是因为大多数对切片类型的操作并不需要直接操作原 <code>slice</code> 结构体，所以 <code>SliceHeader</code> 的引入能够减少切片初始化时的少量开销，这个改动能够减少 ~0.2% 的 Go 语言包大小并且能够减少 92 个 <code>panicindex</code> 的调用，占整个 Go 语言二进制的 ~3.5%。</p><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>对切片常见的操作就是获取它的长度或者容量，这两个不同的函数 <code>len</code> 和 <code>cap</code> 被 Go 语言的编译器看成是两种特殊的操作，即 <code>OLEN</code> 和 <code>OCAP</code>，它们会在 <a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">SSA 生成阶段</a>被 <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L1975-L2724" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.epxr</code></a> 函数转换成 <code>OpSliceLen</code> 和 <code>OpSliceCap</code> 操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OLEN, OCAP:</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">op := ssa.OpSliceLen</span><br><span class="line"><span class="keyword">if</span> n.Op == OCAP &#123;</span><br><span class="line">op = ssa.OpSliceCap</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.newValue1(op, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问切片中的字段可能会触发 <code>decompose builtin</code> 阶段的优化，<code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会被直接替换成切片的长度或者容量，不需要运行时从切片结构中获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(SlicePtr (SliceMake ptr _ _ )) -&gt; ptr</span><br><span class="line">(SliceLen (SliceMake _ <span class="built_in">len</span> _)) -&gt; <span class="built_in">len</span></span><br><span class="line">(SliceCap (SliceMake _ _ <span class="built_in">cap</span>)) -&gt; <span class="built_in">cap</span></span><br></pre></td></tr></table></figure><p>除了获取切片的长度和容量之外，访问切片中元素使用的 <code>OINDEX</code> 操作也会在中间代码生成期间转换成对地址的直接访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OINDEX:</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">p := s.addr(n, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span> s.load(n.Left.Type.Elem(), p)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用 <code>range</code> 遍历切片时也会在编译期间转换成形式更简单的代码，我们会在后面的 <code>range</code> 关键字一节中介绍使用 <code>range</code> 遍历切片的过程。</p><h2 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h2><p>向切片中追加元素应该是最常见的切片操作，在 Go 语言中我们会使用 <code>append</code> 关键字向切片追加元素，中间代码生成阶段的 <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L2732-L2884" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.append</code></a> 方法会拆分 <code>append</code> 关键字，该方法追加元素会根据返回值是否会覆盖原变量，分别进入两种流程，如果 <code>append</code> 返回的『新切片』不需要赋值回原有的变量，就会进入如下的处理流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append(slice, 1, 2, 3)</span></span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(slice, newlen)</span><br><span class="line">    newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>我们会先对切片结构体进行解构获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growslice</code></a> 对切片进行扩容并将新的元素依次加入切片；如果 <code>append</code> 后的切片会覆盖原切片，即 <code>slice = append(slice, 1, 2, 3)</code>， <a href="https://github.com/golang/go/blob/a037582efff56082631508b15b287494df6e9b69/src/cmd/compile/internal/gc/ssa.go#L2732-L2884" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.state.append</code></a> 就会使用另一种方式改写关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice = append(slice, 1, 2, 3)</span></span><br><span class="line">a := &amp;slice</span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint</span>(newlen) &gt; <span class="keyword">uint</span>(<span class="built_in">cap</span>) &#123;</span><br><span class="line">   newptr, <span class="built_in">len</span>, newcap = growslice(slice, newlen)</span><br><span class="line">   vardef(a)</span><br><span class="line">   *a.<span class="built_in">cap</span> = newcap</span><br><span class="line">   *a.ptr = newptr</span><br><span class="line">&#125;</span><br><span class="line">newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">*a.<span class="built_in">len</span> = newlen</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>是否覆盖原变量的逻辑其实差不多，最大的区别在于最后的结果是不是赋值会原有的变量，如果我们选择覆盖原有的变量，也不需要担心切片的拷贝，因为 Go 语言的编译器已经对这种情况作了优化。</p><p><img alt="golang-slice-append" data-src="https://img.draveness.me/2020-03-12-15839729948451-golang-slice-append.png"></p><p>到这里我们已经通过 <code>append</code> 关键字被转换的控制流了解了在切片容量足够时如何向切片中追加元素，但是当切片的容量不足时就会调用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growslice</code></a> 函数为切片扩容，扩容就是为切片分配一块新的内存空间并将原切片的元素全部拷贝过去，我们分几部分分析该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分配内存空间之前需要先确定新的切片容量，Go 语言根据切片的当前容量选择不同的策略进行扩容：</p><ol><li>如果期望容量大于当前容量的两倍就会使用期望容量；</li><li>如果当前切片容量小于 1024 就会将容量翻倍；</li><li>如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li></ol><p>确定了切片的容量之后，就可以计算切片中新数组占用的内存了，计算的方法就是将目标容量和元素大小相乘，计算新容量时可能会发生溢出或者请求的内存超过上限，在这时就会直接 <code>panic</code>，不过相关的代码在这里就被省略了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">capmem, _ = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">capmem = roundupsize(capmem)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">bulkBarrierPreWriteSrcOnly(<span class="keyword">uintptr</span>(p), <span class="keyword">uintptr</span>(old.array), lenmem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memmove(p, old.array, lenmem)</span><br><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果切片中元素不是指针类型，那么就会调用 <code>memclrNoHeapPointers</code> 将超出切片当前长度的位置清空并在最后使用 <code>memmove</code> 将原数组内存中的内容拷贝到新申请的内存中。这里的 <code>memclrNoHeapPointers</code> 和 <code>memmove</code> 都是用目标机器上的汇编指令实现的，在这里就不展开介绍了。</p><p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.growslice</code></a> 函数最终会返回一个新的 <code>slice</code> 结构，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会改变原有的切片，帮助 <code>append</code> 完成元素追加的功能。</p><h2 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h2><p>切片的拷贝虽然不是一个常见的操作类型，但是却是我们学习切片实现原理必须要谈及的一个问题，当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2980-L3040" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.copyany</code></a> 函数也会分两种情况进行处理，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>memmove</code> 会负责对内存进行拷贝，在其他情况下，编译器会使用 <a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L197-L230" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.slicecopy</code></a> 函数替换运行期间调用的 <code>copy</code>，例如：<code>go copy(a, b)</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">n := fm.<span class="built_in">len</span></span><br><span class="line"><span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">n = to.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memmove(to.array, fm.array, size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数的实现非常直接，两种不同的拷贝方式一般都会通过 <code>memmove</code> 将整块内存中的内容拷贝到目标的内存区域中：</p><p><img alt="golang-slice-copy" data-src="https://img.draveness.me/2019-02-20-golang-slice-copy.png"></p><p>相比于依次对元素进行拷贝，这种方式能够提供更好的性能，但是需要注意的是，哪怕使用 <code>memmove</code> 对内存成块进行拷贝，但是这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>切片的很多功能都是在运行时实现的了，无论是初始化切片，还是对切片进行追加或扩容都需要运行时的支持，需要注意的是在遇到大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要在使用时减少这种情况的发生避免对程序的性能造成影响。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.golang.org/slices" target="_blank" rel="external nofollow noopener noreferrer">Arrays, slices (and strings): The mechanics of ‘append’</a></li><li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="external nofollow noopener noreferrer">Go Slices: usage and internals</a></li><li><a href="https://stackoverflow.com/questions/30525184/array-vs-slice-accessing-speed" target="_blank" rel="external nofollow noopener noreferrer">Array vs Slice: accessing speed</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相对于最基本的 Array 数据结构，在 Go 语言中，使用的更多的是 Slice（切片）。Slice 实质上就是动态数组，类似于C++ STL中的 Vector。Slice 的长度并不固定，可以随意向 Slice 中 Append 元素，Slice 在容量不足时会自动扩容。本篇会首先介绍 Slice 的基本使用，然后介绍 Slice 实现的内部原理。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://img.draveness.me/2019-02-20-golang-slice-struct.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="数据结构" scheme="http://houmin.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Slice" scheme="http://houmin.cc/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Array</title>
    <link href="http://houmin.cc/posts/b9b1d0f7/"/>
    <id>http://houmin.cc/posts/b9b1d0f7/</id>
    <published>2020-07-23T04:10:18.000Z</published>
    <updated>2020-08-14T12:56:43.731Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在计算机科学中，数组是一种最早期和最重要的数据结构，是由相同类型的元素（Element）的集合所组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用元素的索引（Index）计算出该元素对应的存储地址，从而快速的访问该元素。最简单的数据结构类型是一维数组，多维数组对应于数学中的矩阵概念，在数值计算和图形学等领域应用比较常见。</p><p>在Go语言中内置了数组这种内置数据结构，本文将首先介绍数组的一般用法，然后深入到运行时来介绍数组的底层实现原理，包括数组的初始化、访问和赋值等操作。</p><a id="more"></a><h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><p>数组作为一种基本的数据类型，需要从两个维度来描述它：</p><ul><li>数组中存储的元素类型</li><li>数组最大能够存储的元素个数</li></ul><p>在 Go 语言中我们可以通过以下方式来表示数组类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">[<span class="number">200</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。在Go语言编译器中，数组的实现表示为：</p><figure class="highlight go"><figcaption><span>cmd/compile/internal/types.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array contains Type fields specific to array types.</span></span><br><span class="line"><span class="keyword">type</span> Array <span class="keyword">struct</span> &#123;</span><br><span class="line">Elem  *Type <span class="comment">// element type</span></span><br><span class="line">Bound <span class="keyword">int64</span> <span class="comment">// number of elements; &lt;0 if unknown yet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 Go 语言中使用数组的简单示例，其中数组的默认值都是0，我们可以通过索引来访问和修改数组中的值，利用内置的 <code>len</code> 方法可以获取数组的长度。另外，我们可以展示了使用多维数组的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Println(<span class="string">"emp:"</span>, a)</span><br><span class="line"></span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">"set:"</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">"get:"</span>, a[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line">    b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"dcl:"</span>, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">            twoD[i][j] = i + j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run arrays.go</span><br><span class="line">emp: [0 0 0 0 0]</span><br><span class="line"><span class="built_in">set</span>: [0 0 0 0 100]</span><br><span class="line">get: 100</span><br><span class="line">len: 5</span><br><span class="line">dcl: [1 2 3 4 5]</span><br><span class="line">2d:  [[0 1 2] [1 2 3]]</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Go 语言中的数组有两种不同的创建方式，一种是显式的指定数组的大小，另一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码对数组的大小进行推断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被『转换』成为前一种，这也就是编译器对数组大小的推导，下面将介绍编译器的推导过程。在编译期间，通过 <code>NewArray</code> 函数生成 Array 数据结构类型。如上所说，类型 <code>Array</code> 包含两个字段，一个是元素类型 <code>Elem</code>，另一个是数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型。而当前数组是否应该在堆栈中初始化也在编译期就确定了：对于Array，设定了其不在Heap中。</p><figure class="highlight go"><figcaption><span>cmd/compile/internal/types.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewArray returns a new fixed-length array Type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">(elem *Type, bound <span class="keyword">int64</span>)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">Fatalf(<span class="string">"NewArray: invalid bound %v"</span>, bound)</span><br><span class="line">&#125;</span><br><span class="line">t := New(TARRAY)</span><br><span class="line">t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;</span><br><span class="line">t.SetNotInHeap(elem.NotInHeap())</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Type</code> 是Go语言中通用的类型定义，其中的Extra字段包含了对于特定类型相关的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Type represents a Go type.</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Extra contains extra etype-specific fields.</span></span><br><span class="line"><span class="comment">// As an optimization, those etype-specific structs which contain exactly</span></span><br><span class="line"><span class="comment">// one pointer-shaped field are stored as values rather than pointers when possible.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TMAP: *Map</span></span><br><span class="line"><span class="comment">// TFORW: *Forward</span></span><br><span class="line"><span class="comment">// TFUNC: *Func</span></span><br><span class="line"><span class="comment">// TSTRUCT: *Struct</span></span><br><span class="line"><span class="comment">// TINTER: *Interface</span></span><br><span class="line"><span class="comment">// TFUNCARGS: FuncArgs</span></span><br><span class="line"><span class="comment">// TCHANARGS: ChanArgs</span></span><br><span class="line"><span class="comment">// TCHAN: *Chan</span></span><br><span class="line"><span class="comment">// TPTR: Ptr</span></span><br><span class="line"><span class="comment">// TARRAY: *Array</span></span><br><span class="line"><span class="comment">// TSLICE: Slice</span></span><br><span class="line">Extra <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Width is the width of this Type in bytes.</span></span><br><span class="line">Width <span class="keyword">int64</span> <span class="comment">// valid if Align &gt; 0</span></span><br><span class="line"></span><br><span class="line">methods    Fields</span><br><span class="line">allMethods Fields</span><br><span class="line"></span><br><span class="line">Nod  *Node <span class="comment">// canonical OTYPE node</span></span><br><span class="line">Orig *Type <span class="comment">// original type (type literal or predefined type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache of composite types, with this type being the element type.</span></span><br><span class="line">Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">ptr   *Type <span class="comment">// *T, or nil</span></span><br><span class="line">slice *Type <span class="comment">// []T, or nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sym    *Sym  <span class="comment">// symbol containing name, for named types</span></span><br><span class="line">Vargen <span class="keyword">int32</span> <span class="comment">// unique name for OTYPE/ONAME</span></span><br><span class="line"></span><br><span class="line">Etype EType <span class="comment">// kind of type</span></span><br><span class="line">Align <span class="keyword">uint8</span> <span class="comment">// the required alignment of this type, in bytes (0 means Width and Align have not yet been computed)</span></span><br><span class="line"></span><br><span class="line">flags bitset8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上限推导"><a href="#上限推导" class="headerlink" title="上限推导"></a>上限推导</h3><p>两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 <code>[10]T</code>，那么变量的类型在编译进行到 <strong>类型检查</strong> 阶段就会被提取出来，随后会使用 <a href="https://github.com/golang/go/blob/616c39f6a636166447bdaac4f0871a5ca52bae8c/src/cmd/compile/internal/types/type.go#L473-L481" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/types.NewArray</code></a> 函数创建包含数组大小的 <code>Array</code> 类型。</p><p>当我们使用 <code>[...]T</code> 的方式声明数组时，虽然在这一步也会创建一个 <code>Array</code> 类型 <code>Array{Elem: elem, Bound: -1}</code>，但是其中的数组大小上限会是 <code>-1</code>，这里的 <code>-1</code> 只是一个占位符，编译器会在后面的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L2755-L2961" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中对该数组的大小进行推导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckcomplit</span><span class="params">(n *Node)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line"><span class="keyword">case</span> TARRAY, TSLICE:</span><br><span class="line"><span class="keyword">var</span> length, i <span class="keyword">int64</span></span><br><span class="line">nl := n.List.Slice()</span><br><span class="line"><span class="keyword">for</span> i2, l := <span class="keyword">range</span> nl &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">length = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.IsDDDArray() &#123;</span><br><span class="line">t.SetNumElem(length)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个删减后的 <a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L2755-L2961" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数通过遍历元素的方式来计算数组中元素的数量。上述代码中的 <code>DDDArray</code> 指的就是使用 <code>[...]T</code> 声明的数组，因为声明这种数组时需要使用三个点（Dot），所以在编译器中就被称作 <code>DDDArray</code>。</p><p>所以我们可以看出 <code>[...]T{1, 2, 3}</code> 和 <code>[3]T{1, 2, 3}</code> 在运行时是完全等价的，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时就可以通过这种方法较少一些工作。</p><h3 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h3><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L875-L967" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p><ol><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">t := n.Type</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line"><span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">      <span class="comment">// lay out static data</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixedlit(inInitFunction, initKindLocalCode, n, var_, init)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组的元素<strong>小于或者等于四个</strong>时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.fixedlit</code></a> 会负责在函数编译之前将 <code>[3]{1, 2, 3}</code> 转换成更加原始的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedlit</span><span class="params">(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> splitnode <span class="function"><span class="keyword">func</span><span class="params">(*Node)</span> <span class="params">(a *Node, value *Node)</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">a, value := splitnode(r)</span><br><span class="line">a = nod(OAS, a, value)</span><br><span class="line">a = typecheck(a, ctxStmt)</span><br><span class="line"><span class="keyword">switch</span> kind &#123;</span><br><span class="line"><span class="keyword">case</span> initKindStatic:</span><br><span class="line">genAsStatic(a)</span><br><span class="line"><span class="keyword">case</span> initKindLocalCode:</span><br><span class="line">a = orderStmtInPlace(a, <span class="keyword">map</span>[<span class="keyword">string</span>][]*Node&#123;&#125;)</span><br><span class="line">a = walkstmt(a)</span><br><span class="line">init.Append(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组中元素的个数小于四个时，<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数接受的 <code>kind</code> 是 <code>initKindLocalCode</code>，上述代码会将原有的初始化语句 <code>[3]int{1, 2, 3}</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>但是如果当前数组的元素大于 4 个，<code>anylit</code> 方法会先获取一个唯一的 <code>staticname</code>，然后调用 <a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L515-L583" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数在静态存储区初始化数组中的元素并将临时变量赋值给当前的数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">t := n.Type</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line"><span class="keyword">if</span> n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">vstat := staticname(t)</span><br><span class="line">vstat.Name.SetReadonly(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">fixedlit(inNonInitFunction, initKindStatic, n, vstat, init)</span><br><span class="line"></span><br><span class="line">a := nod(OAS, var_, vstat)</span><br><span class="line">a = typecheck(a, ctxStmt)</span><br><span class="line">a = walkexpr(a, init)</span><br><span class="line">init.Append(a)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们在代码中初始化 <code>[5]int{1, 2, 3, 4, 5}</code> 数组，那么我们可以将上述过程理解成以下的伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">statictmp_0[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">statictmp_0[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">statictmp_0[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">statictmp_0[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">statictmp_0[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">arr = statictmp_0</span><br></pre></td></tr></table></figure><p>总结起来，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/" target="_blank" rel="external nofollow noopener noreferrer">中间代码生成</a>和<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/" target="_blank" rel="external nofollow noopener noreferrer">机器码生成</a>两个阶段，最后生成可以执行的二进制文件。</p><h2 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h2><p>无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小，如果我们不知道数组中元素的数量，访问时就可能发生越界，而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，如果没有这些信息，我们就无法知道这片连续的内存空间到底存储了什么数据：</p><p><img alt="golang-array-memory" data-src="https://img.draveness.me/2019-12-27-15773821941323-golang-array-memory.png"></p><p>数组访问越界是非常严重的错误，Go 语言中对越界的判断是可以在编译期间由静态类型检查完成的，<a href="https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2081" target="_blank" rel="external nofollow noopener noreferrer"><code>cmd/compile/internal/gc.typecheck1</code></a> 函数会对访问数组的索引进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OINDEX:</span><br><span class="line">ok |= ctxExpr</span><br><span class="line">l := n.Left  <span class="comment">// array</span></span><br><span class="line">r := n.Right <span class="comment">// index</span></span><br><span class="line"><span class="keyword">switch</span> n.Left.Type.Etype &#123;</span><br><span class="line"><span class="keyword">case</span> TSTRING, TARRAY, TSLICE:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> n.Right.Type != <span class="literal">nil</span> &amp;&amp; !n.Right.Type.IsInteger() &#123;</span><br><span class="line">yyerror(<span class="string">"non-integer array index %v"</span>, n.Right)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">x := n.Right.Int64()</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">yyerror(<span class="string">"invalid array index %v (index must be non-negative)"</span>, n.Right)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() &#123;</span><br><span class="line">yyerror(<span class="string">"invalid array index %v (out of bounds for %d-element array)"</span>, n.Right, n.Left.Type.NumElem())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>访问数组的索引是非整数时会直接报错 —— <code>non-integer array index %v</code>；</li><li>访问数组的索引是负数时会直接报错 —— <code>&quot;invalid array index %v (index must be non-negative)&quot;</code>；</li><li>访问数组的索引越界时会直接报错 —— <code>&quot;invalid array index %v (out of bounds for %d-element array)&quot;</code>；</li></ol><p>数组和字符串的一些简单越界错误都会在编译期间发现，比如我们直接使用整数或者常量访问数组，但是如果使用变量去访问数组或者字符串时，编译器就无法发现对应的错误了，这时就需要 Go 语言运行时发挥作用了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">4</span>]: invalid array index <span class="number">4</span> (out of bounds <span class="keyword">for</span> <span class="number">3</span>-element array)</span><br><span class="line">arr[i]: <span class="built_in">panic</span>: runtime error: index out of <span class="keyword">range</span> [<span class="number">4</span>] with length <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <code>panicIndex</code> 和 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L86-L89" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goPanicIndex</code></a> 函数触发程序的运行时错误并导致崩溃退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·panicIndex(SB),NOSPLIT,$<span class="number">0</span><span class="number">-8</span></span><br><span class="line">MOVLAX, x+<span class="number">0</span>(FP)</span><br><span class="line">MOVLCX, y+<span class="number">4</span>(FP)</span><br><span class="line">JMPruntime·goPanicIndex(SB)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goPanicIndex</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">panicCheck1(getcallerpc(), <span class="string">"index out of range"</span>)</span><br><span class="line"><span class="built_in">panic</span>(boundsError&#123;x: <span class="keyword">int64</span>(x), signed: <span class="literal">true</span>, y: y, code: boundsIndex&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组的访问操作 <code>OINDEX</code> 成功通过编译器的检查之后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 <code>ssa.html</code> 文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> check</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outOfRange</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">4</span></span><br><span class="line">elem := arr[i]</span><br><span class="line"><span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOSSAFUNC=outOfRange <span class="keyword">go</span> build array.<span class="keyword">go</span></span><br><span class="line">dumped SSA to ./ssa.html</span><br></pre></td></tr></table></figure><p><code>start</code> 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分就是 <code>elem := arr[i]</code> 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 <code>IsInBounds</code> 以及当条件不满足时触发程序崩溃的 <code>PanicBounds</code> 指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v22 (<span class="number">6</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v20</span><br><span class="line">    v23 (<span class="number">6</span>) = IsInBounds &lt;<span class="keyword">bool</span>&gt; v21 v11</span><br><span class="line">If v23 → b2 b3 (likely) (<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">b2: ← b1-</span><br><span class="line">    v26 (<span class="number">6</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v22 v21</span><br><span class="line">    v27 (<span class="number">6</span>) = Copy &lt;mem&gt; v20</span><br><span class="line">    v28 (<span class="number">6</span>) = Load &lt;<span class="keyword">int</span>&gt; v26 v27 (elem[<span class="keyword">int</span>])</span><br><span class="line">    ...</span><br><span class="line">Ret v30 (+<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">b3: ← b1-</span><br><span class="line">    v24 (<span class="number">6</span>) = Copy &lt;mem&gt; v20</span><br><span class="line">    v25 (<span class="number">6</span>) = PanicBounds &lt;mem&gt; [<span class="number">0</span>] v21 v11 v24</span><br><span class="line">Exit v25 (<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><code>PanicBounds</code> 指令最终会被转换成上面提到的 <code>panicIndex</code> 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标，然后利用 <code>PtrIndex</code> 计算出目标元素的地址，再使用 <code>Load</code> 操作将指针中的元素加载到内存中。</p><p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 <code>PanicBounds</code> 指令交给运行时进行判断，在使用字面量整数访问数组下标时就会生成非常简单的中间代码，当我们将上述代码中的 <code>arr[i]</code> 改成 <code>arr[2]</code> 时，就会得到如下所示的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v21 (<span class="number">5</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v20</span><br><span class="line">    v22 (<span class="number">5</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v21 v14</span><br><span class="line">    v23 (<span class="number">5</span>) = Load &lt;<span class="keyword">int</span>&gt; v22 v20 (elem[<span class="keyword">int</span>])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，而在运行期间这些插入的函数会负责保证不会发生越界错误。</p><p>数组的赋值和更新操作 <code>a[i] = 2</code> 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b1:</span><br><span class="line">    ...</span><br><span class="line">    v21 (<span class="number">5</span>) = LocalAddr &lt;*[<span class="number">3</span>]<span class="keyword">int</span>&gt; &#123;arr&#125; v2 v19</span><br><span class="line">    v22 (<span class="number">5</span>) = PtrIndex &lt;*<span class="keyword">int</span>&gt; v21 v13</span><br><span class="line">    v23 (<span class="number">5</span>) = Store &lt;mem&gt; &#123;<span class="keyword">int</span>&#125; v22 v20 v19</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>赋值的过程中会先确定目标数组的地址，再通过 <code>PtrIndex</code> 获取目标元素的地址，最后使用 <code>Store</code> 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="external nofollow noopener noreferrer">编译期间</a>都会转换成对内存的直接读写，在中间代码生成期间，编译器还会插入运行时方法 <code>panicIndex</code> 调用防止发生越界错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，数组是一种最早期和最重要的数据结构，是由相同类型的元素（Element）的集合所组成的数据结构。计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用元素的索引（Index）计算出该元素对应的存储地址，从而快速的访问该元素。最简单的数据结构类型是一维数组，多维数组对应于数学中的矩阵概念，在数值计算和图形学等领域应用比较常见。&lt;/p&gt;
&lt;p&gt;在Go语言中内置了数组这种内置数据结构，本文将首先介绍数组的一般用法，然后深入到运行时来介绍数组的底层实现原理，包括数组的初始化、访问和赋值等操作。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://img.draveness.me/2019-02-20-3D-array.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="Array" scheme="http://houmin.cc/tags/Array/"/>
    
      <category term="数据结构" scheme="http://houmin.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【备忘录】Linux常见监控指标</title>
    <link href="http://houmin.cc/posts/7f85cd98/"/>
    <id>http://houmin.cc/posts/7f85cd98/</id>
    <published>2020-07-21T09:19:53.000Z</published>
    <updated>2020-07-22T03:36:13.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。</p><a id="more"></a><h2 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h2><p>CPU使用率衡量的是<strong>程序运行占用的CPU百分比</strong>。Linux的CPU使用率信息可以通过/proc/stat文件计算得到。<code>/proc/stat</code>包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计的，单位为jiffies。如下图所示，cpu一行指的是总的CPU信息，cpu0、cpu1、cpu2、cpu3几行指的是CPU各个核的CPU信息。从这里也可以看出这台服务器共有4个核。每列从左到右的<a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external nofollow noopener noreferrer">意思</a>为</p><ul><li><strong>user：</strong>从系统启动开始累计到当前时刻，用户态的CPU时间 ，不包含nice值为负进程所占用的时间</li><li><strong>nice：</strong>从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间</li><li><strong>system：</strong>从系统启动开始累计到当前时刻，内核态时间</li><li><strong>idle：</strong>从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间</li><li><strong>iowait：</strong>从系统启动开始累计到当前时刻，硬盘IO等待时间</li><li><strong>irq：</strong>从系统启动开始累计到当前时刻，硬中断时间</li><li><strong>softirq：</strong>从系统启动开始累计到当前时刻，软中断时间</li><li><strong>steal：</strong>在虚拟环境下 CPU 花在处理其他操作系统的时间，Linux 2.6.11 开始才开始支持。</li><li><strong>guest：</strong>在 Linux 内核控制下 CPU 为 guest 操作系统运行虚拟 CPU 的时间，Linux 2.6.24 开始才开始支持。</li><li><strong>guest_nice:</strong> 在 Linux 内核控制下 CPU 为 guest 操作系统在虚拟 CPU 中运行nice进程的时间，Linux 2.6.33 开始才开始支持。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/<span class="built_in">stat</span> | grep cpu</span><br><span class="line">cpu  180296 204 123070 30283108 13956 0 2046 0 0 0</span><br><span class="line">cpu0 45360 53 30785 7560073 10631 0 771 0 0 0</span><br><span class="line">cpu1 45266 47 30779 7573915 1373 0 508 0 0 0</span><br><span class="line">cpu2 44442 54 30724 7574282 1257 0 405 0 0 0</span><br><span class="line">cpu3 45228 48 30781 7574835 693 0 360 0 0 0</span><br></pre></td></tr></table></figure><p>根据这些信息，就可以计算出CPU使用率。网管Agent的CPU使用率采集算法如下（以CPU0为例）：</p><ul><li>cat /proc/stat | grep ‘cpu0’得到cpu0的信息</li><li>cpu_total1=user+nice+system+idle+iowait+irq+softirq</li><li>cpu_used1=user+nice+system+irq+softirq</li><li>sleep 15秒</li><li>再次cat /proc/stat | grep ‘cpu0’得到cpu的信息</li><li>cpu_total2=user+nice+system+idle+iowait+irq+softirq</li><li>cpu_used2=user+nice+system+irq+softirq</li><li>得到cpu0在15秒内的平均使用率：(cpu_used2 - cpu_used1) / (cpu_total2 - cpu_total1) * 100%</li></ul><p>每分钟会采集4次15秒内的CPU平均使用率。为了避免漏采集CPU峰值，可以取这一分钟内四次采集的最大值上报。</p><h2 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h2><p>系统负载指的是计算机系统执行计算工作的表现，CPU负载指的是在一段时间内计算机的系统负载，一般用1分钟内、5分钟内、15分钟内这三个数字衡量。通过<code>uptime</code>命令可以显示CPU负载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 14:34:03 up 10:43,  4 users,  load average: 0.06, 0.11, 0.09</span><br></pre></td></tr></table></figure><ul><li>对于单核单CPU，CPU负载为0表示CPU完全空闲，CPU负载为1.00表示CPU恰好发挥其最大能力，CPU负载大于1表示系统过载，有进程正在等待调度</li><li>对于多核或者多CPU系统，CPU负载为每个核的CPU负载总和</li></ul><p>关于CPU负载的计算机制，可以参考我的另一篇<a href="../">博客</a>。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p> <code>free</code>命令通过读取 <code>/proc/meminfo</code>，可以显示系统中的使用的和空闲的物理内存、Swap内存，同时也可以显示内核使用的buffer和cache，如下图所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free -w</span><br><span class="line">              total        used        free      shared     buffers       cache   available</span><br><span class="line">Mem:        7773244      311800     2456280         872      233560     4771604     7169352</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>其中各个字段意义为：</p><ul><li>total：所有可以使用的内存（包括/proc/meminfo中的MemTotal和SwapTotal）</li><li>used：使用的内存，通过 <code>total - free - buffers - cache</code> 计算得到</li><li>free：没有使用的内存（包括/proc/meminfo中的MemFree和SwapFree）</li><li>shared：主要是指tmpfs使用的内存，现在已经废弃不用，总是为0</li><li>buffers：被内核Buffers使用的内存</li><li>cache：被内核的Page Cache和Slab使用的内存</li><li>buff/cache：buffers和cache的总和</li><li>available：对于开启一个新的应用还能使用多少内存的估计，不同于cache和free内存外，还考虑了page cache和可再回收的slab内存</li></ul><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p>可以通过 <code>iostat</code>命令来监测磁盘的IO活动，它通过读取 <code>/proc/diskstats</code>文件来获取相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/diskstats</span></span><br><span class="line">3    0   hda 446216 784926 9550688 4382310 424847 312726 5922052 19310380 0 3376340 23705160 0 0 0 0</span><br></pre></td></tr></table></figure><p>hda后的各个参数含义如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Field</span>  <span class="number">1</span> --<span class="meta"> # of reads completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">2</span> --<span class="meta"> # of reads merged, field 6 -- # of writes merged</span></span><br><span class="line">为了提高IO的效率，两个相邻的读写操作会被合并，所以两个<span class="number">4</span>K的读操作在提交给磁盘之前会被合并为一个<span class="number">8</span>K的读操作，杜宇磁盘来说只会视作只有一个读操作。</span><br><span class="line"><span class="keyword">Field</span>  <span class="number">3</span> --<span class="meta"> # of sectors read</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">4</span> --<span class="meta"> # of milliseconds spent reading</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">5</span> --<span class="meta"> # of writes completed</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">6</span> --<span class="meta"> # of writes merged</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">7</span> --<span class="meta"> # of sectors written</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">8</span> --<span class="meta"> # of milliseconds spent writing</span></span><br><span class="line"><span class="keyword">Field</span>  <span class="number">9</span> --<span class="meta"> # of I/Os currently in progress</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">10</span> --<span class="meta"> # of milliseconds spent doing I/Os</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">12</span> --<span class="meta"> # of discards completed</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">13</span> --<span class="meta"> # of discards merged</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">14</span> --<span class="meta"> # of sectors discarded</span></span><br><span class="line"><span class="keyword">Field</span> <span class="number">15</span> --<span class="meta"> # of milliseconds spent discarding</span></span><br></pre></td></tr></table></figure><p>跟记录CPU信息的/proc/stat文件一样，/proc/diskstats中每个字段的数值也是从系统启动后一直累加的。通过这些参数，可以计算出通过 <code>iostat</code>命令算出的参数，具体可以参考<a href="../#iostat">iostat</a> 。我们用delta来表示在时间t内某个字段的增量。例如<strong>定义delta(reads merged)为当前reads merged的值减去t秒前reads merged的值</strong>。</p><ul><li>rrqm/s：delta(<em>reads merged</em>) / t  （得到时间t内平均每秒reads merged的值）</li><li>wrqm/s：delta(<em>writes merged</em>) / t</li><li>r/s：delta(<em>reads completed</em>) / t</li><li>w/s：delta(<em>writes completed</em>) / t</li><li>rsec/s：delta(<em>sectors read</em>) / t</li><li>wsec/s：delta(<em>sectors written</em>) / t</li><li>rkB/s：delta(<em>sectors read</em>) / t / 2  （因为1 扇区为512字节，所以rkB/s为rsec/s的一半）</li><li>wkB/s：delta(<em>sectors written</em>) / t / 2</li><li>avgrq-sz：(delta(<em>sectors read</em>) + delta(<em>sectors written</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li><li><strong>avgqu-sz</strong>：<em>*delta(</em>weighted time spent doing I/Os*) / t / 1000 （单位为毫秒，所以除以1000）</li><li><strong>await：</strong>(delta(<em>time spent reading</em>) + delta(<em>time spent writing</em>)) / (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))</li><li><strong>svctm：</strong>delta(<em>time spent doing I/Os</em>)/ (delta(<em>reads completed</em>) + delta(<em>writes completed</em>))**</li><li><strong>%util：</strong>delta(<em>time spent doing I/Os</em>) / t / 1000 * 100%</li></ul><p>所有磁盘汇总采集项：</p><div class="table-container"><table><thead><tr><th>采集项</th><th>采集项说明</th><th>是否乘以100以保留精度</th></tr></thead><tbody><tr><td>avgqu_sz_max</td><td>所有磁盘avgqu_sz最大值</td><td>是</td></tr><tr><td>svctm_time_max</td><td>所有磁盘svctm最大值</td><td>是</td></tr><tr><td>await_time_max</td><td>所有磁盘await最大值</td><td>是</td></tr><tr><td>util_max</td><td>所有磁盘%util最大值</td><td>否</td></tr><tr><td>disk_total_read</td><td>所有磁盘的r/s总和</td><td>是</td></tr><tr><td>disk_total_write</td><td>所有磁盘的w/s总和</td><td>是</td></tr><tr><td>磁盘IO disk_block_in</td><td>所有磁盘的rkB/s总和。bi即block in，表示从块设备（如磁盘）读取的块数。Linux块设备的块大小都为1024字节，所以disk_bi等于rkB/s。</td><td>否</td></tr><tr><td>磁盘IO disk_block_out</td><td>所有磁盘的rkB/s总和bo即block out，表示发给块设备的块数，即写磁盘。Linux块设备的块大小都为1024字节，所以disk_bi等于wkB/s。</td><td>否</td></tr></tbody></table></div><p>单个磁盘采集项：</p><p>对于安装了1个以上的磁盘的服务器，可以采集单个磁盘的IO数据。最多支持24个盘。</p><div class="table-container"><table><thead><tr><th>采集项</th><th>采集项说明</th><th>是否乘以100以保留精度</th></tr></thead><tbody><tr><td>disk_n_util（n为0-23）</td><td>第n个磁盘的%util值</td><td>否</td></tr><tr><td>disk_n_await</td><td>第n个磁盘的await值</td><td>是</td></tr><tr><td>disk_n_read</td><td>第n个磁盘的r/s值</td><td>是</td></tr><tr><td>disk_n_write</td><td>第n个磁盘的w/s值</td><td>是</td></tr><tr><td>disk_n_block_in</td><td>第n个磁盘的rkB/s值</td><td>否</td></tr><tr><td>disk_n_block_out</td><td>第n个磁盘的wkB/s值</td><td>否</td></tr></tbody></table></div><h2 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h2><h3 id="流量包量"><a href="#流量包量" class="headerlink" title="流量包量"></a>流量包量</h3><p>通过<code>/proc/net/dev</code>文件，可以计算出服务器的流量及包量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/dev</span></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   69570    1756    0    0    0     0          0         0    69570    1756    0    0    0     0       0          0</span><br><span class="line">  eth0: 2012939491 4197833    0    0    0     0          0         0 277523863 3280731    0    0    0     0       0          0</span><br><span class="line">docker0:       0       0    0    0    0     0          0         0        0       0    0    0    0     0       0          0</span><br></pre></td></tr></table></figure><p>与记录CPU信息的 <code>/proc/stat</code>文件类似，<code>/proc/net/dev</code>中的数值，也是从系统启动后一直累加的。</p><p>计算网卡流量方法如下：</p><ul><li>读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes0、receive_packets0、transmit_bytes0、transmit_packets0</li><li>sleep 60秒</li><li>再次读取/proc/net/dev文件，获取eth0的Receive bytes、Receive packets、Transmit bytes、Transmit packets，分别记为receive_bytes1、receive_packets1、transmit_bytes1、transmit_packets1</li><li>根据60秒前后的/proc/net/dev文件，便可计算出下面的指标：<ul><li>60秒内平均每秒入流量：(receive_bytes1 - receive_bytes0) * 8 / 60 / 1000 （kbps）（乘以8是为了把bytes转成bit，除以1000是为了把单位转成k，除以60则是取60秒内的平均值）</li><li>60 秒内平均每秒出流量：(transmit_bytes1 - transmit_bytes0) * 8 / 60 / 1000 （kbps）</li><li>60秒内平均每秒入包数：(receive_packets1 - receive_packets0) / 60 （个）</li><li>60秒内平均每秒出包数：(transmit_packets1 - transmit_packets0) / 60 （个）</li></ul></li></ul><h3 id="TCP连接数"><a href="#TCP连接数" class="headerlink" title="TCP连接数"></a>TCP连接数</h3><p><code>/proc/net/snmp</code>记录了一些TCP信息，其中比较有用的是 <code>CurrEstab</code>字段，即当前已建立的TCP连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/net/snmp</span></span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 3527912 0 23 1893737 0 0 1634151 3266670 18 40 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 92566 32 0 65 0 0 0 0 92501 0 0 0 0 0 93265 0 746 0 0 0 18 0 92501 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType8 OutType0 OutType3 OutType5</span><br><span class="line">IcmpMsg: 65 92501 92501 746 18</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 65567 687 59 249 8 1516787 1268763 805 4 33191 4</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">Udp: 22034 822 0 21968 0 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors IgnoredMulti</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="UDP接收和发送数据报"><a href="#UDP接收和发送数据报" class="headerlink" title="UDP接收和发送数据报"></a>UDP接收和发送数据报</h3><p><code>/proc/net/snmp</code>还记录了一些UDP信息，其中比较有用的是<code>InDatagrams</code>及<code>OutDatagrams</code>字段。 </p><p>UDP接收和发送数据报计算方法与 <code>/proc/net/dev</code>类似，步骤如下：</p><ul><li>读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data0和out_data0</li><li>Sleep 240秒</li><li>再次读取/proc/net/snmp得到InDatagrams及OutDatagrams，分别记为in_data1和out_data1</li><li>根据240秒前后的/proc/net/snmp文件，便可计算下面两个指标：<ul><li>240秒内平均每秒UDP入数据报：(in_data1 - in_data0) / 240</li><li>240秒内平均每秒UDP出数据报：(out_data1 - out_data0) / 240</li></ul></li><li>UDP数据每240上报一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了一些常见的Linux系统监控指标，和它们的计算方式，作为备忘笔记。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://upload.wikimedia.org/wikipedia/commons/b/b1/Htop.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="linux" scheme="http://houmin.cc/tags/linux/"/>
    
      <category term="stats" scheme="http://houmin.cc/tags/stats/"/>
    
      <category term="monitor" scheme="http://houmin.cc/tags/monitor/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】List/Watch机制和Informer模块详解</title>
    <link href="http://houmin.cc/posts/1f0eb2ff/"/>
    <id>http://houmin.cc/posts/1f0eb2ff/</id>
    <published>2020-07-20T07:46:29.000Z</published>
    <updated>2020-07-21T02:16:52.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。</p><a id="more"></a><h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>Kubernetes中的组件，如果要访问Kubernetes中的Object，绝大部分情况下会使用Informer中的Lister()方法，而非直接请求Kubernetes API。</p><h1 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h1><p><img alt="img" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1555472372/article/code-analysis/informer/client-go.png"></p><p><img alt="Client-go Controller Interaction" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-20_client-go-controller-interaction.jpeg"></p><h2 id="client-go组件"><a href="#client-go组件" class="headerlink" title="client-go组件"></a>client-go组件</h2><ul><li><code>Reflector</code>：reflector用来watch特定的k8s API资源。具体的实现是通过<code>ListAndWatch</code>的方法，watch可以是k8s内建的资源或者是自定义的资源。当reflector通过watch API接收到有关新资源实例存在的通知时，它使用相应的列表API获取新创建的对象，并将其放入watchHandler函数内的Delta Fifo队列中。</li><li><code>Informer</code>：informer从Delta Fifo队列中弹出对象。执行此操作的功能是processLoop。base controller的作用是保存对象以供以后检索，并调用我们的控制器将对象传递给它。</li><li><code>Indexer</code>：索引器提供对象的索引功能。典型的索引用例是基于对象标签创建索引。 Indexer可以根据多个索引函数维护索引。Indexer使用线程安全的数据存储来存储对象及其键。 在Store中定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数生成对象的键作为该对象的<code>&lt;namespace&gt; / &lt;name&gt;</code>组合。</li></ul><h2 id="自定义controller组件"><a href="#自定义controller组件" class="headerlink" title="自定义controller组件"></a>自定义controller组件</h2><ul><li><code>Informer reference</code>：指的是Informer实例的引用，定义如何使用自定义资源对象。 自定义控制器代码需要创建对应的Informer。</li><li><code>Indexer reference</code>: 自定义控制器对Indexer实例的引用。自定义控制器需要创建对应的Indexser。</li></ul><blockquote><p>client-go中提供<code>NewIndexerInformer</code>函数可以创建Informer 和 Indexer。</p></blockquote><ul><li><code>Resource Event Handlers</code>：资源事件回调函数，当它想要将对象传递给控制器时，它将被调用。 编写这些函数的典型模式是获取调度对象的key，并将该key排入工作队列以进行进一步处理。</li><li><code>Workqueue</code>：任务队列。 编写资源事件处理程序函数以提取传递的对象的key并将其添加到任务队列。</li><li><code>Process Item</code>：处理任务队列中对象的函数， 这些函数通常使用Indexer引用或Listing包装器来重试与该key对应的对象。</li></ul><h1 id="关键设计"><a href="#关键设计" class="headerlink" title="关键设计"></a>关键设计</h1><p>Informer依赖Kubernetes的List/Watch API。 通过Lister()对象来List/Get对象时，Informer不会去请求Kubernetes API，而是直接查询本地缓存，减少对Kubernetes API的直接调用。</p><p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p><p>Informer组件：</p><ul><li>Controller</li><li>Reflector：通过Kubernetes Watch API监听resource下的所有事件</li><li>Lister：用来被调用List/Get方法</li><li>Processor：记录并触发回调函数</li><li>DeltaFIFO</li><li>LocalStore</li></ul><p>DeltaFIFO和LocalStore是Informer的两级缓存。 DeltaFIFO：用来存储Watch API返回的各种事件。 LocalStore：Lister的List/Get方法访问。</p><p>我们以 Pod 为例，详细说明一下 Informer 的关键逻辑：</p><ol><li>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</li><li>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</li><li>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</li><li>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</li><li>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</li><li>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</li><li>DeltaFIFO 再 Pop 这个事件到 Controller 中</li><li>Controller 收到这个事件，会触发 Processor 的回调函数</li></ol><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737350162-8e7c6121-2b0a-49fa-8ad8-a7b714de3445.png"></p><p>之前说到kubernetes里面的apiserver的只负责数据的CRUD接口实现，并不负责业务逻辑的处理，所以k8s中就通过外挂controller通过对应资源的控制器来负责事件的处理，controller如何感知事件呢？答案就是informer</p><h2 id="基于chunk的消息通知"><a href="#基于chunk的消息通知" class="headerlink" title="基于chunk的消息通知"></a>基于chunk的消息通知</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737386982-feae09ae-ac6d-4090-8ca2-d2f3f5120d61.png"></p><p>watcher的设计在之前的文章中已经介绍，服务端是如何将watcher感知到的事件发送给informer呢？我们提到过apiserver本质上就是一个http的rest接口实现，watch机制则也是基于http协议，不过不同于一般的get其通过chunk机制，来实现消息的通知</p><h2 id="reflector"><a href="#reflector" class="headerlink" title="reflector"></a>reflector</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737435884-518fce5a-0118-4935-be61-0716e2c3ba0c.png"></p><p>服务端通过chunk进行数据的发送，在客户端同样的需要根据对应的chunk来进行数据的解包，同时还要维护这个长链接</p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737496494-8a3052e1-7837-46d9-9513-8d3a64ffe8ba.png"></p><p>通过listwatch接口主要分为两部分，list接口我们可以获取到对应资源当前版本的全量资源，watch接口可以获取到后续变更的资源，通过全量加增量的数据，就构成了在client端一份完整的数据(基于当前版本的)，那后续如果要获取对应的数据，就直接可以通过本地的缓存来进行获取，为此informer抽象了cache这个组件，并且实现了store接口，如果后续要获取资源，则就可以通过本地的缓存来进行获取</p><h2 id="本地索引"><a href="#本地索引" class="headerlink" title="本地索引"></a>本地索引</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737549651-a3636652-fc91-49e1-a91e-9f5e18b05672.png"></p><p>上面将资源缓存在本地的内存中，那如果我们要进行数据查询，快速检索数据，这个时候就需要用到informer里面的indexer, 我们可以注册不同的索引函数，在添加对象的时候，会通过indexer为其建立对应的索引，这样后续我们就可以通过key来检索获取元数据</p><h2 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737669393-995cf89c-87f6-4749-9086-b9febee3a692.png"></p><p>为了协调数据生产与消费的不一致状态，在cleint-go中通过实现了一个无界队列来进行数据的缓冲，当reflector获取到数据之后，只需要将数据写入到无界队列中，则就可以继续watch后续事件，从而减少阻塞时间， 下面的事件去重也是在该队列中实现的</p><h2 id="事件去重"><a href="#事件去重" class="headerlink" title="事件去重"></a>事件去重</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737745807-e10d9521-5633-4cf7-9a0f-90ce2a3dee46.png"></p><p>事件去重是指的，在上面的无界队列中，如果针对某个资源的事件重复被触发，则就只会保留相同事件最后一个事件作为后续处理</p><p>到此对于事件接收和数据缓存相关优化就结束了，接下就是处理层的优化</p><h2 id="复用连接"><a href="#复用连接" class="headerlink" title="复用连接"></a>复用连接</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583737835151-715cdc2b-b53a-4208-85d8-2383fdef8b8f.png"></p><p>在k8s中一些控制器可能会关注多种资源，比如Deployment可能会关注Pod和replicaset，replicaSet可能还会关注Pod，为了避免每个控制器都独立的去与apiserver建立链接，k8s中抽象了sharedInformer的概念，即共享的informer, 针对同一资源只建立一个链接</p><h2 id="基于观察者模式的注册"><a href="#基于观察者模式的注册" class="headerlink" title="基于观察者模式的注册"></a>基于观察者模式的注册</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738078512-ade28ada-2824-46d3-af63-45873a8a37a4.png"></p><p>因为彼此共用informer,但是每个组件的处理逻辑可能各部相同，在informer中通过观察者模式，各个组件可以注册一个EventHandler来实现业务逻辑的注入</p><h2 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h2><p><img alt="image.png" data-src="https://baxiaoshi.cdn.bcebos.com/blog/kubernetes/clientgo/1583738429252-bd646701-8543-47cd-a638-552ac419f5c9.png"></p><h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>该部分的代码主要位于<code>client-go</code>这个第三方包中。</p><p>此部分的逻辑主要位于<code>/vendor/k8s.io/client-go/tools/cache</code>包中，代码目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cache</span><br><span class="line">├── controller.go  <span class="comment"># 包含：Config、Run、processLoop、NewInformer、NewIndexerInformer</span></span><br><span class="line">├── delta_fifo.go  <span class="comment"># 包含：NewDeltaFIFO、DeltaFIFO、AddIfNotPresent</span></span><br><span class="line">├── expiration_cache.go</span><br><span class="line">├── expiration_cache_fakes.go</span><br><span class="line">├── fake_custom_store.go</span><br><span class="line">├── fifo.go   <span class="comment"># 包含：Queue、FIFO、NewFIFO</span></span><br><span class="line">├── heap.go</span><br><span class="line">├── index.go    <span class="comment"># 包含：Indexer、MetaNamespaceIndexFunc</span></span><br><span class="line">├── listers.go</span><br><span class="line">├── listwatch.go   <span class="comment"># 包含：ListerWatcher、ListWatch、List、Watch</span></span><br><span class="line">├── mutation_cache.go</span><br><span class="line">├── mutation_detector.go</span><br><span class="line">├── reflector.go   <span class="comment"># 包含：Reflector、NewReflector、Run、ListAndWatch</span></span><br><span class="line">├── reflector_metrics.go</span><br><span class="line">├── shared_informer.go  <span class="comment"># 包含：NewSharedInformer、WaitForCacheSync、Run、HasSynced</span></span><br><span class="line">├── store.go  <span class="comment"># 包含：Store、MetaNamespaceKeyFunc、SplitMetaNamespaceKey</span></span><br><span class="line">├── testing</span><br><span class="line">│   ├── fake_controller_source.go</span><br><span class="line">├── thread_safe_store.go  <span class="comment"># 包含：ThreadSafeStore、threadSafeMap</span></span><br><span class="line">├── undelta_store.go</span><br></pre></td></tr></table></figure><h2 id="sharedInformerFactory-Start"><a href="#sharedInformerFactory-Start" class="headerlink" title="sharedInformerFactory.Start"></a>sharedInformerFactory.Start</h2><p>在controller-manager的Run函数部分调用了InformerFactory.Start的方法。</p><blockquote><p>此部分代码位于/cmd/kube-controller-manager/app/controllermanager.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">        <span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InformerFactory是一个<code>SharedInformerFactory</code>的接口，接口定义如下：</p><blockquote><p>此部分代码位于vendor/k8s.io/client-go/informers/internalinterfaces/factory_interfaces.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SharedInformerFactory a small interface to allow for adding an informer without an import cycle</span></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    InformerFor(obj runtime.Object, newFunc NewInformerFunc) cache.SharedIndexInformer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。其中，通过<code>startdInformers</code>这个map用来追踪有哪些Informer已经启动，从而可以让Start方法被多次调用。</p><blockquote><p>此部分代码位于vendor/k8s.io/client-go/informers/factory.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start initializes all requested informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> informerType, informer := <span class="keyword">range</span> f.informers &#123;</span><br><span class="line">        <span class="keyword">if</span> !f.startedInformers[informerType] &#123;</span><br><span class="line">            <span class="keyword">go</span> informer.Run(stopCh)</span><br><span class="line">            f.startedInformers[informerType] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sharedIndexInformer-Run"><a href="#sharedIndexInformer-Run" class="headerlink" title="sharedIndexInformer.Run"></a>sharedIndexInformer.Run</h2><blockquote><p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/shared_informer.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ListerWatcher:    s.listerWatcher,</span><br><span class="line">        ObjectType:       s.objectType,</span><br><span class="line">        FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">        RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">        Process: s.HandleDeltas,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">        s.controller = New(cfg)</span><br><span class="line">        s.controller.(*controller).clock = s.clock</span><br><span class="line">        s.started = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">    processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.startedLock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">        s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">    &#125;()</span><br><span class="line">    s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDeltaFIFO"><a href="#NewDeltaFIFO" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><p>DeltaFIFO是一个对象变化的存储队列，依据先进先出的原则，process的函数接收该队列的Pop方法的输出对象来处理相关功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>构造controller的配置文件，构造process，即HandleDeltas，该函数为后面使用到的process函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>调用New(cfg)，构建sharedIndexInformer的controller。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">    s.controller = New(cfg)</span><br><span class="line">    s.controller.(*controller).clock = s.clock</span><br><span class="line">    s.started = <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="cacheMutationDetector-Run"><a href="#cacheMutationDetector-Run" class="headerlink" title="cacheMutationDetector.Run"></a>cacheMutationDetector.Run</h3><p>调用s.cacheMutationDetector.Run，检查缓存对象是否变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br></pre></td></tr></table></figure><p><strong>defaultCacheMutationDetector.Run</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we DON'T want protection from panics.  If we're running this code, we want to die</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d.CompareObjects()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(d.period):</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CompareObjects</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultCacheMutationDetector)</span> <span class="title">CompareObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> d.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    altered := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, obj := <span class="keyword">range</span> d.cachedObjs &#123;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(obj.cached, obj.copied) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"CACHE %s[%d] ALTERED!\n%v\n"</span>, d.name, i, diff.ObjectDiff(obj.cached, obj.copied))</span><br><span class="line">            altered = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> altered &#123;</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"cache %s modified"</span>, d.name)</span><br><span class="line">        <span class="keyword">if</span> d.failureFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">            d.failureFunc(msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processor-run"><a href="#processor-run" class="headerlink" title="processor.run"></a>processor.run</h3><p>调用s.processor.run，将调用sharedProcessor.run，会调用Listener.run和Listener.pop,执行处理queue的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.processor.run)</span><br></pre></td></tr></table></figure><p><strong>sharedProcessor.Run</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.listenersLock.RLock()</span><br><span class="line">        <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            p.wg.Start(listener.run)</span><br><span class="line">            p.wg.Start(listener.pop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">        <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分逻辑待后面分析。</p><h3 id="controller-Run"><a href="#controller-Run" class="headerlink" title="controller.Run"></a>controller.Run</h3><p>调用s.controller.Run，构建Reflector，进行对etcd的缓存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.startedLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">    s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">&#125;()</span><br><span class="line">s.controller.Run(stopCh)</span><br></pre></td></tr></table></figure><p>controller.Run</p><blockquote><p>此部分代码位于/vendor/k8s.io/client-go/tools/cache/controller.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins processing items, and will continue until a value is sent down stopCh.</span></span><br><span class="line"><span class="comment">// It's an error to call Run more than once.</span></span><br><span class="line"><span class="comment">// Run blocks; call via go.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopCh</span><br><span class="line">        c.config.Queue.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    r.ShouldResync = c.config.ShouldResync</span><br><span class="line">    r.clock = c.clock</span><br><span class="line"></span><br><span class="line">    c.reflectorMutex.Lock()</span><br><span class="line">    c.reflector = r</span><br><span class="line">    c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line"></span><br><span class="line">    wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建Reflector</span></span><br><span class="line">r := NewReflector(</span><br><span class="line">    c.config.ListerWatcher,</span><br><span class="line">    c.config.ObjectType,</span><br><span class="line">    c.config.Queue,</span><br><span class="line">    c.config.FullResyncPeriod,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 运行Reflector</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"><span class="comment">// 执行processLoop</span></span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br></pre></td></tr></table></figure><h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><h3 id="Reflector-1"><a href="#Reflector-1" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p><p>常用属性说明：</p><ul><li>expectedType：期望放入缓存store的资源类型。</li><li>store：watch的资源对应的本地缓存。</li><li>listerWatcher：list和watch的接口。</li><li>period：watch的周期，默认为1秒。</li><li>resyncPeriod：resync的周期，当非零的时候，会按该周期执行list。</li><li>lastSyncResourceVersion：最新一次看到的资源的版本号，主要在watch时候使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflector watches a specified resource and causes all changes to be reflected in the given store.</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// name identifies this reflector. By default it will be a file:line if possible.</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">    metrics *reflectorMetrics</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The type of object we expect to place in the store.</span></span><br><span class="line">    expectedType reflect.Type</span><br><span class="line">    <span class="comment">// The destination to sync up with the watch source</span></span><br><span class="line">    store Store</span><br><span class="line">    <span class="comment">// listerWatcher is used to perform lists and watches.</span></span><br><span class="line">    listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// period controls timing between one watch ending and</span></span><br><span class="line">    <span class="comment">// the beginning of the next one.</span></span><br><span class="line">    period       time.Duration</span><br><span class="line">    resyncPeriod time.Duration</span><br><span class="line">    ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// lastSyncResourceVersion is the resource version token last</span></span><br><span class="line">    <span class="comment">// observed when doing a sync with the underlying store</span></span><br><span class="line">    <span class="comment">// it is thread safe, but not synchronized with the underlying store</span></span><br><span class="line">    lastSyncResourceVersion <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">    lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewReflector"><a href="#NewReflector" class="headerlink" title="NewReflector"></a>NewReflector</h3><p>NewReflector主要用来构建Reflector的结构体。</p><blockquote><p>此部分的代码位于/vendor/k8s.io/client-go/tools/cache/reflector.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReflector creates a new Reflector object which will keep the given store up to</span></span><br><span class="line"><span class="comment">// date with the server's contents for the given resource. Reflector promises to</span></span><br><span class="line"><span class="comment">// only put things in the store that have the type of expectedType, unless expectedType</span></span><br><span class="line"><span class="comment">// is nil. If resyncPeriod is non-zero, then lists will be executed after every</span></span><br><span class="line"><span class="comment">// resyncPeriod, so that you can use reflectors to periodically process everything as</span></span><br><span class="line"><span class="comment">// well as incrementally processing the things that change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflectorDisambiguator is used to disambiguate started reflectors.</span></span><br><span class="line"><span class="comment">// initialized to an unstable value to ensure meaning isn't attributed to the suffix.</span></span><br><span class="line"><span class="keyword">var</span> reflectorDisambiguator = <span class="keyword">int64</span>(time.Now().UnixNano() % <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reflector-Run"><a href="#Reflector-Run" class="headerlink" title="Reflector.Run"></a>Reflector.Run</h3><p>Reflector.Run主要执行了<code>ListAndWatch</code>的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span></span><br><span class="line"><span class="comment">// Run will exit when stopCh is closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedType, r.resyncPeriod, r.name)</span><br><span class="line">    wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            utilruntime.HandleError(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListAndWatch first lists all items and get the resource version at the moment of call,</span></span><br><span class="line"><span class="comment">// and then use the resource version to watch.</span></span><br><span class="line"><span class="comment">// It returns error if ListAndWatch didn't even try to initialize watch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    glog.V(<span class="number">3</span>).Infof(<span class="string">"Listing and watching %v from %s"</span>, r.expectedType, r.name)</span><br><span class="line">    <span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicitly set "0" as resource version - it's fine for the List()</span></span><br><span class="line">    <span class="comment">// to be served from cache and potentially be delayed relative to</span></span><br><span class="line">    <span class="comment">// etcd contents. Reflector framework will catch up via Watch() eventually.</span></span><br><span class="line">    options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line">    r.metrics.numberOfLists.Inc()</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    list, err := r.listerWatcher.List(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Failed to list %v: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.listDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v: %v"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line">    items, err := meta.ExtractList(list)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to understand list result %#v (%v)"</span>, r.name, list, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.metrics.numberOfItemsInList.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(items)))</span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">    &#125;</span><br><span class="line">    r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将资源的版本号设置为0，然后调用<code>listerWatcher.List(options)</code>，列出所有list的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号设置为0</span></span><br><span class="line">options := metav1.ListOptions&#123;ResourceVersion: <span class="string">"0"</span>&#125;</span><br><span class="line"><span class="comment">// list接口</span></span><br><span class="line">list, err := r.listerWatcher.List(options)</span><br></pre></td></tr></table></figure><p>获取资源版本号，并将list的内容提取成对象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line">resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line"><span class="comment">// 将list的内容提取成对象列表</span></span><br><span class="line">items, err := meta.ExtractList(list)</span><br></pre></td></tr></table></figure><p>将list中对象列表的内容和版本号存储到本地的缓存store中，并全量替换已有的store的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.syncWith(items, resourceVersion)</span><br></pre></td></tr></table></figure><p>syncWith调用了store的Replace的方法来替换原来store中的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncWith replaces the store's items with the given list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        found = <span class="built_in">append</span>(found, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Store.Replace方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后设置最新的资源版本号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.setLastSyncResourceVersion(resourceVersion)</span><br></pre></td></tr></table></figure><p>setLastSyncResourceVersion:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">setLastSyncResourceVersion</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    r.lastSyncResourceVersionMutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.lastSyncResourceVersionMutex.Unlock()</span><br><span class="line">    r.lastSyncResourceVersion = v</span><br><span class="line"></span><br><span class="line">    rv, err := strconv.Atoi(v)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.metrics.lastResourceVersion.Set(<span class="keyword">float64</span>(rv))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="store-Resync"><a href="#store-Resync" class="headerlink" title="store.Resync"></a>store.Resync</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resyncerrc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">cancelCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(cancelCh)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resyncCh, cleanup := r.resyncChan()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cleanup() <span class="comment">// Call the last one written into cleanup</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.ShouldResync == <span class="literal">nil</span> || r.ShouldResync() &#123;</span><br><span class="line">            glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: forcing resync"</span>, r.name)</span><br><span class="line">            <span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                resyncerrc &lt;- err</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanup()</span><br><span class="line">        resyncCh, cleanup = r.resyncChan()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.store.Resync()</span><br></pre></td></tr></table></figure><p>store的具体对象为<code>DeltaFIFO</code>，即调用DeltaFIFO.Resync</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resync will send a sync event for each item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keys := f.knownObjects.ListKeys()</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">    options = metav1.ListOptions&#123;</span><br><span class="line">        ResourceVersion: resourceVersion,</span><br><span class="line">        <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">        <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">        TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.metrics.numberOfWatches.Inc()</span><br><span class="line">    w, err := r.listerWatcher.Watch(options)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">        <span class="keyword">case</span> io.EOF:</span><br><span class="line">            <span class="comment">// watch closed normally</span></span><br><span class="line">        <span class="keyword">case</span> io.ErrUnexpectedEOF:</span><br><span class="line">            glog.V(<span class="number">1</span>).Infof(<span class="string">"%s: Watch for %v closed with unexpected EOF: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: Failed to watch %v: %v"</span>, r.name, r.expectedType, err))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If this is "connection refused" error, it means that most likely apiserver is not responsive.</span></span><br><span class="line">        <span class="comment">// It doesn't make sense to re-list all objects because most likely we will be able to restart</span></span><br><span class="line">        <span class="comment">// watch where we ended.</span></span><br><span class="line">        <span class="comment">// If that's the case wait and resend watch request.</span></span><br><span class="line">        <span class="keyword">if</span> urlError, ok := err.(*url.Error); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> opError, ok := urlError.Err.(*net.OpError); ok &#123;</span><br><span class="line">                <span class="keyword">if</span> errno, ok := opError.Err.(syscall.Errno); ok &amp;&amp; errno == syscall.ECONNREFUSED &#123;</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">            glog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置watch的超时时间，默认为5分钟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timemoutseconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">options = metav1.ListOptions&#123;</span><br><span class="line">    ResourceVersion: resourceVersion,</span><br><span class="line">    <span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">    <span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">    TimeoutSeconds: &amp;timemoutseconds,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行listerWatcher.Watch(options)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w, err := r.listerWatcher.Watch(options)</span><br></pre></td></tr></table></figure><p>执行watchHandler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh)</span><br></pre></td></tr></table></figure><h4 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h4><p>watchHandler主要是通过watch的方式保证当前的资源版本是最新的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    start := r.clock.Now()</span><br><span class="line">    eventCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stopping the watcher should be idempotent and if we return from this function there's no way</span></span><br><span class="line">    <span class="comment">// we're coming back in with the same watch interface.</span></span><br><span class="line">    <span class="keyword">defer</span> w.Stop()</span><br><span class="line">    <span class="comment">// update metrics</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r.metrics.numberOfItemsInWatch.Observe(<span class="keyword">float64</span>(eventCount))</span><br><span class="line">        r.metrics.watchDuration.Observe(time.Since(start).Seconds())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span> errorStopRequested</span><br><span class="line">        <span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> event.Type == watch.Error &#123;</span><br><span class="line">                <span class="keyword">return</span> apierrs.FromObject(event.Object)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="literal">nil</span> &amp;&amp; e != a &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: expected type %v, but watch event object had type %v"</span>, r.name, e, a))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            meta, err := meta.Accessor(event.Object)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">            <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">            <span class="keyword">case</span> watch.Added:</span><br><span class="line">                err := r.store.Add(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Modified:</span><br><span class="line">                err := r.store.Update(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> watch.Deleted:</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">                <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">                <span class="comment">// to change this.</span></span><br><span class="line">                err := r.store.Delete(event.Object)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">            &#125;</span><br><span class="line">            *resourceVersion = newResourceVersion</span><br><span class="line">            r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">            eventCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchDuration := r.clock.Now().Sub(start)</span><br><span class="line">    <span class="keyword">if</span> watchDuration &lt; <span class="number">1</span>*time.Second &amp;&amp; eventCount == <span class="number">0</span> &#123;</span><br><span class="line">        r.metrics.numberOfShortWatches.Inc()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received"</span>, r.name)</span><br><span class="line">    &#125;</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"%s: Watch close - %v total %v items received"</span>, r.name, r.expectedType, eventCount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取watch接口中的事件的channel，来获取事件的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获得添加、更新、删除的事件时，将对应的对象更新到本地缓存store中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event.Type &#123;</span><br><span class="line"><span class="keyword">case</span> watch.Added:</span><br><span class="line">    err := r.store.Add(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Modified:</span><br><span class="line">    err := r.store.Update(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> watch.Deleted:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Will any consumers need access to the "last known</span></span><br><span class="line">    <span class="comment">// state", which is passed in event.Object? If so, may need</span></span><br><span class="line">    <span class="comment">// to change this.</span></span><br><span class="line">    err := r.store.Delete(event.Object)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新当前的最新版本号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">*resourceVersion = newResourceVersion</span><br><span class="line">r.setLastSyncResourceVersion(newResourceVersion)</span><br></pre></td></tr></table></figure><p>通过对Reflector模块的分析，可以看到多次使用到本地缓存store模块，而store的数据由DeltaFIFO赋值而来，以下针对DeltaFIFO和store做分析。</p><h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO由NewDeltaFIFO初始化，并赋值给config.Queue。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, <span class="literal">nil</span>, s.indexer)</span><br><span class="line"></span><br><span class="line">    cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDeltaFIFO-1"><a href="#NewDeltaFIFO-1" class="headerlink" title="NewDeltaFIFO"></a>NewDeltaFIFO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeltaFIFO returns a Store which can be used process changes to items.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// keyFunc is used to figure out what key an object should have. (It's</span></span><br><span class="line"><span class="comment">// exposed in the returned DeltaFIFO's KeyOf() method, with bonus features.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'compressor' may compress as many or as few items as it wants</span></span><br><span class="line"><span class="comment">// (including returning an empty slice), but it should do what it</span></span><br><span class="line"><span class="comment">// does quickly since it is called while the queue is locked.</span></span><br><span class="line"><span class="comment">// 'compressor' may be nil if you don't want any delta compression.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 'keyLister' is expected to return a list of keys that the consumer of</span></span><br><span class="line"><span class="comment">// this queue "knows about". It is used to decide which items are missing</span></span><br><span class="line"><span class="comment">// when Replace() is called; 'Deleted' deltas are produced for these items.</span></span><br><span class="line"><span class="comment">// It may be nil if you don't need to detect all deletions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> consider merging keyLister with this object, tracking a list of</span></span><br><span class="line"><span class="comment">//       "known" keys when Pop() is called. Have to think about how that</span></span><br><span class="line"><span class="comment">//       affects error retrying.</span></span><br><span class="line"><span class="comment">// TODO(lavalamp): I believe there is a possible race only when using an</span></span><br><span class="line"><span class="comment">//                 external known object source that the above TODO would</span></span><br><span class="line"><span class="comment">//                 fix.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Also see the comment on DeltaFIFO. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeltaFIFO</span><span class="params">(keyFunc KeyFunc, compressor DeltaCompressor, knownObjects KeyListerGetter)</span> *<span class="title">DeltaFIFO</span></span> &#123;</span><br><span class="line">    f := &amp;DeltaFIFO&#123;</span><br><span class="line">        items:           <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas&#123;&#125;,</span><br><span class="line">        queue:           []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">        keyFunc:         keyFunc,</span><br><span class="line">        deltaCompressor: compressor,</span><br><span class="line">        knownObjects:    knownObjects,</span><br><span class="line">    &#125;</span><br><span class="line">    f.cond.L = &amp;f.lock</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller.Run的部分调用了NewReflector。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    r := NewReflector(</span><br><span class="line">        c.config.ListerWatcher,</span><br><span class="line">        c.config.ObjectType,</span><br><span class="line">        c.config.Queue,</span><br><span class="line">        c.config.FullResyncPeriod,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewReflector构造函数，将c.config.Queue赋值给Reflector.store的属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReflector</span><span class="params">(lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">    reflectorSuffix := atomic.AddInt64(&amp;reflectorDisambiguator, <span class="number">1</span>)</span><br><span class="line">    r := &amp;Reflector&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        <span class="comment">// we need this to be unique per process (some names are still the same)but obvious who it belongs to</span></span><br><span class="line">        metrics:       newReflectorMetrics(makeValidPromethusMetricLabel(fmt.Sprintf(<span class="string">"reflector_"</span>+name+<span class="string">"_%d"</span>, reflectorSuffix))),</span><br><span class="line">        listerWatcher: lw,</span><br><span class="line">        store:         store,</span><br><span class="line">        expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">        period:        time.Second,</span><br><span class="line">        resyncPeriod:  resyncPeriod,</span><br><span class="line">        clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DeltaFIFO-1"><a href="#DeltaFIFO-1" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p><p>DeltaFIFO主要用在以下场景：</p><ul><li>希望对象变更最多处理一次</li><li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li><li>要处理对象的删除</li><li>希望定期重新处理对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaFIFO is like FIFO, but allows you to process deletes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO is a producer-consumer queue, where a Reflector is</span></span><br><span class="line"><span class="comment">// intended to be the producer, and the consumer is whatever calls</span></span><br><span class="line"><span class="comment">// the Pop() method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO solves this use case:</span></span><br><span class="line"><span class="comment">//  * You want to process every object change (delta) at most once.</span></span><br><span class="line"><span class="comment">//  * When you process an object, you want to see everything</span></span><br><span class="line"><span class="comment">//    that's happened to it since you last processed it.</span></span><br><span class="line"><span class="comment">//  * You want to process the deletion of objects.</span></span><br><span class="line"><span class="comment">//  * You might want to periodically reprocess objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DeltaFIFO's Pop(), Get(), and GetByKey() methods return</span></span><br><span class="line"><span class="comment">// interface&#123;&#125; to satisfy the Store/Queue interfaces, but it</span></span><br><span class="line"><span class="comment">// will always return an object of type Deltas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on threading: If you call Pop() in parallel from multiple</span></span><br><span class="line"><span class="comment">// threads, you could end up with multiple threads processing slightly</span></span><br><span class="line"><span class="comment">// different versions of the same object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A note on the KeyLister used by the DeltaFIFO: It's main purpose is</span></span><br><span class="line"><span class="comment">// to list keys that are "known", for the purpose of figuring out which</span></span><br><span class="line"><span class="comment">// items have been deleted when Replace() or Delete() are called. The deleted</span></span><br><span class="line"><span class="comment">// object will be included in the DeleteFinalStateUnknown markers. These objects</span></span><br><span class="line"><span class="comment">// could be stale.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may provide a function to compress deltas (e.g., represent a</span></span><br><span class="line"><span class="comment">// series of Updates as a single Update).</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// lock/cond protects access to 'items' and 'queue'.</span></span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    cond sync.Cond</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We depend on the property that items in the set are in</span></span><br><span class="line">    <span class="comment">// the queue and vice versa, and that all Deltas in this</span></span><br><span class="line">    <span class="comment">// map have at least one Delta.</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">    <span class="comment">// or Delete/Add/Update was called first.</span></span><br><span class="line">    populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">    initialPopulationCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// keyFunc is used to make the key used for queued item</span></span><br><span class="line">    <span class="comment">// insertion and retrieval, and should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deltaCompressor tells us how to combine two or more</span></span><br><span class="line">    <span class="comment">// deltas. It may be nil.</span></span><br><span class="line">    deltaCompressor DeltaCompressor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// knownObjects list keys that are "known", for the</span></span><br><span class="line">    <span class="comment">// purpose of figuring out which items have been deleted</span></span><br><span class="line">    <span class="comment">// when Replace() or Delete() is called.</span></span><br><span class="line">    knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indication the queue is closed.</span></span><br><span class="line">    <span class="comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span></span><br><span class="line">    <span class="comment">// Currently, not used to gate any of CRED operations.</span></span><br><span class="line">    closed     <span class="keyword">bool</span></span><br><span class="line">    closedLock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-amp-Store"><a href="#Queue-amp-Store" class="headerlink" title="Queue &amp; Store"></a>Queue &amp; Store</h3><p>DeltaFIFO的类型是Queue接口，Reflector.store是Store接口，Queue接口是一个存储队列，Process的方法执行Queue.Pop出来的数据对象，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue is exactly like a Store, but has a Pop() method too.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">    Store</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pop blocks until it has something to process.</span></span><br><span class="line">    <span class="comment">// It returns the object that was process and the result of processing.</span></span><br><span class="line">    <span class="comment">// The PopProcessFunc may return an ErrRequeue&#123;...&#125; to indicate the item</span></span><br><span class="line">    <span class="comment">// should be requeued before releasing the lock on the queue.</span></span><br><span class="line">    Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIfNotPresent adds a value previously</span></span><br><span class="line">    <span class="comment">// returned by Pop back into the queue as long</span></span><br><span class="line">    <span class="comment">// as nothing else (presumably more recent)</span></span><br><span class="line">    <span class="comment">// has since been added.</span></span><br><span class="line">    AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if the first batch of items has been popped</span></span><br><span class="line">    HasSynced() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close queue</span></span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p><p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store is a generic object storage interface. Reflector knows how to watch a server</span></span><br><span class="line"><span class="comment">// and update a store. A generic store is provided, which allows Reflector to be used</span></span><br><span class="line"><span class="comment">// as a local caching system, and an LRU store, which allows Reflector to work like a</span></span><br><span class="line"><span class="comment">// queue of items yet to be processed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Store makes no assumptions about stored object identity; it is the responsibility</span></span><br><span class="line"><span class="comment">// of a Store implementation to provide a mechanism to correctly key objects and to</span></span><br><span class="line"><span class="comment">// define the contract for obtaining objects by some arbitrary key type.</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">    GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Replace</code>方法会删除原来store中的内容，并将新增的list的内容存入store中，即完全替换数据。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache实现了store的接口，而cache的具体实现又是调用<code>ThreadSafeStore</code>接口来实现功能的。</p><p>cache的功能主要有以下两点：</p><ul><li>通过keyFunc计算对象的key</li><li>调用ThreadSafeStorage接口的方法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache responsibilities are limited to:</span></span><br><span class="line"><span class="comment">//  1. Computing keys for objects via keyFunc</span></span><br><span class="line"><span class="comment">//  2. Invoking methods of a ThreadSafeStorage interface</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">    <span class="comment">// should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ListAndWatch主要用到以下的方法：</p><p><strong>cache.Replace</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace will delete the contents of 'c', using instead the given list.</span></span><br><span class="line"><span class="comment">// 'c' takes ownership of the list, you should not reference the list again</span></span><br><span class="line"><span class="comment">// after calling this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Replace</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">        key, err := c.keyFunc(item)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[key] = item</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Replace(items, resourceVersion)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Add</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add inserts an item into the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Add(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Update</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update sets an item in the cache to its updated state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Update</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Update(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cache.Delete</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete removes an item from the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Delete</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Delete(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p>cache的具体是调用<code>ThreadSafeStore</code>来实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadSafeStore is an interface that allows concurrent access to a storage backend.</span></span><br><span class="line"><span class="comment">// TL;DR caveats: you must not modify anything returned by Get or List as it will break</span></span><br><span class="line"><span class="comment">// the indexing feature in addition to not being thread safe.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The guarantees of thread safety provided by List/Get are only valid if the caller</span></span><br><span class="line"><span class="comment">// treats returned items as read-only. For example, a pointer inserted in the store</span></span><br><span class="line"><span class="comment">// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`</span></span><br><span class="line"><span class="comment">// on the same key and modify the pointer in a non-thread-safe way. Also note that</span></span><br><span class="line"><span class="comment">// modifying objects stored by the indexers (if any) will *not* automatically lead</span></span><br><span class="line"><span class="comment">// to a re-index. So it's not a good idea to directly modify the objects returned by</span></span><br><span class="line"><span class="comment">// Get/List, in general.</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Update(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">    Get(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="keyword">string</span></span><br><span class="line">    Replace(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>)</span><br><span class="line">    Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">    ListIndexFuncValues(name <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) error</span><br><span class="line">    Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>threadSafeMap</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  sync.RWMutex</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">    indexers Indexers</span><br><span class="line">    <span class="comment">// indices maps a name to an Index</span></span><br><span class="line">    indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop"></a>processLoop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller.Run方法中会调用processLoop，以下分析<code>processLoop</code>的处理逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processLoop drains the work queue.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span></span><br><span class="line"><span class="comment">// to make sure that we don't end up processing the same object multiple times</span></span><br><span class="line"><span class="comment">// concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span></span><br><span class="line"><span class="comment">// actually exit when the controller is stopped. Or just give up on this stuff</span></span><br><span class="line"><span class="comment">// ever being stoppable. Converting this whole package to use Context would</span></span><br><span class="line"><span class="comment">// also be helpful.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">                <span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">                c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processLoop主要处理任务队列中的任务，其中处理逻辑是调用具体的<code>ProcessFunc</code>函数来实现，核心代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br></pre></td></tr></table></figure><h3 id="DeltaFIFO-Pop"><a href="#DeltaFIFO-Pop" class="headerlink" title="DeltaFIFO.Pop"></a>DeltaFIFO.Pop</h3><p>Pop会阻塞住直到队列里面添加了新的对象，如果有多个对象，按照先进先出的原则处理，如果某个对象没有处理成功会重新被加入该队列中。</p><p>Pop中会调用具体的process函数来处理对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop blocks until an item is added to the queue, and then returns it.  If</span></span><br><span class="line"><span class="comment">// multiple items are ready, they are returned in the order in which they were</span></span><br><span class="line"><span class="comment">// added/updated. The item is removed from the queue (and the store) before it</span></span><br><span class="line"><span class="comment">// is returned, so if you don't successfully process it, you need to add it back</span></span><br><span class="line"><span class="comment">// with AddIfNotPresent().</span></span><br><span class="line"><span class="comment">// process function is called under lock, so it is safe update data structures</span></span><br><span class="line"><span class="comment">// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc</span></span><br><span class="line"><span class="comment">// may return an instance of ErrRequeue with a nested error to indicate the current</span></span><br><span class="line"><span class="comment">// item should be requeued (equivalent to calling AddIfNotPresent under the lock).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Pop returns a 'Deltas', which has a complete list of all the things</span></span><br><span class="line"><span class="comment">// that happened to the object (deltas) while it was sitting in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">            <span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">            <span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">            <span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        id := f.queue[<span class="number">0</span>]</span><br><span class="line">        f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">        item, ok := f.items[id]</span><br><span class="line">        <span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            f.initialPopulationCount--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        err := process(item)</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">            f.addIfNotPresent(id, item)</span><br><span class="line">            err = e.Err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">        <span class="comment">// ownership to the caller.</span></span><br><span class="line">        <span class="keyword">return</span> item, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    item, ok := f.items[id]</span><br><span class="line">    ...</span><br><span class="line">    err := process(item)</span><br><span class="line">    <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">        f.addIfNotPresent(id, item)</span><br><span class="line">        err = e.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">    <span class="comment">// ownership to the caller.</span></span><br><span class="line">    <span class="keyword">return</span> item, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas"></a>HandleDeltas</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cfg := &amp;Config&#123;</span><br><span class="line">    Queue:            fifo,</span><br><span class="line">    ListerWatcher:    s.listerWatcher,</span><br><span class="line">    ObjectType:       s.objectType,</span><br><span class="line">    FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">    RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">    ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">    Process: s.HandleDeltas,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中process函数就是在sharedIndexInformer.Run方法中，给config.Process赋值的<code>HandleDeltas</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.blockDeltas.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from oldest to newest</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">        <span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">            isSync := d.Type == Sync</span><br><span class="line">            s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">            <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Deleted:</span><br><span class="line">            <span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> d.Type &#123;</span><br><span class="line"><span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> Deleted:</span><br><span class="line">    ...</span><br><span class="line">    s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的类型，调用<code>processor.distribute</code>方法，该方法将对象加入<code>processorListener</code>的channel中。</p><h3 id="sharedProcessor-distribute"><a href="#sharedProcessor-distribute" class="headerlink" title="sharedProcessor.distribute"></a>sharedProcessor.distribute</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p.listenersLock.RLock()</span><br><span class="line">    <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sync &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">            listener.add(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>processorListener.add:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">add</span><span class="params">(notification <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    p.addCh &lt;- notification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合以上的分析，可以看出processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。以下分析processorListener.Run的部分。</p><h2 id="processor"><a href="#processor" class="headerlink" title="processor"></a>processor</h2><p>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p><p>流程：</p><ol><li>listenser的add函数负责将notify装进pendingNotifications。</li><li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li><li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sharedProcessor-Run"><a href="#sharedProcessor-Run" class="headerlink" title="sharedProcessor.Run"></a>sharedProcessor.Run</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      p.listenersLock.RLock()</span><br><span class="line">      <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">      <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">         p.wg.Start(listener.run)</span><br><span class="line">         p.wg.Start(listener.pop)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   &lt;-stopCh</span><br><span class="line">   p.listenersLock.RLock()</span><br><span class="line">   <span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line">   <span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">      <span class="built_in">close</span>(listener.addCh) <span class="comment">// Tell .pop() to stop. .pop() will tell .run() to stop</span></span><br><span class="line">   &#125;</span><br><span class="line">   p.wg.Wait() <span class="comment">// Wait for all .pop() and .run() to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener-pop"><a href="#listener-pop" class="headerlink" title="listener.pop"></a>listener.pop</h4><p>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(p.nextCh) <span class="comment">// Tell .run() to stop</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextCh <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> notification <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nextCh &lt;- notification:</span><br><span class="line">            <span class="comment">// Notification dispatched</span></span><br><span class="line">            <span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">            notification, ok = p.pendingNotifications.ReadOne()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123; <span class="comment">// Nothing to pop</span></span><br><span class="line">                nextCh = <span class="literal">nil</span> <span class="comment">// Disable this select case</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> notificationToAdd, ok := &lt;-p.addCh:</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> notification == <span class="literal">nil</span> &#123; <span class="comment">// No notification to pop (and pendingNotifications is empty)</span></span><br><span class="line">                <span class="comment">// Optimize the case - skip adding to pendingNotifications</span></span><br><span class="line">                notification = notificationToAdd</span><br><span class="line">                nextCh = p.nextCh</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// There is already a notification waiting to be dispatched</span></span><br><span class="line">                p.pendingNotifications.WriteOne(notificationToAdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listener-run"><a href="#listener-run" class="headerlink" title="listener.run"></a>listener.run</h4><p>listener.run部分根据不同的更新类型调用不同的处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *processorListener)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> next := <span class="keyword">range</span> p.nextCh &#123;</span><br><span class="line">        <span class="keyword">switch</span> notification := next.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> updateNotification:</span><br><span class="line">            p.handler.OnUpdate(notification.oldObj, notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> addNotification:</span><br><span class="line">            p.handler.OnAdd(notification.newObj)</span><br><span class="line">        <span class="keyword">case</span> deleteNotification:</span><br><span class="line">            p.handler.OnDelete(notification.oldObj)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            utilruntime.HandleError(fmt.Errorf(<span class="string">"unrecognized notification: %#v"</span>, next))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中具体的实现函数handler是在NewDeploymentController（其他不同类型的controller类似）中赋值的，而该handler是一个接口，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceEventHandler can handle notifications for events that happen to a</span></span><br><span class="line"><span class="comment">// resource. The events are informational only, so you can't return an</span></span><br><span class="line"><span class="comment">// error.</span></span><br><span class="line"><span class="comment">//  * OnAdd is called when an object is added.</span></span><br><span class="line"><span class="comment">//  * OnUpdate is called when an object is modified. Note that oldObj is the</span></span><br><span class="line"><span class="comment">//      last known state of the object-- it is possible that several changes</span></span><br><span class="line"><span class="comment">//      were combined together, so you can't use this to see every single</span></span><br><span class="line"><span class="comment">//      change. OnUpdate is also called when a re-list happens, and it will</span></span><br><span class="line"><span class="comment">//      get called even if nothing changed. This is useful for periodically</span></span><br><span class="line"><span class="comment">//      evaluating or syncing something.</span></span><br><span class="line"><span class="comment">//  * OnDelete will get the final state of the item if it is known, otherwise</span></span><br><span class="line"><span class="comment">//      it will get an object of type DeletedFinalStateUnknown. This can</span></span><br><span class="line"><span class="comment">//      happen if the watch is closed and misses the delete event and we don't</span></span><br><span class="line"><span class="comment">//      notice the deletion until the subsequent re-list.</span></span><br><span class="line"><span class="keyword">type</span> ResourceEventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    OnAdd(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnUpdate(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    OnDelete(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResourceEventHandler"><a href="#ResourceEventHandler" class="headerlink" title="ResourceEventHandler"></a>ResourceEventHandler</h3><p>以下以DeploymentController的处理逻辑为例。</p><p>在<code>NewDeploymentController</code>部分会注册deployment的事件函数，以下注册了三种类型的事件函数，其中包括：dInformer、rsInformer和podInformer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeploymentController creates a new DeploymentController.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer extensionsinformers.DeploymentInformer, rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addDeployment,</span><br><span class="line">        UpdateFunc: dc.updateDeployment,</span><br><span class="line">        <span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">        DeleteFunc: dc.deleteDeployment,</span><br><span class="line">    &#125;)</span><br><span class="line">    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    dc.addReplicaSet,</span><br><span class="line">        UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">        DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">    &#125;)</span><br><span class="line">    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        DeleteFunc: dc.deletePod,</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addDeployment"><a href="#addDeployment" class="headerlink" title="addDeployment"></a>addDeployment</h4><p>以下以<code>addDeployment</code>为例，addDeployment主要是将对象加入到enqueueDeployment的队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">addDeployment</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    d := obj.(*extensions.Deployment)</span><br><span class="line">    glog.V(<span class="number">4</span>).Infof(<span class="string">"Adding deployment %s"</span>, d.Name)</span><br><span class="line">    dc.enqueueDeployment(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueueDeployment的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    enqueueDeployment <span class="function"><span class="keyword">func</span><span class="params">(deployment *extensions.Deployment)</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将dc.enqueue赋值给dc.enqueueDeployment</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.enqueueDeployment = dc.enqueue</span><br></pre></td></tr></table></figure><p>dc.enqueue调用了dc.queue.Add(key)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">enqueue</span><span class="params">(deployment *extensions.Deployment)</span></span> &#123;</span><br><span class="line">    key, err := controller.KeyFunc(deployment)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %#v: %v"</span>, deployment, err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc.queue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dc.queue主要记录了需要被同步的deployment的对象，供syncDeployment使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dc := &amp;DeploymentController&#123;</span><br><span class="line">    ...</span><br><span class="line">    queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewNamedRateLimitingQueue</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedRateLimitingQueue</span><span class="params">(rateLimiter RateLimiter, name <span class="keyword">string</span>)</span> <span class="title">RateLimitingInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;rateLimitingType&#123;</span><br><span class="line">        DelayingInterface: NewNamedDelayingQueue(name),</span><br><span class="line">        rateLimiter:       rateLimiter,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上分析，可以看出processor记录了不同类似的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析的部分主要是k8s的<code>informer</code>机制，即<code>List-Watch</code>机制。</p><h3 id="Reflector-2"><a href="#Reflector-2" class="headerlink" title="Reflector"></a>Reflector</h3><p><code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>只会放置指定的<code>expectedType</code>类型的资源到<code>store</code>中，除非<code>expectedType</code>为nil。如果<code>resyncPeriod</code>不为零，那么<code>Reflector</code>为以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</p><h3 id="ListAndWatch-1"><a href="#ListAndWatch-1" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p><code>ListAndWatch</code>第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</p><h3 id="DeltaFIFO-2"><a href="#DeltaFIFO-2" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p><code>DeltaFIFO</code>是一个生产者与消费者的队列，其中Reflector是生产者，消费者调用Pop()的方法。</p><p>DeltaFIFO主要用在以下场景：</p><ul><li>希望对象变更最多处理一次</li><li>处理对象时，希望查看自上次处理对象以来发生的所有事情</li><li>要处理对象的删除</li><li>希望定期重新处理对象</li></ul><h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p><code>Store</code>是一个通用的存储接口，Reflector通过watch server的方式更新数据到store中，store给Reflector提供本地的缓存，让Reflector可以像消息队列一样的工作。</p><p><code>Store</code>实现的是一种可以准确的写入对象和获取对象的机制。</p><h3 id="processor-1"><a href="#processor-1" class="headerlink" title="processor"></a>processor</h3><p><code>processor</code>的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。在sharedIndexInformer.Run部分会调用processor.run。</p><p>流程：</p><ol><li>listenser的add函数负责将notify装进pendingNotifications。</li><li>pop函数取出pendingNotifications的第一个nofify,输出到nextCh channel。</li><li>run函数则负责取出notify，然后根据notify的类型(增加、删除、更新)触发相应的处理函数，这些函数是在不同的<code>NewXxxcontroller</code>实现中注册的。</li></ol><p><code>processor</code>记录了不同类似的事件函数，其中事件函数在<code>NewXxxController</code>构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似<code>syncDeployment</code>的同步函数来维持期望状态的同步逻辑。</p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li>在controller-manager的Run函数部分调用了InformerFactory.Start的方法，Start方法初始化各种类型的informer，并且每个类型起了个informer.Run的goroutine。</li><li>informer.Run的部分先生成一个DeltaFIFO的队列来存储对象变化的数据。然后调用processor.Run和controller.Run函数。</li><li>controller.Run函数会生成一个Reflector，<code>Reflector</code>的主要作用是watch指定的k8s资源，并将变化同步到本地是<code>store</code>中。<code>Reflector</code>以<code>resyncPeriod</code>为周期定期执行list的操作，这样就可以使用<code>Reflector</code>来定期处理所有的对象，也可以逐步处理变化的对象。</li><li>Reflector接着执行ListAndWatch函数，ListAndWatch第一次会列出所有的对象，并获取资源对象的版本号，然后watch资源对象的版本号来查看是否有被变更。首先会将资源版本号设置为0，<code>list()</code>可能会导致本地的缓存相对于etcd里面的内容存在延迟，<code>Reflector</code>会通过<code>watch</code>的方法将延迟的部分补充上，使得本地的缓存数据与etcd的数据保持一致。</li><li>controller.Run函数还会调用processLoop函数，processLoop通过调用HandleDeltas，再调用distribute，processorListener.add最终将不同更新类型的对象加入<code>processorListener</code>的channel中，供processorListener.Run使用。</li><li>processor的主要功能就是记录了所有的回调函数实例(即 ResourceEventHandler 实例)，并负责触发这些函数。processor记录了不同类型的事件函数，其中事件函数在NewXxxController构造函数部分注册，具体事件函数的处理，一般是将需要处理的对象加入对应的controller的任务队列中，然后由类似syncDeployment的同步函数来维持期望状态的同步逻辑。</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="Informer-二级缓存中的同步问题"><a href="#Informer-二级缓存中的同步问题" class="headerlink" title="Informer 二级缓存中的同步问题"></a>Informer 二级缓存中的同步问题</h2><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存 DeltaIFIFO 和 LocalStore 之间会存在 resync 机制，k8s 中 kube-controller-manager 的 StatefulSetController 中使用了两级缓存的 resync 机制（如下图所示），我们在生产环境中发现 sts 创建后过了很久 pod 才会创建，主要是由于 StatefulSetController 的两级缓存之间 30s 会同步一次，由于 StatefulSetController watch 到变化后就会把对应的 sts 放入 DeltaIFIFO 中，且每隔 30s 会把 LocalStore 中全部的 sts 重新入一遍 DeltaIFIFO，入队时会做一些处理，过滤掉一些不需要重复入队列的 sts，若间隔的 30s 内没有处理完队列中所有的 sts，则待处理队列中始终存在未处理完的 sts，并且在同步过程中产生的 sts 会加的队列的尾部，新加入队尾的 sts 只能等到前面的 sts 处理完成（也就是 resync 完成）才会被处理，所以导致的现象就是 sts 创建后过了很久 pod 才会创建。</p><p>优化的方法就是去掉二级缓存的同步策略（将 setInformer.Informer().AddEventHandlerWithResyncPeriod() 改为 informer.AddEventHandler()）或者调大同步周期，但是在研究 kube-controller-manager 其他 controller 时发现并不是所有的 controller 都有同步策略，社区也有相关的 issue 反馈了这一问题，Remove resync period for sset controller，社区也会在以后的版本中去掉两级缓存之间的 resync 策略。</p><p>k8s.io/kubernetes/pkg/controller/statefulset/stateful_set.go</p><p><img alt="Kubernetes 中 informer 的使用" data-src="https://static001.geekbang.org/wechat/images/a1/a1a5745f0c0309c9d05c484905887fb8.jpeg">kube-controller-manager sts controller</p><h2 id="使用-Informer-如何监听所有资源对象？"><a href="#使用-Informer-如何监听所有资源对象？" class="headerlink" title="使用 Informer 如何监听所有资源对象？"></a>使用 Informer 如何监听所有资源对象？</h2><p>一个 Informer 实例只能监听一种 resource，每个 resource 需要创建对应的 Informer 实例。</p><h2 id="为什么不是使用-workqueue？"><a href="#为什么不是使用-workqueue？" class="headerlink" title="为什么不是使用 workqueue？"></a>为什么不是使用 workqueue？</h2><p>建议使用 RateLimitingQueue，它相比普通的 workqueue 多了以下的功能:</p><ul><li><strong>限流：</strong>可以限制一个 item 被 reenqueued 的次数。</li><li><strong>防止 hot loop：</strong>它保证了一个 item 被 reenqueued 后，不会马上被处理。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/kubernetes/client-go/tree/master/tools/cache" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/tree/master/tools/cache</a></li><li><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></li><li><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Informer模块是Kubernetes中的基础组件，负责各组件与Apiserver的资源与事件同步。List/Watch机制是Kubernetes中实现集群控制模块最核心的设计之一，它采用统一的异步消息处理机制，保证了消息的实时性、可靠性、顺序性和性能等，为声明式风格的API奠定了良好的基础。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-20_client-go-controller-interaction.jpeg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="informer" scheme="http://houmin.cc/tags/informer/"/>
    
      <category term="watch" scheme="http://houmin.cc/tags/watch/"/>
    
      <category term="消息机制" scheme="http://houmin.cc/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    
      <category term="异步" scheme="http://houmin.cc/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>得意忘形</title>
    <link href="http://houmin.cc/posts/c2f57f16/"/>
    <id>http://houmin.cc/posts/c2f57f16/</id>
    <published>2020-07-18T09:19:12.000Z</published>
    <updated>2020-07-26T08:22:57.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Podcast 在我最近的生活中占据了很大的部分，每天走在上下班的路上，带着耳机，听播客中主播与嘉宾的聊天，会觉得是难得自在和舒适的时间。有时候聊到有意思的地方，自己也不禁乐了起来；有时候听到一些新的观点或者事情，自己也好像恍然大悟；或者有时候自己一直以来的感受被主播们说了出来，感同身受豁然开朗。</p><p>「得意忘形」是最近听的比较多的一个播客，他的风格偏务虚，更新也并不太频繁，拖更的现象也常有。但是翻看「得意忘形」两年前录的播客，现在听来很多还是觉得会有启发性。毕竟，他关注的是自我与世界这个主题：我到底是一个什么样的人，我作为人整个系统是如何运作的，我与外界是如何产生交互，到底是什么影响了我对这个世界的看法。</p><blockquote><p>「得意忘形」是一个主张追求个体自由与探寻真理的媒体计划。我们见证了第一次工业革命以来科技对人类社会的极大推动与助益，但也意识到资本主义与市场经济不可避免地催生了消费文化、剥夺了个人价值、并窃取了大众时间。带着对生命的有限性与无目的性的敬畏，我们试图为读者与听众提供更全面的<strong>觉察自我与认知世界</strong>的工具，以不断重建当下的方式穿越时间、抵达生活的本质。</p></blockquote><p>这里是「朝花夕拾」第二十期，选题来自于最近听「得意忘形」两年前的一期：「快乐」到底是什么东西？选择「得意忘形」作为这期的题目，是因为我非常喜欢得意忘形这个词本来描述的那种 <code>in the zone</code>的状态。这一次，我们再聊聊关于「快乐」的问题。</p><blockquote><p>嗜酒能啸，善弹琴。当其得意，忽忘形骸。                                —— 《晋书·阮籍传》</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="1500" height="80" src="//music.163.com/outchain/player?type=3&id=904186633&auto=0&height=66"></iframe><a id="more"></a><h2 id="什么时候会让你开心"><a href="#什么时候会让你开心" class="headerlink" title="什么时候会让你开心"></a>什么时候会让你开心</h2><p>想一想那些让我感觉到开心的时刻</p><ul><li>在羽毛球场双打时候的那种快节奏的刺激感让我觉得开心，打完球后大汗淋漓的状态</li><li>大四时特别喜欢跑步，最开始的时候是比较痛苦的，经过一段时间的适应后，喜欢上了那种<code>Runner&#39;s High</code>的感觉</li><li>自己一个人在路上听播客听到好玩的地方的时候</li><li>自己做了一道色香味俱全的菜的时候，看着开心，吃着也开心</li><li>北京的秋天那种蓝天白云，清风徐来的状态</li><li>去云南玩的时候和同伴们插科打诨，完全自由的那种状态</li><li>自己实验达到预期的效果的时候</li><li>和喜欢的女孩子聊天时候那种自在惬意的感觉</li><li>朋友圈收到很多赞的时候</li></ul><p>总结这些时刻，可以把它大体分为以下几类：</p><ul><li>运动及其带来的成就</li><li>做成一件事情的成就感</li><li>人与人之间的交互和融洽感</li><li>良好的环境，包括天气、美景等</li></ul><h2 id="为什么这些会让我感到快乐？多巴胺？"><a href="#为什么这些会让我感到快乐？多巴胺？" class="headerlink" title="为什么这些会让我感到快乐？多巴胺？"></a>为什么这些会让我感到快乐？多巴胺？</h2><p>多巴胺到底是什么？很多媒体把多巴胺描述成人类感到愉悦的来源，是人类通过药物、运动、食物、性或者地位来追求高潮体验的本质。实际上现在的医学研究表明，多巴胺的作用有很多，其中的一个就是并不是给人带来快乐，而是向大脑承诺奖赏、承诺快乐并控制人的行为。这里需要区分的是，你渴望得到某个东西的快乐，和你实际做那个东西的快乐，这两件事情是不一样的。</p><p>一个典型的例子，你喜欢跑步。跑步的时候确实会感到开心，可能由于分泌了内啡肽等东西，让人体感觉到舒适。但是跑步让你感到快乐的，可能更多的是来源于，「你觉得你是一个跑步的人」以及随之发朋友圈的行为。当你每次跑完步的时候，你会进一步更新你的认知，觉得自己做了一件有意义的事情，然后会觉得开心。</p><p>多巴胺会让人上瘾，你可以因为多巴胺而沉迷于刷手机，也可能因为多巴胺坚持跑步。这是一个固有的生理机制，关键在于你如何利用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Podcast 在我最近的生活中占据了很大的部分，每天走在上下班的路上，带着耳机，听播客中主播与嘉宾的聊天，会觉得是难得自在和舒适的时间。有时候聊到有意思的地方，自己也不禁乐了起来；有时候听到一些新的观点或者事情，自己也好像恍然大悟；或者有时候自己一直以来的感受被主播们说了出来，感同身受豁然开朗。&lt;/p&gt;
&lt;p&gt;「得意忘形」是最近听的比较多的一个播客，他的风格偏务虚，更新也并不太频繁，拖更的现象也常有。但是翻看「得意忘形」两年前录的播客，现在听来很多还是觉得会有启发性。毕竟，他关注的是自我与世界这个主题：我到底是一个什么样的人，我作为人整个系统是如何运作的，我与外界是如何产生交互，到底是什么影响了我对这个世界的看法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「得意忘形」是一个主张追求个体自由与探寻真理的媒体计划。我们见证了第一次工业革命以来科技对人类社会的极大推动与助益，但也意识到资本主义与市场经济不可避免地催生了消费文化、剥夺了个人价值、并窃取了大众时间。带着对生命的有限性与无目的性的敬畏，我们试图为读者与听众提供更全面的&lt;strong&gt;觉察自我与认知世界&lt;/strong&gt;的工具，以不断重建当下的方式穿越时间、抵达生活的本质。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里是「朝花夕拾」第二十期，选题来自于最近听「得意忘形」两年前的一期：「快乐」到底是什么东西？选择「得意忘形」作为这期的题目，是因为我非常喜欢得意忘形这个词本来描述的那种 &lt;code&gt;in the zone&lt;/code&gt;的状态。这一次，我们再聊聊关于「快乐」的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嗜酒能啸，善弹琴。当其得意，忽忘形骸。                                —— 《晋书·阮籍传》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;1500&quot; height=&quot;80&quot; src=&quot;//music.163.com/outchain/player?type=3&amp;id=904186633&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-23_cat.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="快乐" scheme="http://houmin.cc/tags/%E5%BF%AB%E4%B9%90/"/>
    
      <category term="个人管理系统" scheme="http://houmin.cc/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="podcast" scheme="http://houmin.cc/tags/podcast/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Scheduling Framework</title>
    <link href="http://houmin.cc/posts/83a17de0/"/>
    <id>http://houmin.cc/posts/83a17de0/</id>
    <published>2020-07-15T06:48:27.000Z</published>
    <updated>2020-08-04T02:39:56.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes Scheduling Framework 是在Kubernetes 1.15版本后新出现的一种调度框架。Scheduling Framework 在原有的调度流程中, 定义了丰富扩展点接口，开发者可以通过实现扩展点所定义的接口来实现插件，将插件注册到扩展点。Scheduling Framework 在执行调度流程时，运行到相应的扩展点时，会调用用户注册的插件，影响调度决策的结果。通过这种方式来将用户的调度逻辑集成到 Scheduling Framework 中。</p><a id="more"></a><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>随着越来越多的Feature被加入到Kubernetes调度器，整个调度器的代码量越来越大，逻辑越来越复杂，使得对其的维护和调试越来越困难。与此同时，对于那些自己定制调度器的研发人员来说，跟上社区的进展也越来越难。在Kubernetes 1.15版本前的调度器支持了Scheduler Extender的方式来基于HTTP的Webhook来对调度器支持的功能扩展。但是，他们明显存在以下几个问题：</p><ul><li>调度器功能扩展点的数目有限。Extender只有Filter、Prioritize、Preempt和Bind这几个扩展点，而没有起其他的扩展点，比如不能在运行Predicate函数前调用</li><li>每一次调用调度器都需要Marshaling和Unmarshaling JSON数据，相比于直接调用原生函数而言Webhook的HTTP请求方式更慢</li><li>难以通知Extender调度器已经放弃调度一个Pod</li><li>因为Extender以独立进程形式运行，他们不能使用Scheduler Cache</li></ul><p>以上的问题影响了Scheduler的性能与扩展新的特性，基于此提出的Framework框架会将现有的功能转换为Plugin的形式，比如Predicate函数和Prioritize函数。这些Plugin将会被编译进调度器的二进制文件中。此外，对于那些自己定制调度器的研发人员可以基于未经修改的调度器代码和自己的插件代码编译自己的调度器。</p><p>目标：</p><ul><li>让调度器更加可扩展</li><li>通过移动调度器的代码到Plugin从而让其核心代码更加简单</li><li>在Framework中提出扩展点</li><li>提出一个机制来接收Plugin的结果，并且根结收到的结果来继续或者终止调度</li><li>提出一个机制来处理问题并且和Plugin通信</li></ul><h2 id="Proposals"><a href="#Proposals" class="headerlink" title="Proposals"></a>Proposals</h2><p>Scheduling Framework定义了新的扩展点和Go API，这种方式称作Plugin。通过配置Scheduler的ComponentConfig可以开启、关闭或者重排序这些插件。such</p><h2 id="Scheduling-Cycle-amp-Binding-Cycle"><a href="#Scheduling-Cycle-amp-Binding-Cycle" class="headerlink" title="Scheduling Cycle &amp; Binding Cycle"></a>Scheduling Cycle &amp; Binding Cycle</h2><p>每次尝试调度一个Pod都会经历两个阶段：</p><ul><li>Scheduling Cycle：为Pod选择一个Node进行调度</li><li>Binding Cycle：将Scheduling Cycle阶段的决定应用到集群</li></ul><p>这两个阶段一起被称作是 <code>Scheduling Context</code>，也就是调度上下文。</p><p>不同的Scheduling Cycle间串行运行，同一个时间只有一个 scheduling cycle，是线程安全的。binding cycle 是异步执行的，同一个时间中可能会有多个 binding cycle 在运行，是线程不安全的。</p><p>如果一个Pod被认为是Unschedulable，或者是发生了内存错误，那么一个Scheduling Cycle或者Binding Cycle会被终止。然后这个Pod可能被返回到调度队列中。如果一个Binding Cycle终止了，那么会触发 <code>Un-reserve</code>插件。</p><h2 id="Extension-points"><a href="#Extension-points" class="headerlink" title="Extension points"></a>Extension points</h2><p>下图定义了Scheduling Framework中暴露的扩展点，其中Filter等同于原来的Predicate，Scoring等同于之前的Prioritize。对于一个插件，它可能在一个或者多个扩展点注册，从而满足业务的不同逻辑。</p><p><img alt="Scheduling Framework" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-01-25_scheduling-framework-extensions.png"></p><h3 id="Queue-Sort"><a href="#Queue-Sort" class="headerlink" title="Queue Sort"></a>Queue Sort</h3><p>这里的插件用来对调度队列中的Pod排序，同一时间只有一个Queue Sort可以被启用。</p><h3 id="Pre-filter"><a href="#Pre-filter" class="headerlink" title="Pre-filter"></a>Pre-filter</h3><p>这里的插件用来预处理Pod信息，或者检查集群或Pod需满足的特定条件。</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter用于过滤那些不能运行对应Pod的Node，调度器可能会同时评估这些Node，在一个Scheduling Cycle中Filter插件可能被运行多次。</p><h3 id="Pre-Score"><a href="#Pre-Score" class="headerlink" title="Pre-Score"></a>Pre-Score</h3><p>在V1alpha2中，Pre-Score已经可用，之前被称作Post-Filter。</p><p>这个插件会接收来自Filter阶段的Node列表，可以用这些数据来更新内部状态或者产生日志或Metrics。</p><h3 id="Scoring"><a href="#Scoring" class="headerlink" title="Scoring"></a>Scoring</h3><p>Score插件会有两个阶段：</p><ul><li>Scoring：为Filter阶段的Node列表中的Node排序，调度器对于每个Node调用每个Score插件中的 <code>Score</code>方法</li><li>Normalize Scoring：用于修改各个Score插件的分数，从而计算出最终的Node得分列表</li></ul><p>Score插件最终输出的数值必须在  <strong>[MinNodeScore, MaxNodeScore]</strong> 区间，如果不是，Scheduling Cycle将会被终止。</p><h3 id="Reserve"><a href="#Reserve" class="headerlink" title="Reserve"></a>Reserve</h3><p>Reserve插件是一个信息型的插件。当一个Node上的资源被保留给某个Pod的时候，那些需要维护runtime状态的插件，需要利用Reserve扩展点来接收来自Scheduler的通知。这发生在调度器实际上绑定Pod到Node的时候，用来避免在调度器等待Bind成功时候发生Race Condition。</p><p>Reserve是Scheduling Cycle的最后一步，一点Pod进入Reserved状态，它之后要么在调度失败的时候触发Un-reserve插件，要么调度成功的时候触发Post-bind插件。</p><blockquote><p>Note：这个概念以前叫做 Assume</p></blockquote><h3 id="Permit"><a href="#Permit" class="headerlink" title="Permit"></a>Permit</h3><p>Permit插件用来阻止或者推迟对一个Pod的绑定，一个Permit可以做下面三件操作</p><ul><li>Allow；执行approve操作后，一个Pod将被送去Binding</li><li>Reject：执行deny操作后，Pod被返回调度队列，同时触发Un-reserve插件</li><li>Wait (with a timeout)：执行wait操作后，一个Pod保持在Permit阶段知道一个Plugin对它approve；如果timeout了，wait将会变为den y，之后Pod被返回调度队列，触发Un-reserve插件</li></ul><h4 id="WaitPod"><a href="#WaitPod" class="headerlink" title="WaitPod"></a>WaitPod</h4><p>在framework interface中定义了Permit阶段中处于等待的WaitingPod。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/interface.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitingPod represents a pod currently waiting in the permit phase.</span></span><br><span class="line"><span class="keyword">type</span> WaitingPod <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// GetPod returns a reference to the waiting pod.</span></span><br><span class="line">GetPod() *v1.Pod</span><br><span class="line"><span class="comment">// GetPendingPlugins returns a list of pending permit plugin's name.</span></span><br><span class="line">GetPendingPlugins() []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// Allow declares the waiting pod is allowed to be scheduled by plugin pluginName.</span></span><br><span class="line"><span class="comment">// If this is the last remaining plugin to allow, then a success signal is delivered</span></span><br><span class="line"><span class="comment">// to unblock the pod.</span></span><br><span class="line">Allow(pluginName <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">// Reject declares the waiting pod unschedulable.</span></span><br><span class="line">Reject(msg <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitingPod则是一个具体的pod的等待实例，其内部通过pendingPlugins保存插件定义的timer等待时间，对外通过<code>chan *status</code>来接受当前pod的状态，并通过读写锁来进行串行化。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitingPod <span class="keyword">struct</span> &#123;</span><br><span class="line">    pod            *v1.Pod</span><br><span class="line">    pendingPlugins <span class="keyword">map</span>[<span class="keyword">string</span>]*time.Timer</span><br><span class="line">    s              <span class="keyword">chan</span> *Status</span><br><span class="line">    mu             sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitingPodsMap其内部通过pod的uid保存一个map映射，同时通过读写锁来进行数据保护</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitingPodsMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    pods <span class="keyword">map</span>[types.UID]WaitingPod</span><br><span class="line">    mu   sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据每个plugin的wait等待时间构建N个timer, 如果任一的timer到期，则就拒绝</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/waiting_pods_map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWaitingPod</span><span class="params">(pod *v1.Pod, pluginsMaxWaitTime <span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration)</span> *<span class="title">waitingPod</span></span> &#123;</span><br><span class="line">    wp := &amp;waitingPod&#123;</span><br><span class="line">        pod: pod,</span><br><span class="line">        s:   <span class="built_in">make</span>(<span class="keyword">chan</span> *Status, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wp.pendingPlugins = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*time.Timer, <span class="built_in">len</span>(pluginsMaxWaitTime))</span><br><span class="line">    <span class="comment">// The time.AfterFunc calls wp.Reject which iterates through pendingPlugins map. Acquire the</span></span><br><span class="line">    <span class="comment">// lock here so that time.AfterFunc can only execute after newWaitingPod finishes.</span></span><br><span class="line">    wp.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> wp.mu.Unlock()</span><br><span class="line">    <span class="comment">// 根据插件的等待时间来构建timer，如果有任一timer到期，还未曾有任何plugin Allow则会进行Reject</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> pluginsMaxWaitTime &#123;</span><br><span class="line">        plugin, waitTime := k, v</span><br><span class="line">        wp.pendingPlugins[plugin] = time.AfterFunc(waitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            msg := fmt.Sprintf(<span class="string">"rejected due to timeout after waiting %v at plugin %v"</span>,</span><br><span class="line">                waitTime, plugin)</span><br><span class="line">            wp.Reject(msg)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>允许操作必须等待所有的plugin都Allow后，才能发送允许事件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *waitingPod)</span> <span class="title">Allow</span><span class="params">(pluginName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    w.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> timer, exist := w.pendingPlugins[pluginName]; exist &#123;</span><br><span class="line">        <span class="comment">// 停止当前plugin的定时器</span></span><br><span class="line">        timer.Stop()</span><br><span class="line">        <span class="built_in">delete</span>(w.pendingPlugins, pluginName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only signal success status after all plugins have allowed</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(w.pendingPlugins) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有当所有的plugin都允许，才会发生成功允许事件</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> w.s &lt;- NewStatus(Success, <span class="string">""</span>): <span class="comment">// 发送事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reject"><a href="#Reject" class="headerlink" title="Reject"></a>Reject</h4><p>任一一个plugin的定时器到期，或者plugin主动发起reject操作，则都会暂停所有的定时器，并进行消息广播</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *waitingPod)</span> <span class="title">Reject</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    w.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> w.mu.RUnlock()</span><br><span class="line">    <span class="comment">// 停止所有的timer</span></span><br><span class="line">    <span class="keyword">for</span> _, timer := <span class="keyword">range</span> w.pendingPlugins &#123;</span><br><span class="line">        timer.Stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过管道发送拒绝事件</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> w.s &lt;- NewStatus(Unschedulable, msg):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Premit-阶段-Wait-实现"><a href="#Premit-阶段-Wait-实现" class="headerlink" title="Premit 阶段 Wait 实现"></a>Premit 阶段 Wait 实现</h4><p>首先会遍历所有的插件，然后如果发现状态设置为Wait，则会根据插件的等待时间进行wait操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">RunPermitPlugins</span><span class="params">(ctx context.Context, state *CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(status *Status)</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">metrics.FrameworkExtensionPointDuration.WithLabelValues(permit, status.Code().String()).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line">&#125;()</span><br><span class="line">pluginsWaitTime := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Duration)</span><br><span class="line">statusCode := Success</span><br><span class="line"><span class="keyword">for</span> _, pl := <span class="keyword">range</span> f.permitPlugins &#123;</span><br><span class="line">status, timeout := f.runPermitPlugin(ctx, pl, state, pod, nodeName)</span><br><span class="line"><span class="keyword">if</span> !status.IsSuccess() &#123;</span><br><span class="line"><span class="keyword">if</span> status.IsUnschedulable() &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"rejected pod %q by permit plugin %q: %v"</span>, pod.Name, pl.Name(), status.Message())</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(status.Code(), msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> status.Code() == Wait &#123;</span><br><span class="line"><span class="comment">// Not allowed to be greater than maxTimeout.</span></span><br><span class="line"><span class="keyword">if</span> timeout &gt; maxTimeout &#123;</span><br><span class="line">timeout = maxTimeout</span><br><span class="line">&#125;</span><br><span class="line">pluginsWaitTime[pl.Name()] = timeout</span><br><span class="line">statusCode = Wait</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"error while running %q permit plugin for pod %q: %v"</span>, pl.Name(), pod.Name, status.Message())</span><br><span class="line">klog.Error(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(Error, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> statusCode == Wait &#123;</span><br><span class="line">waitingPod := newWaitingPod(pod, pluginsWaitTime)</span><br><span class="line">f.waitingPods.add(waitingPod)</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"one or more plugins asked to wait and no plugin rejected pod %q"</span>, pod.Name)</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(Wait, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitOnPermit will block, if the pod is a waiting pod, until the waiting pod is rejected or allowed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">WaitOnPermit</span><span class="params">(ctx context.Context, pod *v1.Pod)</span> <span class="params">(status *Status)</span></span> &#123;</span><br><span class="line">waitingPod := f.waitingPods.get(pod.UID)</span><br><span class="line"><span class="keyword">if</span> waitingPod == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.waitingPods.remove(pod.UID)</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"pod %q waiting on permit"</span>, pod.Name)</span><br><span class="line"></span><br><span class="line">startTime := time.Now()</span><br><span class="line">s := &lt;-waitingPod.s</span><br><span class="line">metrics.PermitWaitDuration.WithLabelValues(s.Code().String()).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !s.IsSuccess() &#123;</span><br><span class="line"><span class="keyword">if</span> s.IsUnschedulable() &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"pod %q rejected while waiting on permit: %v"</span>, pod.Name, s.Message())</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(s.Code(), msg)</span><br><span class="line">&#125;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"error received while waiting on permit for pod %q: %v"</span>, pod.Name, s.Message())</span><br><span class="line">klog.Error(msg)</span><br><span class="line"><span class="keyword">return</span> NewStatus(Error, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pre-Bind"><a href="#Pre-Bind" class="headerlink" title="Pre-Bind"></a>Pre-Bind</h3><p>执行Bind前的必要工作，比如在目标Node上设置一个网络磁盘并且mount上去。</p><h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><p>当所有的Pre-Bind插件执行完毕后，才会执行Bind插件，每一个Bind插件都按照配置的顺序被调用。一个Bind插件可以选择是否处理对应的Pod，一旦一个Bind插件选择处理Pod，剩余的其他Bind插件都被跳过。</p><h3 id="Post-Bind"><a href="#Post-Bind" class="headerlink" title="Post-Bind"></a>Post-Bind</h3><p>这是一个信息型的插件，当Bind成功后，可以用来清理一些关联的资源。</p><h3 id="Un-reserve"><a href="#Un-reserve" class="headerlink" title="Un-reserve"></a>Un-reserve</h3><p>这是一个信息型的插件，当一个Pod被reserved了，然后在之后的阶段被reject，就会执行Un-reserve插件，主要用来清理一些reserved Pod的状态。</p><h2 id="Plugin-API"><a href="#Plugin-API" class="headerlink" title="Plugin API"></a>Plugin API</h2><p>Plugin首先需要注册和配置，然后使用扩展点的接口，一般形式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueSortPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   Less(*PodInfo, *PodInfo) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PreFilterPlugin <span class="keyword">interface</span> &#123;</span><br><span class="line">   Plugin</span><br><span class="line">   PreFilter(CycleState, *v1.Pod) *Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="CycleState"><a href="#CycleState" class="headerlink" title="CycleState"></a>CycleState</h3><p>很多插件函数会调用一个<code>CycleState</code>参数，它代表了当前的调度上下文，主要是负责调度流程中数据的保存和克隆，其对外暴露了读写锁接口，各扩展点插件可以根据需求独立进行加锁选择。</p><blockquote><p>The <code>CycleState</code> also provides an API similar to <a href="https://godoc.org/context#WithValue" target="_blank" rel="external nofollow noopener noreferrer"><code>context.WithValue</code></a> that can be used to pass data between plugins at different extension points. Multiple plugins can share the state or communicate via this mechanism. The state is preserved only during a single scheduling context. It is worth noting that plugins are assumed to be <strong>trusted</strong>. The scheduler does not prevent one plugin from accessing or modifying another plugin’s state.</p><p>* <em>The only exception is for <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#queue-sort" target="_blank" rel="external nofollow noopener noreferrer">queue sort</a> plugins.</em></p><p><strong>WARNING</strong>: The data available through a <code>CycleState</code> is not valid after a scheduling context ends, and plugins should not hold references to that data longer than necessary.</p></blockquote><p>CycleState主要保存StateData数据，只需要实现一个clone接口即可，CycleState里面的数据，可以被当前framework所有的插件进行数据增加和修改，里面会通过读写锁来保证线程安全，但并不会针对插件进行限制，即信任所有插件，可以任意进行增删。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CycleState <span class="keyword">struct</span> &#123;</span><br><span class="line">    mx      sync.RWMutex</span><br><span class="line">    storage <span class="keyword">map</span>[StateKey]StateData</span><br><span class="line">    <span class="comment">// if recordPluginMetrics is true, PluginExecutionDuration will be recorded for this cycle.</span></span><br><span class="line">    recordPluginMetrics <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateData is a generic type for arbitrary data stored in CycleState.</span></span><br><span class="line"><span class="keyword">type</span> StateData <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Clone is an interface to make a copy of StateData. For performance reasons,</span></span><br><span class="line">    <span class="comment">// clone should make shallow copies for members (e.g., slices or maps) that are not</span></span><br><span class="line">    <span class="comment">// impacted by PreFilter's optional AddPod/RemovePod methods.</span></span><br><span class="line">    Clone() StateData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对外接口的实现，需要对应的插件主动选择进行加读锁或者加写锁，然后进行相关数据的读取和修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Read</span><span class="params">(key StateKey)</span> <span class="params">(StateData, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v, ok := c.storage[key]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(NotFound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write stores the given "val" in CycleState with the given "key".</span></span><br><span class="line"><span class="comment">// This function is not thread safe. In multi-threaded code, lock should be</span></span><br><span class="line"><span class="comment">// acquired first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Write</span><span class="params">(key StateKey, val StateData)</span></span> &#123;</span><br><span class="line">    c.storage[key] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete deletes data with the given key from CycleState.</span></span><br><span class="line"><span class="comment">// This function is not thread safe. In multi-threaded code, lock should be</span></span><br><span class="line"><span class="comment">// acquired first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Delete</span><span class="params">(key StateKey)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(c.storage, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock acquires CycleState lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock releases CycleState lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RLock acquires CycleState read lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.RLock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RUnlock releases CycleState read lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CycleState)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mx.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FrameworkHandle"><a href="#FrameworkHandle" class="headerlink" title="FrameworkHandle"></a>FrameworkHandle</h3><p>FrameworkHandle提供了对于ApiServer和SchedulerCache的访问。<code>FrameworkHandle</code>作为一个Interface，具体是通过framework结构体实现的。</p><blockquote><p>While the <code>CycleState</code> provides APIs relevant to a single scheduling context, the <code>FrameworkHandle</code> provides APIs relevant to the lifetime of a plugin. This is how plugins can get a client (<code>kubernetes.Interface</code>) and <code>SharedInformerFactory</code>, or read data from the scheduler’s cache of cluster state. The handle will also provide APIs to list and approve or reject <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#permit" target="_blank" rel="external nofollow noopener noreferrer">waiting pods</a>.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FrameworkHandle <span class="keyword">interface</span> &#123;</span><br><span class="line">SnapshotSharedLister() schedulerlisters.SharedLister</span><br><span class="line"></span><br><span class="line"><span class="comment">// IterateOverWaitingPods acquires a read lock and iterates over the WaitingPods map.</span></span><br><span class="line">IterateOverWaitingPods(callback <span class="function"><span class="keyword">func</span><span class="params">(WaitingPod)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetWaitingPod returns a waiting pod given its UID.</span></span><br><span class="line">GetWaitingPod(uid types.UID) WaitingPod</span><br><span class="line"></span><br><span class="line"><span class="comment">// RejectWaitingPod rejects a waiting pod given its UID.</span></span><br><span class="line">RejectWaitingPod(uid types.UID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientSet returns a kubernetes clientSet.</span></span><br><span class="line">ClientSet() clientset.Interface</span><br><span class="line"></span><br><span class="line">SharedInformerFactory() informers.SharedInformerFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// VolumeBinder returns the volume binder used by scheduler.</span></span><br><span class="line">VolumeBinder() scheduling.SchedulerVolumeBinder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugin-Registration"><a href="#Plugin-Registration" class="headerlink" title="Plugin Registration"></a>Plugin Registration</h3><p>对于每一个插件，都需要定义一个构造函数，并且把它加入到注册工厂中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PluginFactory = <span class="function"><span class="keyword">func</span><span class="params">(runtime.Unknown, FrameworkHandle)</span> <span class="params">(Plugin, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">map</span>[<span class="keyword">string</span>]PluginFactory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistry</span><span class="params">()</span> <span class="title">Registry</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Registry&#123;</span><br><span class="line">      fooplugin.Name: fooplugin.New,</span><br><span class="line">      barplugin.Name: barplugin.New,</span><br><span class="line">      <span class="comment">// New plugins are registered here.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>NodeAffinity</code>为例，在定义了<code>NodeAffinity</code>这个插件结构体后，需要有一个<code>New</code>函数，函数参数同上面的<code>PluginFactory</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeAffinity is a plugin that checks if a pod node selector matches the node label.</span></span><br><span class="line"><span class="keyword">type</span> NodeAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line">handle framework.FrameworkHandle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New initializes a new plugin and returns it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(_ *runtime.Unknown, h framework.FrameworkHandle)</span> <span class="params">(framework.Plugin, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;NodeAffinity&#123;handle: h&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么是在哪里将这些插件注册到Framework的呢？在 <code>NewFramework</code>函数中对Framework初始化时，会对registry中的每一个插件，如果是配置需要的插件，就调用<code>factory</code>工厂函数，对各个插件初始化构造，并注册到 <code>pluginsMap</code>中。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pluginsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Plugin)</span><br><span class="line"><span class="keyword">for</span> name, factory := <span class="keyword">range</span> r &#123;</span><br><span class="line"><span class="comment">// initialize only needed plugins.</span></span><br><span class="line"><span class="keyword">if</span> _, ok := pg[name]; !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p, err := factory(pluginConfig[name], f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error initializing plugin %q: %v"</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">pluginsMap[name] = p</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>pluginsMap</code>是一个临时的字典，真正注册到framework结构体中，是调用<code>updatePluginList</code>函数利用反射进行注册。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> _, e := <span class="keyword">range</span> f.getExtensionPoints(plugins) &#123;</span><br><span class="line"><span class="keyword">if</span> err := updatePluginList(e.slicePtr, e.plugins, pluginsMap); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>e</code>是framework的插件扩展点</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/v1alpha1/framework.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *framework)</span> <span class="title">getExtensionPoints</span><span class="params">(plugins *config.Plugins)</span> []<span class="title">extensionPoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []extensionPoint&#123;</span><br><span class="line">&#123;plugins.PreFilter, &amp;f.preFilterPlugins&#125;,</span><br><span class="line">&#123;plugins.Filter, &amp;f.filterPlugins&#125;,</span><br><span class="line">&#123;plugins.Reserve, &amp;f.reservePlugins&#125;,</span><br><span class="line">&#123;plugins.PreScore, &amp;f.preScorePlugins&#125;,</span><br><span class="line">&#123;plugins.Score, &amp;f.scorePlugins&#125;,</span><br><span class="line">&#123;plugins.PreBind, &amp;f.preBindPlugins&#125;,</span><br><span class="line">&#123;plugins.Bind, &amp;f.bindPlugins&#125;,</span><br><span class="line">&#123;plugins.PostBind, &amp;f.postBindPlugins&#125;,</span><br><span class="line">&#123;plugins.Unreserve, &amp;f.unreservePlugins&#125;,</span><br><span class="line">&#123;plugins.Permit, &amp;f.permitPlugins&#125;,</span><br><span class="line">&#123;plugins.QueueSort, &amp;f.queueSortPlugins&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，slicePtr指向的是对于framework不同扩展点，存储的不同插件具体实现；而 plugins 这个 PluginSet这个配置，主要配置哪些插件开启，哪些插件关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> extensionPoint <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// the set of plugins to be configured at this extension point.</span></span><br><span class="line">plugins *config.PluginSet</span><br><span class="line"><span class="comment">// a pointer to the slice storing plugins implementations that will run at this</span></span><br><span class="line"><span class="comment">// extension point.</span></span><br><span class="line">slicePtr <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updatePluginList</code>函数其具体实现如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updatePluginList</span><span class="params">(pluginList <span class="keyword">interface</span>&#123;&#125;, pluginSet *config.PluginSet, pluginsMap <span class="keyword">map</span>[<span class="keyword">string</span>]Plugin)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pluginSet == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先通过Elem获取当前数组的类型</span></span><br><span class="line">    plugins := reflect.ValueOf(pluginList).Elem()</span><br><span class="line">    <span class="comment">// 通过数组类型来获取数组内部元素的类型</span></span><br><span class="line">    pluginType := plugins.Type().Elem()</span><br><span class="line">    set := sets.NewString()</span><br><span class="line">    <span class="keyword">for</span> _, ep := <span class="keyword">range</span> pluginSet.Enabled &#123;</span><br><span class="line">        pg, ok := pluginsMap[ep.Name]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s %q does not exist"</span>, pluginType.Name(), ep.Name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合法性检查：如果发现当前插件未实现当前接口，则报错</span></span><br><span class="line">        <span class="keyword">if</span> !reflect.TypeOf(pg).Implements(pluginType) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"plugin %q does not extend %s plugin"</span>, ep.Name, pluginType.Name())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> set.Has(ep.Name) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"plugin %q already registered as %q"</span>, ep.Name, pluginType.Name())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        set.Insert(ep.Name)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加插件到slice中，并保存指针指向</span></span><br><span class="line">        newPlugins := reflect.Append(plugins, reflect.ValueOf(pg))</span><br><span class="line">        plugins.Set(newPlugins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，<code>Registry</code>中的插件是在哪里注册的呢？在 <code>pkg/scheduler/scheduler.go</code>中</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line"><span class="keyword">if</span> err := registry.Merge(options.frameworkOutOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是在plugin目录下硬编码的，也就是Framework内置的插件。对于自己写的插件，需要通过 <code>frameworkOutOfTreeRegistry</code> 配置。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/framework/plugins/registry.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInTreeRegistry</span><span class="params">()</span> <span class="title">framework</span>.<span class="title">Registry</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.Registry&#123;</span><br><span class="line">defaultpodtopologyspread.Name:              defaultpodtopologyspread.New,</span><br><span class="line">imagelocality.Name:                         imagelocality.New,</span><br><span class="line">tainttoleration.Name:                       tainttoleration.New,</span><br><span class="line">nodename.Name:                              nodename.New,</span><br><span class="line">nodeports.Name:                             nodeports.New,</span><br><span class="line">nodepreferavoidpods.Name:                   nodepreferavoidpods.New,</span><br><span class="line">nodeaffinity.Name:                          nodeaffinity.New,</span><br><span class="line">podtopologyspread.Name:                     podtopologyspread.New,</span><br><span class="line">nodeunschedulable.Name:                     nodeunschedulable.New,</span><br><span class="line">noderesources.FitName:                      noderesources.NewFit,</span><br><span class="line">noderesources.BalancedAllocationName:       noderesources.NewBalancedAllocation,</span><br><span class="line">noderesources.MostAllocatedName:            noderesources.NewMostAllocated,</span><br><span class="line">noderesources.LeastAllocatedName:           noderesources.NewLeastAllocated,</span><br><span class="line">noderesources.RequestedToCapacityRatioName: noderesources.NewRequestedToCapacityRatio,</span><br><span class="line">noderesources.ResourceLimitsName:           noderesources.NewResourceLimits,</span><br><span class="line">volumebinding.Name:                         volumebinding.New,</span><br><span class="line">volumerestrictions.Name:                    volumerestrictions.New,</span><br><span class="line">volumezone.Name:                            volumezone.New,</span><br><span class="line">nodevolumelimits.CSIName:                   nodevolumelimits.NewCSI,</span><br><span class="line">nodevolumelimits.EBSName:                   nodevolumelimits.NewEBS,</span><br><span class="line">nodevolumelimits.GCEPDName:                 nodevolumelimits.NewGCEPD,</span><br><span class="line">nodevolumelimits.AzureDiskName:             nodevolumelimits.NewAzureDisk,</span><br><span class="line">nodevolumelimits.CinderName:                nodevolumelimits.NewCinder,</span><br><span class="line">interpodaffinity.Name:                      interpodaffinity.New,</span><br><span class="line">nodelabel.Name:                             nodelabel.New,</span><br><span class="line">serviceaffinity.Name:                       serviceaffinity.New,</span><br><span class="line">queuesort.Name:                             queuesort.New,</span><br><span class="line">defaultbinder.Name:                         defaultbinder.New,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个问题，对于Plugins目录下的每个插件，是如何决定自己属于那个扩展点呢？</p><h2 id="Plugin-Lifecycle"><a href="#Plugin-Lifecycle" class="headerlink" title="Plugin Lifecycle"></a>Plugin Lifecycle</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><blockquote><p>There are two steps to plugin initialization. First, <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#plugin-registration" target="_blank" rel="external nofollow noopener noreferrer">plugins are registered</a>. Second, the scheduler uses its configuration to decide which plugins to instantiate. If a plugin registers for multiple extension points, <em>it is instantiated only once</em>.</p><p>When a plugin is instantiated, it is passed <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#optional-args" target="_blank" rel="external nofollow noopener noreferrer">config args</a> and a <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#frameworkhandle" target="_blank" rel="external nofollow noopener noreferrer"><code>FrameworkHandle</code></a>.</p></blockquote><h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><blockquote><p>There are two types of concurrency that plugin writers should consider. A plugin might be invoked several times concurrently when evaluating multiple nodes, and a plugin may be called concurrently from <em>different <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#scheduling-cycle--binding-cycle" target="_blank" rel="external nofollow noopener noreferrer">scheduling contexts</a></em>.</p><p><em>Note: Within one scheduling context, each extension point is evaluated serially.</em></p><p>In the main thread of the scheduler, only one scheduling cycle is processed at a time. Any extension point up to and including <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#reserve" target="_blank" rel="external nofollow noopener noreferrer">reserve</a> will be finished before the next scheduling cycle begins*. After the reserve phase, the binding cycle is executed asynchronously. This means that a plugin could be called concurrently from two different scheduling contexts, provided that at least one of the calls is to an extension point after reserve. Stateful plugins should take care to handle these situations.</p><p>Finally, <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md#un-reserve" target="_blank" rel="external nofollow noopener noreferrer">un-reserve</a> plugins may be called from either the Permit thread or the Bind thread, depending on how the pod was rejected.</p><p>* <em>The queue sort extension point is a special case. It is not part of a scheduling context and may be called concurrently for many pod pairs.</em></p><p><img alt="image" data-src="https://github.com/kubernetes/enhancements/raw/master/keps/sig-scheduling/20180409-scheduling-framework-threads.png"></p></blockquote><h2 id="Configuring-Plugins"><a href="#Configuring-Plugins" class="headerlink" title="Configuring Plugins"></a>Configuring Plugins</h2><h2 id="Interaction-with-Cluster-Autoscaler"><a href="#Interaction-with-Cluster-Autoscaler" class="headerlink" title="Interaction with Cluster Autoscaler"></a>Interaction with Cluster Autoscaler</h2><h1 id="调度器核心组件流程"><a href="#调度器核心组件流程" class="headerlink" title="调度器核心组件流程"></a>调度器核心组件流程</h1><h2 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h2><h3 id="调度器参数初始化"><a href="#调度器参数初始化" class="headerlink" title="调度器参数初始化"></a>调度器参数初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultSchedulerOptions = schedulerOptions&#123;</span><br><span class="line">profiles: []schedulerapi.KubeSchedulerProfile&#123;</span><br><span class="line"><span class="comment">// Profiles' default plugins are set from the algorithm provider.</span></span><br><span class="line">&#123;SchedulerName: v1.DefaultSchedulerName&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">schedulerAlgorithmSource: schedulerapi.SchedulerAlgorithmSource&#123;</span><br><span class="line">Provider: defaultAlgorithmSourceProviderName(),</span><br><span class="line">&#125;,</span><br><span class="line">disablePreemption:        <span class="literal">false</span>,</span><br><span class="line">percentageOfNodesToScore: schedulerapi.DefaultPercentageOfNodesToScore,</span><br><span class="line">bindTimeoutSeconds:       BindTimeoutSeconds,</span><br><span class="line">podInitialBackoffSeconds: <span class="keyword">int64</span>(internalqueue.DefaultPodInitialBackoffDuration.Seconds()),</span><br><span class="line">podMaxBackoffSeconds:     <span class="keyword">int64</span>(internalqueue.DefaultPodMaxBackoffDuration.Seconds()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件工厂注册表的初始化"><a href="#插件工厂注册表的初始化" class="headerlink" title="插件工厂注册表的初始化"></a>插件工厂注册表的初始化</h3><p>插件工厂注册表的初始化分为两个部分in tree和out of tree即当前版本自带的和用户自定义的两部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先进行当前版本的插件注册表的注册</span></span><br><span class="line">registry := frameworkplugins.NewInTreeRegistry()</span><br><span class="line"><span class="comment">// 加载用户自定义的插件注册表</span></span><br><span class="line"><span class="keyword">if</span> err := registry.Merge(options.frameworkOutOfTreeRegistry); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件informer回调handler绑定"><a href="#事件informer回调handler绑定" class="headerlink" title="事件informer回调handler绑定"></a>事件informer回调handler绑定</h3><p>绑定事件回调主要是通过AddAllEventHandlers主要是将各种资源数据通过SchedulerCache放入本地缓存中，同时针对未调度的pod(!assignedPod即没有绑定Node的pod)加入到调度队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">    schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    informerFactory informers.SharedInformerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br></pre></td></tr></table></figure><h3 id="触发未调度队列中的pod转移"><a href="#触发未调度队列中的pod转移" class="headerlink" title="触发未调度队列中的pod转移"></a>触发未调度队列中的pod转移</h3><p>当资源发生变化的时候，比如service、volume等就会对unschedulableQ中的之前调度失败的pod进行重试，选择将其转移到activeQ或者backoffQ中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveOrBackoffQueue</span><span class="params">(event <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">    unschedulablePods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>, <span class="built_in">len</span>(p.unschedulableQ.podInfoMap))</span><br><span class="line">    <span class="comment">// 获取所有unschedulable的pod</span></span><br><span class="line">    <span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">        unschedulablePods = <span class="built_in">append</span>(unschedulablePods, pInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将unschedulable的pod转移到backoffQ队列或者activeQ队列中</span></span><br><span class="line">    p.movePodsToActiveOrBackoffQueue(unschedulablePods, event)</span><br><span class="line">    <span class="comment">// 修改迁移调度器请求周期, 在失败的时候会进行比较pod的moveRequestCycle是否&gt;=schedulingCycle</span></span><br><span class="line">    p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">    p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h3><p>最后则会启动调度器，其核心流程是在scheduleOne中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先会进行同步缓存</span></span><br><span class="line">    <span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动调度队列的后台定时任务</span></span><br><span class="line">    sched.SchedulingQueue.Run()</span><br><span class="line">    <span class="comment">// 启动调度流程</span></span><br><span class="line">    wait.UntilWithContext(ctx, sched.scheduleOne, <span class="number">0</span>)</span><br><span class="line">    sched.SchedulingQueue.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建调度器核心组件基础数据"><a href="#构建调度器核心组件基础数据" class="headerlink" title="构建调度器核心组件基础数据"></a>构建调度器核心组件基础数据</h2><h3 id="获取等待调度的pod"><a href="#获取等待调度的pod" class="headerlink" title="获取等待调度的pod"></a>获取等待调度的pod</h3><p>获取等待调度的pod则直接通过NextPod进行，其实内部就是对 <code>schedulingQueue.pop</code>的封装</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列中获取等待调度的pod</span></span><br><span class="line">podInfo := sched.NextPod()</span><br><span class="line"><span class="comment">// pod could be nil when schedulerQueue is closed</span></span><br><span class="line"><span class="keyword">if</span> podInfo == <span class="literal">nil</span> || podInfo.Pod == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>NextPod</code> 方法是在Scheduler初始化时候指定的。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;Scheduler&#123;</span><br><span class="line">SchedulerCache:  c.schedulerCache,</span><br><span class="line">Algorithm:       algo,</span><br><span class="line">Profiles:        profiles,</span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, podQueue, c.schedulerCache),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">VolumeBinder:    c.volumeBinder,</span><br><span class="line">SchedulingQueue: podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>具体实现方法如下：</p><figure class="highlight go"><figcaption><span>pkg/scheduler/internal/queue/scheduling_queue.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">PodInfo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">framework</span>.<span class="title">PodInfo</span></span> &#123;</span><br><span class="line">        podInfo, err := queue.Pop()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v/%v"</span>, podInfo.Pod.Namespace, podInfo.Pod.Name)</span><br><span class="line">            <span class="keyword">return</span> podInfo</span><br><span class="line">        &#125;</span><br><span class="line">        klog.Errorf(<span class="string">"Error while retrieving next pod from scheduling queue: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取调度器Profile"><a href="#获取调度器Profile" class="headerlink" title="获取调度器Profile"></a>获取调度器Profile</h3><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prof, err := sched.profileForPod(pod)</span><br></pre></td></tr></table></figure><p>这里的Profile是根据每个Pod制定的Scheduler Name获得对应的调度器Profile</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">profileForPod</span><span class="params">(pod *v1.Pod)</span> <span class="params">(*profile.Profile, error)</span></span> &#123;</span><br><span class="line">prof, ok := sched.Profiles[pod.Spec.SchedulerName]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"profile not found for scheduler name %q"</span>, pod.Spec.SchedulerName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prof, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Profiles</code>是一个对于Framework的封装</p><figure class="highlight go"><figcaption><span>pkg/scheduler/profile/profile.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Profile is a scheduling profile.</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">framework.Framework</span><br><span class="line">Recorder events.EventRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProfile builds a Profile for the given configuration.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProfile</span><span class="params">(cfg config.KubeSchedulerProfile, frameworkFact FrameworkFactory, recorderFact RecorderFactory)</span> <span class="params">(*Profile, error)</span></span> &#123;</span><br><span class="line">f, err := frameworkFact(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r := recorderFact(cfg.SchedulerName)</span><br><span class="line"><span class="keyword">return</span> &amp;Profile&#123;</span><br><span class="line">Framework: f,</span><br><span class="line">Recorder:  r,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map holds profiles indexed by scheduler name.</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]*Profile</span><br></pre></td></tr></table></figure><p>在创建scheduler的时候，建立profiles</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiles, err := profile.NewMap(c.profiles, c.buildFramework, c.recorderFactory)</span><br></pre></td></tr></table></figure><p>关于Profile，可以参考 <a href="https://github.com/kubernetes/kubernetes/pull/88285" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kubernetes/pull/88285</a></p><h3 id="跳过提议Pod重调度"><a href="#跳过提议Pod重调度" class="headerlink" title="跳过提议Pod重调度"></a>跳过提议Pod重调度</h3><p>skipPodSchedule即检查当前 pod是否可以进行跳过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sched.skipPodSchedule(pod) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两种情况下Pod就不需要进行重复的调度</p><ul><li>pod已经被删除</li><li>pod已经被提议调度到某个节点，此时如果只是版本的更新，即除了ResourceVersion、Annotations、NodeName三个字段其余的都未曾变化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipPodSchedule returns true if we could skip scheduling the pod for specified cases.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">skipPodSchedule</span><span class="params">(prof *profile.Profile, pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Case 1: pod is being deleted.</span></span><br><span class="line"><span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">prof.Recorder.Eventf(pod, <span class="literal">nil</span>, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Scheduling"</span>, <span class="string">"skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"Skip schedule deleting pod: %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2: pod has been assumed and pod updates could be skipped.</span></span><br><span class="line"><span class="comment">// An assumed pod can be added again to the scheduling queue if it got an update event</span></span><br><span class="line"><span class="comment">// during its previous scheduling cycle but before getting assumed.</span></span><br><span class="line"><span class="keyword">if</span> sched.skipPodUpdate(pod) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的判断规则是</p><figure class="highlight go"><figcaption><span>pkg/scheduler/eventhandler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skipPodUpdate checks whether the specified pod update should be ignored.</span></span><br><span class="line"><span class="comment">// This function will return true if</span></span><br><span class="line"><span class="comment">//   - The pod has already been assumed, AND</span></span><br><span class="line"><span class="comment">//   - The pod has only its ResourceVersion, Spec.NodeName, Annotations,</span></span><br><span class="line"><span class="comment">//     ManagedFields, Finalizers and/or Conditions updated.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">skipPodUpdate</span><span class="params">(pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// Non-assumed pods should never be skipped.</span></span><br><span class="line">isAssumed, err := sched.SchedulerCache.IsAssumedPod(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to check whether pod %s/%s is assumed: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !isAssumed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gets the assumed pod from the cache.</span></span><br><span class="line">assumedPod, err := sched.SchedulerCache.GetPod(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"failed to get assumed pod %s/%s from cache: %v"</span>, pod.Namespace, pod.Name, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compares the assumed pod in the cache with the pod update. If they are</span></span><br><span class="line"><span class="comment">// equal (with certain fields excluded), this pod update will be skipped.</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">p := pod.DeepCopy()</span><br><span class="line"><span class="comment">// ResourceVersion must be excluded because each object update will</span></span><br><span class="line"><span class="comment">// have a new resource version.</span></span><br><span class="line">p.ResourceVersion = <span class="string">""</span></span><br><span class="line"><span class="comment">// Spec.NodeName must be excluded because the pod assumed in the cache</span></span><br><span class="line"><span class="comment">// is expected to have a node assigned while the pod update may nor may</span></span><br><span class="line"><span class="comment">// not have this field set.</span></span><br><span class="line">p.Spec.NodeName = <span class="string">""</span></span><br><span class="line"><span class="comment">// Annotations must be excluded for the reasons described in</span></span><br><span class="line"><span class="comment">// https://github.com/kubernetes/kubernetes/issues/52914.</span></span><br><span class="line">p.Annotations = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Same as above, when annotations are modified with ServerSideApply,</span></span><br><span class="line"><span class="comment">// ManagedFields may also change and must be excluded</span></span><br><span class="line">p.ManagedFields = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// The following might be changed by external controllers, but they don't</span></span><br><span class="line"><span class="comment">// affect scheduling decisions.</span></span><br><span class="line">p.Finalizers = <span class="literal">nil</span></span><br><span class="line">p.Status.Conditions = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">assumedPodCopy, podCopy := f(assumedPod), f(pod)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(assumedPodCopy, podCopy) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"Skipping pod %s/%s update"</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建调度上下文"><a href="#构建调度上下文" class="headerlink" title="构建调度上下文"></a>构建调度上下文</h3><p>生成CycleState和context, 其中CycleState用于进行调度器周期上线文数据传递共享，而context则负责统一的退出协调管理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建CycleState和context</span></span><br><span class="line">state := framework.NewCycleState()</span><br><span class="line">state.SetRecordPluginMetrics(rand.Intn(<span class="number">100</span>) &lt; pluginMetricsSamplePercent)</span><br><span class="line">schedulingCycleCtx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br></pre></td></tr></table></figure><h2 id="正常调度流程"><a href="#正常调度流程" class="headerlink" title="正常调度流程"></a>正常调度流程</h2><h3 id="调度算法执行"><a href="#调度算法执行" class="headerlink" title="调度算法执行"></a>调度算法执行</h3><p>正常调度只需要调度ScheduleAlgorithm来进行调度，具体实现细节可以看之前的文章</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleResult, err := sched.Algorithm.Schedule(schedulingCycleCtx, state, pod)</span><br></pre></td></tr></table></figure><h3 id="Assume-Pod"><a href="#Assume-Pod" class="headerlink" title="Assume Pod"></a>Assume Pod</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = sched.assume(assumedPod, scheduleResult.SuggestedHost)</span><br></pre></td></tr></table></figure><p>如果一个Pod被提议存储到某个节点，则会先将其加入到SchedulerCache中，同时从SchedulingQueue中移除，避免重复调度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    assumed.Spec.NodeName = host</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到SchedulerCache中这样下个调度周期中，pod会占用对应node的资源</span></span><br><span class="line">    <span class="keyword">if</span> err := sched.SchedulerCache.AssumePod(assumed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"scheduler cache AssumePod failed: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if "assumed" is a nominated pod, we should remove it from internal cache</span></span><br><span class="line">    <span class="comment">// 从调度队列中移除pod</span></span><br><span class="line">    <span class="keyword">if</span> sched.SchedulingQueue != <span class="literal">nil</span> &#123;</span><br><span class="line">        sched.SchedulingQueue.DeleteNominatedPodIfExists(assumed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定调度流程"><a href="#绑定调度流程" class="headerlink" title="绑定调度流程"></a>绑定调度流程</h2><p>首先会遍历所有的插件，然后如果发现状态设置为Wait，则会根据插件的等待时间进行wait操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run "permit" plugins.</span></span><br><span class="line">runPermitStatus := prof.RunPermitPlugins(schedulingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br></pre></td></tr></table></figure><p>运行Permit插件之后，Bind阶段可以异步运行，依次绑定Volumes，运行Prebind插件，执行bind操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">bindingCycleCtx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">waitOnPermitStatus := prof.WaitOnPermit(bindingCycleCtx, assumedPod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind volumes first before Pod</span></span><br><span class="line"><span class="keyword">if</span> !allBound &#123;</span><br><span class="line">err := sched.bindVolumes(assumedPod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run "prebind" plugins.</span></span><br><span class="line">preBindStatus := prof.RunPreBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line"></span><br><span class="line">err := sched.bind(bindingCycleCtx, prof, assumedPod, scheduleResult.SuggestedHost, state)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Run "postbind" plugins.</span></span><br><span class="line">prof.RunPostBindPlugins(bindingCycleCtx, state, assumedPod, scheduleResult.SuggestedHost)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="抢占流程"><a href="#抢占流程" class="headerlink" title="抢占流程"></a>抢占流程</h2><p>如果是预选失败的，并且当前调度器允许抢占功能，则会进行抢占调度处理即sched.preempt</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> fitError, ok := err.(*core.FitError); ok &#123;</span><br><span class="line">    <span class="comment">// 如果是预选失败则进行</span></span><br><span class="line">    <span class="keyword">if</span> sched.DisablePreemption &#123;</span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">"Pod priority feature is not enabled or preemption is disabled by scheduler configuration."</span> +</span><br><span class="line">            <span class="string">" No preemption is performed."</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preemptionStartTime := time.Now()</span><br><span class="line">        <span class="comment">// 抢占调度</span></span><br><span class="line">        sched.preempt(schedulingCycleCtx, state, fwk, pod, fitError)</span><br><span class="line">        metrics.PreemptionAttempts.Inc()</span><br><span class="line">        metrics.SchedulingAlgorithmPreemptionEvaluationDuration.Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">        metrics.DeprecatedSchedulingDuration.WithLabelValues(metrics.PreemptionEvaluation).Observe(metrics.SinceInSeconds(preemptionStartTime))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取抢占者"><a href="#获取抢占者" class="headerlink" title="获取抢占者"></a>获取抢占者</h3><p>首先通过apiserver获取当前需要执行抢占的pod的最新Pod信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preemptor, err := sched.podPreemptor.getUpdatedPod(preemptor)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">"Error getting the updated preemptor pod object: %v"</span>, err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过抢占算法筛选"><a href="#通过抢占算法筛选" class="headerlink" title="通过抢占算法筛选"></a>通过抢占算法筛选</h3><p>通过Preempt筛选要进行抢占操作的node节点、待驱逐的pod、待驱逐的提议的pod</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node, victims, nominatedPodsToClear, err := sched.Algorithm.Preempt(ctx, state, preemptor, scheduleErr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    klog.Errorf(<span class="string">"Error preempting victims to make room for %v/%v: %v"</span>, preemptor.Namespace, preemptor.Name, err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新调度队列中的Pod信息"><a href="#更新调度队列中的Pod信息" class="headerlink" title="更新调度队列中的Pod信息"></a>更新调度队列中的Pod信息</h3><p>如果节点抢占一个pod成功，则会更新队列中的抢占节点的提议节点信息，这样在下个调度周期中，就可以使用该信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sched.SchedulingQueue.<span class="constructor">UpdateNominatedPodForNode(<span class="params">preemptor</span>, <span class="params">nodeName</span>)</span></span><br></pre></td></tr></table></figure><h3 id="更新Pod的提议节点信息"><a href="#更新Pod的提议节点信息" class="headerlink" title="更新Pod的提议节点信息"></a>更新Pod的提议节点信息</h3><p>这里会直接调用apiserver中节点的提议节点信息，为什么要这样做呢？因为当前pod已经抢占了node上部分的节点信息，但是在被抢占的pod完全从节点上删除之前的这段时间，该pod调度依然会失败，但是此时不能继续调用抢占流程了，因为你已经执行了抢占，此时只需要等待对应节点上的node都删除，则再次继续尝试调度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = sched.podPreemptor.setNominatedNodeName(preemptor, nodeName)</span><br></pre></td></tr></table></figure><h3 id="删除被驱逐节点"><a href="#删除被驱逐节点" class="headerlink" title="删除被驱逐节点"></a>删除被驱逐节点</h3><p>删除被驱逐节点直接调用apiserver进行操作，如果此时发现当前pod还在等待插件的Allow操作，则直接进行Reject</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, victim := <span class="keyword">range</span> victims &#123;</span><br><span class="line">        <span class="comment">// 调用apiserver进行删除pod</span></span><br><span class="line">        <span class="keyword">if</span> err := sched.podPreemptor.deletePod(victim); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(<span class="string">"Error preempting pod %v/%v: %v"</span>, victim.Namespace, victim.Name, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the victim is a WaitingPod, send a reject message to the PermitPlugin</span></span><br><span class="line">        <span class="keyword">if</span> waitingPod := fwk.GetWaitingPod(victim.UID); waitingPod != <span class="literal">nil</span> &#123;</span><br><span class="line">            waitingPod.Reject(<span class="string">"preempted"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sched.Recorder.Eventf(victim, preemptor, v1.EventTypeNormal, <span class="string">"Preempted"</span>, <span class="string">"Preempting"</span>, <span class="string">"Preempted by %v/%v on node %v"</span>, preemptor.Namespace, preemptor.Name, nodeName)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="更新被抢占的提议节点"><a href="#更新被抢占的提议节点" class="headerlink" title="更新被抢占的提议节点"></a>更新被抢占的提议节点</h3><p>针对那些已经被提议调度到当前node的pod，会将其node设置为空，重新进行调度选择</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> nominatedPodsToClear &#123;</span><br><span class="line">    <span class="comment">// 清理这些提议的pod</span></span><br><span class="line">    rErr := sched.podPreemptor.removeNominatedNodeName(p)</span><br><span class="line">    <span class="keyword">if</span> rErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Cannot remove 'NominatedPod' field of pod: %v"</span>, rErr)</span><br><span class="line">        <span class="comment">// We do not return as this error is not critical.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Algorithm-Source"><a href="#Algorithm-Source" class="headerlink" title="Algorithm Source"></a>Algorithm Source</h2><h3 id="Algorithm-Provider"><a href="#Algorithm-Provider" class="headerlink" title="Algorithm Provider"></a>Algorithm Provider</h3><h3 id="Algorithm-Policy"><a href="#Algorithm-Policy" class="headerlink" title="Algorithm Policy"></a>Algorithm Policy</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md" target="_blank" rel="external nofollow noopener noreferrer">KEP for scheduling framework</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes Scheduling Framework 是在Kubernetes 1.15版本后新出现的一种调度框架。Scheduling Framework 在原有的调度流程中, 定义了丰富扩展点接口，开发者可以通过实现扩展点所定义的接口来实现插件，将插件注册到扩展点。Scheduling Framework 在执行调度流程时，运行到相应的扩展点时，会调用用户注册的插件，影响调度决策的结果。通过这种方式来将用户的调度逻辑集成到 Scheduling Framework 中。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-01-25_scheduling-framework-extensions.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
      <category term="framework" scheme="http://houmin.cc/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>【下厨房】酸甜麻辣咸</title>
    <link href="http://houmin.cc/posts/8f35743d/"/>
    <id>http://houmin.cc/posts/8f35743d/</id>
    <published>2020-07-13T13:21:43.000Z</published>
    <updated>2020-07-25T14:18:13.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出<code>Hello World</code>，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印<code>Hello World</code>，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。</p><a id="more"></a><h2 id="基本调料"><a href="#基本调料" class="headerlink" title="基本调料"></a>基本调料</h2><h3 id="食盐"><a href="#食盐" class="headerlink" title="食盐"></a>食盐</h3><ul><li>盐乃百味之首，主要用于调出咸味。</li><li>做菜时，<strong>在多数情况下</strong>都是在<strong>最后调味阶段再放盐</strong>的，例如炒菜、炖汤、炖菜时，因为这样可以保证盐不会破坏掉其他的味道，也可以保证碘元素少挥发，还能保证菜品不会过咸。</li><li>但如果在准备<strong>食材时需要提前入味</strong>的情况下，就<strong>需要先放盐了</strong>，例如蒸肉、蒸鱼。</li></ul><p><img alt="盐" data-src="https://pic1.zhimg.com/v2-f828837cbf0cf989cfb25b5b1bbdac78_b.webp"></p><h3 id="酱油"><a href="#酱油" class="headerlink" title="酱油"></a>酱油</h3><ul><li>我国传统调料，主要用来增咸提鲜。酱油可分为生抽和老抽。</li><li><strong>老抽</strong>吃到嘴里很浓稠，一般用于给食物上色提鲜。</li><li><strong>生抽</strong>颜色比较淡，味道稍咸，主要用来调味，炒菜或者凉拌菜的时候用得比较多。</li></ul><h3 id="鸡精和味精"><a href="#鸡精和味精" class="headerlink" title="鸡精和味精"></a>鸡精和味精</h3><ul><li>调鲜专用，主要成分都是谷氨酸钠，两者其实在原料上差别不大，只是口感上，<strong>鸡精更鲜，更有风味</strong>。</li><li>值得一提的是，<strong>鸡精和味精其实真的不会致癌</strong>，所以正常做菜使用是没有问题的！</li></ul><p><strong>使用鸡精和味精的注意事项：</strong></p><ul><li>高汤烹制的菜肴不必使用，因为已经很鲜美了；</li><li>酸性强的菜肴，如糖醋、醋溜菜等不宜使用；</li><li>腌菜不要使用味精；</li><li>不宜过早放味精，要在将出锅时放入；</li><li>如果用于凉拌菜，可以先溶解再使用;</li><li>不能在高温下使用。</li></ul><p><img alt="鸡精和味精" data-src="https://pic3.zhimg.com/v2-73bbb13a22c0b7fd1ec322934b73c1ec_b.jpg"></p><h3 id="醋"><a href="#醋" class="headerlink" title="醋"></a>醋</h3><p>我国古代传统调味料之一。有三千多年的历史。醋在分类上通常有以下几类：<strong>米醋、陈醋、白醋。</strong></p><ul><li><strong>米醋</strong>的口感更好，口感酸甜，可用于糖醋排骨。</li><li><strong>陈醋</strong>酸味很浓烈，很开胃，基本上可用于各种常见的调味。</li><li><strong>白醋</strong>的酸味口感较淡，多用于凉拌菜或西餐的使用。</li></ul><p><strong>下面总结一下醋的各种常见功能：</strong></p><ul><li><strong>去腥去膻：</strong>做鱼做羊的时候可加入少许醋去除异味</li><li><strong>减少辣味：</strong>如果炒菜时不小心辣椒放多了，可以放一些醋减少辣味</li><li><strong>增香：</strong>做菜时候加入少许醋，可以增加菜肴香味并减少油腻程度</li><li><strong>催熟：</strong>炖牛羊肉的时候加一点醋能够让菜肴熟得更快</li><li><strong>增甜：</strong>南方朋友做甜粥的时候加入少许醋可以使粥更甜</li></ul><p><img alt="醋" data-src="https://pic1.zhimg.com/v2-3a5d4fa5e12fd226862b423e39baf703_b.jpg"></p><h3 id="糖"><a href="#糖" class="headerlink" title="糖"></a>糖</h3><ul><li><p>增甜味的调料，常见的种类有白糖、红糖、冰糖。</p><ul><li>一般使用白糖作为调料。</li><li>红糖可以补血破淤具有益气、缓中、助脾化食的作用。</li><li>冰糖可以去痰止咳，一般可用于制作红烧类菜肴时增加色泽及口感，也可用于制作甜品。</li></ul></li><li><p>少许白糖可以提鲜。</p></li><li><p>白糖还可以综合酸味，可做醋溜系的菜。</p></li><li><p>由于糖的特性，可做拔丝香蕉等“拔丝类”菜肴</p></li><li><p>挂霜：白糖入锅，加入适量清水，熬至水近干时，倒入经烘烤或油炸过的原料，离火，翻拌，冷却后，成品表面即似白霜状。如糖霜花生、糖山楂、糖霜核桃等。</p></li><li><p>炒糖色：广泛用于卤菜、红烧菜的调色、如红烧猪蹄、红烧排骨等。</p></li><li><p>糖醋菜系必备，开胃可口。</p><p><img alt="糖" data-src="https://pic3.zhimg.com/v2-0af08e21b39bc930a099b05f35c3ccfa_b.jpg"></p></li></ul><h2 id="酒类"><a href="#酒类" class="headerlink" title="酒类"></a>酒类</h2><h3 id="料酒"><a href="#料酒" class="headerlink" title="料酒"></a><strong>料酒</strong></h3><ul><li><strong>去腥</strong>专家，很多肉类、内脏等食材在初加工时，都会使用料酒去腥。</li><li>例如在<strong>炒鸡蛋的时候加入少许料酒也可以去腥提香</strong></li></ul><h3 id="啤酒"><a href="#啤酒" class="headerlink" title="啤酒"></a><strong>啤酒</strong></h3><ul><li>硬菜会用啤酒去腥、调味，请家里常备“宽啤酒”</li></ul><h3 id="高度白酒"><a href="#高度白酒" class="headerlink" title="高度白酒"></a><strong>高度白酒</strong></h3><ul><li>去除腥味较重的食物时可以用到</li></ul><h2 id="酱类"><a href="#酱类" class="headerlink" title="酱类"></a>酱类</h2><p>酱类调料：各类以酱为形式的调料</p><h3 id="豆瓣酱"><a href="#豆瓣酱" class="headerlink" title="豆瓣酱"></a>豆瓣酱</h3><p>川菜之魂，主要<strong>增加菜肴的咸鲜味</strong>。</p><h3 id="甜面酱"><a href="#甜面酱" class="headerlink" title="甜面酱"></a>甜面酱</h3><p>以面粉、水和食盐为原料的一种酱料，<strong>鲜香甜味十足</strong>。可以当做酱料使用（例如蘸黄瓜），也可以调味，是炸酱面、京酱肉丝等菜肴的必备调料。　　</p><h3 id="番茄酱"><a href="#番茄酱" class="headerlink" title="番茄酱"></a>番茄酱</h3><p>用新鲜番茄经过加工而成的酱料，鲜而酸。常用于<strong>增色、添香、增加酸味口感</strong>，如制作松鼠鱼。</p><h3 id="芝麻酱"><a href="#芝麻酱" class="headerlink" title="芝麻酱"></a>芝麻酱</h3><p>顾名思义是芝麻作为原料调制的酱料，非常的香，<strong>增香必备</strong>。可直接作为蘸料，例如北方的同学吃火锅是喜欢蘸麻酱，也常用于制作凉面、凉拌菜等。</p><h3 id="蚝油"><a href="#蚝油" class="headerlink" title="蚝油"></a>蚝油</h3><p>以素有”海底牛奶”之称的蚝牗牡蛎牍为原料，经煮熟取汁浓缩，加辅料精制而成。蚝油味道鲜美、蚝香浓郁，黏稠适度，营养价值高。适合烹制多种食材，如蚝油牛肉、蚝油生菜、蚝油荷兰豆等，还可<strong>调拌各种面食、涮海鲜、佐餐食用</strong>等。</p><h2 id="香料类"><a href="#香料类" class="headerlink" title="香料类"></a>香料类</h2><p>香料分很多种，主要功能是增加各种风味，使味更有层次感。</p><h3 id="干辣椒："><a href="#干辣椒：" class="headerlink" title="干辣椒："></a>干辣椒：</h3><p><strong>增香、增辣。</strong></p><p>油热时和葱姜一起放锅内爆香，一般家常菜都可以用。</p><h3 id="花椒与麻椒"><a href="#花椒与麻椒" class="headerlink" title="花椒与麻椒"></a>花椒与麻椒</h3><p>增加菜肴的<strong>“麻”味</strong>，同时也是<strong>爆香</strong>的“利器”！炒菜的时候加入花椒可以防止油沸，花椒粉也可以用于包子或者饺子的馅料。麻椒比花椒颜色更重，更麻，喜欢重口味的同学可以用麻椒作为调料。</p><h3 id="八角-大料"><a href="#八角-大料" class="headerlink" title="八角(大料)"></a>八角(大料)</h3><p>也叫大茴香，因此无论<strong>卤、酱、烧、炖，</strong>都可以用到它，用以<strong>去腥添香。</strong>不论炒菜、炖肉、腌菜，八角都要提前放。一份菜一般放三瓣，分量多的可以放一整朵。</p><h3 id="胡椒"><a href="#胡椒" class="headerlink" title="胡椒"></a>胡椒</h3><ul><li>又分<strong>黑胡椒和白胡椒</strong>，常用于提鲜去腥，开胃、促进食欲。</li><li>其中<strong>黑胡椒味道更浓，香中带辣</strong>，适用于炖、煎、烤肉类。</li><li><strong>白胡椒胡椒香味稍淡，辣味更浓</strong>，能提出鲜味。</li><li>需要注意的是，无论黑胡椒、白胡椒皆不能高温油炸，应在菜肴或汤羹即将出锅时加少许。</li></ul><h3 id="香叶"><a href="#香叶" class="headerlink" title="香叶"></a>香叶</h3><p>干燥后的月桂树叶，用以<strong>去腥添香</strong>，用于炖肉、卤味等。</p><h3 id="桂皮"><a href="#桂皮" class="headerlink" title="桂皮"></a>桂皮</h3><p>干燥后的月桂树皮，用以去腥添香，也可以用于炖肉、卤味等。</p><h3 id="小茴香"><a href="#小茴香" class="headerlink" title="小茴香"></a>小茴香</h3><p>用以<strong>去腥添香</strong>，用于炖肉等。其茎叶部分即茴香菜。</p><h3 id="孜然"><a href="#孜然" class="headerlink" title="孜然"></a>孜然</h3><p>祛<strong>除腥膻异味</strong>的作用很强,！还能<strong>解除肉类的油腻</strong>,常用在烧烤牛羊肉中，令肉质更加鲜美芳香并且去除膻味异味。</p><h3 id="五香粉"><a href="#五香粉" class="headerlink" title="五香粉"></a><strong>五香粉</strong></h3><p>花椒、大料、桂皮、丁香等芳香类调料混合研制而成，使用方便。尤其适合用于<strong>烘烤或快炒肉类，炖、焖、煨、蒸、煮菜肴</strong>作调味。</p><h2 id="辣椒类"><a href="#辣椒类" class="headerlink" title="辣椒类"></a>辣椒类</h2><p><img alt="辣椒" data-src="https://pic2.zhimg.com/v2-471d6358a188a14ebf240fa500d0164f_b.jpg"></p><h3 id="剁椒与糟辣椒"><a href="#剁椒与糟辣椒" class="headerlink" title="剁椒与糟辣椒"></a>剁椒与糟辣椒</h3><p>云贵地区称作糟辣椒、湖南地区叫做剁椒，<strong>口味和制作工艺稍有差别</strong>，但是总体来说外表色泽鲜红，具有香、辣、鲜、酸、嫩、咸、脆、的独特风味，有开胃消食、暖胃驱寒的功效。可以直接食用、当做蘸料，也可用于调料，比如制作剁椒鱼头、鱼香肉丝、鱼香茄子等菜肴，值得注意的是，由于<strong>剁椒和糟辣椒本身就有盐味</strong>，所以调味时就<strong>不用额外添加过多的食盐</strong>了！</p><h3 id="红油辣椒"><a href="#红油辣椒" class="headerlink" title="红油辣椒"></a>红油辣椒</h3><p>是川菜中常见的调味料，油色红亮，味道香辣。常用于<strong>凉拌菜、拌面、蘸料等。</strong></p><h3 id="泡椒"><a href="#泡椒" class="headerlink" title="泡椒"></a>泡椒</h3><p>四川特产，由新鲜辣椒腌制而成。香、酸、辣味十足，是制作泡椒类菜肴的必备调料（例如川味鱼香肉丝、泡椒牛肉等）。<br>常见的泡椒主要有两种：</p><ul><li>二荆条泡辣椒：这种辣椒相对较长，辣味适口，香气足，可以切碎了使用，制作传统川菜鱼香肉丝就离不开它</li><li>子弹头泡辣椒：这种辣椒较短，呈鸡心状，其辣味足，因成形较好，在泡椒菜肴中常整个使用，很少加工成茸或切成小块。</li></ul><h2 id="食用油"><a href="#食用油" class="headerlink" title="食用油"></a>食用油</h2><h3 id="菜油-菜籽油"><a href="#菜油-菜籽油" class="headerlink" title="菜油(菜籽油)"></a>菜油(菜籽油)</h3><p>用油菜籽榨出来的一种食用油，有一种“青气味”。菜籽油具有一定的软化血管、延缓衰老的功效。常<strong>用于炒菜，也可以做红油辣椒。不适合凉拌菜。</strong></p><h3 id="花生油"><a href="#花生油" class="headerlink" title="花生油"></a>花生油</h3><p>淡黄透明，气味芬芳，滋味可口，是一种比较容易消化的食用油。花生油的脂肪酸构成是比较好的，易于人体消化和吸收。常用于炒菜，<strong>炒蔬菜最好，比较香。</strong> </p><h3 id="葵花籽油"><a href="#葵花籽油" class="headerlink" title="葵花籽油"></a>葵花籽油</h3><p>营养价值丰富，含有丰富的胡萝卜素。不适合油炸，常用于<strong>做汤、炒菜、凉拌。</strong></p><h3 id="玉米油"><a href="#玉米油" class="headerlink" title="玉米油"></a>玉米油</h3><p>优质玉米油营养含量丰富。也常用于炒菜，清淡不油腻也可增加香味。</p><h3 id="大豆油"><a href="#大豆油" class="headerlink" title="大豆油"></a>大豆油</h3><p>通常我们称之为“大豆色拉油”，是最常用的烹调油之一。做面点，但不适合炒菜。</p><h3 id="橄榄油"><a href="#橄榄油" class="headerlink" title="橄榄油"></a>橄榄油</h3><p>非常营养健康的油。炒菜时油烟很少，但高温易破坏营养，所以要想营养最大化还是凉拌菜比较好，但是缺点是炒菜炒起来没那么“香”。</p><h3 id="猪油"><a href="#猪油" class="headerlink" title="猪油"></a>猪油</h3><p>也称为荤油或猪大油。它是从猪的脂肪中提炼出，初始状态是略黄色半透明液体的食用油，常温下为白色或浅黄色固体，加热后会融化。<strong>猪油含胆固醇较多，对身体不利，建议少吃。</strong>但是炒菜做菜时能增香、添味。另外，由于常温时是固体，故不适合做凉拌食物。</p><h3 id="芝麻油"><a href="#芝麻油" class="headerlink" title="芝麻油"></a>芝麻油</h3><p>具有特别的香味，所以也叫香油。凉拌菜、汤类及热菜首选，可以<strong>增香提味。</strong></p><h3 id="牛油"><a href="#牛油" class="headerlink" title="牛油"></a>牛油</h3><p>从牛的脂肪组织里提炼出来的油脂，常温时也呈固体。风味浓郁，是做麻辣火锅底料必备调料。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们学习一门新的编程语言时，你需要设置好编程环境，然后打印出&lt;code&gt;Hello World&lt;/code&gt;，接下来就可以学习各种语法规则了。与编程一样，搬进出租屋后，我也很快配置好了各种厨具和基本的柴米油盐，具备了条件一道最简单饭菜的条件。但是，学习编程并不仅仅只是为了打印&lt;code&gt;Hello World&lt;/code&gt;，你还需要学习各种语法规则，编程技巧，甚至一些「语法糖」，让你的编程更加自然流畅。对于下厨而言，我们的菜谱就像语法规则，而那些调味料就是我们的语法糖。用好调料可以为我们制作出酸甜麻辣咸等各种美味的口感，还可以为饭菜增色增香。本期是「吃顿好的」第一篇，用于介绍生活中常见的各种调料的功能与用法，内容转自「美食作家王刚」。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_condiment.jpg" type="image" />
    
    
      <category term="吃顿好的" scheme="http://houmin.cc/categories/%E5%90%83%E9%A1%BF%E5%A5%BD%E7%9A%84/"/>
    
    
      <category term="下厨房" scheme="http://houmin.cc/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Scheduler</title>
    <link href="http://houmin.cc/posts/d3e0e7a2/"/>
    <id>http://houmin.cc/posts/d3e0e7a2/</id>
    <published>2020-07-13T12:46:33.000Z</published>
    <updated>2020-08-04T06:41:06.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>调度器（Scheduler）是 Kubernetes 的核心组件，它的主要功能是为待运行的工作负载 Pod 绑定运行的节点 Node。从最早基于谓词和优先级（Predicates and Priorities）的调度器，到 V1.15基于调度框架（Scheduling Framework）的调度器，Kubernetes的调度器正在快速演进，以满足不同场景对于资源调度的需求。</p><p>本文是「Kubernetes解读」的第二篇，本篇将首先介绍Kubernetes Scheduler的背景和它的演进过程，然后会通过 Kubernetes 1.16 版本分析基于谓词与优先级的调度器原理。在「Kubernetes解读」的第三篇 <a href="../83a17de0/">Scheduling Framework</a> 中，我将通过 Kubernetes 1.18 版本分析基于Framwork的调度器原理。</p><a id="more"></a><h2 id="Scheduler-概述"><a href="#Scheduler-概述" class="headerlink" title="Scheduler 概述"></a>Scheduler 概述</h2><h3 id="关于任务资源调度"><a href="#关于任务资源调度" class="headerlink" title="关于任务资源调度"></a>关于任务资源调度</h3><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computing" target="_blank" rel="external nofollow noopener noreferrer">computing</a>, <strong>scheduling</strong> is the method by which work is assigned to resources that complete the work.</p></blockquote><p>在计算机中，调度指的是为任务（Work）分配它所需要的资源（Resource），从而使得完成任务的方法。这里的任务可能是计算的线程，进程或者是数据流，与此同时，对应的资源可能是CPU、网络、内存或者是扩展卡等硬件资源。在计算机中，调度系统无处不在，不论是操作系统级别的调度器，还是编程语言级别的调度器，或者是CDN的资源调度，打车平台订单的调度等等。</p><p><strong>调度的核心就是对有限资源的合理分配，以达到我们期待实现的调度目标，本质上是解决资源的需求与供给不平衡的问题。</strong></p><p>一个调度系统可能会有多种调度目标，比如：</p><ul><li>最大化吞吐量</li><li>最小化等待时间</li><li>最小化延时或者响应时间</li><li>最大化公平</li></ul><p>在实践中，这些指标往往是互相矛盾的，因此调度器的设计往往是根据实际需求的权衡利弊的折中方案。在操作系统的进程调度器中，待调度的任务就是线程，而需要给任务分配的资源就是CPU时间。对于Kubernetes来说，它调度的基本单位是Pod，这些Pod会被调度到不同的Node上执行。不同的节点上资源类型不同，包括CPU、GPU和内存等资源。这些资源可以被拆分，但是都属于当前节点。</p><h3 id="任务资源调度设计的挑战"><a href="#任务资源调度设计的挑战" class="headerlink" title="任务资源调度设计的挑战"></a>任务资源调度设计的挑战</h3><ul><li>调度：任务最少等待时间与优先级</li><li>调度： 任务的本地性：尽可能将任务分配到包含任务执行资源的节点上</li><li>集群：高可用性</li><li>系统：可扩展性：系统如何如何应对业务需求的变化，提供的一种可扩展机制，在集群默认调度策略不满足业务需求时，通过扩展接口，来进行系统的扩展满足业务需求</li></ul><h3 id="Pod调度场景的挑战"><a href="#Pod调度场景的挑战" class="headerlink" title="Pod调度场景的挑战"></a>Pod调度场景的挑战</h3><h4 id="亲和性与反亲和性"><a href="#亲和性与反亲和性" class="headerlink" title="亲和性与反亲和性"></a>亲和性与反亲和性</h4><p>在kubernetes中的亲和性主要是指Pod和Node两种资源</p><ul><li>亲和性：<ul><li>Pod和Pod之间的亲和性</li><li>Pod和Node之间的亲和性</li></ul></li><li>反亲和性<ul><li>Pod和Pod之间的反亲和性</li><li>Pod和Node之间的反亲和性</li></ul></li></ul><p>举个例子：</p><ul><li>Pod之间的反亲和: 为了保证高可用我们通常会将同一业务的多个节点分散在不通的数据中心和机架</li><li>Pod与Node亲和性: 比如某些需要磁盘IO操作的Pod，我们可以调度到具有SSD的机器上，提高IO性能</li></ul><h4 id="多租户与容量规划"><a href="#多租户与容量规划" class="headerlink" title="多租户与容量规划"></a>多租户与容量规划</h4><p>多租户通常是为了进行集群资源的隔离，在业务系统中，通常会按照业务线来进行资源的隔离，同时会给业务设定对应的容量，从而避免单个业务线资源的过度使用影响整个公司的所有业务</p><h4 id="Zone和Node的选择"><a href="#Zone和Node的选择" class="headerlink" title="Zone和Node的选择"></a>Zone和Node的选择</h4><p>zone通常是在业务容灾中常见的概念，通过将服务分散在多个数据中心，避免因为单个数据中心故障导致业务完全不可用</p><p>因为之前亲和性的问题，如何在多个zone中的所有node中选择出一个合适的节点，则是一个比较大的挑战</p><h4 id="多样化资源的扩展"><a href="#多样化资源的扩展" class="headerlink" title="多样化资源的扩展"></a>多样化资源的扩展</h4><p>系统资源除了cpu、内存还包括网络、磁盘io、gpu等等，针对其余资源的分配调度，kubernetes还需要提供额外的扩展机制来进行调度扩展的支持</p><h4 id="资源混部"><a href="#资源混部" class="headerlink" title="资源混部"></a>资源混部</h4><p>kubernetes初期是针对pod调度场景而生，主要其实是在线web业务，这类任务的特点大部分都是无状态的，那如何针对离线场景的去支持离线的批处理计算等任务</p><h3 id="Kubernetes-Pod-LifeCycle"><a href="#Kubernetes-Pod-LifeCycle" class="headerlink" title="Kubernetes Pod LifeCycle"></a>Kubernetes Pod LifeCycle</h3><p>下图展示了一个Pod在Kubernetes集群中从创建到运行的过程：</p><ul><li>用户通过REST API 向ApiServer 创建 Deployment/DaemonSet/Job等任务</li><li>ApiServer收到用户请求后，存储相关数据到Etcd</li><li>Scheduler通过监听ApiServer，获取未调度的 Pod 列表</li><li>Scheduler通过调度算法算出分配给Pod的Node，并将Node信息和Pod进行绑定，结果存储在Etcd</li><li>Node上的Kubelet感知到调度结果，拉取镜像并运行Pod</li></ul><p><img alt="Kubernetes Pod LifeCycle" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-27_k8s-scheduler.png"></p><p>可以看到，Scheduler作为Kubernetes集群中核心模块，可以被视作一个黑盒：</p><ul><li>黑盒的输入为待调度的 Pod 和全部计算节点（Node）的信息</li><li>黑盒的输出为经过内部调度算法和策略处理算出的最优节点</li></ul><h3 id="Scheduler-基本职责"><a href="#Scheduler-基本职责" class="headerlink" title="Scheduler 基本职责"></a>Scheduler 基本职责</h3><p><code>kube-scheduler</code> 是作为单独的进程启动的，可以总结 <code>kube-scheduler</code> 的职责有以下这些：</p><ol><li><strong>Schduler高可用</strong>：基于Etcd实现分布式锁的竞争，实现高可用</li><li><strong>调度资源监听</strong>：基于List/Watch机制监听ApiServer上资源的变化，这里的资源主要指的是 Pod 和 Node ；</li><li><strong>调度节点分配</strong>：通过内部算法算出最优节点，并将结果写入Etcd</li></ol><h3 id="Scheduler-演进"><a href="#Scheduler-演进" class="headerlink" title="Scheduler 演进"></a>Scheduler 演进</h3><p>从Kubernetes v1.0发布开始，Scheduler就采用了基于谓词和优先级的算法进行调度，在完全切换到Scheduling Framework之前，分别在</p><ul><li>v1.2 引入了Scheduler Extender，支持外部扩展</li><li>v1.5 为调度器的优先级算法引入Map/Reduce的计算模式</li><li>v1.15 提出了基于Scheduling Framework的方式，实现Scheduler的轻量化、接口化与组件化</li><li>v1.18 将所有策略全部组件化，默认调度流程切换为Scheduling Framework</li><li>v1.19 将抢占过程也组件化，同时支持multi scheduling profile</li></ul><p><img alt="Scheduler Evolution Timeline" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-30_scheduler-timeline.png"></p><p>随着容器化技术普及，Kubernetes已经成为容器管理领域的事实标准，除了传统的互联网场景的应用，像AI、大数据、边缘计算等场景也开始迁移到 k8s 平台。与此同时，不同场景对于k8s调度器提出的要求也越来越高，k8s调度器正在快速演进中。</p><p>在本篇后续的分析中，将基于Kubernetes 1.16版本对其设计实现的原理和思路进行分析。</p><h2 id="Scheduler-初始化"><a href="#Scheduler-初始化" class="headerlink" title="Scheduler 初始化"></a>Scheduler 初始化</h2><h3 id="调度器结构体初识"><a href="#调度器结构体初识" class="headerlink" title="调度器结构体初识"></a>调度器结构体初识</h3><p>首先看一下调度器这个结构体的实现，其中比较关键的成员是 <code>SchedulerCache</code>、    <code>SchedulingQueue</code> 和 <code>Algorithm</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">  SchedulerCache internalcache.Cache</span><br><span class="line">  Algorithm core.ScheduleAlgorithm</span><br><span class="line">  GetBinder <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span> <span class="title">factory</span>.<span class="title">Binder</span></span></span><br><span class="line">  PodConditionUpdater factory.PodConditionUpdater</span><br><span class="line">  PodPreemptor factory.PodPreemptor</span><br><span class="line">  Framework framework.Framework</span><br><span class="line">  NextPod <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span></span><br><span class="line">  WaitForCacheSync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">  Error <span class="function"><span class="keyword">func</span><span class="params">(*v1.Pod, error)</span></span></span><br><span class="line">  Recorder events.EventRecorder</span><br><span class="line">  StopEverything &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  VolumeBinder *volumebinder.VolumeBinder</span><br><span class="line">  DisablePreemption <span class="keyword">bool</span></span><br><span class="line">  SchedulingQueue internalqueue.SchedulingQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了几个标准动作的函数</p><ul><li>NextPod()：当有下一个可用的Pod的时候，返回对应Pod，否则阻塞。</li><li>WaitForCache()：用于等待Cache同步。</li><li>Error()：当调度出现错误的时候，会调用Error函数，其参数是错误的Pod和错误。</li></ul><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">SchedulerCache:      c.schedulerCache,</span><br><span class="line">Algorithm:           algo,</span><br><span class="line">GetBinder:           getBinderFunc(c.client, extenders),</span><br><span class="line">PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">Framework:           c.framework,</span><br><span class="line">WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">&#125;,</span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(c.podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, c.podQueue, c.schedulerCache, c.StopEverything),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">VolumeBinder:    c.volumeBinder,</span><br><span class="line">SchedulingQueue: c.podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在创建 scheduler Config的时候，会依次对这几个函数定义</p><ul><li>NextPod()：调用SchedulingQueue的<code>MakeNextPodFunc</code>来获取下一个可调用Pod，本质上是调用Queue的Pop方法。</li><li>WaitForCache()：调用SchedulerCache的<code>WaitForCacheSync</code>来等待Cache同步</li><li>Error()：调用 <code>MakeDefaultErrorFunc</code>函数注入一个失败处理函数，主要讲失败的Pod放入到合适的队列重新再调度</li></ul><p>除了这几个主要函数外，还为<code>Scheduler</code>结构定义了几个动作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">schedule</span><span class="params">(pod *v1.Pod, pluginContext *framework.PluginContext)</span> <span class="params">(core.ScheduleResult, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">preempt</span><span class="params">(pluginContext *framework.PluginContext, fwk framework.Framework, preemptor *v1.Pod, scheduleErr error)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assumeVolumes</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="params">(allBound <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bindVolumes</span><span class="params">(assumed *v1.Pod)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">assume</span><span class="params">(assumed *v1.Pod, host <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">bind</span><span class="params">(assumed *v1.Pod, targetNode <span class="keyword">string</span>, pluginContext *framework.PluginContext)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">recordSchedulingFailure</span><span class="params">(pod *v1.Pod, err error, reason <span class="keyword">string</span>, message <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>schedule()：输入是Pod，输出是调度结果，执行调度主要逻辑，通过 <code>genericScheduler</code>实现</li><li>preempt()：抢占调度，通过genericScheduler实现，并且更新 <code>Nominated</code></li><li>assumeVolumes()：根据选择的binding来更新Volume Cache</li><li>bindVolumes()：绑定PV</li><li>assume()：将Pod状态调整到Cache中，变为assumed</li><li>Bind()：执行绑定操作</li></ul><h3 id="调度器参数初始化"><a href="#调度器参数初始化" class="headerlink" title="调度器参数初始化"></a>调度器参数初始化</h3><p>我们在创建Scheduler结构体的时候会制定很多的参数：</p><figure class="highlight go"><figcaption><span>cmd/kube-scheduler/server.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the scheduler.</span></span><br><span class="line">sched, err := scheduler.New(cc.Client,</span><br><span class="line">cc.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">cc.PodInformer,</span><br><span class="line">cc.InformerFactory.Core().V1().PersistentVolumes(),</span><br><span class="line">cc.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">cc.InformerFactory.Core().V1().ReplicationControllers(),</span><br><span class="line">cc.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">cc.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">cc.InformerFactory.Core().V1().Services(),</span><br><span class="line">cc.InformerFactory.Policy().V1beta1().PodDisruptionBudgets(),</span><br><span class="line">cc.InformerFactory.Storage().V1().StorageClasses(),</span><br><span class="line">cc.InformerFactory.Storage().V1beta1().CSINodes(),</span><br><span class="line">cc.Recorder,</span><br><span class="line">cc.ComponentConfig.AlgorithmSource,</span><br><span class="line">stopCh,</span><br><span class="line">registry,</span><br><span class="line">cc.ComponentConfig.Plugins,</span><br><span class="line">cc.ComponentConfig.PluginConfig,</span><br><span class="line">scheduler.WithName(cc.ComponentConfig.SchedulerName),</span><br><span class="line">scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),</span><br><span class="line">scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),</span><br><span class="line">scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),</span><br><span class="line">scheduler.WithBindTimeoutSeconds(*cc.ComponentConfig.BindTimeoutSeconds))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>New</code>传递来自于cmd的参数，并且创建一个 <code>Configurator</code></p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns a Scheduler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(client clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">replicationControllerInformer coreinformers.ReplicationControllerInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">replicaSetInformer appsinformers.ReplicaSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">statefulSetInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pdbInformer policyinformers.PodDisruptionBudgetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">storageClassInformer storageinformersv1.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">csiNodeInformer storageinformersv1beta1.CSINodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">recorder events.EventRecorder,</span></span></span><br><span class="line"><span class="function"><span class="params">schedulerAlgorithmSource kubeschedulerconfig.SchedulerAlgorithmSource,</span></span></span><br><span class="line"><span class="function"><span class="params">stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">registry framework.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">plugins *kubeschedulerconfig.Plugins,</span></span></span><br><span class="line"><span class="function"><span class="params">pluginConfig []kubeschedulerconfig.PluginConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">         opts ...<span class="keyword">func</span>(o *schedulerOptions)</span>) <span class="params">(*Scheduler, error)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set up the configurator which can create schedulers from configs.</span></span><br><span class="line">configurator := factory.NewConfigFactory(&amp;factory.ConfigFactoryArgs&#123;</span><br><span class="line">Client:                         client,</span><br><span class="line">NodeInformer:                   nodeInformer,</span><br><span class="line">PodInformer:                    podInformer,</span><br><span class="line">PvInformer:                     pvInformer,</span><br><span class="line">PvcInformer:                    pvcInformer,</span><br><span class="line">ReplicationControllerInformer:  replicationControllerInformer,</span><br><span class="line">ReplicaSetInformer:             replicaSetInformer,</span><br><span class="line">StatefulSetInformer:            statefulSetInformer,</span><br><span class="line">ServiceInformer:                serviceInformer,</span><br><span class="line">PdbInformer:                    pdbInformer,</span><br><span class="line">StorageClassInformer:           storageClassInformer,</span><br><span class="line">CSINodeInformer:                csiNodeInformer,</span><br><span class="line">HardPodAffinitySymmetricWeight: options.hardPodAffinitySymmetricWeight,</span><br><span class="line">DisablePreemption:              options.disablePreemption,</span><br><span class="line">PercentageOfNodesToScore:       options.percentageOfNodesToScore,</span><br><span class="line">BindTimeoutSeconds:             options.bindTimeoutSeconds,</span><br><span class="line">Registry:                       registry,</span><br><span class="line">Plugins:                        plugins,</span><br><span class="line">PluginConfig:                   pluginConfig,</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> config *factory.Config</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据不同的schedulerAlgorithmSource创建不同的config</span></span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> source.Provider != <span class="literal">nil</span>:</span><br><span class="line">    config = configurator.CreateFromProvider(*source.Provider)</span><br><span class="line"><span class="keyword">case</span> source.Policy != <span class="literal">nil</span>:</span><br><span class="line">    config = configurator.CreateFromConfig(*policy)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create the scheduler.</span></span><br><span class="line">sched := NewFromConfig(config)</span><br><span class="line">  </span><br><span class="line">  AddAllEventHandlers(sched, options.schedulerName, nodeInformer, podInformer, pvInformer, pvcInformer, serviceInformer, storageClassInformer, csiNodeInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigFactoryArgs是哪里来的？来自于命令行参数解析出来的。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigFactoryArgs is a set arguments passed to NewConfigFactory.</span></span><br><span class="line"><span class="keyword">type</span> ConfigFactoryArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Client                         clientset.Interface</span><br><span class="line">NodeInformer                   coreinformers.NodeInformer</span><br><span class="line">PodInformer                    coreinformers.PodInformer</span><br><span class="line">PvInformer                     coreinformers.PersistentVolumeInformer</span><br><span class="line">PvcInformer                    coreinformers.PersistentVolumeClaimInformer</span><br><span class="line">ReplicationControllerInformer  coreinformers.ReplicationControllerInformer</span><br><span class="line">ReplicaSetInformer             appsinformers.ReplicaSetInformer</span><br><span class="line">StatefulSetInformer            appsinformers.StatefulSetInformer</span><br><span class="line">ServiceInformer                coreinformers.ServiceInformer</span><br><span class="line">PdbInformer                    policyinformers.PodDisruptionBudgetInformer</span><br><span class="line">StorageClassInformer           storageinformersv1.StorageClassInformer</span><br><span class="line">CSINodeInformer                storageinformersv1beta1.CSINodeInformer</span><br><span class="line">HardPodAffinitySymmetricWeight <span class="keyword">int32</span></span><br><span class="line">DisablePreemption              <span class="keyword">bool</span></span><br><span class="line">PercentageOfNodesToScore       <span class="keyword">int32</span></span><br><span class="line">BindTimeoutSeconds             <span class="keyword">int64</span></span><br><span class="line">StopCh                         &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Registry                       framework.Registry</span><br><span class="line">Plugins                        *config.Plugins</span><br><span class="line">PluginConfig                   []config.PluginConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 ConfigFactoryArgs 构建 Configurator对象，在这个 <code>NewConfigFactory</code>函数里</p><ul><li>创建新的framework对象</li><li>创建新的SchedulingQueue：podQueue</li><li>创建新的SchedulerCache对象</li><li>创建新的VolumeBinder</li><li>…</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewConfigFactory initializes the default implementation of a Configurator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfigFactory</span><span class="params">(args *ConfigFactoryArgs)</span> *<span class="title">Configurator</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>当收到StopEverything的信号时，关闭podQueue。</p><p><code>CreateFromConfig</code> 用于注册Predicate函数、注册Prioritize函数、生成Extender列表</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateFromConfig creates a scheduler from the configuration file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">CreateFromConfig</span><span class="params">(policy schedulerapi.Policy)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler from configuration: %v"</span>, policy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the policy configuration</span></span><br><span class="line"><span class="keyword">if</span> err := validation.ValidatePolicy(policy); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicateKeys := sets.NewString()</span><br><span class="line"><span class="keyword">if</span> policy.Predicates == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Using predicates from algorithm provider '%v'"</span>, DefaultProvider)</span><br><span class="line">provider, err := GetAlgorithmProvider(DefaultProvider)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">predicateKeys = provider.FitPredicateKeys</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, predicate := <span class="keyword">range</span> policy.Predicates &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering predicate: %s"</span>, predicate.Name)</span><br><span class="line">predicateKeys.Insert(RegisterCustomFitPredicate(predicate))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priorityKeys := sets.NewString()</span><br><span class="line"><span class="keyword">if</span> policy.Priorities == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Using priorities from algorithm provider '%v'"</span>, DefaultProvider)</span><br><span class="line">provider, err := GetAlgorithmProvider(DefaultProvider)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">priorityKeys = provider.PriorityFunctionKeys</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, priority := <span class="keyword">range</span> policy.Priorities &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering priority: %s"</span>, priority.Name)</span><br><span class="line">priorityKeys.Insert(RegisterCustomPriorityFunction(priority))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> extenders []algorithm.SchedulerExtender</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(policy.ExtenderConfigs) != <span class="number">0</span> &#123;</span><br><span class="line">ignoredExtendedResources := sets.NewString()</span><br><span class="line"><span class="keyword">var</span> ignorableExtenders []algorithm.SchedulerExtender</span><br><span class="line"><span class="keyword">for</span> ii := <span class="keyword">range</span> policy.ExtenderConfigs &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating extender with config %+v"</span>, policy.ExtenderConfigs[ii])</span><br><span class="line">extender, err := core.NewHTTPExtender(&amp;policy.ExtenderConfigs[ii])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !extender.IsIgnorable() &#123;</span><br><span class="line">extenders = <span class="built_in">append</span>(extenders, extender)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ignorableExtenders = <span class="built_in">append</span>(ignorableExtenders, extender)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> policy.ExtenderConfigs[ii].ManagedResources &#123;</span><br><span class="line"><span class="keyword">if</span> r.IgnoredByScheduler &#123;</span><br><span class="line">ignoredExtendedResources.Insert(<span class="keyword">string</span>(r.Name))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// place ignorable extenders to the tail of extenders</span></span><br><span class="line">extenders = <span class="built_in">append</span>(extenders, ignorableExtenders...)</span><br><span class="line">predicates.RegisterPredicateMetadataProducerWithExtendedResourceOptions(ignoredExtendedResources)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Providing HardPodAffinitySymmetricWeight in the policy config is the new and preferred way of providing the value.</span></span><br><span class="line"><span class="comment">// Give it higher precedence than scheduler CLI configuration when it is provided.</span></span><br><span class="line"><span class="keyword">if</span> policy.HardPodAffinitySymmetricWeight != <span class="number">0</span> &#123;</span><br><span class="line">c.hardPodAffinitySymmetricWeight = policy.HardPodAffinitySymmetricWeight</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// When AlwaysCheckAllPredicates is set to true, scheduler checks all the configured</span></span><br><span class="line"><span class="comment">// predicates even after one or more of them fails.</span></span><br><span class="line"><span class="keyword">if</span> policy.AlwaysCheckAllPredicates &#123;</span><br><span class="line">c.alwaysCheckAllPredicates = policy.AlwaysCheckAllPredicates</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.CreateFromKeys(predicateKeys, priorityKeys, extenders)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CreateFromKeys</code> 基于刚才生成的<code>predicateKeys, priorityKeys, extenders</code> 得到PredicateFunc、PriorityFuncs，同时创建NewGenericScheduler，最后返回Config结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateFromKeys creates a scheduler from a set of registered fit predicate keys and priority keys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Configurator)</span> <span class="title">CreateFromKeys</span><span class="params">(predicateKeys, priorityKeys sets.String, extenders []algorithm.SchedulerExtender)</span> <span class="params">(*Config, error)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating scheduler with fit predicates '%v' and priority functions '%v'"</span>, predicateKeys, priorityKeys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.GetHardPodAffinitySymmetricWeight() &lt; <span class="number">1</span> || c.GetHardPodAffinitySymmetricWeight() &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid hardPodAffinitySymmetricWeight: %d, must be in the range 1-100"</span>, c.GetHardPodAffinitySymmetricWeight())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicateFuncs, err := c.GetPredicates(predicateKeys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priorityConfigs, err := c.getPriorityFunctionConfigs(priorityKeys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priorityMetaProducer, err := c.getPriorityMetadataProducer()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicateMetaProducer, err := c.GetPredicateMetadataProducer()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">algo := core.NewGenericScheduler(</span><br><span class="line">c.schedulerCache,</span><br><span class="line">c.podQueue,</span><br><span class="line">predicateFuncs,</span><br><span class="line">predicateMetaProducer,</span><br><span class="line">priorityConfigs,</span><br><span class="line">priorityMetaProducer,</span><br><span class="line">c.framework,</span><br><span class="line">extenders,</span><br><span class="line">c.volumeBinder,</span><br><span class="line">c.pVCLister,</span><br><span class="line">c.pdbLister,</span><br><span class="line">c.alwaysCheckAllPredicates,</span><br><span class="line">c.disablePreemption,</span><br><span class="line">c.percentageOfNodesToScore,</span><br><span class="line">c.enableNonPreempting,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">SchedulerCache:      c.schedulerCache,</span><br><span class="line">Algorithm:           algo,</span><br><span class="line">GetBinder:           getBinderFunc(c.client, extenders),</span><br><span class="line">PodConditionUpdater: &amp;podConditionUpdater&#123;c.client&#125;,</span><br><span class="line">PodPreemptor:        &amp;podPreemptor&#123;c.client&#125;,</span><br><span class="line">Framework:           c.framework,</span><br><span class="line">WaitForCacheSync: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cache.WaitForCacheSync(c.StopEverything, c.scheduledPodsHasSynced)</span><br><span class="line">&#125;,</span><br><span class="line">NextPod:         internalqueue.MakeNextPodFunc(c.podQueue),</span><br><span class="line">Error:           MakeDefaultErrorFunc(c.client, c.podQueue, c.schedulerCache, c.StopEverything),</span><br><span class="line">StopEverything:  c.StopEverything,</span><br><span class="line">VolumeBinder:    c.volumeBinder,</span><br><span class="line">SchedulingQueue: c.podQueue,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件Informer回调handler绑定"><a href="#事件Informer回调handler绑定" class="headerlink" title="事件Informer回调handler绑定"></a>事件Informer回调handler绑定</h3><p>在 <code>pkg/scheduler/eventhandler.go</code>中，会将 informer 监听到的资源变更事件与对应的 handler绑定，绑定事件回调主要是通过AddAllEventHandlers主要是将各种资源数据通过SchedulerCache放入本地缓存中，同时针对未调度的pod(!assignedPod即没有绑定Node的pod)加入到调度队列中。主要的事件包括</p><ul><li>Scheduled Pod Cache<ul><li>增加：addPodToCache</li><li>更新：updatePodInCache</li><li>删除：deletePodFromCache</li></ul></li><li>Unscheduled Pod Queue<ul><li>增加：addPodToSchedulingQueue</li><li>更新：updatePodInSchedulingQueue</li><li>删除：deletePodFromSchedulingQueue</li></ul></li><li>Node资源变更：<ul><li>增加：addNodeToCache</li><li>更新：updateNodeInCache</li><li>删除：deleteNodeInCache</li></ul></li><li>PV资源变更<ul><li>增加：onPvAdd</li><li>更新：onPvUpdate</li></ul></li><li>PVC资源变更<ul><li>增加：onPvcAdd</li><li>更新：onPvcUpdate</li></ul></li><li>Service资源变更：这个主要是会影响 <code>ServiceAffinity</code><ul><li>增加：onServiceAdd</li><li>更新：onServiceUpdate</li><li>删除：onServiceDelete</li></ul></li><li>StorageClass资源变更<ul><li>增加：onStorageClassAdd</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAllEventHandlers is a helper function used in tests and in Scheduler</span></span><br><span class="line"><span class="comment">// to add event handlers for various informers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAllEventHandlers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">sched *Scheduler,</span></span></span><br><span class="line"><span class="function"><span class="params">schedulerName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvInformer coreinformers.PersistentVolumeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">storageClassInformer storageinformersv1.StorageClassInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">csiNodeInformer storageinformersv1beta1.CSINodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>当集群资源发生变动时，比如service、volume等就会对unschedulableQ中的之前调度失败的pod进行重试，选择将其转移到activeQ或者backoffQ中，这时候会调用<code>MoveAllToActiveQueue</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// There is a chance of errors when adding pods to other queues,</span></span><br><span class="line"><span class="comment">// we make a temporary slice to store the pods,</span></span><br><span class="line"><span class="comment">// since the probability is low, we set its len to 0</span></span><br><span class="line">addErrorPods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">pod := pInfo.Pod</span><br><span class="line"><span class="keyword">if</span> p.isPodBackingOff(pod) &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the scheduling queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.unschedulableQ.clear()</span><br><span class="line"><span class="comment">// Adding pods that we could not move to Active queue or Backoff queue back to the Unschedulable queue</span></span><br><span class="line"><span class="keyword">for</span> _, podInfo := <span class="keyword">range</span> addErrorPods &#123;</span><br><span class="line">p.unschedulableQ.addOrUpdate(podInfo)</span><br><span class="line">&#125;</span><br><span class="line">p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h3><p>那么整个Scheduler是如何跑起来的呢？它的入口是Run函数，一直运行<code>scheduleOne</code>函数，进入一个 <code>control loop</code>，直到收到了StopEverything的信号。</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !sched.WaitForCacheSync() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(sched.scheduleOne, <span class="number">0</span>, sched.StopEverything)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SchedulingQueue-三级调度队列"><a href="#SchedulingQueue-三级调度队列" class="headerlink" title="SchedulingQueue 三级调度队列"></a>SchedulingQueue 三级调度队列</h2><p><code>SchedulingQueue</code> 是一个Interface，它提供了以下的方法实现对于Pod的入队出队操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SchedulingQueue <span class="keyword">interface</span> &#123;</span><br><span class="line">Add(pod *v1.Pod) error</span><br><span class="line">AddIfNotPresent(pod *v1.Pod) error</span><br><span class="line">AddUnschedulableIfNotPresent(pod *v1.Pod, podSchedulingCycle <span class="keyword">int64</span>) error</span><br><span class="line">SchedulingCycle() <span class="keyword">int64</span></span><br><span class="line">Pop() (*v1.Pod, error)</span><br><span class="line">Update(oldPod, newPod *v1.Pod) error</span><br><span class="line">Delete(pod *v1.Pod) error</span><br><span class="line">MoveAllToActiveQueue()</span><br><span class="line">AssignedPodAdded(pod *v1.Pod)</span><br><span class="line">AssignedPodUpdated(pod *v1.Pod)</span><br><span class="line">NominatedPodsForNode(nodeName <span class="keyword">string</span>) []*v1.Pod</span><br><span class="line">PendingPods() []*v1.Pod</span><br><span class="line">Close()</span><br><span class="line">UpdateNominatedPodForNode(pod *v1.Pod, nodeName <span class="keyword">string</span>)</span><br><span class="line">DeleteNominatedPodIfExists(pod *v1.Pod)</span><br><span class="line">NumUnschedulablePods() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是通过 <code>PriorityQueue</code> 来实现这个queue的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">stop  &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">clock util.Clock</span><br><span class="line">podBackoff *PodBackoffMap</span><br><span class="line"></span><br><span class="line">lock sync.RWMutex</span><br><span class="line">cond sync.Cond</span><br><span class="line"></span><br><span class="line">  activeQ *util.Heap</span><br><span class="line">podBackoffQ *util.Heap</span><br><span class="line">unschedulableQ *UnschedulablePodsMap</span><br><span class="line">nominatedPods *nominatedPodMap</span><br><span class="line">schedulingCycle <span class="keyword">int64</span></span><br><span class="line">moveRequestCycle <span class="keyword">int64</span></span><br><span class="line">closed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的优先级队列是一个三级调度队列，其主要包括：</p><ul><li>活动队列 activeQ：activeQ中存储当前系统中所有正在等待调度的Pod</li><li>不可调度队列 unschedulableQ：当Pod的资源在当前集群中不能被满足时，则会被加入到一个不可调度队列中，然后等待稍后再进行尝试</li><li>backoffQ 队列：backoff机制是并发编程中常见的一种机制，即如果任务反复执行依旧失败，则会按次增长等待调度时间，降低重试效率，从而避免反复失败浪费调度资源。针对调度失败的pod会优先存储在backoff队列中，等待后续重试。</li></ul><p>对于 <code>backoffQ</code> 和 <code>unschedulableQ</code>队列，我们需要定期从其中拿出Pod，放入到activeQ队列。</p><ul><li>每隔1秒执行 <code>flushBackoffQCompleted</code>，去找到backoffQ中等待到期的Pod，将其放入到activeQ中</li><li>每隔30秒执行 <code>flushUnschedulableQLeftover</code>，如果当前时间-pod的最后调度时间大于60s,就重新调度，转移到podBackoffQ或者activeQ中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(p.flushBackoffQCompleted, <span class="number">1.0</span>*time.Second, p.stop)</span><br><span class="line">    <span class="keyword">go</span> wait.Until(p.flushUnschedulableQLeftover, <span class="number">30</span>*time.Second, p.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="三级调度队列" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1578882056126-49b2a324-86dd-455e-b97b-bb9ba54fff5c.png"></p><h3 id="ActiveQ-队列"><a href="#ActiveQ-队列" class="headerlink" title="ActiveQ 队列"></a>ActiveQ 队列</h3><h4 id="当集群有新的Pod的时候"><a href="#当集群有新的Pod的时候" class="headerlink" title="当集群有新的Pod的时候"></a>当集群有新的Pod的时候</h4><p>什么时候会有新的Pod呢？也就是集群资源发生变更的时候：要么是创建了新的Pod，要么增加了PV，改变了Node等资源，导致原来不可调度的Pod可以调度了，这个时候会调用<code>SchedulingQueue.MoveAllToActiveQueue</code>（参见pkg/scheduler/eventhandler.go）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">MoveAllToActiveQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// There is a chance of errors when adding pods to other queues,</span></span><br><span class="line"><span class="comment">// we make a temporary slice to store the pods,</span></span><br><span class="line"><span class="comment">// since the probability is low, we set its len to 0</span></span><br><span class="line">addErrorPods := <span class="built_in">make</span>([]*framework.PodInfo, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">pod := pInfo.Pod</span><br><span class="line"><span class="keyword">if</span> p.isPodBackingOff(pod) &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error adding pod %v to the scheduling queue: %v"</span>, pod.Name, err)</span><br><span class="line">addErrorPods = <span class="built_in">append</span>(addErrorPods, pInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.unschedulableQ.clear()</span><br><span class="line"><span class="comment">// Adding pods that we could not move to Active queue or Backoff queue back to the Unschedulable queue</span></span><br><span class="line"><span class="keyword">for</span> _, podInfo := <span class="keyword">range</span> addErrorPods &#123;</span><br><span class="line">p.unschedulableQ.addOrUpdate(podInfo)</span><br><span class="line">&#125;</span><br><span class="line">p.moveRequestCycle = p.schedulingCycle</span><br><span class="line">p.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，会更新<code>moveRequestCycle</code>参数。</p><p>ActiveQ加入操作干了啥呢？</p><ul><li>会将Pod将入到activeQ，并且从backoffQ和 unschedulableQ中移除当前Pod</li><li>同时广播通知阻塞在Pop操作的scheduler获取新的Pod</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">Add</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line">    pInfo := p.newPodInfo(pod)</span><br><span class="line">    <span class="comment">// 加入activeQ</span></span><br><span class="line">    <span class="keyword">if</span> err := p.activeQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error adding pod %v/%v to the scheduling queue: %v"</span>, pod.Namespace, pod.Name, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从unschedulableQ删除</span></span><br><span class="line">    <span class="keyword">if</span> p.unschedulableQ.get(pod) != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error: pod %v/%v is already in the unschedulable queue."</span>, pod.Namespace, pod.Name)</span><br><span class="line">        p.unschedulableQ.<span class="built_in">delete</span>(pod)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delete pod from backoffQ if it is backing off</span></span><br><span class="line">    <span class="comment">// 从podBackoffQ删除</span></span><br><span class="line">    <span class="keyword">if</span> err := p.podBackoffQ.Delete(pInfo); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error: pod %v/%v is already in the podBackoff queue."</span>, pod.Namespace, pod.Name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储pod和被提名的node</span></span><br><span class="line">    p.nominatedPods.add(pod, <span class="string">""</span>)</span><br><span class="line">    p.cond.Broadcast()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当Pod调度失败时"><a href="#当Pod调度失败时" class="headerlink" title="当Pod调度失败时"></a>当Pod调度失败时</h4><p>当调度失败的时候，scheduler会同时调用<code>scheduler&#39;s.Error</code>来调度之前失败的Pod</p><figure class="highlight go"><figcaption><span>pkg/scheduler/scheduler.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sched *Scheduler)</span> <span class="title">recordSchedulingFailure</span><span class="params">(pod *v1.Pod, err error, reason <span class="keyword">string</span>, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 错误回调</span></span><br><span class="line">    sched.Error(pod, err)</span><br><span class="line">    sched.Recorder.Eventf(pod, <span class="literal">nil</span>, v1.EventTypeWarning, <span class="string">"FailedScheduling"</span>, <span class="string">"Scheduling"</span>, message)</span><br><span class="line">    <span class="keyword">if</span> err := sched.PodConditionUpdater.Update(pod, &amp;v1.PodCondition&#123;</span><br><span class="line">        Type:    v1.PodScheduled,</span><br><span class="line">        Status:  v1.ConditionFalse,</span><br><span class="line">        Reason:  reason,</span><br><span class="line">        Message: err.Error(),</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Error updating the condition of the pod %s/%s: %v"</span>, pod.Namespace, pod.Name, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个错误处理函数到底干了啥呢？</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/factory.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, err error)</span></span> &#123;</span><br><span class="line">    podSchedulingCycle := podQueue.SchedulingCycle()</span><br><span class="line">    <span class="comment">// 省略非核心代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.NodeName) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//重新放回队列</span></span><br><span class="line">        <span class="keyword">if</span> err := podQueue.AddUnschedulableIfNotPresent(pod, podSchedulingCycle); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个Pod调度失败，一种选择是放入到 <code>backoffQ</code>中，另一种选择是放入到 <code>unschedulableQ</code> 中，到底如何选择呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">AddUnschedulableIfNotPresent</span><span class="params">(pod *v1.Pod, podSchedulingCycle <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Every unschedulable pod is subject to backoff timers.</span></span><br><span class="line">p.backoffPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a move request has been received, move it to the BackoffQ, otherwise move</span></span><br><span class="line"><span class="comment">// it to unschedulableQ.</span></span><br><span class="line"><span class="keyword">if</span> p.moveRequestCycle &gt;= podSchedulingCycle &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.podBackoffQ.Add(pInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error adding pod %v to the backoff queue: %v"</span>, pod.Name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.unschedulableQ.addOrUpdate(pInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.nominatedPods.add(pod, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，当一个Pod不能够被调度的时候，它会被放到 unschedulableQ 中，但是如果收到了一个<code>Move Request</code>，那么就将这个Pod移到BackoffQ。这是因为最近集群资源发生了变更，如果放到 BackoffQ，会更快的进行尝试这个Pod，更快地使它得到调度。</p><h3 id="BackoffQ-队列"><a href="#BackoffQ-队列" class="headerlink" title="BackoffQ 队列"></a>BackoffQ 队列</h3><p>BackoffQ是一个堆，每次获取堆顶的元素，查看是否到期，如果到期则将其Pop出来，加入到activeQ中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">flushBackoffQCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 获取堆顶元素</span></span><br><span class="line">        rawPodInfo := p.podBackoffQ.Peek()</span><br><span class="line">        <span class="keyword">if</span> rawPodInfo == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        pod := rawPodInfo.(*framework.PodInfo).Pod</span><br><span class="line">        <span class="comment">// 获取到期时间</span></span><br><span class="line">        boTime, found := p.podBackoff.GetBackoffTime(nsNameForPod(pod))</span><br><span class="line">        <span class="keyword">if</span> !found &#123;</span><br><span class="line">            <span class="comment">// 如果当前已经不在podBackoff中，则就pop出来然后放入到activeQ</span></span><br><span class="line">            klog.Errorf(<span class="string">"Unable to find backoff value for pod %v in backoffQ"</span>, nsNameForPod(pod))</span><br><span class="line">            p.podBackoffQ.Pop()</span><br><span class="line">            p.activeQ.Add(rawPodInfo)</span><br><span class="line">            <span class="keyword">defer</span> p.cond.Broadcast()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未超时</span></span><br><span class="line">        <span class="keyword">if</span> boTime.After(p.clock.Now()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超时就pop出来</span></span><br><span class="line">        _, err := p.podBackoffQ.Pop()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(<span class="string">"Unable to pop pod %v from backoffQ despite backoff completion."</span>, nsNameForPod(pod))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入到activeQ中</span></span><br><span class="line">        p.activeQ.Add(rawPodInfo)</span><br><span class="line">        <span class="keyword">defer</span> p.cond.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnschedulableQ-队列"><a href="#UnschedulableQ-队列" class="headerlink" title="UnschedulableQ 队列"></a>UnschedulableQ 队列</h3><p>如果当前时间-pod的最后调度时间大于60s，就重新调度，转移到podBackoffQ或者activeQ中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PriorityQueue)</span> <span class="title">flushUnschedulableQLeftover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> podsToMove []*framework.PodInfo</span><br><span class="line">    currentTime := p.clock.Now()</span><br><span class="line">    <span class="keyword">for</span> _, pInfo := <span class="keyword">range</span> p.unschedulableQ.podInfoMap &#123;</span><br><span class="line">        lastScheduleTime := pInfo.Timestamp</span><br><span class="line">        <span class="comment">// 如果该pod1分钟内没有被调度就加入到podsToMove</span></span><br><span class="line">        <span class="keyword">if</span> currentTime.Sub(lastScheduleTime) &gt; unschedulableQTimeInterval &#123;</span><br><span class="line">            podsToMove = <span class="built_in">append</span>(podsToMove, pInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(podsToMove) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// podsToMove将这些pod移动到activeQ</span></span><br><span class="line">        p.movePodsToActiveQueue(podsToMove)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NominatedPodMap"><a href="#NominatedPodMap" class="headerlink" title="NominatedPodMap"></a>NominatedPodMap</h3><p>优先级队列有一个<code>nominatedPods</code>用来保存那些被提议运行在特定Nodes上的Pods，其数据结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nominatedPodMap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// nominatedPods is a map keyed by a node name and the value is a list of</span></span><br><span class="line"><span class="comment">// pods which are nominated to run on the node. These are pods which can be in</span></span><br><span class="line"><span class="comment">// the activeQ or unschedulableQ.</span></span><br><span class="line">nominatedPods <span class="keyword">map</span>[<span class="keyword">string</span>][]*v1.Pod</span><br><span class="line"><span class="comment">// nominatedPodToNode is map keyed by a Pod UID to the node name where it is</span></span><br><span class="line"><span class="comment">// nominated.</span></span><br><span class="line">nominatedPodToNode <span class="keyword">map</span>[ktypes.UID]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NextPod"><a href="#NextPod" class="headerlink" title="NextPod()"></a>NextPod()</h3><p>获取下一个Pod的方法，本质上是一个出队操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeNextPodFunc returns a function to retrieve the next pod from a given</span></span><br><span class="line"><span class="comment">// scheduling queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeNextPodFunc</span><span class="params">(queue SchedulingQueue)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">pod, err := queue.Pop()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"About to try and schedule pod %v/%v"</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">return</span> pod</span><br><span class="line">&#125;</span><br><span class="line">klog.Errorf(<span class="string">"Error while retrieving next pod from scheduling queue: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="Scheduler-Cache"><a href="#Scheduler-Cache" class="headerlink" title="Scheduler Cache"></a>Scheduler Cache</h2><p>为什么需要 Scheduler Cache ? 这里的Cache主要用来收集Pod和Node级别的信息，便于Generic Scheduler在调度时高效的查询。</p><blockquote><p>Cache collects pods’ information and provides node-level aggregated information.</p><p>It’s intended for <strong>generic scheduler</strong> to do efficient lookup.</p></blockquote><p>下面是 <code>schedulerCache</code>结构体的详细定义，关于每个字段的具体含义，将在后面具体阐述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedulerCache <span class="keyword">struct</span> &#123;</span><br><span class="line">stop   &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">ttl    time.Duration</span><br><span class="line">period time.Duration</span><br><span class="line"></span><br><span class="line">mu sync.RWMutex</span><br><span class="line">assumedPods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">podStates <span class="keyword">map</span>[<span class="keyword">string</span>]*podState</span><br><span class="line">nodes     <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeInfoListItem</span><br><span class="line">csiNodes  <span class="keyword">map</span>[<span class="keyword">string</span>]*storagev1beta1.CSINode</span><br><span class="line">headNode *nodeInfoListItem</span><br><span class="line">nodeTree *NodeTree</span><br><span class="line">imageStates <span class="keyword">map</span>[<span class="keyword">string</span>]*imageState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pod-状态"><a href="#Pod-状态" class="headerlink" title="Pod 状态"></a>Pod 状态</h3><p>Cache的操作都是以Pod为中心的，对于每次Pod Events，Cache会做递增式update，下面是Cache的状态机。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> State Machine of a pod's events in scheduler's cache</span><br><span class="line"><span class="string">//</span>   +<span class="params">-------------------------------------------</span>+  +<span class="params">----</span>+</span><br><span class="line"><span class="string">//</span>   |                            Add            |  |    |</span><br><span class="line"><span class="string">//</span>   |                                           |  |    | Update</span><br><span class="line"><span class="string">//</span>   +      Assume                Add            v  v    |</span><br><span class="line"><span class="string">//Initial</span> +<span class="params">--------</span>&gt; Assumed +<span class="params">------------</span>+<span class="params">---</span>&gt; Added &lt;--+</span><br><span class="line"><span class="string">//</span>   ^                +   +               |       +</span><br><span class="line"><span class="string">//</span>   |                |   |               |       |</span><br><span class="line"><span class="string">//</span>   |                |   |           Add |       | Remove</span><br><span class="line"><span class="string">//</span>   |                |   |               |       |</span><br><span class="line"><span class="string">//</span>   |                |   |               +       |</span><br><span class="line"><span class="string">//</span>   +<span class="params">----------------</span>+   +<span class="params">-----------</span>&gt; Expired   +<span class="params">----</span>&gt; Deleted</span><br><span class="line"><span class="string">//</span>         Forget             Expire</span><br></pre></td></tr></table></figure><p>这里有几个Event需要解释</p><ul><li>Assume：assumes a pod scheduled and aggregates the pod’s information into its node</li><li>Forget：removes an assumed pod from cache</li><li>Expire：After expiration, its information would be subtracted</li><li>Add：either confirms a pod if it’s assumed, or adds it back if it’s expired</li><li>Update：removes oldPod’s information and adds newPod’s information</li><li>Remove：removes a pod. The pod’s information would be subtracted from assigned node.</li></ul><p>与此同时还对应有Pod的几种状态，其中 <code>Initial</code>、<code>Expired</code>、<code>Deleted</code>这三种状态的Pod在Cache中实际上是不存在的，这里只是为了状态机的表示方便。关于这几个状态的改变，有一个具体的实现结构体，主要是通过 <code>podState</code> 和 <code>assumedPods</code> 这两个map的状态来实现的。</p><p><img alt="Scheduler Pod Cache State Machine" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_k8s-scheduler-cache.jpg"></p><p>在Cache的调度过程中，我们有以下几个假设</p><ul><li>Pod是不会被Assume两次的</li><li>一个Pod可能会直接被Add而不经过scheduler，这种情况下，我们只会看见Add Event而不会看见Assume Event</li><li>如果一个Pod没有被Add过，那么他不会被Remove或者Update</li><li><code>Expired</code>和<code>Deleted</code>都是有效的最终状态。</li></ul><h3 id="Node-状态"><a href="#Node-状态" class="headerlink" title="Node 状态"></a>Node 状态</h3><p>在Cache中，Node通过双向链表的形式保存信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeInfoListItem <span class="keyword">struct</span> &#123;</span><br><span class="line">info *schedulernodeinfo.NodeInfo</span><br><span class="line">next *nodeInfoListItem</span><br><span class="line">prev *nodeInfoListItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>NodeInfo</code>保存的信息如下所示，包含了和Node相关的一系列信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">node *v1.Node</span><br><span class="line"></span><br><span class="line">pods             []*v1.Pod</span><br><span class="line">podsWithAffinity []*v1.Pod</span><br><span class="line">usedPorts        HostPortInfo</span><br><span class="line"></span><br><span class="line">requestedResource *Resource</span><br><span class="line">nonzeroRequest *Resource</span><br><span class="line">allocatableResource *Resource</span><br><span class="line"></span><br><span class="line">taints    []v1.Taint</span><br><span class="line">taintsErr error</span><br><span class="line"></span><br><span class="line">imageStates <span class="keyword">map</span>[<span class="keyword">string</span>]*ImageStateSummary</span><br><span class="line"></span><br><span class="line">TransientInfo *TransientSchedulerInfo</span><br><span class="line"></span><br><span class="line">memoryPressureCondition v1.ConditionStatus</span><br><span class="line">diskPressureCondition   v1.ConditionStatus</span><br><span class="line">pidPressureCondition    v1.ConditionStatus</span><br><span class="line"></span><br><span class="line">generation <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的 <code>schedulerCache</code> 中通过 <code>nodes</code> 这个 map 和 <code>headNode</code>这个指针可以很快的访问Node相关信息。</p><h4 id="NodeInfo-的更新"><a href="#NodeInfo-的更新" class="headerlink" title="NodeInfo 的更新"></a>NodeInfo 的更新</h4><p>当收到informer通知，知道集群Node信息发生改变时，会更新Cache中的Node信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nodeInformer.Informer().AddEventHandler(</span><br><span class="line">cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc:    sched.addNodeToCache,</span><br><span class="line">UpdateFunc: sched.updateNodeInCache,</span><br><span class="line">DeleteFunc: sched.deleteNodeFromCache,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里的<code>add</code>、<code>update</code>、<code>delete</code>会分别调用Cache的 <code>AddNode</code>、<code>UpdateNode</code>和 <code>RemoveNode</code>等函数。以 <code>AddNode</code>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">AddNode</span><span class="params">(node *v1.Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cache.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line"></span><br><span class="line">n, ok := cache.nodes[node.Name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">n = newNodeInfoListItem(schedulernodeinfo.NewNodeInfo())</span><br><span class="line">cache.nodes[node.Name] = n</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cache.removeNodeImageStates(n.info.Node())</span><br><span class="line">&#125;</span><br><span class="line">cache.moveNodeInfoToHead(node.Name)</span><br><span class="line"></span><br><span class="line">cache.nodeTree.AddNode(node)</span><br><span class="line">cache.addNodeImageStates(node, n.info)</span><br><span class="line"><span class="keyword">return</span> n.info.SetNode(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据需要可以创建新的 NodeInfo 结构体，并且插入到双向链表中。</li><li>每次更新Cache中的Node信息时，会将该Node移动到链表头。</li><li>同时会更新 <code>NodeTree</code> 和 <code>NodeImageStates</code>中的信息。</li></ul><h4 id="NodeTree-实现节点打散"><a href="#NodeTree-实现节点打散" class="headerlink" title="NodeTree 实现节点打散"></a>NodeTree 实现节点打散</h4><p>在Cache中还有一个<code>NodeTree</code>的指针用一个树形结构体保存Node的相关信息，目的是用于节点打散。节点打散主要是指的调度器调度的时候，在满足调度需求的情况下，为了保证pod均匀分配到所有的node节点上，通常会按照逐个zone逐个node节点进行分配，从而让pod节点打散在整个集群中。</p><p><code>NodeTree</code>的结构如下所示，NodeTree的tree是一个字典，key是zone的名字，value是一个nodeArray，通过这样可以把不同zone的Node分隔开。nodeArray负责存储一个zone下面的所有node节点，并且通过lastIndex记录当前zone分配的节点索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeTree <span class="keyword">struct</span> &#123;</span><br><span class="line">tree      <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeArray <span class="comment">// a map from zone (region-zone) to an array of nodes in the zone.</span></span><br><span class="line">zones     []<span class="keyword">string</span>              <span class="comment">// a list of all the zones in the tree (keys)</span></span><br><span class="line">zoneIndex <span class="keyword">int</span></span><br><span class="line">numNodes  <span class="keyword">int</span></span><br><span class="line">mu        sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeArray <span class="keyword">struct</span> &#123;</span><br><span class="line">nodes     []<span class="keyword">string</span></span><br><span class="line">lastIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把整个集群的Node看成二维数组，分别是<code>zoneIndex</code>和<code>nodeIndex</code></p><p><img alt="Scheduler Cache State Machine" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-13_node-tree.png"></p><p>每一次在 <code>findNodesThatFit</code> 函数中，通过调用 <code>nodeName := g.cache.NodeTree().Next()</code> 来获得下一个检查的Node，其具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nt *NodeTree)</span> <span class="title">Next</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">nt.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> nt.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nt.zones) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">numExhaustedZones := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nt.zoneIndex &gt;= <span class="built_in">len</span>(nt.zones) &#123;</span><br><span class="line">nt.zoneIndex = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">zone := nt.zones[nt.zoneIndex]</span><br><span class="line">nt.zoneIndex++</span><br><span class="line"><span class="comment">// We do not check the exhausted zones before calling next() on the zone. This ensures</span></span><br><span class="line"><span class="comment">// that if more nodes are added to a zone after it is exhausted, we iterate over the new nodes.</span></span><br><span class="line">nodeName, exhausted := nt.tree[zone].next()</span><br><span class="line"><span class="keyword">if</span> exhausted &#123;</span><br><span class="line">numExhaustedZones++</span><br><span class="line"><span class="keyword">if</span> numExhaustedZones &gt;= <span class="built_in">len</span>(nt.zones) &#123; <span class="comment">// all zones are exhausted. we should reset.</span></span><br><span class="line">nt.resetExhausted()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nodeName</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次先从当前 <code>zoneIndex</code> 获取新的zone，然后更新 <code>zoneIndex</code>。在对应zone的 <code>NodeArray</code>中，调用其 <code>next</code> 方法，获得对应的Node，同时更新 <code>nodeIndex</code>。</p><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>当scheduler获取一个待调度的pod，则需要从Cache中获取当前集群中的快照数据(当前此时集群中node的统计信息)，用于后续调度流程中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">NodeInfoMap <span class="keyword">map</span>[<span class="keyword">string</span>]*NodeInfo</span><br><span class="line">Generation  <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Snapshot的创建与更新"><a href="#Snapshot的创建与更新" class="headerlink" title="Snapshot的创建与更新"></a>Snapshot的创建与更新</h4><p>创建主要位于kubernetes/pkg/scheduler/core/generic_scheduler.go，实际上就是创建一个空的snapshot对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeInfoSnapshot:         framework.NodeInfoSnapshot(),</span><br></pre></td></tr></table></figure><p>数据的更新则是通过snapshot方法来调用Cache的更新接口来进行更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">snapshot</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Used for all fit and priority funcs.</span></span><br><span class="line">    <span class="keyword">return</span> g.cache.UpdateNodeInfoSnapshot(g.nodeInfoSnapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="借助headNode实现增量标记"><a href="#借助headNode实现增量标记" class="headerlink" title="借助headNode实现增量标记"></a>借助headNode实现增量标记</h4><p>随着集群中node和pod的数量的增加，如果每次都全量获取snapshot则会严重影响调度器的调度效率，在Cache中通过一个双向链表和node的递增计数(etcd实现)来实现增量更新。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">UpdateNodeInfoSnapshot</span><span class="params">(nodeSnapshot *schedulernodeinfo.Snapshot)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    cache.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line">    balancedVolumesEnabled := utilfeature.DefaultFeatureGate.Enabled(features.BalanceAttachedNodeVolumes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前snapshot的Genration</span></span><br><span class="line">    snapshotGeneration := nodeSnapshot.Generation</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表，更新snapshot信息</span></span><br><span class="line">    <span class="keyword">for</span> node := cache.headNode; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">        <span class="keyword">if</span> node.info.GetGeneration() &lt;= snapshotGeneration &#123;</span><br><span class="line">            <span class="comment">//所有node信息都更新完毕</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> balancedVolumesEnabled &amp;&amp; node.info.TransientInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Transient scheduler info is reset here.</span></span><br><span class="line">            node.info.TransientInfo.ResetTransientSchedulerInfo()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> np := node.info.Node(); np != <span class="literal">nil</span> &#123;</span><br><span class="line">            nodeSnapshot.NodeInfoMap[np.Name] = node.info.Clone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新snapshot的genration</span></span><br><span class="line">    <span class="keyword">if</span> cache.headNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        nodeSnapshot.Generation = cache.headNode.info.GetGeneration()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果snapshot里面包含过期的pod信息则进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodeSnapshot.NodeInfoMap) &gt; <span class="built_in">len</span>(cache.nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> name := <span class="keyword">range</span> nodeSnapshot.NodeInfoMap &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := cache.nodes[name]; !ok &#123;</span><br><span class="line">                <span class="built_in">delete</span>(nodeSnapshot.NodeInfoMap, name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据过期清理"><a href="#数据过期清理" class="headerlink" title="数据过期清理"></a>数据过期清理</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>Cache要定时将之前在经过本地scheduler分配完成后的假设的pod的信息进行清理，如果这些pod在给定时间内仍然没有感知到对应的pod真正的添加事件则就这些pod删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assumedPods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h4 id="后台定时任务"><a href="#后台定时任务" class="headerlink" title="后台定时任务"></a>后台定时任务</h4><p>默认每1s进行清理一次，设定的 <code>ttl</code> 默认是30s。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> wait.Until(cache.cleanupExpiredAssumedPods, cache.period, cache.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清理逻辑"><a href="#清理逻辑" class="headerlink" title="清理逻辑"></a>清理逻辑</h4><p>清理逻辑主要是针对那些已经完成绑定的pod来进行，如果一个pod完成了在scheduler里面的所有操作后，会有一个过期时间，当前是30s，如果超过该时间即deadline小于当前的时间就删除该pod。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cleanupAssumedPods exists for making test deterministic by taking time as input argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">cleanupAssumedPods</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line">    cache.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> cache.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The size of assumedPods should be small</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> cache.assumedPods &#123;</span><br><span class="line">        ps, ok := cache.podStates[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"Key found in assumed set but not in podStates. Potentially a logical error."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未完成绑定的pod不会被进行清理</span></span><br><span class="line">        <span class="keyword">if</span> !ps.bindingFinished &#123;</span><br><span class="line">            klog.V(<span class="number">3</span>).Infof(<span class="string">"Couldn't expire cache for pod %v/%v. Binding is still in progress."</span>,</span><br><span class="line">                ps.pod.Namespace, ps.pod.Name)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在完成bind之后会设定一个过期时间，目前是30s,如果deadline即bind时间+30s小于当前时间就过期删除</span></span><br><span class="line">        <span class="keyword">if</span> now.After(*ps.deadline) &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Pod %s/%s expired"</span>, ps.pod.Namespace, ps.pod.Name)</span><br><span class="line">            <span class="keyword">if</span> err := cache.expirePod(key, ps); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                klog.Errorf(<span class="string">"ExpirePod failed for %s: %v"</span>, key, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清理pod"><a href="#清理pod" class="headerlink" title="清理pod"></a>清理pod</h4><p>清理pod主要分为如下几个部分： </p><ol><li>对应pod假定分配node的信息 </li><li>清理映射的podState信息</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cache *schedulerCache)</span> <span class="title">expirePod</span><span class="params">(key <span class="keyword">string</span>, ps *podState)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := cache.removePod(ps.pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(cache.assumedPods, key)</span><br><span class="line">    <span class="built_in">delete</span>(cache.podStates, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Predicate-预选"><a href="#Predicate-预选" class="headerlink" title="Predicate 预选"></a>Predicate 预选</h2><p>调度器的目的就是将调度队列中的Pod合理地分配到具有匹配资源的Node上，在<code>Scheduling Framework</code>之前其算法步骤就是预选与优选。预选就是从当前集群中所有节点中，选择满足当前Pod资源和亲和性等要求Node节点，起的是过滤的作用。预选需要考虑的问题是，当集群中Node节点众多时，如何快速高效的过滤出这样的节点。</p><h3 id="Predicate-算法注册"><a href="#Predicate-算法注册" class="headerlink" title="Predicate 算法注册"></a>Predicate 算法注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Register functions that extract metadata used by predicates computations.</span></span><br><span class="line">factory.RegisterPredicateMetadataProducerFactory(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">PredicateMetadataProducer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewPredicateMetadataFactory(args.PodLister)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPORTANT NOTES for predicate developers:</span></span><br><span class="line"><span class="comment">// Registers predicates and priorities that are not enabled by default, but user can pick when creating their</span></span><br><span class="line"><span class="comment">// own set of priorities/predicates.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PodFitsPorts has been replaced by PodFitsHostPorts for better user understanding.</span></span><br><span class="line"><span class="comment">// For backwards compatibility with 1.0, PodFitsPorts is registered as well.</span></span><br><span class="line">factory.RegisterFitPredicate(<span class="string">"PodFitsPorts"</span>, predicates.PodFitsHostPorts)</span><br><span class="line"><span class="comment">// Fit is defined based on the absence of port conflicts.</span></span><br><span class="line"><span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line"><span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.PodFitsHostPortsPred, predicates.PodFitsHostPorts)</span><br><span class="line"><span class="comment">// Fit is determined by resource availability.</span></span><br><span class="line"><span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line"><span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.PodFitsResourcesPred, predicates.PodFitsResources)</span><br><span class="line"><span class="comment">// Fit is determined by the presence of the Host parameter and a string match</span></span><br><span class="line"><span class="comment">// This predicate is actually a default predicate, because it is invoked from</span></span><br><span class="line"><span class="comment">// predicates.GeneralPredicates()</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.HostNamePred, predicates.PodFitsHost)</span><br><span class="line"><span class="comment">// Fit is determined by node selector query.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.MatchNodeSelectorPred, predicates.PodMatchNodeSelector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by volume zone requirements.</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.NoVolumeZoneConflictPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewVolumeZonePredicate(args.PVInfo, args.PVCInfo, args.StorageClassInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Fit is determined by whether or not there would be too many AWS EBS volumes attached to the node</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxEBSVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.EBSVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Fit is determined by whether or not there would be too many GCE PD volumes attached to the node</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxGCEPDVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.GCEPDVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Fit is determined by whether or not there would be too many Azure Disk volumes attached to the node</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxAzureDiskVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.AzureDiskVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxCSIVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewCSIMaxVolumeLimitPredicate(args.CSINodeInfo, args.PVInfo, args.PVCInfo, args.StorageClassInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MaxCinderVolumeCountPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewMaxPDVolumeCountPredicate(predicates.CinderVolumeFilterType, args.CSINodeInfo, args.StorageClassInfo, args.PVInfo, args.PVCInfo)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by inter-pod affinity.</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.MatchInterPodAffinityPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewPodAffinityPredicate(args.NodeInfo, args.PodLister)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by non-conflicting disk volumes.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.NoDiskConflictPred, predicates.NoDiskConflict)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GeneralPredicates are the predicates that are enforced by all Kubernetes components</span></span><br><span class="line"><span class="comment">// (e.g. kubelet and all schedulers)</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.GeneralPred, predicates.GeneralPredicates)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node memory pressure condition.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.CheckNodeMemoryPressurePred, predicates.CheckNodeMemoryPressurePredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node disk pressure condition.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.CheckNodeDiskPressurePred, predicates.CheckNodeDiskPressurePredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node pid pressure condition.</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.CheckNodePIDPressurePred, predicates.CheckNodePIDPressurePredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by node conditions: not ready, network unavailable or out of disk.</span></span><br><span class="line">factory.RegisterMandatoryFitPredicate(predicates.CheckNodeConditionPred, predicates.CheckNodeConditionPredicate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined based on whether a pod can tolerate all of the node's taints</span></span><br><span class="line">factory.RegisterFitPredicate(predicates.PodToleratesNodeTaintsPred, predicates.PodToleratesNodeTaints)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit is determined by volume topology requirements.</span></span><br><span class="line">factory.RegisterFitPredicateFactory(</span><br><span class="line">predicates.CheckVolumeBindingPred,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">predicates</span>.<span class="title">FitPredicate</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> predicates.NewVolumeBindingPredicate(args.VolumeBinder)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部最优"><a href="#局部最优" class="headerlink" title="局部最优"></a>局部最优</h3><p>预选流程需要从当前集群中选择一台符合要求的node。随着集群规模的增长，如果每次遍历所有集群node则会必然导致性能的下降，于是通过局部最优解的方式，缩小筛选节点的数量。具体来说，<code>genericScheduler</code>定义了 <code>minFeasibleNodesToFind</code> 和 <code>minFeasibleNodesPercentageToFind</code>这两个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">minFeasibleNodesToFind = <span class="number">100</span></span><br><span class="line">minFeasibleNodesPercentageToFind = <span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>minFeasibleNodesToFind：定义了在调度阶段参与打分的最小节点数，默认为100。</li><li>minFeasibleNodesPercentageToFind：定义了在调度阶段参与打分的最小百分比，默认为5%。</li></ul><p>通过<code>numFeasibleNodesToFind</code> 函数，结合当前集群中的Node数量，和默认的最小值来决定本次预选阶段需要获取的node节点数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">numFeasibleNodesToFind</span><span class="params">(numAllNodes <span class="keyword">int32</span>)</span> <span class="params">(numNodes <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点数量小于minFeasibleNodesToFind即小于100台node</span></span><br><span class="line">    <span class="comment">// 同理百分比如果大于100就是全量取样</span></span><br><span class="line">    <span class="comment">// 这两种情况都直接遍历整个集群中所有节点</span></span><br><span class="line">    <span class="keyword">if</span> numAllNodes &lt; minFeasibleNodesToFind || g.percentageOfNodesToScore &gt;= <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numAllNodes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedulerapi.DefaultPercentageOfNodesToScore = 50</span></span><br><span class="line">    adaptivePercentage := g.percentageOfNodesToScore</span><br><span class="line">    <span class="keyword">if</span> adaptivePercentage &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        adaptivePercentage = schedulerapi.DefaultPercentageOfNodesToScore - numAllNodes/<span class="number">125</span></span><br><span class="line">        <span class="keyword">if</span> adaptivePercentage &lt; minFeasibleNodesPercentageToFind &#123;</span><br><span class="line">            adaptivePercentage = minFeasibleNodesPercentageToFind</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常取样计算：比如numAllNodes为5000，而adaptivePercentage为50%</span></span><br><span class="line">    <span class="comment">// 则numNodes=50000*0.5/100=250</span></span><br><span class="line">    numNodes = numAllNodes * adaptivePercentage / <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> numNodes &lt; minFeasibleNodesToFind &#123; <span class="comment">// 如果小于最少取样则按照最少取样进行取样</span></span><br><span class="line">        <span class="keyword">return</span> minFeasibleNodesToFind</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行加速"><a href="#并行加速" class="headerlink" title="并行加速"></a>并行加速</h3><p>在当前k8s版本中，默认会启动16个goroutine来进行并行的预选，从而提高预选的性能</p><p>并行取样主要通过调用下面的函数来启动16个goroutine来进行并行取样，并通过ctx来协调退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workqueue.ParallelizeUntil(ctx, <span class="number">16</span>, <span class="keyword">int</span>(allNodes), checkNode)</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="https://pic1.zhimg.com/80/v2-047108dba71d6806c7fed091c15080e8_1440w.jpg"></p><p>通过channel来构建取样索引的管道，每个worker会负责从channel获取的指定索引取样node的填充</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParallelizeUntil</span><span class="params">(ctx context.Context, workers, pieces <span class="keyword">int</span>, doWorkPiece DoWorkPieceFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> ctx != <span class="literal">nil</span> &#123;</span><br><span class="line">        stop = ctx.Done()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成指定数量索引，worker通过索引来进行预选成功节点的存储</span></span><br><span class="line">    toProcess := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, pieces)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pieces; i++ &#123;</span><br><span class="line">        toProcess &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(toProcess)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pieces &lt; workers &#123;</span><br><span class="line">        workers = pieces</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(workers)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">        <span class="comment">// 启动多个goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> piece := <span class="keyword">range</span> toProcess &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//获取索引，后续会通过该索引来进行结果的存储</span></span><br><span class="line">                    doWorkPiece(piece)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待退出</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体每个实际并发执行函数为，它通过在 <code>NodeTree</code> 获取下一个可用的Node，然后调用 <code>podFitsOnNode</code>来检查该Pod是否可以运行在对应的Node上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  nodeName := g.cache.NodeTree().Next()</span><br><span class="line"></span><br><span class="line">  fits, failedPredicates, status, err := g.podFitsOnNode(</span><br><span class="line">    pluginContext,</span><br><span class="line">    pod,</span><br><span class="line">    meta,</span><br><span class="line">    g.nodeInfoSnapshot.NodeInfoMap[nodeName],</span><br><span class="line">    g.predicates,</span><br><span class="line">    g.schedulingQueue,</span><br><span class="line">    g.alwaysCheckAllPredicates,</span><br><span class="line">  )</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两轮筛选"><a href="#两轮筛选" class="headerlink" title="两轮筛选"></a>两轮筛选</h3><p>为了检查一个Pod是否能够运行在给定的Node上，我们通过运行 <code>podFitsOnNode</code>来检查一系列的predicate函数。在这里我们会运行两轮筛选。</p><ul><li>面向未来调度的预选：<ul><li>如果在这个Node上有相同或者更高优先级的<code>Nominated Pods</code>，我们把这些pods加入到meta和nodeInfo中，然后运行predicate算法。之所以考虑更高优先级，是因为当前Pod抢占了低优先级Pod的资源是OK的，但是如果占有了更高优先级资源是不允许的。</li><li>如果在筛选的时候，没有<code>Nominated Pods</code>，或者第一轮筛选中没有通过，那么就不会运行第二轮筛选。</li></ul></li><li>面向当前资源的预选：<ul><li>在这一轮筛选中，如果通过了所有的算法，那么需要在这些pods不加入的情况下，再运行一轮筛选。</li></ul></li></ul><p>第二轮筛选必须存在的原因是，有些预选算法（比如Pod间的亲和性算法）在没有<code>Nominated Pods</code>的条件下可能不会通过筛选。本质上运行两次是一种保守的决策算法。如果我们把<code>nominated pod</code>视作正在运行，那么resource和Pod间anti-affinity算法更有可能失败；如果我们不把<code>nominated pod</code>视作正在运行，那么像pod间的亲和性算法更有可能失败。本质上我们不能假定 <code>Nominated Pods</code> 是否运行，因为它们现在没有运行，而且有可能被调度到另一个Node运行。</p><p>通过两轮筛选在无论那些优先级高的pod是否被调度到当前node上，都可以满足pod的调度需求，在调度的流程中只需要获取之前注册的调度算法，完成预选检测，如果发现有条件不通过则不会进行第二轮筛选，继续选择下一个节点。</p><p><img alt="两轮预选" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579167028012-6daee5fe-ee2d-4821-8650-5eb25a390626.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">podFitsOnNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">pluginContext *framework.PluginContext,</span></span></span><br><span class="line"><span class="function"><span class="params">pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">meta predicates.PredicateMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">info *schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">predicateFuncs <span class="keyword">map</span>[<span class="keyword">string</span>]predicates.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">queue internalqueue.SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">alwaysCheckAllPredicates <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">bool</span>, []predicates.PredicateFailureReason, *framework.Status, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">podsAdded := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">metaToUse := meta</span><br><span class="line">nodeInfoToUse := info</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">podsAdded, metaToUse, nodeInfoToUse = addNominatedPods(pod, meta, info, queue)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !podsAdded || <span class="built_in">len</span>(failedPredicates) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, predicateKey := <span class="keyword">range</span> predicates.Ordering() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(failedPredicates) == <span class="number">0</span> &amp;&amp; status.IsSuccess(), failedPredicates, status, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Priority-优选"><a href="#Priority-优选" class="headerlink" title="Priority 优选"></a>Priority 优选</h2><p>优选阶段主要是对通过了预选过滤的节点按照各种算法打分，打分的结果以 <code>HostPriority</code> 的形式记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostPriority represents the priority of scheduling to a particular host, higher priority is better.</span></span><br><span class="line"><span class="keyword">type</span> HostPriority <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Name of the host</span></span><br><span class="line">Host <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Score associated with the host</span></span><br><span class="line">Score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HostPriorityList declares a []HostPriority type.</span></span><br><span class="line"><span class="keyword">type</span> HostPriorityList []HostPriority</span><br></pre></td></tr></table></figure><p>为了提高优选过程中的计算速度，采用了 <code>Map/Reduce</code> 的方法对计算并行加速，结果存储在一个二维数组中。无锁计算结果的保存主要是通过下面的二维数组实现， 如果要存储一个算法针对某个node的结果，其实只需要通过两个索引即可：算法索引和节点索引。</p><p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579246857471-0d97105c-2a26-4237-bd7d-996e755f0fa1.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在计算的时候，会传入nodes []*v1.Node的数组，存储所有的节点，节点索引主要是指的该部分</span></span><br><span class="line">results := <span class="built_in">make</span>([]schedulerapi.HostPriorityList, <span class="built_in">len</span>(priorityConfigs), <span class="built_in">len</span>(priorityConfigs))</span><br></pre></td></tr></table></figure><h3 id="Priority算法注册"><a href="#Priority算法注册" class="headerlink" title="Priority算法注册"></a>Priority算法注册</h3><p>在优选过程中，每一种策略都以 <code>PriorityConfig</code> 结构表示，具体包含 <code>Map</code> 函数和 <code>Reduce</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PriorityConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Map    PriorityMapFunction</span><br><span class="line">Reduce PriorityReduceFunction</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove it after migrating all functions to</span></span><br><span class="line"><span class="comment">// Map-Reduce pattern.</span></span><br><span class="line">Function PriorityFunction</span><br><span class="line">Weight   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map：输入是(pod, meta, nodeInfo)，输出是该Pod根据该算法在该节点算出的得分</span></span><br><span class="line"><span class="keyword">type</span> PriorityMapFunction <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, meta <span class="keyword">interface</span>&#123;&#125;, nodeInfo *schedulernodeinfo.NodeInfo)</span> <span class="params">(schedulerapi.HostPriority, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce：输入是(pod, meta, map[string]*NodeInfo, result)</span></span><br><span class="line"><span class="keyword">type</span> PriorityReduceFunction <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod, meta <span class="keyword">interface</span>&#123;&#125;, nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo, result schedulerapi.HostPriorityList)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>那么，这些算法是在哪里注册的呢？在factory目录下有注册函数，指定算法名和map/reduce函数以及权重，</p><figure class="highlight go"><figcaption><span>pkg/scheduler/factory/plugins.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterPriorityMapReduceFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">name <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">mapFunction priorities.PriorityMapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">reduceFunction priorities.PriorityReduceFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">weight <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> RegisterPriorityConfigFactory(name, PriorityConfigFactory&#123;</span><br><span class="line">MapReduceFunction: <span class="function"><span class="keyword">func</span><span class="params">(PluginFactoryArgs)</span> <span class="params">(priorities.PriorityMapFunction, priorities.PriorityReduceFunction)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mapFunction, reduceFunction</span><br><span class="line">&#125;,</span><br><span class="line">Weight: weight,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>pkg/scheduler/algorithmprovider/defaults/register_priorities.go</code>中有 <code>init</code>函数来注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Register functions that extract metadata used by priorities computations.</span></span><br><span class="line">factory.RegisterPriorityMetadataProducerFactory(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(args factory.PluginFactoryArgs)</span> <span class="title">priorities</span>.<span class="title">PriorityMetadataProducer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> priorities.NewPriorityMetadataFactory(args.ServiceLister, args.ControllerLister, args.ReplicaSetLister, args.StatefulSetLister)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritize nodes by least requested utilization.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.LeastRequestedPriority, priorities.LeastRequestedPriorityMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritizes nodes to help achieve balanced resource usage</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.BalancedResourceAllocation, priorities.BalancedResourceAllocationMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set this weight large enough to override all other priority functions.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Figure out a better way to do this, maybe at same time as fixing #24720.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.NodePreferAvoidPodsPriority, priorities.CalculateNodePreferAvoidPodsPriorityMap, <span class="literal">nil</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritizes nodes that have labels matching NodeAffinity</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.NodeAffinityPriority, priorities.CalculateNodeAffinityPriorityMap, priorities.CalculateNodeAffinityPriorityReduce, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prioritizes nodes that marked with taint which pod can tolerate.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.TaintTolerationPriority, priorities.ComputeTaintTolerationPriorityMap, priorities.ComputeTaintTolerationPriorityReduce, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageLocalityPriority prioritizes nodes that have images requested by the pod present.</span></span><br><span class="line">factory.RegisterPriorityMapReduceFunction(priorities.ImageLocalityPriority, priorities.ImageLocalityPriorityMap, <span class="literal">nil</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对每一个策略进行简单分析。</p><h3 id="基于节点索引的Map计算"><a href="#基于节点索引的Map计算" class="headerlink" title="基于节点索引的Map计算"></a>基于节点索引的Map计算</h3><p>Map算法将Node方向的计算并行化，对于每一个Node，循环计算该Node在各个算法上的得分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">workqueue.ParallelizeUntil(context.TODO(), <span class="number">16</span>, <span class="built_in">len</span>(nodes), <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">nodeInfo := nodeNameToInfo[nodes[index].Name]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line"><span class="keyword">if</span> priorityConfigs[i].Function != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">results[i][index], err = priorityConfigs[i].Map(pod, meta, nodeInfo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">appendError(err)</span><br><span class="line">results[i][index].Host = nodes[index].Name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基于算法索引的Reduce计算"><a href="#基于算法索引的Reduce计算" class="headerlink" title="基于算法索引的Reduce计算"></a>基于算法索引的Reduce计算</h3><p>Reduce计算，则是为每个算法的计算都启动一个goroutine，每个goroutine通过算法索引来进行该算法的所有map阶段的结果的读取，并进行计算，后续结果仍然存储在对应的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> priorityConfigs &#123;</span><br><span class="line"><span class="keyword">if</span> priorityConfigs[i].Reduce == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">if</span> err := priorityConfigs[index].Reduce(pod, meta, nodeNameToInfo, results[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">appendError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> klog.V(<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, hostPriority := <span class="keyword">range</span> results[index] &#123;</span><br><span class="line">klog.Infof(<span class="string">"%v -&gt; %v: %v, Score: (%d)"</span>, util.GetPodFullName(pod), hostPriority.Host, priorityConfigs[index].Name, hostPriority.Score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上优选算法中有 <code>Reduce</code> 函数的并不多，只有 <code>NodeAffinity</code> 和 <code>TaintToleration</code>两个算有有Reduce函数，而且它们实质上都是调用的 <code>NormalizeReduce</code>。本质上就是将之前算出来的得分正则化，使其处于 <code>[0, maxPriority]</code>区间。因此，在Scheduling Framework框架下，这一部分被 <code>Normalize Scoring</code>阶段所取代。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NormalizeReduce</span><span class="params">(maxPriority <span class="keyword">int</span>, reverse <span class="keyword">bool</span>)</span> <span class="title">PriorityReduceFunction</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_ *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">_ <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">_ <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">result schedulerapi.HostPriorityList)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxCount <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="keyword">if</span> result[i].Score &gt; maxCount &#123;</span><br><span class="line">maxCount = result[i].Score</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> maxCount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reverse &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">result[i].Score = maxPriority</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">score := result[i].Score</span><br><span class="line"></span><br><span class="line">score = maxPriority * score / maxCount</span><br><span class="line"><span class="keyword">if</span> reverse &#123;</span><br><span class="line">score = maxPriority - score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result[i].Score = score</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Preempt-抢占"><a href="#Preempt-抢占" class="headerlink" title="Preempt 抢占"></a>Preempt 抢占</h2><p>抢占调度是分布式调度中一种常见的设计，其核心目标是当不能为高优先级的任务分配资源的时候，会通过抢占低优先级的任务来进行高优先级的调度。</p><h3 id="抢占核心流程"><a href="#抢占核心流程" class="headerlink" title="抢占核心流程"></a>抢占核心流程</h3><h3 id="抢占条件检测"><a href="#抢占条件检测" class="headerlink" title="抢占条件检测"></a>抢占条件检测</h3><p>如果发现需要执行抢占的pod有提名的node，并且对应node上面存在比自己优先级低的pod正在进行删除, 则不允许进行抢占。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">podEligibleToPreemptOthers</span><span class="params">(pod *v1.Pod, nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo, enableNonPreempting <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enableNonPreempting &amp;&amp; pod.Spec.PreemptionPolicy != <span class="literal">nil</span> &amp;&amp; *pod.Spec.PreemptionPolicy == v1.PreemptNever &#123;</span><br><span class="line">        klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v/%v is not eligible for preemption because it has a preemptionPolicy of %v"</span>, pod.Namespace, pod.Name, v1.PreemptNever)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    nomNodeName := pod.Status.NominatedNodeName</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nomNodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeInfo, found := nodeNameToInfo[nomNodeName]; found &#123;</span><br><span class="line">            podPriority := util.GetPodPriority(pod)</span><br><span class="line">            <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfo.Pods() &#123;</span><br><span class="line">                <span class="keyword">if</span> p.DeletionTimestamp != <span class="literal">nil</span> &amp;&amp; util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">                    <span class="comment">// 正在终止的优先级低于当前pod的pod就不会进行抢占</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛选潜在节点"><a href="#筛选潜在节点" class="headerlink" title="筛选潜在节点"></a>筛选潜在节点</h3><p>每个node在预选阶段都会进行一个标记，标记当前node执行预选失败的原因，筛选潜在节点主要是根据对应的错误来进行筛选，如果不是不可解决的预选错误，则该node节点就可以参与接下来的抢占阶段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nodesWherePreemptionMightHelp</span><span class="params">(nodes []*v1.Node, fitErr *FitError)</span> []*<span class="title">v1</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line">    potentialNodes := []*v1.Node&#123;&#125;</span><br><span class="line">    <span class="comment">// 根据预选阶段的错误原因，如果不存在无法解决的错误，则这些node可能在接下来的抢占流程中被使用</span></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="keyword">if</span> fitErr.FilteredNodesStatuses[node.Name].Code() == framework.UnschedulableAndUnresolvable &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        failedPredicates, _ := fitErr.FailedPredicates[node.Name]</span><br><span class="line">        <span class="keyword">if</span> !unresolvablePredicateExists(failedPredicates) &#123; </span><br><span class="line">            <span class="comment">// 如果我们发现并不是不可解决的调度错误的时候，就将这个节点加入到这里</span></span><br><span class="line">            <span class="comment">// 可能通过后续的调整会让这些node重新满足</span></span><br><span class="line">            klog.V(<span class="number">3</span>).Infof(<span class="string">"Node %v is a potential node for preemption."</span>, node.Name)</span><br><span class="line">            potentialNodes = <span class="built_in">append</span>(potentialNodes, node)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> potentialNodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行筛选节点"><a href="#并行筛选节点" class="headerlink" title="并行筛选节点"></a>并行筛选节点</h3><p>筛选抢占节点主要是并行对之前筛选潜在node进行尝试，通过驱逐低优先级pod满足高优先级pod调度，最终会筛选一批可以通过抢占来满足pod调度需要的节点， 其核心实现时通过selectVictimsOnNode来进行检测。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *genericScheduler)</span> <span class="title">selectNodesForPreemption</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    pluginContext *framework.PluginContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">    nodeNameToInfo <span class="keyword">map</span>[<span class="keyword">string</span>]*schedulernodeinfo.NodeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    potentialNodes []*v1.Node,</span></span></span><br><span class="line"><span class="function"><span class="params">    fitPredicates <span class="keyword">map</span>[<span class="keyword">string</span>]predicates.FitPredicate,</span></span></span><br><span class="line"><span class="function"><span class="params">    metadataProducer predicates.PredicateMetadataProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">    queue internalqueue.SchedulingQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    pdbs []*policy.PodDisruptionBudget,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(<span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims, error)</span></span> &#123;</span><br><span class="line">    nodeToVictims := <span class="keyword">map</span>[*v1.Node]*schedulerapi.Victims&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> resultLock sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can use the same metadata producer for all nodes.</span></span><br><span class="line">    meta := metadataProducer(pod, nodeNameToInfo)</span><br><span class="line">    checkNode := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nodeName := potentialNodes[i].Name</span><br><span class="line">        <span class="keyword">var</span> metaCopy predicates.PredicateMetadata</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            metaCopy = meta.ShallowCopy()</span><br><span class="line">        &#125;</span><br><span class="line">        pods, numPDBViolations, fits := g.selectVictimsOnNode(pluginContext, pod, metaCopy, nodeNameToInfo[nodeName], fitPredicates, queue, pdbs)</span><br><span class="line">        <span class="keyword">if</span> fits &#123;</span><br><span class="line">            resultLock.Lock()</span><br><span class="line">            victims := schedulerapi.Victims&#123;</span><br><span class="line">                Pods:             pods,</span><br><span class="line">                NumPDBViolations: numPDBViolations,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeToVictims[potentialNodes[i]] = &amp;victims</span><br><span class="line">            resultLock.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    workqueue.ParallelizeUntil(context.TODO(), <span class="number">16</span>, <span class="built_in">len</span>(potentialNodes), checkNode)</span><br><span class="line">    <span class="keyword">return</span> nodeToVictims, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点筛选节点"><a href="#单点筛选节点" class="headerlink" title="单点筛选节点"></a>单点筛选节点</h3><p><code>selectVictimsOnNode</code>即单点筛选流程是针对单个node来指向具体的驱逐抢占决策的流程, 其核心流程如下</p><p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579429019409-ea29afc8-b17d-410e-8bfc-531b00b49155.png"></p><h4 id="优先级筛选"><a href="#优先级筛选" class="headerlink" title="优先级筛选"></a>优先级筛选</h4><p>优先级筛选首先会对当前node上面的所有节点进行优先级排序，移除所有比当前pod低的pod</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">potentialVictims := util.SortableList&#123;CompFunc: util.MoreImportantPod&#125;</span><br><span class="line">    nodeInfoCopy := nodeInfo.Clone()</span><br><span class="line"></span><br><span class="line">    removePod := <span class="function"><span class="keyword">func</span><span class="params">(rp *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.RemovePod(rp)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.RemovePod(rp, nodeInfoCopy.Node())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addPod := <span class="function"><span class="keyword">func</span><span class="params">(ap *v1.Pod)</span></span> &#123;</span><br><span class="line">        nodeInfoCopy.AddPod(ap)</span><br><span class="line">        <span class="keyword">if</span> meta != <span class="literal">nil</span> &#123;</span><br><span class="line">            meta.AddPod(ap, nodeInfoCopy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    podPriority := util.GetPodPriority(pod)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> nodeInfoCopy.Pods() &#123;</span><br><span class="line">        <span class="keyword">if</span> util.GetPodPriority(p) &lt; podPriority &#123;</span><br><span class="line">            <span class="comment">// 移除所有优先级比自己低的pod</span></span><br><span class="line">            potentialVictims.Items = <span class="built_in">append</span>(potentialVictims.Items, p)</span><br><span class="line">            removePod(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="预选判断"><a href="#预选判断" class="headerlink" title="预选判断"></a>预选判断</h4><p>对移除所有优先级比自己的pod之后，会尝试进行预选流程，如果发现预选流程失败，则当前node即使通过移除所有比自己优先级低的pod也不能满足调度需求,则就进行下一个node判断</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if fits, _, _, err := g.podFitsOnNode(pluginContext, pod, <span class="keyword">meta</span>, node<span class="literal">Inf</span>oCopy, fitPredicates, queue, <span class="literal">false</span>); !fits &#123;</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Encountered error while selecting victims on node %v: %v"</span>, node<span class="literal">Inf</span>o.<span class="keyword">Node</span><span class="title">().Name</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="PDB分组与分组算法"><a href="#PDB分组与分组算法" class="headerlink" title="PDB分组与分组算法"></a>PDB分组与分组算法</h4><p>PDB分组就是对当前节点上筛选出来的低优先级pod按照是否有PDB匹配来进行分组，分为违反PDB和未违反PDB的两组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">violatingVictims, nonViolatingVictims := filterPodsWithPDBViolation(potentialVictims.Items, pdbs)</span><br></pre></td></tr></table></figure><p>分组算法其实也不难，只需要遍历所有的pdb和pod就可以得到最终的分组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterPodsWithPDBViolation</span><span class="params">(pods []<span class="keyword">interface</span>&#123;&#125;, pdbs []*policy.PodDisruptionBudget)</span> <span class="params">(violatingPods, nonViolatingPods []*v1.Pod)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, obj := <span class="keyword">range</span> pods &#123;</span><br><span class="line">        pod := obj.(*v1.Pod)</span><br><span class="line">        pdbForPodIsViolated := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// A pod with no labels will not match any PDB. So, no need to check.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pod.Labels) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, pdb := <span class="keyword">range</span> pdbs &#123;</span><br><span class="line">                <span class="keyword">if</span> pdb.Namespace != pod.Namespace &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                selector, err := metav1.LabelSelectorAsSelector(pdb.Spec.Selector)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// A PDB with a nil or empty selector matches nothing.</span></span><br><span class="line">                <span class="keyword">if</span> selector.Empty() || !selector.Matches(labels.Set(pod.Labels)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We have found a matching PDB.</span></span><br><span class="line">                <span class="keyword">if</span> pdb.Status.PodDisruptionsAllowed &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                    pdbForPodIsViolated = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pdbForPodIsViolated &#123;</span><br><span class="line">            violatingPods = <span class="built_in">append</span>(violatingPods, pod)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonViolatingPods = <span class="built_in">append</span>(nonViolatingPods, pod)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> violatingPods, nonViolatingPods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="违反PDB计数与最少驱逐汇总"><a href="#违反PDB计数与最少驱逐汇总" class="headerlink" title="违反PDB计数与最少驱逐汇总"></a>违反PDB计数与最少驱逐汇总</h4><p>会分别对违反PDB和不违反的pod集合来进行reprievePod检测，如果加入当前pod后，不能满足预选筛选流程，则该pod则必须被进行移除加入到victims中， 同时如果是违反PDB的pod则需要进行违反pdb计数numViolatingVictim</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">reprievePod := <span class="function"><span class="keyword">func</span><span class="params">(p *v1.Pod)</span> <span class="title">bool</span></span> &#123; </span><br><span class="line">      <span class="comment">// 我们首先将pod加入到meta中</span></span><br><span class="line">      addPod(p)</span><br><span class="line">      fits, _, _, _ := g.podFitsOnNode(pluginContext, pod, meta, nodeInfoCopy, fitPredicates, queue, <span class="literal">false</span>)</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> !fits &#123;</span><br><span class="line">          <span class="comment">// 如果我们加入了pod然后导致了预选不成功，则这个pod必须给移除</span></span><br><span class="line">          removePod(p)</span><br><span class="line">          victims = <span class="built_in">append</span>(victims, p) <span class="comment">// 添加到我们需要移除的列表里面</span></span><br><span class="line">          klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %v/%v is a potential preemption victim on node %v."</span>, p.Namespace, p.Name, nodeInfo.Node().Name)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fits</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> violatingVictims &#123;</span><br><span class="line">      <span class="keyword">if</span> !reprievePod(p) &#123;</span><br><span class="line">          numViolatingVictim++</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now we try to reprieve non-violating victims.</span></span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> nonViolatingVictims &#123;</span><br><span class="line">      <span class="comment">// 尝试移除未违反pdb的pod</span></span><br><span class="line">      reprievePod(p)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> victims, numViolatingVictim, <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="筛选最优抢占"><a href="#筛选最优抢占" class="headerlink" title="筛选最优抢占"></a>筛选最优抢占</h3><p>最优筛选主要是通过 <code>pickOneNodeForPreemption</code> 实现，其中筛选数据存储结构主要是通过重用minNodes1和minNodes2两段内存来进行实现，这两个node数组分别配有两个计数器lenNodes1和lenNodes2, 针对具有相同优先级、相同数量的node，每增加一个会进行一次计数器累加， 核心算法流程如下</p><p><img alt="image.png" data-src="https://cdn.nlark.com/yuque/0/2020/png/97498/1579429125998-3ddcaf40-b47c-4234-81bc-fce652fe6f46.png"></p><h4 id="最少违反PDB"><a href="#最少违反PDB" class="headerlink" title="最少违反PDB"></a>最少违反PDB</h4><p>最少违反PDB是根据前面统计的违反PDB的计数统计，找到最少违反的node，如果是单个node则直接返回筛选结束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">minNumPDBViolatingPods := math.MaxInt32</span><br><span class="line"><span class="keyword">var</span> minNodes1 []*v1.Node</span><br><span class="line">lenNodes1 := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> node, victims := <span class="keyword">range</span> nodesToVictims &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(victims.Pods) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发现一个noed不需要任何抢占，则返回它</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    numPDBViolatingPods := victims.NumPDBViolations</span><br><span class="line">    <span class="keyword">if</span> numPDBViolatingPods &lt; minNumPDBViolatingPods &#123; </span><br><span class="line">        <span class="comment">// 如果小于最小pdb数量， 如果数量发生变化，就重置</span></span><br><span class="line">        minNumPDBViolatingPods = numPDBViolatingPods</span><br><span class="line">        minNodes1 = <span class="literal">nil</span></span><br><span class="line">        lenNodes1 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numPDBViolatingPods == minNumPDBViolatingPods &#123; </span><br><span class="line">        <span class="comment">// 多个相同的node会进行追加，并累加计数器 </span></span><br><span class="line">        minNodes1 = <span class="built_in">append</span>(minNodes1, node)</span><br><span class="line">        lenNodes1++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最高优先级最小优先"><a href="#最高优先级最小优先" class="headerlink" title="最高优先级最小优先"></a>最高优先级最小优先</h4><p>最高优先级最小优先是指通过对比多个node的最高优先级的pod，优先级最低的那个node被选中，如果多个则进行下一个算法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">minHighestPriority := <span class="keyword">int32</span>(math.MaxInt32)</span><br><span class="line">    <span class="keyword">var</span> minNodes2 = <span class="built_in">make</span>([]*v1.Node, lenNodes1)</span><br><span class="line">    lenNodes2 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">        node := minNodes1[i]</span><br><span class="line">        victims := nodesToVictims[node]</span><br><span class="line">        <span class="comment">// highestPodPriority is the highest priority among the victims on this node.</span></span><br><span class="line">        <span class="comment">// 返回优先级最高的pod</span></span><br><span class="line">        highestPodPriority := util.GetPodPriority(victims.Pods[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> highestPodPriority &lt; minHighestPriority &#123;</span><br><span class="line">            <span class="comment">// 重置状态</span></span><br><span class="line">            minHighestPriority = highestPodPriority</span><br><span class="line">            lenNodes2 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> highestPodPriority == minHighestPriority &#123;</span><br><span class="line">            <span class="comment">// 如果优先级相等则加入进去</span></span><br><span class="line">            minNodes2[lenNodes2] = node</span><br><span class="line">            lenNodes2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="优先级总和最低优先"><a href="#优先级总和最低优先" class="headerlink" title="优先级总和最低优先"></a>优先级总和最低优先</h4><p>统计每个node上的所有被抢占的pod的优先级的总和，然后在多个node之间进行比较，优先级总和最低的节点被选中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">minSumPriorities := <span class="keyword">int64</span>(math.MaxInt64)</span><br><span class="line">    lenNodes1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> sumPriorities <span class="keyword">int64</span></span><br><span class="line">        node := minNodes2[i]</span><br><span class="line">        <span class="comment">// 统计所有优先级</span></span><br><span class="line">        <span class="keyword">for</span> _, pod := <span class="keyword">range</span> nodesToVictims[node].Pods &#123;</span><br><span class="line">            </span><br><span class="line">            sumPriorities += <span class="keyword">int64</span>(util.GetPodPriority(pod)) + <span class="keyword">int64</span>(math.MaxInt32+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities &lt; minSumPriorities &#123;</span><br><span class="line">            minSumPriorities = sumPriorities</span><br><span class="line">            lenNodes1 = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sumPriorities == minSumPriorities &#123;</span><br><span class="line">            minNodes1[lenNodes1] = node</span><br><span class="line">            lenNodes1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最少优先级的node</span></span><br><span class="line">    <span class="keyword">if</span> lenNodes1 == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minNodes1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="最少抢占数量优先"><a href="#最少抢占数量优先" class="headerlink" title="最少抢占数量优先"></a>最少抢占数量优先</h4><p>最少抢占数量优先即统计每个node被抢占的节点数量，数量最少得被选中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">minNumPods := math.MaxInt32</span><br><span class="line">lenNodes2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenNodes1; i++ &#123;</span><br><span class="line">    node := minNodes1[i]</span><br><span class="line">    numPods := <span class="built_in">len</span>(nodesToVictims[node].Pods)</span><br><span class="line">    <span class="keyword">if</span> numPods &lt; minNumPods &#123;</span><br><span class="line">        minNumPods = numPods</span><br><span class="line">        lenNodes2 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numPods == minNumPods &#123;</span><br><span class="line">        minNodes2[lenNodes2] = node</span><br><span class="line">        lenNodes2++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最少节点数量</span></span><br><span class="line"><span class="keyword">if</span> lenNodes2 == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最近更新节点优先"><a href="#最近更新节点优先" class="headerlink" title="最近更新节点优先"></a>最近更新节点优先</h4><p>该算法会筛选每个node驱逐的pod中优先级最高的pod的最早更新时间(其实就是说这个pod早就被创建了)，然后在多个node之间进行比较，如果谁上面的时间越新(即这个node上的pod可能是最近被调度上去的)，则就选中这个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">latestStartTime := util.GetEarliestPodStartTime(nodesToVictims[minNodes2[<span class="number">0</span>]])</span><br><span class="line">   <span class="keyword">if</span> latestStartTime == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// If the earliest start time of all pods on the 1st node is nil, just return it,</span></span><br><span class="line">       <span class="comment">// which is not expected to happen.</span></span><br><span class="line">       <span class="comment">// 如果第一个节点上所有pod的最早开始时间为零，那么返回它</span></span><br><span class="line">       klog.Errorf(<span class="string">"earliestStartTime is nil for node %s. Should not reach here."</span>, minNodes2[<span class="number">0</span>])</span><br><span class="line">       <span class="keyword">return</span> minNodes2[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   nodeToReturn := minNodes2[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; lenNodes2; i++ &#123;</span><br><span class="line">       node := minNodes2[i]</span><br><span class="line">       <span class="comment">// Get earliest start time of all pods on the current node.</span></span><br><span class="line">       <span class="comment">// 获取当前node最早启动时间</span></span><br><span class="line">       earliestStartTimeOnNode := util.GetEarliestPodStartTime(nodesToVictims[node])</span><br><span class="line">       <span class="keyword">if</span> earliestStartTimeOnNode == <span class="literal">nil</span> &#123;</span><br><span class="line">           klog.Errorf(<span class="string">"earliestStartTime is nil for node %s. Should not reach here."</span>, node)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> earliestStartTimeOnNode.After(latestStartTime.Time) &#123;</span><br><span class="line">           latestStartTime = earliestStartTimeOnNode</span><br><span class="line">           nodeToReturn = node</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> nodeToReturn</span><br></pre></td></tr></table></figure><h2 id="Scheduler-Extender"><a href="#Scheduler-Extender" class="headerlink" title="Scheduler Extender"></a>Scheduler Extender</h2><p>社区最初提供的方案是通过 Extender 的形式来扩展 scheduler。Extender 是外部服务，支持 Filter、Preempt、Prioritize 和 Bind 的扩展，scheduler 运行到相应阶段时，通过调用 Extender 注册的 webhook 来运行扩展的逻辑，影响调度流程中各阶段的决策结果。</p><p>以 Filter 阶段举例，执行过程会经过 2 个阶段:</p><p>1、scheduler 会先执行内置的 Filter 策略，如果执行失败的话，会直接标识 Pod 调度失败。<br>2、如果内置的 Filter 策略执行成功的话，scheduler 通过 Http 调用 Extender 注册的 webhook, 将调度所需要的 Pod 和 Node 的信息发送到到 Extender，根据返回 filter 结果，作为最终结果。</p><p><img alt="Scheduler Extender" data-src="https://static001.infoq.cn/resource/image/ba/71/ba41b64474d1afffa4fa44fe7130c071.jpg"></p><p>我们可以发现 Extender 存在以下问题:</p><p>1、调用 Extender 的接口是 HTTP 请求，受到网络环境的影响，性能远低于本地的函数调用。同时每次调用都需要将 Pod 和 Node 的信息进行 marshaling 和 unmarshalling 的操作，会进一步降低性能。<br>2、用户可以扩展的点比较有限，位置比较固定，无法支持灵活的扩展，例如只能在执行完默认的 Filter 策略后才能调用。</p><p>基于以上介绍，Extender 的方式在集群规模较小，调度效率要求不高的情况下，是一个灵活可用的扩展方案，但是在正常生产环境的大型集群中，Extender 无法支持高吞吐量，性能较差。</p><h2 id="Multiple-Schedulers"><a href="#Multiple-Schedulers" class="headerlink" title="Multiple Schedulers"></a>Multiple Schedulers</h2><p>Scheduler 在 Kubernetes 集群中其实类似于一个特殊的 Controller，通过监听 Pod 和 Node 的信息，给 Pod 挑选最佳的节点，更新 Pod 的 spec.NodeName 的信息来将调度结果同步到节点。所以对于部分有特殊的调度需求的用户，有些开发者通过自研 Custom Scheduler 来完成以上的流程，然后通过和 default scheduler 同时部署的方式，来支持自己特殊的调度需求。</p><p><img alt="进击的Kubernetes调度系统（一）：Scheduling Framework" data-src="https://static001.infoq.cn/resource/image/98/de/982345178a76967d014yy05300ca59de.jpg"></p><p>Custom Scheduler 会存在一下问题：</p><p>1、如果与 default scheduler 同时部署，因为每个调度器所看到的资源视图都是全局的，所以在调度决策中可能会在同一时刻在同一个节点资源上调度不同的 Pod，导致节点资源冲突的问题。<br>2、有些用户将调度器所能调度的资源通过 Label 划分不同的池子，可以避免资源冲突的现象出现。但是这样又会导致整体集群资源利用率的下降。<br>3、有些用户选择通过完全自研的方式来替换 default scheduler，这种会带来比较高的研发成本，以及 Kubernetes 版本升级后可能存在的兼容性问题。</p><p>Scheduler Extender 的性能较差可是维护成本较小，Custom Scheduler 的研发和维护的成本特别高但是性能较好，这种情况是开发者面临这种两难处境。这时候 Kubernetes Scheduling Framework V2 横空出世，给我们带来鱼和熊掌可以兼得的方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调度器（Scheduler）是 Kubernetes 的核心组件，它的主要功能是为待运行的工作负载 Pod 绑定运行的节点 Node。从最早基于谓词和优先级（Predicates and Priorities）的调度器，到 V1.15基于调度框架（Scheduling Framework）的调度器，Kubernetes的调度器正在快速演进，以满足不同场景对于资源调度的需求。&lt;/p&gt;
&lt;p&gt;本文是「Kubernetes解读」的第二篇，本篇将首先介绍Kubernetes Scheduler的背景和它的演进过程，然后会通过 Kubernetes 1.16 版本分析基于谓词与优先级的调度器原理。在「Kubernetes解读」的第三篇 &lt;a href=&quot;../83a17de0/&quot;&gt;Scheduling Framework&lt;/a&gt; 中，我将通过 Kubernetes 1.18 版本分析基于Framwork的调度器原理。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-27_k8s-scheduler.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="scheduler" scheme="http://houmin.cc/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>再出发</title>
    <link href="http://houmin.cc/posts/4987aa35/"/>
    <id>http://houmin.cc/posts/4987aa35/</id>
    <published>2020-07-12T14:59:21.000Z</published>
    <updated>2020-07-20T01:30:36.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。</p><a id="more"></a><h2 id="饮食起居"><a href="#饮食起居" class="headerlink" title="饮食起居"></a>饮食起居</h2><p>这是我整理完毕的工作台，其中购置了墙布用于装饰墙面，购买了可组装的书桌（拼了将近两个小时才拼好），又自己买了ikbc c87的键盘，从姐姐家里带来的蓝牙音响，还有之前买的LAMY钢笔，皮皮送拇指琴，真的是很喜欢很舒适的工作台了。</p><p><img alt="整理完毕的工作台" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-06_settle-down.jpg"></p><p>在上学时曾经期待过工作之后的生活场景，想着是自己每天上能够自己准备早餐，晚上下班后能够自己在家安排自己的生活。但是一周的上班生活马上用现实教育了我，每天早上8.30点出门直接在公司吃早饭，工作到9点半后下班，到家就10点后了，基本上洗漱完后就可以直接睡觉了。做饭这种事情，只能发生在周末了。然而，在入职前我就反了一个错误，一口气买了好多菜，平时也不做，好些都给浪费了。而且，为了简单，平时做的最多的就是面了。不过，不管怎样，总算是开伙了。即使只是在周末下厨，也不能丧失了生活的乐趣了啊，趁这个机会好好学习做菜是一个不错的想法。为此，我特地创建了一个<a href="../../categories/吃顿好的/">「吃顿好的」</a>专栏，用于记录我周末下厨房的菜谱。在后续的工作生涯中，这个专栏会持续更新。</p><h2 id="追光计划"><a href="#追光计划" class="headerlink" title="追光计划"></a>追光计划</h2><p>「追光计划」源自我在微博上看到一个<a href="https://weibo.com/ttarticle/p/show?id=2309404521623347921078" target="_blank" rel="external nofollow noopener noreferrer">摄影师小姐姐</a>为自己在北京最后一段时间留下记录影像的规划，她这样说道</p><blockquote><p>不知道你是否也有过类似的感觉——越是长久的生活在一个城市，反而越少了了解它的冲动。</p><p>就好比在武汉生活的四五年里，我一次都没有去过黄鹤楼，也几乎不去武大。那些外地游客心心念念的美景，本地人好像都因为太过习惯而熟视无睹。</p><p>在北京我也一样。除了故宫外，其他大众或冷门的景点，我鲜少踏足，也很少抓紧特别的天气去拍点什么，总想着：“以后还有机会的”。我拍过很多日出日落，那些绝美的光影，几乎都来自旅途，却独独少了我生活的北京。</p><p>似乎人总是这样，偶尔难得旅行，就总想紧紧抓住异乡风景。会起早贪黑去追逐日出日落，也乐于打卡各种陌生的小众景点。而你生活的地方，却总忘了多看几眼。</p><p>故事的转机发生在我决定离开北京之后。</p></blockquote><p>小姐姐和我有着类似的生活坐标（武汉与北京），直到决定离开北京后才开始意识到好好拍摄北京的风景。我也是一样，本来决定在离校前好好拍摄北大的风光，却也最终没能够实现。在过去的一两周里，我一直在质疑自己，为什么要留在北京呢？在这里呆了都七年了，为什么不换一个地方生活呢？</p><p>想到这里，我给自已一个三年之期：如果在未来三年，我没能够找到留在北京的理由，或者是因为一个人，或者是因为一件事，三年到期之时也许就是我离开北京的日子。不管到时候是否离开，在这三年里，我也有自己的追光计划。我要好好记录在北京的日子，记录那些光影。作为最基本的示例，我开创了一个新的相册，<a href="../../album/知春里知春/">知春里知春</a>，用于记录我在知春里生活的时光。另外，随着追光计划的开展，我也会把那些美丽的景色放到另一个相册，<a href="../../album/Beijing">北京</a> 。</p><h2 id="职业发展"><a href="#职业发展" class="headerlink" title="职业发展"></a>职业发展</h2><p>我职业生涯的正式起点，开启于腾讯云的kubernetes团队。在过去的一周里，我开始阅读kubernetes源码，在阅读的过程中，我越来越感觉到自己积淀的欠缺。不仅是CNCF云原生的生态发展，还有kubernetes本身机制的原理，或者是Go语言的最佳实践，以及Linux操作系统的基础原理，自己都知之甚少。或者说有时候只是知道一些名词，但是对其原理，发展机制都不太了解。</p><p>作为一个工程师，这些技术点是我的立身之本，必须在接下来的一年内能够快速积淀，给自己的职业发展奠定一个扎实的基础。为此，我列出了在接下来两年我要去点亮的技能树，这只是最基础的专业内容。它涉及的范围很广泛，但是要戒骄戒躁，一步一步来。</p><p><img alt="Kubernetes技能树" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-12_kubernetes-skill-map.png"></p><h2 id="运动健身"><a href="#运动健身" class="headerlink" title="运动健身"></a>运动健身</h2><p>在年初的时候，我大言不惭的说：</p><blockquote><p>数据是最重忠实的记录者，每周 3 次跑步，每次 5 公里，期待明年能够达到 700 公里的跑步量。</p></blockquote><p>现在每一次的跑步都是通过Keep记录，翻开Keep，发现上半年的记录只有27公里，真的是完全不达标啊。也许你可以归因于疫情，但是如此懈怠真的太不自律了。下半年开始，发现在公司地下有免费健身房，正好可以每天中午午饭时间去跑一个小时的步。按照下半年25周，每周5次每次5公里的跑步记录，勉强可以达到625公里的目标。如果再加上周末的户外跑步，比如附近的人民大学，海淀黄庄一带，可以大体满足700公里的目标，加油呀！</p><h2 id="阅读观影"><a href="#阅读观影" class="headerlink" title="阅读观影"></a>阅读观影</h2><p>翻了翻豆瓣，上半年的阅读依旧还是颗粒无收。主要还是没有一个Read List，也没有一个阅读规划，匆匆半年过去，一本书也没读过很正常。预计下半年看书还是会很少，更多的看的是专业相关的技术文档的内容。</p><p>至于观影，上半年看了很多金融相关的电影和纪录片，比如大空头等，对金融与市场有了更多的认识。另外，还入坑了「Rick and Morty」，这个系列可以慢慢刷。不知道为什么，现在好像对刷新的剧没有了之前那么大的激情，更多的是看木鱼和电影最Top对电影的讲解，整体开始偏快餐。</p><h2 id="行万里路"><a href="#行万里路" class="headerlink" title="行万里路"></a>行万里路</h2><p>在年初的时候，我给自己计划了两场旅行：</p><ul><li>和家里的春节南国之旅</li><li>和鹏飞的节后湖南之行</li></ul><p>然而这场疫情改变了一切，上半年创造了上大学以后呆在家的最长纪录，从1.19到5.7的一百多天。之后，我去杭州呆了两个月，好好逛了逛杭州，见识了西湖之美。本来计划的毕业旅行也因为一再爆发的疫情而最终取消，残念。</p><p>今年下半年，有意去新疆走一趟，趁着国庆，看看壮美的新疆，期待最终能够成行。作为一个已经毕业的人，除了国庆之外，已经没有了出去玩的机会，想一想真是心酸。不管怎么样，国庆一定要出去走走，可不能浪费这次假期。</p><h2 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h2><p>去年年末给自己定了一个理财的小目标：</p><blockquote><p>给自己定一个小目标，期待自己明年在投资上至少能够有 20 个点的收入，最好能够到 40 个点的收入。</p></blockquote><p>截止到现在，得益于行情好，已经获得了40个点的收益，希望可以在后面半年继续努力：）整体来说，上半年还是偏保守，在2.3春节开盘千股跌停的那天，我几近满仓。然而后面行情低迷是多年不遇的打底没敢全仓进入，只是半仓观望。加上进入资金也不多，最后的收益其实了了。</p><p><img alt="2020上半年收益曲线" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-12_investment.jpg"></p><p>关于理论知识，上半年在疫情期间听了徐高老师的「宏观经济十六讲中国专题」，看了一些炒股的基础知识，但是一直没有落实成文本的形式积淀下来，下半年在空余时间要在落实层面做到更好。毕竟，现在的股票买卖还是没有任何理论依据，选股的原因，买入的时机，抛出的选择都十分无脑，有时候迷之自信，没有任何逻辑。构建自己的交易体系，长路漫漫。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>卡林巴琴停了很久，年初的规划仍在，今天又弹了段「青花瓷」，找回了感觉，下半年的音乐计划继续。</p><p>2020上半年继续单身，工作以后社交状态越发封闭，这段时间先好好调整自己的状态吧，期待在工作上更好的适应，做出自己的成绩。</p><p>这次的半年总结拖了两个星期，工作和生活开始慢慢进入状态，继续加油呀，努力做更好的自己：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十九期，在过去的一周里，我正式入职腾讯。告别学校，步入职场，不管怎么说，这都算得上一次新的起点。与此同时，一年过半，翻翻2020的年初计划，正好可以梳理往者期待未来，再出发，让我们开始传奇2020的下半年。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-06_sunset.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="个人管理系统" scheme="http://houmin.cc/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="职场" scheme="http://houmin.cc/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="追光计划" scheme="http://houmin.cc/tags/%E8%BF%BD%E5%85%89%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】开篇</title>
    <link href="http://houmin.cc/posts/d8b96fe4/"/>
    <id>http://houmin.cc/posts/d8b96fe4/</id>
    <published>2020-07-07T12:47:00.000Z</published>
    <updated>2020-07-15T06:39:42.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>Kubernetes来源于希腊词汇<a href="https://en.wiktionary.org/wiki/κυβερνήτης" target="_blank" rel="external nofollow noopener noreferrer">κυβερνήτης</a>，意思是<a href="https://en.wikipedia.org/wiki/Helmsman" target="_blank" rel="external nofollow noopener noreferrer">helmsman</a>，也即是舵手的意思，也可引申为<code>pilot</code>或者<code>governor</code>的含义。与此同时，kubernetes也是<a href="https://en.wikipedia.org/wiki/Cybernetics" target="_blank" rel="external nofollow noopener noreferrer">cybernetics</a>的控制系统的意味。随着容器技术的广泛应用，特别是docker的流行，对于容器编排系统的需求导致了kubernetes的出现。docker具有集装箱的意思，而kubernetes就是管理运送集装箱的舵手。</p><p>2014年中，kubernetes首次被宣布，前期的主要开发人员来自于Google的 <a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager" target="_blank" rel="external nofollow noopener noreferrer">Borg</a>)系统，它的发展与设计也深受Borg影响。与Borg采用C++设计不同，kubernetes一开始就采用Go语言实现。</p><p>Kubernetes v1.0 was released on July 21, 2015.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-13" target="_blank" rel="external nofollow noopener noreferrer">[13]</a> Along with the Kubernetes v1.0 release, Google partnered with the <a href="https://en.wikipedia.org/wiki/Linux_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Linux Foundation</a> to form the <a href="https://en.wikipedia.org/wiki/Cloud_Native_Computing_Foundation" target="_blank" rel="external nofollow noopener noreferrer">Cloud Native Computing Foundation</a> (CNCF)<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-14" target="_blank" rel="external nofollow noopener noreferrer">[14]</a> and offered Kubernetes as a seed technology. On March 6, 2018, Kubernetes Project reached ninth place in commits at GitHub, and second place in authors and issues to the <a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="external nofollow noopener noreferrer">Linux kernel</a>.<a href="https://en.wikipedia.org/wiki/Kubernetes#cite_note-15" target="_blank" rel="external nofollow noopener noreferrer">[15]</a></p><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p><p>这是一艘载着一堆集装箱的轮船，轮船在大海上运着集装箱奔波，把集装箱送到它们该去的地方。我们之前其实介绍过一个概念叫做 container，container 这个英文单词也有另外的一个意思就是“集装箱”。Kubernetes 也就借着这个寓意，希望成为运送集装箱的一个轮船，来帮助我们管理这些集装箱，也就是管理这些容器。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/1f/a7/1f5c9e99df79ea86ca5062fef22e21a7.png"></p><h3 id="应用部署演进"><a href="#应用部署演进" class="headerlink" title="应用部署演进"></a>应用部署演进</h3><ul><li>传统部署时代：直接在物理服务器上部署应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。<ul><li>如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。</li><li>一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li></ul></li><li>虚拟化部署时代：引入虚拟化功能，允许在单个物理服务器的 CPU 上运行多个虚拟机（VM）。<ul><li>虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。</li><li>因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。</li><li>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li></ul></li><li>容器化部署时代：容器是轻量级的虚拟化，相对于虚拟机，其具有更多的优势<ul><li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过快速简单的回滚(由于镜像不可变性)，提供可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像，从而将应用程序与基础架构分离。</li><li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li><li>云和操作系统分发的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、Google Kubernetes Engine 和其他任何地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li><li>资源隔离：可预测的应用程序性能。</li><li>资源利用：高效率和高密度。</li></ul></li></ul><p><img alt="Container Evolution" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_container-evolution.svg"></p><p>沿着虚拟化的路径，容器流行后需要有容器编排管理的服务，于是诞生了kubernetes。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li><p><strong>服务发现与负载均衡</strong></p><p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果到容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>Kubernetes 允许自动挂载选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p><strong>自动二进制打包</strong><br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong><br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 </p></li></ul><h2 id="Kubernetes-Components"><a href="#Kubernetes-Components" class="headerlink" title="Kubernetes Components"></a>Kubernetes Components</h2><p>Kubernetes集群是由众多的Node组成，遵循主从架构，整个Kubernetes集群可以被划分为控制面和控制面管理的众多Node。</p><p><img alt="Kubernetes Components" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_components-of-kubernetes.png"></p><h3 id="Control-Plane-Components"><a href="#Control-Plane-Components" class="headerlink" title="Control Plane Components"></a>Control Plane Components</h3><p>Kubernetes 的控制面负责对集群作出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的Pod）。控制面的组建可以在集群中的任意节点中运行，但是通常会在同一个节点上启动所有控制面的组建，并且这个节点不再运行用户容器，此即称作Master节点。控制面的每一个组件都既可以运行在单master节点，也可以运行在多master节点以实现高可用。</p><p>Master节点包含四个主要的组件：API Server、Controller Manager、Scheduler 以及 Etcd，如下图所示。</p><p><img alt="Control Plane" data-src="https://platform9.com/wp-content/uploads/2019/05/kubernetes-constructs-concepts-architecture.jpg"></p><h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>kube-apiserver 是 Kubernetes 最重要的核心组件之一，暴露了Kubernetes API，是控制面的前端组件，它主要提供以下的功能：</p><ul><li>提供集群管理的 REST API 接口，实现了认证、授权、准入控制等安全校验功能，同时也负责集群状态的存储操作（通过 etcd）。</li><li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</li></ul><p><img alt="Kube Api Server" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_kube-apiserver.png"></p><p>在实际使用中，通常通过 <a href="https://kubernetes.io/docs/user-guide/kubectl-overview/" target="_blank" rel="external nofollow noopener noreferrer">kubectl</a> 来访问 apiserver，也可以通过 Kubernetes 各个语言的 client 库来访问 apiserver。在使用 kubectl 时，打开调试日志也可以看到每个 API 调用的格式，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --v=8 get pods</span><br></pre></td></tr></table></figure><p>可通过 <code>kubectl api-versions</code> 和 <code>kubectl api-resources</code> 查询 Kubernetes API 支持的 API 版本以及资源对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl api-versions</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br><span class="line">apiextensions.k8s.io/v1beta1</span><br><span class="line">apiregistration.k8s.io/v1</span><br><span class="line">apiregistration.k8s.io/v1beta1</span><br><span class="line">apps/v1</span><br><span class="line">apps/v1beta1</span><br><span class="line">apps/v1beta2</span><br><span class="line">authentication.k8s.io/v1</span><br><span class="line">authentication.k8s.io/v1beta1</span><br><span class="line">authorization.k8s.io/v1</span><br><span class="line">authorization.k8s.io/v1beta1</span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">batch/v1</span><br><span class="line">batch/v1beta1</span><br><span class="line">certificates.k8s.io/v1beta1</span><br><span class="line">events.k8s.io/v1beta1</span><br><span class="line">extensions/v1beta1</span><br><span class="line">metrics.k8s.io/v1beta1</span><br><span class="line">networking.k8s.io/v1</span><br><span class="line">policy/v1beta1</span><br><span class="line">rbac.authorization.k8s.io/v1</span><br><span class="line">rbac.authorization.k8s.io/v1beta1</span><br><span class="line">scheduling.k8s.io/v1beta1</span><br><span class="line">storage.k8s.io/v1</span><br><span class="line">storage.k8s.io/v1beta1</span><br><span class="line">v1</span><br><span class="line"></span><br><span class="line">$ kubectl api-resources --api-group=storage.k8s.io</span><br><span class="line">NAME                SHORTNAMES   APIGROUP         NAMESPACED   KIND</span><br><span class="line">storageclasses      sc           storage.k8s.io   <span class="literal">false</span>        StorageClass</span><br><span class="line">volumeattachments                storage.k8s.io   <span class="literal">false</span>        VolumeAttachment</span><br></pre></td></tr></table></figure><h4 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h4><p>Etcd是一个分布式的键值数据库，兼具一致性和高可用性，API Server 中所需要的这些原信息都被放置在 etcd 中。Etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。</p><h4 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h4><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p><p><img alt="controller manager" data-src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/controller-manager.png"></p><p>每个Controller通过API Server提供的接口实时监控整个集群的每个资源对象的当前状态，当发生各种故障导致系统状态发生变化时，会尝试将系统状态修复到“期望状态”。从逻辑上讲，每个<a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="external nofollow noopener noreferrer">控制器</a>都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p><p>这些控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><p>我们刚刚提到的 API Server，它本身在部署结构上是一个可以水平扩展的一个部署组件；Controller 是一个可以进行热备的一个部署组件，它只有一个 active，它的调度器也是相应的，虽然只有一个 active，但是可以进行热备。</p><h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>Scheduler是Master节点上的调度器组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><p>Scheduler在整个系统中起”承上启下”作用：</p><ul><li>承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node</li><li>启下：Node上的kubelet接管Pod的生命周期。</li></ul><p>Scheduler的主要工作：</p><ul><li><p>通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中</p></li><li><p>kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</p><p><img alt="Scheduler" data-src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510579017/article/kubernetes/core/scheduler.png"></p></li></ul><p>Scheduler的调度流程：</p><ul><li>预选调度过程，即遍历所有目标Node，筛选出符合要求的候选节点，kubernetes内置了多种预选策略（xxx Predicates）供用户选择</li><li>确定最优节点，在第一步的基础上采用优选策略（xxx Priority）计算出每个候选节点的积分，取最高积分。</li></ul><p>调度流程通过插件式加载的“调度算法提供者”（AlgorithmProvider）具体实现，一个调度算法提供者就是包括一组预选策略与一组优选策略的结构体。</p><h3 id="Node-Components"><a href="#Node-Components" class="headerlink" title="Node Components"></a><strong>Node Components</strong></h3><p>Kubernetes 的 Node 是真正运行业务负载的，每个业务负载会以 Pod 的形式运行。一个 Pod 中运行的一个或者多个容器，真正去运行这些 Pod 的组件的是叫做 <strong>kubelet</strong>，也就是 Node 上最为关键的组件，它通过 API Server 接收到所需要 Pod 运行的状态，然后提交到 Container Runtime 组件中。</p><p>在 OS 上去创建容器所需要运行的环境，最终把容器或者 Pod 运行起来，也需要对存储跟网络进行管理。Kubernetes 并不会直接进行网络存储的操作，他们会靠 Storage Plugin 或者是网络的 Plugin 来进行操作。用户自己或者云厂商都会去写相应的 <strong>Storage Plugin</strong> 或者 <strong>Network Plugin</strong>，去完成存储操作或网络操作。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/5c/f8/5c9fe50067821e9e86a74cae4cbdd9f8.png"></p><h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p>Kubelet是Node上的pod管家。在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。</p><h4 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h4><p><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="external nofollow noopener noreferrer">kube-proxy</a> 是集群中每个节点上运行的网络代理,实现 Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service</a> 概念的一部分。</p><p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。</p><h4 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h4><p>Container Runtime（容器运行时）是负责容器运行的软件。</p><p>Kubernetes支持几种容器运行时环境：Docker、Containerd、CRI-O等。</p><h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a><strong>Addons</strong></h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>尽管并非严格要求其他附加组件，但所有示例都依赖<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="external nofollow noopener noreferrer">集群 DNS</a>，因此所有 Kubernetes 集群都应具有 DNS。</p><p>除了您环境中的其他 DNS 服务器之外，集群 DNS 还是一个 DNS 服务器，它为 Kubernetes 服务提供 DNS 记录。</p><p>Cluster DNS 是一个 DNS 服务器，和您部署环境中的其他 DNS 服务器一起工作，为 Kubernetes 服务提供DNS记录。</p><p>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中。</p><h4 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h4><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="external nofollow noopener noreferrer">Dashboard</a> 是 Kubernetes 集群的通用基于 Web 的 UI。它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><h4 id="Container-Resource-Monitoring"><a href="#Container-Resource-Monitoring" class="headerlink" title="Container Resource Monitoring"></a>Container Resource Monitoring</h4><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="external nofollow noopener noreferrer">容器资源监控</a>将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p><h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="external nofollow noopener noreferrer">集群层面日志</a> 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面我们以一个例子再去看一下 Kubernetes 架构中的这些组件，是如何互相进行 interaction 的。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/04/9b/047e4723316d6424b26341de5007329b.png"></p><p>用户可以通过 UI 或者 CLI 提交一个 Pod 给 Kubernetes 进行部署，这个 Pod 请求首先会通过 CLI 或者 UI 提交给 Kubernetes API Server，下一步 API Server 会把这个信息写入到它的存储系统 etcd，之后 Scheduler 会通过 API Server 的 watch 或者叫做 notification 机制得到这个信息：有一个 Pod 需要被调度。</p><p>这个时候 Scheduler 会根据它的内存状态进行一次调度决策，在完成这次调度之后，它会向 API Server report 说：“OK！这个 Pod 需要被调度到某一个节点上。”</p><p>这个时候 API Server 接收到这次操作之后，会把这次的结果再次写到 etcd 中，然后 API Server 会通知相应的节点进行这次 Pod 真正的执行启动。相应节点的 kubelet 会得到这个通知，kubelet 就会去调 Container runtime 来真正去启动配置这个容器和这个容器的运行环境，去调度 Storage Plugin 来去配置存储，network Plugin 去配置网络。</p><p>这个例子我们可以看到：这些组件之间是如何相互沟通相互通信，协调来完成一次 Pod 的调度执行操作的。</p><h2 id="The-Kubernetes-API"><a href="#The-Kubernetes-API" class="headerlink" title="The Kubernetes API"></a>The Kubernetes API</h2><p>Kubernetes API 允许你查询和操作 Kubernetes 集群中对象的状态。Kubernetes集群控制面的核心是 Api Server 以及他暴露的 HTTP API。用户，集群中的其他部分，还有外部组件都是通过API Server进行通信。</p><h3 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h3><p>为了使删除字段或者重构资源表示更加容易，Kubernetes 支持 多个API版本。每一个版本都在不同API路径下，例如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1</code>。</p><p>我们选择在API级别进行版本化，而不是在资源或字段级别进行版本化，以确保API提供清晰，一致的系统资源和行为视图，并控制对已废止的API和/或实验性API的访问。 JSON和Protobuf序列化模式遵循架构更改的相同准则 - 下面的所有描述都同时适用于这两种格式。</p><p>请注意，API版本控制和软件版本控制只有间接相关性。 <a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md" target="_blank" rel="external nofollow noopener noreferrer">API和发行版本建议</a> 描述了API版本与软件版本之间的关系。</p><p>不同的API版本名称意味着不同级别的软件稳定性和支持程度。 每个级别的标准在<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions" target="_blank" rel="external nofollow noopener noreferrer">API变更文档</a>中有更详细的描述。 内容主要概括如下：</p><ul><li>Alpha 测试版本：<ul><li>版本名称包含了 <strong><code>alpha</code></strong> (例如：<strong><code>v1alpha1</code></strong>)。</li><li>可能是有缺陷的。启用该功能可能会带来隐含的问题，默认情况是关闭的。</li><li>支持的功能可能在没有通知的情况下随时删除。</li><li>API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知。</li><li>由于bugs风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</li></ul></li><li>Beta 测试版本：<ul><li>版本名称包含了 <strong><code>beta</code></strong> (例如: <strong><code>v2beta3</code></strong>)。</li><li>代码已经测试过。启用该功能被认为是安全的，功能默认已启用。</li><li>所有已支持的功能不会被删除，细节可能会发生变化。</li><li>对象的模式和/或语义可能会在后续的beta测试版或稳定版中以不兼容的方式进行更改。 发生这种情况时，我们将提供迁移到下一个版本的说明。 这可能需要删除、编辑和重新创建API对象。执行编辑操作时需要谨慎行事，这可能需要停用依赖该功能的应用程序。</li><li>建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。 如果您有多个可以独立升级的集群，则可以放宽此限制。</li><li><strong>请尝试我们的 beta 版本功能并且给出反馈！一旦他们退出 beta 测试版，我们可能不会做出更多的改变。</strong></li></ul></li><li>稳定版本：<ul><li>版本名称是 <strong><code>vX</code></strong>，其中 <strong><code>X</code></strong> 是整数。</li></ul></li></ul><h3 id="API-描述"><a href="#API-描述" class="headerlink" title="API 描述"></a>API 描述</h3><p>下面我们介绍一下 Kubernetes 的 API 的基础知识。从 high-level 上看，Kubernetes API 是由 <strong>HTTP+JSON </strong> 组成的：用户访问的方式是 HTTP，访问的 API 中 content 的内容是 JSON 格式的。</p><p>Kubernetes 的 kubectl 也就是 command tool，Kubernetes UI，或者有时候用 curl，直接与 Kubernetes 进行沟通，都是使用 HTTP + JSON 这种形式。</p><p>下面有个例子：比如说，对于这个 Pod 类型的资源，它的 HTTP 访问的路径，就是 API，然后是 apiVesion: V1, 之后是相应的 Namespaces，以及 Pods 资源，最终是 Podname，也就是 Pod 的名字。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/23/2e/23921b341e482ad31ce28fc15269ad2e.png"></p><p>如果我们去提交一个 Pod，或者 get 一个 Pod 的时候，它的 content 内容都是用 JSON 或者是 YAML 表达的。上图中有个 yaml 的例子，在这个 yaml file 中，对 Pod 资源的描述也分为几个部分。</p><p>第一个部分，一般来讲会是 API 的 <strong>version</strong>。比如在这个例子中是 V1，它也会描述我在操作哪个资源；比如说我的 <strong>kind</strong> 如果是 pod，在 Metadata 中，就写上这个 Pod 的名字；比如说 nginx，我们也会给它打一些 <strong>label</strong>，我们等下会讲到 label 的概念。在 Metadata 中，有时候也会去写 <strong>annotation</strong>，也就是对资源的额外的一些用户层次的描述。</p><h2 id="Kubernetes-Objects"><a href="#Kubernetes-Objects" class="headerlink" title="Kubernetes Objects"></a>Kubernetes Objects</h2><p>Kubernetes对象是Kubernetes集群中持久化的实体，通过这些实体可以代表集群的状态。具体的，它们可以描述以下内容：</p><ul><li>哪些容器化应用在运行（以及在哪个 Node 上）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p><p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>。比如，当使用 <code>kubectl</code> 命令行接口时，CLI 会执行必要的 Kubernetes API 调用，也可以在程序中使用 <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="external nofollow noopener noreferrer">客户端库</a> 直接调用 Kubernetes API。</p><h3 id="Object-Spec-and-Status"><a href="#Object-Spec-and-Status" class="headerlink" title="Object Spec and Status"></a>Object Spec and Status</h3><p>每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象 <em>spec</em> 和 对象 <em>status</em> 。 <em>spec</em> 是必需的，它描述了对象的 <em>期望状态（Desired State）</em> —— 希望对象所具有的特征。 <em>status</em> 描述了对象的 <em>实际状态（Actual State）</em> ，它是由 Kubernetes 系统提供和更新的。在任何时刻，Kubernetes 控制面一直努力地管理着对象的实际状态以与期望状态相匹配。</p><p>例如，Kubernetes Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能需要设置 Deployment 的规约，以指定该应用需要有 3 个副本在运行。 Kubernetes 系统读取 Deployment 规约，并启动我们所期望的该应用的 3 个实例 —— 更新状态以与规约相匹配。 如果那些实例中有失败的（一种状态变更），Kubernetes 系统通过修正来响应规约和状态之间的不一致 —— 这种情况，会启动一个新的实例来替换。</p><p>关于对象 spec、status 和 metadata 的更多信息，查看 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 约定</a>。</p><h3 id="Describing-a-Kubernetes-object"><a href="#Describing-a-Kubernetes-object" class="headerlink" title="Describing a Kubernetes object"></a>Describing a Kubernetes object</h3><p>当创建 Kubernetes 对象时，必须提供对象的Spec，用来描述该对象的期望状态，以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>），API 请求必须在请求体中包含 JSON 格式的信息。 <strong>大多数情况下，需要在 .yaml 文件中为 <code>kubectl</code> 提供这些信息</strong>。 <code>kubectl</code> 在发起 API 请求时，将这些信息转换成 JSON 格式。</p><p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：</p><figure class="highlight yaml"><figcaption><span>application/deployment.yaml </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="Required-Fields"><a href="#Required-Fields" class="headerlink" title="Required Fields"></a>Required Fields</h3><p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p><ul><li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li><li><code>kind</code> - 想要创建的对象的类型</li><li><code>metadata</code> - 帮助识别对象唯一性的数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li><li><code>spec</code> - 你对该对象期望的状态</li></ul><p>对象 <code>spec</code> 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API 参考</a>能够帮助我们找到任何我们想创建的对象的 spec 格式。 例如，可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Pod</code> 的 <code>spec</code> 格式， 并且可以从 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#deploymentspec-v1-apps" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 查看 <code>Deployment</code> 的 <code>spec</code> 格式。</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是 Kubernetes 应用程序的基本执行单元，是Kubernetes对象模型中创建的最小单元，Pod表示集群是运行的进程。</p><p>用户可以通过 Kubernetes 的 Pod API 生产一个 Pod，让 Kubernetes 对这个 Pod 进行调度，也就是把它放在某一个 Kubernetes 管理的节点上运行起来。一个 Pod 简单来说是对一组容器的抽象，它里面会包含一个或多个容器。</p><p>比如像下面的这幅图里面，它包含了两个容器，每个容器可以指定它所需要资源大小。比如说，一个核一个 G，或者说 0.5 个核，0.5 个 G。</p><p>当然在这个 Pod 中也可以包含一些其他所需要的资源：比如说我们所看到的 Volume 卷这个存储资源；比如说我们需要 100 个 GB 的存储或者 20GB 的另外一个存储。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/b2/9f/b246d174b3169a242ac5799bc962f69f.png"></p><p>在 Pod 里面，我们也可以去定义容器所需要运行的方式。比如说运行容器的 Command，以及运行容器的环境变量等等。Pod 这个抽象也给这些容器提供了一个共享的运行环境，它们会共享同一个网络环境，这些容器可以用 localhost 来进行直接的连接。而 Pod 与 Pod 之间，是互相有 isolation 隔离的。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume 就是卷的概念，它是用来管理 Kubernetes 存储的，是用来声明在 Pod 中的容器可以访问文件目录的，一个卷可以被挂载在 Pod 中一个或者多个容器的指定路径下面。</p><p>而 Volume 本身是一个抽象的概念，一个 Volume 可以去支持多种的后端的存储。比如说 Kubernetes 的 Volume 就支持了很多存储插件，它可以支持本地的存储，可以支持分布式的存储，比如说像 ceph，GlusterFS ；它也可以支持云存储，比如说阿里云上的云盘、AWS 上的云盘、Google 上的云盘等等。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/54/5b/542cf5c317c5e567ba63a720802ae85b.png"></p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 是在 Pod 这个抽象上更为上层的一个抽象，它可以定义一组 Pod 的副本数目、以及这个 Pod 的版本。一般大家用 Deployment 这个抽象来做应用的真正的管理，而 Pod 是组成 Deployment 最小的单元。</p><p>Kubernetes 是通过 Controller，也就是我们刚才提到的控制器去维护 Deployment 中 Pod 的数目，它也会去帮助 Deployment 自动恢复失败的 Pod。</p><p>比如说我可以定义一个 Deployment，这个 Deployment 里面需要两个 Pod，当一个 Pod 失败的时候，控制器就会监测到，它重新把 Deployment 中的 Pod 数目从一个恢复到两个，通过再去新生成一个 Pod。通过控制器，我们也会帮助完成发布的策略。比如说进行滚动升级，进行重新生成的升级，或者进行版本的回滚。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/4e/e2/4ea8feaad09e871bbca804e7f61738e2.png"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 提供了一个或者多个 Pod 实例的稳定访问地址。</p><p>比如在上面的例子中，我们看到：一个 Deployment 可能有两个甚至更多个完全相同的 Pod。对于一个外部的用户来讲，访问哪个 Pod 其实都是一样的，所以它希望做一次负载均衡，在做负载均衡的同时，我只想访问某一个固定的 VIP，也就是 Virtual IP 地址，而不希望得知每一个具体的 Pod 的 IP 地址。</p><p>我们刚才提到，这个 pod 本身可能 terminal go（终止），如果一个 Pod 失败了，可能会换成另外一个新的。</p><p>对一个外部用户来讲，提供了多个具体的 Pod 地址，这个用户要不停地去更新 Pod 地址，当这个 Pod 再失败重启之后，我们希望有一个抽象，把所有 Pod 的访问能力抽象成一个第三方的一个 IP 地址，实现这个的 Kubernetes 的抽象就叫 Service。</p><p>实现 Service 有多种方式，Kubernetes 支持 Cluster IP，上面我们讲过的 kuber-proxy 的组网，它也支持 nodePort、 LoadBalancer 等其他的一些访问的能力。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/bb/4a/bbcd5a617d228099f69ddc987ca18f4a.png"></p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace 是用来做一个集群内部的逻辑隔离的，它包括鉴权、资源管理等。Kubernetes 的每个资源，比如刚才讲的 Pod、Deployment、Service 都属于一个 Namespace，同一个 Namespace 中的资源需要命名的唯一性，不同的 Namespace 中的资源可以重名。</p><p>Namespace 一个用例，比如像在阿里巴巴，我们内部会有很多个 business units，在每一个 business units 之间，希望有一个视图上的隔离，并且在鉴权上也不一样，在 cuda 上面也不一样，我们就会用 Namespace 来去给每一个 BU 提供一个他所看到的这么一个看到的隔离的机制。</p><p><img alt="从零开始入门 K8s：详解 K8s 核心概念" data-src="https://static001.infoq.cn/resource/image/a0/4d/a00719f494ae94a40be0be6012e5134d.png"></p><h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><p>参考 <a href="https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.im/post/5de3a7e06fb9a0719139ad93#heading-8</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl</span></span><br><span class="line"><span class="comment">## 声明式资源管理</span></span><br><span class="line"><span class="comment"># kubectl apply</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 命令式资源管理</span></span><br><span class="line"><span class="comment"># kubectl create</span></span><br><span class="line"><span class="comment"># kubectl expose</span></span><br><span class="line"><span class="comment"># kubectl scale</span></span><br><span class="line"><span class="comment"># kubectl annotate</span></span><br><span class="line"><span class="comment"># kubectl label</span></span><br><span class="line"><span class="comment"># kubectl delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 资源查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl get</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl get [(-o|--output=)](TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags] [options]</span><br><span class="line"><span class="comment"># Examples: </span></span><br><span class="line">kubectl get services                          <span class="comment"># 列出当前NS中所有service资源</span></span><br><span class="line">kubectl get pods --all-namespaces             <span class="comment"># 列出集群所有NS中所有的Pod</span></span><br><span class="line">kubectl get pods -o wide                      <span class="comment"># -o wide也比较常用，可以显示更多资源信息，比如pod的IP等</span></span><br><span class="line">kubectl get deployment my-dep                 <span class="comment"># 可以直接指定资源名查看</span></span><br><span class="line">kubectl get deployment my-dep --watch         <span class="comment"># --watch 参数可以监控资源的状态，在状态变换时输出。在跟踪服务部署情况时很有用</span></span><br><span class="line">kubectl get pod my-pod -o yaml                <span class="comment"># 查看yaml格式的资源配置，这里包括资实际的status，可以用--export排除</span></span><br><span class="line">kubectl get pod my-pod -l app=nginx           <span class="comment"># 查看所有带有标签app: nginx的pod</span></span><br><span class="line"><span class="comment"># kubectl describe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 容器管理</span></span><br><span class="line"><span class="comment"># kubectl log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### kubectl exec</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> POD [-c CONTAINER] -- COMMAND [args...] [options]</span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod ls                         <span class="comment"># 对my-pod执行ls命令</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -t -i nginx-78f5d695bd-czm8z bash <span class="comment"># 进入pod的shell，并打开伪终端和标准输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl cp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 集群管理</span></span><br><span class="line"><span class="comment"># kubectl cluster-info</span></span><br><span class="line"><span class="comment"># kubectl version</span></span><br><span class="line"><span class="comment"># kubectl cordon/uncordon</span></span><br><span class="line"><span class="comment"># kubectl drain</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes是一个开源的工业级自动化容器编排平台，广泛用于应用的部署、弹性扩充和管理。本文是「Kubernetes解读」系列开篇，主要介绍 Kubernetes 的整体概念。在以后的日子里，我会对 Kubernetes 涉及到的方方面面进行学习与解读。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-07_kubernetes.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="CNCF" scheme="http://houmin.cc/tags/CNCF/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="系统设计" scheme="http://houmin.cc/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>毕业快乐</title>
    <link href="http://houmin.cc/posts/959c2cfa/"/>
    <id>http://houmin.cc/posts/959c2cfa/</id>
    <published>2020-07-05T14:58:46.000Z</published>
    <updated>2020-07-20T01:30:36.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。</p><a id="more"></a><h2 id="欢迎回家"><a href="#欢迎回家" class="headerlink" title="欢迎回家"></a>欢迎回家</h2><p>在 7 月 5 日，我得到一次毕业生返校机会，用于打包行李。在此之前，我已经委托 HT 和 CR 帮忙把行李寄了出来，事实上已经没有什么东西需要打包。但是我仍然申请了返校，为的是再以毕业生的身份看一看燕园。在去年冬天，刚开始迷上摄影的我在下雪的燕园拍了好些照片，当时的我还想着要好好利用这最后的半年，多拍一些学校的照片。没想到这次的疫情直接导致了这半年完全不能回来，真的很遗憾了。</p><p><img alt="欢迎回家，半年后再次回到燕园" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_welcome-back.jpg"></p><p>作为 <a href="../c924112f">对比</a>，我在去年冬天拍照的机位再次拍摄了夏天的景色，再见燕园已经是另一幅样子。</p><p><img alt="夏日翠影中的塞万提斯" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_cervantes.jpg"></p><p><img alt="大雅之堂" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_daya.jpg"></p><p><img alt="上次拍的这个视角，正是几个女孩子在这里堆雪人，今天的静园静悄悄的，只有偶尔几个毕业生过来拍照" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_green.jpg"></p><p><img alt="南北阁，夏天的味道" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_south-north.jpg"></p><p><img alt="二体，与冬天下雪时不同，这次回来正下着零星的小雨" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_roof.jpg"></p><p><img alt="夏日未名湖，没有冰场，没有雪花，只有满满的绿色" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-05_tower.jpg"></p><h2 id="毕业快乐"><a href="#毕业快乐" class="headerlink" title="毕业快乐"></a>毕业快乐</h2><p>2013年8月29日，我和大姐二姐第一次来到燕园，那天还没有正式开学，小雨迷蒙，绕着燕园转了好半天，当时觉得燕园很大，一切都很新，未来充满希望；2020年7月5日，我最后一次以学生的身份回到燕园，同样是小雨淅沥，时隔半年，燕园显得熟悉而又陌生。在2017年的夏天，我已经毕业过一次。只是那一次，从本专业本科保研到对应实验室，毕业的感觉并没有很强烈。但是这一次，是彻底结束了学生生涯，走向社会，走向独立。七年前，我对于未来会如何发展一无所知，不知道自己未来会去向何处；今天，我对于自己想做什么内心大致有了方向，但是不确定性仍然存在。在这七年间，我见到了很多很厉害，很努力，很有趣的同学，他们始终是我前进和奋斗的榜样。我一直会告诉自己，我永远可以变得更好。</p><p>当我坐着自如搬家师傅帮我把好几大箱的行李搬到租住的房间，看着行李我累得完全不想动，我清醒地意识到，从此刻开始，我的学生生涯永远不再。我甚至还不争气的流下了眼泪，仿佛是为了给自己一个正式的道别。毋庸置疑，毕业是人生中的一个重要节点，从社会意义上来讲你完成了你身份的转变。但是毕业真的是那么值得伤感的一件事情吗？看到一些师兄毕业后的生活状态，按照他们的话说，从此成为一名社畜，日常995，还得承受工作的压力。也许这就是现实，但是我还是愿意乐观一点。对我来说，毕业标志着我进入了人生新的一个阶段，你需要在这个阶段去做更有意义、有价值的事情。也许有时候会很辛苦，但是作为一个独立的人，你可以探索更多有意思的事情。</p><p>毕业快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十八期，这一期的主题是毕业🎓。什么才算做毕业的节点，自然不是学院那仓促的毕业典礼，或许学校隆重的在线毕业典礼可以算是，又或者是你搬到出租房的那一天。对我来说，我的毕业节点是我拍上封面图的那一刻。不能进入学校，我穿上学位服，戴着口罩来到西门外，拍下了这张可以留存一辈子的毕业照。我郑重的告诉自己，七年的燕园时光到此结束，毕业快乐。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-07-02_graduation.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="毕业" scheme="http://houmin.cc/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>西湖印象</title>
    <link href="http://houmin.cc/posts/2f653e3b/"/>
    <id>http://houmin.cc/posts/2f653e3b/</id>
    <published>2020-06-20T07:05:47.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。</p><p>这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。</p><a id="more"></a><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><img alt="这天去西湖的时候，天空的云彩特别好看，再加上山峦剪影，很有感觉" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-lake.jpg"></p><p><img alt="在这个地方拍了会延时，发现还是日落那会拍延时更好看，这里镜头应该往前推一点" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-tower.jpg"></p><p><img alt="厨师帽？" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_cloud-hat.jpg"></p><h2 id="湖"><a href="#湖" class="headerlink" title="湖"></a>湖</h2><p><img alt="集贤亭，走到这里看到很多大爷专业设备都准备好了，经典取景地" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_pavilion.jpg"></p><p><img alt="不是三潭印月，拍的晚霞时的小亭子" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_tower.jpg"></p><p><img alt="湖边的旅游警察" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_police.jpg"></p><h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p><img alt="湖边喂鸽子的小女孩，这个小男孩正在看着下一张图片的场景" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_dove.jpg"></p><p><img alt="对，一大堆人正在喂着小松鼠，西湖边的松鼠可真多" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_squirrel.jpg"></p><p><img alt="前一天过来转的时候，正好下雨，碰到一对在湖边看风景的情侣，很有感觉" data-src="https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_lover.jpg"></p><h2 id="霞"><a href="#霞" class="headerlink" title="霞"></a>霞</h2><p>傍晚的时候又拍了会延时，没带三脚架，镜头有一些晃动，下次再弄弄</p><iframe src="//player.bilibili.com/player.html?aid=796036715&bvid=BV1CC4y1a7iw&cid=203569493&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是「朝花夕拾」第十七期，距离上一期又过去了一个月，最近有些拖更，是时候好好调整状态了。距离上一期，这段时间里也发生了很多的事情，毕业设计答辩顺利通过，预期清零的疫情在返校前又生波折，北京突发疫情防控转严。我将原来 6.16 返回学校的计划推迟，本想着出去走走，没想到其他地方也渐有零星案例，于是推迟了黄山之行，只能在杭州转转。&lt;/p&gt;
&lt;p&gt;这段时间，杭州阴雨连绵，我宅在老姐家里，把过去一段时间拍的片子整理了出来，以下是我的西湖印象。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-06-12_pavilion.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="摄影" scheme="http://houmin.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="西湖" scheme="http://houmin.cc/tags/%E8%A5%BF%E6%B9%96/"/>
    
      <category term="杭州" scheme="http://houmin.cc/tags/%E6%9D%AD%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>【普鲁斯特问卷】2020</title>
    <link href="http://houmin.cc/posts/ab5f63d0/"/>
    <id>http://houmin.cc/posts/ab5f63d0/</id>
    <published>2020-05-25T12:23:33.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? </p><p>作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）</p><a id="more"></a><p>话不多说，我们开始。</p><h3 id="你认为最完美的快乐是怎样的？"><a href="#你认为最完美的快乐是怎样的？" class="headerlink" title="你认为最完美的快乐是怎样的？"></a><strong>你认为最完美的快乐是怎样的？</strong></h3><ul><li>做成一件事之后的满足感。</li><li>和好朋友一起无所忌惮的吐槽。</li><li>运动完之后多巴胺分泌的快感。</li></ul><h3 id="你最希望拥有哪种才华？"><a href="#你最希望拥有哪种才华？" class="headerlink" title="你最希望拥有哪种才华？"></a><strong>你最希望拥有哪种才华？</strong></h3><p>羡慕那些拥有绝对音感的人，希望自己能够拥有音乐方面的才华。</p><p>最近在玩卡林巴和尤克里里，记谱对我来说真的是一件困难的事情，心手协调更是需要训练。一直觉得那些音乐创作人是很厉害的存在，自己也想要学乐器词曲，期待有一天能够创作出在音乐上自己的作品。</p><h3 id="你最恐惧的是什么？"><a href="#你最恐惧的是什么？" class="headerlink" title="你最恐惧的是什么？"></a><strong>你最恐惧的是什么？</strong></h3><p>快节奏的都市生活，害怕自己陷入对升职加薪追求的焦虑，而忘了自己到底想要什么。</p><h3 id="你目前的心境怎样？"><a href="#你目前的心境怎样？" class="headerlink" title="你目前的心境怎样？"></a><strong>你目前的心境怎样？</strong></h3><p>现在的我，身处杭州，刚刚提交毕业论文，准备着毕业答辩。将近 20 年的学生生涯即将结束，期待着顺利完成答辩，开始职场的生活。希望能够回到北京，见到那些很久没有见到的朋友。马上就要工作，开始自己独立的生活，希望自己之后的生活忙碌而有节奏，有机会的话也许可以认识我喜欢的人。</p><h3 id="还在世的人中你最钦佩的是谁？"><a href="#还在世的人中你最钦佩的是谁？" class="headerlink" title="还在世的人中你最钦佩的是谁？"></a><strong>还在世的人中你最钦佩的是谁？</strong></h3><p>Linus，开源软件之神。</p><h3 id="你认为自己最伟大的成就是什么？"><a href="#你认为自己最伟大的成就是什么？" class="headerlink" title="你认为自己最伟大的成就是什么？"></a><strong>你认为自己最伟大的成就是什么？</strong></h3><p>距今为止，没有什么伟大的成就。</p><p>希望自己以后能够做出一些有意义，有价值的事情。</p><h3 id="你自己的哪个特点让你最觉得痛恨？"><a href="#你自己的哪个特点让你最觉得痛恨？" class="headerlink" title="你自己的哪个特点让你最觉得痛恨？"></a><strong>你自己的哪个特点让你最觉得痛恨？</strong></h3><p>不够勇敢，不能勇敢地说出自己的喜欢。</p><h3 id="你最喜欢的旅行是哪一次？"><a href="#你最喜欢的旅行是哪一次？" class="headerlink" title="你最喜欢的旅行是哪一次？"></a><strong>你最喜欢的旅行是哪一次？</strong></h3><p>去年找完工作后，<code>Four Sum</code>一起的云南之旅。</p><p>经历了春天的找实习与夏天的找工作，确定完工作去向后，精神一下子放松下来，实验室的四个同学一起说走就走，去了大理和丽江。大理风光很美，苍山洱海，分外惬意；丽江古镇差强人意，玉龙雪山蓝月谷令人惊异。除了美丽的自然风光，主要还是当时四个人都轻松自在，潇洒自得。</p><p>大西南可以去很多次，还有大西北，期望以后有机会可以和自己喜欢的人一起去旅行。</p><h3 id="你最痛恨别人的什么特点？"><a href="#你最痛恨别人的什么特点？" class="headerlink" title="你最痛恨别人的什么特点？"></a><strong>你最痛恨别人的什么特点？</strong></h3><p>虚伪。</p><p>讨厌虚伪的客套，对真诚、聪明、对世界有热情的人自带好感。</p><h3 id="你最珍惜的财产是什么？"><a href="#你最珍惜的财产是什么？" class="headerlink" title="你最珍惜的财产是什么？"></a><strong>你最珍惜的财产是什么？</strong></h3><p>宝贵的时间，自由的灵魂。</p><h3 id="你最奢侈的是什么？"><a href="#你最奢侈的是什么？" class="headerlink" title="你最奢侈的是什么？"></a><strong>你最奢侈的是什么？</strong></h3><p>爱与被爱。</p><h3 id="你认为程度最浅的痛苦是什么？"><a href="#你认为程度最浅的痛苦是什么？" class="headerlink" title="你认为程度最浅的痛苦是什么？"></a><strong>你认为程度最浅的痛苦是什么？</strong></h3><p>不了解万千世界的痛苦。</p><h3 id="你认为哪种美德是被过高的评估的？"><a href="#你认为哪种美德是被过高的评估的？" class="headerlink" title="你认为哪种美德是被过高的评估的？"></a><strong>你认为哪种美德是被过高的评估的？</strong></h3><p>艰苦朴素，无私奉献。</p><p>哪里有那么多的无私，更多的是无奈与不舍。不是很喜欢新闻里面那些对于无私奉献广泛的宣传，我更喜欢那些给这些人优厚的物质与精神回报，并宣传之，比如最近的海尔救人小哥奖房的宣传我就挺喜欢的。</p><h3 id="你最喜欢的职业是什么？"><a href="#你最喜欢的职业是什么？" class="headerlink" title="你最喜欢的职业是什么？"></a><strong>你最喜欢的职业是什么？</strong></h3><p>工程师。</p><p>用自己的双手构建自己的世界。</p><h3 id="你对自己的外表哪一点不满意？"><a href="#你对自己的外表哪一点不满意？" class="headerlink" title="你对自己的外表哪一点不满意？"></a><strong>你对自己的外表哪一点不满意？</strong></h3><p>整体上挺满意的，就是之前脸上的痘痘让我有些烦恼。</p><p>不过，经过最近一段时间的调养，痘痘已经基本消失啦，接下来就是消除痘印了。</p><h3 id="你最后悔的事情是什么？"><a href="#你最后悔的事情是什么？" class="headerlink" title="你最后悔的事情是什么？"></a><strong>你最后悔的事情是什么？</strong></h3><p>做过很多后悔的事情，最后悔的还是与人相关。在不懂事的时候，说过一些令人伤心的话，尤其是对那些爱自己的人。现在想起来那些场景，脸上依然会不由自主的发烫。</p><h3 id="还在世的人中你最鄙视的是谁？"><a href="#还在世的人中你最鄙视的是谁？" class="headerlink" title="还在世的人中你最鄙视的是谁？"></a><strong>还在世的人中你最鄙视的是谁？</strong></h3><p>不太好说鄙视谁，鄙视那些身在其位不谋其政的人。</p><h3 id="你最喜欢男性身上的什么品质？"><a href="#你最喜欢男性身上的什么品质？" class="headerlink" title="你最喜欢男性身上的什么品质？"></a><strong>你最喜欢男性身上的什么品质？</strong></h3><p>大气。</p><p>待人接物落落大方，不卑不亢；处理事情自信沉稳，界限分明；对个人专业熟稔明晰，对不是自己的专业充满好奇心，能够积极主动的去了解；对爱的人温柔体贴，以真心告以真心。</p><h3 id="你使用过的最多的单词或者是词语是什么？"><a href="#你使用过的最多的单词或者是词语是什么？" class="headerlink" title="你使用过的最多的单词或者是词语是什么？"></a><strong>你使用过的最多的单词或者是词语是什么？</strong></h3><p>哈哈哈。</p><h3 id="你最喜欢女性身上的什么品质？"><a href="#你最喜欢女性身上的什么品质？" class="headerlink" title="你最喜欢女性身上的什么品质？"></a><strong>你最喜欢女性身上的什么品质？</strong></h3><p>我最喜欢女性的品质，是温柔与活泼、有自己的思考、善于沟通、具有爱人与被爱的能力。</p><h3 id="你最伤痛的事是什么？"><a href="#你最伤痛的事是什么？" class="headerlink" title="你最伤痛的事是什么？"></a><strong>你最伤痛的事是什么？</strong></h3><p>最伤痛的事情，莫过于全然付出的真心不被对方珍视吧。</p><h3 id="你最看重朋友的什么特点？"><a href="#你最看重朋友的什么特点？" class="headerlink" title="你最看重朋友的什么特点？"></a><strong>你最看重朋友的什么特点？</strong></h3><p>真诚、靠谱、乐观。</p><p>不喜欢虚伪滑头的人，也不喜欢一直悲悲戚戚的人。</p><h3 id="你这一生中最爱的人或东西是什么？"><a href="#你这一生中最爱的人或东西是什么？" class="headerlink" title="你这一生中最爱的人或东西是什么？"></a><strong>你这一生中最爱的人或东西是什么？</strong></h3><p>或许是我自己？</p><p>我希望我自己永远能够变得更好，也希望自己能够给自己爱的人带来更多的欢乐。</p><h3 id="你希望以什么样的方式死去？"><a href="#你希望以什么样的方式死去？" class="headerlink" title="你希望以什么样的方式死去？"></a><strong>你希望以什么样的方式死去？</strong></h3><p>我希望自己能够平平静静的走，就像睡着了那样，不要拖累自己的孩子们，也不要因为化疗等让自己万分痛苦。</p><p>另外，如果年老的时候我心爱的人在我身边时，我希望她能够走在我的前面，不要留她一个人在后面。</p><h3 id="如果你可以改变你的家庭一件事，那会是什么？"><a href="#如果你可以改变你的家庭一件事，那会是什么？" class="headerlink" title="如果你可以改变你的家庭一件事，那会是什么？"></a><strong>如果你可以改变你的家庭一件事，那会是什么？</strong></h3><p>如果可以改变的话，希望小时候爷爷和妈妈的关系能够好一些吧。两个人都很爱我，但是却因为爷爷的一些难以改变的观念，导致他们两人关系一直很差。即使如此，妈妈在爷爷走的时候仍然贴心的照顾他，如果之前关系能够好一些，那么小时候的家庭可以说很完美吧。</p><p>不过这些都是已经过去的事情了，现在家里的孩子都已经长大，爷爷已经离去。虽然不是大富大贵之家，小康家庭倒也过的很好，还记得爸妈为了家里能够过的更好一些而辛苦地工作，朴素的家庭条件也给我们留下了勤恳踏实的作风。</p><h3 id="如果你能选择的话，你希望让什么重现？"><a href="#如果你能选择的话，你希望让什么重现？" class="headerlink" title="如果你能选择的话，你希望让什么重现？"></a><strong>如果你能选择的话，你希望让什么重现？</strong></h3><p>爱。</p><p>现在仍然单身一人，希望能够找到一个自己喜欢，并且她也喜欢我的人。</p><h3 id="你的座右铭是什么？"><a href="#你的座右铭是什么？" class="headerlink" title="你的座右铭是什么？"></a><strong>你的座右铭是什么？</strong></h3><blockquote><p>我将融入剧烈争斗的大人世界，要在那边孤军奋战，必须变得比任何人都坚不可摧。</p></blockquote><p>倒也不是座右铭，一直没有明确的座右铭，只是正好看到这句话比较符合当前的心境罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间，距离上期「朝花夕拾」过去已经整整一月，昨天刚把毕业论文送审，心情稍微放松了些。在过去的一个月里，我从武汉来到了杭州，在老姐家里改完了论文，全国的疫情也即将清零。可以预见的是，在今年上半年的最后一个月，我将完成毕业论文线上答辩、返回学校办理毕业手续、在北京租房并开始职场生活。不能预见的是，毕业旅行是否还能成行？毕业典礼是否仍将举办? &lt;/p&gt;
&lt;p&gt;作为短暂的休息，「朝花夕拾」第十六期完成了自己的第一版普鲁斯特问卷。普鲁斯特问卷源于《追忆逝水年华》的作者马塞尔•普鲁斯特（Marcel Proust），其中包含一系列涉及到被提问者的生活、思想、价值观及人生经验的 28 个问题，可以较为全面地展示答卷者的价值观、兴趣爱好及特质。正值从学校向职场转变的时期，可以预见在未来几年自己对于这一系列问题的回答仍然会动态变化。这里是 2020 版，接下来日子里我每年都会给自己做一次普鲁斯特问卷，以此见证自己的变化与成长。也许未来再看，会是另一番感觉，最大的可能就是留下一堆黑历史吧：）&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-05-25_proustquestionnaire.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="价值观" scheme="http://houmin.cc/tags/%E4%BB%B7%E5%80%BC%E8%A7%82/"/>
    
      <category term="普鲁斯特问卷" scheme="http://houmin.cc/tags/%E6%99%AE%E9%B2%81%E6%96%AF%E7%89%B9%E9%97%AE%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>四月物语</title>
    <link href="http://houmin.cc/posts/43b91bee/"/>
    <id>http://houmin.cc/posts/43b91bee/</id>
    <published>2020-04-25T05:40:59.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。</p>    <div id="aplayer-wLsXUCAp" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="610725" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><p>最近在忙些啥？对，我在写论文，持续处于焦虑状态，期待能够早点写完，具体心情此处不表。夏天真的来了，眼见着窗外的杉树从冬日的灰冷，到春日的嫩绿，到现在的青翠。一转眼，已经在家呆了三个多月，冬日归来，到现在也不知何日返京。每天早上起来，听到窗外清脆的鸟叫声，会觉得这样每天在家的日子也很不错。但是，实际上这些天的状态并不是很好，毕业的焦虑，每天早上翻看着最新疫情的状况，期待着能够早点回到北京，早点回到正常的生活中。</p><p>然而，现实却告诉我，很有可能我们即将面临一种新常态了。在未来的一两年中，新冠可能将会持续潜伏在我们身边。这是一次真正引起全局性改变的疫情。作为毕业生，可以预见，北京应该会在五月份或者六月份让我们回去，可能只是收拾行李，毕业典礼之类的活动很可能都没了，真的是很难得的毕业季。</p><p>所有的这些，对我有什么影响？这些都是我所无力改变的现实，相比于父辈祖辈们所见识过的历史，这些都还只能算是开始。我能够做些什么呢？继续沉淀自己吧，好好的完成毕业论文，继续学习和总结。</p><p>等，春天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「四月物语」是岩井俊二拍摄的一部关于暗恋的纯爱电影，松隆子在里面很美，像那些洒落的樱花，像那把雨中的红伞。四月将尽，已是暮春，武汉的现存病例已经降到了 25 以下，清零将至。封面图是在写论文间歇拍摄的窗外场景，夏天已经跃跃欲试。&lt;/p&gt;

    &lt;div id=&quot;aplayer-wLsXUCAp&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;610725&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2020-04-25_beyond-the-window.jpg" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="春天" scheme="http://houmin.cc/tags/%E6%98%A5%E5%A4%A9/"/>
    
      <category term="新冠" scheme="http://houmin.cc/tags/%E6%96%B0%E5%86%A0/"/>
    
      <category term="新常态" scheme="http://houmin.cc/tags/%E6%96%B0%E5%B8%B8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>【备忘录】播客录</title>
    <link href="http://houmin.cc/posts/d7e805bd/"/>
    <id>http://houmin.cc/posts/d7e805bd/</id>
    <published>2020-04-18T12:30:31.000Z</published>
    <updated>2020-07-14T11:57:25.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。</p><a id="more"></a><h2 id="收听工具"><a href="#收听工具" class="headerlink" title="收听工具"></a>收听工具</h2><p>下面是收听 PodCast 常见的一些工具，目前我选用的是 Moon FM。</p><h3 id="Pocket-Casts-全平台的播客老字号"><a href="#Pocket-Casts-全平台的播客老字号" class="headerlink" title="Pocket Casts - 全平台的播客老字号"></a>Pocket Casts - 全平台的播客老字号</h3><p>有条件科学上网、不介意英文界面的朋友，用它绝不会错！</p><p>👍优点：</p><ul><li>目前Android体验第一梯队选手，比较推荐。</li><li>主流的播放功能很全，前进后退30s/变速/跳过空白/人声加强/定时关闭都有，还有比较罕见的手动Skipping Intros，给开头废话比较多的节目用上还挺爽的。</li><li>有数据统计功能，如果作为主力App的话很适合定期回顾做记录。</li><li>全平台可用，即使换了设备也不用转移收听数据。</li><li>设计好看，配色可自选，无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>英文界面，需要爬梯收听。推荐页几乎见不到中文播客。</li></ul><h3 id="Castbox-主攻海外市场的国产播客App"><a href="#Castbox-主攻海外市场的国产播客App" class="headerlink" title="Castbox - 主攻海外市场的国产播客App"></a>Castbox - 主攻海外市场的国产播客App</h3><p>适合有条件科学上网，且不打算用英文App的朋友。</p><p>如果你恰好有多种兴趣，还有查收听数据的习惯，那用它再好不过了！</p><p>👍优点：</p><ul><li>体验第一梯队的选手，比较推荐。</li><li>主流功能很全，除了Skipping Intros，Pocket Casts有的它都有。</li><li>Castbox支持自建多个播放列表，非常适合兴趣纷杂，喜欢在老节目里寻宝的听众。单集添加到播放列表就会自动下载，听完自动删除，顺滑极了。</li><li>可视化的数据统计也是一个亮点。除了收听总时长，还能看到过去一周的每日收听时长</li></ul><p>🤦‍♂️缺点：</p><ul><li>需要爬梯收听。主阵地在海外，所以推荐内容里英文浓度高。页面广告略多。</li></ul><h3 id="Spotify-正版流媒体音乐服务平台"><a href="#Spotify-正版流媒体音乐服务平台" class="headerlink" title="Spotify - 正版流媒体音乐服务平台"></a>Spotify - 正版流媒体音乐服务平台</h3><p>适合正好用Spotify听音乐的朋友，为了听播客而单独下载就不太值。</p><p>👍优点：</p><ul><li>毕竟是老牌音乐App，音频的基本功能它都有。登录后无广告。</li><li>如果你正好会使用Spotify听音乐，那顺带用它听播客就不错。</li></ul><p>🤦‍♂️缺点：</p><h3 id="Moon-FM-全平台的国产播客App"><a href="#Moon-FM-全平台的国产播客App" class="headerlink" title="Moon FM - 全平台的国产播客App"></a>Moon FM - 全平台的国产播客App</h3><p>对App颜值有高要求的朋友请一定试试它！</p><p>👍优点：</p><ul><li>去年新诞生的一个播客App，也是目前中文播客应用的佼佼者，对中文用户很友好。</li><li>页面灵巧又清爽，设计上是费了心的。好看的App提名必须有它。</li><li>有一定的发现功能。基础收听功能虽然比不上老牌应用全面，但变速、睡眠定时都有。</li><li>全平台可用。无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>交互逻辑比较小众，需要接受时间。没有前进后退30s。</li><li>发现功能仅限于精选播客，个性化推荐有待完善。</li></ul><h3 id="海盗电台-快速生长的国产播客App新面孔"><a href="#海盗电台-快速生长的国产播客App新面孔" class="headerlink" title="海盗电台 - 快速生长的国产播客App新面孔"></a>海盗电台 - 快速生长的国产播客App新面孔</h3><ul><li>适合已有一些常听节目的爱好者，给“听”换上更干净纯粹的工具。</li></ul><p>👍优点：</p><ul><li>开发者更新很积极，功能不断完善中，DarkMode也有了。</li><li>基础播放功能不错，除了前进后退30s、变速、睡眠定时，跳过空白的功能也已经有了。</li><li>因为是国产App，所以对中文用户很友好。</li><li>设计简洁舒适。无广告。</li></ul><p>🤦‍♂️缺点：</p><ul><li>暂无发现功能。一些基本功能也待完善，比如自动下载。</li></ul><h3 id="网易云-播客作为边角料"><a href="#网易云-播客作为边角料" class="headerlink" title="网易云 - 播客作为边角料"></a>网易云 - 播客作为边角料</h3><p>适合正好在用网易云听音乐，且固定只听几个播客节目的朋友。</p><p>👍优点：</p><ul><li>中文播客较全，播客主为了流量几乎都会上传。</li><li>沾了音乐区的光，播客的评论氛围还不错。</li><li>如果正好在用网易云听音乐，就不用多下一个app专门听播客了。</li></ul><p>🤦‍♂️缺点：</p><ul><li>我头一次听播客就是在网易云。当时是iOS的朋友锲而不舍推一档节目给我，而网易云给了我非常便利的起步。但在此之后很久，我都只听那一档播客。</li><li>原因很简单，网易云毕竟主业在音乐，播客作为非常边角的板块，甚至没有推荐功能，发现新节目纯靠搜索，也没有播客app的基础播放功能。</li></ul><h3 id="喜马拉雅-大而全的老牌泛音频平台"><a href="#喜马拉雅-大而全的老牌泛音频平台" class="headerlink" title="喜马拉雅 - 大而全的老牌泛音频平台"></a>喜马拉雅 - 大而全的老牌泛音频平台</h3><p>适合对界面简洁要求不高，希望多多发现中文播客节目的听众。</p><p>👍优点：</p><ul><li>中文播客较全，播客主为了流量几乎都会上传。</li><li>毕竟是老牌音频平台，应该是国产app中基础收听功能最全的，前进后退30s/变速/定时关闭/跳过头尾配齐了。</li><li>推荐功能对中文用户很友好，尤其发现相关播客的功能，对需要扩充收听列表的朋友来说很实用。</li><li>可以顺带听听有声书。</li></ul><p>🤦‍♂️缺点：</p><ul><li>页面真的有点繁杂。</li><li>不像别的平台广告只出现在屏幕上，喜马拉雅的片头片尾是有音频广告的，需要付费去除。</li><li>还有一点有些苛刻了，毕竟是目前播客app的通病：被推荐的来来回回就是几个头部节目，成长中的小众播客很难被发现。</li><li>荔枝、蜻蜓和喜马拉雅的情况非常相近。不再赘述。</li></ul><h2 id="收听栏目"><a href="#收听栏目" class="headerlink" title="收听栏目"></a>收听栏目</h2><p>正在尝试去探索一些比较知名的播客，等过段时间再来反馈。</p><h3 id="GQ-Talk"><a href="#GQ-Talk" class="headerlink" title="GQ Talk"></a>GQ Talk</h3><h3 id="忽左忽右"><a href="#忽左忽右" class="headerlink" title="忽左忽右"></a>忽左忽右</h3><h3 id="得意忘形"><a href="#得意忘形" class="headerlink" title="得意忘形"></a>得意忘形</h3><h3 id="内核恐慌"><a href="#内核恐慌" class="headerlink" title="内核恐慌"></a>内核恐慌</h3><h3 id="日谈公园"><a href="#日谈公园" class="headerlink" title="日谈公园"></a>日谈公园</h3><h3 id="面面相趣"><a href="#面面相趣" class="headerlink" title="面面相趣"></a>面面相趣</h3>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;p&gt;播客 PodCast 是一种自助广播形式，相对于传统广播的被动收听，播客可以让我们自由选择可以收听的内容，收听的时间以及形式。通过不同来源「新闻聚合」得到节目是 PodCast 收听的特色和主要吸引力。PodCast 一词来源于 iPod 和 BroadCast，开始于 2004年在互联网上用于发布音频文件。实际上，采用 PodCast 的技术也可以用来传送视频、相片和文本等文件。PodCast 被设计来用于订阅非现场信息，以 MP3 等多媒体文件的形式发布，便于订阅者离线收听。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://images-cosmos.s3-ap-southeast-1.amazonaws.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="好奇计划" scheme="http://houmin.cc/categories/%E5%A5%BD%E5%A5%87%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="podcast" scheme="http://houmin.cc/tags/podcast/"/>
    
      <category term="rss" scheme="http://houmin.cc/tags/rss/"/>
    
  </entry>
  
</feed>
