<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-09-17T08:10:52.683Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时序数据库 InfluxDB</title>
    <link href="http://houmin.cc/posts/c57001b4/"/>
    <id>http://houmin.cc/posts/c57001b4/</id>
    <published>2020-09-16T04:16:58.000Z</published>
    <updated>2020-09-17T08:10:52.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>InfluxDB 是使用 Go 编写的基于时间序列的数据库，用于存储大量带有时间戳的数据，报错 DevOps 监控，日志数据，应用程序的指标、数据分析数据等等。通过 InfluxDB 自动保存数据，你不需要删除和清理，只需要定义一段时间 DB 会帮你自动清理。</p><a id="more"></a><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>InfluxDB 和传统数据库（如：MySQL）的一些区别</p><div class="table-container"><table><thead><tr><th style="text-align:center">InfluxDB</th><th style="text-align:center">传统数据库中的概念</th></tr></thead><tbody><tr><td style="text-align:center">database</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">measurement</td><td style="text-align:center">数据库中的表</td></tr><tr><td style="text-align:center">points</td><td style="text-align:center">表里面的一行数据</td></tr></tbody></table></div><h3 id="特有概念"><a href="#特有概念" class="headerlink" title="特有概念"></a>特有概念</h3><ol><li><p>tag–标签，在 InfluxDB 中，tag 是一个非常重要的部分，表名+tag 一起作为数据库的索引，是“key-value”的形式</p></li><li><p>field–数据，field 主要是用来存放数据的部分，也是“key-value”的形式</p></li><li><p>timestamp–时间戳，作为时序型数据库，时间戳是 InfluxDB 中最重要的部分，在插入数据时可以自己指定也可留空让系统指定</p><p><strong>说明</strong>：<em>在插入新数据时，tag、field 和 timestamp 之间用空格分隔</em></p></li><li><p>series–序列，所有在数据库中的数据，都需要通过图表来展示，而这个 series 表示这个表里面的数据，可以在图表上画成几条线。具体可以通过 <code>SHOW SERIES FROM &quot;表名&quot;</code> 进行查询</p></li><li><p>Retention policy–数据保留策略，可以定义数据保留的时长，每个数据库可以有多个数据保留策略，但只能有一个默认策略</p></li><li><p>Point–点，表示每个表里某个时刻的某个条件下的一个 field 的数据，因为体现在图表上就是一个点，于是将其称为 point。Point 由时间戳（time）、数据（field）、标签（tags）组成</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">Point 属性</th><th style="text-align:center">传统数据库中的概念</th></tr></thead><tbody><tr><td style="text-align:center">time</td><td style="text-align:center">每个数据记录时间，是数据库中的主索引 (会自动生成)</td></tr><tr><td style="text-align:center">fields</td><td style="text-align:center">表中的列（没有索引的属性）也就是记录的值：温度， 湿度</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">表中的索引：地区，海拔</td></tr></tbody></table></div><h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><ul><li>8083：Web admin 管理服务的端口, <a href="http://localhost:8083/" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:8083</a></li><li>8086：HTTP API 的端口</li><li>8088：集群端口 (目前还不是很清楚, 配置在全局的 bind-address，默认不配置就是开启的)</li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">influxdb:1.7.4</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb-storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8086</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30004</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">influxdb</span></span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f influx.yaml</span><br><span class="line">$ kubectl get pod -n monitoring</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">influxdb-685854ccf7-mlr4g   1/1     Running   0          11m</span><br><span class="line">$ kubectl get svc -n monitoring</span><br><span class="line">NAME       TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">influxdb   NodePort   172.18.253.93   &lt;none&gt;        8086:30004/TCP   11m</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it influxdb-685854ccf7-mlr4g bash -n monitoring</span><br><span class="line">root@influxdb-685854ccf7-mlr4g:/<span class="comment"># influx</span></span><br><span class="line">Connected to http://localhost:8086 version 1.7.4</span><br><span class="line">InfluxDB shell version: 1.7.4</span><br><span class="line">Enter an InfluxQL query</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="客户端命令操作"><a href="#客户端命令操作" class="headerlink" title="客户端命令操作"></a>客户端命令操作</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>CREATE DATABASE {NAME};</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; create database houmin</span><br><span class="line">&gt; show databases</span><br><span class="line">name: databases</span><br><span class="line">name</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">_internal</span><br><span class="line">houmin</span><br></pre></td></tr></table></figure><ul><li>这时候我们发现数据库有一个表“_internal”，其实这个表是 influxdb 数据库的一些指标存储库。有点类似 mysql 数据库的 mysql 库。</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>DROP DATABASE {NAME};</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; drop database houmin</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>USE {DB}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use houmin</span><br><span class="line">Using database houmin</span><br></pre></td></tr></table></figure><h3 id="数据表和数据操作"><a href="#数据表和数据操作" class="headerlink" title="数据表和数据操作"></a>数据表和数据操作</h3><p>建库的操作可以发现非常类似于 MySQL 下的操作。而在 InfluxDB 下没有细分的表的概念，InfluxDB 下的表在插入数据库的时候自动会创建。可以通过 <code>show measurements</code> 命令查看所有的表，这个类似于 MySQL 下的<code>show tables</code></p><h4 id="显示所有表"><a href="#显示所有表" class="headerlink" title="显示所有表"></a>显示所有表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show measurements</span><br><span class="line">name: measurements</span><br><span class="line">name</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">cpu</span><br><span class="line">temperature</span><br></pre></td></tr></table></figure><h4 id="新建表（写数据）"><a href="#新建表（写数据）" class="headerlink" title="新建表（写数据）"></a>新建表（写数据）</h4><p>标准格式，注意在写数据的时候如果不添加时间戳，系统会默认添加一个时间。InfluxDB 中没有显式的新建表的语句，只能通过 insert 数据的方式来建立新表。</p><ul><li>语法格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> &lt;measurement&gt;[,&lt;tag-<span class="keyword">key</span>&gt;=&lt;tag-<span class="keyword">value</span>&gt;...] &lt;<span class="keyword">field</span>-<span class="keyword">key</span>&gt;=&lt;<span class="keyword">field</span>-<span class="keyword">value</span>&gt;[,&lt;field2-<span class="keyword">key</span>&gt;=&lt;field2-<span class="keyword">value</span>&gt;...] [unix-nano-<span class="built_in">timestamp</span>]</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT cpu,host=serverA,region=us_west value=0.64</span><br><span class="line"></span><br><span class="line">&gt; INSERT temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; drop measurement disk_free</span><br><span class="line">&gt; show measurements</span><br><span class="line">name: measurements</span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line">name</span><br><span class="line">weather</span><br></pre></td></tr></table></figure><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>查询语句与 SQL 一样，不用过多的学习</p><ul><li>查询数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT "host", "region", "value" FROM "cpu"</span><br><span class="line">name: cpu</span><br><span class="line">time                host    region  value</span><br><span class="line"><span class="comment">----                ----    ------  -----</span></span><br><span class="line">1600221790602821979 serverA us_west 0.64</span><br></pre></td></tr></table></figure><ul><li>每个表输出一行（支持 Go 语言的正则表达式、支持类似于 MySQL 中的 limit 语句）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM /.*/ LIMIT 1</span><br><span class="line">name: cpu</span><br><span class="line">time                external host    internal machine region  type value</span><br><span class="line"><span class="comment">----                -------- ----    -------- ------- ------  ---- -----</span></span><br><span class="line">1563895618490964877          serverA                  us_west      0.64</span><br><span class="line"></span><br><span class="line">name: temperature</span><br><span class="line">time                external host internal machine region type     value</span><br><span class="line"><span class="comment">----                -------- ---- -------- ------- ------ ----     -----</span></span><br><span class="line">1434067467000000000 25            37       unit42         assembly</span><br></pre></td></tr></table></figure><h4 id="修改和删除数据"><a href="#修改和删除数据" class="headerlink" title="修改和删除数据"></a>修改和删除数据</h4><p>InfluxDB 属于时序数据库，没有提供修改和删除数据的方法。</p><p>但是删除可以通过 InfluxDB 的数据保存策略（Retention Policies）来实现</p><p>update 更新语句没有，不过有 alter 命令，在 influxdb 中，删除操作用和更新基本不用到 。在针对数据保存策略方面，有一个特殊的删除方式，这个后面再提。</p><h3 id="series-操作"><a href="#series-操作" class="headerlink" title="series 操作"></a>series 操作</h3><p>series 表示这个表里面的数据，可以在图表上画成几条线，series 主要通过 tags 排列组合算出来。</p><p>我们可以查询表的 series，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; show series from cpu</span><br><span class="line">key</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">cpu,host=serverA,region=us_east</span><br><span class="line">cpu,host=serverA,region=us_west</span><br><span class="line">cpu,host=serverX,region=us_east</span><br><span class="line">cpu,host=serverX,region=us_west</span><br></pre></td></tr></table></figure><h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示用户</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">USERS</span></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">"username"</span> <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'password'</span></span><br><span class="line"><span class="comment"># 创建管理员权限的用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">"username"</span> <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'password'</span> <span class="keyword">WITH</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">"username"</span></span><br></pre></td></tr></table></figure><p>influxdb 的权限设置比较简单，只有读、写、ALL 几种。</p><h2 id="HTTP-API-操作"><a href="#HTTP-API-操作" class="headerlink" title="HTTP API 操作"></a>HTTP API 操作</h2><h3 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h3><div class="table-container"><table><thead><tr><th>接口路径</th><th>描述</th></tr></thead><tbody><tr><td>/debug/pprof</td><td>debug 排查问题使用</td></tr><tr><td>/debug/requests</td><td>使用这个请求监听最近是否有请求</td></tr><tr><td>/debug/vars</td><td>查询 influxdb 收集到静态信息</td></tr><tr><td>/ping</td><td>检测 influxdb 状态</td></tr><tr><td>/query</td><td>查询数据接口（同时可以创建库）</td></tr><tr><td>/write</td><td>写入数据接口（一个已存在数据库）</td></tr></tbody></table></div><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>2xx：服务请求正常</li><li>4xx：代表请求语法有问题</li><li>5xx：服务端出问题，导致超时等故障</li></ul><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -XPOST http://localhost:8086/query --data-urlencode <span class="string">"q=CREATE DATABASE mydb"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 5edd88a8-ef90-11e8-83cd-a0999b0f94e3</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.0~n201811230800</span><br><span class="line">X-Request-Id: 5edd88a8-ef90-11e8-83cd-a0999b0f94e3</span><br><span class="line">Date: Sat, 24 Nov 2018 02:26:38 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">&#123;<span class="string">"results"</span>:[&#123;<span class="string">"statement_id"</span>:0&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i  -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary <span class="string">'cpu_load_short,host=server01,region=us-west value=0.65 1434055564000000000'</span></span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 1ae386c4-ef91-11e8-83d8-a0999b0f94e3</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.0~n201811230800</span><br><span class="line">X-Request-Id: 1ae386c4-ef91-11e8-83d8-a0999b0f94e3</span><br><span class="line">Date: Sat, 24 Nov 2018 02:31:53 GMT</span><br></pre></td></tr></table></figure><h3 id="写入多个数据点"><a href="#写入多个数据点" class="headerlink" title="写入多个数据点"></a>写入多个数据点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary <span class="string">'cpu_load_short,host=server02 value=0.67</span></span><br><span class="line"><span class="string">HTTP/1.1 204 No Content</span></span><br><span class="line"><span class="string">Content-Type: application/json</span></span><br><span class="line"><span class="string">Request-Id: 086bd107-f7c3-11ea-803c-3a3192636d64</span></span><br><span class="line"><span class="string">X-Influxdb-Build: OSS</span></span><br><span class="line"><span class="string">X-Influxdb-Version: 1.7.4</span></span><br><span class="line"><span class="string">X-Request-Id: 086bd107-f7c3-11ea-803c-3a3192636d64</span></span><br><span class="line"><span class="string">Date: Wed, 16 Sep 2020 02:19:22 GMT</span></span><br></pre></td></tr></table></figure><h3 id="从文件导入数据库"><a href="#从文件导入数据库" class="headerlink" title="从文件导入数据库"></a>从文件导入数据库</h3><p>从文件导入时候建议不要超过 5000 条，如果超过请对文件进行切割，因为 http api 的接口 5s 会超时，请求数据过多会导致数据无法确认是否成功。<br>文件 cpu_data.txt 内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu_data.txt</span><br><span class="line">cpu_load_short,host=server02 value=111</span><br><span class="line">cpu_load_short,host=server02,region=us-west value=0.222 1543027130702900257</span><br><span class="line">cpu_load_short,direction=<span class="keyword">in</span>,host=server01,region=us-west value=111.222 1543027129702900257</span><br><span class="line">$ curl -i -XPOST <span class="string">'http://localhost:8086/write?db=mydb'</span> --data-binary @cpu_data.txt</span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request-Id: 40022e79-f7c3-11ea-803d-3a3192636d64</span><br><span class="line">X-Influxdb-Build: OSS</span><br><span class="line">X-Influxdb-Version: 1.7.4</span><br><span class="line">X-Request-Id: 40022e79-f7c3-11ea-803d-3a3192636d64</span><br><span class="line">Date: Wed, 16 Sep 2020 02:20:55 GMT</span><br></pre></td></tr></table></figure><h2 id="数据保存策略（Retention-Policies）"><a href="#数据保存策略（Retention-Policies）" class="headerlink" title="数据保存策略（Retention Policies）"></a>数据保存策略（Retention Policies）</h2><p>InfluxDB 每秒可以处理成千上万条数据，要将这些数据全部保存下来会占用大量的存储空间，有时我们可能并不需要将所有历史数据进行存储。InfluxDB 没有提供直接删除 Points 的方法，但是它提供了 Retention Policies，用来让我们自定义数据的保留时间。</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">RETENTION</span> POLICIES <span class="keyword">ON</span> <span class="string">"testDB"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">show</span> <span class="keyword">retention</span> policies <span class="keyword">on</span> <span class="string">"mydb"</span></span><br><span class="line"><span class="keyword">name</span>    <span class="keyword">duration</span> shardGroupDuration replicaN <span class="keyword">default</span></span><br><span class="line"><span class="comment">----    -------- ------------------ -------- -------</span></span><br><span class="line">autogen <span class="number">0</span>s       <span class="number">168</span>h0m0s           <span class="number">1</span>        <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">RETENTION</span> <span class="keyword">POLICY</span> <span class="string">"rp_name"</span> <span class="keyword">ON</span> <span class="string">"db_name"</span> <span class="keyword">DURATION</span> <span class="number">30</span>d <span class="keyword">REPLICATION</span> <span class="number">1</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>rp_name：策略名</li><li>db_name：具体的数据库名</li><li>30d：保存 30 天，30 天之前的数据将被删除<br>它具有各种时间参数，比如：h（小时），w（星期）</li><li>REPLICATION 1：副本个数，这里填 1 就可以了</li><li>DEFAULT 设为默认的策略</li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER RETENTION<span class="built_in"> POLICY </span><span class="string">"rp_name"</span> ON db_name<span class="string">" DURATION 3w DEFAULT</span></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP RETENTION<span class="built_in"> POLICY </span><span class="string">"rp_name"</span> ON <span class="string">"db_name"</span></span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>InfluxDB 提供了很多的有用的函数，这里列举了常用的三个维度函数，Use InfluxQL functions to aggregate, select, and transform data.</p><div class="table-container"><table><thead><tr><th>Aggregations</th><th>Selectors</th><th>Transformations</th></tr></thead><tbody><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#count" target="_blank" rel="external nofollow noopener noreferrer">COUNT()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#bottom" target="_blank" rel="external nofollow noopener noreferrer">BOTTOM()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#ceiling" target="_blank" rel="external nofollow noopener noreferrer">CEILING()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#distinct" target="_blank" rel="external nofollow noopener noreferrer">DISTINCT()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#first" target="_blank" rel="external nofollow noopener noreferrer">FIRST()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="external nofollow noopener noreferrer">DERIVATIVE()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#integral" target="_blank" rel="external nofollow noopener noreferrer">INTEGRAL()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#last" target="_blank" rel="external nofollow noopener noreferrer">LAST()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#difference" target="_blank" rel="external nofollow noopener noreferrer">DIFFERENCE()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#mean" target="_blank" rel="external nofollow noopener noreferrer">MEAN()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#max" target="_blank" rel="external nofollow noopener noreferrer">MAX()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#elapsed" target="_blank" rel="external nofollow noopener noreferrer">ELAPSED()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#median" target="_blank" rel="external nofollow noopener noreferrer">MEDIAN()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#min" target="_blank" rel="external nofollow noopener noreferrer">MIN()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#floor" target="_blank" rel="external nofollow noopener noreferrer">FLOOR()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#spread" target="_blank" rel="external nofollow noopener noreferrer">SPREAD()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#percentile" target="_blank" rel="external nofollow noopener noreferrer">PERCENTILE()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#histogram" target="_blank" rel="external nofollow noopener noreferrer">HISTOGRAM()</a></td></tr><tr><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#sum" target="_blank" rel="external nofollow noopener noreferrer">SUM()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#top" target="_blank" rel="external nofollow noopener noreferrer">TOP()</a></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#moving-average" target="_blank" rel="external nofollow noopener noreferrer">MOVING_AVERAGE()</a></td></tr><tr><td></td><td></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#non-negative-derivative" target="_blank" rel="external nofollow noopener noreferrer">NON_NEGATIVE_DERIVATIVE()</a></td></tr><tr><td></td><td></td><td><a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#stddev" target="_blank" rel="external nofollow noopener noreferrer">STDDEV()</a></td></tr></tbody></table></div><h3 id="聚合类函数"><a href="#聚合类函数" class="headerlink" title="聚合类函数"></a>聚合类函数</h3><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT() 函数"></a>COUNT() 函数</h4><p>返回一个（field）字段中的非空值的数量。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(water<span class="emphasis">_level) FROM h2o_</span>feet</span><br><span class="line">name: h2o<span class="emphasis">_feet</span></span><br><span class="line"><span class="emphasis">--------------</span></span><br><span class="line"><span class="emphasis">time                           count</span></span><br><span class="line"><span class="emphasis">1970-01-01T00:00:00Z     15258</span></span><br></pre></td></tr></table></figure><p>说明 water_level 这个字段在 h2o_feet 表中共有 15258 条数据。</p><p>注意：InfluxDB 中的函数如果没有指定时间的话，会默认以 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间。</p><p>可以在 where 中加入时间条件，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(water_level) FROM h2o_feet WHERE time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-09-18T17:00:00Z' GROUP BY time(4d)</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           count</span><br><span class="line">2015-08-17T00:00:00Z     1440</span><br><span class="line">2015-08-21T00:00:00Z     1920</span><br><span class="line">2015-08-25T00:00:00Z     1920</span><br><span class="line">2015-08-29T00:00:00Z     1920</span><br><span class="line">2015-09-02T00:00:00Z     1915</span><br><span class="line">2015-09-06T00:00:00Z     1920</span><br><span class="line">2015-09-10T00:00:00Z     1920</span><br><span class="line">2015-09-14T00:00:00Z     1920</span><br><span class="line">2015-09-18T00:00:00Z     335</span><br></pre></td></tr></table></figure><h4 id="DISTINCT-函数"><a href="#DISTINCT-函数" class="headerlink" title="DISTINCT() 函数"></a>DISTINCT() 函数</h4><p>返回一个字段（field）的唯一值。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DISTINCT("level description") FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           distinct</span><br><span class="line">1970-01-01T00:00:00Z     between 6 and 9 feet</span><br><span class="line">1970-01-01T00:00:00Z     below 3 feet</span><br><span class="line">1970-01-01T00:00:00Z     between 3 and 6 feet</span><br><span class="line">1970-01-01T00:00:00Z     at or greater than 9 feet</span><br></pre></td></tr></table></figure><p>这个例子显示 level description 这个字段共有四个值，然后将其显示了出来，时间为默认时间。</p><h4 id="MEAN-函数"><a href="#MEAN-函数" class="headerlink" title="MEAN() 函数"></a>MEAN() 函数</h4><p>返回一个字段（field）中的值的算术平均值（平均值）。字段类型必须是长整型或 float64。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MEAN(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEAN(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           mean</span><br><span class="line">1970-01-01T00:00:00Z     4.286791371454075</span><br></pre></td></tr></table></figure><p>说明 water_level 字段的平均值为<code>4.286791371454075</code>，时间为默认时间，当然，你也可以加入 where 条件。</p><h4 id="MEDIAN-函数"><a href="#MEDIAN-函数" class="headerlink" title="MEDIAN() 函数"></a>MEDIAN() 函数</h4><p>从单个字段（field）中的排序值返回中间值（中位数）。字段值的类型必须是长整型或 float64 格式。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MEDIAN</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEDIAN(water_level) from h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           median</span><br><span class="line">1970-01-01T00:00:00Z     4.124</span><br></pre></td></tr></table></figure><p>说明表中 water_level 字段的中位数是 4.124</p><h4 id="SPREAD-函数"><a href="#SPREAD-函数" class="headerlink" title="SPREAD() 函数"></a>SPREAD() 函数</h4><p>返回字段的最小值和最大值之间的差值。数据的类型必须是长整型或 float64。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SPREAD(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT SPREAD(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            spread</span><br><span class="line">1970-01-01T00:00:00Z      10.574</span><br></pre></td></tr></table></figure><h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM() 函数"></a>SUM() 函数</h4><p>返回一个字段中的所有值的和。字段的类型必须是长整型或 float64。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT SUM(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           sum</span><br><span class="line">1970-01-01T00:00:00Z     67777.66900000002</span><br></pre></td></tr></table></figure><p>此语句计算出了 h2o_feet 表中 所有 water_level 字段的和。</p><h3 id="选择类函数"><a href="#选择类函数" class="headerlink" title="选择类函数"></a>选择类函数</h3><h4 id="TOP-函数"><a href="#TOP-函数" class="headerlink" title="TOP() 函数"></a>TOP() 函数</h4><p>作用：返回一个字段中最大的 N 个值，字段类型必须是长整型或 float64 类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT TOP("water_level",3) FROM "h2o_feet"</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">time                   top</span><br><span class="line"><span class="comment">----                   ---</span></span><br><span class="line">2015-08-29T07:18:00Z   9.957</span><br><span class="line">2015-08-29T07:24:00Z   9.964</span><br><span class="line">2015-08-29T07:30:00Z   9.954</span><br></pre></td></tr></table></figure><p>这个例子返回表中 water_level 字段中最大的三个值。</p><h4 id="BOTTOM-函数"><a href="#BOTTOM-函数" class="headerlink" title="BOTTOM() 函数"></a>BOTTOM() 函数</h4><p>作用：返回一个字段中最小的 N 个值。字段类型必须是长整型或 float64 类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BOTTOM(&lt;field_key&gt;[,&lt;tag_keys&gt;],&lt;N&gt;)[,&lt;tag_keys&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           bottom</span><br><span class="line">2015-08-29T14:30:00Z     -0.61</span><br><span class="line">2015-08-29T14:36:00Z     -0.591</span><br><span class="line">2015-08-30T15:18:00Z     -0.594</span><br></pre></td></tr></table></figure><p>这个例子返回表中 water_level 字段中最小的三个值。</p><p>也可将关联 tag 放在一起查询，但如果 tag 值少于 N 的值，则返回的值的个数只会取 tag 中字段值少的那个。</p><p>如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,location,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           bottom     location</span><br><span class="line">2015-08-29T10:36:00Z     -0.243     santa_monica</span><br><span class="line">2015-08-29T14:30:00Z     -0.61      coyote_creek</span><br></pre></td></tr></table></figure><p>语句取最小的三个值，然而结果只返回了 2 个值，因为 location 这个 tag 只有 两个取值。</p><h4 id="FIRST-函数"><a href="#FIRST-函数" class="headerlink" title="FIRST() 函数"></a>FIRST() 函数</h4><p>作用：返回一个字段中最老的取值。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT FIRST(water_level) FROM h2o_feet WHERE location = 'santa_monica'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           first</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br></pre></td></tr></table></figure><p>这个语句返回了 在 location 为 santa_monica 条件下，最旧的那个 water_level 字段的取值和时间。</p><h4 id="LAST-函数"><a href="#LAST-函数" class="headerlink" title="LAST() 函数"></a>LAST() 函数</h4><p>作用：返回一个字段中最新的取值。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT LAST(water_level),location FROM h2o_feet WHERE time &gt;= '2015-08-18T00:42:00Z' and time &lt;= '2015-08-18T00:54:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           last      location</span><br><span class="line">2015-08-18T00:54:00Z     6.982     coyote_creek</span><br></pre></td></tr></table></figure><h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX() 函数"></a>MAX() 函数</h4><p>作用：返回一个字段中的最大值。该字段类型必须是长整型，float64，或布尔类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MAX(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           max       location</span><br><span class="line">2015-08-29T07:24:00Z     9.964     coyote_creek</span><br></pre></td></tr></table></figure><h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN() 函数"></a>MIN() 函数</h4><p>作用：返回一个字段中的最小值。该字段类型必须是长整型，float64，或布尔类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MIN(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                          min       location</span><br><span class="line">2015-08-29T14:30:00Z    -0.61     coyote_creek</span><br></pre></td></tr></table></figure><h4 id="PERCENTILE-函数"><a href="#PERCENTILE-函数" class="headerlink" title="PERCENTILE() 函数"></a>PERCENTILE() 函数</h4><p>作用：返回排序值排位为 N 的百分值。字段的类型必须是长整型或 float64。</p><p>百分值是介于 100 到 0 之间的整数或浮点数，包括 100。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;] <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT PERCENTILE(water_level,5),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                      percentile     location</span><br><span class="line">2015-08-28T12:06:00Z      1.122             santa_monica</span><br></pre></td></tr></table></figure><p>就是将 water_level 字段按照不同的 location 求百分比，然后取第五位数据。</p><h3 id="变换类函数"><a href="#变换类函数" class="headerlink" title="变换类函数"></a>变换类函数</h3><h4 id="DERIVATIVE-函数"><a href="#DERIVATIVE-函数" class="headerlink" title="DERIVATIVE() 函数"></a>DERIVATIVE() 函数</h4><p>作用：返回一个字段在一个 series 中的变化率。</p><p>InfluxDB 会计算按照时间进行排序的字段值之间的差异，并将这些结果转化为单位变化率。其中，单位可以指定，默认为 1s。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>其中，<code>unit</code>取值可以为以下几种：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u <span class="comment">--microseconds</span></span><br><span class="line">s <span class="comment">--seconds</span></span><br><span class="line">m <span class="comment">--minutes</span></span><br><span class="line">h <span class="comment">--hours</span></span><br><span class="line">d <span class="comment">--days</span></span><br><span class="line">w <span class="comment">--weeks</span></span><br></pre></td></tr></table></figure><p>DERIVATIVE() 函数还可以在 GROUP BY time() 的条件下与聚合函数嵌套使用，格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure><p>示例：</p><p>假设 location = santa_monica 条件下数据有以下几条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           water_level</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br><span class="line">2015-08-18T00:06:00Z     2.116</span><br><span class="line">2015-08-18T00:12:00Z     2.028</span><br><span class="line">2015-08-18T00:18:00Z     2.126</span><br><span class="line">2015-08-18T00:24:00Z     2.041</span><br><span class="line">2015-08-18T00:30:00Z     2.051</span><br></pre></td></tr></table></figure><p>计算每一秒的变化率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.00014444444444444457</span><br><span class="line">2015-08-18T00:12:00Z     -0.00024444444444444465</span><br><span class="line">2015-08-18T00:18:00Z     0.0002722222222222218</span><br><span class="line">2015-08-18T00:24:00Z     -0.000236111111111111</span><br><span class="line">2015-08-18T00:30:00Z     2.777777777777842e-05</span><br></pre></td></tr></table></figure><p>第一行数据的计算公式为<code>(2.116 - 2.064) / (360s / 1s)</code></p><p>计算每六分钟的变化率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,6m) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z     -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z     0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z     -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z     0.010000000000000231</span><br></pre></td></tr></table></figure><p>第一行数据的计算过程如下：<code>(2.116 - 2.064) / (6m / 6m)</code></p><p>计算每 12 分钟的变化率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,12m) FROM h2o_feet WHERE location = 'santa_monica' LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.10400000000000009</span><br><span class="line">2015-08-18T00:12:00Z     -0.17600000000000016</span><br><span class="line">2015-08-18T00:18:00Z     0.19599999999999973</span><br><span class="line">2015-08-18T00:24:00Z     -0.16999999999999993</span><br><span class="line">2015-08-18T00:30:00Z     0.020000000000000462</span><br></pre></td></tr></table></figure><p>第一行数据计算过程为：<code>(2.116 - 2.064 / (6m / 12m)</code></p><p>计算每 12 分钟最大值的变化率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(MAX(water_level)) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-08-18T00:36:00Z' GROUP BY time(12m)</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:12:00Z     0.009999999999999787</span><br><span class="line">2015-08-18T00:24:00Z     -0.07499999999999973</span><br></pre></td></tr></table></figure><p>这个函数功能非常多，也非常复杂，更多对于此功能的详细解释请看官网：<a href="https://www.linuxdaxue.com/wp-content/themes/template/inc/go.php?url=https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="external nofollow noopener noreferrer">https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative</a></p><h4 id="DIFFERENCE-函数"><a href="#DIFFERENCE-函数" class="headerlink" title="DIFFERENCE() 函数"></a>DIFFERENCE() 函数</h4><p>作用：返回一个字段中连续的时间值之间的差异。字段类型必须是长整型或 float64。</p><p>最基本的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DIFFERENCE</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>与 GROUP BY time() 以及其他嵌套函数一起使用的语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DIFFERENCE</span>(&lt;<span class="keyword">function</span>&gt;(&lt;field_key&gt;)) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure><p>其中，函数可以包含以下几个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(), MEAN(), MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), 和 PERCENTILE()</span><br></pre></td></tr></table></figure><p>使用示例</p><p>例子中使用的源数据如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location='santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure><p>计算<code>water_level</code>间的差异：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DIFFERENCE(water_level) FROM h2o_feet WHERE location='santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            difference</span><br><span class="line">2015-08-18T00:06:00Z      0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z      -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z      0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z      -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z      0.010000000000000231</span><br><span class="line">2015-08-18T00:36:00Z      0.016000000000000014</span><br></pre></td></tr></table></figure><p>数据类型都为 float 类型。</p><h4 id="ELAPSED-函数"><a href="#ELAPSED-函数" class="headerlink" title="ELAPSED() 函数"></a>ELAPSED() 函数</h4><p>作用：返回一个字段在连续的时间间隔间的差异，间隔单位可选，默认为 1 纳秒。</p><p>单位可选项如下：</p><div class="table-container"><table><thead><tr><th>Units</th><th>Meaning</th></tr></thead><tbody><tr><td>ns</td><td>nanoseconds (1 billionth of a second)</td></tr><tr><td>u or µ</td><td>microseconds (1 millionth of a second)</td></tr><tr><td>ms</td><td>milliseconds (1 thousandth of a second)</td></tr><tr><td>s</td><td>second</td></tr><tr><td>m</td><td>minute</td></tr><tr><td>h</td><td>hour</td></tr><tr><td>d</td><td>day</td></tr><tr><td>w</td><td>week</td></tr></tbody></table></div><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ELAPSED(&lt;field_key&gt;, &lt;unit&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><p>计算 h2o_feet 字段在纳秒间隔下的差异。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      360000000000</span><br><span class="line">2015-08-18T00:12:00Z      360000000000</span><br><span class="line">2015-08-18T00:18:00Z      360000000000</span><br><span class="line">2015-08-18T00:24:00Z      360000000000</span><br></pre></td></tr></table></figure><p>在一分钟间隔下的差异率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1m) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      6</span><br><span class="line">2015-08-18T00:12:00Z      6</span><br><span class="line">2015-08-18T00:18:00Z      6</span><br><span class="line">2015-08-18T00:24:00Z      6</span><br></pre></td></tr></table></figure><p>注意：如果设置的时间间隔比字段数据间的时间间隔更大时，则函数会返回 0，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1h) FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:24:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      0</span><br><span class="line">2015-08-18T00:12:00Z      0</span><br><span class="line">2015-08-18T00:18:00Z      0</span><br><span class="line">2015-08-18T00:24:00Z      0</span><br></pre></td></tr></table></figure><h4 id="MOVING-AVERAGE-函数"><a href="#MOVING-AVERAGE-函数" class="headerlink" title="MOVING_AVERAGE() 函数"></a>MOVING_AVERAGE() 函数</h4><p>作用：返回一个连续字段值的移动平均值，字段类型必须是长整形或者 float64 类型。</p><p>语法：</p><p>基本语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOVING_AVERAGE(&lt;field_key&gt;,&lt;<span class="keyword">window</span>&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>与其他函数和 GROUP BY time() 语句一起使用时的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MOVING_AVERAGE(&lt;<span class="keyword">function</span>&gt;(&lt;field_key&gt;),&lt;<span class="keyword">window</span>&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure><p>此函数可以和以下函数一起使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(), MEAN(),MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), and PERCENTILE().</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location = 'santa_monica' AND time &gt;= '2015-08-18T00:00:00Z' and time &lt;= '2015-08-18T00:36:00Z'</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure><h4 id="NON-NEGATIVE-DERIVATIVE-函数"><a href="#NON-NEGATIVE-DERIVATIVE-函数" class="headerlink" title="NON_NEGATIVE_DERIVATIVE() 函数"></a>NON_NEGATIVE_DERIVATIVE() 函数</h4><p>作用：返回在一个 series 中的一个字段中值的变化的非负速率。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NON_NEGATIVE_DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>其中 unit 取值可以为以下几个：</p><p>Valid time specifications for <code>unit</code> are:</p><ul><li><code>u</code> microseconds</li><li><code>s</code> seconds</li><li><code>m</code> minutes</li><li><code>h</code> hours</li><li><code>d</code> days</li><li><code>w</code> weeks</li></ul><p>与聚合类函数放在一起使用时的语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NON_NEGATIVE_DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) <span class="keyword">FROM</span> &lt;measurement_name&gt; <span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure><p>此函数示例请参阅：<a href="https://www.linuxdaxue.com/influxdb-study-influxdb-transformations-funcitons.html#title-0" target="_blank" rel="external nofollow noopener noreferrer">DERIVATIVE()</a>``函数</p><h4 id="STDDEV-函数"><a href="#STDDEV-函数" class="headerlink" title="STDDEV() 函数"></a>STDDEV() 函数</h4><p>作用：返回一个字段中的值的标准偏差。值的类型必须是长整型或 float64 类型。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STDDEV</span>(&lt;field_key&gt;) <span class="keyword">FROM</span> &lt;measurement_name&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">stuff</span>&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">time                           stddev</span><br><span class="line">1970-01-01T00:00:00Z     2.279144584196145</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet WHERE time &gt;= '2015-08-18T00:00:00Z' and time &lt; '2015-09-18T12:06:00Z' GROUP BY time(1w), location</span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = coyote_creek</span><br><span class="line">time                           stddev</span><br><span class="line"><span class="comment">----                           ------</span></span><br><span class="line">2015-08-13T00:00:00Z     2.2437263080193985</span><br><span class="line">2015-08-20T00:00:00Z     2.121276150144719</span><br><span class="line">2015-08-27T00:00:00Z     3.0416122170786215</span><br><span class="line">2015-09-03T00:00:00Z     2.5348065025435207</span><br><span class="line">2015-09-10T00:00:00Z     2.584003954882673</span><br><span class="line">2015-09-17T00:00:00Z     2.2587514836274414</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = santa_monica</span><br><span class="line">time                           stddev</span><br><span class="line"><span class="comment">----                           ------</span></span><br><span class="line">2015-08-13T00:00:00Z     1.11156344587553</span><br><span class="line">2015-08-20T00:00:00Z     1.0909849279082366</span><br><span class="line">2015-08-27T00:00:00Z     1.9870116180096962</span><br><span class="line">2015-09-03T00:00:00Z     1.3516778450902067</span><br><span class="line">2015-09-10T00:00:00Z     1.4960573811500588</span><br><span class="line">2015-09-17T00:00:00Z     1.075701669442093</span><br></pre></td></tr></table></figure><h2 id="连续查询"><a href="#连续查询" class="headerlink" title="连续查询"></a>连续查询</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>InfluxDB 的连续查询是在数据库中自动定时启动的一组语句，语句中必须包含 <code>SELECT</code>关键词和<code>GROUP BY time()</code>关键词。</p><p>InfluxDB 会将查询结果放在指定的数据表中。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>使用连续查询是最优的降低采样率的方式，连续查询和存储策略搭配使用将会大大降低 InfluxDB 的系统占用量。</p><p>而且使用连续查询后，数据会存放到指定的数据表中，这样就为以后统计不同精度的数据提供了方便。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>只有管理员用户可以操作连续查询。</p><p>1）新建连续查询</p><p>新建连续查询的语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt; </span><br><span class="line">[RESAMPLE [EVERY &lt;<span class="built_in">interval</span>&gt;] [<span class="keyword">FOR</span> &lt;<span class="built_in">interval</span>&gt;]] </span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)] <span class="keyword">INTO</span> &lt;different_measurement&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;current_measurement&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;<span class="built_in">interval</span>&gt;)[,&lt;<span class="keyword">stuff</span>&gt;] </span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>查询部分被 CREATE CONTINUOUS QUERY […] BEGIN 和 END 所包含，主要的逻辑代码也是在这一部分。</p><p>使用示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">CREATE</span> CONTINUOUS QUERY cq_30m <span class="keyword">ON</span> telegraf <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> mean(used) <span class="keyword">INTO</span> mem_used_30m <span class="keyword">FROM</span> mem <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br><span class="line">&gt; <span class="keyword">SHOW</span> CONTINUOUS QUERIES</span><br><span class="line"><span class="type">name</span>: telegraf</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="type">name</span>    query</span><br><span class="line">cq_30m    <span class="keyword">CREATE</span> CONTINUOUS QUERY cq_30m <span class="keyword">ON</span> telegraf <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> mean(used) <span class="keyword">INTO</span> telegraf."default".mem_used_30m <span class="keyword">FROM</span> telegraf."default".mem </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">name</span>: _internal</span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"><span class="type">name</span>    query</span><br></pre></td></tr></table></figure><p>示例在 telegraf 库中新建了一个名为 cq_30m 的连续查询，每三十分钟取一个 used 字段的平均值，加入 mem_used_30m 表中。使用的数据保留策略都是 default。</p><p>2）显示所有已存在的连续查询</p><p>查询所有连续查询可以使用如下语句：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SHOW CONTINUOUS QUERIES</span><br><span class="line">name: telegraf</span><br><span class="line">--------------</span><br><span class="line">name    query</span><br><span class="line">cq<span class="emphasis">_30m    CREATE CONTINUOUS QUERY cq_</span>30m ON telegraf </span><br><span class="line">BEGIN SELECT mean(used) INTO telegraf."default".mem<span class="emphasis">_used_</span>30m FROM telegraf."default".mem </span><br><span class="line">GROUP BY time(30m) END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name: <span class="emphasis">_internal</span></span><br><span class="line"><span class="emphasis">---------------</span></span><br><span class="line"><span class="emphasis">name    query</span></span><br></pre></td></tr></table></figure><p>可以看到其连续查询的名称以及 语句等信息。</p><p>3）删除 Continuous Queries</p><p>删除连续查询的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt;</span><br></pre></td></tr></table></figure><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>在 InfluxDB 中，将连续查询与数据存储策略一起使用会达到最好的效果。</p><p>比如，将精度高的表的存储策略定为一个周，然后将精度底的表存储策略定的时间久一点，这要就可以实现高低搭配，以满足不同的工作需要。</p><h2 id="再谈连续查询"><a href="#再谈连续查询" class="headerlink" title="再谈连续查询"></a>再谈连续查询</h2><h3 id="连续查询语法"><a href="#连续查询语法" class="headerlink" title="连续查询语法"></a>连续查询语法</h3><p>连续查询的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> &lt;cq_name&gt; <span class="keyword">ON</span> &lt;database_name&gt; [RESAMPLE [EVERY &lt;<span class="built_in">interval</span>&gt;] [<span class="keyword">FOR</span> &lt;<span class="built_in">interval</span>&gt;]] <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;<span class="keyword">stuff</span>&gt;)] <span class="keyword">INTO</span> &lt;different_measurement&gt; <span class="keyword">FROM</span> &lt;current_measurement&gt; [<span class="keyword">WHERE</span> &lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(&lt;<span class="built_in">interval</span>&gt;)[,&lt;<span class="keyword">stuff</span>&gt;] <span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="指定连续查询的时间范围"><a href="#指定连续查询的时间范围" class="headerlink" title="指定连续查询的时间范围"></a>指定连续查询的时间范围</h3><p>可以使用 <code>RESAMPLE FOR</code> 关键词来指定连续查询的时间范围，比如，每次执行都对 1 小时内的数据进行连续查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires_1 <span class="keyword">ON</span> transylvania RESAMPLE <span class="keyword">FOR</span> <span class="number">60</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations_1 <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这个语句每次会将 1 小时的数据执行连续查询，也就是说，每次执行时，会将 now() 到 now()-30m 和 now()-30m 到 now()-60m 分别做连续查询，这样我们就可以手动指定连续查询的时间范围了。</p><h3 id="指定连续查询的执行频次"><a href="#指定连续查询的执行频次" class="headerlink" title="指定连续查询的执行频次"></a>指定连续查询的执行频次</h3><p>可以使用 <code>RESAMPLE EVERY</code> 关键词来指定连续查询的执行频次，比如，指定连续查询的执行频次为每 15m 执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires <span class="keyword">ON</span> transylvania RESAMPLE EVERY <span class="number">15</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这样，连续查询会每隔 15m 执行一次。</p><h3 id="同时指定连续查询的范围和频次"><a href="#同时指定连续查询的范围和频次" class="headerlink" title="同时指定连续查询的范围和频次"></a>同时指定连续查询的范围和频次</h3><p>将 RESAMPLE FOR 和 EVERY 关键词同时使用，可以同时指定连续查询的范围和频次，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CONTINUOUS <span class="keyword">QUERY</span> vampires_2 <span class="keyword">ON</span> transylvania RESAMPLE EVERY <span class="number">15</span>m <span class="keyword">FOR</span> <span class="number">60</span>m <span class="keyword">BEGIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(dracula) <span class="keyword">INTO</span> vampire_populations_2 <span class="keyword">FROM</span> raw_vampires <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">time</span>(<span class="number">30</span>m) <span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这个语句指定连续查询每 15m 执行一次，每次执行的范围为 60m。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>基础教程文档：<a href="https://www.linuxdaxue.com/series/influxdb-series/" target="_blank" rel="external nofollow noopener noreferrer">InfluxDB 系列教程 | Linux 大学</a></li><li><a href="https://blog.51cto.com/nginxs/2321857" target="_blank" rel="external nofollow noopener noreferrer">00-InfluxDB 入门介绍-我的运维历程-51CTO 博客</a></li><li><a href="http://www.361way.com/influxdb-user/5291.html" target="_blank" rel="external nofollow noopener noreferrer">influxdb 的简单使用 - 运维之路</a></li><li><a href="https://segmentfault.com/a/1190000012385313" target="_blank" rel="external nofollow noopener noreferrer">influxdb 语法 - 个人文章 - SegmentFault 思否</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InfluxDB 是使用 Go 编写的基于时间序列的数据库，用于存储大量带有时间戳的数据，报错 DevOps 监控，日志数据，应用程序的指标、数据分析数据等等。通过 InfluxDB 自动保存数据，你不需要删除和清理，只需要定义一段时间 DB 会帮你自动清理。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_influxdb.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="数据库" scheme="http://houmin.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="influxdb" scheme="http://houmin.cc/tags/influxdb/"/>
    
  </entry>
  
  <entry>
    <title>Grafana 入门</title>
    <link href="http://houmin.cc/posts/588dbd28/"/>
    <id>http://houmin.cc/posts/588dbd28/</id>
    <published>2020-09-16T02:13:33.000Z</published>
    <updated>2020-09-17T08:10:42.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Grafana是一个开源的度量分析与可视化套件。经常被用作基础设施的时间序列数据和应用程序分析的可视化，它在其他领域也被广泛的使用包括工业传感器、家庭自动化、天气和过程控制等。</p><a id="more"></a><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">grafana/grafana:7.0.5</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_USER</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GF_SECURITY_ADMIN_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">admin321</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">grafana</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">472</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">472</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">storage</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">grafana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">grafana</span></span><br></pre></td></tr></table></figure><p>这里设置了环境变量<code>GF_SECURITY_ADMIN_USER</code>和<code>GF_SECURITY_ADMIN_PASSWORD</code>，用来配置 grafana 的管理员用户和密码的。由于 grafana 将 dashboard、插件这些数据保存在<code>/var/lib/grafana</code>这个目录下面的，所以我们这里如果需要做数据持久化的话，就需要针对这个目录进行 volume 挂载声明。</p><p>创建 <code>Deployment</code> 和 <code>Service</code> 之后，即可在浏览器访问 Grafana 对应的服务。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_grafana.png"></p><h2 id="Data-Source"><a href="#Data-Source" class="headerlink" title="Data Source"></a>Data Source</h2><h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.qikqiak.com/post/grafana-usage-in-k8s" target="_blank" rel="external nofollow noopener noreferrer">https://www.qikqiak.com/post/grafana-usage-in-k8s</a></li><li><a href="https://ken.io/note/grafana-quickstart-influxdb-datasource-graph" target="_blank" rel="external nofollow noopener noreferrer">https://ken.io/note/grafana-quickstart-influxdb-datasource-graph</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Grafana是一个开源的度量分析与可视化套件。经常被用作基础设施的时间序列数据和应用程序分析的可视化，它在其他领域也被广泛的使用包括工业传感器、家庭自动化、天气和过程控制等。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="可观测性" scheme="http://houmin.cc/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
      <category term="grafana" scheme="http://houmin.cc/tags/grafana/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="http://houmin.cc/posts/18c039ab/"/>
    <id>http://houmin.cc/posts/18c039ab/</id>
    <published>2020-09-15T07:53:18.000Z</published>
    <updated>2020-09-17T07:53:11.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Prometheus是一套开源的监控、报警、时间序列数据库的组合，起始是由SoundCloud公司开发的。从2016年加入CNCF，2016年6月正式发布1.0版本，2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合，到2018年8月毕业，现在已经成为Kubernetes的官方监控方案，社区活跃，第三方集成非常丰富。</p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Prometheus是一个开源的完整监控解决方案，其对传统监控系统的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统Prometheus具有以下优点：</p><ul><li><strong>易于管理</strong>：只有一个单独的二进制文件，不存在任何的第三方依赖，采用Pull的方式拉取数据</li><li><strong>强大的数据模型</strong>：每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识</li><li><strong>强大的查询语言PromQL</strong>：内置了一个强大的数据查询语言PromQL，可以实现多种查询、聚合</li><li><strong>高性能</strong>：单实例可以处理数以百万的监控指标、每秒处理数十万的数据点</li><li><strong>易扩展</strong>：支持sharding和联邦集群，实现多数据中心</li><li><strong>易集成</strong>：支持多种语言的SDK进行应用程序数据埋点，社区有丰富插件</li><li><strong>可视化</strong>：自带Prometheus UI，可以进行查询与展示，Grafana也完整支持Prometheus。</li><li><strong>开放性</strong>：使用sdk采集的数据可以被其他监控系统使用，不一定非要用Prometheus</li></ul><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>Prometheus从exporter拉取数据，或者间接地通过网关gateway拉取数据（如果在k8s内部署，可以使用服务发现的方式），它默认本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中，采集到的数据有两个去向，一个是报警，另一个是可视化。PromQL和其他API可视化地展示收集的数据，并通过Alertmanager提供报警能力。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-architecture.png"></p><h3 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h3><ul><li><p>Prometheus Server 负责从 Exporter 拉取和存储监控数据,并提供一套灵活的查询语言（PromQL）</p><ul><li>Retrieval: 采样模块</li><li>TSDB: 存储模块默认本地存储为tsdb</li><li>HTTP Server: 提供http接口查询和面板，默认端口为9090</li></ul></li><li><p>Exporters/Jobs 负责收集目标对象（host, container…）的性能数据，并通过 HTTP 接口供 Prometheus Server 获取。支持数据库、硬件、消息中间件、存储系统、http服务器、jmx等。只要符合接口格式，就可以被采集。</p></li><li><p>Short-lived jobs 瞬时任务的场景，无法通过pull方式拉取，需要使用push方式，与PushGateway搭配使用</p></li><li><p>PushGateway 可选组件，主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。</p></li><li><p>客户端sdk 官方提供的客户端类库有go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持nodejs、php、erlang等</p></li><li><p>Alertmanager 从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。</p></li><li><p>Service Discovery</p><p>服务发现，Prometheus支持多种服务发现机制：文件，DNS，Consul,Kubernetes,OpenStack,EC2等等。基于服务发现的过程并不复杂，通过第三方提供的接口，Prometheus查询到需要监控的Target列表，然后轮训这些Target获取监控数据。</p></li></ul><p>其大概的工作流程是：</p><ul><li>Prometheus server 定期从配置好的 jobs 或者 exporters 中拉 metrics，或者从 Pushgateway 拉取 metrics，或者从其他的 Prometheus server 中拉 metrics。</li><li>Prometheus server 在本地存储收集到的 metrics，并运行已定义好的 alert.rules，记录新的时间序列或者向 Alertmanager 推送警报。</li><li>Alertmanager 根据配置文件，对接收到的警报进行处理，发出告警。</li><li>在图形界面中，可视化采集数据。</li></ul><h3 id="Push与Pull"><a href="#Push与Pull" class="headerlink" title="Push与Pull"></a>Push与Pull</h3><p>Prometheus采集数据是用的pull也就是拉模型,通过HTTP协议去采集指标，只要应用系统能够提供HTTP接口就可以接入监控系统，相比于私有协议或二进制协议来说开发、简单。优点主要是：</p><ul><li>开发任何新功能，你甚至可以在电脑上查看你的监控</li><li>如果目标实例挂掉，你可以很快知道</li><li>你可以手动指定目标实例，并且在浏览器中查看他的健康状态</li></ul><p>总体来说，Pull模式比Push模式更好一些，在监控系统中这也不是一个很重要的点。 如果要使用push的方式，可以使用<a href="https://prometheus.io/docs/instrumenting/pushing/" target="_blank" rel="external nofollow noopener noreferrer">Pushgateway</a>的方式，如定时任务的采集。</p><p>对于定时任务这种短周期的指标采集，如果采用pull模式，可能造成任务结束了，Prometheus还没有来得及采集，这个时候可以使用加一个中转层，客户端推数据到Push Gateway缓存一下，由Prometheus从push gateway pull指标过来。(需要额外搭建Push Gateway，同时需要新增job去从gateway采数据)</p><p>推的代表有 ElasticSearch，InfluxDB，OpenTSDB 等，需要你从程序中将指标使用 TCP，UDP 等方式推送至相关监控应用，只是使用 TCP 的话，一旦监控应用挂掉或存在瓶颈，容易对应用本身产生影响，而使用 UDP 的话，虽然不用担心监控应用，但是容易丢数据。</p><p>拉的代表，主要代表就是 Prometheus，让我们不用担心监控应用本身的状态。而且，可以利用 DNS-SRV 或者 Consul 等服务发现功能就可以自动添加监控。</p><p>当然，InfluxDB 加上 collector，或者 ES 加上 metricbeat 也可以变为 『拉』，而 Prometheus 加上 Push Gateway 也可以变为 『推』。</p><p>更多区别可以参考下图：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/03/15502975113235.jpg"></p><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>Prometheus有着非常高效的时间序列数据存储方法，每个采样数据仅仅占用3.5byte左右空间，上百万条时间序列，30秒间隔，保留60天，大概花了200多G（引用官方PPT）。</p><p>Prometheus内部主要分为三大块，Retrieval是负责定时去暴露的目标页面上去抓取采样指标数据，Storage是负责将采样数据写磁盘，PromQL是Prometheus提供的查询语言模块。</p><p>Prometheus内置了一个基于本地存储的时间序列数据库。在Prometheus设计上，使用本地存储可以降低Prometheus部署和管理的复杂度同时减少高可用（HA）带来的复杂性。 在默认情况下，用户只需要部署多套Prometheus，采集相同的Targets即可实现基本的HA。同时由于Promethus高效的数据处理能力，单个Prometheus Server基本上能够应对大部分用户监控规模的需求。</p><p>同时为了适应数据持久化的问题，Prometheus提供了remote_write和remote_read的特性，支持将数据存储到远端和从远端读取数据。通过将监控与数据分离，Prometheus能够更好地进行弹性扩展。</p><h2 id="部署使用"><a href="#部署使用" class="headerlink" title="部署使用"></a>部署使用</h2><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>当使用Deployment管理和部署应用程序时，用户可以方便了对应用进行扩容或者缩容，从而产生多个Pod实例。为了能够统一管理这些Pod的配置信息，在Kubernetes中可以使用ConfigMaps资源定义和管理这些配置，并且通过环境变量或者文件系统挂载的方式让容器使用这些配置。</p><p>这里将使用ConfigMaps管理Prometheus的配置文件，创建prometheus-config.yml文件，并写入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span> </span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>当ConfigMap资源创建成功后，我们就可以通过Volume挂载的方式，将Prometheus的配置文件挂载到容器中。 这里我们通过Deployment部署Prometheus Server实例，创建prometheus-deployment.yml文件，并写入以下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">prom/prometheus:v2.19.0</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/prometheus</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--config.file=/etc/config/prometheus.yml</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9090</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>由于之前配置了 <code>Traefik</code>，所以这里的 Prometheus 服务不使用 <code>NodePort</code> 方式暴露，在本地设置好 <code>prometheus.houmin</code> 的 host之后，在浏览器中访问：<code>http://prometheus.houmin:&lt;TraefikPort&gt;/</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">prometheus.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">prometheus</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure><h2 id="PromQL查询"><a href="#PromQL查询" class="headerlink" title="PromQL查询"></a>PromQL查询</h2><p>Prometheus除了存储数据外，还提供了一种强大的功能表达式语言 PromQL，允许用户实时选择和汇聚时间序列数据。</p><p>表达式的结果可以在浏览器中显示为图形，也可以显示为表格数据，或者由外部系统通过 HTTP API 调用。通过PromQL用户可以非常方便地查询监控数据，或者利用表达式进行告警配置。比如集群中网络使用：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by (<span class="name">name</span>) (<span class="name">rate</span>(<span class="name">container_network_receive_bytes_total</span>&#123;image!=<span class="string">""</span>&#125;[<span class="number">1</span>m]))</span><br></pre></td></tr></table></figure><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-network.png"></p><h3 id="Metric类型"><a href="#Metric类型" class="headerlink" title="Metric类型"></a>Metric类型</h3><p>关于时间序列存储，可以参考：<a href="https://www.infoq.cn/article/database-timestamp-01" target="_blank" rel="external nofollow noopener noreferrer">https://www.infoq.cn/article/database-timestamp-01</a></p><p>Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库TSDB中，并且定时保存到硬盘上。time-series是按照时间戳和值的序列顺序存放的，我们称之为向量(vector)。每条time-series通过指标名称(metrics name)和一组标签集(labelset)命名。</p><p>在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：</p><ul><li>指标(metric)：metric name和描述当前样本特征的labelsets;</li><li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li><li>样本值(value)： 一个folat64的浮点型数据表示当前样本的值。</li></ul><p>如某一时刻的node_cpu指标为459.71</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_cpu&#123;app=<span class="string">"node-exporter"</span>,cpu=<span class="string">"cpu0"</span>,<span class="keyword">instance</span>=<span class="string">"192.168.0.4:9100"</span>,job=<span class="string">"kubernetes-service-endpoints"</span>,kubernetes_name=<span class="string">"node-exporter"</span>,kubernetes_namespace=<span class="string">"kube-system"</span>,mode=<span class="string">"guest"</span>&#125;     <span class="number">459.71</span></span><br></pre></td></tr></table></figure><p>Prometheus定义了4中不同的指标类型(metric type):</p><ul><li>Counter 计数器</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计数器，只增不减，如http_requests_total请求总数</span><br><span class="line"></span><br><span class="line">例如，通过rate()函数获取HTTP请求量的增长率：</span><br><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total[<span class="number">5</span>m])</span></span></span><br></pre></td></tr></table></figure><ul><li>Gauge 仪表盘</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前状态，可增可减。如kube_pod_status_ready当前pod可用数</span><br><span class="line">可以获取样本在一段时间返回内的变化情况,如：</span><br><span class="line"><span class="function"><span class="title">delta</span><span class="params">(kube_pod_status_ready[<span class="number">2</span>h])</span></span></span><br></pre></td></tr></table></figure><ul><li>Histogram 直方图</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Histogram 由 &lt;basename&gt;_bucket&#123;<span class="attribute">le</span>=<span class="string">"&lt;upper inclusive bound&gt;"</span>&#125;，&lt;basename&gt;_bucket&#123;<span class="attribute">le</span>=<span class="string">"+Inf"</span>&#125;, &lt;basename&gt;_sum，&lt;basename&gt;_count 组成，主要用于表示一段时间范围内对数据进行采样（通常是请求持续时间或响应大小），并能够对其指定区间以及总数进行统计，通常它采集的数据展示为直方图。</span><br><span class="line"></span><br><span class="line">例如 Prometheus<span class="built_in"> server </span>中 prometheus_local_storage_series_chunks_persisted, 表示 Prometheus 中每个时序需要存储的 chunks 数量，我们可以用它计算待持久化的数据的分位数。</span><br></pre></td></tr></table></figure><ul><li>Summary 摘要</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Summary 和 Histogram 类似，由 &lt;basename&gt;&#123;<span class="attribute">quantile</span>=<span class="string">"&lt;φ&gt;"</span>&#125;，&lt;basename&gt;_sum，&lt;basename&gt;_count 组成，主要用于表示一段时间内数据采样结果（通常是请求持续时间或响应大小），它直接存储了 quantile 数据，而不是根据统计区间计算出来的。</span><br><span class="line"></span><br><span class="line">例如 Prometheus<span class="built_in"> server </span>中 prometheus_target_interval_length_seconds。</span><br><span class="line"></span><br><span class="line">Histogram 需要通过 &lt;basename&gt;_bucket 计算 quantile, 而 Summary 直接存储了 quantile 的值。</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>PromQL是Prometheus内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。如http_requests_total指标，你可以通过附加一组标签，并用{}括起来，来进一步筛选这些时间序列。下面这个例子只选择有http_requests_total名称的、有prometheus工作标签的、有canary组标签的时间序列：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">"prometheus"</span>,<span class="keyword">group</span>=<span class="string">"canary"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果条件为空，可以写为：http_requests_total{}</p><p>另外，也可以也可以将标签值反向匹配，或者对正则表达式匹配标签值。如操作符：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=：选择正好相等的字符串标签</span><br><span class="line">!=：选择不相等的字符串标签</span><br><span class="line">=~：选择匹配正则表达式的标签（或子标签）</span><br><span class="line">!=：选择不匹配正则表达式的标签（或子标签）</span><br></pre></td></tr></table></figure><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>类似<code>http_requests_total{job=&quot;prometheus&quot;,group=&quot;canary&quot;}</code>的方式，得到的是瞬时值，如果想得到一定范围内的值，可以使用范围查询。</p><p>时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据，如：http_request_total{}[5m]。除了分钟，支持的单位有：</p><ul><li>s - 秒</li><li>m - 分钟</li><li>h - 小时</li><li>d - 天</li><li>w - 周</li><li>y - 年</li></ul><h3 id="偏移查询"><a href="#偏移查询" class="headerlink" title="偏移查询"></a>偏移查询</h3><p>如：查询http_requests_total在当前时刻的一周的速率：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total&#123;&#125; offset <span class="number">1</span>w)</span></span></span><br></pre></td></tr></table></figure><p>偏移修饰符允许更改查询中单个即时向量和范围向量的时间偏移量，例如，以下表达式返回相对于当前查询时间5分钟前的http_requests_total值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total offset <span class="number">5</span>m</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;<span class="keyword">job</span>=<span class="string">"prometheus"</span>&#125;[<span class="number">5</span>m]</span><br></pre></td></tr></table></figure><p>请注意，偏移量修饰符始终需要跟随选择器，即以下是正确的：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=<span class="string">"<span class="keyword">GET</span>"</span>&#125; offset 5m) // GOOD.</span><br></pre></td></tr></table></figure><p>下面是错误的:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total&#123;method=<span class="string">"<span class="keyword">GET</span>"</span>&#125;) offset 5m // INVALID.</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Prometheus 的查询语言支持基本的逻辑运算和算术运算</p><h4 id="二元算术运算："><a href="#二元算术运算：" class="headerlink" title="二元算术运算："></a>二元算术运算：</h4><ul><li>+加法</li><li>-减法</li><li>*乘法</li><li>/ 除法</li><li>% 模</li><li>^ 幂等</li></ul><p>运算中用到的基础数据类型：</p><ul><li>瞬时向量（Instant vector） - 一组时间序列，每个时间序列包含单个样本，它们共享相同的时间戳。也就是说，表达式的返回值中只会包含该时间序列中的最新的一个样本值。而相应的这样的表达式称之为瞬时向量表达式。</li><li>区间向量（Range vector） - 一组时间序列，每个时间序列包含一段时间范围内的样本数据。</li><li>标量（Scalar） - 一个浮点型的数据值。</li><li>字符串（String） - 一个简单的字符串值。</li></ul><p>二元运算操作符支持 scalar/scalar(标量/标量)、vector/scalar(向量/标量)、和 vector/vector(向量/向量) 之间的操作。</p><p>在两个标量之间进行数学运算，得到的结果也是标量。</p><p>例如，如果我们想根据 node_disk_bytes_written 和 node_disk_bytes_read 获取主机磁盘IO的总量，可以使用如下表达式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">node_disk_bytes_written</span> + node_disk_bytes_read</span><br></pre></td></tr></table></figure><p>或者node的内存数GB</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total / (<span class="number">1024</span> * <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><ul><li>== (相等)</li><li>!= (不相等)</li><li><code>&gt;</code> (大于)</li><li>&lt; (小于)</li><li><code>&gt;=</code>  (大于等于)</li><li>&lt;=  (小于等于)</li></ul><p>如：获取http_requests_total请求总数是否超过10000，返回0和1，1则报警</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total &gt; <span class="number">10000</span> # 结果为 <span class="literal">true</span> 或 <span class="literal">false</span></span><br><span class="line">http_requests_total &gt; <span class="built_in">bool</span> <span class="number">10000</span> # 结果为 <span class="number">1</span> 或 <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ul><li>and (并且)</li><li>or (或者)</li><li>unless (排除)</li></ul><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>四则运算有优先级，promql的复杂运算也有优先级</p><p>例如，查询主机的CPU使用率，可以使用表达式：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span>* (<span class="number">1</span> - avg (irate(node_cpu&#123;mode=<span class="comment">'idle'&#125;[5m])) by(job) )</span></span><br></pre></td></tr></table></figure><p>其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率 在PromQL操作符中优先级由高到低依次为：</p><ol><li>^</li><li>*, /, %</li><li>+, -</li><li>==, !=, &lt;=, &lt;, &gt;=, &gt;</li><li>and, unless</li><li>or</li></ol><h4 id="匹配模式（联合查询）"><a href="#匹配模式（联合查询）" class="headerlink" title="匹配模式（联合查询）"></a>匹配模式（联合查询）</h4><p>与数据库中的join类似，promsql有两种典型的匹配查询：</p><ul><li>一对一（one-to-one）</li><li>多对一（many-to-one）或一对多（one-to-many）</li></ul><p>例如当存在样本：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"500"</span>&#125;  <span class="number">24</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"404"</span>&#125;  <span class="number">30</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"put"</span>, code=<span class="string">"501"</span>&#125;  <span class="number">3</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"500"</span>&#125; <span class="number">6</span></span><br><span class="line">method_code:http_errors:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"404"</span>&#125; <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>&#125;  <span class="number">600</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"del"</span>&#125;  <span class="number">34</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>&#125; <span class="number">120</span></span><br></pre></td></tr></table></figure><p>使用 PromQL 表达式：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m<span class="comment">&#123;code="500"&#125;</span> / ignoring(code) <span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m</span><br></pre></td></tr></table></figure><p>该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p><p>因此结果如下：</p><p>{method=”get”} 0.04 // 24 / 600 {method=”post”} 0.05 // 6 / 120</p><p>同时由于 method 为 put 和 del 的样本找不到匹配项，因此不会出现在结果当中。</p><p><strong>多对一模式</strong></p><p>例如，使用表达式：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left <span class="function"><span class="keyword">method</span>:</span>http_requests:rate5m</span><br></pre></td></tr></table></figure><p>该表达式中，左向量 method_code:http_errors:rate5m 包含两个标签 method 和 code。而右向量 method:http_requests:rate5m 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 code。</p><p>在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group 修饰符 group_left 指定左向量具有更好的基数。</p><p>最终的运算结果如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"500"</span>&#125; <span class="number">0.04</span> // <span class="number">24</span> / <span class="number">600</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"get"</span>, code=<span class="string">"404"</span>&#125; <span class="number">0.05</span> // <span class="number">30</span> / <span class="number">600</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"500"</span>&#125; <span class="number">0.05</span> // <span class="number">6</span> / <span class="number">120</span> &#123;<span class="function"><span class="keyword">method</span>=</span><span class="string">"post"</span>, code=<span class="string">"404"</span>&#125; <span class="number">0.175</span> // <span class="number">21</span> / <span class="number">120</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提醒：<span class="keyword">group</span> <span class="title">修饰符只能在比较和数学运算符中使用。在逻辑运算 and</span>，unless 和 <span class="keyword">or</span> 操作中默认与右向量中的所有元素进行匹配。</span><br></pre></td></tr></table></figure><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个具有较少样本值的新的时间序列。</p><ul><li>sum (求和)</li><li>min (最小值)</li><li>max (最大值)</li><li>avg (平均值)</li><li>stddev (标准差)</li><li>stdvar (标准差异)</li><li>count (计数)</li><li>count_values (对 value 进行计数)</li><li>bottomk (样本值最小的 k 个元素)</li><li>topk (样本值最大的k个元素)</li><li>quantile (分布统计)</li></ul><p>这些操作符被用于聚合所有标签维度，或者通过 without 或者 by 子语句来保留不同的维度。</p><ul><li>without 用于从计算结果中移除列举的标签，而保留其它标签。</li><li>by 则正好相反，结果向量中只保留列出的标签，其余标签则移除。</li></ul><p>通过 without 和 by 可以按照样本的问题对数据进行聚合。</p><p>例如：如果指标 http_requests_total 的时间序列的标签集为 application, instance, 和 group，我们可以通过以下方式计算所有 instance 中每个 application 和 group 的请求总量：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">http_requests_total</span>) without (<span class="name">instance</span>)</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">http_requests_total</span>) by (<span class="name">application</span>, group)</span><br></pre></td></tr></table></figure><p>如果只需要计算整个应用的 HTTP 请求总量，可以直接使用表达式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sum</span><span class="params">(http_requests_total)</span></span></span><br></pre></td></tr></table></figure><p>count_values 用于时间序列中每一个样本值出现的次数。count_values 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p><p>这个标签的名字由聚合参数指定，同时这个标签值是唯一的样本值。</p><p>例如要计算运行每个构建版本的二进制文件的数量：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count_values(<span class="string">"version"</span>, <span class="keyword">build_version)</span></span><br><span class="line"><span class="keyword">返回结果如下：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">&#123;count="641"&#125; </span>  <span class="number">1</span></span><br><span class="line">&#123;<span class="built_in">count</span>=<span class="string">"3226"</span>&#125;  <span class="number">2</span></span><br><span class="line">&#123;<span class="built_in">count</span>=<span class="string">"644"</span>&#125;   <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>topk 和 bottomk</strong> </p><p>则用于对样本值进行排序，返回当前样本值前 n 位，或者后 n 位的时间序列。</p><p>获取 HTTP 请求数前 5 位的时序样本数据，可以使用表达式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">topk</span><span class="params">(<span class="number">5</span>, http_requests_total)</span></span></span><br></pre></td></tr></table></figure><p>quantile 用于计算当前样本数据值的分布情况 quantile(φ, express) ，其中 0 ≤ φ ≤ 1</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如，当 φ 为 <span class="number">0.5</span> 时，即表示找到当前样本数据中的中位数：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">quantile(<span class="number">0.5</span>, http_requests_total)</span><br><span class="line">返回结果如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#125;   <span class="number">656</span></span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。如上文提到的irate</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span>* (<span class="number">1</span> - avg (irate(node_cpu&#123;mode=<span class="comment">'idle'&#125;[5m])) by(job) )</span></span><br></pre></td></tr></table></figure><p>常用的有：</p><p>两分钟内的平均CPU使用率：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rate</span><span class="params">(node_cpu[<span class="number">2</span>m])</span></span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">irate</span><span class="params">(node_cpu[<span class="number">2</span>m])</span></span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，</span><br><span class="line">其无法反应在时间窗口内样本数据的突发变化。</span><br><span class="line">例如，对于主机而言在<span class="number">2</span>分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用<span class="number">100</span>%的情况，</span><br><span class="line">但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</span><br><span class="line"></span><br><span class="line">为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-<span class="type">vector</span>)。</span><br><span class="line"></span><br><span class="line">irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。</span><br><span class="line"></span><br><span class="line">irate函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率。</span><br><span class="line">这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</span><br></pre></td></tr></table></figure><p>irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。</p><p>因此在长期趋势分析或者告警中更推荐使用rate函数。</p><p>完整的函数列表为：</p><ul><li>abs()</li><li>absent()</li><li>ceil()</li><li>changes()</li><li>clamp_max()</li><li>clamp_min()</li><li>day_of_month()</li><li>day_of_week()</li><li>days_in_month()</li><li>delta()</li><li>deriv()</li><li>exp()</li><li>floor()</li><li>histogram_quantile()</li><li>holt_winters()</li><li>hour()</li><li>idelta()</li><li>increase()</li><li>irate()</li><li>label_join()</li><li>label_replace()</li><li>ln()</li><li>log2()</li><li>log10()</li><li>minute()</li><li>month()</li><li>predict_linear()</li><li>rate()</li><li>resets()</li><li>round()</li><li>scalar()</li><li>sort()</li><li>sort_desc()</li><li>sqrt()</li><li>time()</li><li>timestamp()</li><li>vector()</li><li>year()</li><li>_over_time()</li></ul><h3 id="API访问"><a href="#API访问" class="headerlink" title="API访问"></a>API访问</h3><p>Prometheus当前稳定的HTTP API可以通过/api/v1访问</p><p>错误状态码：</p><ul><li>404 Bad Request：当参数错误或者缺失时。</li><li>422 Unprocessable Entity 当表达式无法执行时。</li><li>503 Service Unavailiable 当请求超时或者被中断时。</li></ul><p>所有的API请求均使用以下的JSON格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"success"</span> | <span class="string">"error"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &lt;data&gt;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为error时，有如下报错信息</span></span><br><span class="line">  <span class="attr">"errorType"</span>: <span class="string">"&lt;string&gt;"</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"&lt;string&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过HTTP API我们可以分别通过/api/v1/query和/api/v1/query_range查询PromQL表达式当前或者一定时间范围内的计算结果。</p><h4 id="瞬时数据查询"><a href="#瞬时数据查询" class="headerlink" title="瞬时数据查询"></a>瞬时数据查询</h4><p>URL请求参数：</p><ul><li>query=：PromQL表达式。</li><li>time=：用于指定用于计算PromQL的时间戳。可选参数，默认情况下使用当前系统时间。</li><li>timeout=：超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 'http://localhost:<span class="number">9090</span>/api/v1/query?query=up&amp;time=<span class="number">2015-07-01</span>T20:10:51.781Z'</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line">   <span class="attr">"data"</span> : &#123;</span><br><span class="line">      <span class="attr">"resultType"</span> : <span class="string">"vector"</span>,</span><br><span class="line">      <span class="attr">"result"</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"prometheus"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9090"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"value"</span>: [ <span class="number">1435781451.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"node"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9100"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"value"</span> : [ <span class="number">1435781451.781</span>, <span class="string">"0"</span> ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>URL请求参数：</p><ul><li>query=: PromQL表达式。</li><li>start=: 起始时间。</li><li>end=: 结束时间。</li><li>step=: 查询步长。</li><li>timeout=: 超时设置。可选参数，默认情况下使用-query,timeout的全局设置。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl 'http://localhost:<span class="number">9090</span>/api/v1/query_range?query=up&amp;start=<span class="number">2015-07-01</span>T20:10:30.781Z&amp;end=<span class="number">2015-07-01</span>T20:11:00.781Z&amp;step=15s'</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"status"</span> : <span class="string">"success"</span>,</span><br><span class="line">   <span class="attr">"data"</span> : &#123;</span><br><span class="line">      <span class="attr">"resultType"</span> : <span class="string">"matrix"</span>,</span><br><span class="line">      <span class="attr">"result"</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"prometheus"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9090"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"values"</span> : [</span><br><span class="line">               [ <span class="number">1435781430.781</span>, <span class="string">"1"</span> ],</span><br><span class="line">               [ <span class="number">1435781445.781</span>, <span class="string">"1"</span> ],</span><br><span class="line">               [ <span class="number">1435781460.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">"metric"</span> : &#123;</span><br><span class="line">               <span class="attr">"__name__"</span> : <span class="string">"up"</span>,</span><br><span class="line">               <span class="attr">"job"</span> : <span class="string">"node"</span>,</span><br><span class="line">               <span class="attr">"instance"</span> : <span class="string">"localhost:9091"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"values"</span> : [</span><br><span class="line">               [ <span class="number">1435781430.781</span>, <span class="string">"0"</span> ],</span><br><span class="line">               [ <span class="number">1435781445.781</span>, <span class="string">"0"</span> ],</span><br><span class="line">               [ <span class="number">1435781460.781</span>, <span class="string">"1"</span> ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Alert-Rules"><a href="#Alert-Rules" class="headerlink" title="Alert Rules"></a>Alert Rules</h2><p>Prometheus中的告警规则允许你基于PromQL表达式定义告警触发条件，Prometheus后端对这些触发规则进行周期性计算，当满足触发条件后则会触发告警通知。默认情况下，用户可以通过Prometheus的Web界面查看这些告警规则以及告警的触发状态。当Promthues与Alertmanager关联之后，可以将告警发送到外部服务如Alertmanager中并通过Alertmanager可以对这些告警进行进一步的处理。</p><h3 id="定义告警规则"><a href="#定义告警规则" class="headerlink" title="定义告警规则"></a>定义告警规则</h3><p>一条典型的告警规则如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">HighErrorRate</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">job:request_latency_seconds:mean5m&#123;job="myjob"&#125;</span> <span class="string">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">High</span> <span class="string">request</span> <span class="string">latency</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">description</span> <span class="string">info</span></span><br></pre></td></tr></table></figure><p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：</p><ul><li>alert：告警规则的名称。</li><li>expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。</li><li>for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。</li><li>labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。</li><li>annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。</li></ul><p>为了能够让Prometheus能够启用定义的告警规则，我们需要在Prometheus全局配置文件中通过<strong>rule_files</strong>指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>默认情况下Prometheus会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过<code>evaluation_interval</code>来覆盖默认的计算周期：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">evaluation_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">1m</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h3><p>一般来说，在告警规则文件的annotations中使用<code>summary</code>描述告警的概要信息，<code>description</code>用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations的中标签的值。</p><p>通过<code>$labels.&lt;labelname&gt;</code>变量可以访问当前告警实例中指定标签的值。$value则可以获取当前PromQL表达式计算的样本值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To insert a firing element's label values:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$labels.&lt;labelname&gt;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="comment"># To insert the numeric expression value of the firing element:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$value</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>例如，可以通过模板化优化summary以及description的内容的可读性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes."</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that has a median request latency &gt;1s.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">APIHighRequestLatency</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">api_http_request_latencies_second&#123;quantile="0.5"&#125;</span> <span class="string">&gt;</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"High request latency on <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> has a median request latency above 1s (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>s)"</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>配置 Alert Rules，修改 Prometheus 配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prometheus-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">prometheus.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">      <span class="attr">scrape_interval:</span>     <span class="string">15s</span></span><br><span class="line">      <span class="attr">evaluation_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">rule_files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/recording_rules.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/alerting_rules.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/rules</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/config/alerts</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['node-exporter:9100']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'container'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['cadvisor:8080']</span></span><br><span class="line">  <span class="attr">alerting_rules.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hostStatsAlert</span></span><br><span class="line">      <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">hostMemUsageAlert</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">(sum(node_memory_MemTotal_bytes)</span> <span class="bullet">-</span> <span class="string">sum(node_memory_MemFree_bytes</span> <span class="string">+</span> <span class="string">node_memory_Buffers_bytes+node_memory_Cached_bytes))</span> <span class="string">/</span> <span class="string">sum(node_memory_MemTotal_bytes)</span> <span class="string">&gt;</span> <span class="number">0.55</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">severity:</span> <span class="string">page</span></span><br><span class="line">        <span class="attr">annotations:</span></span><br><span class="line">            <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usgae high"</span></span><br><span class="line">            <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usage above 85% (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>)"</span></span><br><span class="line">  <span class="attr">alerts:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">recording_rules.yml:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">rules:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>重启Prometheus后访问Prometheus UI 可以查看当前以加载的规则文件：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-rules.png"></p><p>切换到Alerts标签可以查看当前告警的活动状态。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-alerts.png"></p><p>现在只是在 Prometheus Web 页面查看警告，通过配置 <code>Alert Manager</code> 可以实现连接钉钉/Slack等平台报警。</p><h2 id="Recording-Rules"><a href="#Recording-Rules" class="headerlink" title="Recording Rules"></a>Recording Rules</h2><p>通过PromQL可以实时对Prometheus中采集到的样本数据进行查询，聚合以及其它各种运算操作。而在某些PromQL较为复杂且计算量较大时，直接使用PromQL可能会导致Prometheus响应超时的情况。这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。Prometheus通过Recoding Rule规则支持这种后台计算的方式，可以实现对复杂查询的性能优化，提高查询效率。</p><p>在Prometheus配置文件中，通过rule_files定义recoding rule规则文件的访问路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>每一个规则文件通过以下格式进行定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule_group&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>一个简单的规则文件可能是这个样子的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">record:</span> <span class="string">job:http_inprogress_requests:sum</span></span><br><span class="line">      <span class="attr">expr:</span> <span class="string">sum(http_inprogress_requests)</span> <span class="string">by</span> <span class="string">(job)</span></span><br></pre></td></tr></table></figure><p>rule_group的具体配置项如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the group. Must be unique within a file.</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often rules in the group are evaluated.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.evaluation_interval</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>与告警规则一致，一个group下可以包含多条规则rule。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the time series to output to. Must be a valid metric name.</span></span><br><span class="line"><span class="attr">record:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The PromQL expression to evaluate. Every evaluation cycle this is</span></span><br><span class="line"><span class="comment"># evaluated at the current time, and the result recorded as a new set of</span></span><br><span class="line"><span class="comment"># time series with the metric name as given by 'record'.</span></span><br><span class="line"><span class="attr">expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Labels to add or overwrite before storing the result.</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>根据规则中的定义，Prometheus会在后台完成expr中定义的PromQL表达式计算，并且将计算结果保存到新的时间序列record中。同时还可以通过labels为这些样本添加额外的标签。</p><p>这些规则文件的计算频率与告警规则计算频率一致，都通过global.evaluation_interval定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  [ evaluation_interval: &lt;duration&gt; |<span class="built_in"> default </span>= 1m ]</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/vovlie/p/7709312.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/vovlie/p/7709312.html</a></li><li><a href="https://www.infoq.cn/article/Prometheus-theory-source-code" target="_blank" rel="external nofollow noopener noreferrer">https://www.infoq.cn/article/Prometheus-theory-source-code</a></li><li><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="external nofollow noopener noreferrer">https://yunlzheng.gitbook.io/prometheus-book/</a></li><li><a href="https://yasongxu.gitbook.io/container-monitor/" target="_blank" rel="external nofollow noopener noreferrer">https://yasongxu.gitbook.io/container-monitor/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Prometheus是一套开源的监控、报警、时间序列数据库的组合，起始是由SoundCloud公司开发的。从2016年加入CNCF，2016年6月正式发布1.0版本，2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合，到2018年8月毕业，现在已经成为Kubernetes的官方监控方案，社区活跃，第三方集成非常丰富。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-architecture.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="可观测性" scheme="http://houmin.cc/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
      <category term="prometheus" scheme="http://houmin.cc/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Node Exporter</title>
    <link href="http://houmin.cc/posts/dd1e183c/"/>
    <id>http://houmin.cc/posts/dd1e183c/</id>
    <published>2020-09-15T06:51:03.000Z</published>
    <updated>2020-09-17T07:49:51.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Exporter 是Prometheus的一类数据采集组件的总称，负责从目标处搜集数据，并将其转化为Prometheus支持的格式。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取，默认的抓取地址为 <code>http://current_ip:9100/metrics</code>。Node Exporter 用于采集服务器层面的运行指标，包括机器的 loadavg、filesystem、meminfo等基础监控，类似于传统主机监控维度的zabbix-agent。<code>Node Export</code> 由prometheus官方提供、维护，不会捆绑安装，但基本上是必备的exporter。</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>node-exporter用于提供*NIX内核的硬件以及系统指标。</p><ul><li>如果是windows系统，可以使用<a href="https://github.com/martinlindhe/wmi_exporter" target="_blank" rel="external nofollow noopener noreferrer">WMI exporter</a></li><li>如果是采集NVIDIA的GPU指标，可以使用<a href="https://github.com/NVIDIA/gpu-monitoring-tools/tree/master/exporters/prometheus-dcgm" target="_blank" rel="external nofollow noopener noreferrer">prometheus-dcgm </a></li></ul><p>根据不同的*NIX操作系统，node-exporter采集指标的支持也是不一样的，如：</p><ul><li>diskstats 支持    Darwin, Linux</li><li>cpu 支持Darwin, Dragonfly, FreeBSD, Linux, Solaris等，</li></ul><p>详细信息参考：<a href="https://github.com/prometheus/node_exporter" target="_blank" rel="external nofollow noopener noreferrer">node_exporter</a></p><p>我们可以使用 —collectors.enabled参数指定node_exporter收集的功能模块,或者用—no-collector指定不需要的模块，如果不指定，将使用默认配置。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">prometheus.io/scrape:</span> <span class="string">'true'</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">scrape</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9100</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">node-exporter</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/node-exporter:v1.0.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">scrape</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>得到一个daemonset和一个service对象，部署后，为了能够让Prometheus能够从当前node exporter获取到监控数据，这里需要修改Prometheus配置文件。编辑 <code>prometheus.yml</code> 并在scrape_configs节点下添加以下内容:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">scrape_configs</span>:</span><br><span class="line">  # 采集node exporter监控数据</span><br><span class="line">  - <span class="attribute">job_name</span>: <span class="string">'node'</span></span><br><span class="line">    <span class="attribute">static_configs</span>:</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'localhost:9100'</span>]</span><br></pre></td></tr></table></figure><p>也可以使用<code>prometheus.io/scrape: &#39;true&#39;</code>标识来自动获取service的metric接口</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>source<span class="emphasis">_labels: [_</span><span class="emphasis">_meta_</span>kubernetes<span class="emphasis">_service_</span>annotation<span class="emphasis">_prometheus_</span>io<span class="emphasis">_scrape]</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启prometheus就能看到对应的指标</p><p><strong>直接查看：</strong></p><p>如果是二进制或者docker部署，部署成功后可以访问：<a href="http:///${IP}:9100/metrics">http://${IP}:9100/metrics</a></p><p>会输出下面格式的内容，包含了node-exporter暴露的所有指标：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0"</span>&#125; 6.1872e-05</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.25"</span>&#125; 0.000119463</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.5"</span>&#125; 0.000151156</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.75"</span>&#125; 0.000198764</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"1"</span>&#125; 0.009889647</span><br><span class="line">go_gc_duration_seconds_sum 0.257232201</span><br><span class="line">go_gc_duration_seconds_count 1187</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP node_cpu Seconds the cpus spent in each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu counter</span></span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="guest"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="guest_nice"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="idle"&#125; 68859.19</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="iowait"&#125; 167.22</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="irq"&#125; 0</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="nice"&#125; 19.92</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="softirq"&#125; 17.05</span><br><span class="line">node_cpu&#123;<span class="attribute">cpu</span>=<span class="string">"cpu0"</span>,mode="steal"&#125; 28.1</span><br></pre></td></tr></table></figure><p><strong>Prometheus查看：</strong></p><p>类似go_gc_duration_seconds和node_cpu就是metric的名称，如果使用了Prometheus,则可以在<code>http://${IP}:9090/</code> 页面的指标中搜索到以上的指标：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_node-exporter-metrics.png"></p><p>常用指标类型有：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_cpu：系统CPU使用量</span><br><span class="line">node_disk*：磁盘IO</span><br><span class="line">node_filesystem*：文件系统用量</span><br><span class="line">node_load1：系统负载</span><br><span class="line">node_memeory*：内存使用量</span><br><span class="line">node_network*：网络带宽</span><br><span class="line">node_time：当前系统时间</span><br><span class="line">go_*：<span class="keyword">node</span> <span class="title">exporter</span>中go相关指标</span><br><span class="line">process_*：<span class="keyword">node</span> <span class="title">exporter</span>自身进程相关运行指标</span><br></pre></td></tr></table></figure><p><strong>Grafana查看：</strong></p><p>Prometheus虽然自带了web页面，但一般会和更专业的Grafana配套做指标的可视化，Grafana有很多模板，用于更友好地展示出指标的情况，如<a href="https://grafana.com/dashboards/8919" target="_blank" rel="external nofollow noopener noreferrer">Node Exporter for Prometheus</a></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p><p>在grafana中配置好变量、导入模板就会有上图的效果。</p><h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><p>node-exporter是Prometheus官方推荐的exporter，类似的还有</p><ul><li><a href="https://github.com/prometheus/haproxy_exporter" target="_blank" rel="external nofollow noopener noreferrer">HAProxy exporter</a></li><li><a href="https://github.com/prometheus/collectd_exporter" target="_blank" rel="external nofollow noopener noreferrer">Collectd exporter</a></li><li><a href="https://github.com/prometheus/snmp_exporter" target="_blank" rel="external nofollow noopener noreferrer">SNMP exporter</a></li><li><a href="https://github.com/prometheus/mysqld_exporter" target="_blank" rel="external nofollow noopener noreferrer">MySQL server exporter</a></li><li>….</li></ul><p>官方推荐的都会在<a href="https://github.com/prometheus下，在[exporter推荐页](https://prometheus.io/docs/instrumenting/exporters/)，也会有很多第三方的exporter，由个人或者组织开发上传，如果有自定义的采集需求，可以自己编写[exporter](https://prometheus.io/docs/instrumenting/writing_exporters/)。" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/prometheus下，在[exporter推荐页](https://prometheus.io/docs/instrumenting/exporters/)，也会有很多第三方的exporter，由个人或者组织开发上传，如果有自定义的采集需求，可以自己编写[exporter](https://prometheus.io/docs/instrumenting/writing_exporters/)。</a></p><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p>node-exporter的主函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package collector includes all individual collectors to gather and export system metrics.</span></span><br><span class="line"><span class="keyword">package</span> collector</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line">    <span class="string">"github.com/prometheus/common/log"</span></span><br><span class="line">    <span class="string">"gopkg.in/alecthomas/kingpin.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Namespace defines the common namespace to be used by all metrics.</span></span><br><span class="line"><span class="keyword">const</span> namespace = <span class="string">"node"</span></span><br></pre></td></tr></table></figure><p>可以看到exporter的实现需要引入github.com/prometheus/client_golang/prometheus库，client_golang是prometheus的官方go库，既可以用于集成现有应用，也可以作为连接Prometheus HTTP API的基础库。</p><p>比如定义了基础的数据类型以及对应的方法：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter：收集事件次数等单调递增的数据</span><br><span class="line">Gauge：收集当前的状态，比如数据库连接数</span><br><span class="line"><span class="keyword">Histogram</span>：收集随机正态分布数据，比如响应延迟</span><br><span class="line">Summary：收集随机正态分布数据，和 <span class="keyword">Histogram</span> 是类似的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Exporter 是Prometheus的一类数据采集组件的总称，负责从目标处搜集数据，并将其转化为Prometheus支持的格式。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取，默认的抓取地址为 &lt;code&gt;http://current_ip:9100/metrics&lt;/code&gt;。Node Exporter 用于采集服务器层面的运行指标，包括机器的 loadavg、filesystem、meminfo等基础监控，类似于传统主机监控维度的zabbix-agent。&lt;code&gt;Node Export&lt;/code&gt; 由prometheus官方提供、维护，不会捆绑安装，但基本上是必备的exporter。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_node-exporter.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="可观测性" scheme="http://houmin.cc/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】kube-state-metrics</title>
    <link href="http://houmin.cc/posts/9bd76ed5/"/>
    <id>http://houmin.cc/posts/9bd76ed5/</id>
    <published>2020-09-15T05:40:21.000Z</published>
    <updated>2020-09-17T08:03:35.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>已经有了cadvisor、heapster、metric-server，几乎容器运行的所有指标都能拿到，但是下面这种情况却无能为力：</p><ul><li>我调度了多少个replicas？现在可用的有几个？</li><li>多少个Pod是running/stopped/terminated状态？</li><li>Pod重启了多少次？</li><li>我有多少job在运行中</li></ul><p>而这些则是kube-state-metrics提供的内容，它基于client-go开发，轮询Kubernetes API，并将Kubernetes的结构化信息转换为metrics。</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>kube-state-metrics提供的指标，按照阶段分为三种类别：</p><ul><li>1.实验性质的：k8s api中alpha阶段的或者spec的字段。</li><li>2.稳定版本的：k8s中不向后兼容的主要版本的更新</li><li>3.被废弃的：已经不在维护的。</li></ul><p>指标类别包括：</p><ul><li>CronJob Metrics</li><li>DaemonSet Metrics</li><li>Deployment Metrics</li><li>Job Metrics</li><li>LimitRange Metrics</li><li>Node Metrics</li><li>PersistentVolume Metrics</li><li>PersistentVolumeClaim Metrics</li><li>Pod Metrics</li><li>Pod Disruption Budget Metrics</li><li>ReplicaSet Metrics</li><li>ReplicationController Metrics</li><li>ResourceQuota Metrics</li><li>Service Metrics</li><li>StatefulSet Metrics</li><li>Namespace Metrics</li><li>Horizontal Pod Autoscaler Metrics</li><li>Endpoint Metrics</li><li>Secret Metrics</li><li>ConfigMap Metrics</li></ul><p>以pod为例：</p><ul><li>kube_pod_info</li><li>kube_pod_owner</li><li>kube_pod_status_phase</li><li>kube_pod_status_ready</li><li>kube_pod_status_scheduled</li><li>kube_pod_container_status_waiting</li><li>kube_pod_container_status_terminated_reason</li><li>…</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://github.com/kubernetes/kube-state-metrics/tree/master/examples/standard" target="_blank" rel="external nofollow noopener noreferrer">部署清单</a>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kube-<span class="section">state</span>-metrics/</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-cluster-role-binding.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-cluster-role.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-deployment.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-role-binding.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-role.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-service-account.yaml</span><br><span class="line">   ├── kube-<span class="section">state</span>-metrics-service.yaml</span><br></pre></td></tr></table></figure><p>主要镜像有： image: quay.io/coreos/kube-state-metrics:v1.5.0 image: k8s.gcr.io/addon-resizer:1.8.3（参考metric-server文章，用于扩缩容）</p><p>对于pod的资源限制，一般情况下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>MiB memory <span class="number">0.1</span> cores</span><br></pre></td></tr></table></figure><p>超过100节点的集群：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2M</span>iB memory per <span class="keyword">node</span> <span class="title">0</span>.<span class="number">001</span> cores per <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure><p>kube-state-metrics做过一次性能优化，具体内容参考下文</p><p>部署成功后，prometheus的target会出现如下标志</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/d3c663e527607ecc3eab922ca13a8f44.png"></p><p>因为kube-state-metrics-service.yaml中有<code>prometheus.io/scrape: &#39;true&#39;</code>标识，因此会将metric暴露给prometheus，而Prometheus会在kubernetes-service-endpoints这个job下自动发现kube-state-metrics，并开始拉取metrics，无需其他配置。</p><p>使用kube-state-metrics后的常用场景有：</p><ul><li>存在执行失败的Job: kube_job_status_failed{job=”kubernetes-service-endpoints”,k8s_app=”kube-state-metrics”}==1</li><li>集群节点状态错误: kube_node_status_condition{condition=”Ready”,status!=”true”}==1</li><li>集群中存在启动失败的Pod：kube_pod_status_phase{phase=~”Failed|Unknown”}==1</li><li>最近30分钟内有Pod容器重启: changes(kube_pod_container_status_restarts[30m])&gt;0</li></ul><p>配合报警可以更好地监控集群的运行</p><h2 id="与metric-server的对比"><a href="#与metric-server的对比" class="headerlink" title="与metric-server的对比"></a>与metric-server的对比</h2><ul><li>metric-server（或heapster）是从api-server中获取cpu、内存使用率这种监控指标，并把他们发送给存储后端，如influxdb或云厂商，他当前的核心作用是：为HPA等组件提供决策指标支持。</li><li>kube-state-metrics关注于获取k8s各种资源的最新状态，如deployment或者daemonset，之所以没有把kube-state-metrics纳入到metric-server的能力中，是因为他们的关注点本质上是不一样的。metric-server仅仅是获取、格式化现有数据，写入特定的存储，实质上是一个监控系统。而kube-state-metrics是将k8s的运行状况在内存中做了个快照，并且获取新的指标，但他没有能力导出这些指标</li><li>换个角度讲，kube-state-metrics本身是metric-server的一种数据来源，虽然现在没有这么做。</li><li>另外，像Prometheus这种监控系统，并不会去用metric-server中的数据，他都是自己做指标收集、集成的（Prometheus包含了metric-server的能力），但Prometheus可以监控metric-server本身组件的监控状态并适时报警，这里的监控就可以通过kube-state-metrics来实现，如metric-serverpod的运行状态。</li></ul><h2 id="深入解析"><a href="#深入解析" class="headerlink" title="深入解析"></a>深入解析</h2><p>kube-state-metrics本质上是不断轮询api-server，代码结构也很简单 主要代码目录</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── collectors</span><br><span class="line">│   ├── builder.<span class="keyword">go</span></span><br><span class="line">│   ├── collectors.<span class="keyword">go</span></span><br><span class="line">│   ├── configmap.<span class="keyword">go</span></span><br><span class="line">│   ......</span><br><span class="line">│   ├── testutils.<span class="keyword">go</span></span><br><span class="line">│   ├── testutils_test.<span class="keyword">go</span></span><br><span class="line">│   └── utils.<span class="keyword">go</span></span><br><span class="line">├── constant</span><br><span class="line">│   └── resource_unit.<span class="keyword">go</span></span><br><span class="line">├── metrics</span><br><span class="line">│   ├── metrics.<span class="keyword">go</span></span><br><span class="line">│   └── metrics_test.<span class="keyword">go</span></span><br><span class="line">├── metrics_store</span><br><span class="line">│   ├── metrics_store.<span class="keyword">go</span></span><br><span class="line">│   └── metrics_store_test.<span class="keyword">go</span></span><br><span class="line">├── <span class="keyword">options</span></span><br><span class="line">│   ├── collector.<span class="keyword">go</span></span><br><span class="line">│   ├── <span class="keyword">options</span>.<span class="keyword">go</span></span><br><span class="line">│   ├── options_test.<span class="keyword">go</span></span><br><span class="line">│   ├── types.<span class="keyword">go</span></span><br><span class="line">│   └── types_test.<span class="keyword">go</span></span><br><span class="line">├── <span class="keyword">version</span></span><br><span class="line">│   └── <span class="keyword">version</span>.<span class="keyword">go</span></span><br><span class="line">└── whiteblacklist</span><br><span class="line">    ├── whiteblacklist.<span class="keyword">go</span></span><br><span class="line">    └── whiteblacklist_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>所有类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    DefaultNamespaces = NamespaceList&#123;metav1.NamespaceAll&#125;</span><br><span class="line">    DefaultCollectors = CollectorSet&#123;</span><br><span class="line">        <span class="string">"daemonsets"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"deployments"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"limitranges"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"nodes"</span>:                    <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"pods"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"poddisruptionbudgets"</span>:     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"replicasets"</span>:              <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"replicationcontrollers"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"resourcequotas"</span>:           <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"services"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"jobs"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"cronjobs"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"statefulsets"</span>:             <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"persistentvolumes"</span>:        <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"persistentvolumeclaims"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"namespaces"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"horizontalpodautoscalers"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"endpoints"</span>:                <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"secrets"</span>:                  <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">        <span class="string">"configmaps"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>构建对应的收集器</p><p>Family即一个类型的资源集合，如job下的kube_job_info、kube_job_created，都是一个FamilyGenerator实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">metrics.FamilyGenerator&#123;</span><br><span class="line">            Name: <span class="string">"kube_job_info"</span>,</span><br><span class="line">            Type: metrics.MetricTypeGauge,</span><br><span class="line">            Help: <span class="string">"Information about job."</span>,</span><br><span class="line">            GenerateFunc: wrapJobFunc(<span class="function"><span class="keyword">func</span><span class="params">(j *v1batch.Job)</span> <span class="title">metrics</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">                <span class="keyword">return</span> metrics.Family&#123;&amp;metrics.Metric&#123;</span><br><span class="line">                    Name:  <span class="string">"kube_job_info"</span>,</span><br><span class="line">                    Value: <span class="number">1</span>,</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">buildCronJobCollector</span><span class="params">()</span> *<span class="title">Collector</span></span> &#123;</span><br><span class="line">   <span class="comment">// 过滤传入的白名单</span></span><br><span class="line">    filteredMetricFamilies := filterMetricFamilies(b.whiteBlackList, cronJobMetricFamilies)</span><br><span class="line">    composedMetricGenFuncs := composeMetricGenFuncs(filteredMetricFamilies)</span><br><span class="line">  <span class="comment">// 将参数写到header中</span></span><br><span class="line">    familyHeaders := extractMetricFamilyHeaders(filteredMetricFamilies)</span><br><span class="line">  <span class="comment">// NewMetricsStore实现了client-go的cache.Store接口，实现本地缓存。</span></span><br><span class="line">    store := metricsstore.NewMetricsStore(</span><br><span class="line">        familyHeaders,</span><br><span class="line">        composedMetricGenFuncs,</span><br><span class="line">    )</span><br><span class="line">  <span class="comment">// 按namespace构建Reflector，监听变化</span></span><br><span class="line">    reflectorPerNamespace(b.ctx, b.kubeClient, &amp;batchv1beta1.CronJob&#123;&#125;, store, b.namespaces, createCronJobListWatch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewCollector(store)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能优化：</p><p>kube-state-metrics在之前的版本中暴露出两个问题：</p><ul><li><ol><li>/metrics接口响应慢(10-20s)</li></ol></li><li><ol><li>内存消耗太大，导致超出limit被杀掉</li></ol></li></ul><p>问题一的方案就是基于client-go的cache tool实现本地缓存，具体结构为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cache = map[<span class="string">uuid</span>][<span class="symbol"></span>]byte&#123;&#125;</span><br></pre></td></tr></table></figure><p>问题二的的方案是：对于时间序列的字符串，是存在很多重复字符的（如namespace等前缀筛选），可以用指针或者结构化这些重复字符。</p><h2 id="优化点和问题"><a href="#优化点和问题" class="headerlink" title="优化点和问题"></a>优化点和问题</h2><ul><li>因为kube-state-metrics是监听资源的add、delete、update事件，那么在kube-state-metrics部署之前已经运行的资源，岂不是拿不到数据？kube-state-metric利用client-go可以初始化所有已经存在的资源对象，确保没有任何遗漏</li><li>kube-state-metrics当前不会输出metadata信息(如help和description）</li><li>缓存实现是基于golang的map，解决并发读问题当期是用了一个简单的互斥锁，应该可以解决问题，后续会考虑golang的sync.Map安全map。</li><li>kube-state-metrics通过比较resource version来保证event的顺序</li><li>kube-state-metrics并不保证包含所有资源</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/kube-state-metrics" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kube-state-metrics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经有了cadvisor、heapster、metric-server，几乎容器运行的所有指标都能拿到，但是下面这种情况却无能为力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我调度了多少个replicas？现在可用的有几个？&lt;/li&gt;
&lt;li&gt;多少个Pod是running/stopped/terminated状态？&lt;/li&gt;
&lt;li&gt;Pod重启了多少次？&lt;/li&gt;
&lt;li&gt;我有多少job在运行中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些则是kube-state-metrics提供的内容，它基于client-go开发，轮询Kubernetes API，并将Kubernetes的结构化信息转换为metrics。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-15_kube-state-metrics.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Metrics Server</title>
    <link href="http://houmin.cc/posts/913a8837/"/>
    <id>http://houmin.cc/posts/913a8837/</id>
    <published>2020-09-15T03:39:59.000Z</published>
    <updated>2020-09-17T07:48:51.700Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>从 v1.8 开始，资源使用情况的监控可以通过 Metrics API的形式获取，具体的组件为Metrics Server，用来替换之前的 heapster，heapster从1.11开始逐渐被废弃。</p><p>Metrics-Server是集群核心监控数据的聚合器，从 Kubernetes1.8 开始，它作为一个 Deployment对象默认部署在由kube-up.sh脚本创建的集群中，如果是其他部署方式需要单独安装，或者咨询对应的云厂商。</p><a id="more"></a><h2 id="Metrics-API"><a href="#Metrics-API" class="headerlink" title="Metrics API"></a>Metrics API</h2><p>介绍Metrics-Server之前，必须要提一下Metrics API的概念</p><p>Metrics API相比于之前的监控采集方式(hepaster)是一种新的思路，官方希望核心指标的监控应该是稳定的，版本可控的，且可以直接被用户访问(例如通过使用 kubectl top 命令)，或由集群中的控制器使用(如HPA)，和其他的Kubernetes APIs一样。</p><p>官方废弃heapster项目，就是为了将核心资源监控作为一等公民对待，即像pod、service那样直接通过api-server或者client直接访问，不再是安装一个hepater来汇聚且由heapster单独管理。</p><p>假设每个pod和node我们收集10个指标，从k8s的1.6开始，支持5000节点，每个节点30个pod，假设采集粒度为1分钟一次，则：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">10 </span>x <span class="number">5000</span> x <span class="number">30</span> / <span class="number">60</span> = <span class="number">25000</span> 平均每分钟<span class="number">2</span>万多个采集指标</span><br></pre></td></tr></table></figure><p>因为k8s的api-server将所有的数据持久化到了etcd中，显然k8s本身不能处理这种频率的采集，而且这种监控数据变化快且都是临时数据，因此需要有一个组件单独处理他们，k8s版本只存放部分在内存中，于是metric-server的概念诞生了。</p><p>其实hepaster已经有暴露了api，但是用户和Kubernetes的其他组件必须通过master proxy的方式才能访问到，且heapster的接口不像api-server一样，有完整的鉴权以及client集成。这个api现在还在alpha阶段（18年8月），希望能到GA阶段。类api-server风格的写法：<a href="https://github.com/kubernetes/apiserver" target="_blank" rel="external nofollow noopener noreferrer">generic apiserver</a></p><p>有了Metrics Server组件，也采集到了该有的数据，也暴露了api，但因为api要统一，如何将请求到api-server的<code>/apis/metrics</code>请求转发给Metrics Server呢，解决方案就是：<a href="https://github.com/kubernetes/kube-aggregator" target="_blank" rel="external nofollow noopener noreferrer">kube-aggregator</a>,在k8s的1.7中已经完成，之前Metrics Server一直没有面世，就是耽误在了kube-aggregator这一步。</p><p>kube-aggregator（聚合api）主要提供：</p><ul><li>Provide an API for registering API servers.</li><li>Summarize discovery information from all the servers.</li><li>Proxy client requests to individual servers.</li></ul><p>详细设计文档：<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p>metric api的使用：</p><ul><li>Metrics API 只可以查询当前的度量数据，并不保存历史数据</li><li>Metrics API URI 为 /apis/metrics.k8s.io/，在 k8s.io/metrics 维护</li><li>必须部署 metrics-server 才能使用该 API，metrics-server 通过调用 Kubelet Summary API 获取数据</li></ul><p>如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/nodes</span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/nodes/&lt;node-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8001/apis</span><span class="regexp">/metrics.k8s.io/v</span>1beta1/namespace/&lt;namespace-name&gt;<span class="regexp">/pods/</span>&lt;pod-name&gt;</span><br></pre></td></tr></table></figure><h2 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics-Server"></a>Metrics-Server</h2><p>Metrics server定时从Kubelet的Summary API(类似/ap1/v1/nodes/nodename/stats/summary)采集指标信息，这些聚合过的数据将存储在内存中，且以metric-api的形式暴露出去。</p><p>Metrics server复用了api-server的库来实现自己的功能，比如鉴权、版本等，为了实现将数据存放在内存中吗，去掉了默认的etcd存储，引入了内存存储（即实现<a href="https://github.com/kubernetes/apiserver/blob/master/pkg/registry/rest/rest.go" target="_blank" rel="external nofollow noopener noreferrer">Storage interface</a>)。因为存放在内存中，因此监控数据是没有持久化的，可以通过第三方存储来拓展，这个和heapster是一致的。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png"></p><p>Metrics server出现后，新的Kubernetes 监控架构将变成上图的样子</p><ul><li>核心流程（黑色部分）：这是 Kubernetes正常工作所需要的核心度量，从 Kubelet、cAdvisor 等获取度量数据，再由metrics-server提供给 Dashboard、HPA 控制器等使用。</li><li>监控流程（蓝色部分）：基于核心度量构建的监控流程，比如 Prometheus 可以从 metrics-server 获取核心度量，从其他数据源（如 Node Exporter 等）获取非核心度量，再基于它们构建监控告警系统。</li></ul><p>官方地址：<a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/metrics-server</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如上文提到的，metric-server是扩展的apiserver，依赖于kube-aggregator，因此需要在apiserver中开启相关参数。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--requestheader-client-ca-file</span>=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line"><span class="attr">--proxy-client-cert-file</span>=/etc/kubernetes/certs/proxy.crt</span><br><span class="line"><span class="attr">--proxy-client-key-file</span>=/etc/kubernetes/certs/proxy.key</span><br><span class="line"><span class="attr">--requestheader-allowed-names</span>=aggregator</span><br><span class="line"><span class="attr">--requestheader-extra-headers-prefix</span>=X-Remote-Extra-</span><br><span class="line"><span class="attr">--requestheader-group-headers</span>=X-Remote-Group</span><br><span class="line"><span class="attr">--requestheader-username-headers</span>=X-Remote-User</span><br></pre></td></tr></table></figure><p>安装文件下载地址：<a href="https://github.com/kubernetes-incubator/metrics-server/tree/master/deploy/1.8%2B" target="_blank" rel="external nofollow noopener noreferrer">1.8+</a>，注意更换镜像地址为国内镜像</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> -f metric-<span class="keyword">server</span>/</span><br></pre></td></tr></table></figure><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/15473067971765.jpg"></p><p>安装成功后，访问地址api地址为：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/15473069387068.jpg"></p><p>Metrics Server的资源占用量会随着集群中的Pod数量的不断增长而不断上升，因此需要 addon-resizer垂直扩缩这个容器。addon-resizer依据集群中节点的数量线性地扩展Metrics Server，以保证其能够有能力提供完整的metrics API服务。具体参考：<a href="https://github.com/kubernetes/autoscaler/tree/master/addon-resizer" target="_blank" rel="external nofollow noopener noreferrer">链接</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>基于Metrics Server的HPA：<a href="http://blog.51cto.com/ylw6006/2115087" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p>kubernetes的新监控体系中，metrics-server属于Core metrics(核心指标)，提供API metrics.k8s.io，仅提供Node和Pod的CPU和内存使用情况。而其他Custom Metrics(自定义指标)由Prometheus等组件来完成，后续文章将对自定义指标进行解析。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/metrics-server</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 v1.8 开始，资源使用情况的监控可以通过 Metrics API的形式获取，具体的组件为Metrics Server，用来替换之前的 heapster，heapster从1.11开始逐渐被废弃。&lt;/p&gt;
&lt;p&gt;Metrics-Server是集群核心监控数据的聚合器，从 Kubernetes1.8 开始，它作为一个 Deployment对象默认部署在由kube-up.sh脚本创建的集群中，如果是其他部署方式需要单独安装，或者咨询对应的云厂商。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>cAdvisor</title>
    <link href="http://houmin.cc/posts/703a5727/"/>
    <id>http://houmin.cc/posts/703a5727/</id>
    <published>2020-09-15T02:10:58.000Z</published>
    <updated>2020-09-17T07:48:14.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>cAdvisor</code>即 <code>container advisor</code>，是Google为了对Node机器上的资源及容器进行实时监控和性能数据采集提出的开源解决方还提供基础查询界面和http接口，方便其他组件如Prometheus进行数据抓取，或者cadvisor + influxdb + grafna搭配使用。cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。cAdvisor使用Go语言开发，利用Linux的cgroups获取容器的资源使用信息，在 kubernetes 中集成在 kubelet 里作为默认启动项。</p><a id="more"></a><h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cadvisor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">google/cadvisor:v0.33.0</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rootfs</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/rootfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/sys</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--housekeeping_interval=10s</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--disable_metrics=disk</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rootfs</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var-run</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sys</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/sys</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker</span></span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cadvisor</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitoring</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">cadvisor.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">cadvisor</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">cadvisor</span></span><br></pre></td></tr></table></figure><p>在本地设置好 hosts 之后，访问 <code>http://cadvisor.houmin:&lt;TraefikNode&gt;/</code> 即可看到 <code>cAdvisor</code> 的界面。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_cadvisor.png"></p><h3 id="与-Prometheus-集成"><a href="#与-Prometheus-集成" class="headerlink" title="与 Prometheus 集成"></a>与 Prometheus 集成</h3><p>Step1: 修改 Prometheus 配置信息，添加 cadvisor 访问地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prometheus.yml</span></span><br><span class="line">    <span class="attr">scrape_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['node-exporter:9100']</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'container'</span></span><br><span class="line">        <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['cadvisor:8080']</span>  <span class="comment"># 本地 cadvisor 访问地址</span></span><br></pre></td></tr></table></figure><p>重新加载 Prometheus 配置，访问 <code>http://prometheus.houmin:30869/targets</code> 可以看到新加的 cAdvisor 已经生效。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor.png"></p><p>此时访问 Prometheus 的 graph 页面 <code>http://prometheus.houmin:30869/graph</code>，搜索 <code>container</code> 你将看到容器相关数据。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-graph.png"></p><p>在 Prometheus 中查看集群内存使用量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum by (name)(container_memory_usage_bytes&#123;image!=""&#125;)</span><br></pre></td></tr></table></figure><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_prometheus-cadvisor-memory.png"></p><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><div class="table-container"><table><thead><tr><th>分类</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>cpu</td><td>cpu_usage_total</td><td></td></tr><tr><td></td><td>cpu_usage_system</td><td></td></tr><tr><td></td><td>cpu_usage_user</td><td></td></tr><tr><td></td><td>cpu_usage_per_cpu</td><td></td></tr><tr><td></td><td>load_average</td><td>Smoothed average of number of runnable threads x 1000</td></tr><tr><td>memory</td><td>memory_usage</td><td>Memory Usage</td></tr><tr><td></td><td>memory_working_set</td><td>Working set size</td></tr><tr><td>network</td><td>rx_bytes</td><td>Cumulative count of bytes received</td></tr><tr><td></td><td>rx_errors</td><td>Cumulative count of receive errors encountered</td></tr><tr><td></td><td>tx_bytes</td><td>Cumulative count of bytes transmitted</td></tr><tr><td></td><td>tx_errors</td><td>Cumulative count of transmit errors encountered</td></tr><tr><td>filesystem</td><td>fs_device</td><td>Filesystem device</td></tr><tr><td></td><td>fs_limit</td><td>Filesystem limit</td></tr><tr><td></td><td>fs_usage</td><td>Filesystem usage</td></tr></tbody></table></div><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/5a577e4d0a5da14b7b634b5c62264f72.png"></p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> glog.Flush()</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> *versionFlag &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"cAdvisor version %s (%s)/n"</span>, version.Info[<span class="string">"version"</span>], version.Info[<span class="string">"revision"</span>])</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    setMaxProcs()</span><br><span class="line">    memoryStorage, err := NewMemoryStorage()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to initialize storage driver: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    sysFs, err := sysfs.NewRealSysFs()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to create a system interface: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    collectorHttpClient := createCollectorHttpClient(*collectorCert, *collectorKey)</span><br><span class="line">    containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to create a Container Manager: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    <span class="keyword">if</span> *enableProfiling &#123;</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">        mux.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register all HTTP handlers.</span></span><br><span class="line">    err = cadvisorhttp.RegisterHandlers(mux, containerManager, *httpAuthFile, *httpAuthRealm, *httpDigestFile, *httpDigestRealm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to register HTTP handlers: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    cadvisorhttp.RegisterPrometheusHandler(mux, containerManager, *prometheusEndpoint, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// Start the manager.</span></span><br><span class="line">    <span class="keyword">if</span> err := containerManager.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Fatalf(<span class="string">"Failed to start container manager: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Install signal handler.</span></span><br><span class="line">    installSignalHandler(containerManager)</span><br><span class="line">    glog.Infof(<span class="string">"Starting cAdvisor version: %s-%s on port %d"</span>, version.Info[<span class="string">"version"</span>], version.Info[<span class="string">"revision"</span>], *argPort)</span><br><span class="line">    addr := fmt.Sprintf(<span class="string">"%s:%d"</span>, *argIp, *argPort)</span><br><span class="line">    glog.Fatal(http.ListenAndServe(addr, mux))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过new出来的memoryStorage以及sysfs实例，创建一个manager实例，manager的interface中定义了许多用于获取容器和machine信息的函数。核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memoryStorage, err := NewMemoryStorage()</span><br><span class="line">sysFs, err := sysfs.NewRealSysFs()</span><br><span class="line">#创建containerManager</span><br><span class="line">containerManager, err := manager.New(memoryStorage, sysFs, *maxHousekeepingInterval, *allowDynamicHousekeeping, ignoreMetrics.MetricSet, &amp;collectorHttpClient)</span><br><span class="line">#启动containerManager</span><br><span class="line">err := containerManager.Start()</span><br></pre></td></tr></table></figure><p>核心函数：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/9c27a63d31346f4e6dc592e71977d568.png"></p><p>生成manager实例的时候，还需要传递两个额外的参数，分别是</p><ul><li>maxHousekeepingInterval：存在内存的时间，默认60s</li><li>allowDynamicHousekeeping：是否允许动态配置housekeeping，也就是下一次开始搜集容器信息的时间，默认true</li></ul><p>因为需要暴露服务，所以在handler文件中，将上面生成的containerManager注册进去（cadvisor/http/handler.go)，之后就是启动manager，运行其Start方法，开始搜集信息，存储信息的循环操作。</p><p>以memory采集为例：</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/197e5adaba371a4000ef9fd087dbf987.png"></p><p>具体的信息还是通过runc/libcontainer获得，libcontainer是对cgroup的封装。在/sys/fs/cgroup/memory中包含大量的了memory相关的信息（参考docker原生监控文章）</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/8d1b0d821546002af20648d131858457.png"></p><p>Prometheus的收集器（cadvisor/metrics/prometheus.go）</p><p><img alt="img" data-src="http://www.xuyasong.com/wp-content/uploads/2019/01/10f40e80b299ff5df8a99acca63c2644.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优缺点：</p><ul><li>优点：谷歌开源产品，监控指标齐全，部署方便，而且有官方的docker镜像。</li><li>缺点：是集成度不高，默认只在本地保存1分钟数据，但可以集成InfluxDB等存储</li></ul><p>备注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">爱奇艺参照cadvisor开发的dadvisor，数据写入graphite，</span><br><span class="line">等同于cadvisor+influxdb，但dadvisor并没有开源</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://luoji.live/categories/cadvisor/" target="_blank" rel="external nofollow noopener noreferrer">https://luoji.live/categories/cadvisor/</a></li><li><a href="https://github.com/google/cadvisor" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/google/cadvisor</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;cAdvisor&lt;/code&gt;即 &lt;code&gt;container advisor&lt;/code&gt;，是Google为了对Node机器上的资源及容器进行实时监控和性能数据采集提出的开源解决方还提供基础查询界面和http接口，方便其他组件如Prometheus进行数据抓取，或者cadvisor + influxdb + grafna搭配使用。cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。cAdvisor使用Go语言开发，利用Linux的cgroups获取容器的资源使用信息，在 kubernetes 中集成在 kubelet 里作为默认启动项。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-15_cadvisor.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="cadvisor" scheme="http://houmin.cc/tags/cadvisor/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】监控的可观测性</title>
    <link href="http://houmin.cc/posts/58272b06/"/>
    <id>http://houmin.cc/posts/58272b06/</id>
    <published>2020-09-15T01:15:58.000Z</published>
    <updated>2020-09-17T07:57:02.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>监控是大型分布式系统的重要基础设施，可以帮助开发者查看系统的运行状态。</p><a id="more"></a><h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><h3 id="监控类型"><a href="#监控类型" class="headerlink" title="监控类型"></a>监控类型</h3><ul><li>资源监控：监控CPU、内存、网络等资源的指标</li><li>性能监控：APM（Application Performance Monitoring）监控</li><li>安全监控：对越权管理、安全漏洞扫描等监控</li><li>事件监控：对k8s中的事件监控</li></ul><h3 id="资源指标"><a href="#资源指标" class="headerlink" title="资源指标"></a>资源指标</h3><p>对于kubernetes集群进行监控，主要可以分为两类：</p><ul><li>监控集群本身</li><li>监控Pod对象</li></ul><p>对于集群本身的监控主要包括：</p><ul><li>节点资源状态：主要包括网络带宽、磁盘空间、CPU和内存使用率</li><li>节点的数量：即时性了解集群的可用节点数量可以为用户计算服务器使用的费用支出提供参考</li><li>运行的Pod对象：正在运行的Pod对象数量可以评估可用节点数量是否足够，以及节点故障时是否能平衡负载。</li></ul><p>对于Pod资源的监控主要分为以下三类：</p><ul><li>Kubernetes指标：监测特定应用相关的Pod对象的部署过程、副本数量、状态信息、健康状态、网络使用等</li><li>容器级指标：容器的Resource Request、Resource Limit、CPU、内存、磁盘空间、网络带宽的实际占用情况</li><li>应用级指标：应用自身的内建指标，和业务规则相关</li></ul><h2 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h2><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="Docker-Stats"><a href="#Docker-Stats" class="headerlink" title="Docker Stats"></a>Docker Stats</h3><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-16_cadvisor.png"></p><h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><h3 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png"></p><h3 id="Kube-State-Metrics"><a href="#Kube-State-Metrics" class="headerlink" title="Kube-State-Metrics"></a>Kube-State-Metrics</h3><h3 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node-Exporter"></a>Node-Exporter</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_prometheus-node-exporter.png"></p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p><img alt="Prometheus" data-src="https://cdn.nlark.com/lark/0/2018/png/25353/1537426329901-660f59fd-12eb-441c-a637-28467b6447ff.png"></p><h2 id="展示与报警"><a href="#展示与报警" class="headerlink" title="展示与报警"></a>展示与报警</h2><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><h3 id="Zabbix-Dashboard"><a href="#Zabbix-Dashboard" class="headerlink" title="Zabbix Dashboard"></a>Zabbix Dashboard</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/monitoring_architecture.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes monitoring architecture</a></li><li><a href="https://yasongxu.gitbook.io/container-monitor" target="_blank" rel="external nofollow noopener noreferrer">https://yasongxu.gitbook.io/container-monitor</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;监控是大型分布式系统的重要基础设施，可以帮助开发者查看系统的运行状态。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-17_metrics-server.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="container" scheme="http://houmin.cc/tags/container/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="监控" scheme="http://houmin.cc/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="cAdvisor" scheme="http://houmin.cc/tags/cAdvisor/"/>
    
      <category term="Prometheus" scheme="http://houmin.cc/tags/Prometheus/"/>
    
      <category term="metrics" scheme="http://houmin.cc/tags/metrics/"/>
    
      <category term="observability" scheme="http://houmin.cc/tags/observability/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Envoy 入门</title>
    <link href="http://houmin.cc/posts/7beb34d2/"/>
    <id>http://houmin.cc/posts/7beb34d2/</id>
    <published>2020-09-11T11:15:08.000Z</published>
    <updated>2020-09-11T12:26:23.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Envoy</code> 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 <code>Envoy</code>没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，<code>Envoy</code>也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。</p><a id="more"></a><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img alt="Envoy Architecture" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p><p>首先介绍Envoy中的一些基本概念：</p><ul><li>Downstream：下游主机，指连接到Envoy的主机，这些主机用来发送请求并接受响应。</li><li>Upstream：上游主机，指接收来自Envoy连接和请求的主机，并返回响应。</li><li>Listener：服务或程序的监听器， Envoy暴露一个或多个监听器监听下游主机的请求，当监听到请求时，通过Filter Chain把对请求的处理全部抽象为Filter， 例如ReadFilter、WriteFilter、HttpFilter等。</li><li>Cluster：服务提供集群，指Envoy连接的一组逻辑相同的上游主机。Envoy通过服务发现功能来发现集群内的成员，通过负载均衡功能将流量路由到集群的各个成员。</li><li>xDS：xDS中的x是一个代词，类似云计算里的XaaS可以指代IaaS、PaaS、SaaS等。DS为Discovery Service，即发现服务的意思。xDS包括CDS（cluster discovery service）、RDS（route discovery service）、EDS（endpoint discovery service）、ADS（aggregated discovery service），其中ADS称为聚合的发现服务，是对CDS、RDS、LDS、EDS服务的统一封装，解决CDS、RDS、LDS、EDS信息更新顺序依赖的问题，从而保证以一定的顺序同步各类配置信息。以上Endpoint、Cluster、Route的概念介绍如下：<ul><li>Endpoint：一个具体的“应用实例”，类似于Kubernetes中的一个Pod；</li><li>Cluster：可以理解“应用集群”，对应提供相同服务的一个或多个Endpoint， 类似Kubernetes中Service概念，即一个Service提供多个相同服务的Pod；</li><li>Route：当我们做金丝雀发布部署时，同一个服务会有多个版本，这时需要Route规则规定请求如何路由到其中的某个版本上。</li></ul></li></ul><p>xDS模块的功能是通过Envoy API V1（基于HTTP）或V2（基于gRPC）实现一个服务端将配置信息暴露给上游主机，等待上游主机的拉取。</p><p>Envoy正常的工作流程为Host A（下游主机）发送请求至上游主机（Host B、Host C、Host D等），Envoy通过Listener监听到有下游主机的请求，收到请求后的Envoy将所有请求流量劫持至Envoy内部，并将请求内容抽象为Filter Chains路由至某个上游主机中从而实现路由转发及负载均衡能力。</p><p>Envoy为了实现流量代理能力通常需要一个统一的配置文件来记录信息以便启动时加载，在Envoy中启动配置文件有静态配置和动态配置两种方式。静态配置是将配置信息写入文件中，启动时直接加载，动态配置通过xDS实现一个Envoy的服务端（可以理解为以API接口对外实现服务发现能力）。</p><h3 id="Network-Topology"><a href="#Network-Topology" class="headerlink" title="Network Topology"></a>Network Topology</h3><p>Envoy作为Service Mesh中的 sidecar 代理，请求可以通过 ingress 或者 egress listener 到达 envoy。</p><ul><li>Ingress Listener 负责从服务网格中其他节点接受请求，并将请求转发到本地应用。本地应用的响应之后通过 Envoy 转发到 downstream。</li><li>Egress Listener 负责从本地应用接受请求，并将请求转发到服务网格中的其他节点。</li></ul><p><img alt="Service Mesh" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-service-mesh.svg"></p><p>除了服务网格外，Envoy还可以用作很多其他的请求，比如作为内部的负载均衡器：</p><p><img alt="Internal Load Balancer" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-ilb.svg"></p><p>或者作为网络边缘的 <code>ingress/egress</code> 代理：</p><p><img alt="Ingress/Egress Proxy on Network Edge" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-edge.svg"></p><p>在实际应用中，Envoy一般会发挥上述多种功能，一个网络请求路径中可能会通过多个Envoy：</p><p><img alt="Hybrid Envoy" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-hybrid.svg"></p><p>为了可靠性和可扩充性，Envoy可能会被配置成多层拓扑的形式：</p><p><img alt="Envoy Tiered" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-tiered.svg"></p><h3 id="High-Level-Architecture"><a href="#High-Level-Architecture" class="headerlink" title="High Level Architecture"></a>High Level Architecture</h3><p>Envoy中服务请求处理过程可以大致分为两个部分：</p><ul><li>Listener 子系统：处理来自 downstream 的请求。</li><li>Cluster 子系统：负责选择和配置 upstream 连接。</li></ul><p><img alt="High Level Architecture" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-architecture.svg"></p><p>Envoy采用了基于事件的线程模型：</p><ul><li>一个主线程负责server的生命周期，配置处理，统计等</li><li>多个worker线程负责处理请求。</li></ul><p>所有的线程都运行在一个基于 <a href="https://libevent.org/" target="_blank" rel="external nofollow noopener noreferrer">libevent</a> 的事件循环中，任何 downstream 的 TCP连接都会被分配一个 work 线程来处理</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Envoy 进程中运行着一系列 <code>Inbound/Outbound</code> 监听器（Listener），<code>Inbound</code> 代理入站流量，<code>Outbound</code> 代理出站流量。Listener 的核心就是过滤器链（FilterChain），链中每个过滤器都能够控制流量的处理流程。过滤器链中的过滤器分为两个类别：</p><ul><li><strong>网络过滤器</strong>（Network Filters）: 工作在 <code>L3/L4</code>，是 Envoy 网络连接处理的核心，处理的是原始字节，分为 <code>Read</code>、<code>Write</code> 和 <code>Read/Write</code> 三类。</li><li><strong>HTTP 过滤器</strong>（HTTP Filters）: 工作在 <code>L7</code>，由特殊的网络过滤器 <code>HTTP connection manager</code> 管理，专门处理 <code>HTTP1/HTTP2/gRPC</code> 请求。它将原始字节转换成 <code>HTTP</code> 格式，从而可以对 <code>HTTP</code> 协议进行精确控制。</li></ul><p>除了 <code>HTTP connection manager</code> 之外，还有一种特别的网络过滤器叫 <code>Thrift Proxy</code>。<code>Thrift</code> 是一套包含序列化功能和支持服务通信的 RPC 框架，详情参考<a href="https://zh.wikipedia.org/wiki/Thrift" target="_blank" rel="external nofollow noopener noreferrer">维基百科</a>。Thrift Proxy 管理了两个 Filter：<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/router_filter" target="_blank" rel="external nofollow noopener noreferrer">Router</a> 和 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/rate_limit_filter" target="_blank" rel="external nofollow noopener noreferrer">Rate Limit</a>。</p><p>除了过滤器链之外，还有一种过滤器叫<strong>监听器过滤器</strong>（Listener Filters），它会在过滤器链之前执行，用于操纵连接的<strong>元数据</strong>。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 <code>UDP</code> 时，就可以指定 UDP 监听器过滤器。根据上面的分类，Envoy 过滤器的架构如下图所示：</p><p><img alt="img" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504224710.png"></p><h2 id="Request-Flow"><a href="#Request-Flow" class="headerlink" title="Request Flow"></a>Request Flow</h2><h3 id="Listener-TCP-Accept"><a href="#Listener-TCP-Accept" class="headerlink" title="Listener TCP Accept"></a>Listener TCP Accept</h3><p><img alt="Listener TCP Accept" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listeners.svg"></p><h3 id="Listener-filter-chains-and-network-filter-chain-matching"><a href="#Listener-filter-chains-and-network-filter-chain-matching" class="headerlink" title="Listener filter chains and network filter chain matching"></a>Listener filter chains and network filter chain matching</h3><p><img alt="Listener Filter Chains" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listener-filters.svg"></p><p><img alt="../_images/lor-filter-chain-match.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-filter-chain-match.svg"></p><h3 id="TLS-transport-socket-decryption"><a href="#TLS-transport-socket-decryption" class="headerlink" title="TLS transport socket decryption"></a>TLS transport socket decryption</h3><p><img alt="../_images/lor-transport-socket.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-transport-socket.svg"></p><h3 id="Network-filter-chain-processing"><a href="#Network-filter-chain-processing" class="headerlink" title="Network filter chain processing"></a>Network filter chain processing</h3><p><img alt="../_images/lor-network-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-filters.svg"></p><p><img alt="../_images/lor-network-read.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-read.svg"></p><p><img alt="../_images/lor-network-write.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-write.svg"></p><h3 id="HTTP-2-codec-encoding"><a href="#HTTP-2-codec-encoding" class="headerlink" title="HTTP/2 codec encoding"></a>HTTP/2 codec encoding</h3><h3 id="TLS-transport-socket-encryption"><a href="#TLS-transport-socket-encryption" class="headerlink" title="TLS transport socket encryption"></a>TLS transport socket encryption</h3><p><img alt="../_images/lor-http-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-filters.svg"></p><p><img alt="../_images/lor-http.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http.svg"></p><p><img alt="../_images/lor-http-decode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-decode.svg"></p><p><img alt="../_images/lor-http-encode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-encode.svg"></p><p><img alt="../_images/lor-route-config.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-route-config.svg"></p><h3 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h3><p><img alt="../_images/lor-lb.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-lb.svg"></p><h3 id="Response-path-and-HTTP-lifecycle"><a href="#Response-path-and-HTTP-lifecycle" class="headerlink" title="Response path and HTTP lifecycle"></a>Response path and HTTP lifecycle</h3><p><img alt="../_images/lor-client.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-client.svg"></p><h3 id="Post-request-processing"><a href="#Post-request-processing" class="headerlink" title="Post-request processing"></a>Post-request processing</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.aliyun.com/article/606655" target="_blank" rel="external nofollow noopener noreferrer">https://developer.aliyun.com/article/606655</a></li><li><a href="https://www.cnblogs.com/popsuper1982/p/9841978.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/popsuper1982/p/9841978.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 &lt;code&gt;Envoy&lt;/code&gt;没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，&lt;code&gt;Envoy&lt;/code&gt;也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio 流量控制</title>
    <link href="http://houmin.cc/posts/151719f0/"/>
    <id>http://houmin.cc/posts/151719f0/</id>
    <published>2020-09-10T08:47:28.000Z</published>
    <updated>2020-09-11T12:16:08.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 <a href="../22cae0b8">Istio 入门</a> 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。</p><a id="more"></a><p><img alt="Istio Architecture" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h2 id="路由和流量转移"><a href="#路由和流量转移" class="headerlink" title="路由和流量转移"></a>路由和流量转移</h2><p>Istio 为了控制服务请求，引入了服务版本（version）的概念，可以通过版本这一标签将服务进行区分。版本的设置是非常灵活的，以下是几种典型的设置方式：</p><ul><li>根据服务的迭代编号进行定义（如 v1、v2 版本）</li><li>根据部署环境进行定义（比如 dev、staging、production）</li><li>自定义的任何用于区分服务的某种标记</li></ul><p>通过版本标签，Istio 就可以定义灵活的路由规则来控制流量，上面提到的金丝雀发布这类应用场景就很容易实现了。</p><p>下图展示了使用服务版本实现路由分配的例子。服务版本定义了版本号（v1.5、v2.0-alpha）和环境（us-prod、us-staging）两种信息。服务 B 包含了 4 个 Pod，其中 3 个是部署在生产环境的 v1.5 版本，而 Pod4 是部署在预生产环境的 v2.0-alpha 版本。运维人员可以根据服务版本来指定路由规则，使 99% 的流量流向 v1.5 版本，而 1% 的流量进入 v2.0-alpha 版本。</p><p><img alt="路由" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/concept-feature-routing.png"></p><p>除了上面介绍的服务间流量控制外，还能控制与网格边界交互的流量。可以在系统的入口和出口处部署 Sidecar 代理，让所有流入和流出的流量都由代理进行转发。负责入和出的代理就叫做入口网关和出口网关，它们把守着进入和流出网格的流量。下图展示了 Ingress 和 Egress 在请求流中的位置，有了他们俩，也就可以控制出入网格的流量了。</p><p><img alt="入口和出口网关" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/concept-feature-gateway.png"></p><p>Istio 还能设置流量策略。比如可以对连接池相关的属性进行设置，通过修改最大连接等参数，实现对请求负载的控制。还可以对负载均衡策略进行设置，在轮询、随机、最少访问等方式之间进行切换。还能设置异常探测策略，将满足异常条件的实例从负载均衡池中摘除，以保证服务的稳定性。</p><hr><p>Istio 的流量路由规则可以让您很容易的控制服务之间的流量和 API 调用。Istio 在服务层面提供了断路器，超时，重试等功能，通过这些功能可以简单地实现 A/B 测试，金丝雀发布，基于百分比的流量分割等，此外还提供了开箱即用的故障恢复功能，用于增加应用的健壮性，以应对服务故障或网络故障。这些功能都可以通过 Istio 的流量管理 API 添加流量配置来实现。</p><p>跟其他 Istio 配置一样，流量管理 API 也使用 CRD 指定。本小节主要介绍下面几个典型的流量管理 API 资源，以及这些 API 的功能和使用示例。</p><h3 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h3><p>VirtualService 由一组 <strong>路由规则</strong> 组成，描述了 <strong>用户请求的目标地址</strong> 到 <strong>服务网格中实际工作负载</strong> 之间的映射。在这个映射中，VirtualService提供了丰富的配置方式，可以为发送到这些 Workloads 的流量指定不同的路由规则。对应于具体的配置，用户请求的目标地址用 <code>hosts</code> 字段来表示，网格内的实际负载由每个 <code>route</code> 配置项中的 <code>destination</code> 字段指定。</p><pre class="mermaid">graph LRsubgraph VirtualServiceClientRequests -- DifferentTrafficRoutingRules --> DestinationWorkloadsHosts -- DifferentTrafficRoutingRules --> RouteDestinationend</pre><p>VirtualService 通过解耦 <strong>用户请求的目标地址</strong> 和 <strong>真实响应请求的目标工作负载</strong>，为服务提供了合适的统一抽象层，而由此演化设计的配置模型为管理这方面提供了一致的环境。对于原生 Kubernetes 而言，只有在 Ingress 处有这种路由规则的定义，对于集群内部不同Service的不同版本之间，并没有类似 VirtualService 的定义。</p><p>使用 VirtualService，可以为一个或多个主机名指定流量行为。在 VirtualService 中使用路由规则，告诉 Envoy如何发送 VirtualService 的流量到适当的目标。路由目标可以是相同服务的不同版本，或者是完全不同的服务。</p><p>一个典型的应用场景是将流量发送到被指定为服务子集的服务的不同版本。客户端将 VirtualService 视为一个单一实体，将请求发送至 VirtualService 主机，然后 Envoy 根据 VirtualService 规则把流量路由到不同的版本中。</p><p>这种方式可以方便地创建一种金丝雀的发布策略实现新版本流量的平滑比重升级。流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。相比之下，类似 Kubernetes 的容器调度平台仅支持基于部署中实例扩缩容比重的流量分发，那样会日趋复杂化。关于使用VirtualService实现金丝雀部署，可以参考 <a href="https://istio.io/latest/blog/2017/0.1-canary/" target="_blank" rel="external nofollow noopener noreferrer">Canary</a> 。</p><p>VirtualService 也提供了如下功能。</p><ul><li>通过单个 VirtualService 处理多个应用程序服务。例如，如果您的服务网格使用是 Kubernetes，您可以配置一个 VirtualService 来处理一个特定命名空间的所有服务。将单一的 VirtualService 映射为多个“真实”的服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。您的路由规则可以指定“请求到 <code>monolith.com</code> 的 URLs 跳转至 <code>microservice A</code> 中”。</li><li>和 Gateway  一起配置流量规则来控制入口和出口流量。</li></ul><p>在一些应用场景中，由于指定服务子集，需要配置 DestinationRule 来使用这些功能。在不同的对象中指定服务子集以及其他特定的目标策略可以帮助您在不同的 VirtualService 中清晰地复用这些功能。</p><p>下面的 VirtualService 根据是否来自于特定用户路由请求到不同的服务版本中（如果请求来自用户 <code>jason</code> ，则访问 <code>v2</code> 版本的 <code>reviews</code>，否则访问 <code>v3</code> 版本）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>下面对这些字段依次解释：</p><h4 id="Hosts"><a href="#Hosts" class="headerlink" title="Hosts"></a>Hosts</h4><p>用来配置 Downstream 访问的可寻址地址，也就是用户请求的目标地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">reviews</span></span><br></pre></td></tr></table></figure><ul><li>VirtualService 主机名可以是 IP 地址、 DNS 域名、完全限定域名（FQDN)</li><li>也可以是 依赖于平台的一个简称（例如 Kubernetes 服务的短名称）</li><li>也可以使用通配符 <code>*</code>前缀，创建一组匹配所有服务的路由规则</li><li>VirtualService 的 <code>hosts</code> 实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址。这可以为没有路由到网格内部的虚拟主机建模。</li></ul><h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><p><code>http</code> 字段用来配置路由规则，通常情况下配置一组路由规则，当请求到来时，自上而下依次进行匹配，直到匹配成功后跳出匹配。它可以对请求的 uri、method、authority、headers、port、queryParams 以及是否对 uri 大小写敏感等进行配置。</p><blockquote><p>除了HTTP协议，也可以使用 <code>tcp</code> 和 <code>tls</code> 片段为 <a href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#TCPRoute" target="_blank" rel="external nofollow noopener noreferrer">TCP</a> 和未终止的 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#TLSRoute" target="_blank" rel="external nofollow noopener noreferrer">TLS</a> 流量设置路由规则</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">end-user:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>我们推荐在每个 VirtualService 中配置一条默认「无条件的」或者基于权重的规则以确保 VirtualService 至少有一条匹配的路由。</p><h5 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h5><p>路由片段的 <code>destination</code> 字段指定符合匹配条件的流量目标地址。这里不像 VirtualService 的 <code>hosts</code>，Destination 的 <code>host</code> 必须是存在于 Istio 服务注册中心的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。这个目标地址可以是代理的网格服务或者作为服务入口加入的非网格服务。下面的场景中我们运行在 Kubernetes 平台上，主机名是 Kubernetes 的服务名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">subset:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">*Note for Kubernetes users*: When short names are used (e.g. "reviews" instead of "reviews.default.svc.cluster.local"), Istio will interpret the short name based on the namespace of the rule, not the service. A rule in the "default" namespace containing a host "reviews will be interpreted as "reviews.default.svc.cluster.local", irrespective of the actual namespace associated with the reviews service. To avoid potential misconfiguration, it is recommended to always use fully qualified domain names over short names.</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>路由规则是将特定流量子集路由到特定目标地址的强大工具。可以在流量端口、<code>header</code> 字段、 URL 等内容上设置匹配条件。例如，下面的VirtualService 使用户发送流量到两个独立的服务，ratings and reviews， 就好像它们是 <code>http://bookinfo.com/</code> 这个更大的 VirtualService 的一部分。VirtualService 规则根据请求的 URL 和指向适当服务的请求匹配流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bookinfo.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/ratings</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br></pre></td></tr></table></figure><p>对于匹配条件，您可以使用确定的值，一条前缀、或者一条正则表达式。</p><p>您可以使用 <code>AND</code> 向同一个 <code>match</code> 块添加多个匹配条件， 或者使用 <code>OR</code> 向同一个规则添加多个 <code>match</code> 块。对于任意给定的 VirtualService ，您可以配置多条路由规则。这可以使您的路由条件在一个单独的 VirtualService 中基于业务场景的复杂度来进行相应的配置。可以在 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPMatchRequest" target="_blank" rel="external nofollow noopener noreferrer">HTTPMatchRequest 参考</a>中查看匹配条件字段和他们可能的值。</p><p>再者进一步使用匹配条件，您可以使用基于“权重”百分比分发流量。这在 A/B 测试和金丝雀部署中非常有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">75</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>您也可以使用路由规则在流量上执行一些操作，例如</p><ul><li>扩展或者删除 <code>headers</code></li><li>重写 URL</li><li>为调用这个目标地址设置重试策略</li></ul><h3 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h3><p><code>DestinationRule</code> 是 Istio 流量路由功能的重要组成部分。一个 <code>VirtualService</code> 可以看作是如何将流量分发到给定的目标地址，然后调用 <code>DestinationRule</code> 来配置分发到该目标地址的流量。<code>DestinationRule</code> 在 <code>VirtualService</code> 的路由规则之后起作用(即在 <code>VirtualService</code> 的 <code>match</code> -&gt; <code>route</code> -&gt; <code>destination</code> 之后起作用，此时流量已经分发到真实的 <code>Service</code> 上)，应用于真实的目标地址。</p><p>特别地，可以使用 <code>DestinationRule</code> 来指定命名的服务子集，例如根据版本对服务的实例进行分组，然后通过 <code>VirtualService</code> 的路由规则中的服务子集将控制流量分发到不同服务的实例中。</p><p><code>DestinationRule</code> 允许在调用完整的目标服务或特定的服务子集(如倾向使用的负载均衡模型，TLS 安全模型或断路器)时自定义 Envoy流量策略。Istio 默认会使用轮询策略，此外 Istio 也支持如下负载均衡模型，可以在 <code>DestinationRule</code> 中使用这些模型，将请求分发到特定的服务或服务子集。</p><ul><li>Random：将请求转发到一个随机的实例上</li><li>Weighted：按照指定的百分比将请求转发到实例上</li><li>Least requests：将请求转发到具有最少请求数目的实例上</li></ul><p>下面的 <code>DestinationRule</code> 使用不同的负载均衡策略为 my-svc 目的服务配置了3个不同的 Subset</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-destination-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">my-svc</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span>     <span class="comment">#默认的负载均衡策略模型为随机</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">RANDOM</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  <span class="comment">#subset1，将流量转发到具有标签 version:v1 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  <span class="comment">#subset2，将流量转发到具有标签 version:v2 的 deployment 对应的服务上,指定负载均衡为轮询</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span>   <span class="comment">#subset3，将流量转发到具有标签 version:v3 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>每个子集由一个或多个 <code>labels</code> 定义，对应 Kubernetes 中的对象(如 <code>Pod</code> )的 key/value 对。这些标签定义在 Kubernetes 服务的 deployment 的 metadata 中，用于标识不同的版本。</p><p>除了定义子集外，<code>DestinationRule</code> 还定义了该目的地中所有子集的默认流量策略，以及仅覆盖该子集的特定策略。默认的策略定义在 <code>subset</code> 字段之上，为 <code>v1</code> 和 <code>v3</code> 子集设置了随机负载均衡策略，在 <code>v2</code> 策略中使用了轮询负载均衡。</p><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Gateway 用于管理进出网格的流量，指定可以进入或离开网格的流量。Gateway 配置应用于网格边缘的独立的 Envoy代理上，而不是服务负载的 Envoy 代理上。</p><p>与其他控制进入系统的流量的机制(如 Kubernetes Ingress API)不同，Istio gateway 允许利用 Istio 的流量路由的强大功能和灵活性。Istio 的 gateway 资源仅允许配置 4-6 层的负载属性，如暴露的端口，TLS 配置等等，但结合 Istio 的 <code>VirtualService</code>，就可以像管理 Istio 网格中的其他数据面流量一样管理 Gateway 的流量。</p><p>Gateway 主要用于管理 Ingress 流量，但也可以配置 Egress Gateway。通过 Egress Gateway 可以配置流量离开网格的特定节点，限制哪些服务可以访问外部网络，或通过 Egress 安全控制来提高网格的安全性。Gateway 可以用于配置为一个纯粹的内部代理。</p><p>Istio (通过 <code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code> 参数)提供了一些预配置的 Gateway 代理，<code>default</code> profile 下仅会部署 Ingress Gateway。Gateway 可以通过部署文件进行部署，也可以单独部署。</p><p>下面是 <code>default</code> profile 默认安装的 Ingress</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get gw</span><br><span class="line">NAME               AGE</span><br><span class="line">bookinfo-gateway   28h</span><br></pre></td></tr></table></figure><p>可以看到该 ingress 就是一个普通的 <code>Pod</code>，该 <code>Pod</code> 仅包含一个 Istio-proxy 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n istio-system |grep ingress</span><br><span class="line">istio-ingressgateway-64f6f9d5c6-qrnw2 1/1 Running 0 4d20h</span><br></pre></td></tr></table></figure><p>下面是一个 Gateway 的例子，用于配置外部 HTTPS 的 ingress 流量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-host-gwy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>              <span class="comment">#指定 gateway 配置下发的代理，如具有标签 app: my-gateway-controller 的 pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-gateway-controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span>                <span class="comment">#gateway pod 暴露的端口信息</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span>                <span class="comment">#外部流量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/tmp/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/tmp/tls.key</span></span><br></pre></td></tr></table></figure><p>上述 Gateway 配置允许来自 <code>ext-host.example.com</code> 流量进入网格的 443 端口，但没有指定该流量的路由。(此时流量只能进入网格，但没有指定处理该流量的服务，因此需要与 <code>VirtualService</code> 进行绑定)</p><p>为了为 Gateway 指定路由，需要通过 <code>VirtualService</code> 的 <code>Gateway</code> 字段，将 <code>Gateway</code> 绑定到一个 <code>VirtualService</code> 上，将来自 <code>ext-host.example.com</code> 流量引入一个 <code>VirtualService</code>，<code>hosts</code> 可以是通配符，表示引入匹配到的流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">virtual-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">  <span class="attr">gateways:</span>        <span class="comment">#将 gateway "ext-host-gwy" 绑定到 virtual service "virtual-svc"上</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host-gwy</span></span><br></pre></td></tr></table></figure><p>Egress Gateway 提供了对网格的出口流量进行统一管控的功能，在安装 Istio 时默认是不开启的。可以使用以下命令查看是否开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod -l istio=egressgateway -n istio-system</span></span><br></pre></td></tr></table></figure><p>若没有开启，使用以下命令添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl manifest apply --<span class="built_in">set</span> values.global.istioNamespace=istio-system \</span><br><span class="line">    --<span class="built_in">set</span> values.gateways.istio-egressgateway.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Egress Gateway 的一个简单示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-egressgateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">egressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">edition.cnn.com</span></span><br></pre></td></tr></table></figure><p>可以看出，与 Ingress Gateway 不同，Egress Gateway 使用有 <code>istio: egressgateway</code> 标签的 Pod 来代理流量，实际上这也是一个 Envoy 代理。当网格内部需要访问 <code>edition.cnn.com</code> 这个地址时，流量将会统一先转发到 Egress Gateway 上，再由 Egress Gateway 将流量转发到 <code>edition.cnn.com</code> 上。</p><h3 id="ServiceEntry"><a href="#ServiceEntry" class="headerlink" title="ServiceEntry"></a>ServiceEntry</h3><p>Istio 支持对接 Kubernetes、Consul 等多种不同的注册中心，控制平面<code>Pilot</code>启动时，会从指定的注册中心获取 <code>Service Mesh</code> 集群的服务信息和实例列表，并将这些信息进行处理和转换，然后通过 xDS 下发给对应的数据平面，保证服务之间可以互相发现并正常访问。</p><p>同时，由于这些服务和实例信息都来源于服务网格内部，Istio 无法从注册中心直接获取网格外的服务，导致不利于网格内部与外部服务之间的通信和流量管理。为此，Istio 引入 ServiceEntry 实现对外通信和管理。</p><p>使用 ServiceEntry 可以将外部的服务条目添加到 Istio 内部的服务注册表中，以便让网格中的服务能够访问并路由到这些手动指定的服务。ServiceEntry 描述了服务的属性（DNS 名称、VIP、端口、协议、端点）。这些服务可能是位于网格外部（如，web APIs），也可能是处于网格内部但不属于平台服务注册表中的条目（如，需要和 Kubernetes 服务交互的一组虚拟机服务）。</p><h4 id="ServiceEntry-示例和属性介绍"><a href="#ServiceEntry-示例和属性介绍" class="headerlink" title="ServiceEntry 示例和属性介绍"></a>ServiceEntry 示例和属性介绍</h4><p>对于网格外部的服务，下面的 ServiceEntry 示例表示网格内部的应用通过 https 访问外部的 API。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.google.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure><p>对于在网格内部但不属于平台服务注册表的服务，使用下面的示例可以将一组在非托管 VM 上运行的 MongoDB 实例添加到 Istio 的注册中心，以便可以将这些服务视为网格中的任何其他服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-svc-mongocluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mymongodb.somedomain</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.192</span><span class="number">.192</span><span class="number">.192</span><span class="string">/24</span> <span class="comment"># VIPs</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">27018</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">MONGO</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_INTERNAL</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">STATIC</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p>结合上面给出的示例，这里对 ServiceEntry 涉及的关键属性解释如下：</p><ul><li><code>hosts</code>: 表示与该 ServiceEntry 相关的主机名，可以是带有通配符前缀的 DNS 名称。</li><li><code>address</code>: 与服务相关的虚拟 IP 地址，可以是 CIDR 前缀的形式。</li><li><code>ports</code>: 和外部服务相关的端口，如果外部服务的 endpoints 是 Unix socket 地址，这里必须只有一个端口。</li><li><code>location</code>: 用于指定该服务属于网格内部（MESH_INTERNAL）还是外部（MESH_EXTERNAL）。</li><li><code>resolution</code>: 主机的服务发现模式，可以是 NONE、STATIC、DNS。</li><li><code>endpoints</code>: 与服务相关的一个或多个端点。</li><li><code>exportTo</code>: 用于控制 ServiceEntry 跨命名空间的可见性，这样就可以控制在一个命名空间下定义的资源对象是否可以被其他命名空间下的 <code>Sidecar</code>、Gateway 和 VirtualService 使用。目前支持两种选项，”.” 表示仅应用到当前命名空间，”*” 表示应用到所有命名空间。</li></ul><h4 id="使用-ServiceEntry-访问外部服务"><a href="#使用-ServiceEntry-访问外部服务" class="headerlink" title="使用 ServiceEntry 访问外部服务"></a>使用 ServiceEntry 访问外部服务</h4><p>Istio 提供了三种访问外部服务的方法：</p><ol><li>允许 <code>Sidecar</code> 将请求传递到未在网格内配置过的任何外部服务。使用这种方法时，无法监控对外部服务的访问，也不能利用 Istio 的流量控制功能。</li><li>配置 ServiceEntry 以提供对外部服务的受控访问。这是 Istio 官方推荐使用的方法。</li><li>对于特定范围的 IP，完全绕过 <code>Sidecar</code>。仅当出于性能或其他原因无法使用 <code>Sidecar</code> 配置外部访问时，才建议使用该配置方法。</li></ol><p>这里，我们重点讨论第 2 种方式，也就是使用 ServiceEntry 完成对网格外部服务的受控访问。</p><p>对于 <code>Sidecar</code> 对外部服务的处理方式，Istio 提供了两种选项:</p><ul><li><code>ALLOW_ANY</code>：默认值，表示 Istio 代理允许调用未知的外部服务。上面的第一种方法就使用了该配置项。</li><li><code>REGISTRY_ONLY</code>：Istio 代理会阻止任何没有在网格中定义的 HTTP 服务或 ServiceEntry 的主机。</li></ul><p>可以使用下面的命令查看当前所使用的模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | grep -o <span class="string">"mode: ALLOW_ANY"</span></span><br><span class="line">mode: ALLOW_ANY</span><br></pre></td></tr></table></figure><p>如果当前使用的是 <code>ALLOW_ANY</code> 模式，可以使用下面的命令切换为 <code>REGISTRY_ONLY</code> 模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | sed <span class="string">'s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g'</span> | kubectl replace -n istio-system -f -</span><br><span class="line">configmap <span class="string">"istio"</span> replaced</span><br></pre></td></tr></table></figure><p>在 <code>REGISTRY_ONLY</code> 模式下，需要使用 ServiceEntry 才能完成对外部服务的访问。当创建如下的 ServiceEntry 时，服务网格内部的应用就可以正常访问 httpbin.org 服务了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure><h4 id="管理外部流量"><a href="#管理外部流量" class="headerlink" title="管理外部流量"></a>管理外部流量</h4><p>使用 ServiceEntry 可以使网格内部服务发现并访问外部服务，除此之外，还可以对这些到外部服务的流量进行管理。结合 VirtualService 为对应的 ServiceEntry 配置外部服务访问规则，如请求超时、故障注入等，实现对指定服务的受控访问。</p><p>下面的示例就是为外部服务 httpbin.org 设置了超时时间，当请求时间超过 3s 时，请求就会直接中断，避免因外部服务访问时延过高而影响内部服务的正常运行。由于外部服务的稳定性通常无法管控和监测，这种超时机制对内部服务的正常运行具有重要意义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>同样的，我们也可以为 ServiceEntry 设置故障注入规则，为系统测试提供基础。下面的示例表示为所有访问 <code>httpbin.org</code> 服务的请求注入一个403错误。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">httpbin-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line"> <span class="attr">http:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">       <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">   <span class="attr">fault:</span></span><br><span class="line">     <span class="attr">abort:</span></span><br><span class="line">       <span class="attr">percent:</span> <span class="number">100</span></span><br><span class="line">       <span class="attr">httpStatus:</span> <span class="number">403</span></span><br></pre></td></tr></table></figure><h3 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h3><p>在默认的情况下，Istio 中所有 Pod 中的 Envoy 代理都是可以被寻址的。然而在某些场景下，我们为了做资源隔离，希望只访问某些 Namespace 下的资源。这个时候，我们就可以使用 Sidecar配置来实现。下面是一个简单的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sidecar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"./*"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"istio-system/*"</span></span><br></pre></td></tr></table></figure><p>该示例就规定了在命名空间为 bookinfo 下的所有服务仅可以访问本命名空间下的服务以及 <code>istio-system</code> 命名空间下的服务。</p><h2 id="弹性功能"><a href="#弹性功能" class="headerlink" title="弹性功能"></a>弹性功能</h2><p>除了最核心的路由和流量转移功能外，Istio 还提供了一定的弹性功能，目前支持超时、重试和熔断。</p><h3 id="Request-Timeouts"><a href="#Request-Timeouts" class="headerlink" title="Request Timeouts"></a>Request Timeouts</h3><p>如果程序请求长时间无法返回结果，则需要设置超时机制，超过设置的时间则返回错误信息。这样做既可以节约等待时消耗的资源，也可以避免由于级联错误引起的一系列问题。</p><p>设置超时的方式也有很多种，比如通过修改代码在应用程序侧设置请求超时时间，但是这样很不灵活，也容易出现遗漏的现象，而 Istio 则可以在基础设施层解决这一问题。在 Istio 里添加超时非常简单，只需要在路由配置里添加 <code>timeout</code> 这个关键字就可以实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><h3 id="Retries"><a href="#Retries" class="headerlink" title="Retries"></a>Retries</h3><p>在网络环境不稳定的情况下，会出现暂时的网络不可达现象，这时需要重试机制，通过多次尝试来获取正确的返回信息。重试逻辑可以写业务代码中，比如 Bookinfo 应用中的<code>productpage</code>服务就存在硬编码重试，而 Istio 可以通过简单的配置来实现重试功能，让开发人员无需关注重试部分的代码实现，专心实现业务代码。在 Istio 里添加超时和重试都非常简单，只需要在路由配置里添 <code>retry</code> 这个关键字就可以实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">2s</span></span><br></pre></td></tr></table></figure><h3 id="Circuit-Breaking"><a href="#Circuit-Breaking" class="headerlink" title="Circuit Breaking"></a>Circuit Breaking</h3><p>熔断是一种非常有用的过载保护手段，可以避免服务的级联失败。在熔断器中，设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。熔断适用于在负载均衡池中的“真实”网格目标地址，可以在 DestinationRule 中配置熔断器阈值，让配置适用于服务中的每个主机。</p><p>Istio 里面的熔断需要在自定义资源 <code>DestinationRule</code> 的 <code>TrafficPolicy</code> 里进行设置。下面的示例将 v1 子集的<code>reviews</code>服务工作负载的并发连接数限制为 100：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">connectionPool:</span></span><br><span class="line">        <span class="attr">tcp:</span></span><br><span class="line">          <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Istio 还提供了对流量进行调试的能力，包括故障注入和流量镜像。对流量进行调试可以让系统具有更好的容错能力，也方便我们在问题排查时通过调试来快速定位原因所在。</p><h3 id="Fault-Injection"><a href="#Fault-Injection" class="headerlink" title="Fault Injection"></a>Fault Injection</h3><p>在一个微服务架构的系统中，为了让系统达到较高的健壮性要求，通常需要对系统做定向错误测试。比如电商中的订单系统、支付系统等若出现故障那将是非常严重的生产事故，因此必须在系统设计前期就需要考虑多样性的异常故障并对每一种异常设计完善的恢复策略或优雅的回退策略，尽全力规避类似事故的发生，使得当系统发生故障时依然可以正常运作。而在这个过程中，服务故障模拟一直以来是一个非常繁杂的工作，于是在这样的背景下就衍生出了故障注入技术手段，故障注入是用来模拟上游服务请求响应异常行为的一种手段。通过人为模拟上游服务请求的一些故障信息来检测下游服务的故障策略是否能够承受这些故障并进行自我恢复。</p><p>Istio 提供了一种无侵入式的故障注入机制，让开发测试人员在不用调整服务程序的前提下，通过配置即可完成对服务的异常模拟。Istio 1.5 仅支持网络层的故障模拟，即支持模拟上游服务的处理时长、服务异常状态、自定义响应状态码等故障信息，暂不支持对于服务主机内存、CPU 等信息故障的模拟。他们都是通过配置上游主机的 VirtualService 来实现的。当我们在 VirtualService 中配置了故障注入时，上游服务的 Envoy代理在拦截到请求之后就会做出相应的响应。</p><p>目前，Istio 提供两种类型的故障注入，abort 类型与 delay 类型。</p><ul><li><strong>abort</strong>：非必配项，配置一个 Abort 类型的对象。用来注入请求异常类故障。简单的说，就是用来模拟上游服务对请求返回指定异常码时，当前的服务是否具备处理能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-faultabort" target="_blank" rel="external nofollow noopener noreferrer">config.filter.http.fault.v2.FaultAbort</a> 配置项，当 VirtualService 资源应用时，Envoy将会该配置加载到过滤器中并处理接收到的流量。</li><li><strong>delay</strong>：非必配项，配置一个 Delay 类型的对象。用来注入延时类故障。通俗一点讲，就是人为模拟上游服务的响应时间，测试在高延迟的情况下，当前的服务是否具备容错容灾的能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/fault/v2/fault.proto#envoy-api-msg-config-filter-fault-v2-faultdelay" target="_blank" rel="external nofollow noopener noreferrer">config.filter.fault.v2.FaultDelay</a> 配置型，同样也是在应用 Istio 的 VirtualService 资源时，Envoy将该配置加入到过滤器中。</li></ul><p>实际上，Istio 的故障注入正是基于 Envoy的 config.filter.http.fault.v2.HTTPFault 过滤器实现的，它的局限性也来自于 Envoy故障注入机制的局限性。对于 Envoy的 HttpFault 的详细介绍请参考 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-httpfault" target="_blank" rel="external nofollow noopener noreferrer">Envoy 文档</a>。对比 Istio 故障注入的配置项与 Envoy故障注入的配置项，不难发现，Istio 简化了对于故障控制的手段，去掉了 Envoy中通过 HTTP header 控制故障注入的配置。</p><h4 id="HTTPFaultInjection-Abort"><a href="#HTTPFaultInjection-Abort" class="headerlink" title="HTTPFaultInjection.Abort"></a>HTTPFaultInjection.Abort</h4><ul><li><strong>httpStatus</strong>：必配项，是一个整型的值。表示注入 HTTP 请求的故障状态码。</li><li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li><li><strong>percent</strong>：已经废弃的一个配置，与 percentage 配置功能一样，已经被 percentage 代替。</li></ul><p>如下的配置表示对 <code>v1</code> 版本的 <code>ratings.prod.svc.cluster.local</code> 服务访问的时候进行故障注入，<code>0.1</code>表示有千分之一的请求被注入故障， <code>400</code> 表示故障为该请求的 HTTP 响应码为 <code>400</code> 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">abort:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">httpStatus:</span> <span class="number">400</span></span><br></pre></td></tr></table></figure><h4 id="HTTPFaultInjection-Delay"><a href="#HTTPFaultInjection-Delay" class="headerlink" title="HTTPFaultInjection.Delay"></a>HTTPFaultInjection.Delay</h4><ul><li><strong>fixedDelay</strong>：必配项，表示请求响应的模拟处理时间。格式为：<code>1h/1m/1s/1ms</code>， 不能小于 <code>1ms</code>。</li><li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li><li><strong>percent</strong>：已经废弃的一个配置，与 <code>percentage</code> 配置功能一样，已经被 <code>percentage</code> 代替。</li></ul><p>如下的配置表示对 <code>v1</code> 版本的 <code>reviews.prod.svc.cluster.local</code> 服务访问的时候进行延时故障注入，<code>0.1</code> 表示有千分之一的请求被注入故障，<code>5s</code> 表示<code>reviews.prod.svc.cluster.local</code> 延时 <code>5s</code>返回。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure><h3 id="Mirroring"><a href="#Mirroring" class="headerlink" title="Mirroring"></a>Mirroring</h3><p>流量镜像（Mirroring / traffic-shadow），也叫作影子流量，就是通过复制一份请求并把它发送到镜像服务，从而实现流量的复制功能。流量镜像的主要应用场景有以下几种：最主要的就是进行<strong>线上问题排查</strong>。</p><p>一般情况下，因为系统环境，特别是数据环境、用户使用习惯等问题，我们很难在开发环境中模拟出真实的生产环境中出现的棘手问题，同时生产环境也不能记录太过详细的日志，因此很难定位到问题。有了流量镜像，我们就可以把真实的请求发送到镜像服务，再打开 debug 日志来查看详细的信息。除此以外，还可以通过它来观察生产环境的请求处理能力，比如在镜像服务进行压力测试。也可以将复制的请求信息用于数据分析。流量镜像在 Istio 里实现起来也非常简单，只需要在路由配置中通添加<code>mirror</code>关键字即可。</p><h4 id="流量镜像能够为我们带来什么"><a href="#流量镜像能够为我们带来什么" class="headerlink" title="流量镜像能够为我们带来什么"></a>流量镜像能够为我们带来什么</h4><p>很多情况下，当我们对服务做了重构，或者我们对项目做了重大优化时，怎么样保证服务是健壮的呢？在传统的服务里，我们只能通过大量的测试，模拟在各种情况下服务的响应情况。虽然也有手工测试、自动化测试、压力测试等一系列手段去检测它，但是测试本身就是一个样本化的行为，即使测试人员再完善它的测试样例，无法全面的表现出线上服务的一个真实流量形态。往往当项目发布之后，总会出现一些意外，比如你服务里收到客户使用的某些数据库不认识的特殊符号，再比如用户在本该输入日期的输入框中输入了 “—” 字样的字符，又比如用户使用乱码替换你的 token 值批量恶意攻击服务等等，这样的情况屡见不鲜。数据的多样性，复杂性决定了开发人员在开发阶段根本是无法考虑周全的。</p><p>而流量镜像的设计，让这类问题得到了最大限度的解决。流量镜像讲究的不再是使用少量样本去评估一个服务的健壮性，而是在不影响线上坏境的前提下将线上流量持续的镜像到我们的预发布坏境中去，让重构后的服务在上线之前就结结实实地接受一波真实流量的冲击与考验，让所有的风险全部暴露在上线前夕，通过不断的暴露问题，解决问题让服务在上线前夕就拥有跟线上服务一样的健壮性。由于测试坏境使用的是真实流量，所以不管从流量的多样性，真实性，还是复杂性上都将能够得以展现，同时预发布服务也将表现出其最真实的处理能力和对异常的处理能力。运用这种模式，一方面，我们将不会再跟以前一样在发布服务前夕内心始终忐忑不安，只能祈祷上线之后不会出现问题。另一方面，当大量的流量流入重构服务之后，开发过程中难以评估的性能问题也将完完整整的暴露出来，此时开发人员将会考虑它服务的性能，测试人员将会更加完善他们的测试样例。通过暴露问题，解决问题，再暴露问题，再解决问题的方式循序渐进地完善预发布服务来增加我们上线的成功率。同时也变相的促进我们开发测试人员技能水平的提高。</p><p>当然，流量镜像的作用不仅仅只是解决上面这样的场景问题，我们可以根据它的特性，解决更多的问题。比如，假如我们在上线后突然发现一个线上问题，而这个问题在测试坏境中始终不能复现。那么这个时候我们就能利用它将异常流量镜像到一个分支服务中去，然后我们可以随意在这个分支服务上进行分析调试，这里所说的分支服务，可以是原服务的只用于问题分析而不处理正式业务的副本服务，也可以是一个只收集镜像流量的组件类服务。又比如突然需要收集某个时间段某些流量的特征数据做分析，像这种临时性的需求，使用流量镜像来处理非常合适，既不影响线上服务的正常运转，也达到了收集分析的目的。</p><h4 id="流量镜像的实现原理"><a href="#流量镜像的实现原理" class="headerlink" title="流量镜像的实现原理"></a>流量镜像的实现原理</h4><p>实际上在 Istio 中，服务间的通讯都是被 Envoy代理拦截并处理的， Istio 流量镜像的设计也是基于 Envoy特性实现的。它的流量转发如下图所示。可以看到，当流量进入到<code>Service A</code>时，因为在<code>Service A</code>的 Envoy代理上配置了流量镜像规则，那么它首先会将原始流量转发到<code>v1</code>版本的 <code>Service B</code>服务子集中去 。同时也会将相同的流量复制一份，异步地发送给<code>v2</code>版本的<code>Service B</code> 服务子集中去，可以明显的看到，<code>Service A</code> 发送完镜像流量之后并不关心它的响应情况。</p><p>在很多情况下，我们需要将真实的流量数据与镜像流量数据进行收集并分析，那么当我们收集完成后应该怎样区分哪些是真实流量，哪些是镜像流量呢？ 实际上，Envoy团队早就考虑到了这样的场景，他们为了区分镜像流量与真实流量，在镜像流量中修改了请求标头中 <code>host</code> 值来标识，它的修改规则是：在原始流量请求标头中的 <code>host</code> 属性值拼接上<code>“-shadow”</code> 字样作为镜像流量的 <code>host</code> 请求标头。</p><p>为了能够更清晰的对比出原始流量与镜像流量的区别，我们使用以下的一个示例来说明：</p><p>如下图所示，我们发起一个<code>http://istio.gateway.xxxx.tech/serviceB/request/info</code>的请求，请求首先进入了<code>istio-ingressgateway</code> ，它是一个 Istio 的 Gateway 资源类型的服务，它本身就是一个 Envoy代理。在这个例子里，就是它对流量进行了镜像处理。可以看到，它将流量转发给<code>v1</code>版本<code>Service B</code>服务子集的同时也复制了一份流量发送到了<code>v2</code>版本的<code>Service B</code>服务子集中去。</p><p><img alt="concepts-traffic-shadow-request" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-request.png"></p><p>在上面的请求链中，请求标头数据有什么变化呢？下图收集了它们请求标头中的所有信息，可以明显的对比出正式流量与镜像流量请求标头中<code>host</code>属性的区别（部分相同的属性值过长，这里只截取了前半段）。从图中我们可以看出，首先就是host属性值的不同，而区别就是多了一个<code>“-shadow”</code>的后缀。再者发现<code>x-forwarded-for</code>属性也不相同，<code>x-forwarded-for</code>协议头的格式是：<code>x-forwarded-for: client1, proxy1, proxy2</code>， 当流量经过 Envoy代理时这个协议头将会把代理服务的 IP 添加进去。实例中<code>10.10.2.151</code>是我们云主机的 IP，而<code>10.10.2.121</code>是<code>isito-ingressgateway</code>所对应<code>Pod</code>的 IP 。从这里也能看到，镜像流量是由<code>istio-ingressgatway</code>发起的。除了这两个请求标头的不同，其他配置项是完全一样的。</p><p><img alt="concepts-traffic-shadow-header" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-header.png"></p><h4 id="流量镜像的配置"><a href="#流量镜像的配置" class="headerlink" title="流量镜像的配置"></a>流量镜像的配置</h4><p>上面我们介绍了流量镜像的原理及使用场景，接下来我们再介绍下流量的镜像如何配置才能生效。在 Istio 架构里，镜像流量是借助于 VirtualService 这个资源中的 <code>HTTPRoute</code> 配置项的<code>mirror</code>与<code>mirrorPercent</code>这两项子配置项来实现的，这两个配置项的定义也是非常的简单。</p><ul><li><strong>mirror</strong>：配置一个 Destination 类型的对象，这里就是我们镜像流量转发的服务地址。具体的 <strong>VirtualService</strong> 配置与<strong>DestinationRule</strong> 对象配置属性请参考相关介绍页。</li><li><strong>mirrorPercent</strong>：配置一个数值，这个配置项用来指定有多少的原始流量将被转发到镜像流量服务中去，它的有效值为<code>0~100</code>，如果配置成<code>0</code>则表示不发送镜像流量。</li></ul><p>下面的例子就是我们在示例中使用到的<code>Service B</code>的镜像流量配置，其中，<code>mirror.host</code>配置项是配置一个域名或者在Istio 注册表中注册过的服务名称，可以看到，该配置指定了镜像流量需要发送的目标服务地址为<code>serviceB</code>。<code>mirror.subset</code>配置项配置一个<code>Service B</code>服务的服务子集名称 ，指定了要将镜像流量镜像到<code>v2</code>版本的<code>Service B</code>服务子集中去。<code>mirror_percent</code>配置将<code>100%</code>的真实流量进行镜像发送。所以下面的配置整体表示当流量到来时，将请求转发到<code>v1</code>版本的<code>service B</code>服务子集中，再以镜像的方式发送到<code>v2</code>版本的<code>service B</code>服务上一份，并将真实流量全部镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio.gateway.xxxx.tech</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingressgateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/serviceB</span></span><br><span class="line">    <span class="attr">rewrite:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">mirror:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">mirror_percent:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p><code>service B</code> 服务对应的 DestinationRule 配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 &lt;a href=&quot;../22cae0b8&quot;&gt;Istio 入门&lt;/a&gt; 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio 入门</title>
    <link href="http://houmin.cc/posts/22cae0b8/"/>
    <id>http://houmin.cc/posts/22cae0b8/</id>
    <published>2020-09-09T02:44:08.000Z</published>
    <updated>2020-09-11T07:17:06.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p><a id="more"></a><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>微服务应用最大的痛点就是处理服务间的通信，而这一问题的核心其实就是流量管理。首先我们来看看传统的微服务应用在没有 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#service-mesh" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh</a> 介入的情况下，是如何完成诸如金丝雀发布这样的路由功能的。我们假设不借助任何现成的第三方框架，一个最简单的实现方法，就是在服务间添加一个负载均衡（比如 Nginx）做代理，通过修改配置的权重来分配流量。这种方式使得对流量的管理和基础设施绑定在了一起，难以维护。</p><p>而使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 就可以轻松的实现各种维度的流量控制。下图是典型的金丝雀发布策略：根据权重把 5% 的流量路由给新版本，如果服务正常，再逐渐转移更多的流量到新版本。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的流量控制功能主要分为三个方面：</p><ul><li>请求路由和流量转移</li><li>弹性功能，包括熔断、超时、重试</li><li>调试能力，包括故障注入和流量镜像</li></ul><p>关于流量控制的更多内容，参考 <a href="../151719f0">Istio流量控制</a></p><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>安全对于微服务这样的分布式系统来说至关重要。与单体应用在进程内进行通信不同，网络成为了服务间通信的纽带，这使得它对安全有了更迫切的需求。比如为了抵御外来攻击，我们需要对流量进行加密；为保证服务间通信的可靠性，需要使用mTLS的方式进行交互；为控制不同身份的访问，需要设置不同粒度的授权策略。作为一个服务网格，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 提供了一整套完整的安全解决方案。它可以以透明的方式，为我们的微服务应用添加安全策略。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的安全架构是由多个组件协同完成的。Citadel 是负责安全的主要组件，用于密钥和证书的管理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 会将安全策略配置分发给 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 代理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 执行安全策略来实现访问控制。下图展示了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的安全架构和运作流程。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-secure-arch.svg"></p><p>关于安全管理的更多内容，参考 <a href="../">Istio安全管理</a></p><h3 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h3><p>面对复杂的应用环境和不断扩展的业务需求，即使再完备的测试也难以覆盖所有场景，无法保证服务不会出现故障。正因为如此，才需要“可观察性”来对服务的运行时状态进行监控、上报、分析，以提高服务可靠性。具有可观察性的系统，可以在服务出现故障时大大降低问题定位的难度，甚至可以在出现问题之前及时发现问题以降低风险。具体来说，可观察性可以：</p><ul><li>及时反馈异常或者风险使得开发人员可以及时关注、修复和解决问题（告警）；</li><li>出现问题时，能够帮助快速定位问题根源并解决问题，以减少服务损失（减损）；</li><li>收集并分析数据，以帮助开发人员不断调整和改善服务（持续优化）。</li></ul><p>而在微服务治理之中，随着服务数量大大增加，服务拓扑不断复杂化，可观察性更是至关重要。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 自然也不可能缺少对可观察性的支持。它会为所有的服务间通信生成详细的遥测数据，使得网格中每个服务请求都可以被观察和跟踪。开发人员可以凭此定位故障，维护和优化相关服务。而且，这一特性的引入无需侵入被观察的服务。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 一共提供了三种不同类型的数据从不同的角度支撑起其可观察性：</p><ul><li>指标（Metrics）</li><li>日志（Access Logs）</li><li>分布式追踪（Distributed Traces）</li></ul><p>关于可观测行的更多内容，参考 <a href="../">Istio可观测性</a></p><h2 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h2><p>Istio的架构由<strong>控制平面</strong>和<strong>数据平面</strong>两个部分组成。</p><ul><li>数据平面：由整个网格内的sidecar代理组成，每个sidecar代理会接管流入和流出服务的流量，并配合控制平面完成流量控制等方面的内容。</li><li>控制平面：负责控制和管理数据平面的sidecar代理，完成配置的分发、服务发现和授权鉴权等功能。</li></ul><p>控制平面是 Istio 在原有服务网格产品上，首次提出的架构，实现了对于数据平面的统一管理。</p><p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><h4 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h4><p><code>Pilot</code> 组件的主要功能是将路由规则等配置信息转换为 sidecar 可以识别的信息，并下发给数据平面。可以把它简单的理解为是一个<strong>配置分发器</strong>（dispatcher），并辅助 sidecar 完成流量控制相关的功能。它管理sidecar代理之间的路由流量规则，并配置故障恢复功能，如超时、重试和熔断。</p><p><img alt="Istio Pilot Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot-arch.svg"></p><p>上图显示了Pilot的基本架构，它主要由以下几个部分组成：</p><h5 id="Abstract-Model"><a href="#Abstract-Model" class="headerlink" title="Abstract Model"></a>Abstract Model</h5><p>为了实现对不同服务注册中心 （Kubernetes、consul） 的支持，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 需要对不同的输入来源的数据有一个统一的存储格式，也就是抽象模型。抽象模型中定义的关键成员包括 HostName（Service名称）、Ports（Service端口）、Address（Service ClusterIP）、Resolution （负载均衡策略） 等。</p><h5 id="Platform-Adapters"><a href="#Platform-Adapters" class="headerlink" title="Platform Adapters"></a>Platform Adapters</h5><p>借助平台适配器 Pilot 可以实现服务注册中心数据到抽象模型之间的数据转换。例如 Pilot 中的 Kubernetes 适配器通过 Kubernetes API 服务器得到 Kubernetes 中 Service 和 Pod 的相关信息，然后翻译为抽象模型提供给 Pilot 使用。通过平台适配器模式，Pilot 还可以从 Consul 等平台中获取服务信息，还可以开发适配器将其他提供服务发现的组件集成到 Pilot 中。</p><h5 id="xDS-API"><a href="#xDS-API" class="headerlink" title="xDS API"></a>xDS API</h5><p>Pilot 使用了一套起源于 Envoy 项目的标准数据面 API 来将服务信息和流量规则下发到数据面的 sidecar 中。这套标准数据面 API，也叫 xDS。Sidecar 通过 xDS API 可以动态获取 Listener （监听器）、Route （路由）、<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#cluster" target="_blank" rel="external nofollow noopener noreferrer">Cluster</a> （集群）及 Endpoint （集群成员）配置：</p><ul><li>LDS，Listener 发现服务：Listener 监听器控制 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 启动端口监听（目前只支持 TCP 协议），并配置 L3/L4 层过滤器，当网络连接达到后，配置好的网络过滤器堆栈开始处理后续事件。</li><li>RDS，Router 发现服务：用于 HTTP 连接管理过滤器动态获取路由配置，路由配置包含 HTTP 头部修改（增加、删除 HTTP 头部键值），virtual hosts （虚拟主机），以及 virtual hosts 定义的各个路由条目。</li><li>CDS，Cluster发现服务：用于动态获取 Cluster 信息。</li><li>EDS，Endpoint 发现服务：用于动态维护端点信息，端点信息中还包括负载均衡权重、金丝雀状态等，基于这些信息，Sidecar 可以做出智能的负载均衡决策。</li></ul><h5 id="User-API"><a href="#User-API" class="headerlink" title="User API"></a>User API</h5><p>Pilot 还定义了一套用户 API， 用户 API 提供了面向业务的高层抽象，可以被运维人员理解和使用。</p><p>运维人员使用该 API 定义流量规则并下发到 Pilot，这些规则被 Pilot 翻译成数据面的配置，再通过标准数据面 API 分发到 sidecar 实例，可以在运行期对微服务的流量进行控制和调整。</p><p>通过运用不同的流量规则，可以对网格中微服务进行精细化的流量控制，如按版本分流、断路器、故障注入、灰度发布等。</p><p>关于 Pilot 的具体实现，可以参考 <a href="../">Istio Pilot 模块分析</a></p><h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><p><code>Citadel</code> 是 Istio 中专门负责安全的组件，内置有身份和证书管理功能，可以实现较为强大的授权和认证等操作，在1.5 版本之后取消了独立进程，作为一个模块被整合在 istiod 中。</p><p>总体来说，Istio 在安全架构方面主要包括以下内容：</p><ul><li>证书签发机构（CA）负责密钥和证书管理</li><li>API 服务器将安全配置分发给数据平面</li><li>客户端、服务端通过代理安全通信</li><li>Envoy 代理管理遥测和审计</li></ul><p>Istio 的身份标识模型使用一级服务标识来确定请求的来源，它可以灵活的标识终端用户、工作负载等。在平台层面，Istio 可以使用类似于服务名称来标识身份，或直接使用平台提供的服务标识。比如 Kubernetes 的 ServiceAccount，AWS IAM 用户、角色账户等。</p><p>在身份和证书管理方面，Istio 使用 X.509 证书，并支持密钥和证书的自动轮换。从 1.1 版本开始，Istio 开始支持安全发现服务器（SDS），随着不断的完善和增强，1.5 版本 SDS 已经成为默认开启的组件。Citadel 以前有两个功能：将证书以 Secret 的方式挂载到命名空间里；通过 SDS gRPC 接口与 nodeagent（已废弃）通信。目前 Citadel 只需要完成与 SDS 相关的工作，其他功能被移动到了 istiod 中。</p><p>关于Citadel的更多内容，参考 <a href="../">Istio安全管理</a></p><h4 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h4><p><code>Galley</code> 是 Istio 1.1 版本中新增加的组件，其目的是将 <code>Pilot</code> 和底层平台（如 Kubernetes）进行解耦。它分担了原本 <code>Pilot</code> 的一部分功能，主要负责配置的验证、提取和处理等功能。</p><h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><p>Istio 数据平面核心是以 sidecar 模式运行的智能代理。Sidecar 模式将数据平面核心组件部署到单独的流程或容器中，以提供隔离和封装。Sidecar 应用与父应用程序共享相同的生命周期，与父应用程序一起创建和退出。Sidecar 应用附加到父应用程序，并为应用程序提供额外的特性支持。</p><p>如下图所示，数据平面的 sidecar 代理可以调节和控制微服务之间所有的网络通信，每个服务 Pod 启动时会伴随启动 <code>istio-init</code> 和 proxy 容器。 </p><ul><li><code>istio-init</code> 容器主要功能是初始化 Pod 网络和对 Pod设置 iptable 规则，设置完成后自动结束。</li><li>Proxy 容器会启动两个服务：<code>istio-agent</code> 以及网络代理组件<ul><li><code>istio-agent</code>  的作用是同步管理数据，启动并管理网络代理服务进程，上报遥测数据</li><li>网络代理组件则根据管理策略完成流量管控、生成遥测数据。</li></ul></li></ul><p>数据平面真正触及到对网络数据包的相关操作，是上层控制平面策略的具体执行者。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-data-plane-arch.png"></p><p>Envoy 是 Istio 中默认的数据平面 Sidecar 代理，关于 Sidecar 是如何实现自动注入和流量劫持，以及Sidecar的流量路由机制如何实现，更多可参考 <a href="../">Envoy系列文章</a> 。</p><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>这里介绍在 Kubernetes 环境下安装 Istio，在开始之前，你需要有一个 Kubernetes 运行环境。</p><p>从 Istio v1.7 版本开始，Istio官方推荐使用 istioctl 安装。下面是安装步骤：</p><ul><li>在 <a href="https://github.com/istio/istio/releases" target="_blank" rel="external nofollow noopener noreferrer">Istio release</a> 页面下载与操作系统匹配的安装包，并将其解压。这里可以直接用Istio提供的脚本：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/istio/istio/release-1.7/release/downloadIstioCandidate.sh | sh -</span><br><span class="line">$  [root@VM-1-28-centos istio]<span class="comment"># ls </span></span><br><span class="line">istio-1.7.0  istio-1.7.0-linux-amd64.tar.gz</span><br><span class="line">$ [root@VM-1-28-centos istio]<span class="built_in">cd</span> istio-1.7.0</span><br><span class="line">$ [root@VM-1-28-centos istio-1.7.0]<span class="comment"># tree -L 2</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── istioctl</span><br><span class="line">├── LICENSE</span><br><span class="line">├── manifests</span><br><span class="line">│   ├── charts</span><br><span class="line">│   ├── deploy</span><br><span class="line">│   ├── examples</span><br><span class="line">│   └── profiles</span><br><span class="line">├── manifest.yaml</span><br><span class="line">├── README.md</span><br><span class="line">├── samples</span><br><span class="line">│   ├── addons</span><br><span class="line">│   ├── bookinfo</span><br><span class="line">│   ├── certs</span><br><span class="line">│   ├── cross-network-gateway</span><br><span class="line">│   ├── custom-bootstrap</span><br><span class="line">│   ├── external</span><br><span class="line">│   ├── fortio</span><br><span class="line">│   ├── health-check</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   ├── httpbin</span><br><span class="line">│   ├── https</span><br><span class="line">│   ├── kubernetes-blog</span><br><span class="line">│   ├── operator</span><br><span class="line">│   ├── rawvm</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── security</span><br><span class="line">│   ├── sleep</span><br><span class="line">│   ├── tcp-echo</span><br><span class="line">│   └── websockets</span><br><span class="line">└── tools</span><br><span class="line">    ├── certs</span><br><span class="line">    ├── convert_RbacConfig_to_ClusterRbacConfig.sh</span><br><span class="line">    ├── dump_kubernetes.sh</span><br><span class="line">    ├── _istioctl</span><br><span class="line">    └── istioctl.bash</span><br><span class="line"></span><br><span class="line">27 directories, 9 files</span><br></pre></td></tr></table></figure><p>安装目录内容： </p><div class="table-container"><table><thead><tr><th>目录</th><th>包含内容</th></tr></thead><tbody><tr><td><code>bin</code></td><td>包含 istioctl 的客户端文件</td></tr><tr><td><code>manifests</code></td><td>包含 各种部署的 manifests</td></tr><tr><td><code>samples</code></td><td>包含示例应用程序</td></tr><tr><td><code>tools</code></td><td>包含用于性能测试和在本地机器上进行测试的脚本</td></tr></tbody></table></div><ul><li>将<code>istioctl</code>客户端路径加入 <code>$PATH</code> 中，从而可以使用 istioctl 命令行工具</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(<span class="built_in">pwd</span>)/bin</span><br></pre></td></tr></table></figure><ul><li>安装 <code>demo</code> 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo</span><br><span class="line">✔ Istio core installed</span><br><span class="line">✔ Istiod installed</span><br><span class="line">✔ Egress gateways installed</span><br><span class="line">✔ Ingress gateways installed</span><br><span class="line">✔ Installation complete</span><br></pre></td></tr></table></figure><ul><li>添加一个Namespace Label，使得之后在部署你的应用的时候，istio会自动注入Envoy sidecar 代理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label namespace default istio-injection=enabled</span><br></pre></td></tr></table></figure><h3 id="部署-Bookinfo"><a href="#部署-Bookinfo" class="headerlink" title="部署 Bookinfo"></a>部署 Bookinfo</h3><p>Bookinfo 是 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 社区官方推荐的示例应用之一。它可以用来演示多种 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的特性，并且它是一个异构的微服务应用。该应用由四个单独的微服务构成。 这个应用模仿了在线书店，可以展示书店中书籍的信息。例如页面上会显示一本书的描述，书籍的细节（ ISBN、页数等），以及关于这本书的一些评论。</p><p>Bookinfo 应用分为四个单独的微服务， 这些服务对 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个不同语言编写的服务构成，并且其中有一个应用会包含多个版本。</p><ul><li><code>productpage</code> 会调用 <code>details</code> 和 <code>reviews</code> 两个微服务，用来生成页面。</li><li><code>details</code> 中包含了书籍的信息。</li><li><code>reviews</code> 中包含了书籍相关的评论。它还会调用 <code>ratings</code> 微服务。</li><li><code>ratings</code> 中包含了由书籍评价组成的评级信息。</li></ul><p><code>reviews</code> 微服务有 3 个版本，可用来展示各服务之间的不同的调用链路：</p><ul><li>v1 版本不会调用 <code>ratings</code> 服务。</li><li>v2 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul><p>下图展示了这个应用的端到端架构：</p><p><img alt="Bookinfo Application without Istio" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo-noistio.svg"></p><ul><li>部署示例应用程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details unchanged</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings unchanged</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews unchanged</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage unchanged</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure><ul><li>之后应用起来，当每个Pod状态变为Ready的时候，sidecar也部署成功。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   172.18.252.45    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">kubernetes    ClusterIP   172.18.252.1     &lt;none&gt;        443/TCP    51d</span><br><span class="line">productpage   ClusterIP   172.18.253.238   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">ratings       ClusterIP   172.18.254.131   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">reviews       ClusterIP   172.18.255.63    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5974b67c8-z67st        2/2     Running   0          2m8s</span><br><span class="line">productpage-v1-797898bc54-frzdz   2/2     Running   0          2m8s</span><br><span class="line">ratings-v1-c6cdf8d98-xmhz8        2/2     Running   0          2m8s</span><br><span class="line">reviews-v1-8bdc65f7b-mjktx        2/2     Running   0          2m8s</span><br><span class="line">reviews-v2-868d77d678-4dzmn       2/2     Running   0          2m8s</span><br><span class="line">reviews-v3-6c9b646cb4-5tp9q       2/2     Running   0          2m8s</span><br></pre></td></tr></table></figure><ul><li>查看应用是否成功运行，通过给productpage发送请求，查看其返回</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> <span class="string">"<span class="variable">$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')</span>"</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">"&lt;title&gt;.*&lt;/title&gt;"</span></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><h3 id="集群外部访问应用"><a href="#集群外部访问应用" class="headerlink" title="集群外部访问应用"></a>集群外部访问应用</h3><p>到现在，Bookinfo 应用已经成功部署，我们在集群内部也已经可以访问，但是在集群外部还不能够访问。为了使得外部能够访问应用程序，我们需要创建一个<a href="https://istio.io/latest/docs/concepts/traffic-management/#gateways" target="_blank" rel="external nofollow noopener noreferrer">Istio Ingress Gateway</a>。</p><ul><li>将应用于istio gateway关联</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure><ul><li>确保配置上没有问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl analyze</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure><ul><li>确定Ingress的IP和Ports</li></ul><p>通过下面的命令来设置 <code>INGRESS_HOST</code> 和 <code>INGRESS_PORT</code>环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   172.18.252.12   49.233.242.233   15021:32663/TCP,80:31968/TCP,443:31588/TCP,31400:32002/TCP,15443:30652/TCP   18m</span><br></pre></td></tr></table></figure><p>这里显示 <code>EXTERNAL_IP</code> 已经变设置，表明当前环境下有一个可以使用的外部负载均衡器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="http2")].port&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="https")].port&#125;'</span>)</span><br></pre></td></tr></table></figure><ul><li>设定GATEWAY_URL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GATEWAY_URL</span></span><br><span class="line">49.233.242.233:80</span><br></pre></td></tr></table></figure><ul><li>确认外部访问是否成功：在浏览器直接访问 <code>http://&lt;GATE_WAYURL&gt;/productpage</code> 来访问Bookinfo应用</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-external-access.png"></p><h3 id="查看Dashboard"><a href="#查看Dashboard" class="headerlink" title="查看Dashboard"></a>查看Dashboard</h3><p>Istio集成了 <a href="https://istio.io/latest/docs/ops/integrations/" target="_blank" rel="external nofollow noopener noreferrer">一些</a> 遥测应用，他们可以帮助你对你的服务网格有直观的认识、展示网格的拓扑、分析网格的健康状态</p><ul><li>安装Kiali </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/addons</span><br><span class="line">$ <span class="keyword">while</span> ! kubectl <span class="built_in">wait</span> --<span class="keyword">for</span>=condition=available --timeout=600s deployment/kiali -n istio-system; <span class="keyword">do</span> sleep 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>访问Kiali</li></ul><p>官方教程指示使用 <code>istioctl dashboard kiali</code> 命令来打开浏览器访问 Kiali服务，但是我的 Kubernetes 集群在服务器上，这样显然不行，不要将 Kiali 服务暴露给外部。因为之前集群已经安装了 Traefik ，所以可以使用 Ingress来暴露。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kiali</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/kiali</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kiali</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">20001</span></span><br></pre></td></tr></table></figure><p>在命令行创建Ingress，打开浏览器访问 <code>http://&lt;NodeIP&gt;:&lt;TraefikWebNodePort&gt;/kiali</code> 即可访问Kiali</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-kiali.png"></p><p>在左侧导航栏点击Graph，选择default的命名空间，可以看到 <code>Bookinfo</code> 应用中各个服务间的关系：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-kiali.png"></p><p>到此为止，你的Istio和相关的服务已经在集群中完好的部署，关于其具体功能演示，参照 <a href="../151719f0">Istio流量控制</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://istio.io/latest/docs/setup/getting-started" target="_blank" rel="external nofollow noopener noreferrer">https://istio.io/latest/docs/setup/getting-started</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】开篇</title>
    <link href="http://houmin.cc/posts/ac3e3d15/"/>
    <id>http://houmin.cc/posts/ac3e3d15/</id>
    <published>2020-09-08T06:24:34.000Z</published>
    <updated>2020-09-14T04:13:40.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>Service Mesh 是一个<strong>基础设施层</strong>，用于处理<strong>服务到服务间</strong>的网络通信。<strong>云原生应用</strong>有着复杂的服务拓扑，Service Mesh负责在这些<strong>网络拓扑中实现请求的可靠传递</strong>。在实践中，Service Mesh通常实现为一组轻量级的<strong>网络代理</strong>，它们与应用程序部署在一起，但是<strong>对应用保持透明</strong>。</p></blockquote><p>本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。</p><a id="more"></a><h2 id="历史演进"><a href="#历史演进" class="headerlink" title="历史演进"></a>历史演进</h2><p>随着行业需求的推动，互联网服务从最早的仅有少数几台的大型服务器演变到成百上千的小型服务，服务架构也从最早期的单体式（Monolithic）到分布式（Distributed），再到微服务（Microservices）、容器化（Containerization）、容器编排（Container Orchestration），最后到服务网格（Service Mesh）、无服务器（Serverless）。</p><p>总结分布式系统的演进过程，我们可以看到一种通用的发展规律：</p><ul><li>首先是对每种情况提出临时解决方案</li><li>然后是更复杂的解决方案，类似于 library 以实现统一复用</li><li>随着对问题有更多的了解，开始将这些解决方案落实到 platform</li></ul><p>接下来我们会回顾从早期TCP/IP协议栈的广泛应用，到微服务时代从容器编排到服务网格的演进过程，并再次体会上述规律。</p><h3 id="计算机网络系统的演进"><a href="#计算机网络系统的演进" class="headerlink" title="计算机网络系统的演进"></a>计算机网络系统的演进</h3><p>从多台计算机开始通信以来，服务间通信是应用最为广泛的模式。以下图为例，ServiceA 和 ServiceB 可以是我们提供应用的服务端与客户端。在开发者开发这些服务的时候，需要借助底层的网络硬件和协议进行通信。这张图只是一个简化的师徒，省略了在代码操作的数据和通过线路发送接收的电信号之间转换的很多层。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc.png"></p><p>更加具体一点，把底层的网络协议栈加入，我们会看到下图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc-stack.png"></p><p>从上世纪50年代起，上述的模型就一直在使用。最开始，由于计算机系统规模相对较小，每个节点之间的链路协议都是经过专门设计和维护的。随着计算机规模的迅速扩大，很多个小的网络系统开始连接起来。在这个过程中，不同主机间如何找到彼此，跨网络间如何路由转发，如何实现流量控制等问题，成了摆在网络系统设计人员面前亟需解决的难题。</p><p>为了实现各个网络节点的路由转发，屏蔽链路层协议，人们发明了IP网络协议。然而，IP网络协议还不能够解决流量控制的问题。这里的流量控制，值得是防止一台服务器发送过多的数据包，超出下游服务器的处理能力。在最开始，编写网络服务和应用程序的开发者来负责处理上述流量控制的问题。这就意味着在编写应用程序过程中，网络处理的逻辑和应用自身的业务逻辑被耦合在一起，如下图所示。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-flow-control.png"></p><p>然而，这种每个开发人员都要去考虑流量处理等传输层的问题太过复杂，程序开发的成本太高。随着技术的快速发展，流量处理和其他网络问题相关的解决方案被整合到网络协议栈，TCP/IP席卷了世界，成为互联网事实上的协议标准。流量控制等网络问题的代码仍在，但是你不再需要自己去开发与维护这段代码，而是直接调用系统提供的网络协议栈。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-tcp.png"></p><h3 id="微服务架构的演进"><a href="#微服务架构的演进" class="headerlink" title="微服务架构的演进"></a>微服务架构的演进</h3><p>确定于上世界80年代的TCP/IP网络协议栈和通用的网络模型对于互联网的发展发挥了巨大的作用，极大了促进了互联网应用的繁荣。网络应用的功能逐渐复杂起来，人们把所有的组件都集中在一个应用当中，这即是<code>单体应用 Monolithic</code>。单体应用基于相同技术栈开发、访问共享的数据库、共同部署运维和扩容。同时，组件之间的通信也趋于频繁和耦合，所有的交互都是以函数调用的形式来实现。</p><p>然而，随着互联网的迅猛发展，网络应用中需要添加越来越多的功能，应用的复杂度不断提升，参与软件开发的协作人数也越来越多，单体应用开始爆发出其固有局限性。在这种背景下，微服务的思潮降临，让软件开发重新变得小而美：</p><ul><li>单⼀职责：拆分后的单个微服务，通常只负责单个高内聚自闭环功能，因此很易于开发、理解和维护。</li><li>架构灵活：不同微服务应用之间在技术选型层面几乎是独立的，可以⾃由选择最适合的技术栈。</li><li>部署隔离：相比巨无霸单体应用，单个微服务应用的代码和产物体积大大减少，更容易持续集成和快速部署；同时，通过进程级别的隔离，也不再像单体应用一样只能同生共死，故障隔离效果显著提升。</li><li>独⽴扩展：单体应用时代，某个模块如果存在资源瓶颈（e.g. CPU/内存），只能跟随整个应用一起扩容，白白浪费很多资源。微服务化后，扩展的粒度细化到了微服务级别，可以更精确地按需独立扩展。</li></ul><p>然而，微服务也不是银弹，在微服务落地的过程中，也产生了很多的问题，其中主要的问题就是服务间通信：</p><ul><li><p><strong>如何找到服务的提供⽅？</strong></p><p>微服务通讯必须走远程过程调用（HTTP/REST本质上也属于RPC），当其中一个应用需要消费另一个应用的服务时，无法再像单体应用一样通过简单的进程内机制（e.g. Spring的依赖注入）就能获取到服务实例；你甚至都不知道有没有这个服务方。</p></li><li><p><strong>如何保证远程调⽤的可靠性?</strong></p><p>既然是RPC，那必然要走IP网络，而我们都知道网络（相比计算和存储）是软件世界里最不可靠的东西。虽然有TCP这种可靠传输协议，但频繁丢包、交换机故障甚至电缆被挖断也常有发生；即使网络是好的，如果对方机器宕机了，或者进程负载过高不响应呢？</p></li><li><p><strong>如何降低服务调⽤的延迟？</strong></p><p>网络不只是不可靠，还有延迟的问题。虽然相同系统内的微服务应用通常都部署在一起，同机房内调用延迟很小；但对于较复杂的业务链路，很可能一次业务访问就会包括数十次RPC调用，累积起来的延迟就很可观了。</p></li><li><p><strong>如何保证服务调⽤的安全性？</strong></p><p>网络不只是不可靠和有延迟，还是不安全的。互联网时代，你永远不知道屏幕对面坐的是人还是狗；同样，微服务间通讯时，如果直接走裸的通讯协议，你也永远不知道对端是否真的就是自己人，或者传输的机密信息是否有被中间人偷听。</p></li></ul><h4 id="服务通信：耦合业务逻辑"><a href="#服务通信：耦合业务逻辑" class="headerlink" title="服务通信：耦合业务逻辑"></a>服务通信：耦合业务逻辑</h4><p>就像历史总是会重演，为了解决上述微服务引入的问题，最早需要工程师独立去完成对应的服务，在业务逻辑中实现下列逻辑：</p><ul><li>服务发现（Service Discovery）：解决“我想调用你，如何找到你”的问题。</li><li>服务熔断（Circuit Breaker）：缓解服务之间依赖的不可靠问题。</li><li>负载均衡（Load Balancing）：通过均匀分配流量，让请求处理更加及时。</li><li>安全通讯：包括协议加密（TLS）、身份认证（证书/签名）、访问鉴权（RBAC）等</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service.png"></p><p>然而，随着分布式程度的增加，这些服务的复杂度也越来越高，一些问题不得不考虑：</p><ul><li>重复造轮子：需要编写和维护⼤量非功能性代码，如何集中精力专注业务创新?</li><li>与业务耦合：服务通讯逻辑与业务代码逻辑混在一起，动不动还会遇到点匪夷所思的分布式bug。</li></ul><h4 id="服务通信：独立Library"><a href="#服务通信：独立Library" class="headerlink" title="服务通信：独立Library"></a>服务通信：独立Library</h4><p>为了解决重复造轮子的问题，集成了服务通信中各种问题的Library开始变得十分流行，包括 Apache Dubbo（手动置顶）、Spring Cloud、Netflix OSS、gRPC 等等。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service-lib.png"></p><p>这些可复用的类库和框架，确确实实带来了质量和效率上的大幅提升，但是也存在着下列问题：</p><ul><li>并非完全透明：程序员们仍然需要正确理解和使⽤这些库，上手成本和出错概率依然很高。</li><li>限制技术选择：使用这些技术后，应用很容易就会被对应的语⾔和框架强绑定（vendor-lock）。</li><li>维护成本高：库版本升级，需要牵连应⽤一起重新构建和部署；麻烦不说，还要祈祷别出故障。</li></ul><h4 id="服务通信：Sidecar"><a href="#服务通信：Sidecar" class="headerlink" title="服务通信：Sidecar"></a>服务通信：Sidecar</h4><p>像网络协议栈发展的过程一样，将大规模分布式服务所需要的功能剥离出来集成到底层平台是一个众望所归的选择。人们通过应用层的协议(例如HTTP)写出了很多复杂的应用程序和服务，甚至不用考虑TCP是如何控制数据包在网络上传输的。这就是我们微服务所需要的，从事服务开发的工程师们可以专注于业务逻辑的开发，避免浪费时间去编写服务基础设施代码或者管理这些库和框架。</p><p>在这个想法下，我们可以得到类似于如下的图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-protocol.png"></p><p>不幸的是，更改协议栈来增加微服务的功能不是一个可行的方案，许多开发者是通过一组代理来实现此功能。这里的设计思想是<strong>服务不需要和下游服务直连，所有的流量都通过该代理透明的来实现对应的功能</strong>。这里的透明代理，通过一种叫做 <code>Sidecar</code> 的模式来运行，Sidecar将上述类库和框架要干的事情从应用中彻底剥离了出来，并统一下沉到了基础设施层，这其中的典型代表就是 Linkerd 和 Envoy。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-sidecar.png"></p><h4 id="服务通信：Service-Mesh"><a href="#服务通信：Service-Mesh" class="headerlink" title="服务通信：Service Mesh"></a>服务通信：Service Mesh</h4><p>在这种模型中，每个服务都会有一个配套的代理SideCar。考虑到服务之间的通信仅仅通过SideCar代理，我们最终得到如下的部署图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data.png"></p><p>Buoyant的CEO William Morgan ，发现了各个SideCar代理之间互联组成了一个网状网络，<strong>2017初，William为这个网状的平台起了一个<a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/" target="_blank" rel="external nofollow noopener noreferrer">“Service Mesh”的定义</a></strong>。</p><blockquote><p>Service Mesh是一个用于服务和服务之间通信的专用基础设施层。它负责服务请求能够在复杂的服务拓扑(组成了云原生应用)中可靠的进行投递。在实践中，Serivce Mesh的典型实现是作为轻量级网络代理阵列，部署在应用程序旁边，不需要业务进程感知到。</p></blockquote><p>William关于Service Mesh的定义中，最有说服力的一点是，他不再将SideCar代理视为一个独立组件，而是承认了<strong>它们组成的网络像它们自身一样是有价值的</strong></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data2.png"></p><p>随着很多公司将它们的微服务部署到更复杂的系统运行环境中，例如Kubernetes和Mesos，人们开始使用这些平台提供的工具来实现合适的Serivce Mesh的想法。它们将独立的SideCar代理从独立的工作环境中转移到一个适当的，有集中的控制面。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control.png"></p><p>看下我们的鸟瞰图，服务之间的流量仍然是通过SideCar代理来进行转发，但是控制平面知道每个SideCar实例。控制平面能够让代理实现例如访问控制，指标收集等需要协作完成的事情。Istio是这个模型的典型实现。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control2.png"> </p><h2 id="主流实现"><a href="#主流实现" class="headerlink" title="主流实现"></a>主流实现</h2><p>Service Mesh 的主流实现包括：</p><ul><li>Linkerd：背后公司是Buoyant，开发语⾔使用Scala，2016年1⽉15日初次发布，2017年1⽉23日加入CNCF。</li><li>Envoy：背后公司是Lyft，开发语言使用C++ 11，2016年9月13日初次发布，2017年9⽉14日加⼊CNCF。</li><li>Istio：背后公司是Google和IBM，开发语言使用Go，2017年5⽉月10日初次发布。</li><li>Conduit：背后公司也是Buoyant，开发语言使用Rust和Go，2017年12月5日初次发布，现在已经加入了 <code>Linkerd</code> 项目。</li></ul><h3 id="Linkerd"><a href="#Linkerd" class="headerlink" title="Linkerd"></a>Linkerd</h3><p>现在（2020.09.08） <code>Linkerd</code> 已经发展到 2.8 版本，由控制面和数据面组成，详情可以参考 <a href="https://linkerd.io/2/reference/architecture/" target="_blank" rel="external nofollow noopener noreferrer">这里</a></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_linkerd-control-plane.png"></p><h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p>Envoy是一个高性能的Service Mesh软件，现在主要被用于数据面作为 Sidecar 代理，详情可以参考 <a href="../7beb34d2/">这里</a></p><p><img alt data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Istio是第二代 Service Mesh，第一次提出控制面的概念，详情可以参考 <a href="../22cae0b8/">这里</a></p><p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h3 id="NginMesh"><a href="#NginMesh" class="headerlink" title="NginMesh"></a>NginMesh</h3><p>Service Mesh 最基础的功能毕竟是 sidecar proxy. 提到 proxy 怎么能够少了 nginx? 我想nginx自己也是这么想的吧 毫不意外，nginx也推出了其 service mesh 的开源实现：nginMesh.</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_nginx-sidecar.png"></p><p>不过，与 William Morgan 的死磕策略不同，nginMesh 从一开始就没有想过要做一套完整的第二代Service Mesh 开源方案，而是直接宣布兼容Istio, 作为Istio的 sidecar proxy. 由于 nginx 在反向代理方面广泛的使用，以及运维技术的相对成熟，nginMesh在sidecar proxy领域应该会有一席之地。</p><h2 id="对比Kubernetes原生架构"><a href="#对比Kubernetes原生架构" class="headerlink" title="对比Kubernetes原生架构"></a>对比Kubernetes原生架构</h2><h3 id="Kube-proxy-vs-Sidecar"><a href="#Kube-proxy-vs-Sidecar" class="headerlink" title="Kube-proxy vs Sidecar"></a>Kube-proxy vs Sidecar</h3><p>下图展示的是 Kubernetes 与 Service Mesh 中的的服务访问关系：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_k8s-vs-service-mesh.png"></p><ul><li>Kubernetes 集群的每个节点都部署了一个 <code>kube-proxy</code> 组件，该组件会与 Kubernetes API Server 通信，获取集群中的 <code>Service</code> 信息，然后设置 iptables 规则，直接将对某个 <code>Service</code> 的请求发送到对应的 Endpoint（属于同一组 <code>Service</code> 的 <code>Pod</code>）上。</li><li>Kube-proxy 实现了流量在 Kubernetes <code>Service</code> 多个 <code>Pod</code> 实例间的负载均衡，但是如何对这些 <code>Service</code> 间的流量做细粒度的控制，比如按照百分比划分流量到不同的应用版本（这些应用都属于同一个 <code>Service</code>，但位于不同的 deployment 上），做金丝雀发布（灰度发布）和蓝绿发布？Kubernetes 社区给出了 <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="external nofollow noopener noreferrer">使用 Deployment 做金丝雀发布的方法</a>，该方法本质上就是通过修改 <code>Pod</code> 的 label 来将不同的 <code>Pod</code> 划归到 Deployment 的 <code>Service</code> 上。</li></ul><p><code>kube-proxy</code> 的设置都是全局生效的，无法对每个服务做细粒度的控制，而 <code>Service Mesh</code> 通过 <code>Sidecar</code> proxy 的方式将 Kubernetes 中对流量的控制从 <code>Service</code> 一层抽离出来，可以做更多的扩展。</p><h3 id="Ingress-vs-Gateway"><a href="#Ingress-vs-Gateway" class="headerlink" title="Ingress vs Gateway"></a>Ingress vs Gateway</h3><p> <code>kube-proxy</code> 只能路由 Kubernetes 集群内部的流量，而我们知道 Kubernetes 集群的 <code>Pod</code> 位于 CNI 创建的外网络中，集群外部是无法直接与其通信的，因此 Kubernetes 中创建了 Ingress 这个资源对象，它由位于 Kubernetes 边缘节点（这样的节点可以是很多个也可以是一组）的 Ingress controller 驱动，负责管理 <strong>南北向流量</strong>，Ingress 必须对接各种 Ingress Controller 才能使用，比如 <a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>、<a href="https://traefik.io/" target="_blank" rel="external nofollow noopener noreferrer">traefik</a>。</p><ul><li>Ingress 只适用于 HTTP 流量，使用方式也很简单，只能对 <code>Service</code>、port、HTTP 路径等有限字段匹配来路由流量，这导致它无法路由如 MySQL、Redis 和各种私有 RPC 等 TCP 流量。</li><li>要想直接路由南北向的流量，只能使用 <code>Service</code> 的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要进行额外的端口管理。</li><li>有些 Ingress controller 支持暴露 TCP 和 UDP 服务，但是只能使用 <code>Service</code> 来暴露，Ingress 本身是不支持的，例如 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>，服务暴露的端口是通过创建 ConfigMap 的方式来配置的。</li></ul><p><code>Istio</code> Gateway 的功能与 Kubernetes Ingress 类似，都是负责集群的南北向流量。<code>Istio</code> <code>Gateway</code> 描述的负载均衡器用于承载进出网格边缘的连接。该规范中描述了一系列开放端口和这些端口所使用的协议、负载均衡的 SNI 配置等内容。Gateway 是一种 CRD 扩展，它同时复用了 <code>Sidecar</code> proxy 的能力，详细配置请参考 <a href="https://istio.io/docs/reference/config/networking/gateway/" target="_blank" rel="external nofollow noopener noreferrer">Istio 官网</a>。</p><h2 id="落地问题"><a href="#落地问题" class="headerlink" title="落地问题"></a>落地问题</h2><p>服务网格的出现带来的变革：</p><p>第一，<strong>微服务治理与业务逻辑的解耦</strong>。服务网格把 SDK 中的<strong>大部分</strong>能力从应用中剥离出来，拆解为独立进程，以 Sidecar 的模式进行部署。服务网格通过将服务通信及相关管控功能从业务程序中分离并下沉到基础设施层，使其和业务系统完全解耦，使开发人员更加专注于业务本身。</p><blockquote><p>注意，这里提到了一个词“大部分”，SDK 中往往还需要保留<strong>协议编解码</strong>的逻辑，甚至在某些场景下还需要一个轻量级的 SDK 来实现细粒度的治理与监控策略。例如，要想实现方法级别的调用链追踪，服务网格则需要业务应用实现 trace ID 的传递，而这部分实现逻辑也可以通过轻量级的 SDK 实现。因此，从代码层面来讲，服务网格并非是零侵入的。</p></blockquote><p>第二，<strong>异构系统的统一治理</strong>。随着新技术的发展和人员更替，在同一家公司中往往会出现不同语言、不同框架的应用和服务，为了能够统一管控这些服务，以往的做法是为每种语言、每种框架都开发一套完整的 SDK，维护成本非常之高，而且给公司的中间件团队带来了很大的挑战。有了服务网格之后，通过将主体的服务治理能力下沉到基础设施，多语言的支持就轻松很多了。只需要提供一个非常轻量级的 SDK，甚至很多情况下都不需要一个单独的 SDK，就可以方便地实现多语言、多协议的统一流量管控、监控等需求。</p><p>此外，服务网格相对于传统微服务框架，还拥有三大技术优势：</p><ul><li>可观察性。因为服务网格是一个专用的基础设施层，所有的服务间通信都要通过它，所以它在技术堆栈中处于独特的位置，以便在服务调用级别上提供统一的遥测指标。这意味着，所有服务都被监控为“黑盒”。服务网格捕获诸如来源、目的地、协议、URL、状态码、延迟、持续时间等线路数据。这本质上等同于 web 服务器日志可以提供的数据，但是服务网格可以为所有服务捕获这些数据，而不仅仅是单个服务的 web 层。需要指出的是，收集数据仅仅是解决微服务应用程序中可观察性问题的一部分。存储与分析这些数据则需要额外能力的机制的补充，然后作用于警报或实例自动伸缩等。</li><li>流量控制。通过 <code>Service Mesh</code>，可以为服务提供智能路由（蓝绿部署、金丝雀发布、A/B test）、超时重试、熔断、故障注入、流量镜像等各种控制能力。而以上这些往往是传统微服务框架不具备，但是对系统来说至关重要的功能。例如，服务网格承载了微服务之间的通信流量，因此可以在网格中通过规则进行故障注入，模拟部分微服务出现故障的情况，对整个应用的健壮性进行测试。由于服务网格的设计目的是有效地将来源请求调用连接到其最优目标服务实例，所以这些流量控制特性是“面向目的地的”。这正是服务网格流量控制能力的一大特点。</li><li>安全。在某种程度上，单体架构应用受其单地址空间的保护。然而，一旦单体架构应用被分解为多个微服务，网络就会成为一个重要的攻击面。更多的服务意味着更多的网络流量，这对黑客来说意味着更多的机会来攻击信息流。而服务网格恰恰提供了保护网络调用的能力和基础设施。服务网格的安全相关的好处主要体现在以下三个核心领域：服务的认证、服务间通讯的加密、安全相关策略的强制执行。</li></ul><p>服务网格带来了巨大变革并且拥有其强大的技术优势，被称为第二代“微服务架构”。然而就像之前说的软件开发没有银弹，传统微服务架构有许多痛点，而服务网格也不例外，也有它的局限性。</p><ul><li>增加了复杂度。服务网格将 <code>Sidecar</code> 代理和其它组件引入到已经很复杂的分布式环境中，会极大地增加整体链路和操作运维的复杂性。</li><li>运维人员需要更专业。在容器编排器（如 Kubernetes）上添加 <code>Istio</code> 之类的服务网格，通常需要运维人员成为这两种技术的专家，以便充分使用二者的功能以及定位环境中遇到的问题。</li><li>延迟。从链路层面来讲，服务网格是一种侵入性的、复杂的技术，可以为系统调用增加显著的延迟。这个延迟是毫秒级别的，但是在特殊业务场景下，这个延迟可能也是难以容忍的。</li><li>平台的适配。服务网格的侵入性迫使开发人员和运维人员适应高度自治的平台并遵守平台的规则。</li></ul><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>展望未来，Kubernetes 正在爆炸式发展，它已经成为企业绿地应用的容器编排的首选。如果说 Kubernetes 已经彻底赢得了市场，并且基于 Kubernetes 的应用程序的规模和复杂性持续增加，那么就会有一个临界点，而服务网格则将是有效管理这些应用程序所必需的。随着服务网格技术的持续发展，其实现产品（如 <code>Istio</code>）的架构与功能的不断优化，服务网格将完全取代传统微服务架构，成为大小企业微服务化和上云改造的首选架构。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="external nofollow noopener noreferrer">https://philcalcado.com/2017/08/03/pattern_service_mesh.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Service Mesh 是一个&lt;strong&gt;基础设施层&lt;/strong&gt;，用于处理&lt;strong&gt;服务到服务间&lt;/strong&gt;的网络通信。&lt;strong&gt;云原生应用&lt;/strong&gt;有着复杂的服务拓扑，Service Mesh负责在这些&lt;strong&gt;网络拓扑中实现请求的可靠传递&lt;/strong&gt;。在实践中，Service Mesh通常实现为一组轻量级的&lt;strong&gt;网络代理&lt;/strong&gt;，它们与应用程序部署在一起，但是&lt;strong&gt;对应用保持透明&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="sidecar" scheme="http://houmin.cc/tags/sidecar/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes解读】Ingress</title>
    <link href="http://houmin.cc/posts/8dfd4de5/"/>
    <id>http://houmin.cc/posts/8dfd4de5/</id>
    <published>2020-08-19T12:52:45.000Z</published>
    <updated>2020-09-10T05:23:07.241Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Ingress 是 Kubernetes 的一种 API 对象，将集群内部的 Service 通过 HTTP/HTTPS 方式暴露到集群外部，并通过规则定义 HTTP/HTTPS 的路由。Ingress 具备如下特性：集群外部可访问的 URL、负载均衡、SSL Termination、按域名路由。</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Kubernetes 暴露服务的有三种方式：分别为 LoadBlancer Service、NodePort Service、Ingress。</p><p>LoadBlancer Service 是 Kubernetes 结合云平台的组件，如国外 GCE、AWS、国内阿里云等等，使用它向使用的底层云平台申请创建负载均衡器来实现，有局限性，对于使用云平台的集群比较方便，但是和云平台强绑定。</p><p>NodePort Service 是通过在节点上暴露端口，然后通过将端口映射到具体某个服务上来实现服务暴露，比较直观方便，但是对于集群来说，随着 Service 的不断增加，需要的端口越来越多，很容易出现端口冲突，而且不容易管理。此外，打开节点的端口，也会面临安全上的风险，生产环境并不推荐使用。</p><p>Ingress 作为 Kubernetes 基本API对象，是外部请求访问集群的入口，负责为进入集群的请求提供路由规则集合和转发，将外部的请求转发到集群内部Service上。相对于上述两种暴露方式，有以下特点：</p><ul><li>动态配置服务：增加新的服务时，不再需要在流量入口新增反向代理指向新的服务，只需配置好Ingress即可</li><li>减少不必要端口暴露：只需要将Ingress服务映射出去，即可代理所有后端服务，更加安全，便于管理端口</li></ul><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><h3 id="组成模块"><a href="#组成模块" class="headerlink" title="组成模块"></a>组成模块</h3><p>Ingress 通过反向代理负载均衡服务器实现对外暴露服务目的，一般有三个组件组成：</p><ul><li>反向代理负载均衡服务器<strong>：拦截外部请求，通常以 <code>Deployment</code> 或者 <code>DaemonSet</code> 的方式部署到集群中，常见的有 <code>Nginx</code>、<code>Apache</code>、<code>Traefik</code>等。</strong></li><li><strong>Ingress</strong>：定义路由规则，将路由配置抽象成一个 Ingress 对象。</li><li><strong>Ingress Controller</strong>：实时监控集群，获取 <code>Service</code> 、<code>Pod</code>和 <code>Ingress</code>等的变化，将 Ingress 的规则动态更新到反向代理负载均衡服务器上，刷新其路由配置信息，实现 <strong>服务发现</strong>。</li></ul><p><img alt="Kubernetes Ingress" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-31_k8s-ingress.png"></p><h3 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h3><p>下面是一个Ingress资源示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/testpath</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"foo.bar.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/bar"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"*.foo.com"</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/foo"</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>与所有其他 Kubernetes 资源一样，Ingress 需要使用 <code>apiVersion</code>、<code>kind</code> 和 <code>metadata</code> 字段。 Ingress 对象的命名必须是合法的 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names" target="_blank" rel="external nofollow noopener noreferrer">DNS 子域名名称</a>。  Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器， 不同的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="external nofollow noopener noreferrer">Ingress 控制器</a> 支持不同的注解。</p><p>Ingress <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" target="_blank" rel="external nofollow noopener noreferrer">规约</a> 提供了配置负载均衡器或者代理服务器所需的所有信息。 最重要的是，其中包含与所有传入请求匹配的规则列表。 <strong>Ingress 资源仅支持用于转发 HTTP 流量的规则。</strong></p><h4 id="Ingress-Rules"><a href="#Ingress-Rules" class="headerlink" title="Ingress Rules"></a>Ingress Rules</h4><p>每个 HTTP 规则都包含以下信息：</p><ul><li>可选主机。在此示例第一个规则中，未指定主机，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了主机（例如 foo.bar.com），则规则适用于该主机。</li><li>路径列表（例如，<code>/testpath</code>）,每个路径都有一个由 <code>serviceName</code> 和 <code>servicePort</code> 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。</li><li>后端是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">Service 文档</a>中所述的服务和端口名称的组合。 与规则的主机和路径匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到列出的后端。</li></ul><p>通常在 Ingress 控制器中会配置默认后端，以服务任何不符合规范中路径的请求。</p><h4 id="DefaultBackend"><a href="#DefaultBackend" class="headerlink" title="DefaultBackend"></a>DefaultBackend</h4><p>没有规则的 Ingress 将所有流量发送到同一个默认后端。 默认后端通常是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="external nofollow noopener noreferrer">Ingress 控制器</a> 的配置选项，并且未在 Ingress 资源中指定。</p><p>如果主机或路径都没有与 Ingress 对象中的 HTTP 请求匹配，则流量将路由到默认后端。</p><h3 id="Path-Types"><a href="#Path-Types" class="headerlink" title="Path Types"></a>Path Types</h3><p>Ingress 中的每个路径都有对应的路径类型。当前支持的路径类型有三种：</p><ul><li><em><code>ImplementationSpecific</code></em> （默认）：对于这种类型，匹配取决于 IngressClass。 具体实现可以将其作为单独的 <code>pathType</code> 处理或者与 <code>Prefix</code> 或 <code>Exact</code> 类型作相同处理。</li><li><em><code>Exact</code></em>：精确匹配 URL 路径，且对大小写敏感。</li><li><em><code>Prefix</code></em>：基于以 <code>/</code> 分隔的 URL 路径前缀匹配。匹配对大小写敏感，并且对路径中的元素逐个完成。 路径元素指的是由 <code>/</code> 分隔符分隔的路径中的标签列表。 如果每个 <em>p</em> 都是请求路径 <em>p</em> 的元素前缀，则请求与路径 <em>p</em> 匹配。</li></ul><h2 id="Traefik实战"><a href="#Traefik实战" class="headerlink" title="Traefik实战"></a>Traefik实战</h2><p><code>Traefik</code>是一个用Go语言开发的轻量级的Http反向代理和<a href="https://cloud.tencent.com/product/clb?from=10680" target="_blank" rel="external nofollow noopener noreferrer">负载均衡</a>器，能够监听后端的变化并自动更新服务配置。它的特点如下：</p><ul><li>天然拥抱<code>kubernetes</code>，直接与集群k8s的<code>Api Server</code>通信，反应非常迅速，实时感知集群中<code>Ingress</code>定义的路由规则集合和后端<code>Service</code>、<code>Pod</code>的变化，自动<strong>热更新</strong><code>Traefik</code>后端配置，根本不用创建<code>Ingress controller</code>对象</li><li>提供了友好的控制面板和监控界面，不仅可以方便地查看<code>Traefik</code>根据<code>Ingress</code>生成的路由配置信息，还可以查看统计的一些性能指标数据</li><li>支持丰富的<code>annotations</code>配置，可配置众多出色的特性，例如：<strong>自动熔断</strong>、<strong>负载均衡策略</strong>、<strong>黑名单</strong>、<strong>白名单</strong></li><li>支持许多后端存储，如：zookeeper、eureka、consul、rancher、docker等，它会自动感知这些统一配置中心的变化，热更新自己的路由配置</li></ul><p><a href="https://www.infoq.cn/article/2glSpfgdiwG0UYz3V4tM" target="_blank" rel="external nofollow noopener noreferrer">如何在 K8S 集群中部署 Traefik Ingress Controller</a> 详细介绍了如何在 k8s 集群部署 Traefik Ingress Controller 的详细过程，本文在此复现其操作。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>在本文的后半部分，我将演示如何在一个 Kubernetes 集群部署 Traefik 作为 Ingress Controller，同时使用 Ingress 实现按域名路由和流量分配。在此之前，你需要一个已经部署成功的 Kubernetes 集群和一个能够与集群通信的kubectl 工具。</p><blockquote><p>软文时间：你可以在MiniKube创建运行 Kubernetes 集群，也欢迎使用腾讯云的TKE容器服务，快速实现1分钟内自动创建好 Kubernetes 集群。</p></blockquote><h3 id="启用RBAC"><a href="#启用RBAC" class="headerlink" title="启用RBAC"></a>启用RBAC</h3><p>为了能够使 Traefik 能够访问集群中运行的 Pod、Endpoint、Ingress和 Service等资源，需要向 Traefik 授予一些权限。这里我们创建了一个具有一组权限的ClusterRole，授予其管理和监视集群中所有命名空间的资源。同时，我们创建一个新的ServiceAccount，为Traefik 提供集群中的身份。最后，通过 ClusterRoleBinding 将二者绑定在一起。</p><figure class="highlight yaml"><figcaption><span>rbac.yam</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">extensions</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f rbac.yaml</span></span><br><span class="line">serviceaccount/traefik-ingress created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/traefik-ingress created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/traefik-ingress created</span><br></pre></td></tr></table></figure><h3 id="部署Traefik"><a href="#部署Traefik" class="headerlink" title="部署Traefik"></a>部署Traefik</h3><p>官方 Traefik 文档支持三种类型的部署：使用 Deployment 对象、使用 DaemonSet 对象或使用 Helm Chart。这里我们使用 Deployment manifest。</p><figure class="highlight yaml"><figcaption><span>deployment.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">traefik-ingress</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">traefik:v1.7.16</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--api</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubernetes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--logLevel=INFO</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f deployment.yaml</span></span><br><span class="line">deployment.extensions/traefik-ingress created</span><br><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl get pods -n kube-system</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">traefik-ingress-56f459f5cb-psrhr    1/1     Running   0          16s</span><br></pre></td></tr></table></figure><h3 id="为外部访问创建NodePorts"><a href="#为外部访问创建NodePorts" class="headerlink" title="为外部访问创建NodePorts"></a>为外部访问创建NodePorts</h3><p>接下来创建一个服务来从集群外部访问 Traefik，这里我们只暴露Traefik给外部，其他的内部服务都可以通过定义Ingress规则来通过 Traefik 暴露出来，极大避免了 NodePort的冲突。在实际生产环境中，这里的 NodePort 可以替换成云服务商提供的LB。</p><figure class="highlight yaml"><figcaption><span>service.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">traefik-ingress-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>在命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl create -f service.yaml</span></span><br><span class="line">service/traefik-ingress-service created</span><br><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl get svc -n kube-system</span></span><br><span class="line">NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                       AGE</span><br><span class="line">hpa-metrics-service       ClusterIP   172.18.254.168   &lt;none&gt;        443/TCP                       51d</span><br><span class="line">kube-dns                  ClusterIP   172.18.253.26    &lt;none&gt;        53/TCP,53/UDP                 51d</span><br><span class="line">traefik-ingress-service   NodePort    172.18.253.6     &lt;none&gt;        80:30993/TCP,8080:31846/TCP   2s</span><br></pre></td></tr></table></figure><p>这个时候，已经可以在浏览器访问 Traefik 服务了，在浏览器输入 <code>http://&lt;NodeIP&gt;:&lt;AdminNodePort&gt;</code> 就可以看到 Traefik 的 WebUI了。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-access.png"></p><p>这个时候WebUI还没有管理任何Ingress，接下来我们创建Ingress。</p><h3 id="实现按域名的路由"><a href="#实现按域名的路由" class="headerlink" title="实现按域名的路由"></a>实现按域名的路由</h3><figure class="highlight yaml"><figcaption><span>animals-ingress.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">animals</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">hare.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">hare</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bear.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">bear</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">moose.houmin</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">moose</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure><p>在命令行执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl create -f animals-ingress.yaml</span></span><br><span class="line">ingress.extensions/animals created</span><br></pre></td></tr></table></figure><p>这个时候只创建了 Ingress，还没有创建 Frontend 的 Service 和后端服务的 EndPoint，查看Traefik看到</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-ingress.png"></p><p>创建对应的 Service：</p><figure class="highlight yaml"><figcaption><span>animals-service.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">traefik.backend.circuitbreaker:</span> <span class="string">"NetworkErrorRatio() &gt; 0.5"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">task:</span> <span class="string">hare</span></span><br></pre></td></tr></table></figure><p>在命令行执行命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@VM-1-28-centos</span> <span class="string">traefik]#</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">animals-service.yaml</span></span><br><span class="line"><span class="string">service/bear</span> <span class="string">created</span></span><br><span class="line"><span class="string">service/moose</span> <span class="string">created</span></span><br><span class="line"><span class="string">service/hare</span> <span class="string">created</span></span><br></pre></td></tr></table></figure><p>这个时候 Ingress 中 Frontend 对应的 Service已经正常工作，但是 Backend 的EndPoint还没有就绪：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-service.png"></p><p>修改本机Host，添加记录如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">NodeIP</span>&gt; <span class="selector-tag">hare</span><span class="selector-class">.houmin</span> <span class="selector-tag">moose</span><span class="selector-class">.houmin</span> <span class="selector-tag">bear</span><span class="selector-class">.houmin</span></span><br></pre></td></tr></table></figure><p>这个时候在浏览器访问 <code>http://hare.houmin:&lt;WebNodePort&gt;</code>，在这里 <code>WebNodePort</code> 也就对应于 30993，显示 <code>Service Unavailable</code>。符合预期，因为Backend的Endpoint还没有起来。</p><p>创建对应的 Deployment：</p><figure class="highlight yaml"><figcaption><span>animals-deployment.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">bear</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">bear</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bear</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:bear</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">moose</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">moose</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">moose</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:moose</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">    <span class="attr">animal:</span> <span class="string">hare</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">      <span class="attr">task:</span> <span class="string">hare</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">animals</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">hare</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v0.0.1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hare</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">supergiantkir/animals:hare</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在命令行中执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos traefik]<span class="comment"># kubectl apply -f animals-deployment.yaml</span></span><br><span class="line">deployment.extensions/bear created</span><br><span class="line">deployment.extensions/moose created</span><br><span class="line">deployment.extensions/hare created</span><br></pre></td></tr></table></figure><p><img alt="查看WebUI，显示后端EndPoint服务已就绪" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-endpoint.png"></p><p>这个是否分别访问Bear、Hare和Moose服务：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-bear.png"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-hare.png"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-moose.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ingress 是 Kubernetes 的一种 API 对象，将集群内部的 Service 通过 HTTP/HTTPS 方式暴露到集群外部，并通过规则定义 HTTP/HTTPS 的路由。Ingress 具备如下特性：集群外部可访问的 URL、负载均衡、SSL Termination、按域名路由。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-31_k8s-ingress.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
      <category term="ingress" scheme="http://houmin.cc/tags/ingress/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】Service</title>
    <link href="http://houmin.cc/posts/cfed77f0/"/>
    <id>http://houmin.cc/posts/cfed77f0/</id>
    <published>2020-08-18T12:37:46.000Z</published>
    <updated>2020-09-12T01:42:41.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes 中的 Service 将一组 Pod 以统一的形式对外暴露成一个服务，它利用运行在内核空间的 iptables 或者 ipvs 高效地转发来自节点内部和外部的流量。作为非常重要的 Kubernetes 对象，Service 不仅在逻辑上提供了微服务的概念，还引入 LoadBalancer 类型的 Service 无缝对接云服务商提供的复杂资源。</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>我们知道，Kubernetes 中的每一个 Pod 都可以通过 <code>podIP</code> 被直接访问，但是 Pod 是有生命周期的对象，它们可以被创建，而且销毁之后不会再启动。如果 <code>Deployment</code>、<code>ReplicaSet</code> 等对象管理 Pod，则它们可以动态地创建和销毁 Pod。在这种情况下，<code>Deployment</code>当前时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。</p><p>这就造成了一个问题，如果一组backend Pod 为集群中的另一组frontend Pod 提供服务时，由于每一个 Pod 都有自己的IP地址，并且这组Pod是会动态变化的，那么Frontend如何做服务发现以及会话保持，从而可以使用 Backend Pod 的服务？</p><p>为了解决这个问题，Kubernetes提出了 Service 这个概念：Service 是一组 Pod的逻辑集合和访问方式的抽象。举个例子，考虑一个图片处理后端，它运行了 3 个副本。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。 Service 定义的抽象能够解耦这种关联。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>下面是一个 Service 的典型定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>这里注意几个Port的定义区分：</p><ul><li>port：service暴露在cluster ip上的端口，<code>&lt;cluster ip&gt;:port</code> 是提供给集群内部客户访问service的入口</li><li>targetPort：Pod监听的端口，service会把流量转发到对应的Pod，Pod中的容器也需要监听这个端口</li><li>nodePort：对应于NodePort类型的Service时指定的节点上的Port，详见 <a href="#NodePort">NodePort</a></li></ul><p>在命令行中可以看到集群为Service创建了一个 <code>ClusterIP</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-28-centos nginx]<span class="comment"># kubectl get svc</span></span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nginx         ClusterIP   172.18.255.55    &lt;none&gt;        8080/TCP   5s</span><br></pre></td></tr></table></figure><p>创建 Nginx 实际对应的 Deployment：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>对应于实际服务请求的路径如下图所示：</p><p><img alt="Kubernetes Service" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-kube-proxy.png"></p><h2 id="Publish-Services"><a href="#Publish-Services" class="headerlink" title="Publish Services"></a>Publish Services</h2><p>Kubernetes 中支持四种服务暴露的方式： ClusterIP、NodePort、LoadBalancer、ExternelName</p><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><p>ClusterIP 类型的 service 是 kubernetes 集群默认的服务暴露方式，它只能用于集群内部通信，可以被各 pod 访问，其访问方式为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod ---&gt; ClusterIP:ServicePort --&gt; (iptables)DNAT --&gt; PodIP:containePort</span><br></pre></td></tr></table></figure><p>ClusterIP Service 类型的结构如下图所示:</p><p><img alt="Cluster IP" data-src="https://upload-images.jianshu.io/upload_images/1262158-875870767bdb199d.png"></p><h4 id="Headless-service"><a href="#Headless-service" class="headerlink" title="Headless service"></a>Headless service</h4><p>当不需要负载均衡以及单独的 ClusterIP 时，可以通过指定 <code>spec.clusterIP</code> 的值为 <code>None</code> 来创建 Headless service，它会给一个集群内部的每个成员提供一个唯一的 DNS 域名来作为每个成员的网络标识，集群内部成员之间使用域名通信。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>如果想要在集群外访问集群内部的服务，可以使用这种类型的 service，NodePort 类型的 service 会在集群内部署了 kube-proxy 的每个节点打开一个指定的端口，之后所有的流量直接发送到这个端口，然后会被转发到 service 后端真实的服务进行访问。Nodeport 构建在 ClusterIP 上，其访问链路如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client ---&gt; NodeIP:NodePort ---&gt; ClusterIP:ServicePort ---&gt; (iptables)DNAT ---&gt; PodIP:containePort</span><br></pre></td></tr></table></figure><p>其对应具体的 iptables 规则会在后文进行讲解。</p><p>NodePort service 类型的结构如下图所示:</p><p><img alt="Node Port" data-src="https://upload-images.jianshu.io/upload_images/1262158-0873f8f59cb83a8c.png"></p><p>修改 service 定义如下，其中 <code>nodeport</code> 字段表示通过 nodeport 方式访问的端口，<code>port</code> 表示通过 service 方式访问的端口，<code>targetPort</code> 表示 pod port。如果这里的 <code>nodePort</code> 字段不指定，Kubernetes会自动申请一个Node Port。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="comment"># By default and for convenience, the `targetPort` is set to the same value as the `port` field.</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="comment"># Optional field</span></span><br><span class="line">    <span class="comment"># By default and for convenience, the Kubernetes control plane will allocate a port from a range (default: 30000-32767)</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure><p>执行 <code>kubectl get service</code> 可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx         NodePort    172.18.252.115   &lt;none&gt;        80:30080/TCP   20s</span><br></pre></td></tr></table></figure><p>这时候，在浏览器中选择集群中任意一节点的IP作为 <code>nodeIP</code>，通过浏览器 <code>http://&lt;nodeIP&gt;:&lt;nodePort&gt;</code> 可以看到 Nginx 的欢迎界面。</p><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>LoadBalancer 类型的 service 通常和云厂商的 LB 结合一起使用，用于将集群内部的服务暴露到外网，云厂商的 LoadBalancer 会给用户分配一个 IP，之后通过该 IP 的流量会转发到你的 service 上。</p><p>LoadBalancer service 类型的结构如下图所示:</p><p><img alt="Load Balancer" data-src="https://upload-images.jianshu.io/upload_images/1262158-6f8d3d4c58adeeca.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.0</span><span class="number">.171</span><span class="number">.239</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span> <span class="number">78.11</span><span class="number">.24</span><span class="number">.19</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">146.148</span><span class="number">.47</span><span class="number">.155</span></span><br></pre></td></tr></table></figure><h3 id="ExternelName"><a href="#ExternelName" class="headerlink" title="ExternelName"></a>ExternelName</h3><p>类型为 ExternalName 的服务将服务映射到 DNS 名称，而不是典型的选择器，例如 <code>my-service</code> 或者 <code>cassandra</code>。 您可以使用 <code>spec.externalName</code> 参数指定这些服务。</p><p>例如，以下 Service 定义将 <code>prod</code> 名称空间中的 <code>my-service</code> 服务映射到 <code>my.database.example.com</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">my.database.example.com</span></span><br></pre></td></tr></table></figure><p>当查找主机 <code>my-service.prod.svc.cluster.local</code> 时，集群 DNS 服务返回 <code>CNAME</code> 记录， 其值为 <code>my.database.example.com</code>。 访问 <code>my-service</code> 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。 如果以后您决定将数据库移到群集中，则可以启动其 Pod，添加适当的选择器或端点以及更改服务的 <code>type</code>。</p><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>Service 是一组具有相同 label pod 集合的抽象，集群内外的各个服务可以通过 service 进行互相通信。在 Kubernetes 中创建一个新的 Service 对象需要两大模块同时协作:</p><ul><li>Controller：在每次创建新的 Service 对象时，会同时创建一个 Endpoint 对象。Endpoint 是用于<strong>容器发现</strong>，Service 只是将多个 Pod 进行关联。Endpoints Controller 是负责生成和维护所有 Endpoints 对象的控制器，监听 Service 和对应 Pod 的变化，更新对应 Service 的 Endpoints 对象。当 Pod 处于 running 且准备就绪时，Endpoints Controller 会将 Pod IP 记录到 Endpoints 对象中。</li><li>kube-proxy：它运行在 Kubernetes 集群中的每一个节点上，会根据 Service 和 Endpoint 的变动改变节点上 iptables 或者 ipvs 中保存的规则。</li></ul><p><img alt="Kubernetes Service" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-service.png"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>每当有服务被创建或者销毁时，Informer 都会通知 <code>ServiceController</code>，它会将这些任务投入工作队列中并由其本身启动的 Worker 协程消费：</p><pre class="mermaid">sequenceDiagram    participant I as Informer    participant SC as ServiceController    participant Q as WorkQueue    participant B as Balancer    I->>+SC: Add/Update/DeleteService    SC->>Q: Add    Q-->>SC: return    deactivate SC    loop Worker        SC->>+Q: Get        Q-->>-SC: key        SC->>SC: syncService        SC->>+B: EnsureLoadBalancer        B-->>-SC: LoadBalancerStatus    end</pre><h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>我们在使用 Kubernetes 时虽然很少会直接与 Endpoint 资源打交道，但是它却是 Kubernetes 中非常重要的组成部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endpoints is a collection of endpoints that implement the actual service.  Example:</span></span><br><span class="line"><span class="comment">//   Name: "mysvc",</span></span><br><span class="line"><span class="comment">//   Subsets: [</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       Addresses: [&#123;"ip": "10.10.1.1"&#125;, &#123;"ip": "10.10.2.2"&#125;],</span></span><br><span class="line"><span class="comment">//       Ports: [&#123;"name": "a", "port": 8675&#125;, &#123;"name": "b", "port": 309&#125;]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       Addresses: [&#123;"ip": "10.10.3.3"&#125;],</span></span><br><span class="line"><span class="comment">//       Ports: [&#123;"name": "a", "port": 93&#125;, &#123;"name": "b", "port": 76&#125;]</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"><span class="keyword">type</span> Endpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta</span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line"><span class="comment">// The set of all endpoints is the union of all subsets.</span></span><br><span class="line">Subsets []EndpointSubset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndpointSubset is a group of addresses with a common set of ports.  The</span></span><br><span class="line"><span class="comment">// expanded set of endpoints is the Cartesian product of Addresses x Ports.</span></span><br><span class="line"><span class="comment">// For example, given:</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     Addresses: [&#123;"ip": "10.10.1.1"&#125;, &#123;"ip": "10.10.2.2"&#125;],</span></span><br><span class="line"><span class="comment">//     Ports:     [&#123;"name": "a", "port": 8675&#125;, &#123;"name": "b", "port": 309&#125;]</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// The resulting set of endpoints can be viewed as:</span></span><br><span class="line"><span class="comment">//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],</span></span><br><span class="line"><span class="comment">//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]</span></span><br><span class="line"><span class="keyword">type</span> EndpointSubset <span class="keyword">struct</span> &#123;</span><br><span class="line">Addresses         []EndpointAddress</span><br><span class="line">NotReadyAddresses []EndpointAddress</span><br><span class="line">Ports             []EndpointPort</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>While you’re correct that in the <a href="https://kubernetes.io/docs/reference/glossary" target="_blank" rel="external nofollow noopener noreferrer">glossary</a> there’s indeed no entry for endpoint, it is a well defined Kubernetes network concept or abstraction. Since it’s of secondary nature, you’d usually not directly manipulate it. There’s a core resource <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#endpoints-v1-core" target="_blank" rel="external nofollow noopener noreferrer">Endpoint</a> defined and it’s also supported on the command line:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="keyword">get</span> ep</span><br><span class="line">NAME         ENDPOINTS            AGE</span><br><span class="line">kubernetes   <span class="number">192.168</span><span class="number">.64</span><span class="number">.13</span>:<span class="number">8443</span>   <span class="number">10</span>d</span><br></pre></td></tr></table></figure><p>And there you see what it effectively is: an IP address and a port. Usually, you’d let a service manage endpoints (one EP per pod the service routes traffic to) but you can also <a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="external nofollow noopener noreferrer">manually manage</a> them if you have a use case that requires it.</p><p>  服务和pod不是直接连接，而是通过<strong>Endpoint资源</strong>进行连通。endpoint资源是暴露<strong>一个服务的ip地址和port的列表。</strong>  选择器用于构建ip和port列表，然后存储在endpoint资源中。当客户端连接到服务时，服务代理选择这些列表中的ip和port对中的一个，并将传入连接重定向到在该位置监听的服务器。  endpoint是一个单独的资源并不是服务的属性，<strong>endpoint的名称必须和服务的名称相匹配</strong>。</p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>  为没有选择器的服务创建endpoint资源： <code>$ kubectl create -f endpoint.yml</code>  endpoint对象需要与服务相同的名称，并包含该服务的目标ip和port列表，服务和endpoint资源都发布到服务器后，这样服务就可以像具有pod选择器那样的服务正常使用。</p><p><img alt="endpoint yml 模板" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/1"></p></blockquote><p><code>EndpointController</code> 本身并没有通过 <code>Informer</code> 监听 Endpoint 资源的变动，但是它却同时订阅了 Service 和 Pod 资源的增删事件，对于 Service 资源来讲，<code>EndpointController</code> 会通过以下的方式进行处理：</p><pre class="mermaid">sequenceDiagram    participant I as Informer    participant EC as EndpointController    participant Q as WorkQueue    participant PL as PodLister    participant C as Client    I->>+EC: Add/Update/DeleteService    EC->>Q: Add    Q-->>EC: return    loop Worker        EC->>+Q: Get        Q-->>-EC: key        EC->>+EC: syncService        EC->>+PL: ListPod(service.Spec.Selector)        PL-->>-EC: Pods        loop Every Pod            EC->>EC: addEndpointSubset        end        EC->>C: Create/UpdateEndpoint        C-->>-EC: result    end</pre><p><code>EndpointController</code> 中的 <code>syncService</code> 方法是用于创建和删除 Endpoint 资源最重要的方法，在这个方法中我们会根据 Service 对象规格中的选择器 Selector 获取集群中存在的所有 Pod，并将 Service 和 Pod 上的端口进行映射生成一个 <code>EndpointPort</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">syncService</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">namespace, name, _ := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">service, _ := e.serviceLister.Services(namespace).Get(name)</span><br><span class="line">pods, _ := e.podLister.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelectorPreValidated())</span><br><span class="line"></span><br><span class="line">subsets := []v1.EndpointSubset&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">epa := *podToEndpointAddress(pod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line"></span><br><span class="line">portName := servicePort.Name</span><br><span class="line">portProto := servicePort.Protocol</span><br><span class="line">portNum, _ := podutil.FindPort(pod, servicePort)</span><br><span class="line"></span><br><span class="line">epp := &amp;v1.EndpointPort&#123;Name: portName, Port: <span class="keyword">int32</span>(portNum), Protocol: portProto&#125;</span><br><span class="line">subsets, _, _ = addEndpointSubset(subsets, pod, epa, epp, tolerateUnreadyEndpoints)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">subsets = endpoints.RepackSubsets(subsets)</span><br><span class="line"></span><br><span class="line">currentEndpoints = &amp;v1.Endpoints&#123;</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name:   service.Name,</span><br><span class="line">Labels: service.Labels,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newEndpoints := currentEndpoints.DeepCopy()</span><br><span class="line">newEndpoints.Subsets = subsets</span><br><span class="line">newEndpoints.Labels = service.Labels</span><br><span class="line">e.client.CoreV1().Endpoints(service.Namespace).Create(newEndpoints)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个 Pod 都会生成一个新的 <code>EndpointSubset</code>，其中包含了 Pod 的 IP 地址和端口和 Service 的规格中指定的输入端口和目标端口，在最后 <code>EndpointSubset</code> 的数据会被重新打包并通过客户端创建一个新的 Endpoint 资源。</p><p>在上面我们已经提到过，除了 Service 的变动会触发 Endpoint 的改变之外，Pod 对象的增删也会触发 <code>EndpointController</code> 中的回调函数。</p><pre class="mermaid">sequenceDiagram    participant I as Informer    participant EC as EndpointController    participant Q as WorkQueue    participant SL as ServiceLister    I->>+EC: Add/Update/DeletePod    EC->>+SL: GetPodServices    SL-->>-EC: []Service    EC->>Q: Add    Q-->>EC: return    deactivate EC</pre><p><code>getPodServiceMemberships</code> 会获取跟当前 Pod 有关的 Service 对象并将所有的 Service 对象都转换成 <code>&lt;namespace&gt;/&lt;name&gt;</code> 的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndpointController)</span> <span class="title">getPodServiceMemberships</span><span class="params">(pod *v1.Pod)</span> <span class="params">(sets.String, error)</span></span> &#123;</span><br><span class="line">set := sets.String&#123;&#125;</span><br><span class="line">services, _ := e.serviceLister.GetPodServices(pod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> services &#123;</span><br><span class="line">key, _ := controller.KeyFunc(services[i])</span><br><span class="line">set.Insert(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些服务最后会被加入 <code>EndpointController</code> 的队列中，等待它持有的几个 Worker 对 Service 进行同步。</p><p>这些其实就是 <code>EndpointController</code> 的作用，订阅 Pod 和 Service 对象的变更，并根据当前集群中的对象生成 Endpoint 对象将两者进行关联。</p><h2 id="Proxy-Mode"><a href="#Proxy-Mode" class="headerlink" title="Proxy Mode"></a>Proxy Mode</h2><p>在 Kubernetes 集群中的每一个节点都运行着一个 kube-proxy 进程，这个进程会负责监听 Kubernetes 主节点中 Service 的增加和删除事件并修改运行代理的配置，为节点内的客户端提供流量的转发和负载均衡等功能。在整个集群中另一个订阅 Service 对象变动的组件就是 kube-proxy 了，每当 kube-proxy 在新的节点上启动时都会初始化一个 <code>ServiceConfig</code> 对象，就像介绍 iptables 代理模式时提到的，这个对象会接受 Service 的变更事件：</p><pre class="mermaid">sequenceDiagram    participant SCT as ServiceChangeTracker    participant SC as ServiceConfig    participant P as Proxier    participant EC as EndpointConfig    participant ECT as EndpointChangeTracker    participant SR as SyncRunner    SC->>+P: OnServiceAdd/Update/Delete/Synced    P->>SCT: Update    SCT-->>P: Return ServiceMap    deactivate P    EC->>+P: OnEndpointsAdd/Update/Delete/Synced    ECT-->>P: Return EndpointMap    P->>ECT: Update    deactivate P    loop Every minSyncPeriod ~ syncPeriod        SR->>P: syncProxyRules    end</pre><p>这些变更事件都会被订阅了集群中对象变动的 <code>ServiceConfig</code> 和 <code>EndpointConfig</code> 对象推送给启动的 <code>Proxier</code> 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceConfig)</span> <span class="title">handleAddService</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">service, ok := obj.(*v1.Service)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">c.eventHandlers[i].OnServiceAdd(service)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到事件变动的 <code>Proxier</code> 实例随后会根据启动时的配置更新 iptables 或者 ipvs 中的规则，这些应用最终会负责对进出的流量进行转发并完成一些负载均衡相关的任务。</p><h3 id="Userspace"><a href="#Userspace" class="headerlink" title="Userspace"></a>Userspace</h3><p>作为运行在用户空间的代理，对于每一个 Service 都会在当前的节点上开启一个端口，所有连接到当前代理端口的请求都会被转发到 Service 背后的一组 Pod 上，它其实会在节点上添加 iptables 规则，通过 iptables 将流量转发给 kube-proxy 处理。</p><p>如果当前节点上的 kube-proxy 在启动时选择了 userspace 模式，那么每当有新的 Service 被创建时，kube-proxy 就会增加一条 iptables 记录并启动一个 Goroutine，前者用于将节点中服务对外发出的流量转发给 kube-proxy，再由后者持有的一系列 Goroutine 将流量转发到目标的 Pod 上。</p><p>在 userspace 模式下，访问服务的请求到达节点后首先进入内核 iptables，然后回到用户空间，由 kube-proxy 转发到后端的 pod，这样流量从用户空间进出内核带来的性能损耗是不可接受的，所以也就有了 iptables 模式。</p><p>为什么 userspace 模式要建立 iptables 规则，因为 kube-proxy 监听的端口在用户空间，这个端口不是服务的访问端口也不是服务的 nodePort，因此需要一层 iptables 把访问服务的连接重定向给 kube-proxy 服务。</p><p><img alt="Service Userspace Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-userspace.svg"></p><p>这一系列的工作大都是在 <code>OnServiceAdd</code> 被触发时中完成的，正如上面所说的，该方法会调用 <code>mergeService</code> 将传入服务 Service 的端口变成一条 iptables 的配置命令为当前节点增加一条规则，同时在 <code>addServiceOnPort</code> 方法中启动一个 TCP 或 UDP 的 Socket：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">mergeService</span><span class="params">(service *v1.Service)</span> <span class="title">sets</span>.<span class="title">String</span></span> &#123;</span><br><span class="line">svcName := types.NamespacedName&#123;Namespace: service.Namespace, Name: service.Name&#125;</span><br><span class="line">existingPorts := sets.NewString()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line">serviceName := proxy.ServicePortName&#123;NamespacedName: svcName, Port: servicePort.Name&#125;</span><br><span class="line">existingPorts.Insert(servicePort.Name)</span><br><span class="line">info, exists := proxier.getServiceInfo(serviceName)</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">proxier.closePortal(serviceName, info)</span><br><span class="line">proxier.stopProxy(serviceName, info)</span><br><span class="line">&#125;</span><br><span class="line">proxyPort,  := proxier.proxyPorts.AllocateNext()</span><br><span class="line"></span><br><span class="line">serviceIP := net.ParseIP(service.Spec.ClusterIP)</span><br><span class="line">info, _ = proxier.addServiceOnPort(serviceName, servicePort.Protocol, proxyPort, proxier.udpIdleTimeout)</span><br><span class="line">info.portal.ip = serviceIP</span><br><span class="line">info.portal.port = <span class="keyword">int</span>(servicePort.Port)</span><br><span class="line">info.externalIPs = service.Spec.ExternalIPs</span><br><span class="line">info.loadBalancerStatus = *service.Status.LoadBalancer.DeepCopy()</span><br><span class="line">info.nodePort = <span class="keyword">int</span>(servicePort.NodePort)</span><br><span class="line">info.sessionAffinityType = service.Spec.SessionAffinity</span><br><span class="line"></span><br><span class="line">proxier.openPortal(serviceName, info)</span><br><span class="line">proxier.loadBalancer.NewService(serviceName, info.sessionAffinityType, info.stickyMaxAgeSeconds)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> existingPorts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个启动的进程会监听同一个节点上，转发自所有进程的 TCP 和 UDP 请求并将这些数据包发送给目标的 Pod 对象。</p><p>在用户空间模式中，如果一个连接被目标服务拒绝，我们的代理服务能够重新尝试连接其他的服务，除此之外用户空间模式并没有太多的优势。</p><h3 id="IPTables"><a href="#IPTables" class="headerlink" title="IPTables"></a>IPTables</h3><p>另一种常见的代理模式就是直接使用 iptables 转发当前节点上的全部流量，这种脱离了用户空间在内核空间中实现转发的方式能够极大地提高 proxy 的效率，增加 kube-proxy 的吞吐量。</p><p>iptables 模式是目前默认的代理方式，基于 netfilter 实现。当客户端请求 service 的 ClusterIP 时，根据 iptables 规则路由到各 pod 上，iptables 使用 DNAT 来完成转发，其采用了随机数实现负载均衡。</p><p>iptables 模式与 userspace 模式最大的区别在于，iptables 模块使用 DNAT 模块实现了 service 入口地址到 pod 实际地址的转换，免去了一次内核态到用户态的切换，另一个与 userspace 代理模式不同的是，如果 iptables 代理最初选择的那个 pod 没有响应，它不会自动重试其他 pod。</p><p>iptables 模式最主要的问题是在 service 数量大的时候会产生太多的 iptables 规则，使用非增量式更新会引入一定的时延，大规模情况下有明显的性能问题。</p><p><img alt="Service Iptables Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-iptables.svg"></p><p>iptables 作为一种代理模式，它同样实现了 <code>OnServiceUpdate</code>、<code>OnEndpointsUpdate</code> 等方法，这两个方法会分别调用相应的变更追踪对象。</p><pre class="mermaid">sequenceDiagram    participant SC as ServiceConfig    participant P as Proxier    participant SCT as ServiceChangeTracker    participant SR as SyncRunner    participant I as iptable    SC->>+P: OnServiceAdd    P->>P: OnServiceUpdate    P->>SCT: Update    SCT-->>P: Return ServiceMap    deactivate P    loop Every minSyncPeriod ~ syncPeriod        SR->>+P: syncProxyRules        P->>I: UpdateChain        P->>P: writeLine x N        P->>I: RestoreAll        deactivate P    end</pre><p>变更追踪对象会根据 <code>Service</code> 或 <code>Endpoint</code> 对象的前后变化改变 <code>ServiceChangeTracker</code> 本身的状态，这些变更会每隔一段时间通过一个 700 行的巨大方法 <code>syncProxyRules</code> 同步，在这里就不介绍这个方法的具体实现了，它的主要功能就是根据 <code>Service</code> 和 <code>Endpoint</code> 对象的变更生成一条一条的 iptables 规则，比较感兴趣的读者，可以点击 <a href="https://sourcegraph.com/github.com/kubernetes/kubernetes@master/-/blob/pkg/proxy/iptables/proxier.go#L640-1379" target="_blank" rel="external nofollow noopener noreferrer">proxier.go#L640-1379</a> 查看代码。</p><p>当我们使用 iptables 的方式启动节点上的代理时，所有的流量都会先经过 <code>PREROUTING</code> 或者 <code>OUTPUT</code> 链，随后进入 Kubernetes 自定义的链入口 KUBE-SERVICES、单个 Service 对应的链 <code>KUBE-SVC-XXXX</code> 以及每个 Pod 对应的链 <code>KUBE-SEP-XXXX</code>，经过这些链的处理，最终才能够访问当一个服务的真实 IP 地址。</p><p>虽然相比于用户空间来说，直接运行在内核态的 iptables 能够增加代理的吞吐量，但是当集群中的节点数量非常多时，iptables 并不能达到生产级别的可用性要求，每次对规则进行匹配时都会遍历 iptables 中的所有 Service 链。</p><p>规则的更新也不是增量式的，当集群中的 Service 达到 5,000 个，每增加一条规则都需要耗时 11min，当集群中的 Service 达到 20,000 个时，每增加一条规则都需要消耗 5h 的时间，这也就是告诉我们在大规模集群中使用 iptables 作为代理模式是完全不可用的。</p><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>ipvs 就是用于解决在大量 Service 时，iptables 规则同步变得不可用的性能问题。与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，这也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能。</p><p><img alt="Service IPVS Proxy Mode" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-services-ipvs.svg"></p><p>在处理 Service 的变化时，ipvs 包和 iptables 其实就有非常相似了，它们都同样使用 <code>ServiceChangeTracker</code> 对象来追踪变更，只是两者对于同步变更的方法 <code>syncProxyRules</code> 实现上有一些不同。</p><pre class="mermaid">sequenceDiagram    participant P as Proxier    participant SR as SyncRunner    participant IP as ipvs    participant I as iptable    loop Every minSyncPeriod ~ syncPeriod        SR->>+P: syncProxyRules        P->>P: writeLine(iptable)        P->>IP: Add/UpdateVirtualServer(syncService)        IP-->>P: result        P->>IP: AddRealServer(syncEndpoint)        IP-->>P: result        P->>I: RestoreAll        deactivate P    end</pre><p>我们从 ipvs 的源代码和上述的时序图中可以看到，Kubernetes ipvs 的实现其实是依赖于 iptables 的，后者能够辅助它完成一些功能，使用 ipvs 相比 iptables 能够减少节点上的 iptables 规则数量，这也是因为 ipvs 接管了原来存储在 iptables 中的规则。</p><p>除了能够提升性能之外，ipvs 也提供了多种类型的负载均衡算法，除了最常见的 Round-Robin 之外，还支持最小连接、目标哈希、最小延迟等算法，能够很好地提升负载均衡的效率。</p><p>当集群规模比较大时，iptables 规则刷新会非常慢，难以支持大规模集群，因其底层路由表的实现是链表，对路由规则的增删改查都要涉及遍历一次链表，ipvs 的问世正是解决此问题的，ipvs 是 LVS 的负载均衡模块，与 iptables 比较像的是，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构并且工作在内核态，也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能，几乎允许无限的规模扩张。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://xigang.github.io/2019/07/21/kubernetes-service/" target="_blank" rel="external nofollow noopener noreferrer">https://xigang.github.io/2019/07/21/kubernetes-service/</a></li><li><a href="https://www.cnblogs.com/passzhang/p/12544597.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/passzhang/p/12544597.html</a></li><li><a href="https://draveness.me/kubernetes-service/" target="_blank" rel="external nofollow noopener noreferrer">https://draveness.me/kubernetes-service/</a></li><li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 中的 Service 将一组 Pod 以统一的形式对外暴露成一个服务，它利用运行在内核空间的 iptables 或者 ipvs 高效地转发来自节点内部和外部的流量。作为非常重要的 Kubernetes 对象，Service 不仅在逻辑上提供了微服务的概念，还引入 LoadBalancer 类型的 Service 无缝对接云服务商提供的复杂资源。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-30_k8s-kube-proxy.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】Pod</title>
    <link href="http://houmin.cc/posts/b88b921f/"/>
    <id>http://houmin.cc/posts/b88b921f/</id>
    <published>2020-08-14T11:57:14.000Z</published>
    <updated>2020-09-12T01:46:44.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Pod</code> 是 Kubernetes 集群中能够被创建、调度和管理的最小部署单元，是一组容器的集合，是 k8s 中最简单的对象，也是 k8s 中最为基础的概念。同一个 Pod 中的容器可以共享同一个网络命名空间，IP地址和端口空间。从生命周期上来讲，Pod是短暂而不是长久的应用。Pod被调度到节点，保持在这个节点直到被摧毁。</p><p>本文将分两个部分对 Pod 解读，第一个部分介绍 Pod 的基本概念和常见特性，第二部分会从源码层面介绍 Pod 从创建到删除的整个生命周期的实现。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为 Kubernetes 集群中的基本单元，Pod 就是最小并且最简单的 Kubernetes 对象，这个简单的对象其实就能够独立启动一个后端进程并在集群的内部为调用方提供服务。在上一篇文章 <a href="https://draveness.me/kubernetes-object-intro" target="_blank" rel="external nofollow noopener noreferrer">从 Kubernetes 中的对象谈起</a> 中，我们曾经介绍过简单的 Kubernetes Pod 是如何使用 YAML 进行描述的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3600"</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>这个 YAML 文件描述了一个 Pod 启动时运行的容器和命令以及它的重启策略，在当前 Pod 出现错误或者执行结束后是否应该被 Kubernetes 的控制器拉起来，除了这些比较显眼的配置之外，元数据 <code>metadata</code> 的配置也非常重要，<code>name</code> 是当前对象在 Kubernetes 集群中的唯一标识符，而标签 <code>labels</code> 可以帮助我们快速选择对象。</p><p>在同一个 Pod 中，有几个概念特别值得关注，首先就是容器，在 Pod 中其实可以同时运行一个或者多个容器，这些容器能够共享网络、存储以及 CPU、内存等资源。在这一小节中我们将关注 Pod 中的容器、卷和网络三大概念。</p><h3 id="Pod-Spec"><a href="#Pod-Spec" class="headerlink" title="Pod Spec"></a>Pod Spec</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PodSpec is a description of a pod.</span></span><br><span class="line"><span class="keyword">type</span> PodSpec <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// List of volumes that can be mounted by containers belonging to the pod.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/storage/volumes</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge,retainKeys</span></span><br><span class="line">Volumes []Volume <span class="string">`json:"volumes,omitempty" patchStrategy:"merge,retainKeys" patchMergeKey:"name" protobuf:"bytes,1,rep,name=volumes"`</span></span><br><span class="line"><span class="comment">// List of initialization containers belonging to the pod.</span></span><br><span class="line"><span class="comment">// Init containers are executed in order prior to containers being started. If any</span></span><br><span class="line"><span class="comment">// init container fails, the pod is considered to have failed and is handled according</span></span><br><span class="line"><span class="comment">// to its restartPolicy. The name for an init container or normal container must be</span></span><br><span class="line"><span class="comment">// unique among all containers.</span></span><br><span class="line"><span class="comment">// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.</span></span><br><span class="line"><span class="comment">// The resourceRequirements of an init container are taken into account during scheduling</span></span><br><span class="line"><span class="comment">// by finding the highest request/limit for each resource type, and then using the max of</span></span><br><span class="line"><span class="comment">// of that value or the sum of the normal containers. Limits are applied to init containers</span></span><br><span class="line"><span class="comment">// in a similar fashion.</span></span><br><span class="line"><span class="comment">// Init containers cannot currently be added or removed.</span></span><br><span class="line"><span class="comment">// Cannot be updated.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">InitContainers []Container <span class="string">`json:"initContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,20,rep,name=initContainers"`</span></span><br><span class="line"><span class="comment">// List of containers belonging to the pod.</span></span><br><span class="line"><span class="comment">// Containers cannot currently be added or removed.</span></span><br><span class="line"><span class="comment">// There must be at least one container in a Pod.</span></span><br><span class="line"><span class="comment">// Cannot be updated.</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">Containers []Container <span class="string">`json:"containers" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,2,rep,name=containers"`</span></span><br><span class="line"><span class="comment">// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing</span></span><br><span class="line"><span class="comment">// pod to perform user-initiated actions such as debugging. This list cannot be specified when</span></span><br><span class="line"><span class="comment">// creating a pod, and it cannot be modified by updating the pod spec. In order to add an</span></span><br><span class="line"><span class="comment">// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.</span></span><br><span class="line"><span class="comment">// This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">EphemeralContainers []EphemeralContainer <span class="string">`json:"ephemeralContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,34,rep,name=ephemeralContainers"`</span></span><br><span class="line"><span class="comment">// Restart policy for all containers within the pod.</span></span><br><span class="line"><span class="comment">// One of Always, OnFailure, Never.</span></span><br><span class="line"><span class="comment">// Default to Always.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RestartPolicy RestartPolicy <span class="string">`json:"restartPolicy,omitempty" protobuf:"bytes,3,opt,name=restartPolicy,casttype=RestartPolicy"`</span></span><br><span class="line"><span class="comment">// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.</span></span><br><span class="line"><span class="comment">// Value must be non-negative integer. The value zero indicates delete immediately.</span></span><br><span class="line"><span class="comment">// If this value is nil, the default grace period will be used instead.</span></span><br><span class="line"><span class="comment">// The grace period is the duration in seconds after the processes running in the pod are sent</span></span><br><span class="line"><span class="comment">// a termination signal and the time when the processes are forcibly halted with a kill signal.</span></span><br><span class="line"><span class="comment">// Set this value longer than the expected cleanup time for your process.</span></span><br><span class="line"><span class="comment">// Defaults to 30 seconds.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">TerminationGracePeriodSeconds *<span class="keyword">int64</span> <span class="string">`json:"terminationGracePeriodSeconds,omitempty" protobuf:"varint,4,opt,name=terminationGracePeriodSeconds"`</span></span><br><span class="line"><span class="comment">// Optional duration in seconds the pod may be active on the node relative to</span></span><br><span class="line"><span class="comment">// StartTime before the system will actively try to mark it failed and kill associated containers.</span></span><br><span class="line"><span class="comment">// Value must be a positive integer.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ActiveDeadlineSeconds *<span class="keyword">int64</span> <span class="string">`json:"activeDeadlineSeconds,omitempty" protobuf:"varint,5,opt,name=activeDeadlineSeconds"`</span></span><br><span class="line"><span class="comment">// Set DNS policy for the pod.</span></span><br><span class="line"><span class="comment">// Defaults to "ClusterFirst".</span></span><br><span class="line"><span class="comment">// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.</span></span><br><span class="line"><span class="comment">// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.</span></span><br><span class="line"><span class="comment">// To have DNS options set along with hostNetwork, you have to specify DNS policy</span></span><br><span class="line"><span class="comment">// explicitly to 'ClusterFirstWithHostNet'.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">DNSPolicy DNSPolicy <span class="string">`json:"dnsPolicy,omitempty" protobuf:"bytes,6,opt,name=dnsPolicy,casttype=DNSPolicy"`</span></span><br><span class="line"><span class="comment">// NodeSelector is a selector which must be true for the pod to fit on a node.</span></span><br><span class="line"><span class="comment">// Selector which must match a node's labels for the pod to be scheduled on that node.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">NodeSelector <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"nodeSelector,omitempty" protobuf:"bytes,7,rep,name=nodeSelector"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceAccountName is the name of the ServiceAccount to use to run this pod.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ServiceAccountName <span class="keyword">string</span> <span class="string">`json:"serviceAccountName,omitempty" protobuf:"bytes,8,opt,name=serviceAccountName"`</span></span><br><span class="line"><span class="comment">// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.</span></span><br><span class="line"><span class="comment">// Deprecated: Use serviceAccountName instead.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">DeprecatedServiceAccount <span class="keyword">string</span> <span class="string">`json:"serviceAccount,omitempty" protobuf:"bytes,9,opt,name=serviceAccount"`</span></span><br><span class="line"><span class="comment">// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">AutomountServiceAccountToken *<span class="keyword">bool</span> <span class="string">`json:"automountServiceAccountToken,omitempty" protobuf:"varint,21,opt,name=automountServiceAccountToken"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,</span></span><br><span class="line"><span class="comment">// the scheduler simply schedules this pod onto that node, assuming that it fits resource</span></span><br><span class="line"><span class="comment">// requirements.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">NodeName <span class="keyword">string</span> <span class="string">`json:"nodeName,omitempty" protobuf:"bytes,10,opt,name=nodeName"`</span></span><br><span class="line"><span class="comment">// Host networking requested for this pod. Use the host's network namespace.</span></span><br><span class="line"><span class="comment">// If this option is set, the ports that will be used must be specified.</span></span><br><span class="line"><span class="comment">// Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">HostNetwork <span class="keyword">bool</span> <span class="string">`json:"hostNetwork,omitempty" protobuf:"varint,11,opt,name=hostNetwork"`</span></span><br><span class="line"><span class="comment">// Use the host's pid namespace.</span></span><br><span class="line"><span class="comment">// Optional: Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">HostPID <span class="keyword">bool</span> <span class="string">`json:"hostPID,omitempty" protobuf:"varint,12,opt,name=hostPID"`</span></span><br><span class="line"><span class="comment">// Use the host's ipc namespace.</span></span><br><span class="line"><span class="comment">// Optional: Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">HostIPC <span class="keyword">bool</span> <span class="string">`json:"hostIPC,omitempty" protobuf:"varint,13,opt,name=hostIPC"`</span></span><br><span class="line"><span class="comment">// Share a single process namespace between all of the containers in a pod.</span></span><br><span class="line"><span class="comment">// When this is set containers will be able to view and signal processes from other containers</span></span><br><span class="line"><span class="comment">// in the same pod, and the first process in each container will not be assigned PID 1.</span></span><br><span class="line"><span class="comment">// HostPID and ShareProcessNamespace cannot both be set.</span></span><br><span class="line"><span class="comment">// Optional: Default to false.</span></span><br><span class="line"><span class="comment">// +k8s:conversion-gen=false</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ShareProcessNamespace *<span class="keyword">bool</span> <span class="string">`json:"shareProcessNamespace,omitempty" protobuf:"varint,27,opt,name=shareProcessNamespace"`</span></span><br><span class="line"><span class="comment">// SecurityContext holds pod-level security attributes and common container settings.</span></span><br><span class="line"><span class="comment">// Optional: Defaults to empty.  See type description for default values of each field.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">SecurityContext *PodSecurityContext <span class="string">`json:"securityContext,omitempty" protobuf:"bytes,14,opt,name=securityContext"`</span></span><br><span class="line"><span class="comment">// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.</span></span><br><span class="line"><span class="comment">// If specified, these secrets will be passed to individual puller implementations for them to use. For example,</span></span><br><span class="line"><span class="comment">// in the case of docker, only DockerConfig type secrets are honored.</span></span><br><span class="line"><span class="comment">// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=name</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">ImagePullSecrets []LocalObjectReference <span class="string">`json:"imagePullSecrets,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,15,rep,name=imagePullSecrets"`</span></span><br><span class="line"><span class="comment">// Specifies the hostname of the Pod</span></span><br><span class="line"><span class="comment">// If not specified, the pod's hostname will be set to a system-defined value.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Hostname <span class="keyword">string</span> <span class="string">`json:"hostname,omitempty" protobuf:"bytes,16,opt,name=hostname"`</span></span><br><span class="line"><span class="comment">// If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".</span></span><br><span class="line"><span class="comment">// If not specified, the pod will not have a domainname at all.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Subdomain <span class="keyword">string</span> <span class="string">`json:"subdomain,omitempty" protobuf:"bytes,17,opt,name=subdomain"`</span></span><br><span class="line"><span class="comment">// If specified, the pod's scheduling constraints</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Affinity *Affinity <span class="string">`json:"affinity,omitempty" protobuf:"bytes,18,opt,name=affinity"`</span></span><br><span class="line"><span class="comment">// If specified, the pod will be dispatched by specified scheduler.</span></span><br><span class="line"><span class="comment">// If not specified, the pod will be dispatched by default scheduler.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">SchedulerName <span class="keyword">string</span> <span class="string">`json:"schedulerName,omitempty" protobuf:"bytes,19,opt,name=schedulerName"`</span></span><br><span class="line"><span class="comment">// If specified, the pod's tolerations.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Tolerations []Toleration <span class="string">`json:"tolerations,omitempty" protobuf:"bytes,22,opt,name=tolerations"`</span></span><br><span class="line"><span class="comment">// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts</span></span><br><span class="line"><span class="comment">// file if specified. This is only valid for non-hostNetwork pods.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=ip</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line">HostAliases []HostAlias <span class="string">`json:"hostAliases,omitempty" patchStrategy:"merge" patchMergeKey:"ip" protobuf:"bytes,23,rep,name=hostAliases"`</span></span><br><span class="line"><span class="comment">// If specified, indicates the pod's priority. "system-node-critical" and</span></span><br><span class="line"><span class="comment">// "system-cluster-critical" are two special keywords which indicate the</span></span><br><span class="line"><span class="comment">// highest priorities with the former being the highest priority. Any other</span></span><br><span class="line"><span class="comment">// name must be defined by creating a PriorityClass object with that name.</span></span><br><span class="line"><span class="comment">// If not specified, the pod priority will be default or zero if there is no</span></span><br><span class="line"><span class="comment">// default.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PriorityClassName <span class="keyword">string</span> <span class="string">`json:"priorityClassName,omitempty" protobuf:"bytes,24,opt,name=priorityClassName"`</span></span><br><span class="line"><span class="comment">// The priority value. Various system components use this field to find the</span></span><br><span class="line"><span class="comment">// priority of the pod. When Priority Admission Controller is enabled, it</span></span><br><span class="line"><span class="comment">// prevents users from setting this field. The admission controller populates</span></span><br><span class="line"><span class="comment">// this field from PriorityClassName.</span></span><br><span class="line"><span class="comment">// The higher the value, the higher the priority.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Priority *<span class="keyword">int32</span> <span class="string">`json:"priority,omitempty" protobuf:"bytes,25,opt,name=priority"`</span></span><br><span class="line"><span class="comment">// Specifies the DNS parameters of a pod.</span></span><br><span class="line"><span class="comment">// Parameters specified here will be merged to the generated DNS</span></span><br><span class="line"><span class="comment">// configuration based on DNSPolicy.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">DNSConfig *PodDNSConfig <span class="string">`json:"dnsConfig,omitempty" protobuf:"bytes,26,opt,name=dnsConfig"`</span></span><br><span class="line"><span class="comment">// If specified, all readiness gates will be evaluated for pod readiness.</span></span><br><span class="line"><span class="comment">// A pod is ready when all its containers are ready AND</span></span><br><span class="line"><span class="comment">// all conditions specified in the readiness gates have status equal to "True"</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">ReadinessGates []PodReadinessGate <span class="string">`json:"readinessGates,omitempty" protobuf:"bytes,28,opt,name=readinessGates"`</span></span><br><span class="line"><span class="comment">// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used</span></span><br><span class="line"><span class="comment">// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.</span></span><br><span class="line"><span class="comment">// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an</span></span><br><span class="line"><span class="comment">// empty definition that uses the default runtime handler.</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md</span></span><br><span class="line"><span class="comment">// This is a beta feature as of Kubernetes v1.14.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RuntimeClassName *<span class="keyword">string</span> <span class="string">`json:"runtimeClassName,omitempty" protobuf:"bytes,29,opt,name=runtimeClassName"`</span></span><br><span class="line"><span class="comment">// EnableServiceLinks indicates whether information about services should be injected into pod's</span></span><br><span class="line"><span class="comment">// environment variables, matching the syntax of Docker links.</span></span><br><span class="line"><span class="comment">// Optional: Defaults to true.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">EnableServiceLinks *<span class="keyword">bool</span> <span class="string">`json:"enableServiceLinks,omitempty" protobuf:"varint,30,opt,name=enableServiceLinks"`</span></span><br><span class="line"><span class="comment">// PreemptionPolicy is the Policy for preempting pods with lower priority.</span></span><br><span class="line"><span class="comment">// One of Never, PreemptLowerPriority.</span></span><br><span class="line"><span class="comment">// Defaults to PreemptLowerPriority if unset.</span></span><br><span class="line"><span class="comment">// This field is alpha-level and is only honored by servers that enable the NonPreemptingPriority feature.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PreemptionPolicy *PreemptionPolicy <span class="string">`json:"preemptionPolicy,omitempty" protobuf:"bytes,31,opt,name=preemptionPolicy"`</span></span><br><span class="line"><span class="comment">// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.</span></span><br><span class="line"><span class="comment">// This field will be autopopulated at admission time by the RuntimeClass admission controller. If</span></span><br><span class="line"><span class="comment">// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.</span></span><br><span class="line"><span class="comment">// The RuntimeClass admission controller will reject Pod create requests which have the overhead already</span></span><br><span class="line"><span class="comment">// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value</span></span><br><span class="line"><span class="comment">// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md</span></span><br><span class="line"><span class="comment">// This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">Overhead ResourceList <span class="string">`json:"overhead,omitempty" protobuf:"bytes,32,opt,name=overhead"`</span></span><br><span class="line"><span class="comment">// TopologySpreadConstraints describes how a group of pods ought to spread across topology</span></span><br><span class="line"><span class="comment">// domains. Scheduler will schedule pods in a way which abides by the constraints.</span></span><br><span class="line"><span class="comment">// This field is only honored by clusters that enable the EvenPodsSpread feature.</span></span><br><span class="line"><span class="comment">// All topologySpreadConstraints are ANDed.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// +patchMergeKey=topologyKey</span></span><br><span class="line"><span class="comment">// +patchStrategy=merge</span></span><br><span class="line"><span class="comment">// +listType=map</span></span><br><span class="line"><span class="comment">// +listMapKey=topologyKey</span></span><br><span class="line"><span class="comment">// +listMapKey=whenUnsatisfiable</span></span><br><span class="line">TopologySpreadConstraints []TopologySpreadConstraint <span class="string">`json:"topologySpreadConstraints,omitempty" patchStrategy:"merge" patchMergeKey:"topologyKey" protobuf:"bytes,33,opt,name=topologySpreadConstraints"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pod的状态"><a href="#Pod的状态" class="headerlink" title="Pod的状态"></a>Pod的状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These are the valid statuses of pods.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// PodPending means the pod has been accepted by the system, but one or more of the containers</span></span><br><span class="line"><span class="comment">// has not been started. This includes time before being bound to a node, as well as time spent</span></span><br><span class="line"><span class="comment">// pulling images onto the host.</span></span><br><span class="line">PodPending PodPhase = <span class="string">"Pending"</span></span><br><span class="line"><span class="comment">// PodRunning means the pod has been bound to a node and all of the containers have been started.</span></span><br><span class="line"><span class="comment">// At least one container is still running or is in the process of being restarted.</span></span><br><span class="line">PodRunning PodPhase = <span class="string">"Running"</span></span><br><span class="line"><span class="comment">// PodSucceeded means that all containers in the pod have voluntarily terminated</span></span><br><span class="line"><span class="comment">// with a container exit code of 0, and the system is not going to restart any of these containers.</span></span><br><span class="line">PodSucceeded PodPhase = <span class="string">"Succeeded"</span></span><br><span class="line"><span class="comment">// PodFailed means that all containers in the pod have terminated, and at least one container has</span></span><br><span class="line"><span class="comment">// terminated in a failure (exited with a non-zero exit code or was stopped by the system).</span></span><br><span class="line">PodFailed PodPhase = <span class="string">"Failed"</span></span><br><span class="line"><span class="comment">// PodUnknown means that for some reason the state of the pod could not be obtained, typically due</span></span><br><span class="line"><span class="comment">// to an error in communicating with the host of the pod.</span></span><br><span class="line">PodUnknown PodPhase = <span class="string">"Unknown"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pod affinity is a group of inter pod affinity scheduling rules.</span></span><br><span class="line"><span class="keyword">type</span> PodAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// NOT YET IMPLEMENTED. <span class="doctag">TODO:</span> Uncomment field once it is implemented.</span></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system will try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system may or may not try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm <span class="string">`json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line"><span class="comment">// The scheduler will prefer to schedule pods to nodes that satisfy</span></span><br><span class="line"><span class="comment">// the affinity expressions specified by this field, but it may choose</span></span><br><span class="line"><span class="comment">// a node that violates one or more of the expressions. The node that is</span></span><br><span class="line"><span class="comment">// most preferred is the one with the greatest sum of weights, i.e.</span></span><br><span class="line"><span class="comment">// for each node that meets all of the scheduling requirements (resource</span></span><br><span class="line"><span class="comment">// request, requiredDuringScheduling affinity expressions, etc.),</span></span><br><span class="line"><span class="comment">// compute a sum by iterating through the elements of this field and adding</span></span><br><span class="line"><span class="comment">// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the</span></span><br><span class="line"><span class="comment">// node(s) with the highest sum are the most preferred.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm <span class="string">`json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pod anti affinity is a group of inter pod anti affinity scheduling rules.</span></span><br><span class="line"><span class="keyword">type</span> PodAntiAffinity <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// NOT YET IMPLEMENTED. <span class="doctag">TODO:</span> Uncomment field once it is implemented.</span></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system will try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line"><span class="comment">// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field are not met at</span></span><br><span class="line"><span class="comment">// scheduling time, the pod will not be scheduled onto the node.</span></span><br><span class="line"><span class="comment">// If the anti-affinity requirements specified by this field cease to be met</span></span><br><span class="line"><span class="comment">// at some point during pod execution (e.g. due to a pod label update), the</span></span><br><span class="line"><span class="comment">// system may or may not try to eventually evict the pod from its node.</span></span><br><span class="line"><span class="comment">// When there are multiple elements, the lists of nodes corresponding to each</span></span><br><span class="line"><span class="comment">// podAffinityTerm are intersected, i.e. all terms must be satisfied.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm <span class="string">`json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line"><span class="comment">// The scheduler will prefer to schedule pods to nodes that satisfy</span></span><br><span class="line"><span class="comment">// the anti-affinity expressions specified by this field, but it may choose</span></span><br><span class="line"><span class="comment">// a node that violates one or more of the expressions. The node that is</span></span><br><span class="line"><span class="comment">// most preferred is the one with the greatest sum of weights, i.e.</span></span><br><span class="line"><span class="comment">// for each node that meets all of the scheduling requirements (resource</span></span><br><span class="line"><span class="comment">// request, requiredDuringScheduling anti-affinity expressions, etc.),</span></span><br><span class="line"><span class="comment">// compute a sum by iterating through the elements of this field and adding</span></span><br><span class="line"><span class="comment">// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the</span></span><br><span class="line"><span class="comment">// node(s) with the highest sum are the most preferred.</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm <span class="string">`json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>每一个 Kubernetes 的 Pod 其实都具有两种不同的容器，两种不同容器的职责其实十分清晰，一种是 <code>InitContainer</code>，这种容器会在 Pod 启动时运行，主要用于初始化一些配置，另一种是 Pod 在 Running 状态时内部存活的 <code>Container</code>，它们的主要作用是对外提供服务或者作为工作节点处理异步任务等等。</p><p><img alt="kubernetes-pod-init-and-regular-containers" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-init-and-regular-containers.png"></p><p>通过对不同容器类型的命名我们也可以看出，<code>InitContainer</code> 会比 <code>Container</code> 优先启动，在 <code>kubeGenericRuntimeManager.SyncPod</code> 方法中会先后启动两种容器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line"><span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line"><span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line"><span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line"><span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: start the init container.</span></span><br><span class="line"><span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 6: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">container := &amp;pod.Spec.Containers[idx]</span><br><span class="line"></span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析私有方法 <code>startContainer</code> 的实现我们得出：容器的类型最终只会影响在 Debug 时创建的标签，所以对于 Kubernetes 来说两种容器的启动和执行也就只有顺序先后的不同。</p><h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>每一个 Pod 中的容器是可以通过 <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="external nofollow noopener noreferrer">卷（Volume）</a> 的方式共享文件目录的，这些 Volume 能够存储持久化的数据；在当前 Pod 出现故障或者滚动更新时，对应 Volume 中的数据并不会被清除，而是会在 Pod 重启后重新挂载到期望的文件目录中：</p><p><img alt="kubernetes-containers-share-volumes" data-src="https://img.draveness.me/2018-12-25-kubernetes-containers-share-volumes.png"></p><p>kubelet.go 文件中的私有方法 <code>syncPod</code> 会调用 <code>WaitForAttachAndMount</code> 方法为等待当前 Pod 启动需要的挂载文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *volumeManager)</span> <span class="title">WaitForAttachAndMount</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">expectedVolumes := getExpectedVolumes(pod)</span><br><span class="line">uniquePodName := util.GetUniquePodName(pod)</span><br><span class="line"></span><br><span class="line">vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)</span><br><span class="line"></span><br><span class="line">wait.PollImmediate(</span><br><span class="line">podAttachAndMountRetryInterval,</span><br><span class="line">podAttachAndMountTimeout,</span><br><span class="line">vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会在 <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="external nofollow noopener noreferrer">后面的章节</a> 详细地介绍 Kubernetes 中卷的创建、挂载是如何进行的，在这里我们需要知道的是卷的挂载是 Pod 启动之前必须要完成的工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncPod</span><span class="params">(o syncPodOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !kl.podIsTerminated(pod) &#123;</span><br><span class="line">kl.volumeManager.WaitForAttachAndMount(pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line">result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">kl.reasonCache.Update(pod.UID, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前 Pod 的卷创建完成之后，就会调用上一节中提到的 <code>SyncPod</code> 公有方法继续进行同步 Pod 信息和创建、启动容器的工作。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>同一个 Pod 中的多个容器会被共同分配到同一个 Host 上并且共享网络栈，也就是说这些 Pod 能够通过 localhost 互相访问到彼此的端口和服务，如果使用了相同的端口也会发生冲突，同一个 Pod 上的所有容器会连接到同一个网络设备上，这个网络设备就是由 Pod Sandbox 中的沙箱容器在 <code>RunPodSandbox</code> 方法中启动时创建的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span> <span class="title">RunPodSandbox</span><span class="params">(ctx context.Context, r *runtimeapi.RunPodSandboxRequest)</span> <span class="params">(*runtimeapi.RunPodSandboxResponse, error)</span></span> &#123;</span><br><span class="line">config := r.GetConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: Pull the image for the sandbox.</span></span><br><span class="line">image := defaultSandboxImage</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Create the sandbox container.</span></span><br><span class="line">createConfig, _ := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">createResp, _ := ds.client.CreateContainer(*createConfig)</span><br><span class="line"></span><br><span class="line">resp := &amp;runtimeapi.RunPodSandboxResponse&#123;PodSandboxId: createResp.ID&#125;</span><br><span class="line"></span><br><span class="line">ds.setNetworkReady(createResp.ID, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: Create Sandbox Checkpoint.</span></span><br><span class="line">ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">ds.client.StartContainer(createResp.ID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: Setup networking for the sandbox.</span></span><br><span class="line">cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)</span><br><span class="line">networkOptions := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沙箱容器其实就是 <code>pause</code> 容器，上述方法引用的 <code>defaultSandboxImage</code> 其实就是官方提供的 <code>k8s.gcr.io/pause:3.1</code> 镜像，这里会创建沙箱镜像和检查点并启动容器。</p><p><img alt="kubernetes-pod-network" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-network.png"></p><p>每一个节点上都会由 Kubernetes 的网络插件 Kubenet 创建一个基本的 <code>cbr0</code> 网桥并为每一个 Pod 创建 <code>veth</code> 虚拟网络设备，同一个 Pod 中的所有容器就会通过这个网络设备共享网络，也就是能够通过 localhost 互相访问彼此暴露的端口和服务。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Kubernetes 中的每一个 Pod 都包含多个容器，这些容器在通过 Kubernetes 创建之后就能共享网络和存储，这其实是 Pod 非常重要的特性，我们能通过这个特性构建比较复杂的服务拓扑和依赖关系。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>想要深入理解 Pod 的实现原理，最好最快的办法就是从 Pod 的生命周期入手，通过理解 Pod 创建、重启和删除的原理我们最终就能够系统地掌握 Pod 的生命周期与核心原理。</p><p><img alt="kubernetes-pod-lifecycle" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-lifecycle.png"></p><p>当 Pod 被创建之后，就会进入健康检查状态，当 Kubernetes 确定当前 Pod 已经能够接受外部的请求时，才会将流量打到新的 Pod 上并继续对外提供服务，在这期间如果发生了错误就可能会触发重启机制，在 Pod 被删除之前都会触发一个 <code>PreStop</code> 的钩子，其中的方法完成之后 Pod 才会被删除，接下来我们就会按照这里的顺序依次介绍 Pod 『从生到死』的过程。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Pod 的创建都是通过 <code>SyncPod</code> 来实现的，创建的过程大体上可以分为六个步骤：</p><ol><li>计算 Pod 中沙盒和容器的变更；</li><li>强制停止 Pod 对应的沙盒；</li><li>强制停止所有不应该运行的容器；</li><li>为 Pod 创建新的沙盒；</li><li>创建 Pod 规格中指定的初始化容器；</li><li>依次创建 Pod 规格中指定的常规容器；</li></ol><p>我们可以看到 Pod 的创建过程其实是比较简单的，首先计算 Pod 规格和沙箱的变更，然后停止可能影响这一次创建或者更新的容器，最后依次创建沙盒、初始化容器和常规容器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">ref, _ := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">m.purgeInitContainers(pod, podStatus)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">podSandboxID := podContainerChanges.SandboxID</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">podSandboxID, _, _ = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">&#125;</span><br><span class="line">podSandboxConfig, _ := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">container := &amp;pod.Spec.Containers[idx]</span><br><span class="line">msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后的 <code>SyncPod</code> 方法的脉络非常清晰，可以很好地理解整个创建 Pod 的工作流程；而初始化容器和常规容器被调用 <code>startContainer</code> 来启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">startContainer</span><span class="params">(podSandboxID <span class="keyword">string</span>, podSandboxConfig *runtimeapi.PodSandboxConfig, container *v1.Container, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, podIP <span class="keyword">string</span>, containerType kubecontainer.ContainerType)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">imageRef, _, _ := m.imagePuller.EnsureImageExists(pod, container, pullSecrets)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">containerID, _ := m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)</span><br><span class="line"></span><br><span class="line">m.internalLifecycle.PreStartContainer(pod, container, containerID)</span><br><span class="line"></span><br><span class="line">m.runtimeService.StartContainer(containerID)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> container.Lifecycle != <span class="literal">nil</span> &amp;&amp; container.Lifecycle.PostStart != <span class="literal">nil</span> &#123;</span><br><span class="line">kubeContainerID := kubecontainer.ContainerID&#123;</span><br><span class="line">Type: m.runtimeName,</span><br><span class="line">ID:   containerID,</span><br><span class="line">&#125;</span><br><span class="line">msg, _ := m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动每一个容器的过程中也都按照相同的步骤进行操作：</p><ol><li>通过镜像拉取器获得当前容器中使用镜像的引用；</li><li>调用远程的 <code>runtimeService</code> 创建容器；</li><li>调用内部的生命周期方法 <code>PreStartContainer</code> 为当前的容器设置分配的 CPU 等资源；</li><li>调用远程的 <code>runtimeService</code> 开始运行镜像；</li><li>如果当前的容器包含 <code>PostStart</code> 钩子就会执行该回调；</li></ol><p>每次 <code>SyncPod</code> 被调用时不一定是创建新的 Pod 对象，它还会承担更新、删除和同步 Pod 规格的职能，根据输入的新规格执行相应的操作。</p><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>如果我们遵循 Pod 的最佳实践，其实应该尽可能地为每一个 Pod 添加 <code>livenessProbe</code> 和 <code>readinessProbe</code> 的健康检查，这两者能够为 Kubernetes 提供额外的存活信息，如果我们配置了合适的健康检查方法和规则，那么就不会出现服务未启动就被打入流量或者长时间未响应依然没有重启等问题。</p><p>在 Pod 被创建或者被移除时，会被加入到当前节点上的 <code>ProbeManager</code> 中，<code>ProbeManager</code> 会负责这些 Pod 的健康检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">kl.podManager.AddPod(pod)</span><br><span class="line">kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">kl.probeManager.AddPod(pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodRemoves</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">kl.podManager.DeletePod(pod)</span><br><span class="line">kl.deletePod(pod)</span><br><span class="line">kl.probeManager.RemovePod(pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后的 <code>HandlePodAdditions</code> 和 <code>HandlePodRemoves</code> 方法非常直白，我们可以直接来看 <code>ProbeManager</code> 如何处理不同节点的健康检查。</p><p><img alt="kubernetes-probe-manager" data-src="https://img.draveness.me/2018-12-25-kubernetes-probe-manager.png"></p><p>每一个新的 Pod 都会被调用 <code>ProbeManager</code> 的<code>AddPod</code> 函数，这个方法会初始化一个新的 Goroutine 并在其中运行对当前 Pod 进行健康检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">key.containerName = c.Name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.ReadinessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">key.probeType = readiness</span><br><span class="line">w := newWorker(m, readiness, pod, c)</span><br><span class="line">m.workers[key] = w</span><br><span class="line"><span class="keyword">go</span> w.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.LivenessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">key.probeType = liveness</span><br><span class="line">w := newWorker(m, liveness, pod, c)</span><br><span class="line">m.workers[key] = w</span><br><span class="line"><span class="keyword">go</span> w.run()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行健康检查的过程中，Worker 只是负责根据当前 Pod 的状态定期触发一次 <code>Probe</code>，它会根据 Pod 的配置分别选择调用 <code>Exec</code>、<code>HTTPGet</code> 或 <code>TCPSocket</code> 三种不同的 <code>Probe</code> 方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbe</span><span class="params">(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">timeout := time.Duration(p.TimeoutSeconds) * time.Second</span><br><span class="line"><span class="keyword">if</span> p.Exec != <span class="literal">nil</span> &#123;</span><br><span class="line">command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)</span><br><span class="line"><span class="keyword">return</span> pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.HTTPGet != <span class="literal">nil</span> &#123;</span><br><span class="line">scheme := strings.ToLower(<span class="keyword">string</span>(p.HTTPGet.Scheme))</span><br><span class="line">host := p.HTTPGet.Host</span><br><span class="line">port, _ := extractPort(p.HTTPGet.Port, container)</span><br><span class="line">path := p.HTTPGet.Path</span><br><span class="line">url := formatURL(scheme, host, port, path)</span><br><span class="line">headers := buildHeader(p.HTTPGet.HTTPHeaders)</span><br><span class="line"><span class="keyword">if</span> probeType == liveness &#123;</span><br><span class="line"><span class="keyword">return</span> pb.livenessHttp.Probe(url, headers, timeout)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// readiness</span></span><br><span class="line"><span class="keyword">return</span> pb.readinessHttp.Probe(url, headers, timeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.TCPSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">port, _ := extractPort(p.TCPSocket.Port, container)</span><br><span class="line">host := p.TCPSocket.Host</span><br><span class="line"><span class="keyword">return</span> pb.tcp.Probe(host, port, timeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, fmt.Errorf(<span class="string">"Missing probe handler for %s:%s"</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kubernetes 在 Pod 启动后的 <code>InitialDelaySeconds</code> 时间内会等待 Pod 的启动和初始化，在这之后会开始健康检查，默认的健康检查重试次数是三次，如果健康检查正常运行返回了一个确定的结果，那么 Worker 就是记录这次的结果，在连续失败 <code>FailureThreshold</code> 次或者成功 <code>SuccessThreshold</code> 次，那么就会改变当前 Pod 的状态，这也是为了避免由于服务不稳定带来的抖动。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当 Kubelet 在 <code>HandlePodRemoves</code> 方法中接收到来自客户端的删除请求时，就会通过一个名为 <code>deletePod</code> 的私有方法中的 Channel 将这一事件传递给 PodKiller 进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">deletePod</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">kl.podWorkers.ForgetWorker(pod.UID)</span><br><span class="line"></span><br><span class="line">runningPods, _ := kl.runtimeCache.GetPods()</span><br><span class="line">runningPod := kubecontainer.Pods(runningPods).FindPod(<span class="string">""</span>, pod.UID)</span><br><span class="line">podPair := kubecontainer.PodPair&#123;APIPod: pod, RunningPod: &amp;runningPod&#125;</span><br><span class="line"></span><br><span class="line">kl.podKillingCh &lt;- &amp;podPair</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kubelet 除了将事件通知给 PodKiller 之外，还需要将当前 Pod 对应的 Worker 从持有的 <code>podWorkers</code> 中删除；PodKiller 其实就是 Kubelet 持有的一个 Goroutine，它会在后台持续运行并监听来自 <code>podKillingCh</code> 的事件：</p><p><img alt="kubernetes-pod-killer" data-src="https://img.draveness.me/2018-12-25-kubernetes-pod-killer.png"></p><p>经过一系列的方法调用之后，最终调用容器运行时的 <code>killContainersWithSyncResult</code> 方法，这个方法会同步地杀掉当前 Pod 中全部的容器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainersWithSyncResult</span><span class="params">(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="params">(syncResults []*kubecontainer.SyncResult)</span></span> &#123;</span><br><span class="line">containerResults := <span class="built_in">make</span>(<span class="keyword">chan</span> *kubecontainer.SyncResult, <span class="built_in">len</span>(runningPod.Containers))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> runningPod.Containers &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(container *kubecontainer.Container)</span></span> &#123;</span><br><span class="line">killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, container.Name)</span><br><span class="line">m.killContainer(pod, container.ID, container.Name, <span class="string">"Need to kill Pod"</span>, gracePeriodOverride)</span><br><span class="line">containerResults &lt;- killContainerResult</span><br><span class="line">&#125;(container)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(containerResults)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> containerResult := <span class="keyword">range</span> containerResults &#123;</span><br><span class="line">syncResults = <span class="built_in">append</span>(syncResults, containerResult)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个容器来说，它们在被停止之前都会先调用 <code>PreStop</code> 的钩子方法，让容器中的应用程序能够有时间完成一些未处理的操作，随后调用远程的服务停止运行的容器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainer</span><span class="params">(pod *v1.Pod, containerID kubecontainer.ContainerID, containerName <span class="keyword">string</span>, reason <span class="keyword">string</span>, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">containerSpec := kubecontainer.GetContainerSpec(pod, containerName);</span><br><span class="line"></span><br><span class="line">gracePeriod := <span class="keyword">int64</span>(minimumGracePeriodInSeconds)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> pod.DeletionGracePeriodSeconds != <span class="literal">nil</span>:</span><br><span class="line">gracePeriod = *pod.DeletionGracePeriodSeconds</span><br><span class="line"><span class="keyword">case</span> pod.Spec.TerminationGracePeriodSeconds != <span class="literal">nil</span>:</span><br><span class="line">gracePeriod = *pod.Spec.TerminationGracePeriodSeconds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.executePreStopHook(pod, containerID, containerSpec, gracePeriod)</span><br><span class="line">m.internalLifecycle.PreStopContainer(containerID.ID)</span><br><span class="line">m.runtimeService.StopContainer(containerID.ID, gracePeriod)</span><br><span class="line">m.containerRefManager.ClearRef(containerID)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个简化版本的 <code>killContainer</code> 方法中，我们可以大致看出停止运行容器的大致逻辑，先从 Pod 的规格中计算出当前停止所需要的时间，然后运行钩子方法和内部的生命周期方法，最后将容器停止并清除引用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们已经介绍了 Pod 中的几个重要概念 — 容器、卷和网络以及从创建到删除整个过程是如何实现的。</p><p>Kubernetes 中 Pod 的运行和管理总是与 kubelet 以及它的组件密不可分，后面的文章中也会介绍 kubelet 究竟是什么，它在整个 Kubernetes 中扮演什么样的角色。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Pod&lt;/code&gt; 是 Kubernetes 集群中能够被创建、调度和管理的最小部署单元，是一组容器的集合，是 k8s 中最简单的对象，也是 k8s 中最为基础的概念。同一个 Pod 中的容器可以共享同一个网络命名空间，IP地址和端口空间。从生命周期上来讲，Pod是短暂而不是长久的应用。Pod被调度到节点，保持在这个节点直到被摧毁。&lt;/p&gt;
&lt;p&gt;本文将分两个部分对 Pod 解读，第一个部分介绍 Pod 的基本概念和常见特性，第二部分会从源码层面介绍 Pod 从创建到删除的整个生命周期的实现。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-07-27_pod.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="pod" scheme="http://houmin.cc/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】Controller Manager</title>
    <link href="http://houmin.cc/posts/76a404e7/"/>
    <id>http://houmin.cc/posts/76a404e7/</id>
    <published>2020-08-11T12:46:45.000Z</published>
    <updated>2020-09-12T01:46:48.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Controller Manager</code>作为集群的管理控制中心，维护集群中的所有控制器，对维持集群的稳定和自我修复，实现高可用，副本控制等起关键作用。</p><a id="more"></a><h2 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h2><p><img alt="12039474-1e134c69dc68c410.png" data-src="https://www.pianshen.com/images/715/6480752a76065ff8de202236459f36bb.png"></p><h2 id="关键性调用链"><a href="#关键性调用链" class="headerlink" title="关键性调用链"></a>关键性调用链</h2><p><img alt="12039474-6d0b6a2aabc46a28.png" data-src="https://www.pianshen.com/images/592/394742076228162f618ca01a59ee1170.png"></p><h2 id="源码分析过程"><a href="#源码分析过程" class="headerlink" title="源码分析过程"></a>源码分析过程</h2><h3 id="组件启动的入口"><a href="#组件启动的入口" class="headerlink" title="组件启动的入口"></a>组件启动的入口</h3><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/controller-manager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">command := app.NewControllerManagerCommand()</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line"><span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line"><span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line"><span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">logs.InitLogs()</span><br><span class="line"><span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取配置文件，进行配置读取和初始化默认配置"><a href="#读取配置文件，进行配置读取和初始化默认配置" class="headerlink" title="读取配置文件，进行配置读取和初始化默认配置"></a>读取配置文件，进行配置读取和初始化默认配置</h3><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go -&gt;NewControllerManagerCommand</p><ul><li>初始化Controller-manager的配置选项结构:<strong>NewKubeControllerManagerOptions()</strong></li><li>创建执行命令结构包括Use,Long,和Run:<strong>cmd := &amp;cobra.Command{</strong></li><li>解析配置文件: <strong>s.AddFlags</strong><br>1.KnownControllers()获取所有controller<br>2.将配置文件中的配置选项注入到配置对象中<br>3.同时将controller需要的参数写入.</li></ul><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/app/controllermanager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerManagerCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerManagerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">s, err := options.NewKubeControllerManagerOptions()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"unable to initialize command options: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use: <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">Long: <span class="string">`The Kubernetes controller manager is a daemon that embeds</span></span><br><span class="line"><span class="string">the core control loops shipped with Kubernetes. In applications of robotics and</span></span><br><span class="line"><span class="string">automation, a control loop is a non-terminating loop that regulates the state of</span></span><br><span class="line"><span class="string">the system. In Kubernetes, a controller is a control loop that watches the shared</span></span><br><span class="line"><span class="string">state of the cluster through the apiserver and makes changes attempting to move the</span></span><br><span class="line"><span class="string">current state towards the desired state. Examples of controllers that ship with</span></span><br><span class="line"><span class="string">Kubernetes today are the replication controller, endpoints controller, namespace</span></span><br><span class="line"><span class="string">controller, and serviceaccounts controller.`</span>,</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line">utilflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs := cmd.Flags()</span><br><span class="line">namedFlagSets := s.Flags(KnownControllers(), ControllersDisabledByDefault.List())</span><br><span class="line">verflag.AddFlags(namedFlagSets.FlagSet(<span class="string">"global"</span>))</span><br><span class="line">globalflag.AddGlobalFlags(namedFlagSets.FlagSet(<span class="string">"global"</span>), cmd.Name())</span><br><span class="line">registerLegacyGlobalFlags(namedFlagSets)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> namedFlagSets.FlagSets &#123;</span><br><span class="line">fs.AddFlagSet(f)</span><br><span class="line">&#125;</span><br><span class="line">usageFmt := <span class="string">"Usage:\n  %s\n"</span></span><br><span class="line">cols, _, _ := term.TerminalSize(cmd.OutOrStdout())</span><br><span class="line">cmd.SetUsageFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Fprintf(cmd.OutOrStderr(), usageFmt, cmd.UseLine())</span><br><span class="line">cliflag.PrintSections(cmd.OutOrStderr(), namedFlagSets, cols)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">cmd.SetHelpFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(cmd.OutOrStdout(), <span class="string">"%s\n\n"</span>+usageFmt, cmd.Long, cmd.UseLine())</span><br><span class="line">cliflag.PrintSections(cmd.OutOrStdout(), namedFlagSets, cols)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件启动执行"><a href="#组件启动执行" class="headerlink" title="组件启动执行"></a>组件启动执行</h3><p>从main中的command.Execute()到4.2中构造的Run<br><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>//加载所有控制器，并将对应参数注入到控制器中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())</span><br></pre></td></tr></table></figure><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>KnownControllers()中的NewControllerInitializers初始化所有的控制器</p><figure class="highlight go"><figcaption><span>cmd/kube-controller-manager/app/controllermanager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">controllers[<span class="string">"endpoint"</span>] = startEndpointController</span><br><span class="line">controllers[<span class="string">"endpointslice"</span>] = startEndpointSliceController</span><br><span class="line">controllers[<span class="string">"replicationcontroller"</span>] = startReplicationController</span><br><span class="line">controllers[<span class="string">"podgc"</span>] = startPodGCController</span><br><span class="line">controllers[<span class="string">"resourcequota"</span>] = startResourceQuotaController</span><br><span class="line">controllers[<span class="string">"namespace"</span>] = startNamespaceController</span><br><span class="line">controllers[<span class="string">"serviceaccount"</span>] = startServiceAccountController</span><br><span class="line">controllers[<span class="string">"garbagecollector"</span>] = startGarbageCollectorController</span><br><span class="line">controllers[<span class="string">"daemonset"</span>] = startDaemonSetController</span><br><span class="line">controllers[<span class="string">"job"</span>] = startJobController</span><br><span class="line">controllers[<span class="string">"deployment"</span>] = startDeploymentController</span><br><span class="line">controllers[<span class="string">"replicaset"</span>] = startReplicaSetController</span><br><span class="line">controllers[<span class="string">"horizontalpodautoscaling"</span>] = startHPAController</span><br><span class="line">controllers[<span class="string">"disruption"</span>] = startDisruptionController</span><br><span class="line">controllers[<span class="string">"statefulset"</span>] = startStatefulSetController</span><br><span class="line">controllers[<span class="string">"cronjob"</span>] = startCronJobController</span><br><span class="line">controllers[<span class="string">"csrsigning"</span>] = startCSRSigningController</span><br><span class="line">controllers[<span class="string">"csrapproving"</span>] = startCSRApprovingController</span><br><span class="line">controllers[<span class="string">"csrcleaner"</span>] = startCSRCleanerController</span><br><span class="line">controllers[<span class="string">"ttl"</span>] = startTTLController</span><br><span class="line">controllers[<span class="string">"bootstrapsigner"</span>] = startBootstrapSignerController</span><br><span class="line">controllers[<span class="string">"tokencleaner"</span>] = startTokenCleanerController</span><br><span class="line">controllers[<span class="string">"nodeipam"</span>] = startNodeIpamController</span><br><span class="line">controllers[<span class="string">"nodelifecycle"</span>] = startNodeLifecycleController</span><br><span class="line"><span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">controllers[<span class="string">"service"</span>] = startServiceController</span><br><span class="line">controllers[<span class="string">"route"</span>] = startRouteController</span><br><span class="line">controllers[<span class="string">"cloud-node-lifecycle"</span>] = startCloudNodeLifecycleController</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">&#125;</span><br><span class="line">controllers[<span class="string">"persistentvolume-binder"</span>] = startPersistentVolumeBinderController</span><br><span class="line">controllers[<span class="string">"attachdetach"</span>] = startAttachDetachController</span><br><span class="line">controllers[<span class="string">"persistentvolume-expander"</span>] = startVolumeExpandController</span><br><span class="line">controllers[<span class="string">"clusterrole-aggregation"</span>] = startClusterRoleAggregrationController</span><br><span class="line">controllers[<span class="string">"pvc-protection"</span>] = startPVCProtectionController</span><br><span class="line">controllers[<span class="string">"pv-protection"</span>] = startPVProtectionController</span><br><span class="line">controllers[<span class="string">"ttl-after-finished"</span>] = startTTLAfterFinishedController</span><br><span class="line">controllers[<span class="string">"root-ca-cert-publisher"</span>] = startRootCACertPublisher</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>真正进入执行</p><ul><li>启动controller-manager的http服务和对应处理器，包括安全和非安全：<strong>BuildHandlerChain</strong></li><li>构造run的执行体</li><li>需要选主的情况，选主完执行run;不需要选主的直接执行run，然后panic</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(<span class="built_in">c</span> *config.CompletedConfig)</span></span> error &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// To help debugging, immediately log version</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glog.<span class="type">Infof</span>(<span class="string">"Version: %+v"</span>, version.<span class="type">Get</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cfgz, err := configz.<span class="type">New</span>(<span class="string">"componentconfig"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cfgz.<span class="type">Set</span>(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        glog.<span class="type">Errorf</span>(<span class="string">"unable to register configz: %c"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the controller manager HTTP server</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stopCh := make(chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">SecureServing</span> != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler := genericcontrollermanager.<span class="type">NewBaseHandler</span>(&amp;<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">Debugging</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler = genericcontrollermanager.<span class="type">BuildHandlerChain</span>(handler, &amp;<span class="built_in">c</span>.<span class="type">Authorization</span>, &amp;<span class="built_in">c</span>.<span class="type">Authentication</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">c</span>.<span class="type">SecureServing</span>.<span class="type">Serve</span>(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">InsecureServing</span> != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler := genericcontrollermanager.<span class="type">NewBaseHandler</span>(&amp;<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">Debugging</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        handler = genericcontrollermanager.<span class="type">BuildHandlerChain</span>(handler, &amp;<span class="built_in">c</span>.<span class="type">Authorization</span>, &amp;<span class="built_in">c</span>.<span class="type">Authentication</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">c</span>.<span class="type">InsecureServing</span>.<span class="type">Serve</span>(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-chan <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rootClientBuilder := controller.<span class="type">SimpleControllerClientBuilder</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">ClientConfig</span>: <span class="built_in">c</span>.<span class="type">Kubeconfig</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> clientBuilder controller.<span class="type">ControllerClientBuilder</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">KubeCloudShared</span>.<span class="type">UseServiceAccountCredentials</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">SAController</span>.<span class="type">ServiceAccountKeyFile</span>) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// It'c possible another controller process is creating the tokens for us.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If one isn't, we'll timeout and exit when our client builder is unable to create the tokens.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                glog.<span class="type">Warningf</span>(<span class="string">"--use-service-account-credentials was specified without providing a --service-account-private-key-file"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            clientBuilder = controller.<span class="type">SAControllerClientBuilder</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">ClientConfig</span>:         restclient.<span class="type">AnonymousClientConfig</span>(<span class="built_in">c</span>.<span class="type">Kubeconfig</span>),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">CoreClient</span>:           <span class="built_in">c</span>.<span class="type">Client</span>.<span class="type">CoreV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">AuthenticationClient</span>: <span class="built_in">c</span>.<span class="type">Client</span>.<span class="type">AuthenticationV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">Namespace</span>:            <span class="string">"kube-system"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            clientBuilder = rootClientBuilder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx, err := <span class="type">CreateControllerContext</span>(<span class="built_in">c</span>, rootClientBuilder, clientBuilder, stop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            glog.<span class="type">Fatalf</span>(<span class="string">"error building controller context: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动控制器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := <span class="type">StartControllers</span>(ctx, saTokenControllerInitFunc, <span class="type">NewControllerInitializers</span>(ctx.<span class="type">LoopMode</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            glog.<span class="type">Fatalf</span>(<span class="string">"error starting controllers: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ctx.<span class="type">InformerFactory</span>.<span class="type">Start</span>(ctx.<span class="type">Stop</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        close(ctx.<span class="type">InformersStarted</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        select &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//note 如果未启用选主（只是单节点），直接启动，并且panic，不在往下走，因为run内部有select挂起</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">LeaderElect</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        run(wait.<span class="type">NeverStop</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panic(<span class="string">"unreachable"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id, err := os.<span class="type">Hostname</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a uniquifier so that two processes on the same host don't accidentally both become active</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成唯一ID,相当于进程锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    id = id + <span class="string">"_"</span> + string(uuid.<span class="type">NewUUID</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rl, err := resourcelock.<span class="type">New</span>(<span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">ResourceLock</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">"kube-system"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">"kube-controller-manager"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">c</span>.<span class="type">LeaderElectionClient</span>.<span class="type">CoreV1</span>(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        resourcelock.<span class="type">ResourceLockConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Identity</span>:      id,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">EventRecorder</span>: <span class="built_in">c</span>.<span class="type">EventRecorder</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        glog.<span class="type">Fatalf</span>(<span class="string">"error creating lock: %v"</span>, err)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行选主，并在选为主节点后执行run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    leaderelection.<span class="type">RunOrDie</span>(leaderelection.<span class="type">LeaderElectionConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Lock</span>:          rl,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">LeaseDuration</span>: <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">LeaseDuration</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">RenewDeadline</span>: <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">RenewDeadline</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">RetryPeriod</span>:   <span class="built_in">c</span>.<span class="type">ComponentConfig</span>.<span class="type">GenericComponent</span>.<span class="type">LeaderElection</span>.<span class="type">RetryPeriod</span>.<span class="type">Duration</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Callbacks</span>: leaderelection.<span class="type">LeaderCallbacks</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选主完成后执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">OnStartedLeading</span>: run,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">OnStoppedLeading</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                glog.<span class="type">Fatalf</span>(<span class="string">"leaderelection lost"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    panic(<span class="string">"unreachable"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转到run内部核心的三个动作</strong> ：CreateControllerContext 、 StartControllers和ctx.InformerFactory.Start</p><h4 id="CreateControllerContext"><a href="#CreateControllerContext" class="headerlink" title="CreateControllerContext"></a>CreateControllerContext</h4><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go</p><ul><li>拿到对kube-APIserver中资源的操作句柄</li><li>确认Kube-APIServer的健康（最多等待10s），然后拿获取连接</li><li>创建控制器上下文</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateControllerContext creates a context struct containing references to resources needed by the</span></span><br><span class="line"><span class="comment">// controllers such as the cloud provider and clientBuilder. rootClientBuilder is only used for</span></span><br><span class="line"><span class="comment">// the shared-informers client and token controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateControllerContext</span><span class="params">(s *config.CompletedConfig, rootClientBuilder, clientBuilder controller.ControllerClientBuilder, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(ControllerContext, error)</span></span> &#123;</span><br><span class="line">versionedClient := rootClientBuilder.ClientOrDie(<span class="string">"shared-informers"</span>)</span><br><span class="line">sharedInformers := informers.NewSharedInformerFactory(versionedClient, ResyncPeriod(s)())</span><br><span class="line"></span><br><span class="line">metadataClient := metadata.NewForConfigOrDie(rootClientBuilder.ConfigOrDie(<span class="string">"metadata-informers"</span>))</span><br><span class="line">metadataInformers := metadatainformer.NewSharedInformerFactory(metadataClient, ResyncPeriod(s)())</span><br><span class="line"></span><br><span class="line"><span class="comment">// If apiserver is not running we should wait for some time and fail only then. This is particularly</span></span><br><span class="line"><span class="comment">// important when we start apiserver and controller manager at the same time.</span></span><br><span class="line"><span class="keyword">if</span> err := genericcontrollermanager.WaitForAPIServer(versionedClient, <span class="number">10</span>*time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ControllerContext&#123;&#125;, fmt.Errorf(<span class="string">"failed to wait for apiserver being healthy: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a discovery client capable of being refreshed.</span></span><br><span class="line">discoveryClient := rootClientBuilder.ClientOrDie(<span class="string">"controller-discovery"</span>)</span><br><span class="line">cachedClient := cacheddiscovery.NewMemCacheClient(discoveryClient.Discovery())</span><br><span class="line">restMapper := restmapper.NewDeferredDiscoveryRESTMapper(cachedClient)</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">restMapper.Reset()</span><br><span class="line">&#125;, <span class="number">30</span>*time.Second, stop)</span><br><span class="line"></span><br><span class="line">availableResources, err := GetAvailableResources(rootClientBuilder)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ControllerContext&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cloud, loopMode, err := createCloudProvider(s.ComponentConfig.KubeCloudShared.CloudProvider.Name, s.ComponentConfig.KubeCloudShared.ExternalCloudVolumePlugin,</span><br><span class="line">s.ComponentConfig.KubeCloudShared.CloudProvider.CloudConfigFile, s.ComponentConfig.KubeCloudShared.AllowUntaggedCloud, sharedInformers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ControllerContext&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx := ControllerContext&#123;</span><br><span class="line">ClientBuilder:                   clientBuilder,</span><br><span class="line">InformerFactory:                 sharedInformers,</span><br><span class="line">ObjectOrMetadataInformerFactory: controller.NewInformerFactory(sharedInformers, metadataInformers),</span><br><span class="line">ComponentConfig:                 s.ComponentConfig,</span><br><span class="line">RESTMapper:                      restMapper,</span><br><span class="line">AvailableResources:              availableResources,</span><br><span class="line">Cloud:                           cloud,</span><br><span class="line">LoopMode:                        loopMode,</span><br><span class="line">Stop:                            stop,</span><br><span class="line">InformersStarted:                <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">ResyncPeriod:                    ResyncPeriod(s),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StartControllers"><a href="#StartControllers" class="headerlink" title="StartControllers"></a>StartControllers</h4><p><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go<br>启动初始化的所有控制器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Always start the SA token controller first using a full-power client, since it needs to mint tokens for the rest</span></span><br><span class="line"><span class="comment">// If this fails, just return here and fail since other controllers won't be able to get credentials.</span></span><br><span class="line"><span class="keyword">if</span> _, _, err := startSATokenController(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the cloud provider with a reference to the clientBuilder only after token controller</span></span><br><span class="line"><span class="comment">// has started in case the cloud provider uses the client builder.</span></span><br><span class="line"><span class="keyword">if</span> ctx.Cloud != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.Cloud.Initialize(ctx.ClientBuilder, ctx.Stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line"><span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">klog.Warningf(<span class="string">"%q is disabled"</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">1</span>).Infof(<span class="string">"Starting %q"</span>, controllerName)</span><br><span class="line">debugHandler, started, err := initFn(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Error starting %q"</span>, controllerName)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !started &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Skipping %q"</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">basePath := <span class="string">"/debug/controllers/"</span> + controllerName</span><br><span class="line">unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">"/"</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">"Started %q"</span>, controllerName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ctx-InformerFactory-Start"><a href="#ctx-InformerFactory-Start" class="headerlink" title="ctx.InformerFactory.Start"></a>ctx.InformerFactory.Start</h4><p>controller-manager中的informer开始启动监听资源的事件，将事件放到自己的队列中（具有限流特性）。处理进程从队列总获取事件开始进行任务处理。</p><blockquote><p>将新建的ReplicaSet，放入队列</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj could be an *apps.ReplicaSet, or a DeletionFinalStateUnknown marker item.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">enqueueReplicaSet</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    key, err := controller.KeyFunc(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't get key for object %+v: %v"</span>, obj, err))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rsc.queue.Add(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从队列中获取对象进行处理（具体过程见下方）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    key, quit := rsc.queue.Get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    err := rsc.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        rsc.queue.Forget(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"Sync %q failed with %v"</span>, key, err))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rsc.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以startReplicaSetController为例"><a href="#以startReplicaSetController为例" class="headerlink" title="以startReplicaSetController为例"></a>以startReplicaSetController为例</h2><p>在StartControllers中initFn方法是NewControllerInitializers中初始化Controller是定义，以下主要看下startReplicaSetController。<br><strong>位置：</strong> k8s.io/kubernetes/cmd/kube-controller-manager/app/apps.go<br>其中NewReplicaSetController主要是初始化ReplicaSetController的结构，包括apiserver的客户端，informer的回调函数等等。NewReplicaSetController-&gt;NewBaseController</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReplicaSetController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: <span class="string">"apps"</span>, Version: <span class="string">"v1"</span>, Resource: <span class="string">"replicasets"</span>&#125;] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> replicaset.NewReplicaSetController(</span><br><span class="line">ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">ctx.ClientBuilder.ClientOrDie(<span class="string">"replicaset-controller"</span>),</span><br><span class="line">replicaset.BurstReplicas,</span><br><span class="line">).Run(<span class="keyword">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键函数run：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go<br>run中执行rsc.worker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run begins watching and syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> rsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">controllerName := strings.ToLower(rsc.Kind)</span><br><span class="line">klog.Infof(<span class="string">"Starting %v controller"</span>, controllerName)</span><br><span class="line"><span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down %v controller"</span>, controllerName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rsc.worker即为rsc.syncHandler，而syncHandler在创建时来源于rsc.syncReplicaSet（见NewBaseController方法）<br><strong>那么我们转到syncReplicaSet</strong><br><strong>位置：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go<br><strong>updateReplicaSetStatus：</strong>在pod死亡或者新建时更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncReplicaSet will sync the ReplicaSet with the given key if it has had its expectations fulfilled,</span></span><br><span class="line"><span class="comment">// meaning it did not expect to see any more of its pods created or deleted. This function is not meant to be</span></span><br><span class="line"><span class="comment">// invoked concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing %v %q (%v)"</span>, rsc.Kind, key, time.Since(startTime))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"%v %v has been deleted"</span>, rsc.Kind, key)</span><br><span class="line">rsc.expectations.DeleteExpectations(key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting pod selector to selector: %v"</span>, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list all pods to include the pods that don't match the rs`s selector</span></span><br><span class="line"><span class="comment">// anymore but has the stale controller ref.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Do the List and Filter in a single pass, or use an index.</span></span><br><span class="line">allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ignore inactive pods.</span></span><br><span class="line">filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> filteredPods are pointing to objects from cache - if you need to</span></span><br><span class="line"><span class="comment">// modify them, you need to copy it first.</span></span><br><span class="line">filteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manageReplicasErr error</span><br><span class="line"><span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">manageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class="line">&#125;</span><br><span class="line">rs = rs.DeepCopy()</span><br><span class="line">newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always updates status as pods come up or die.</span></span><br><span class="line">updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Multiple things could lead to this update failing. Requeuing the replica set ensures</span></span><br><span class="line"><span class="comment">// Returning an error causes a requeue without forcing a hotloop</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Resync the ReplicaSet after MinReadySeconds as a last line of defense to guard against clock-skew.</span></span><br><span class="line"><span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转到updateReplicaSetStatus：</strong>k8s.io/kubernetes/pkg/controller/replicaset/replica_set_utils.go<br>调用UpdateStatus，通过apiserver更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updateReplicaSetStatus attempts to update the Status.Replicas of the given ReplicaSet, with a single GET/PUT retry.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateReplicaSetStatus</span><span class="params">(c appsclient.ReplicaSetInterface, rs *apps.ReplicaSet, newStatus apps.ReplicaSetStatus)</span> <span class="params">(*apps.ReplicaSet, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// This is the steady state. It happens when the ReplicaSet doesn't have any expectations, since</span></span><br><span class="line"><span class="comment">// we do a periodic relist every 30s. If the generations differ but the replicas are</span></span><br><span class="line"><span class="comment">// the same, a caller might've resized to the same replica count.</span></span><br><span class="line"><span class="keyword">if</span> rs.Status.Replicas == newStatus.Replicas &amp;&amp;</span><br><span class="line">rs.Status.FullyLabeledReplicas == newStatus.FullyLabeledReplicas &amp;&amp;</span><br><span class="line">rs.Status.ReadyReplicas == newStatus.ReadyReplicas &amp;&amp;</span><br><span class="line">rs.Status.AvailableReplicas == newStatus.AvailableReplicas &amp;&amp;</span><br><span class="line">rs.Generation == rs.Status.ObservedGeneration &amp;&amp;</span><br><span class="line">reflect.DeepEqual(rs.Status.Conditions, newStatus.Conditions) &#123;</span><br><span class="line"><span class="keyword">return</span> rs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the generation number we acted on, otherwise we might wrongfully indicate</span></span><br><span class="line"><span class="comment">// that we've seen a spec update when we retry.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This can clobber an update if we allow multiple agents to write to the</span></span><br><span class="line"><span class="comment">// same status.</span></span><br><span class="line">newStatus.ObservedGeneration = rs.Generation</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getErr, updateErr error</span><br><span class="line"><span class="keyword">var</span> updatedRS *apps.ReplicaSet</span><br><span class="line"><span class="keyword">for</span> i, rs := <span class="number">0</span>, rs; ; i++ &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(fmt.Sprintf(<span class="string">"Updating status for %v: %s/%s, "</span>, rs.Kind, rs.Namespace, rs.Name) +</span><br><span class="line">fmt.Sprintf(<span class="string">"replicas %d-&gt;%d (need %d), "</span>, rs.Status.Replicas, newStatus.Replicas, *(rs.Spec.Replicas)) +</span><br><span class="line">fmt.Sprintf(<span class="string">"fullyLabeledReplicas %d-&gt;%d, "</span>, rs.Status.FullyLabeledReplicas, newStatus.FullyLabeledReplicas) +</span><br><span class="line">fmt.Sprintf(<span class="string">"readyReplicas %d-&gt;%d, "</span>, rs.Status.ReadyReplicas, newStatus.ReadyReplicas) +</span><br><span class="line">fmt.Sprintf(<span class="string">"availableReplicas %d-&gt;%d, "</span>, rs.Status.AvailableReplicas, newStatus.AvailableReplicas) +</span><br><span class="line">fmt.Sprintf(<span class="string">"sequence No: %v-&gt;%v"</span>, rs.Status.ObservedGeneration, newStatus.ObservedGeneration))</span><br><span class="line"></span><br><span class="line">rs.Status = newStatus</span><br><span class="line">updatedRS, updateErr = c.UpdateStatus(context.TODO(), rs, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> updateErr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> updatedRS, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Stop retrying if we exceed statusUpdateRetries - the replicaSet will be requeued with a rate limit.</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= statusUpdateRetries &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Update the ReplicaSet with the latest resource version for the next poll</span></span><br><span class="line"><span class="keyword">if</span> rs, getErr = c.Get(context.TODO(), rs.Name, metav1.GetOptions&#123;&#125;); getErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If the GET fails we can't trust status.Replicas anymore. This error</span></span><br><span class="line"><span class="comment">// is bound to be more interesting than the update failure.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, getErr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, updateErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PodGCController"><a href="#PodGCController" class="headerlink" title="PodGCController"></a>PodGCController</h2><blockquote><p>1.gc掉超过阈值限制的pod，按时间排序gc</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcTerminated</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">terminatedPods := []*v1.Pod&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> isPodTerminated(pod) &#123;</span><br><span class="line">terminatedPods = <span class="built_in">append</span>(terminatedPods, pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">terminatedPodCount := <span class="built_in">len</span>(terminatedPods)</span><br><span class="line">deleteCount := terminatedPodCount - gcc.terminatedPodThreshold</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> deleteCount &gt; terminatedPodCount &#123;</span><br><span class="line">deleteCount = terminatedPodCount</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> deleteCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.Infof(<span class="string">"garbage collecting %v pods"</span>, deleteCount)</span><br><span class="line"><span class="comment">// sort only when necessary</span></span><br><span class="line">sort.Sort(byCreationTimestamp(terminatedPods))</span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deleteCount; i++ &#123;</span><br><span class="line">wait.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(namespace <span class="keyword">string</span>, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wait.Done()</span><br><span class="line"><span class="keyword">if</span> err := gcc.deletePod(namespace, name); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// ignore not founds</span></span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleError(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(terminatedPods[i].Namespace, terminatedPods[i].Name)</span><br><span class="line">&#125;</span><br><span class="line">wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.gc掉孤儿pod：pod上的node信息不在当前可调度的节点上，即没有和有效node绑定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcOrphaned deletes pods that are bound to nodes that don't exist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcOrphaned</span><span class="params">(pods []*v1.Pod, nodes []*v1.Node)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing orphaned"</span>)</span><br><span class="line">existingNodeNames := sets.NewString()</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">existingNodeNames.Insert(node.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add newly found unknown nodes to quarantine</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> pod.Spec.NodeName != <span class="string">""</span> &amp;&amp; !existingNodeNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line">gcc.nodeQueue.AddAfter(pod.Spec.NodeName, quarantineTime)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check if nodes are still missing after quarantine period</span></span><br><span class="line">deletedNodesNames, quit := gcc.discoverDeletedNodes(existingNodeNames)</span><br><span class="line"><span class="keyword">if</span> quit &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Delete orphaned pods</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> !deletedNodesNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Found orphaned Pod %v/%v assigned to the Node %v. Deleting."</span>, pod.Namespace, pod.Name, pod.Spec.NodeName)</span><br><span class="line"><span class="keyword">if</span> err := gcc.deletePod(pod.Namespace, pod.Name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">0</span>).Infof(<span class="string">"Forced deletion of orphaned Pod %v/%v succeeded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.gc掉没有调度成功的pod：表现在pod的NodeName为空,主要由于资源等条件不满足</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcUnscheduledTerminating deletes pods that are terminating and haven't been scheduled to a particular node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcUnscheduledTerminating</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing unscheduled pods which are terminating."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> pod.DeletionTimestamp == <span class="literal">nil</span> || <span class="built_in">len</span>(pod.Spec.NodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"Found unscheduled terminating Pod %v/%v not assigned to any Node. Deleting."</span>, pod.Namespace, pod.Name)</span><br><span class="line"><span class="keyword">if</span> err := gcc.deletePod(pod.Namespace, pod.Name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">0</span>).Infof(<span class="string">"Forced deletion of unscheduled terminating Pod %v/%v succeeded"</span>, pod.Namespace, pod.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// byCreationTimestamp sorts a list by creation timestamp, using their names as a tie breaker.</span></span><br><span class="line"><span class="keyword">type</span> byCreationTimestamp []*v1.Pod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(o) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; o[i], o[j] = o[j], o[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byCreationTimestamp)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> o[i].CreationTimestamp.Equal(&amp;o[j].CreationTimestamp) &#123;</span><br><span class="line"><span class="keyword">return</span> o[i].Name &lt; o[j].Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o[i].CreationTimestamp.Before(&amp;o[j].CreationTimestamp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Controller Manager&lt;/code&gt;作为集群的管理控制中心，维护集群中的所有控制器，对维持集群的稳定和自我修复，实现高可用，副本控制等起关键作用。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="controller" scheme="http://houmin.cc/tags/controller/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】ApiServer之初识API</title>
    <link href="http://houmin.cc/posts/3bc1a603/"/>
    <id>http://houmin.cc/posts/3bc1a603/</id>
    <published>2020-08-10T12:46:14.000Z</published>
    <updated>2020-09-12T01:46:57.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>ApiServer</code>作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。</p><p>kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：</p><ul><li>提供 <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes API</a>，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用</li><li>代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；</li><li>允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd</li><li>资源在不同版本之间的转换</li></ul><a id="more"></a><h2 id="API-Overview"><a href="#API-Overview" class="headerlink" title="API Overview"></a>API Overview</h2><p>ApiServer 主要通过对外提供HTTP API 的方式与其他组件进行交互。API首选的序列化方案是JSON，但是也支持Protobuf协议。API主要有下面三种类型：</p><ul><li>core group：主要在 <code>/api/v1</code> 下；</li><li>named groups：其 path 为 <code>/apis/$NAME/$VERSION</code>；</li><li>暴露系统状态的一些 API：如<code>/metrics</code> 、<code>/healthz</code> 等；</li></ul><p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-space-1.png"></p><h3 id="GVK-GVR"><a href="#GVK-GVR" class="headerlink" title="GVK/GVR"></a>GVK/GVR</h3><p><img alt="Terminology" data-src="https://www.openshift.com/hs-fs/hubfs/Imported_Blog_Media/API-server-gvr.png?width=400&amp;height=152&amp;name=API-server-gvr.png"></p><p>在Kubernetes中，要想定位一个对象，我们需要指定GVK或者GVR。比如这里声明了 apiVersion 是 <code>apps/v1</code>，其实就是隐含了 <code>Group</code> 是 apps，<code>Version</code> 是 v1，<code>Kind</code> 就是定义的 DaemonSet，而 kubectl 接收到这个声明之后，就可以根据这个声明去调用 API Server 对应的 URL 去获取信息，例如这个就是 <code>/api/apps/v1/daemonset</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-exporter</span></span><br></pre></td></tr></table></figure><p>对应到实际的URI的请求组织形式，如下图所示：</p><p><img alt="GVR" data-src="http://images.liuliqiang.info/2019/11/24/02/25/56/d14b874da710/"></p><p>通过结构体字段可以发现，它们其实就是Group、Version、Kind、Resource的不同组合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Kind    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">Group    <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">Resource <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">Group <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Kind  <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><p>Kubernetes中的每个对象都有一个字段 <code>Kind</code> 表明其类型，以Pod为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><code>Kubernetes</code> 中 Kind 有三种类型：</p><ul><li>系统中持久的实体对象，比如 <code>Pod</code> , <code>Namespace</code></li><li>一系列有某些共同特征的实体列表，比如 <code>PodLists</code>，<code>NodeLists</code></li><li>用于某些特定应用的一些非持久的实体，比如 <code>APIGroup</code>，<code>APIResource</code>, <code>Status</code></li></ul><p>Kind就是一个资源对象对应的种类 kind是通过<code>Kind=reflector.TypeOf(&amp;Pod{}).Elem().Name()</code>进行取值，取得的就是Pod这个结构体的名字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> PodList <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> NodeList <span class="keyword">struct</span></span><br></pre></td></tr></table></figure><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p><code>API Group</code> 是一些有关系的Kinds的集合，比如所有的批处理对象，<code>Job</code> 或者 <code>ScheduledJob</code> 都在 <code>batch</code>这个API Group。</p><p>各个Group是相互独立的，发展速度也不同，所有每个Group都会有不同的Version，而kubernetes是通过插件的方式来使用各个Group的，可以根据需求决定使用哪个Group。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Group="core"</span></span><br><span class="line"><span class="string">Version=v1</span></span><br><span class="line"></span><br><span class="line"><span class="string">Group="apps"</span></span><br><span class="line"><span class="string">Version=v1beta1</span></span><br></pre></td></tr></table></figure><p><code>GroupMeta</code>主要包括Group的元信息，里面的成员RESTMapper，与APIGroupVersion一样，其实APIGroupVersion的RESTMapper直接取值于GroupMeta的RESTMapper。一个Group可能包含多个版本，存储在 GroupVersions 中，而 GroupVersion 是默认存储在etcd中的版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupMeta <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// GroupVersion represents the preferred version of the group.</span></span><br><span class="line"><span class="comment">// 该group的默认版本</span></span><br><span class="line">GroupVersion unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupVersions is Group + all versions in that group.</span></span><br><span class="line"><span class="comment">// 该Group中可能会有多个版本，该字段就包含了所有的versions</span></span><br><span class="line">GroupVersions []unversioned.GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// Codec is the default codec for serializing output that should use</span></span><br><span class="line"><span class="comment">// the preferred version.  Use this Codec when writing to</span></span><br><span class="line"><span class="comment">// disk, a data store that is not dynamically versioned, or in tests.</span></span><br><span class="line"><span class="comment">// This codec can decode any object that the schema is aware of.</span></span><br><span class="line"><span class="comment">// 用于编解码</span></span><br><span class="line">Codec runtime.Codec</span><br><span class="line"></span><br><span class="line"><span class="comment">// SelfLinker can set or get the SelfLink field of all API types.</span></span><br><span class="line"><span class="comment">// to go through the InterfacesFor method below.</span></span><br><span class="line">SelfLinker runtime.SelfLinker</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known</span></span><br><span class="line"><span class="comment">// versions.</span></span><br><span class="line"><span class="comment">// RESTMapper提供 REST路径 与 那些在api.Scheme和所有已知版本中声明的对象之间的默认映射。用于类型，对象之间的转换</span></span><br><span class="line"></span><br><span class="line">RESTMapper meta.RESTMapper</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesFor returns the default Codec and ResourceVersioner for a given version</span></span><br><span class="line"><span class="comment">// string, or an error if the version is not known.</span></span><br><span class="line"><span class="comment">// function provided below once every place that populates this field has been changed.</span></span><br><span class="line">InterfacesFor <span class="function"><span class="keyword">func</span><span class="params">(version unversioned.GroupVersion)</span> <span class="params">(*meta.VersionInterfaces, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InterfacesByVersion stores the per-version interfaces.</span></span><br><span class="line">InterfacesByVersion <span class="keyword">map</span>[unversioned.GroupVersion]*meta.VersionInterfaces</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>每个 API Group 下面都能存在有多个 version 版本。为了扩展性，Kubernetes支持多版本的API路径，比如 <code>/api/v1</code> 或者 <code>/apis/extensions/v1beta1/</code>， 不同版本的API意味着不同程度的稳定性和支持度。比如在一个 group 群组中最早有第一个 v1alpha1 版本，后来中间发展到了 v1beta1 版本，最终发展到 v1 的稳定版本。 如果在系统创建了一个 v1beta1 版本的对象，那么它能过被 Group 任一支持的版本（ 比如v1 ）检索到， 这是由于 API server 能够支持不同版本对象之间的无损耗转换。</p><p><strong>type GroupVersion struct</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">Group   <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=group"`</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GroupVersion</code>中就是两个string类型，<code>Group</code>和<code>Version</code>，分别对应了api所处的分组和版本，这也是kubernetes实现多版本的基础。</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Resource 代表以 JSON 格式通过 HTTP 发送或检索的资源实体。 它既可以使一个单独的resource资源（比如…/namespaces/default，也可以是一组resource 资源（比如…/jobs）。 这里说明一下 Reource 和 Kind 的区别： 其实基本上都是一个概念，只是 Kind 表示一个种类，在实际中它是首字母大写的； Resource 表示资源，在实际中它是全部小写的，并且有单数和复数之分。我们可以把Kind和Resource的关系理解成面向对象编程中类与对象的关系，Kind 其实就是一个类，用于描述对象的；而 Resource 就是具体的 Kind，可以理解成类已经实例化成对象。</p><p>Resource就是指定了一个名字和kind的资源对象，不管它有没有namespace。 resource是通过<code>plural, singular := KindToResource(kind)</code>取值，singular是将Kind转换为小写字母，而plural是变为复数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// name is the name of the resource.</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"><span class="comment">// namespaced indicates if a resource is namespaced or not.</span></span><br><span class="line">Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line"><span class="comment">// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')</span></span><br><span class="line">Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reousrce := unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"nodes"</span>, </span><br><span class="line">Namespaced: <span class="literal">false</span>,</span><br><span class="line">Kind:       <span class="string">"Node"</span>, </span><br><span class="line">&#125;</span><br><span class="line">reousrce = unversioned.APIResource&#123;</span><br><span class="line">Name:       <span class="string">"pods"</span>,</span><br><span class="line">Namespaced: <span class="literal">true</span>,</span><br><span class="line">Kind:       <span class="string">"Pod"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="资源外部版本与内部版本"><a href="#资源外部版本与内部版本" class="headerlink" title="资源外部版本与内部版本"></a>资源外部版本与内部版本</h4><h4 id="资源代码定义"><a href="#资源代码定义" class="headerlink" title="资源代码定义"></a>资源代码定义</h4><h4 id="将资源注册到资源注册表"><a href="#将资源注册到资源注册表" class="headerlink" title="将资源注册到资源注册表"></a>将资源注册到资源注册表</h4><h4 id="资源首选版本"><a href="#资源首选版本" class="headerlink" title="资源首选版本"></a>资源首选版本</h4><h4 id="资源操作方法"><a href="#资源操作方法" class="headerlink" title="资源操作方法"></a>资源操作方法</h4><h4 id="资源与命名空间"><a href="#资源与命名空间" class="headerlink" title="资源与命名空间"></a>资源与命名空间</h4><h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><h4 id="资源对象描述文件定义"><a href="#资源对象描述文件定义" class="headerlink" title="资源对象描述文件定义"></a>资源对象描述文件定义</h4><h3 id="Kubernetes内置资源全图"><a href="#Kubernetes内置资源全图" class="headerlink" title="Kubernetes内置资源全图"></a>Kubernetes内置资源全图</h3><h3 id="runtime-Object-类型基石"><a href="#runtime-Object-类型基石" class="headerlink" title="runtime.Object 类型基石"></a>runtime.Object 类型基石</h3><h3 id="Unstructured数据"><a href="#Unstructured数据" class="headerlink" title="Unstructured数据"></a>Unstructured数据</h3><h3 id="Scheme资源注册表"><a href="#Scheme资源注册表" class="headerlink" title="Scheme资源注册表"></a>Scheme资源注册表</h3><h4 id="Scheme资源注册表数据结构"><a href="#Scheme资源注册表数据结构" class="headerlink" title="Scheme资源注册表数据结构"></a>Scheme资源注册表数据结构</h4><h4 id="资源注册表注册方法"><a href="#资源注册表注册方法" class="headerlink" title="资源注册表注册方法"></a>资源注册表注册方法</h4><h4 id="资源注册表查询方法"><a href="#资源注册表查询方法" class="headerlink" title="资源注册表查询方法"></a>资源注册表查询方法</h4><h3 id="Codec编解码器"><a href="#Codec编解码器" class="headerlink" title="Codec编解码器"></a>Codec编解码器</h3><h4 id="Codec编解码实例化"><a href="#Codec编解码实例化" class="headerlink" title="Codec编解码实例化"></a>Codec编解码实例化</h4><h4 id="jsonSerializer-与-yamlSerializer序列化器"><a href="#jsonSerializer-与-yamlSerializer序列化器" class="headerlink" title="jsonSerializer 与 yamlSerializer序列化器"></a>jsonSerializer 与 yamlSerializer序列化器</h4><h4 id="protobufSerializer序列化器"><a href="#protobufSerializer序列化器" class="headerlink" title="protobufSerializer序列化器"></a>protobufSerializer序列化器</h4><h3 id="Converter-资源版本转换器"><a href="#Converter-资源版本转换器" class="headerlink" title="Converter 资源版本转换器"></a>Converter 资源版本转换器</h3><h4 id="Converter-转换器数据结构"><a href="#Converter-转换器数据结构" class="headerlink" title="Converter 转换器数据结构"></a>Converter 转换器数据结构</h4><h4 id="Converter注册转换函数"><a href="#Converter注册转换函数" class="headerlink" title="Converter注册转换函数"></a>Converter注册转换函数</h4><h4 id="Converter-资源版本转换原理"><a href="#Converter-资源版本转换原理" class="headerlink" title="Converter 资源版本转换原理"></a>Converter 资源版本转换原理</h4><h2 id="API-Request-Flow"><a href="#API-Request-Flow" class="headerlink" title="API Request Flow"></a>API Request Flow</h2><p>了解了 kube-apiserver 的 API 后，下面会介绍 kube-apiserver 如何处理一个 API 请求，一个请求完整的流程如下图所示：</p><p><img alt="img" data-src="http://cdn.tianfeiyu.com/API-server-flow-2.png"></p><p>关于 API 的处理代码都在 <code>k8s.io/pkg/api</code> 包中，会处理来自集群内部和集群外部的API请求。</p><p>此处以一次 POST 请求示例说明，当请求到达 kube-apiserver 时，kube-apiserver 首先会执行在 http filter chain 中注册的过滤器链。该过滤器对其执行一系列过滤操作，主要有认证、鉴权等检查操作。当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互。</p><h3 id="Filter-Chain"><a href="#Filter-Chain" class="headerlink" title="Filter Chain"></a>Filter Chain</h3><p>一个HTTP Request首先会被 <code>DefaultBuildHandlerChain</code>注册的 filter chain处理，每一个filter会传递各自的info到 <code>ctx.RequestInfo</code>上。</p><ul><li><code>WithRequestInfo()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/requestinfo.go" target="_blank" rel="external nofollow noopener noreferrer">requestinfo.go</a> attaches a <code>RequestInfo</code> to the context</li><li><code>WithMaxInFlightLimit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/maxinflight.go" target="_blank" rel="external nofollow noopener noreferrer">maxinflight.go</a> limits the number of in-flight requests</li><li><code>WithTimeoutForNonLongRunningRequests()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/timeout.go" target="_blank" rel="external nofollow noopener noreferrer">timeout.go</a> times out non-long-running requests like most <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code> requests in contrast to long-running requests like watches and proxy requests</li><li><code>WithPanicRecovery()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/wrap.go" target="_blank" rel="external nofollow noopener noreferrer">wrap.go</a> wraps an handler to recover and log panics</li><li><code>WithCORS()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/cors.go" target="_blank" rel="external nofollow noopener noreferrer">cors.go</a> provides a CORS implementation; CORS stands for Cross-Origin Resource Sharing and is a mechanism that allows JavaScript embedded in a HTML page to make XMLHttpRequests to a domain different from the one the JavaScript originated from.</li><li><code>WithAuthentication()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authentication.go" target="_blank" rel="external nofollow noopener noreferrer">authentication.go</a> tries to authenticate the given request as a user and stores the user info in the provided context. On success, the <code>Authorization</code> HTTP header is removed from the request.</li><li><code>WithAudit()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/audit.go" target="_blank" rel="external nofollow noopener noreferrer">audit.go</a> decorates the handler with audit logging information for all incoming requests The audit log entries contain infos such as source IP of the request, user invoking the operation, and namespace of the request.</li><li><code>WithImpersonation()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/impersonation.go" target="_blank" rel="external nofollow noopener noreferrer">impersonation.go</a> handles user impersonation, by checking requests that attempt to change the user (similar to sudo).</li><li><code>WithAuthorization()</code> as defined in <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authorization.go" target="_blank" rel="external nofollow noopener noreferrer">authorization.go</a> passes all authorized requests on to multiplexer which dispatched the request to the right handler, and returns a forbidden error otherwise.</li></ul><ul><li>WithRequestInfo：</li><li>MaxInflightLimit</li><li>TimeoutForNonLongRunningRequests</li><li>Panic Recovery</li><li>CORS</li><li>Authentication</li><li>Audit</li><li>Impersonation</li><li>Authorization</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line"><span class="keyword">if</span> c.FlowControl != <span class="literal">nil</span> &#123;</span><br><span class="line">handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)</span><br><span class="line">&#125;</span><br><span class="line">handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">failedHandler := genericapifilters.Unauthorized(c.Serializer)</span><br><span class="line">failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)</span><br><span class="line">handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"true"</span>)</span><br><span class="line">handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)</span><br><span class="line">handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)</span><br><span class="line"><span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &amp;&amp; !c.SecureServing.DisableHTTP2 &amp;&amp; c.GoawayChance &gt; <span class="number">0</span> &#123;</span><br><span class="line">handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)</span><br><span class="line">&#125;</span><br><span class="line">handler = genericapifilters.WithAuditAnnotations(handler, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">handler = genericapifilters.WithWarningRecorder(handler)</span><br><span class="line">handler = genericapifilters.WithCacheControl(handler)</span><br><span class="line">handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line"><span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler-Operation"><a href="#Handler-Operation" class="headerlink" title="Handler Operation"></a>Handler Operation</h3><p>当 filter chain 处理完成后，请求会通过 route 进入到对应的 handler 中，handler 中的操作主要是与 etcd 的交互，在 handler 中的主要的操作如下所示：</p><p><img alt="API-server-storage-flow-2" data-src="http://cdn.tianfeiyu.com/API-server-storage-flow-2.png"></p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a><strong>Decoder</strong></h3><p>在解码时，首先从 HTTP path 中获取期待的 version，然后使用 scheme 以正确的 version 创建一个与之匹配的空对象，并使用 JSON 或 protobuf 解码器进行转换，在转换的第一步中，如果用户省略了某些字段，Decoder 会把其设置为默认值。</p><h3 id="Admission"><a href="#Admission" class="headerlink" title="Admission"></a><strong>Admission</strong></h3><p>在解码完成后，需要通过验证集群的全局约束来检查是否可以创建或更新对象，并根据集群配置设置默认值。在 <code>k8s.io/kubernetes/plugin/pkg/admission</code> 目录下可以看到 kube-apiserver 可以使用的所有全局约束插件，kube-apiserver 在启动时通过设置 <code>--enable-admission-plugins</code> 参数来开启需要使用的插件，通过 <code>ValidatingAdmissionWebhook</code> 或 <code>MutatingAdmissionWebhook</code> 添加的插件也都会在此处进行工作。</p><h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a><strong>Validation</strong></h3><p>主要检查 object 中字段的合法性。</p><p>在 handler 中执行完以上操作后最后会执行与 etcd 相关的操作，POST 操作会将数据写入到 etcd 中，以上在 handler 中的主要处理流程如下所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1beta1 ⇒ internal ⇒    |<span class="string">    ⇒       </span>|<span class="string">    ⇒  v1  ⇒ json/yaml ⇒ etcd</span></span><br><span class="line"><span class="string">                     admission    validation</span></span><br></pre></td></tr></table></figure><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img alt="apiserver diagram" data-src="https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png"></p><ul><li>Scheme：定义了资源序列化和反序列化的方法，以及资源类型和版本的对应关系</li><li>Storage：是对资源的完整封装，实现了资源创建、删除、watch等操作</li><li>APIGroupInfo：是同一个group下所有资源的集合</li></ul><p>每个资源对应着两个版本：</p><ul><li>External Object：这个版本是对外给用户访问创建的接口对象，比如使用yaml或json创建对象时，都要使用External Object</li><li>Internal Object：这个版本是核心对象，实现了资源的创建和删除，对应了在ETCD中持久化的版本</li></ul><p>这两个版本的资源是需要相互转换的，而转换的函数就需要事先初始化到Scheme中， 多个external version版本之间的资源进行相互转换，都是需要通过internal version进行中转。所以在ETCD中存储的资源是带版本的，这也是kubernetes能实现多版本转换的关键。</p><h2 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h2><p>ApiServer 共由 3 个组件构成（Aggregator、KubeAPIServer、APIExtensionServer），这些组件依次通过 Delegation 处理请求：</p><ul><li><strong>Aggregator</strong>：暴露的功能类似于一个七层负载均衡，将来自用户的请求拦截转发给其他服务器，并且负责整个 APIServer 的 Discovery 功能；</li><li><strong>KubeAPIServer</strong> ：负责对请求的一些通用处理，认证、鉴权等，以及处理各个内建资源的 REST 服务；</li><li><strong>APIExtensionServer</strong>：主要处理 CustomResourceDefinition（CRD）和 CustomResource（CR）的 REST 请求，也是 Delegation 的最后一环，如果对应 CR 不能被处理的话则会返回 404。</li></ul><p>Aggregator 和 APIExtensionsServer 对应两种主要扩展 APIServer 资源的方式，即分别是 AA 和 CRD。</p><h3 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h3><p>Aggregator 通过 APIServices 对象关联到某个 Service 来进行请求的转发，其关联的 Service 类型进一步决定了请求转发形式。Aggregator 包括一个 <code>GenericAPIServer</code> 和维护自身状态的 Controller。其中 <code>GenericAPIServer</code> 主要处理 <code>apiregistration.k8s.io</code> 组下的 APIService 资源请求。</p><p><strong>Aggregator 除了处理资源请求外还包含几个 controller：</strong></p><ul><li><code>apiserviceRegistrationController</code>：负责 APIServices 中资源的注册与删除；</li><li><code>availableConditionController</code>：维护 APIServices 的可用状态，包括其引用 Service 是否可用等；</li><li><code>autoRegistrationController</code>：用于保持 API 中存在的一组特定的 APIServices；</li><li><code>crdRegistrationController</code>：负责将 CRD GroupVersions 自动注册到 APIServices 中；</li><li><code>openAPIAggregationController</code>：将 APIServices 资源的变化同步至提供的 OpenAPI 文档；</li></ul><p>kubernetes 中的一些附加组件，比如 metrics-server 就是通过 Aggregator 的方式进行扩展的，实际环境中可以通过使用 <a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="external nofollow noopener noreferrer">apiserver-builder</a> 工具轻松以 Aggregator 的扩展方式创建自定义资源。</p><h4 id="启用-API-Aggregation"><a href="#启用-API-Aggregation" class="headerlink" title="启用 API Aggregation"></a>启用 API Aggregation</h4><p>在 kube-apiserver 中需要增加以下配置来开启 API Aggregation：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--proxy-client-cert-file=/etc/kubernetes/certs/proxy.crt</span><br><span class="line">--proxy-client-key-file=/etc/kubernetes/certs/proxy.key</span><br><span class="line">--requestheader-client-ca-file=/etc/kubernetes/certs/proxy-ca.crt</span><br><span class="line">--requestheader-allowed-names=aggregator</span><br><span class="line">--requestheader-extra-headers-prefix=X-Remote-Extra-</span><br><span class="line">--requestheader-group-headers=X-Remote-Group</span><br><span class="line">--requestheader-username-headers=X-Remote-User</span><br></pre></td></tr></table></figure><h3 id="KubeAPIServer"><a href="#KubeAPIServer" class="headerlink" title="KubeAPIServer"></a>KubeAPIServer</h3><p>KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。</p><h3 id="APIExtensionServer"><a href="#APIExtensionServer" class="headerlink" title="APIExtensionServer"></a>APIExtensionServer</h3><p>APIExtensionServer 作为 Delegation 链的最后一层，是处理所有用户通过 Custom Resource Definition 定义的资源服务器。</p><p>其中包含的 controller 以及功能如下所示：</p><ul><li><code>openapiController</code>：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 <code>/openapi/v2</code> 进行查看；</li><li><code>crdController</code>：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 <code>$ kubectl api-versions</code> 和 <code>$ kubectl api-resources</code> 查看；</li><li><code>namingController</code>：检查 crd obj 中是否有命名冲突，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>establishingController</code>：检查 crd 是否处于正常状态，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>nonStructuralSchemaController</code>：检查 crd obj 结构是否正常，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>apiApprovalController</code>：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd <code>.status.conditions</code> 中查看；</li><li><code>finalizingController</code>：类似于 finalizes 的功能，与 CRs 的删除有关；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ApiServer&lt;/code&gt;作为 Kubernetes 的核心组件，让集群中所有资源可被描述和配置，即包括了pod、ingress、pvc这些基础资源，也包括deployment、rc、hpa等管理对象；ApiServer就像是一个包含一定逻辑的对象数据库代理；提供了RESTful API接口，其他组件或客户端可以通过该接口获取集群中资源对象的配置和状态，以实现各种逻辑处理；ApiServer本身是无状态的，集群所有的数据都会存储在ETCD中，各个组件对于资源对象的List-Watch机制都要通过 ApiServer 的验证授权和准入。&lt;/p&gt;
&lt;p&gt;kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/kubernetes-api/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Kubernetes API&lt;/a&gt;，包括认证授权、数据校验以及集群状态变更等，供客户端及其他组件调用&lt;/li&gt;
&lt;li&gt;代理集群中的一些附加组件组件，如 Kubernetes UI、metrics-server、npd 等；&lt;/li&gt;
&lt;li&gt;允许对于对象状态的操作，比如Pod和Service的状态的改变，实现对象的持久化到Etcd&lt;/li&gt;
&lt;li&gt;资源在不同版本之间的转换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://raw.githubusercontent.com/TroyYing/image/master/k8s_code_apiserver/apiserver_diagram.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="源码解读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="apiserver" scheme="http://houmin.cc/tags/apiserver/"/>
    
  </entry>
  
  <entry>
    <title>所谓生活</title>
    <link href="http://houmin.cc/posts/47d0d3b/"/>
    <id>http://houmin.cc/posts/47d0d3b/</id>
    <published>2020-08-09T14:20:20.000Z</published>
    <updated>2020-08-21T08:11:30.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。</p><a id="more"></a><h2 id="所见"><a href="#所见" class="headerlink" title="所见"></a>所见</h2><p>一直说要拍拍夏天的荷花，入职一个月以来，周末却一直呆在家里，没有出门。一来是外面太热，二来一直没有把自己的时间安排好，迟迟没有出门。下周要去房山参加一个星期的封闭培训，等到回来时，北京的夏天就过去了。想到这里，立马敲定晚上出门，带着相机，坐地铁到达什刹海公园。</p><p>走出地铁第一感受是，外面人好多。这不是我第一次来这里了，从烟袋斜街进去，转后海一条街，已经成了我的惯常路线。然而我们想到的是，即使国内仍然被疫情阴影笼罩，什刹海这里已经摩肩接踵，除了口罩已经不太能够看出疫情的痕迹了。</p><p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily.png"></p><p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily2.png"></p><p><img alt="夏天，荷花" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_lily3.png"></p><p>第二个让我感触比较大的是人们的生活状态。踢毽子、抽陀螺、跳舞、遛狗、打球、跑步，大家的状态都很放松，可以自在的玩自己的爱好。</p><p><img alt="荷花市坊抽陀螺的大爷" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_pick.png"></p><p><img alt="地安门两个人一起跳舞的叔叔阿姨" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dance.png"></p><p><img alt="走到景山后街，见证了两个导盲犬的相遇与分离" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dogs1.png"></p><p><img alt="他们两个明天应该还会相遇吧" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-dogs2.png"></p><p><img alt="狗狗主人还热情地给我看了他平时拍到的狗狗照片" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_dogs3.png"></p><p>这与我在办公室的状态很不一样。在平常的日子里，每天除了上下班就没有其他的生活了。周末自己宅在家里，也不是这种惬意。总觉得有事情要做，总觉得有事情没有做完。这种状态，只有在找完工作之后的那半年才有吧。</p><h2 id="所闻"><a href="#所闻" class="headerlink" title="所闻"></a>所闻</h2><p>继续往景山走，却不想景区已经关门，只好往故宫走。</p><p><img alt="在角楼，一边也在拍角楼的素不相识的大哥主动提出借给我三脚架，于是才有了这张照片" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-city.png"></p><p>拍角楼的时候，一个大爷主动跟我说话，推荐我拍拍景山前面的灯。本以为是一个简单的搭话，没想到我们两个聊了一个多小时的庄子、道与术、中西方哲学。这可能是这段时间里我交流密度最多的一个小时了。真的很奇妙，本是互不相识的人，却可以因为一方的主动聊起来，聊完之后也拂袖而去。与之相反，在办公室中，虽然也是每天都见面，但是实际上却说不上什么话。</p><h2 id="所想"><a href="#所想" class="headerlink" title="所想"></a>所想</h2><p>总的来说，这次外出让我感到很开心，让我感觉到城市中人与人的连接性，让我感到了北京的可爱。这些都是实实在在存在的人，他们都有着自己的生活。就是这样，你是可以变得更加主动一些的，没准你就可以发现难得的惊喜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有出去走走了，趁着夏天还没有结束，在封闭培训前去什刹海走了走，看到了生活的另一种可能。这里是「朝花夕拾」第二十二期，今天我们聊一聊生活。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-08-08_forbidden-city.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="夏天" scheme="http://houmin.cc/tags/%E5%A4%8F%E5%A4%A9/"/>
    
      <category term="故宫" scheme="http://houmin.cc/tags/%E6%95%85%E5%AE%AB/"/>
    
      <category term="什刹海" scheme="http://houmin.cc/tags/%E4%BB%80%E5%88%B9%E6%B5%B7/"/>
    
      <category term="生活" scheme="http://houmin.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】Go Module</title>
    <link href="http://houmin.cc/posts/55d129f1/"/>
    <id>http://houmin.cc/posts/55d129f1/</id>
    <published>2020-08-07T14:07:31.000Z</published>
    <updated>2020-08-22T08:36:58.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="包管理机制"><a href="#包管理机制" class="headerlink" title="包管理机制"></a>包管理机制</h2><p>Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。</p><p>从 v1.5 开始开始引入 vendor 包模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 vendor 内的包进行编译、测试等，这之后第三方的包管理思路都是通过这种方式来实现，比如说由社区维护准官方包管理工具 dep。</p><a id="more"></a><p>不过官方并不认同这种方式，在 v1.11 中加入了 Go Module 作为官方包管理形式，就这样 dep 无奈的结束了使命。最初的 Go Module 提案的名称叫做 vgo，下面为了介绍简称为 gomod。不过在 v1.11 和 v1.12 的 Go 版本中 gomod 是不能直接使用的。可以通过 <code>go env</code> 命令返回值的 <code>GOMOD</code> 字段是否为空来判断是否已经开启了 gomod，如果没有开启，可以通过设置环境变量 <code>export GO111MODULE=on</code> 开启。</p><p>目前 gomod 在 Go v1.12 功能基本稳定，到下一个版本 v1.13 将默认开启，是时候开始在项目中使用 gomod 了。</p><p>自从 Go 官方从去年推出 1.11 之后，增加新的依赖管理模块并且更加易于管理项目中所需要的模块。模块是存储在文件树中的 Go 包的集合，其根目录中包含 go.mod 文件。 go.mod 文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求。每个依赖性要求都被写为模块路径和特定语义版本。</p><p>从 Go 1.11 开始，Go 允许在 $GOPATH/src 外的任何目录下使用 go.mod 创建项目。在 $GOPATH/src 中，为了兼容性，Go 命令仍然在旧的 GOPATH 模式下运行。从 Go 1.13 开始，模块模式将成为默认模式。</p><p>Go在构建设计方面深受Google内部开发实践的影响，比如go get的设计就深受<a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/pdf" target="_blank" rel="external nofollow noopener noreferrer">Google内部单一代码仓库(single monorepo)和基于主干(trunk/mainline based)的开发模型</a>的影响：只获取Trunk/mainline代码和版本无感知。</p><p><img alt="img{512x368}" data-src="https://tonybai.com/wp-content/uploads/google-trunk-based-and-release-branch-dev-model.png"></p><blockquote><p>Google内部基于主干的开发模型：<br>– 所有开发人员基于主干trunk/mainline开发：提交到trunk或从trunk获取最新的代码（同步到本地workspace）<br>– 版本发布时，建立Release branch，release branch实质上就是某一个时刻主干代码的快照；<br>– 必须同步到release branch上的bug fix和增强改进代码也通常是先在主干上提交(commit)，然后再cherry-pick到release branch上</p></blockquote><p>我们知道go get获取的代码会放在$GOPATH/src下面，而go build会在$GOROOT/src和$GOPATH/src下面按照import path去搜索package，由于go get 获取的都是各个package repo的trunk/mainline的代码，因此，<a href="https://tonybai.com/2015/07/10/some-changes-in-go-1-5/" target="_blank" rel="external nofollow noopener noreferrer">Go 1.5</a>之前的Go compiler都是基于目标Go程序依赖包的trunk/mainline代码去编译的。这样的机制带来的问题是显而易见的，至少包括：</p><ul><li>因依赖包的trunk的变化，导致不同人获取和编译你的包/程序时得到的结果实质是不同的，即不能实现reproduceable build</li><li>因依赖包的trunk的变化，引入不兼容的实现，导致你的包/程序无法通过编译</li><li>因依赖包演进而无法通过编译，导致你的包/程序无法通过编译</li></ul><p>为了实现reporduceable build，Go 1.5引入了<a href="https://tonybai.com/2015/07/31/understand-go15-vendor/" target="_blank" rel="external nofollow noopener noreferrer">Vendor机制</a>，Go编译器会优先在vendor下搜索依赖的第三方包，这样如果开发者将特定版本的依赖包存放在vendor下面并提交到code repo，那么所有人理论上都会得到同样的编译结果，从而实现reporduceable build。</p><p>在Go 1.5发布后的若干年，gopher们把注意力都集中在如何利用vendor解决包依赖问题，从手工添加依赖到vendor、手工更新依赖，到一众包依赖管理工具的诞生：比如: <a href="https://github.com/kardianos/govendor" target="_blank" rel="external nofollow noopener noreferrer">govendor</a>、<a href="https://github.com/Masterminds/glide" target="_blank" rel="external nofollow noopener noreferrer">glide</a>以及号称准官方工具的<a href="https://github.com/golang/dep" target="_blank" rel="external nofollow noopener noreferrer">dep</a>，努力地尝试着按照当今主流思路解决着诸如：“钻石型依赖”等难题。</p><p>正当gopher认为dep将“顺理成章”地升级为go toolchain一部分的时候，vgo横空出世，并通过对“Semantic Import Versioning”和”Minimal Version Selected”的设定，在原Go tools上简单快速地实现了Go原生的包依赖管理方案 。vgo就是go module的前身。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>你可以在 $GOPATH/src 之外的任何地方创建一个新的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /tmp/scratchpad/repo &amp;&amp; <span class="built_in">cd</span> /tmp/scratchpad/repo</span><br></pre></td></tr></table></figure><p>初始化一个新的模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init github.com/SimpCosm/repo</span><br><span class="line">go: creating new go.mod: module github.com/SimpCosm/repo</span><br></pre></td></tr></table></figure><p>成功之后你会发现目录下会生成一个 go.mod 文件。首行为当前的模块名称，接下来是 go 的使用版本。这两行和 <code>npm package.json</code> 的 <code>name</code> 和 <code>engine</code> 字段的功能很类似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module github.com/SimpCosm/repo</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure><p>创建一个文件 main.go 然后加入以下代码，这里直接 import 了 Go 维护者 Russ Cox 写一个简单的库，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"rsc.io/quote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并且运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o hello</span><br><span class="line">go: finding module <span class="keyword">for</span> package rsc.io/quote</span><br><span class="line">go: downloading rsc.io/quote v1.5.2</span><br><span class="line">go: found rsc.io/quote <span class="keyword">in</span> rsc.io/quote v1.5.2</span><br><span class="line">go: downloading rsc.io/sampler v1.3.0</span><br><span class="line">go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><p><code>go build</code> 之后，会在 go.mod 引入所需要的依赖包。之后再来看看 go.mod 文件的情况，require 就是 gin 框架所需要的所有依赖包 并且在每个依赖包的后面已经表明了版本号。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module github.com/SimpCosm/repo</span><br><span class="line"></span><br><span class="line">go <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>与此同时，工程目录下多了一个 <code>go.sum</code>文件，有点类似于 <code>npm package-lock.json</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">golang.org&#x2F;x&#x2F;text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8&#x3D;</span><br><span class="line">golang.org&#x2F;x&#x2F;text v0.0.0-20170915032832-14c0d48ead0c&#x2F;go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi&#x2F;IjpwHt7yyuwOQ&#x3D;</span><br><span class="line">rsc.io&#x2F;quote v1.5.2 h1:w5fcysjrx7yqtD&#x2F;aO+QwRjYZOKnaM9Uh2b40tElTs3Y&#x3D;</span><br><span class="line">rsc.io&#x2F;quote v1.5.2&#x2F;go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0&#x3D;</span><br><span class="line">rsc.io&#x2F;sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh&#x2F;QiW4&#x3D;</span><br><span class="line">rsc.io&#x2F;sampler v1.3.0&#x2F;go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA&#x3D;</span><br></pre></td></tr></table></figure><p>gomod 不会在 <code>$GOPATH/src</code> 目录下保存 <code>rsc.io/quote</code> 包的源码，而是包源码和链接库保存在 <code>$GOPATH/pkg/mod</code> 目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls $GOPATH&#x2F;pkg&#x2F;mod</span><br><span class="line">cache      golang.org rsc.io</span><br></pre></td></tr></table></figure><p>除了 <code>go run</code> 命令以外，<code>go build</code>、<code>go test</code> 等命令也能自动下载相关依赖包。</p><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>可以看到，在上面的示例中完全没有使用 <code>go get</code> 命令，日常的工作流如下：</p><ul><li>编写 <code>.go</code> 代码，根据需要添加 import statements</li><li><code>go build</code> 或者 <code>go test</code> 命令会自动添加下载新的依赖来满足 import 的要求，并且更新 <code>go.mod</code> 文件</li><li>当对依赖的版本有特殊要求的时候，可以使用 <code>go get foo@v1.2.3</code>, <code>go get foo@master</code>, <code>go get foo@e3702bed2</code> 命令，或者直接编辑 <code>go.mod</code> 文件</li></ul><p>使用较多的命令初识：</p><ul><li><code>go list -m all</code> — 查看在编译中所有直接和非直接依赖的最终版本</li><li><code>go list -u -m all</code> — 查看所有直接和非直接依赖可用的升级补丁</li><li><code>go get -u ./...</code> or <code>go get -u=patch ./...</code> (from module root directory) — 更新所有直接和非直接以来到最新版本</li><li><code>go build ./...</code> or <code>go test ./...</code> (from module root directory) — 编译或测试模块中所有package</li><li><code>go mod tidy</code> — 移除不再需要的依赖，并且添加需要的依赖</li><li><code>replace</code> directive or <code>gohack</code> — 使用replace 指令</li><li><code>go mod vendor</code> — 可选的创造 <code>vendor</code> 目录</li></ul><h2 id="New-Concept"><a href="#New-Concept" class="headerlink" title="New Concept"></a>New Concept</h2><p>本小结提供了一些 <code>High-Level</code>的概念介绍。如果想要了解更多的细节，可以看这个40分钟的 <a href="https://www.youtube.com/watch?v=F8nrpe0XWRg&amp;list=PLq2Nv-Sh8EbbIjQgDzapOFeVfv5bGOoPE&amp;index=3&amp;t=0s" target="_blank" rel="external nofollow noopener noreferrer">Russ Cox 介绍 go module背后的设计哲学</a> 视频，也可以看官方的 <a href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" target="_blank" rel="external nofollow noopener noreferrer">Proposal</a>，或者是早期更详细的 <a href="https://research.swtch.com/vgo" target="_blank" rel="external nofollow noopener noreferrer">vgo博客系列</a> 。</p><h3 id="Modules-定义"><a href="#Modules-定义" class="headerlink" title="Modules 定义"></a>Modules 定义</h3><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><h3 id="Version-Selection"><a href="#Version-Selection" class="headerlink" title="Version Selection"></a>Version Selection</h3><h3 id="Semantic-Import-Versioning"><a href="#Semantic-Import-Versioning" class="headerlink" title="Semantic Import Versioning"></a>Semantic Import Versioning</h3><h2 id="How-to-Use-Modules"><a href="#How-to-Use-Modules" class="headerlink" title="How to Use Modules"></a>How to Use Modules</h2><h2 id="包管理命令"><a href="#包管理命令" class="headerlink" title="包管理命令"></a>包管理命令</h2><h3 id="升级依赖项"><a href="#升级依赖项" class="headerlink" title="升级依赖项"></a>升级依赖项</h3><p>首先我们需要查看以下我们使用到的依赖列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m all                                                                           ─╯</span><br><span class="line">backend</span><br><span class="line">github.com/davecgh/go-spew v1.1.1</span><br><span class="line">github.com/gin-contrib/sse v0.1.0</span><br><span class="line">github.com/gin-gonic/gin v1.6.3</span><br><span class="line">github.com/go-playground/assert/v2 v2.0.1</span><br><span class="line">github.com/go-playground/locales v0.13.0</span><br><span class="line">github.com/go-playground/universal-translator v0.17.0</span><br><span class="line">github.com/go-playground/validator/v10 v10.2.0</span><br><span class="line">github.com/golang/protobuf v1.3.3</span><br><span class="line">github.com/google/gofuzz v1.0.0</span><br><span class="line">github.com/json-iterator/go v1.1.9</span><br><span class="line">github.com/leodido/go-urn v1.2.0</span><br><span class="line">github.com/mattn/go-isatty v0.0.12</span><br><span class="line">github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421</span><br><span class="line">github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742</span><br><span class="line">github.com/pmezard/go-difflib v1.0.0</span><br><span class="line">github.com/stretchr/objx v0.1.0</span><br><span class="line">github.com/stretchr/testify v1.4.0</span><br><span class="line">github.com/ugorji/go v1.1.7</span><br><span class="line">github.com/ugorji/go/codec v1.1.7</span><br><span class="line">golang.org/x/sys v0.0.0-20200116001909-b77594299b42</span><br><span class="line">golang.org/x/text v0.3.2</span><br><span class="line">golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e</span><br><span class="line">gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405</span><br><span class="line">gopkg.in/yaml.v2 v2.2.8</span><br></pre></td></tr></table></figure><p>因为这里使用的是最新的版本，无法升级，所以这里给出一个回退的例子。将 GIN 框架的版本回退到上个版本。这里需要使用一个命令查看依赖的版本历史。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m -versions github.com/gin-gonic/gin</span><br><span class="line"><span class="comment"># 将会列出 Gin 版本历史</span></span><br><span class="line">github.com/gin-gonic/gin v1.1.1 v1.1.2 v1.1.3 v1.1.4 v1.3.0 v1.4.0 v1.5.0 v1.6.0 v1.6.1 v1.6.2 v1.6.3</span><br></pre></td></tr></table></figure><p>将版本更新到上个版本，这里只是个演示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/gin-gonic/gin@v1.4.0 <span class="comment"># 只需要在依赖后面加上 @version 就可以了</span></span><br><span class="line">go get github.com/gin-gonic/gin@v1.4.0                                                   ─╯</span><br><span class="line">go: downloading github.com/gin-gonic/gin v1.4.0</span><br><span class="line">go: downloading github.com/json-iterator/go v1.1.9</span><br><span class="line">go: downloading gopkg.in/go-playground/validator.v8 v8.18.2</span><br><span class="line">$ go list -m all</span><br><span class="line"><span class="comment"># 看到了版本变化</span></span><br><span class="line">github.com/gin-gonic/gin v1.4.0</span><br></pre></td></tr></table></figure><p>或者可以使用 <code>go mod</code> 来进行版本的切换，这样就需要两个步骤了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit -require=<span class="string">"github.com/gin-gonic/gin@v1.4.0"</span> <span class="comment"># 修改 go.mod 文件</span></span><br><span class="line">$ go mod tidy <span class="comment"># 下载更新依赖</span></span><br></pre></td></tr></table></figure><p><code>go mod tidy</code> 会自动清理掉不需要的依赖项，同时可以将依赖项更新到当前版本。</p><p>使用起来这是一个很简单过程，只需要几个命令，你便可以知道依赖的版本信息，以及自由选择安装的版本，一切都变得这么简单。</p><h3 id="删除未使用的依赖项"><a href="#删除未使用的依赖项" class="headerlink" title="删除未使用的依赖项"></a>删除未使用的依赖项</h3><p>如果你在项目过程需要移除一些不需要的依赖，可以使用下面的命令来执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br></pre></td></tr></table></figure><h3 id="命令备忘"><a href="#命令备忘" class="headerlink" title="命令备忘"></a>命令备忘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go mod</span><br><span class="line">The commands are:</span><br><span class="line">    download    download modules to <span class="built_in">local</span> cache</span><br><span class="line">    edit        edit go.mod from tools or scripts</span><br><span class="line">    graph       <span class="built_in">print</span> module requirement graph</span><br><span class="line">    init        initialize new module <span class="keyword">in</span> current directory</span><br><span class="line">    tidy        add missing and remove unused modules</span><br><span class="line">    vendor      make vendored copy of dependencies</span><br><span class="line">    verify      verify dependencies have expected content</span><br><span class="line">    why         explain why packages or modules are needed</span><br></pre></td></tr></table></figure><h2 id="包管理命令-1"><a href="#包管理命令-1" class="headerlink" title="包管理命令"></a>包管理命令</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>如果要想先下载依赖，那么可以直接像以前那样 <code>go get</code> 即可，不过 gomod 下可以跟语义化版本号，比如 <code>go get foo@v1.2.3</code>，也可以跟 git 的分支或 tag，比如<code>go get foo@master</code>，当然也可以跟 git 提交哈希，比如 <code>go get foo@e3702bed2</code>。需要特别注意的是，gomod 除了遵循语义化版本原则外，还遵循最小版本选择原则，也就是说如果当前版本是 v1.1.0，只会下载不超过这个最大版本号。如果使用 <code>go get foo@master</code>，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码，如下所示，使用包含当前最新提交哈希的虚拟版本号替代直接的 <code>master</code> 版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go get golang.org/x/crypto/sha3@master</span><br><span class="line">go: finding golang.org/x/crypto/sha3 latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/adesight/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果下载所有依赖可以使用 <code>go mod download</code> 命令。</p><h3 id="升级依赖"><a href="#升级依赖" class="headerlink" title="升级依赖"></a>升级依赖</h3><p>查看所有以升级依赖版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go list -u -m all</span><br><span class="line">go: finding golang.org/x/sys latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">github.com/adesight/<span class="built_in">test</span></span><br><span class="line">golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a [v0.0.0-20190316082340-a2f829d7f35f]</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.99.99</span><br></pre></td></tr></table></figure><p>升级次级或补丁版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u rsc.io&#x2F;quote</span><br></pre></td></tr></table></figure><p>仅升级补丁版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u&#x3D;patch rscio&#x2F;quote</span><br></pre></td></tr></table></figure><p>升降级版本号，可以使用比较运算符控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get foo@&#39;&lt;v1.6.2&#39;</span><br></pre></td></tr></table></figure><h3 id="移除依赖"><a href="#移除依赖" class="headerlink" title="移除依赖"></a>移除依赖</h3><p>当前代码中不需要了某些包，删除相关代码片段后并没有在 <code>go.mod</code> 文件中自动移出。</p><p>运行下面命令可以移出所有代码中不需要的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>如果仅仅修改 <code>go.mod</code> 配置文件的内容，那么可以运行 <code>go mod edit --droprequire=path</code>，比如要移出 <code>golang.org/x/crypto</code> 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit --droprequire&#x3D;golang.org&#x2F;x&#x2F;crypto</span><br></pre></td></tr></table></figure><h3 id="查看依赖包"><a href="#查看依赖包" class="headerlink" title="查看依赖包"></a>查看依赖包</h3><p>可以直接查看 <code>go.mod</code> 文件，或者使用命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">github.com&#x2F;adesight&#x2F;test</span><br><span class="line">golang.org&#x2F;x&#x2F;crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">golang.org&#x2F;x&#x2F;sys v0.0.0-20190215142949-d0b11bdaac8a</span><br><span class="line">golang.org&#x2F;x&#x2F;text v0.3.0</span><br><span class="line">rsc.io&#x2F;quote v1.5.2</span><br><span class="line">rsc.io&#x2F;sampler v1.99.99</span><br><span class="line">$ go list -m -json all # json 格式输出</span><br><span class="line">&#123;</span><br><span class="line">        &quot;Path&quot;: &quot;golang.org&#x2F;x&#x2F;text&quot;,</span><br><span class="line">        &quot;Version&quot;: &quot;v0.3.0&quot;,</span><br><span class="line">        &quot;Time&quot;: &quot;2017-12-14T13:08:43Z&quot;,</span><br><span class="line">        &quot;Indirect&quot;: true,</span><br><span class="line">        &quot;Dir&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;golang.org&#x2F;x&#x2F;text@v0.3.0&quot;,</span><br><span class="line">        &quot;GoMod&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;cache&#x2F;download&#x2F;golang.org&#x2F;x&#x2F;text&#x2F;@v&#x2F;v0.3.0.mod&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        &quot;Path&quot;: &quot;rsc.io&#x2F;quote&quot;,</span><br><span class="line">        &quot;Version&quot;: &quot;v1.5.2&quot;,</span><br><span class="line">        &quot;Time&quot;: &quot;2018-02-14T15:44:20Z&quot;,</span><br><span class="line">        &quot;Dir&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;rsc.io&#x2F;quote@v1.5.2&quot;,</span><br><span class="line">        &quot;GoMod&quot;: &quot;&#x2F;Users&#x2F;lishude&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;cache&#x2F;download&#x2F;rsc.io&#x2F;quote&#x2F;@v&#x2F;v1.5.2.mod&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块配置文本格式化"><a href="#模块配置文本格式化" class="headerlink" title="模块配置文本格式化"></a>模块配置文本格式化</h3><p>由于可手动修改 go.mod 文件，所以可能此文件并没有被格式化，使用下面命令进行文本格式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure><h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><p>发布包新版本和其它包管理工具基本一致，可以直接打标签，不过打标签之前需要在 go.mod 中写入相应的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit --module&#x3D;github.com&#x2F;islishude&#x2F;gomodtest&#x2F;v2</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com&#x2F;islishude&#x2F;gomodtest&#x2F;v2</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">golang.org&#x2F;x&#x2F;crypto v0.0.0-20190313024323-a1f597ede03a &#x2F;&#x2F; indirect</span><br><span class="line">rsc.io&#x2F;quote v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>官方推荐将上述过程在一个新分支来避免混淆，那么类如上述例子可以创建一个 v2 分支，但这个不是强制要求的。</p><p>还有一种方式发布新版本，那就是在主线版本种加入 v2 文件夹，相应的也需要内置 go.mod 这个文件。</p><p>比如上述我们引入的 <a href="https://link.zhihu.com/?target=http%3A//rsc.io/quote" rel="external nofollow noopener noreferrer" target="_blank">http://rsc.io/quote</a> 包，其中 v3 版本是用内置文件夹，而 v2 使用的是 tag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── buggy</span><br><span class="line">│   └── buggy_test.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── quote.go</span><br><span class="line">├── quote_test.go</span><br><span class="line">└── v3</span><br><span class="line">    ├── go.mod</span><br><span class="line">    ├── go.sum</span><br><span class="line">    └── quote.go</span><br><span class="line">$ git tag -a</span><br><span class="line">bad</span><br><span class="line">v1.0.0</span><br><span class="line">v1.1.0</span><br><span class="line">v1.2.0</span><br><span class="line">v1.2.1</span><br><span class="line">v1.3.0</span><br><span class="line">v1.4.0</span><br><span class="line">v1.5.0</span><br><span class="line">v1.5.1</span><br><span class="line">v1.5.2</span><br><span class="line">v1.5.3-pre1</span><br><span class="line">v2.0.0</span><br><span class="line">v2.0.1</span><br><span class="line">v3.0.0</span><br><span class="line">v3.1.0</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>根据上面的说明，想必你会看到一个问题，当我们升级主版本号的时候，要更改 module 名称，也就是上面所说的加上版本号，这就存在一个问题，如果我们要更新到主版本号的依赖就没有这么简单了，因为升级的依赖包路径都需要修改，<strong>这个在其它语言包管理以及 Go 第三方包管理工具都不存在的一点</strong>。</p><p>如下所示，升级 <code>rsc.io/quote</code> 到 v3 版本。注意一点，作为例子这里包作者对函数也加上了版本，其实大部分人是不会加的。这个模式叫做 <code>semantic import versioning</code>，也是备受争议，大多数人认为这个没有特别大的作用，而维护者则认为这是为了 Go 下一个十年的必要条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;rsc.io&#x2F;quote&#x2F;v3&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(quote.HelloV3())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于内部开发我觉得还挺好，让大家都了解，不要随意加入破坏性更新。</p><p>不过由于这个不讨喜功能，不同版本可以存在同一个包了。补充一句，对于 v0 和 v1 版本并不需要加入到 import path 内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">q1 &quot;rsc.io&#x2F;quote&quot;</span><br><span class="line">&quot;rsc.io&#x2F;quote&#x2F;v3&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(quote.HelloV3())</span><br><span class="line">fmt.Println(q1.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从老项目迁移"><a href="#从老项目迁移" class="headerlink" title="从老项目迁移"></a>从老项目迁移</h3><p>从很多第三方的包管理工具迁移到 gomod 特别简单，直接运行 <code>go mod init</code> 即可。</p><p>如果没有使用任何第三方包管理工具，除了运行 <code>go mod init</code> 初始化以外，还要使用 <code>go get ./...</code> 下载安装所有依赖包，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</p><p>默认情况下，<code>go get</code> 命令使用 <code>@latest</code> 版本控制符对所有依赖进行下载，如果想要更改某一个包的版本，可以使用 <code>go mod edit --require</code> 命令，比如要更新 <code>rsc.io/quote</code> 到 v3.1.0 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit --require&#x3D;rsc.io&#x2F;quote@v3.1.0</span><br></pre></td></tr></table></figure><h3 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a>GOSUMDB</h3><p>它的值是一个 Go checksum database，用于使 Go 在拉取模块版本时(无论是从源站拉取还是通过 Go module proxy 拉取)保证拉取到的模块版本数据未经篡改，也可以是“off”即禁止 Go 在后续操作中校验模块版本</p><ul><li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li><li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li><li>拥有默认值：<code>sum.golang.org</code> (之所以没有按照上面的格式是因为 Go 对默认值做了特殊处理)。</li><li>可被 Go module proxy 代理 (详见：Proxying a Checksum Database)。</li><li><code>sum.golang.org</code> 在中国无法访问，故而更加建议将 GOPROXY 设置为 <code>goproxy.cn</code>，因为 <code>goproxy.cn</code> 支持代理 <code>sum.golang.org</code>。</li></ul><h3 id="Go-Checksum-Database"><a href="#Go-Checksum-Database" class="headerlink" title="Go Checksum Database"></a>Go Checksum Database</h3><p>Go checksum database 主要用于保护 Go 不会从任何源头拉到被篡改过的非法 Go 模块版本，其作用（左）和工作机制（右）如下图：</p><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76259e2243468?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>如果有兴趣的小伙伴可以看看 <a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#proxying-a-checksum-database" target="_blank" rel="external nofollow noopener noreferrer">Proposal: Secure the Public Go Module Ecosystem</a>，有详细介绍其算法机制，如果想简单一点，查看 <code>go help module-auth</code> 也是一个不错的选择。</p><h3 id="GONOPROXY-GONOSUMDB-GOPRIVATE"><a href="#GONOPROXY-GONOSUMDB-GOPRIVATE" class="headerlink" title="GONOPROXY/GONOSUMDB/GOPRIVATE"></a>GONOPROXY/GONOSUMDB/GOPRIVATE</h3><p>这三个环境变量都是用在当前项目依赖了私有模块，也就是依赖了由 GOPROXY 指定的 Go module proxy 或由 GOSUMDB 指定 Go checksum database 无法访问到的模块时的场景</p><ul><li>它们三个的值都是一个以英文逗号 “,” 分割的模块路径前缀，匹配规则同 path.Match。</li><li>其中 GOPRIVATE 较为特殊，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是只是用 GOPRIVATE。</li></ul><p>在使用上来讲，比如 <code>GOPRIVATE=*.corp.example.com</code> 表示所有模块路径以 <code>corp.example.com</code> 的下一级域名 (如 <code>team1.corp.example.com</code>) 为前缀的模块版本都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 <code>corp.example.com</code> 本身。</p><h3 id="Global-Caching"><a href="#Global-Caching" class="headerlink" title="Global Caching"></a>Global Caching</h3><p>这个主要是针对 Go modules 的全局缓存数据说明，如下：</p><ul><li>同一个模块版本的数据只缓存一份，所有其他模块共享使用。</li><li>目前所有模块版本数据均缓存在 <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sum</code> 下，未来或将移至 <code>$GOCACHE/mod</code>和<code>$GOCACHE/sum</code> 下( 可能会在当 <code>$GOPATH</code> 被淘汰后)。</li><li>可以使用 <code>go clean -modcache</code> 清理所有已缓存的模块版本数据。</li></ul><p>另外在 Go1.11 之后 GOCACHE 已经不允许设置为 off 了，我想着这也是为了模块数据缓存移动位置做准备，因此大家应该尽快做好适配。</p><h2 id="快速迁移项目至-Go-Modules"><a href="#快速迁移项目至-Go-Modules" class="headerlink" title="快速迁移项目至 Go Modules"></a>快速迁移项目至 Go Modules</h2><ul><li>第一步: 升级到 Go 1.13。</li><li>第二步: 让 GOPATH 从你的脑海中完全消失，早一步踏入未来。<ul><li>修改 GOBIN 路径（可选）：<code>go env -w GOBIN=$HOME/bin</code>。</li><li>打开 Go modules：<code>go env -w GO111MODULE=on</code>。</li><li>设置 GOPROXY：<code>go env -w GOPROXY=https://goproxy.cn,direct</code> # 在中国是必须的，因为它的默认值被墙了。</li></ul></li><li>第三步(可选): 按照你喜欢的目录结构重新组织你的所有项目。</li><li>第四步: 在你项目的根目录下执行 <code>go mod init &lt;OPTIONAL_MODULE_PATH&gt;</code> 以生成 go.mod 文件。</li><li>第五步: 想办法说服你身边所有的人都去走一下前四步。</li></ul><h2 id="迁移后-go-get-行为的改变"><a href="#迁移后-go-get-行为的改变" class="headerlink" title="迁移后 go get 行为的改变"></a>迁移后 go get 行为的改变</h2><ul><li><p>用 <code>go help module-get</code> 和 <code>go help gopath-get</code>分别去了解 Go modules 启用和未启用两种状态下的 go get 的行为</p></li><li><p>用 </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span></span><br></pre></td></tr></table></figure><p> 拉取新的依赖</p><ul><li>拉取最新的版本(优先择取 tag)：<code>go get golang.org/x/text@latest</code></li><li>拉取 <code>master</code> 分支的最新 commit：<code>go get golang.org/x/text@master</code></li><li>拉取 tag 为 v0.3.2 的 commit：<code>go get golang.org/x/text@v0.3.2</code></li><li>拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：<code>go get golang.org/x/text@342b2e</code></li><li>用 <code>go get -u</code> 更新现有的依赖</li><li>用 <code>go mod download</code> 下载 go.mod 文件中指明的所有依赖</li><li>用 <code>go mod tidy</code> 整理现有的依赖</li><li>用 <code>go mod graph</code> 查看现有的依赖结构</li><li>用 <code>go mod init</code> 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)</li></ul></li><li><p>用 <code>go mod edit</code> 编辑 go.mod 文件</p></li><li><p>用 <code>go mod vendor</code> 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)</p></li><li><p>用 <code>go mod verify</code> 校验一个模块是否被篡改过</p></li></ul><p>这里我们注意到有两点比较特别，分别是：</p><ul><li>第一点：为什么 “拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2” 呢。这是因为虽然我们设置了拉取 @342b2e commit，但是因为 Go modules 会与 tag 进行对比，若发现对应的 commit 与 tag 有关联，则进行转换。</li><li>第二点：为什么不建议使用 <code>go mod vendor</code>，因为 Go modules 正在淡化 Vendor 的概念，很有可能 Go2 就去掉了。</li></ul><h2 id="使用-Go-Modules-时常遇见的坑"><a href="#使用-Go-Modules-时常遇见的坑" class="headerlink" title="使用 Go Modules 时常遇见的坑"></a>使用 Go Modules 时常遇见的坑</h2><h3 id="坑-1-判断项目是否启用了-Go-Modules"><a href="#坑-1-判断项目是否启用了-Go-Modules" class="headerlink" title="坑 1: 判断项目是否启用了 Go Modules"></a>坑 1: 判断项目是否启用了 Go Modules</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76259e244d232?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="坑-2-管理-Go-的环境变量"><a href="#坑-2-管理-Go-的环境变量" class="headerlink" title="坑 2: 管理 Go 的环境变量"></a>坑 2: 管理 Go 的环境变量</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76260c9b62f20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要是提到 Go1.13 新增了 <code>go env -w</code> 用于写入环境变量，而写入的地方是 <code>os.UserConfigDir</code> 所返回的路径，需要注意的是 <code>go env -w</code> 不会覆写。</p><h3 id="坑-3-从-dep、glide-等迁移至-Go-Modules"><a href="#坑-3-从-dep、glide-等迁移至-Go-Modules" class="headerlink" title="坑 3: 从 dep、glide 等迁移至 Go Modules"></a>坑 3: 从 dep、glide 等迁移至 Go Modules</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7626035b57218?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要是指从旧有的依赖包管理工具（dep/glide 等）进行迁移时，因为 BUG 的原因会导致不经过 GOPROXY 的代理，解决方法有如下两个：</p><ul><li>手动创建一个 go.mod 文件，再执行 go mod tidy 进行补充。</li><li>上代理，相当于不使用 GOPROXY 了。</li></ul><h3 id="坑-4-拉取私有模块"><a href="#坑-4-拉取私有模块" class="headerlink" title="坑 4:拉取私有模块"></a>坑 4:拉取私有模块</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625ca879e03a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要想涉及两块知识点，如下：</p><ul><li>GOPROXY 是无权访问到任何人的私有模块的，所以你放心，安全性没问题。</li><li>GOPROXY 除了设置模块代理的地址以外，还需要增加 “direct” 特殊标识才可以成功拉取私有库。</li></ul><h3 id="坑-5-更新现有的模块"><a href="#坑-5-更新现有的模块" class="headerlink" title="坑 5:更新现有的模块"></a>坑 5:更新现有的模块</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d76270adc1426d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="坑-6-主版本号"><a href="#坑-6-主版本号" class="headerlink" title="坑 6:主版本号"></a>坑 6:主版本号</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625ce242f466?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="Go-Module-Proxy-简介"><a href="#Go-Module-Proxy-简介" class="headerlink" title="Go Module Proxy 简介"></a>Go Module Proxy 简介</h2><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625db94698c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在这里再次强调了 Go Module Proxy 的作用（图左），以及其对应的协议交互流程（图右），有兴趣的小伙伴可以认真看一下。</p><h2 id="Goproxy-中国-goproxy-cn"><a href="#Goproxy-中国-goproxy-cn" class="headerlink" title="Goproxy 中国(goproxy.cn)"></a>Goproxy 中国(goproxy.cn)</h2><p>在这块主要介绍了  Goproxy 的实践操作以及 goproxy.cn 的一些 Q&amp;A 和 近况，如下：</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q：如果中国 Go 语言社区没有咱们自己家的 Go Module Proxy 会怎么样？</strong></p><p><strong>A：</strong>在 Go 1.13 中 GOPROXY 和 GOSUMDB 这两个环境变量都有了在中国无法 访问的默认值，尽管我在 golang.org/issue/31755 里努力尝 试过，但最终仍然无法为咱们中国的 Go 语言开发者谋得一个完美的解决方案。所以从今以后咱 们中国的所有 Go 语言开发者，只要是 使用了 Go modules 的，那么都必须先修改 GOPROXY 和 GOSUMDB 才能正常使用 Go 做开发，否则可能连一个最简单的程序都跑不起 来(只要它有依 赖第三方模 块)。</p><p><strong>Q： 我创建 Goproxy 中国(goproxy.cn)的主要原因？</strong></p><p><strong>A：</strong>其实更早的时候，也就是今年年初我也曾 试图在 golang.org/issue/31020 中请求 Go team 能想办法避免那时的 GOPROXY 即将拥有的默认值可以在中国正常访问，但 Go team 似乎也无能为力，为此我才坚定了创建 goproxy.cn 的信念。既然别人没法儿帮忙，那咱们就 得自己动手，不为别的，就为了让大家以后能够更愉快地使用 Go 语言配合 Go modules 做开发。</p><p>最初我先是和七牛云的 许叔(七牛云的 创始人兼 CEO 许式伟)提出了我打算 创建 goproxy.cn 的想法，本是抱着 试试看的目的，但没想 到 许叔几乎是没有超过一分钟的考虑便认可了我的想法并表示愿意一起推 动。那一阵子刚好赶上我在写毕业论文，所以项目开发完后就 一直没和七牛云做交接，一直跑在我的个人服 务器上。直到有一次 goproxy.cn 被攻击了，一下午的功夫 烧了我一百多美元，然后我才 意识到这种项目真不能个人来做。个人来做不靠 谱，万一依赖这个项目的人多了，项目再出什么事儿，那就会给大家􏰁成不必要的损 失。所以我赶紧和七牛云做了交接，把 goproxy.cn 完全交给了七牛云，甚至连域名都过户了去。</p><h3 id="近况"><a href="#近况" class="headerlink" title="近况"></a>近况</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625e53fc7ff9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>Goproxy 中国 (goproxy.cn) 是目前中国最可靠的 Go module proxy (真不是在自卖自夸)。</li><li>为中国 Go 语言开发者量身打􏰁，支持代理 GOSUMDB 的默认值，经过全球 CDN 加速，高可用，可 应用进公司复杂的开发环境中，亦可用作上游代理。</li><li>由中国倍受信赖的云服务提供商七牛云无偿提供基础设施支持的开源的非营利性项目。</li><li>目标是为中国乃至全世界的 Go 语言开发者提供一个免 费的、可靠的、持 续在线的且经过 CDN 加􏰀的 Go module proxy。</li><li>域名已由七牛云进行了备案 (沪ICP备11037377号-56)。</li></ul><h3 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h3><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625dbdfb4f03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>此处呈现的是存储大小，主要是针对模块包代码，而一般来讲代码并不会有多大，0-10MB，10-50MB 占最大头，也是能够理解，但是大于 100MB 的模块包代码就比较夸张了。</p><p><img alt="image" data-src="https://user-gold-cdn.xitu.io/2019/9/28/16d7625f82db3eba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>此时主要是展示了一下近期 goproxy.cn 的网络数据情况，我相信未来是会越来越高的，值得期待。</p><h2 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q：如何解决 Go 1.13 在从 GitLab 拉取模块版本时遇到的，Go 错误地按照非期望值的路径寻找目标模块版本结果致使最终目标模块拉取失败的问题？</strong></p><p><strong>A：</strong>GitLab 中配合 goget 而设置的 <code>&lt;meta&gt;</code> 存在些许问题，导致 Go 1.13 错误地识别了模块的具体路径，这是个 Bug，据说在 GitLab 的新版本中已经被修复了，详细内容可以看 <a href="https://github.com/golang/go/issues/34094" target="_blank" rel="external nofollow noopener noreferrer">github.com/golang/go/i…</a> 这个 Issue。然后目前的解决办法的话除了升级 GitLab 的版本外，还可以参考 <a href="https://github.com/developer-learning/night-reading-go/issues/468#issuecomment-535850154" target="_blank" rel="external nofollow noopener noreferrer">github.com/developer-l…</a> 这条回复。</p><p><strong>Q：使用 Go modules 时可以同时依赖同一个模块的不同的两个或者多个小版本（修订版本号不同）吗？</strong></p><p><strong>A：</strong>不可以的，Go modules 只可以同时依赖一个模块的不同的两个或者多个大版本（主版本号不同）。比如可以同时依赖 <code>example.com/foobar@v1.2.3</code> 和 <code>example.com/foobar/v2@v2.3.4</code>，因为他们的模块路径（module path）不同，Go modules 规定主版本号不是 v0 或者 v1 时，那么主版本号必须显式地出现在模块路径的尾部。但是，同时依赖两个或者多个小版本是不支持的。比如如果模块 A 同时直接依赖了模块 B 和模块 C，且模块 A 直接依赖的是模块 C 的 v1.0.0 版本，然后模块 B 直接依赖的是模块 C 的 v1.0.1 版本，那么最终 Go modules 会为模块 A 选用模块 C 的 v1.0.1 版本而不是模块 A 的 go.mod 文件中指明的 v1.0.0 版本。</p><p>这是因为 Go modules 认为只要主版本号不变，那么剩下的都可以直接升级采用最新的。但是如果采用了最新的结果导致项目 Break 掉了，那么 Go modules 就会 Fallback 到上一个老的版本，比如在前面的例子中就会 Fallback 到 v1.0.0 版本。</p><p><strong>Q：在 go.sum 文件中的一个模块版本的 Hash 校验数据什么情况下会成对出现，什么情况下只会存在一行？</strong></p><p><strong>A：</strong>通常情况下，在 go.sum 文件中的一个模块版本的 Hash 校验数据会有两行，前一行是该模块的 ZIP 文件的 Hash 校验数据，后一行是该模块的 go.mod 文件的 Hash 校验数据。但是也有些情况下只会出现一行该模块的 go.mod 文件的 Hash 校验数据，而不包含该模块的 ZIP 文件本身的 Hash 校验数据，这个情况发生在 Go modules 判定为你当前这个项目完全用不到该模块，根本也不会下载该模块的 ZIP 文件，所以就没必要对其作出 Hash 校验保证，只需要对该模块的 go.mod 文件作出 Hash 校验保证即可，因为 go.mod 文件是用得着的，在深入挖取项目依赖的时候要用。</p><p><strong>Q：能不能更详细地讲解一下 go.mod 文件中的 replace 动词的行为以及用法？</strong></p><p><strong>A：</strong>这个 replace 动词的作用是把一个“模块版本”替换为另外一个“模块版本”，这是“模块版本”和“模块版本（module path）”之间的替换，“=&gt;”标识符前面的内容是待替换的“模块版本”的“模块路径”，后面的内容是要替换的目标“模块版本”的所在地，即路径，这个路径可以是一个本地磁盘的相对路径，也可以是一个本地磁盘的绝对路径，还可以是一个网络路径，但是这个目标路径并不会在今后你的项目代码中作为你“导入路径（import path）”出现，代码里的“导入路径”还是得以你替换成的这个目标“模块版本”的“模块路径”作为前缀。</p><p>另外需要注意，Go modules 是不支持在 “导入路径” 里写相对路径的。举个例子，如果项目 A 依赖了模块 B，比如模块 B 的“模块路径”是 <code>example.com/b</code>，然后它在的磁盘路径是 <code>~/b</code>，在项目 A 里的 go.mod 文件中你有一行 <code>replace example.com/b=&gt;~/b</code>，然后在项目 A 里的代码中的“导入路基”就是 <code>import&quot;example.com/b&quot;</code>，而不是 <code>import&quot;~/b&quot;</code>，剩下的工作是 Go modules 帮你自动完成了的。</p><p>然后就是我在分享中也提到了， exclude 和 replace 这两个动词只作用于当前主模块，也就是当前项目，它所依赖的那些其他模块版本中如果出现了你待替换的那个模块版本的话，Go modules 还是会为你依赖的那个模块版本去拉取你的这个待替换的模块版本。</p><p>举个例子，比如项目 A 直接依赖了模块 B 和模块 C，然后模块 B 也直接依赖了模块 C，那么你在项目 A 中的 go.mod 文件里的 <code>replace c=&gt;~/some/path/c</code> 是只会影响项目 A 里写的代码中，而模块 B 所用到的还是你 replace 之前的那个 c，并不是你替换成的 <code>~/some/path/c</code> 这个。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.youtube.com/watch?v=F8nrpe0XWRg&amp;list=PLq2Nv-Sh8EbbIjQgDzapOFeVfv5bGOoPE&amp;index=3&amp;t=0s" target="_blank" rel="external nofollow noopener noreferrer">Russ Cox 介绍 go module背后的设计哲学</a></li><li><a href="https://go.googlesource.com/proposal/+/master/design/24301-versioned-go.md" target="_blank" rel="external nofollow noopener noreferrer">Go Module Proposal</a></li><li><a href="https://research.swtch.com/vgo" target="_blank" rel="external nofollow noopener noreferrer">vgo博客系列</a> </li><li><a href="https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/" target="_blank" rel="external nofollow noopener noreferrer">https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;包管理机制&quot;&gt;&lt;a href=&quot;#包管理机制&quot; class=&quot;headerlink&quot; title=&quot;包管理机制&quot;&gt;&lt;/a&gt;包管理机制&lt;/h2&gt;&lt;p&gt;Go 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。&lt;/p&gt;&lt;p&gt;从 v1.5 开始开始引入 vendor 包模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 vendor 内的包进行编译、测试等，这之后第三方的包管理思路都是通过这种方式来实现，比如说由社区维护准官方包管理工具 dep。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="go" scheme="http://houmin.cc/tags/go/"/>
    
      <category term="包管理系统" scheme="http://houmin.cc/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【Go语言设计与实现】同步原语</title>
    <link href="http://houmin.cc/posts/77ffac6b/"/>
    <id>http://houmin.cc/posts/77ffac6b/</id>
    <published>2020-08-05T04:18:30.000Z</published>
    <updated>2020-08-22T08:35:03.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。</p><p>本节会介绍 Go 语言中常见的同步原语 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 以及扩展原语 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>semaphore.Weighted</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>singleflight.Group</code></a> 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。</p><a id="more"></a><h2 id="基本原语"><a href="#基本原语" class="headerlink" title="基本原语"></a>基本原语</h2><p>Go 语言在 <a href="https://golang.org/pkg/sync/" target="_blank" rel="external nofollow noopener noreferrer"><code>sync</code></a> 包中提供了用于同步的一些基本原语，包括常见的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a>：</p><p><img alt="golang-basic-sync-primitives" data-src="https://img.draveness.me/2020-01-23-15797104327981-golang-basic-sync-primitives.png"></p><p>这些基本原语提高了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级的更高的 Channel 实现同步。</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Go 语言的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 由两个字段 <code>state</code> 和 <code>sema</code> 组成。其中 <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="keyword">int32</span></span><br><span class="line">sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放：</p><p><img alt="golang-mutex-state" data-src="https://img.draveness.me/2020-01-23-15797104328010-golang-mutex-state.png"></p><p>在默认情况下，互斥锁的所有状态位都是 <code>0</code>，<code>int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li><li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li><li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li><li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li></ul><h4 id="正常模式和饥饿模式"><a href="#正常模式和饥饿模式" class="headerlink" title="正常模式和饥饿模式"></a>正常模式和饥饿模式</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么，它们有什么样的关系。</p><p>在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被「饿死」。</p><p><img alt="golang-mutex-mode" data-src="https://img.draveness.me/2020-01-23-15797104328020-golang-mutex-mode.png"></p><p>饥饿模式是在 Go 语言 <a href="https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be" target="_blank" rel="external nofollow noopener noreferrer">1.9</a> 版本引入的优化<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#fn:1" target="_blank" rel="external nofollow noopener noreferrer">1</a>，引入的目的是保证互斥锁的公平性（Fairness）。</p><p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</p><p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p><h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h4><p>我们在这一节中将分别介绍互斥锁的加锁和解锁过程，它们分别使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 方法。</p><p>互斥锁的加锁是靠 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 完成的，最新的 Go 语言源代码中已经将 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 方法进行了简化，方法的主干只保留最常见、简单的情况 — 当锁的状态是 0 时，将 <code>mutexLocked</code> 位置成 1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果互斥锁的状态不是 0 时就会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L84-L171" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.lockSlow</code></a> 尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将该方法分成几个部分介绍获取锁的过程：</p><ol><li>判断当前 Goroutine 能否进入自旋；</li><li>通过自旋等待互斥锁的释放；</li><li>计算互斥锁的最新状态；</li><li>更新互斥锁的状态并获取锁；</li></ol><p>我们先来介绍互斥锁是如何判断当前 Goroutine 能否进入自旋等互斥锁的释放：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">starving := <span class="literal">false</span></span><br><span class="line">awoke := <span class="literal">false</span></span><br><span class="line">iter := <span class="number">0</span></span><br><span class="line">old := m.state</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ol><li><p>互斥锁只有在普通模式才能进入自旋；</p></li><li><p><code>sync.runtime_canSpin</code></p></li></ol><p>   需要返回</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>   ：</p><ol><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ol><p>一旦当前 Goroutine 能够进入自旋就会调用<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L5356-L5358" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_doSpin</code></a> 和 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L593-L599" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.procyield</code></a> 并执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">MOVLcycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">PAUSE</span><br><span class="line">SUBL$<span class="number">1</span>, AX</span><br><span class="line">JNZagain</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算了新的互斥锁状态之后，就会使用 CAS 函数 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L75" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.CompareAndSwapInt32</code></a> 更新该状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 通过 CAS 函数获取了锁</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们没有通过 CAS 获得锁，会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 使用信号量保证资源不会被两个 Goroutine 获取。<a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L72-L82" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Lock</code></a> 方法的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><p>互斥锁的解锁过程 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 与加锁过程相比就很简单，该过程会先使用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>AddInt32</code></a> 函数快速解锁，这时会发生下面的两种情况：</p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，这段代码会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L194-L226" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.unlockSlow</code></a> 方法开始慢速解锁：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L194-L226" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.unlockSlow</code></a> 方法首先会校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了就会直接抛出异常 <code>sync: unlock of unlocked mutex</code> 中止当前程序。</p><p>在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在正常模式下，这段代码会分别处理以下两种情况处理；<ul><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法就可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒等待者并移交锁的所有权；</li></ul></li><li>在饥饿模式下，上述代码会直接调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 方法将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们已经从多个方面分析了互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 的实现原理，在这里我们从加锁和解锁两个方面总结一下结论和注意事项。</p><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，就会直接通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 并且在普通模式下工作，就会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 函数将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒当前 Goroutine；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；</li></ul><p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p><ul><li>当互斥锁已经被解锁时，那么调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，就会直接返回；在其他情况下会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li></ul><h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><p>读写互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。</p><div class="table-container"><table><thead><tr><th></th><th>读</th><th>写</th></tr></thead><tbody><tr><td>读</td><td>Y</td><td>N</td></tr><tr><td>写</td><td>N</td><td>N</td></tr></tbody></table></div><p>一个常见的服务对资源的读写比例会非常高，因为大多数的读请求之间不会相互影响，所以我们可以读写资源操作的分离，在类似场景下提高服务的性能。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 中总共包含以下 5 个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">w           Mutex</span><br><span class="line">writerSem   <span class="keyword">uint32</span></span><br><span class="line">readerSem   <span class="keyword">uint32</span></span><br><span class="line">readerCount <span class="keyword">int32</span></span><br><span class="line">readerWait  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>w</code> — 复用互斥锁提供的能力；</li><li><code>writerSem</code> 和 <code>readerSem</code> — 分别用于写等待读和读等待写：</li><li><code>readerCount</code> 存储了当前正在执行的读操作的数量；</li><li><code>readerWait</code> 表示当写操作被阻塞时等待的读操作个数；</li></ul><p>我们会依次分析获取写锁和读锁的实现原理，其中：</p><ul><li>写操作使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L92-L110" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Lock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 方法；</li><li>读操作使用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RLock</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 方法；</li></ul><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><p>当资源的使用者想要获取写锁时，需要调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L92-L110" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Lock</code></a> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rw.w.Lock()</span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用结构体持有的</li></ol><p>   <code>sync.Mutex</code></p><p>   的</p><p>   <code>sync.Mutex.Lock</code></p><p>   方法阻塞后续的写操作；</p><ul><li>因为互斥锁已经被获取，其他 Goroutine 在获取写锁时就会进入自旋或者休眠；</li></ul><ol><li><p>调用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 方法阻塞后续的读操作：</p></li><li><p>如果仍然有其他 Goroutine 持有互斥锁的读锁（r != 0），该 Goroutine 会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 进入休眠状态等待所有读锁所有者执行结束后释放 <code>writerSem</code> 信号量将当前协程唤醒。</p></li></ol><p>写锁的释放会调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">throw(<span class="string">"sync: Unlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与加锁的过程正好相反，写锁的释放分以下几个执行：</p><ol><li>调用 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 函数将变回正数，释放读锁；</li><li>通过 for 循环触发所有由于获取读锁而陷入等待的 Goroutine：</li><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L179-L192" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex.Unlock</code></a> 方法释放写锁；</li></ol><p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』。</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><p>读锁的加锁方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L43-L56" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RLock</code></a> 很简单，该方法会通过 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 将 <code>readerCount</code> 加一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L70-L72" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li><li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法就会成功返回；</li></ol><p>当 Goroutine 想要释放读锁时，会调用如下所示的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">rw.rUnlockSlow(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会先减少正在读资源的 <code>readerCount</code> 整数，根据 <a href="https://github.com/golang/go/blob/ca7c12d4c9eb4a19ca5103ec5763537cccbcc13b/src/sync/atomic/doc.go#L93" target="_blank" rel="external nofollow noopener noreferrer"><code>atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p><ul><li>如果返回值大于等于零 — 读锁直接解锁成功；</li><li>如果返回值小于零 — 有一个正在执行的写操作，在这时会调用<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.rUnlockSlow</code></a> 方法；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">throw(<span class="string">"sync: RUnlock of unlocked RWMutex"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L77-L87" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.rUnlockSlow</code></a> 会减少获取锁的写操作等待的读操作数 <code>readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code>writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>读写互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex</code></a> 虽然提供的功能非常复杂，不过因为它建立在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 上，所以整体的实现上会简单很多。我们总结一下读锁和写锁的关系：</p><ul><li>调用</li></ul><p>  <code>sync.RWMutex.Lock</code></p><p>  尝试获取写锁时；</p><ul><li>每次 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L62-L75" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerWait</code> 其减一，当它归零时该 Goroutine 就会获得写锁；<ul><li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li></ul></li></ul><ul><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L118-L140" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li></ul><p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>我们可以通过 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 将原本顺序执行的代码在多个 Goroutine 中并发执行，加快程序处理的速度。</p><p><img alt="golang-syncgroup" data-src="https://img.draveness.me/2020-01-23-15797104328028-golang-syncgroup.png"></p><h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 结构体中的成员变量非常简单，其中只包含两个成员变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line">state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>noCopy</code> — 保证 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 不会被开发者通过再赋值的方式拷贝；</li><li><code>state1</code> — 存储着状态和信号量；</li></ul><p><a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 是一个特殊的私有结构体，<a href="http://golang.so/pkg/cmd/vendor/golang.org/x/tools/go/analysis/passes/copylock/" target="_blank" rel="external nofollow noopener noreferrer"><code>tools/go/analysis/passes/copylock</code></a> 包中的分析器会在编译期间检查被拷贝的变量中是否包含 <a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 结构体，如果包含该结构体就会在运行时报出以下错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">yawg := wg</span><br><span class="line">fmt.Println(wg, yawg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> vet proc.<span class="keyword">go</span></span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: assignment copies lock value to yawg: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">14</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br><span class="line">./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">18</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br></pre></td></tr></table></figure><p>这段代码会因为变量赋值或者调用函数时发生值拷贝导致分析器报错。</p><p>除了 <a href="https://github.com/golang/go/blob/c2eba53e7f80df21d51285879d51ab81bcfbf6bc/src/sync/cond.go#L94" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.noCopy</code></a> 字段之外，<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a>` 结构体中还包含一个总共占用 12 字节的数组，这个数组会存储当前结构体的状态，在 64 位与 32 位的机器上表现也非常不同。</p><p><img alt="golang-waitgroup-state" data-src="https://img.draveness.me/2020-01-23-15797104328035-golang-waitgroup-state.png"></p><p><strong>图 6-9 WaitGroup 在 64 位和 32 位机器的不同状态</strong></p><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 提供的私有方法 <a href="https://github.com/golang/go/blob/4c3f26076b6a9853bcc3c7d7e43726c044ac028a/src/sync/waitgroup.go#L32-L38" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.state</code></a> 能够帮我们从 <code>state1</code> 字段中取出它的状态和信号量。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 对外暴露了三个方法 — <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a>、<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a>。</p><p>因为其中的 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 只是向 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入了 -1，所以我们重点分析另外两个方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line"><span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">*statep = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法可以更新 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 中的计数器 <code>counter</code>。虽然 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，也就是所有任务都执行完成时，就会通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L65-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semrelease</code></a> 唤醒处于等待状态的所有 Goroutine。</p><p><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的另一个方法 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L55-L57" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.runtime_Semacquire</code></a> 陷入睡眠状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">state := atomic.LoadUint64(statep)</span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">runtime_Semacquire(semap)</span><br><span class="line"><span class="keyword">if</span> +statep != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"sync: WaitGroup is reused before previous Wait has returned"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的计数器归零时，当陷入睡眠状态的 Goroutine 就被唤醒，上述方法会立刻返回。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过对 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 的分析和研究，我们能够得出以下结论：</p><ul><li><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 必须在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li><li><a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 只是对 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</li><li>可以同时有多个 Goroutine 等待当前 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li></ul><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Go 语言标准库中 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。在运行如下所示的代码时，我们会看到如下所示的运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"only once"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">only once</span><br></pre></td></tr></table></figure><h4 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h4><p>每一个 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体中都只包含一个用于标识代码块是否执行过的 <code>done</code> 以及一个互斥锁 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">done <span class="keyword">uint32</span></span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 是 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：</p><ul><li>如果传入的函数已经执行过，就会直接返回；</li><li>如果传入的函数没有执行过，就会调用 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L61-L68" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.doSlow</code></a> 执行传入的函数：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">o.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为当前 Goroutine 获取互斥锁；</li><li>执行传入的无入参函数；</li><li>运行延迟函数调用，将成员变量 <code>done</code> 更新成 1；</li></ol><p><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 就会通过成员变量 <code>done</code> 确保函数不会执行第二次。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>作为用于保证函数执行次数的 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L12-L20" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a href="https://github.com/golang/go/tree/master/src/sync/atomic" target="_blank" rel="external nofollow noopener noreferrer"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p><ul><li><a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li><li>两次调用 <a href="https://github.com/golang/go/blob/bc593eac2dc63d979a575eccb16c7369a5ff81e0/src/sync/once.go#L40-L59" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Once.Do</code></a> 方法传入不同的函数也只会执行第一次调用的函数；</li></ul><h3 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h3><p>Go 语言标准库中的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 一个条件变量，它可以让一系列的 Goroutine 都在满足特定条件时被唤醒。每一个 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁，我们可以通过下面的例子了解它的使用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> listen(c)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, os.Interrupt)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Broadcast()</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Wait()</span><br><span class="line">fmt.Println(<span class="string">"listen"</span>)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">listen</span><br><span class="line">...</span><br><span class="line">listen</span><br></pre></td></tr></table></figure><p>上述代码同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情：</p><ul><li>10 个 Goroutine 通过 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 等待特定条件的满足；</li><li>1 个 Goroutine 会调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法通知所有陷入等待的 Goroutine；</li></ul><p>调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法后，上述代码会打印出 10 次 “listen” 并结束调用。</p><p><img alt="golang-cond-broadcast" data-src="https://img.draveness.me/2020-01-23-15797104328042-golang-cond-broadcast.png"></p><h4 id="结构体-3"><a href="#结构体-3" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 的结构体中包含以下 4 个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy  noCopy</span><br><span class="line">L       Locker</span><br><span class="line">notify  notifyList</span><br><span class="line">checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>noCopy</code> — 用于保证结构体不会在编译期间拷贝；</li><li><code>copyChecker</code> — 用于禁止运行期间发生的拷贝；</li><li><code>L</code> — 用于保护内部的 <code>notify</code> 字段，<code>Locker</code> 接口类型的变量；</li><li><code>notify</code> — 一个 Goroutine 的链表，它是实现同步机制的核心结构；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait <span class="keyword">uint32</span></span><br><span class="line">notify <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">lock mutex</span><br><span class="line">head *sudog</span><br><span class="line">tail *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.notifyList</code></a> 结构体中，<code>head</code> 和 <code>tail</code> 分别指向的链表的头和尾，<code>wait</code> 和 <code>notify</code> 分别表示当前正在等待的和已经通知到的 Goroutine，我们通过这两个变量就能确认当前待通知和已通知的 Goroutine。</p><h4 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 对外暴露的 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 方法会将当前 Goroutine 陷入休眠状态，它的执行过程分成以下两个步骤：</p><ol><li>调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L479-L483" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListAdd</code></a> 将等待计数器加一并解锁；</li><li>调用 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListWait</code></a> 等待其他 Goroutine 的唤醒并加锁：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">t := runtime_notifyListAdd(&amp;c.notify) <span class="comment">// runtime.notifyListAdd 的链接名</span></span><br><span class="line">c.L.Unlock()</span><br><span class="line">runtime_notifyListWait(&amp;c.notify, t) <span class="comment">// runtime.notifyListWait 的链接名</span></span><br><span class="line">c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L488-L518" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListWait</code></a> 函数会获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">s := acquireSudog()</span><br><span class="line">s.g = getg()</span><br><span class="line">s.ticket = t</span><br><span class="line"><span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">l.head = s</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.tail.next = s</span><br><span class="line">&#125;</span><br><span class="line">l.tail = s</span><br><span class="line">goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了将当前 Goroutine 追加到链表的末端之外，我们还会调用 <a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/proc.go#L309-L311" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.goparkunlock</code></a> 将当前 Goroutine 陷入休眠状态，该函数也是在 Go 语言切换 Goroutine 时经常会使用的方法，它会直接让出当前处理器的使用权并等待调度器的唤醒。</p><p><img alt="golang-cond-notifylist" data-src="https://img.draveness.me/2020-01-23-15797104328049-golang-cond-notifylist.png"></p><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 和 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法就是用来唤醒调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 陷入休眠的 Goroutine，它们两个的实现有一些细微差别：</p><ul><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 方法会唤醒队列最前面的 Goroutine；</li><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 方法会唤醒队列中全部的 Goroutine；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.checker.check()</span><br><span class="line">runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L554-L604" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListNotifyOne</code></a> 函数只会从 <a href="https://github.com/golang/go/blob/41cb0aedffdf4c5087de82710c4d016a3634b4ac/src/sync/runtime.go#L33-L39" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.notifyList</code></a> 链表中找到满足 <code>sudog.ticket == l.notify</code> 条件的 Goroutine 并通过 <code>readyWithTime</code> 唤醒：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">t := l.notify</span><br><span class="line">atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line"><span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">n := s.next</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">p.next = n</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.head = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">l.tail = p</span><br><span class="line">&#125;</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L522-L550" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.notifyListNotifyAll</code></a> 会依次通过 <a href="https://github.com/golang/go/blob/a4c579e8f7c8129b2c27779f206ebd2c9b393633/src/runtime/sema.go#L79-L84" target="_blank" rel="external nofollow noopener noreferrer"><code>runtime.readyWithTime</code></a> 函数唤醒链表中 Goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">s := l.head</span><br><span class="line">l.head = <span class="literal">nil</span></span><br><span class="line">l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">next := s.next</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">s = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的 Goroutine 需要等待调度器的调度。</p><p>在一般情况下，我们都会先调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 或者 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 不是一个常用的同步机制，在遇到长时间条件无法满足时，与使用 <code>for {}</code> 进行忙碌等待相比，<a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L21-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond</code></a> 能够让出处理器的使用权。在使用的过程中我们需要注意以下问题：</p><ul><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L52-L58" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Wait</code></a> 方法在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L64-L67" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Signal</code></a> 方法唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li><li><a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/sync/cond.go#L73-L76" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li></ul><h2 id="扩展原语"><a href="#扩展原语" class="headerlink" title="扩展原语"></a>扩展原语</h2><p>除了标准库中提供的同步原语之外，Go 语言还在子仓库 <a href="https://github.com/golang/sync" target="_blank" rel="external nofollow noopener noreferrer">sync</a> 中提供了四种扩展原语，<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/syncmap/go19.go#L17" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/syncmap.Map</code></a>，其中的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/syncmap/go19.go#L17" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/syncmap.Map</code></a> 在 1.9 版本中被移植到了标准库中。</p><p><img alt="golang-extension-sync-primitives" data-src="https://img.draveness.me/2020-01-23-15797104328056-golang-extension-sync-primitives.png"></p><p>本节会介绍 Go 语言在扩展包中提供的三种同步原语，也就是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a>、<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a>。</p><h3 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="ErrGroup"></a>ErrGroup</h3><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 就为我们在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能，我们可以使用如下所示的方式并行获取网页的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    url := urls[i]</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        resp, err := http.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            resp.Body.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Successfully fetched all URLs."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L51-L66" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Go</code></a> 方法能够创建一个 Goroutine 并在其中执行传入的函数，而 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L39-L45" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Wait</code></a> 会等待所有 Goroutine 全部返回，该方法的不同返回结果也有不同的含义：</p><ul><li>如果返回错误 — 这一组 Goroutine 最少返回一个错误；</li><li>如果返回空值 — 所有 Goroutine 都成功执行；</li></ul><h4 id="结构体-4"><a href="#结构体-4" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体同时由三个比较重要的部分组成：</p><ol><li><code>cancel</code> — 创建 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 时返回的取消函数，用于在多个 Goroutine 之间同步取消信号；</li><li><code>wg</code> — 用于等待一组 Goroutine 完成子任务的同步原语；</li><li><code>errOnce</code> — 用于保证只接收一个子任务返回的错误；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些字段共同组成了 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体并为我们提供同步、错误传播以及上下文取消等功能。</p><h4 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h4><p>我们能通过 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L32-L35" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.WithContext</code></a> 构造器创建新的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="params">(*Group, context.Context)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行新的并行子任务需要使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L51-L66" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Go</code></a> 方法，这个方法的执行过程如下：</p><ol><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L53-L95" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Add</code></a> 增加待处理的任务；</li><li>创建一个新的 Goroutine 并在 Goroutine 内部运行子任务；</li><li>返回错误时及时调用 <code>cancel</code> 并对 <code>err</code> 赋值，只有最早返回的错误才会被上游感知到，后续的错误都会被舍弃：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Go</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">g.wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> g.wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">g.errOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.err = err</span><br><span class="line"><span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">g.cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Wait</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">g.wg.Wait()</span><br><span class="line"><span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">g.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个用于等待的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L39-L45" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group.Wait</code></a> 方法只是调用了 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a>，在子任务全部完成时取消 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 并返回可能出现的错误。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 的实现没有涉及底层和运行时包中的 API，它只是对基本同步语义进行了封装以提供更加复杂的功能。在使用时，我们也需要注意以下的几个问题：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/errgroup.Group</code></a> 在出现错误或者等待结束后都会调用 <a href="https://github.com/golang/go/blob/71bbffbc48d03b447c73da1f54ac57350fc9b36a/src/context/context.go#L62-L154" target="_blank" rel="external nofollow noopener noreferrer"><code>context.Context</code></a> 的 <code>cancel</code> 方法同步取消信号；</li><li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃；</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。</p><ul><li>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来；</li><li>当遇到计数器大于信号量大小时就会进入休眠等待其他线程释放信号；</li></ul><p>Go 语言的扩展包中就提供了带权重的信号量 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a>，我们可以按照不同的权重对资源的访问进行管理，这个结构体对外也只暴露了四个方法：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L21-L24" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.NewWeighted</code></a> 用于创建新的信号量；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 阻塞地获取指定权重的资源，如果当前没有空闲资源，就会陷入休眠等待；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 非阻塞地获取指定权重的资源，如果当前没有空闲资源，就会直接返回 <code>false</code>；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 用于释放指定权重的资源；</li></ul><h4 id="结构体-5"><a href="#结构体-5" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L21-L24" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.NewWeighted</code></a> 方法能根据传入的信号量最大权重创建一个 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 结构体指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWeighted</span><span class="params">(n <span class="keyword">int64</span>)</span> *<span class="title">Weighted</span></span> &#123;</span><br><span class="line">w := &amp;Weighted&#123;size: n&#125;</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">size    <span class="keyword">int64</span></span><br><span class="line">cur     <span class="keyword">int64</span></span><br><span class="line">mu      sync.Mutex</span><br><span class="line">waiters list.List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 结构体中包含一个 <code>waiters</code> 列表，其中存储着等待获取资源的 Goroutine，除此之外它还包含当前信号量的上限以及一个计数器 <code>cur</code>，这个计数器的范围就是 [0, size]：</p><p><img alt="golang-semaphore" data-src="https://img.draveness.me/2020-01-23-15797104328063-golang-semaphore.png"></p><p><strong>图 6-11 权重信号量</strong></p><p>信号量中的计数器会随着用户对资源的访问和释放进行改变，引入的权重概念能够提供更细粒度的资源的访问控制，尽可能满足常见的用例。</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 方法能用于获取指定权重的资源，这个方法总共由三个不同的情况组成：</p><ol><li>当信号量中剩余的资源大于获取的资源并且没有等待的 Goroutine 时就会直接获取信号量；</li><li>当需要获取的信号量大于 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted</code></a> 的上限时，由于不可能满足条件就会直接返回错误；</li><li>遇到其他情况时会将当前 Goroutine 加入到等待列表并通过 <code>select</code> 等待调度器唤醒当前 Goroutine，Goroutine 被唤醒后就会获取信号量；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">s.cur += n</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">elem := s.waiters.PushBack(w)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">err := ctx.Err()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ready:</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">s.waiters.Remove(elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">case</span> &lt;-ready:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个用于获取信号量的方法 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 只会非阻塞地判断当前信号量是否有充足的资源，如果有充足的资源就会直接立刻返回 <code>true</code>，否则就会返回 <code>false</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">TryAcquire</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line">success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> success &#123;</span><br><span class="line">s.cur += n</span><br><span class="line">&#125;</span><br><span class="line">s.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 不会等待资源的释放，所以可能更适用于一些延时敏感、用户需要立刻感知结果的场景。</p><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>当我们要释放信号量时，<a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法会从头到尾遍历 <code>waiters</code> 列表中全部的等待者，如果释放资源后的信号量有充足的剩余资源就会通过 Channel 唤起指定的 Goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line">s.cur -= n</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">next := s.waiters.Front()</span><br><span class="line"><span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">w := next.Value.(waiter)</span><br><span class="line"><span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">s.cur += w.n</span><br><span class="line">s.waiters.Remove(next)</span><br><span class="line"><span class="built_in">close</span>(w.ready)</span><br><span class="line">&#125;</span><br><span class="line">s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可能会出现剩余资源无法唤起 Goroutine 的情况，在这时当前方法就会释放锁后直接返回。</p><p>通过对 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法的分析我们能发现，如果一个信号量需要的占用的资源非常多，它可能会长时间无法获取锁，这也是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 方法引入上下文参数的原因，为信号量的获取设置超时时间。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>带权重的信号量确实有着更多的应用场景，这也是 Go 语言对外提供的唯一一种信号量实现，在使用的过程中我们需要注意以下的几个问题：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L40-L78" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Acquire</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L82-L90" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.TryAcquire</code></a> 方法都可以用于获取资源，前者会阻塞地获取信号量，后者会非阻塞地获取信号量；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 方法会按照 FIFO 的顺序唤醒可以被唤醒的 Goroutine；</li><li>如果一个 Goroutine 获取了较多地资源，由于 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L93-L127" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/semaphore.Weighted.Release</code></a> 的释放策略可能会等待比较长的时间；</li></ul><h3 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight"></a>SingleFlight</h3><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 是 Go 语言扩展包中提供了另一种同步原语，它能够在一个服务中抑制对下游的多次重复请求。一个比较常见的使用场景是 — 我们在使用 Redis 对数据库中的数据进行缓存，发生缓存击穿时，大量的流量都会打到数据库上进而影响服务的尾延时。</p><p><img alt="golang-query-without-single-flight" data-src="https://img.draveness.me/2020-01-23-15797104328070-golang-query-without-single-flight.png"></p><p><strong>图 6-12 Redis 缓存击穿问题</strong></p><p>但是 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 能有效地解决这个问题，它能够限制对同一个 <code>Key</code> 的多次重复请求，减少对下游的瞬时流量。</p><p><img alt="golang-extension-single-flight" data-src="https://img.draveness.me/2020-01-23-15797104328078-golang-extension-single-flight.png"></p><p><strong>图 6-13 缓解缓存击穿问题</strong></p><p>在资源的获取非常昂贵时（例如：访问缓存、数据库），就很适合使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 对服务进行优化。我们来了解一下它的使用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    requestGroup singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context, request Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    v, err, _ := requestGroup.Do(request.Hash(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        rows, err := <span class="comment">// select * from tables</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response&#123;</span><br><span class="line">        rows: rows,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为请求的哈希在业务上一般表示相同的请求，所以上述代码使用它作为请求的键。当然，我们也可以选择其他的唯一字段作为 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 方法的第一个参数减少重复的请求。</p><h4 id="结构体-6"><a href="#结构体-6" class="headerlink" title="结构体"></a>结构体</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 结构体由一个互斥锁<a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.Mutex</code></a> 和一个映射表组成，每一个 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体都保存了当前调用对应的信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err error</span><br><span class="line"></span><br><span class="line">dups  <span class="keyword">int</span></span><br><span class="line">chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体中的 <code>val</code> 和 <code>err</code> 字段都只会在执行传入的函数时赋值一次并在 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 返回时被读取；<code>dups</code> 和 <code>chans</code> 两个字段分别存储了抑制的请求数量以及用于同步结果的 Channel。</p><h4 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h4><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 提供了两个用于抑制相同请求的方法：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> — 同步等待的方法 <code>Do</code>；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> — 返回 Channel 异步等待的方法；</li></ul><p>这两个方法在功能上没有太多的区别，只是在接口的表现上稍有不同。</p><p>每次调用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 方法时都会获取互斥锁，随后判断是否已经存在 <code>key</code> 对应的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体：</p><ol><li>当不存在对应的</li></ol><p>   <code>x/sync/singleflight.call</code></p><p>   时：</p><ol><li>初始化一个新的 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体指针；</li><li>增加 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup</code></a> 持有的计数器；</li><li>将 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L12-L29" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.call</code></a> 结构体指针添加到映射表；</li><li>释放持有的互斥锁；</li><li>阻塞地调用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 方法等待结果的返回；</li></ol><ol><li>当存在对应的</li></ol><p>   <code>x/sync/singleflight.call</code></p><p>   时；</p><ol><li>增加 <code>dups</code> 计数器，它表示当前重复的调用次数；</li><li>释放持有的互斥锁；</li><li>通过 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 等待请求的返回；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">c.dups++</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">c.wg.Wait()</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">c := <span class="built_in">new</span>(call)</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">g.doCall(c, key, fn)</span><br><span class="line"><span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>val</code> 和 <code>err</code> 两个字段都只会在 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 方法中赋值，所以当 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L96-L108" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.doCall</code></a> 和 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L103-L141" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Wait</code></a> 返回时，函数调用的结果和错误都会返回给 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 函数的调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">doCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line">c.val, c.err = fn()</span><br><span class="line">c.wg.Done()</span><br><span class="line"></span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(g.m, key)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>运行传入的函数 <code>fn</code>，该函数的返回值就会赋值给 <code>c.val</code> 和 <code>c.err</code>；</li><li>调用 <a href="https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L98-L100" target="_blank" rel="external nofollow noopener noreferrer"><code>sync.WaitGroup.Done</code></a> 方法通知所有等待结果的 Goroutine — 当前函数已经执行完成，可以从 <code>call</code> 结构体中取出返回值并返回了；</li><li>获取持有的互斥锁并通过管道将信息同步给使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 方法的 Goroutine；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">DoChan</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) &lt;-<span class="title">chan</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">g.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">c.dups++</span><br><span class="line">c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line">g.m[key] = c</span><br><span class="line">g.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 方法分别提供了同步和异步的调用方式，这让我们使用起来也更加灵活。</p><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>当我们需要减少对下游的相同请求时，就可以使用 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 来增加吞吐量和服务质量，不过在使用的过程中我们也需要注意以下的几个问题：</p><ul><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L51-L69" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Do</code></a> 和 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L73-L93" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.DoChan</code></a> 一个用于同步阻塞调用传入的函数，一个用于异步调用传入的参数并通过 Channel 接收函数的返回值；</li><li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L113-L120" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group.Forget</code></a> 方法可以通知 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="external nofollow noopener noreferrer"><code>x/sync/singleflight.Group</code></a> 在持有的映射表中删除某个键，接下来对该键的调用就不会等待前面的函数返回了；</li><li>一旦调用的函数返回了错误，所有在等待的 Goroutine 也都会接收到同样的错误；</li></ul><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>我们在这一节中介绍了 Go 语言标准库中提供的基本原语以及扩展包中的扩展原语，这些并发编程的原语能够帮助我们更好地利用 Go 语言的特性构建高吞吐量、低延时的服务、解决并发带来的问题。</p><p>在设计同步原语时，我们不仅要考虑 API 接口的易用、解决并发编程中可能遇到的线程竞争问题，还需要对尾延时进行、优化保证公平性，理解同步原语也是我们理解并发编程无法跨越的一个步骤。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li>“sync: allow inlining the Mutex.Lock fast path” <a href="https://github.com/golang/go/commit/41cb0aedffdf4c5087de82710c4d016a3634b4ac" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/commit/41cb0aedffdf4c5087de82710c4d016a3634b4ac</a></li><li>“sync: allow inlining the Mutex.Unlock fast path” <a href="https://github.com/golang/go/commit/4c3f26076b6a9853bcc3c7d7e43726c044ac028a#diff-daec021895d1400f2c064a3e851c0d2c" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/commit/4c3f26076b6a9853bcc3c7d7e43726c044ac028a#diff-daec021895d1400f2c064a3e851c0d2c</a></li><li>“runtime: fall back to fair locks after repeated sleep-acquire failures” <a href="https://github.com/golang/go/issues/13086" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/golang/go/issues/13086</a></li><li>Go Team. May 2014. “The Go Memory Model” <a href="https://golang.org/ref/mem" target="_blank" rel="external nofollow noopener noreferrer">https://golang.org/ref/mem</a></li><li>Chris. May 2017. “The X-Files: Exploring the Golang Standard Library Sub-Repositories” <a href="https://rodaine.com/2017/05/x-files-intro/" target="_blank" rel="external nofollow noopener noreferrer">https://rodaine.com/2017/05/x-files-intro/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。&lt;/p&gt;
&lt;p&gt;本节会介绍 Go 语言中常见的同步原语 &lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/mutex.go#L25-L28&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.Mutex&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/rwmutex.go#L28-L34&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.RWMutex&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/waitgroup.go#L20-L29&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/once.go#L12-L20&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.Once&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/golang/go/blob/71239b4f491698397149868c88d2c851de2cd49b/src/sync/cond.go#L21-L29&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;sync.Cond&lt;/code&gt;&lt;/a&gt; 以及扩展原语 &lt;a href=&quot;https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;errgroup.Group&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;semaphore.Weighted&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;&lt;code&gt;singleflight.Group&lt;/code&gt;&lt;/a&gt; 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="Go" scheme="http://houmin.cc/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://houmin.cc/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="并发" scheme="http://houmin.cc/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
