<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Houmin</title>
  
  <subtitle>Yesterday You Said Tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://houmin.cc/"/>
  <updated>2020-12-31T15:54:36.389Z</updated>
  <id>http://houmin.cc/</id>
  
  <author>
    <name>Houmin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 渺小</title>
    <link href="http://houmin.cc/posts/9d4b744a/"/>
    <id>http://houmin.cc/posts/9d4b744a/</id>
    <published>2020-12-31T14:47:19.000Z</published>
    <updated>2020-12-31T15:54:36.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>当写下 <a href="https://houmin.cc/posts/2ecc368">2019 未来へ</a> 的时候，我没有意识到2020年将会发生什么。那时的我是轻松惬意的，文字里透露着面向未来的自信，期冀着能够做出自己的改变。一年过去了，咻的一下，很快，生活中的种种已经发生了改变。2020 年发生的种种让我更加意识到到自身的渺小与浅陋，绝大多数时候你改变不了什么，你能确定改变的只能是自己，尽管这并不简单。</p><p>这里是 「岁末围炉」系列的第二篇 <code>2020 渺小</code>，主题曲选择的是田馥甄的渺小，封面图来自冬日的雍和宫。 2020 年结束了，渺小的我依然在构建自己的框架，向着生命，向着未来。</p>    <div id="aplayer-UMydVDDJ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="27968284" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="世界你好"><a href="#世界你好" class="headerlink" title="世界你好"></a>世界你好</h2><p>有人说，2020 年是这些年来最糟糕的一年，2020年是见证历史的一年，正如时代周刊在年底的一期杂志封面所提到的一样：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-14_time-2020-cover.jpg"></p><ul><li>年初，美军定点清除伊朗名将之花苏莱曼尼，美伊爆发克制性冲突，伊朗导弹误击乌克兰民航客机，176人死亡</li><li>年初，新冠疫情在武汉爆发，李文亮之死引发全国震动，武汉封城，全国驰援下湖北控制住疫情，中国控制住疫情</li><li>然而，疫情继续在全球爆发，截止2020年底全球累计确诊人数到达8000万人，累计死亡人数180万人，东京奥运会延期</li><li>因为新冠疫情的爆发，全球经济衰退，年初美股四次熔断，历史罕见负油价，在美联储持续降息放水下，美股在下半年一路长红</li><li>美国黑人佛洛伊德被警察跪杀，引发美国几十年来规模最大的反种族歧视、反暴力执法抗议，BLM运动下，众多历史雕像被摧毁</li><li>美国2020年大选跌宕起伏，拜登最终赢得大选，但特朗普所代表的群众依然广泛，美国党派冲突、阶层冲突矛盾进一步激化</li><li>中美贸易冲突进一步加剧，美国封杀TikTok、微信等企业，中美互关总领事馆</li><li>互联网行业整治监管趋紧，蚂蚁金服暂停上市，阿里、腾讯、顺丰被罚，巨头入局社区团购引发争议，蛋壳公寓暴雷</li><li>……</li></ul><p>所有的这些事件中，新冠疫情是影响最大的因素。事实证明，与非典不同，我们已经不能指望它在夏天凭空消失，我们所能依靠的只有疫苗。尽管在国内疫情已经得到了控制，但是全球疫情仍然严重，在未来的两年里，它仍将一直围绕着我们，各国之间仍然不能自由通航，以前的那种人员自由流动已经成为一种奢望。伴随着疫情，全球经济持续衰退，有可能造成甚于2008年的全球经济大危机，贫富差距加大，阶层矛盾进一步激化，民粹主义进一步发展。</p><p>显而易见的是，这个世界的情况没有在变好，而在过去十年间进一步恶化，08年以来的次贷危机和欧债危机造成的负面影响至今都还没有完全释放。在没有新的技术革新发生的情况下，未来的环境还会更差，战争的发生不是没有可能。所以，在天灾、疫情、战争带来的威胁下，我们能够做什么呢？我们什么都做不了，在这些面前我们只是渺小的蝼蚁。我们能够做的，就是尝试去理解世界，完善自己。</p><h2 id="行为框架"><a href="#行为框架" class="headerlink" title="行为框架"></a>行为框架</h2><p>在过去的一年，我一直在尝试去更好地理解自己的行为模式，去记录数据，去分析数据，去更新自己的模型。尽管还没有达到我想要的效果，但是我明显地感觉到，<code>I&#39;m on my way</code>。这种记录与分析里最重要的一种表达方式，就是我给自己建立的这个站点，或者也可以说是我的个人博客。虽然除了个人博客，我还想在这个站点记录更多的东西，不过不管怎么样我们可以慢慢来。如你所见，在<a href="https://houmin.cc/about/"> <code>houmin.cc</code></a>，我创建了几个不同的栏目用于定期的去总结、去梳理生活与学习工作中碰到的问题。</p><p>除了一年一度的 <a href="https://houmin.cc/categories/岁末围炉">岁末围炉</a>，另一个重要的专栏就是 <a href="https://houmin.cc/categories/朝花夕拾">朝花夕拾</a> 了。「朝花夕拾」是我给自己安排的每周总结，2020年第一期是 <a href="https://houmin.cc/posts/3e030bdb/">Carpe Diem</a>，最后一期是 <a href="https://houmin.cc/posts/64c2f65e">十字路口</a>。尽管号称每周更新，期间不乏拖更与断更，下面是2020年的「朝花夕拾」发布记录。可以看到，到2020年结束，朝花夕拾总共发布了29期。如果每周按照正常发布的节奏（以及排除年终/生日那周），总计应该有50期。尽管只是刚刚超过预期的一半，令我高兴的是整个「朝花夕拾」的框架已经建立。</p><div id="echarts4085" style="width: 100%;height: 600px;margin: 0 auto"></div><script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script><script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('echarts4085'));  // 指定图表的配置项和数据  option = {    title: {        text: '朝花夕拾'    },    tooltip: {        trigger: 'axis',        axisPointer: {            type: 'cross',            crossStyle: {                color: '#999'            }        }    },    toolbox: {        feature: {            dataView: {show: true, readOnly: false},            magicType: {show: true, type: ['line', 'bar']},            restore: {show: true},            saveAsImage: {show: true}        }    },    legend: {        data: ['单月发布', '累计发布']    },    xAxis: [        {            type: 'category',            data:  ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'],            axisPointer: {                type: 'shadow'            }        }    ],    yAxis: [        {            type: 'value',            name: '单月发布',            min: 0,            max: 4,            interval: 4,            axisLabel: {                formatter: '{value} 篇'            }        },        {            type: 'value',            name: '累计发布',            min: 0,            max: 50,            interval: 4,            axisLabel: {                formatter: '{value} 篇'            }        }    ],    series: [        {            name: '单月发布',            type: 'bar',            data: [3, 4, 4, 4, 1, 1, 4, 1, 0, 0, 4, 3],        },        {            name: '累计发布',            type: 'line',            yAxisIndex: 1,            data: [3, 7, 11, 15, 16, 17, 21, 22, 22, 22, 26, 29],        }    ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);</script><p>看看那些没能够定期发布的时间段，我依稀还能想到当时发生了什么。五月和六月，因为面临毕业论文答辩，没有花太多的时间在博客上，7月份入职后，在八月、九月和十月基本上都在消化吸收工作中涉及到的知识点，你可以看到那段时间我在 「术业专攻」中发布了很多专业内容的笔记。如果没有十一月的回归正常发布，今年的曲线将会很难看。</p><p>按照我多年来新年计划失效的经验（如果说这次朝花夕拾没能够完全按期发布也算是一次失败经验的话），如果没有定期的回顾与总结，一旦某段时间放松自己，偏离目标，就会因为破窗效应索性放弃了整个一年的计划。一方面是缺少定期的回顾，另外一方面是自己设定的计划完成时间粒度太粗，一旦某段时间放弃则全盘放弃，正如我年初在 <a href="https://houmin.cc/posts/c924112f">Do You Want To Build A Snowman?</a> 这篇博文中提到的一样。</p><p>现在回过头看，非常庆幸自己在2019年底有一段空闲时间给自己建立了一个框架，并在后续的日子里能够坚持实践。也许没有完全达到我期待中的效果，至少框架已经初具模型。事实上，早在16年的时候我就创建过自己的个人网站，也比较早的意识到博客系统可能会对我产生的帮助。然而（按照我现在的理解），正是因为没有建立一个好的可以执行下去的框架，导致当年创建的博客两次中断，在后续的日子里也没有留下多少有价值的记录。我也曾经建立过自己的 wiki 平台，但是因为项目维护和数据的获取更新等问题没有坚持下去。现在的这种框架对于我来说是最好的方式。</p><p>建立框架对于知识体系的构建产生帮助的最为典型的一个例子是，「术业专攻」这个栏目的建立与文章发布。在年初的时候，我在  <a href="https://houmin.cc/posts/c924112f">Do You Want To Build A Snowman?</a> 这篇博文讨论过个人知识管理的话题，当时得到的几个明确结论是：</p><ul><li>Data、Information、Knowledge、Wisdom这几个概念之间有着明显的区别，看到数据并不等于获取信息，阅读博客和书籍并不等同于学会了知识，知道了知识并不等同于掌握了智慧</li><li>提高知识获取效率最好的方法是主动去搜索资料，而不是被动的在信息流中流于表面的学习</li><li>只靠搜索不能内化知识，虽然可能在某个地方能够看到这些知识，但他们永远不是你的</li><li>只靠把知识存储在文件夹或笔记中，而不去花时间整理它们不能内化知识，你需要通过自己的整理去建立索引，方便以后更好的调用这些知识</li><li>图像、思维导图、定期回顾复习、向他人表述能够更好的帮助知识内化</li></ul><p>结合这几个结论，当前我的博客系统就是我最好的知识管理工具，也是我自己的笔记系统。截止2020年底，我在「术业专攻」总共发布了90篇博文，其中大部分是我在专业内容上的笔记总结。目前原创性的内容还比较少，更多的是在做笔记、做梳理、做总结。通过在发布博文的过程中，我会去结合自身的理解去消化吸收这些内容，在我的知识体系中构建自己的索引。在这个过程中，我越发体会到自己的浅陋，除了发布的这些博文，还有很多那些还没来得及被消化和发布的内容存在我的草稿箱中。在过去的一年中，我还剩下 300+ 的博文没有发布，这需要大量的时间去消化吸收。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-19_hexo-drafts.png"></p><p>这是一个动态增长的过程，每每在工作中碰到一些新的知识点，我会去搜索相关的资料并保存于草稿箱中。保存于草稿箱并不等同于我消化吸收了对应的内容，我还需要去按照自己的思维脉络，整理出属于自己的文章。之后再碰到对应的问题后，我就可以很好的在自己的知识体系中定位问题，索引出相关知识点。即使短暂的不记住了，我也可以再来博客系统来回顾。</p><p>除了专业相关的内容，我还根据自己的兴趣点，建立了 <a href="https://houmin.cc/categories/资本不眠">「资本不眠」</a>、<a href="https://houmin.cc/categories/好奇计划">「好奇计划」</a> 等栏目，用于记录专业内容之外的那些有意思的内容，并且可能还会去进一步扩展更多的栏目。记录、消化、总结、思考、时间、提高，是获取知识、创造新知识的最好办法，而 <code>houmin.cc</code> 就是我在这上面最好的框架与平台。</p><p>根据我前面一以贯之的理念，为了更好的成长，我们需要用数据去量化成长的指标，从而进一步反思与优化自己的行为模式。对于我这个系统最基础的框架也是一样，我们也需要数据去衡量这个框架的进步与效果。也就是说，你如何反映出你的框架在实际work，你如何知道自己的产出是否有实际意义，作为一个网站，我给他最明确的指标就是网站搜索与访问量。</p><p>听起来有点像运营微信微博等新媒体账号，对于你运营的网站，你期待的指标就是他的点击量和访问量获得显著提升。但是，与微信微博稍微有点不同的是，我的网站将完全基于搜索获取流量，而不是依赖于社交网络的传播。一方面我不得不承认，我现在网站中的很多内容还很粗浅，还不足以吸引人们在社交网络中传播它；另一方面，与我前面提到的知识管理理念相匹配，应该是人找信息，而不是信息找人，我们才是信息获取的发起方，通过搜索得到的内容将发挥更大的作用。</p><p>下图是 <code>houmin.cc</code> 在过去一年来的搜索数据，尽管目前网站的日均访问量仍然很小很小，但是已经可以看到相比于2019年的日均访问量已经有了一个量级的提高。未来的一年，给自己定下的一个目标是，要进一步修正和完善这个框架，创作更多有价值的内容。当我们实现这个目标后，可以看到的一个效果是，这个站点的日均访问量将进一步提升一个量级。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-31_site-google-search.png"></p><p>虽然在这里对访问量提出了一定的指标，更关键的是要提高自己网站内容的质量，输出有价值的内容，提高自己的影响力。这里提出这样的目标，源自于之前在网络上搜索问题时，碰见的那些 <a href="https://houmin.cc/links">有意思的站点</a> 。他们的博客记录着他们的思考，记录着那些有价值的内容，是我想要实现的目标。</p><h2 id="好好工作"><a href="#好好工作" class="headerlink" title="好好工作"></a>好好工作</h2><p>2020年7月，我从学校进入职场，开始了正式的职场生活。半年的工作让我对自己未来的期待，对当前的不足有了更加清晰的认识。经过几段实习经历和半年的工作经历，你已经见证了各种各样的前辈，你也看到了作为一个专业的技术工程师应该具备的能力。2021年，继续好好工作，扩展自己的深度和广度，加油！</p><div class="table-container"><table><thead><tr><th>考察指标</th><th>具体指标</th><th>实践改进方式</th></tr></thead><tbody><tr><td>技术实力</td><td>掌握扎实的底层技术原理，包括 kubernetes、linux、网络、Go语言等方面</td><td>「术业专攻」博客更新</td></tr><tr><td>业界动态</td><td>洞悉业界动态，知道大家现在都在做什么，未来的趋势在哪里，我们可以做的事情有哪些</td><td>创建「业界动态」专栏</td></tr><tr><td>开源影响力</td><td>积极参与开源社区贡献，在社区构建自己的影响力</td><td>成为k8s社区Member</td></tr><tr><td>产品思维</td><td>在公司内部积极完成leader下发的任务，并能够从产品和业务的角度去更好的思考问题</td><td>公司影响力提升</td></tr></tbody></table></div><h2 id="阅读光影"><a href="#阅读光影" class="headerlink" title="阅读光影"></a>阅读光影</h2><p>和2019年一样，2020年我并没有阅读多少书籍，豆瓣上标记的只有3本，但是我仍然愿意在这里花上一段篇幅来讨论它。从2014年注册豆瓣以来，下面是我每年在豆瓣读书上标记的阅读数，可以看到，本科时期是我阅读热情的高峰，尤其是大二和大三的时候，基本上每年阅读数能够达到50本。可是，读研之后，阅读的书就越来越少了，甚至在19年毫无所获。</p><div id="echarts2442" style="width: 100%;height: 600px;margin: 0 auto"></div><script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script><script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('echarts2442'));  // 指定图表的配置项和数据  option = {    title: {        text: '豆瓣阅读数据'    },    tooltip: {        trigger: 'axis',        axisPointer: {            type: 'cross',            crossStyle: {                color: '#999'            }        }    },    toolbox: {        feature: {            dataView: {show: true, readOnly: false},            magicType: {show: true, type: ['line', 'bar']},            restore: {show: true},            saveAsImage: {show: true}        }    },    legend: {        data: ['阅读统计']    },    xAxis: [        {            type: 'category',            data:  ['2014', '2015', '2016', '2017', '2018', '2019', '2020'],            axisPointer: {                type: 'shadow'            }        }    ],    yAxis: [        {            type: 'value',            name: '阅读统计',            min: 0,            max: 60,            interval: 5,            axisLabel: {                formatter: '{value}'            }        }    ],    series: [        {            name: '阅读统计',            type: 'bar',            data: [25, 55, 49, 6, 6, 0, 3]        }    ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);</script><p>2020年的上半年也是基本如此，没有阅读什么书籍。没有人会否认阅读的重要性，相对于从公众号或者知乎里面获取的零碎知识，阅读书籍是一种更加体系化的知识获取方式。在本科时期，我对于历史和小说比较感兴趣，这些领域的阅读都相对轻松。那个时候我经常会很快地扫读，也很少去写一些阅读笔记和书评，很多书籍看完之后就丢在一边，导致阅读的相对收益并不高。</p><p>双十一之后，我从PT那里拿来了 Kindle，开始构建自己的阅读系统，构建主题阅读的方法论：</p><ul><li>问题意识。为什么要读一本书，是因为你心中对于某个主题包含着困惑（小说等书除外），你是抱着解答这些问题的期待翻开一本书的。我给自己建立了一个<a href="https://www.douban.com/doulist/133636602/" target="_blank" rel="external nofollow noopener noreferrer">2021阅读清单</a>，这是一个很实用主义的书单，涉及到各种经济学的原理与实践、涉及到行为模式的构建、涉及到专业知识的深化，我希望通过阅读这些书去解决这些问题。</li><li>整理书籍的知识框架。一本书的精髓在于作者的框架逻辑，而不在于其遣词造句，读书最重要读的是其知识框架。</li><li>交叉阅读验证知识框架。同一个主题往往不止一本书籍，阅读同一主题中的不同书籍可以交叉验证之前总结的知识框架。</li><li>将书籍的知识框架打入到你的知识体系，将内化的知识表达出来。这个过程中，读书笔记是第一步，通过读书笔记，可以实现对书籍的二次精读，更加关注知识的整体架构，获取的知识才是成体系的，而不是碎片化的信息。</li></ul><p>以此方法论为基础，我将2020年阅读的三本书籍分别写下了阅读笔记，列次如下：</p><ul><li><a href="https://houmin.cc">【读书笔记】如何阅读一本书</a></li><li><a href="https://houmin.cc">【读书笔记】光变</a></li><li><a href="https://houmin.cc">【读书笔记】褚时健传</a></li></ul><p>与阅读相同，希望新的一年观影也能够感受更多的东西。在年初的时候，当时对 2008 年的经济危机十分感兴趣，看了好几部关于次贷危机的纪录片与电影，并以 <a href="https://houmin.cc/posts/787197ce/">The Big Short</a> 的形式总结发布出来。</p><p>新的一年，我也给自己建立了一个 <a href="https://www.douban.com/doulist/133864290/" target="_blank" rel="external nofollow noopener noreferrer">2021观影清单</a>，观影的同时，希望有更多的文章发布。</p><h2 id="资本不眠"><a href="#资本不眠" class="headerlink" title="资本不眠"></a>资本不眠</h2><p>2019 年初，给自己定下的一个目标是股市收益超过20个点，最好能够达到40个点。得益于今年不错的行情，再一次达到了这个目标，最终收益率达到了 <code>35%</code>，稍稍跑赢沪深300。不得不说，在投资方面我仍然没有入门，这是这两年来的股市行情向好，才没有亏钱。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-31_invest-return.jpg"></p><p>对于股票投资，我现在最大的问题在于，我不知道为什么要买一只股票。对于一只真正好的股票，股票涨了一些的时候我能不能拿得住，股票跌的时候我会不会害怕。这家公司身处什么行业，其主营业务是什么，它的管理层是一些怎样的人，它在过去几年的业绩怎么样，公司和行业的发展怎么样？现在处于经济周期的哪个阶段？股票建仓的策略如何？你对这只股票预期的收益是多少？</p><p>上面的种种问题，我心里都没有底。今年最大的一个遗憾是新能源，看看下面来自我账户的两张图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-31_gwm.jpg"></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-31_byd.jpg"></p><p>对的，这两只在今年大涨了4倍的股票我在他们起飞之前都已经关注过。这还不算，19年初就已经关注起新能源汽车行业，并且在 2020 年初还专门写了篇 <a href="https://houmin.cc/posts/8082c63c/">聊聊行业：以新能源汽车为例</a>  的文章，作为行业研究的入门笔记。然而，我还是错过了这一切：）</p><p>为什么？想想当初买这两只股票的逻辑：哟，长城汽车最高价到过16块，现在才七八块，绝对便宜啊，而且听说长城哈弗卖的挺不错的，不亏。然后我在长城处于7块到10块震荡的时候一直在做T，到10块后稍微跌了跌就清仓了。嗯，也能够赚点钱，但是 ：）比亚迪也基本是这样很早就卖了。</p><p>说实话，真的很心痛，要是没有卖该多好：）不过说起来，没能拿住，本质上就是自己认知思维没打开，整个投资框架没有建立起来，这笔钱还不属于我。2020年的下半年，我完全没有操作，一方面因为这两只股票的教训已经从认知上更倾向于长期投资，不太喜欢这种短期波动获取的收益；另一方面因为工作原因，没有太多的时间去研究其他的股票，也就没有去操作。</p><p>新的一年，在投资方面还是要去建立自己的投资框架，熟悉了解财经相关的知识，现在对财经方面的兴趣越来越强了（不愧是个俗人：）在2021年，希望至少完成5篇财经方面书籍的阅读，并且整理相关阅读笔记并发布。另外，除了A股投资，也要给自己开一个美股和港股的账户，毕竟那边有很多很好的标的；除了现在的股票投资，明年应该开始指数基金定投计划。</p><p>还是那句话，希望明年整体投资收益超过20%，最好能够到40%，加油。</p><h2 id="旅行影像"><a href="#旅行影像" class="headerlink" title="旅行影像"></a>旅行影像</h2><p>因为疫情，原来的旅行计划被迫放弃。令人开心的是，随着国内疫情的控制，今年还是除了北京，还是走了走杭州和西北，我将所看到的记录在了这些文章里。</p><ul><li><a href="https://houmin.cc/posts/2f653e3b/">西湖印象</a>：初夏到达杭州姐姐家，盛夏回到北京，杭州很美</li><li><a href="https://houmin.cc/posts/2561fdfd/">26：一个人的北京</a>：国庆去了趟大西北，真美</li></ul><p>2020 年我仍然在记录着，除了旅行中的光影，我也记录着身边的影像，你可以在 <a href="https://houmin.cc/tags/摄影">这里</a> 看到。越来越觉得，除了奇美的自然景观，人的影像有时候会更加生动。新的一年，希望自己能够更多的走出去，希望自己的镜头下能够记录更多更美的时刻。</p><h2 id="我与其他"><a href="#我与其他" class="headerlink" title="我与其他"></a>我与其他</h2><ul><li>2020年，我重新捡起了跑步，断断续续着，希望新的一年能够找回大四时跑步的状态，并参加一次马拉松</li><li>2020年，我开始审视自己的睡眠，并开始抓取自己的睡眠数据，希望新的一年能够将这一数据回归到正常</li><li>2020年，卡林巴琴最终没有坚持下来，可是我仍然记得音乐带来的放松，希望以后能够掌握一门乐器，也许吉他</li><li>2020年，「朝花夕拾」开始每周更多的记录，希望新的一年能够开拓数据收集的范围，记录世界纪录自己</li><li>2020年，我开始高密度的听起了播客，喜欢下班路上听着播客的放松状态，希望以后我也能够做一档自己的播客</li><li>2020年，我依旧是单身一个人，工作后能够投入到感情上面的时间越发减少，希望新的一年自己能够更加主动</li><li>2020年结束了，可以确定的是，我们以后会不止一次地回忆起这不平凡的一年，下面是来自「声东击西」记录2020的声音</li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="1500" height="80" src="//music.163.com/outchain/player?type=3&id=2071218639&auto=1&height=66"></iframe><hr><p>再见，2020</p><p>你好，2021</p><p>新年快乐！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当写下 &lt;a href=&quot;https://houmin.cc/posts/2ecc368&quot;&gt;2019 未来へ&lt;/a&gt; 的时候，我没有意识到2020年将会发生什么。那时的我是轻松惬意的，文字里透露着面向未来的自信，期冀着能够做出自己的改变。一年过去了，咻的一下，很快，生活中的种种已经发生了改变。2020 年发生的种种让我更加意识到到自身的渺小与浅陋，绝大多数时候你改变不了什么，你能确定改变的只能是自己，尽管这并不简单。&lt;/p&gt;
&lt;p&gt;这里是 「岁末围炉」系列的第二篇 &lt;code&gt;2020 渺小&lt;/code&gt;，主题曲选择的是田馥甄的渺小，封面图来自冬日的雍和宫。 2020 年结束了，渺小的我依然在构建自己的框架，向着生命，向着未来。&lt;/p&gt;

    &lt;div id=&quot;aplayer-UMydVDDJ&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;27968284&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-20_temple.png" type="image" />
    
    
      <category term="岁末围炉" scheme="http://houmin.cc/categories/%E5%B2%81%E6%9C%AB%E5%9B%B4%E7%82%89/"/>
    
    
      <category term="年终总结" scheme="http://houmin.cc/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>十字路口</title>
    <link href="http://houmin.cc/posts/64c2f65e/"/>
    <id>http://houmin.cc/posts/64c2f65e/</id>
    <published>2020-12-12T11:23:16.000Z</published>
    <updated>2020-12-13T11:31:32.452Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>改变的路总是很难走，尽管有挫折，但是仍要努力向前。这里是2020年「朝花夕拾」第二十八期 <code>十字路口</code>，这应该是 2020 年 「朝花夕拾」倒数第二期了。就在今天，北京又迎来了小雪，虽然只有不到两个小时，仍然给人带来些许欣喜。十字路口，尽管前面存在着各种不确定，唯一确定的是你希望找到一个更加自洽的自我。</p>    <div id="aplayer-YgAOXVmI" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="346836" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>很久没有出门啦，说好的二十四节气好久没有进展，北京大冬天的真的就想一个人呆在家里。好啦，继续看数据吧：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-12_rescue-time.png"></p><p>这周感觉工作效率一般般，因为没有制定一周规划，整个星期都显得目标不明确。现在越工作越感觉自己知道的东西太少了，在专业上还有很多很多需要去学习和努力的地方。</p><p>接下来是 <code>Forest</code> 和 <code>Running</code>，这周跑步很不在状态，虽然也跑了三次，但是还是没有找到跑步的状态：</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Forest - Nov 29 ~ Dec 05, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-12_forest.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Running - Nov 29 ~ Dec 05, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-12_running.jpg"></div></div></div></div><p>下面是睡眠数据总结，可以看到上周的周三晚上过了一点半才睡觉，第二天整天都昏昏沉沉的，导致当天都没有跑步。回忆了一下，那天是看《褚时健传》看的兴起，一下子就看到了很晚，这个太要不得了，下周要避免。另外一个就是，周五晚上普遍睡的比较晚，周六早上也起的很晚，比如这周到11点才从床上爬起来，这个太难受了。</p><div id="echarts2403" style="width: 100%;height: 600px;margin: 0 auto"></div><script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script><script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('echarts2403'));  // 指定图表的配置项和数据  var dateTime = ['2020-11-29', '2020-11-30', '2020-12-01', '2020-12-02', '2020-12-03', '2020-12-04', '2020-12-05', '2020-12-06', '2020-12-07', '2020-12-08', '2020-12-09', '2020-12-10', '2020-12-11', '2020-12-12', '2020-12-13'];var sleepTime = [-0.95, -0.18, 4.03, -0.55, 0.58, 0.38, 1.13, -0.08, 1.37, -0.08, 1.7, -0.38, 0.57, 1.05, -0.93];var awakeTime = [7.8, 8.67, 7.72, 7.83, 6.82, 4.85, 9.28, 7.38, 7.23, 4.7, 8.2, 4.95, 8.17, 11.45, 6.7];var awakeTimeBar = [];for (let i = 0; i < sleepTime.length; ++i) {    var awakeTimeValue = awakeTime[i];    if (sleepTime[i] > 0) {        awakeTimeValue = awakeTime[i] - sleepTime[i];    }    awakeTimeBar.push(awakeTimeValue);}option = {    title: {        text: '睡眠监控'     },    tooltip: {        trigger: 'axis',        formatter: function(params) {            function getHourMinute(timeValue) {                if (timeValue < 0) timeValue = 24 + timeValue;                var m = Math.floor((timeValue % 1) * 60);                m = m.toString().padStart(2, '0');                var h = Math.floor(timeValue);                return {                    hour: h,                    minute: m                }            }            var sleepValue = params[0].data;            var awakeValue = params[1].data;            var sleepTime = getHourMinute(sleepValue);            var awakeTime = getHourMinute(awakeValue);            var totalTime = getHourMinute(awakeValue - sleepValue);            return params[0].name + '<br />'                + params[0].seriesName + ": " + sleepTime.hour + ":" + sleepTime.minute + '<br />'                + params[1].seriesName + ": " + awakeTime.hour + ":" + awakeTime.minute + '<br />'                +  "睡眠时长: " + totalTime.hour + ":" + totalTime.minute;        }    },    toolbox: {        feature: {            dataView: {show: true, readOnly: false},            restore: {show: true},            saveAsImage: {show: true}        }    },    legend: {        data: ['入睡时间', '起床时间', '睡眠时间']    },    xAxis: [        {            type: 'category',            data: dateTime,            axisPointer: {                type: 'shadow'            }        }    ],    yAxis: [        {            type: 'value',            axisLine: {                show: false            },            name: '时间',            axisLabel: {                formatter: function (h) {                    h = Math.floor(h);                    if (h < 0) {                        return h + 24 + ':00';                    } else {                        return h + ':00';                    }                 },                 margin: 20            }        }    ],    series: [        {            name: '入睡时间',            type: 'line',            data: sleepTime        },        {            name: '起床时间',            type: 'line',            data: awakeTime        },        {            type: 'bar',            stack: '总量',            data: sleepTime,            itemStyle: {                normal: {                    color: function(params) {                        if (params.data > 0) return 'rgba(0,0,0,0)';                        else return '#2F4554'                    }                }            }        },        {            type: 'bar',            stack: '总量',            data: awakeTimeBar,            itemStyle: {                normal: {                    color: function(params) {                       return '#2F4554'                    }                }            }        }    ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);</script><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;改变的路总是很难走，尽管有挫折，但是仍要努力向前。这里是2020年「朝花夕拾」第二十八期 &lt;code&gt;十字路口&lt;/code&gt;，这应该是 2020 年 「朝花夕拾」倒数第二期了。就在今天，北京又迎来了小雪，虽然只有不到两个小时，仍然给人带来些许欣喜。十字路口，尽管前面存在着各种不确定，唯一确定的是你希望找到一个更加自洽的自我。&lt;/p&gt;

    &lt;div id=&quot;aplayer-YgAOXVmI&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;346836&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-13_cross.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="十字路口" scheme="http://houmin.cc/tags/%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>远离他们</title>
    <link href="http://houmin.cc/posts/36fc760d/"/>
    <id>http://houmin.cc/posts/36fc760d/</id>
    <published>2020-12-05T11:23:16.000Z</published>
    <updated>2020-12-13T10:38:03.322Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>像燃烧的火球在天边下坠，这是今天旁晚的晚霞，从没拍到过这样的烟云。这里是「朝花夕拾」第二十七期 <code>远离他们</code>，原谅我的起名无能，我只是觉得这首歌很好听。最近开始捡起了阅读，不再是刷着手机睡觉，而是看着Kindle入眠。相比之前，感觉自己的状态好了很多，也越来越觉得以前从信息流中漫无目的滑过的浅薄。远离他们，远离浮躁、远离喧嚣、远离无用的信息流，沉淀下来，做些有意义的事情（强行点题，手工狗头） </p>    <div id="aplayer-CnMFcXPz" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1447573210" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p><img alt="坠落烟云" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-05_drop.png"></p><p>例行数据回顾，首先是 <code>RescueTime</code>：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-05_rescue-time.png"></p><p>这周记录的时间相对上周要少，因为周日出去浪了，所以基本没有碰电脑。总体来说，这周的企业微信用的比上周要多，因为多了一些沟通的事情，这周主要的事情也就是在自己学习 <code>k8s</code>，总结自己的博客中。还是继续坚持之前的做法，用固定的时间来去解决沟通的问题。</p><p>接下来是 <code>Forest</code> 和 <code>Running</code>，现在工作的时候很少刷手机了，只有在吃饭的时候刷刷手机，但是就在那一个小时也容易一直拖拉，需要进一步改变。跑步方面，这周坚持了四次，比上周数据有所增加，但是说实话一直还没有找到跑步的感觉，继续加油叭。之前大四跑步疯狂的时候，说自己要跑马拉松，但是最后鸽了，这次看能不能跑上明年的北马呢？</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Forest - Nov 29 ~ Dec 05, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-05_forest.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Running - Nov 29 ~ Dec 05, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-05_running.jpg"></div></div></div></div><p>接下来是睡眠数据总结，这里我更新了处理数据的 <code>Python</code> 脚本，主要的展示逻辑放在了 <code>ECharts</code> 里面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/env python3</span><br><span class="line"># -*- coding: UTF<span class="number">-8</span> -*-</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">datafile = <span class="string">"sleep.csv"</span></span><br><span class="line"></span><br><span class="line">def get_time_value(timeArray):</span><br><span class="line">    <span class="keyword">return</span> timeArray.tm_hour + round(float(timeArray.tm_min) / float(<span class="number">60</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">def get_time(timestamp):</span><br><span class="line">    timeStamp = float(timestamp)</span><br><span class="line">    timeArray = time.localtime(timeStamp)</span><br><span class="line">    <span class="keyword">return</span> timeArray</span><br><span class="line"></span><br><span class="line">def parse_csv(datafile):</span><br><span class="line">    dateTime = []</span><br><span class="line">    sleepTime = []</span><br><span class="line">    awakeTime = []</span><br><span class="line">    with open(datafile, <span class="string">"r"</span>) as f:</span><br><span class="line">        r = csv.DictReader(f)</span><br><span class="line">        <span class="keyword">for</span> line in r:</span><br><span class="line">            start, stop = line[<span class="string">"start"</span>], line[<span class="string">"stop"</span>]</span><br><span class="line">            pStart = get_time(start)</span><br><span class="line">            pStop = get_time(stop)</span><br><span class="line">            pDate = time.strftime(<span class="string">"%Y-%m-%d"</span>, pStop)</span><br><span class="line">            dateTime.<span class="built_in">append</span>(pDate)</span><br><span class="line"></span><br><span class="line">            sleepTimeValue = get_time_value(pStart)</span><br><span class="line">            awakeTimeValue = get_time_value(pStop)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sleepTimeValue &gt; <span class="number">20</span>:</span><br><span class="line">                sleepTimeValue = round(sleepTimeValue - <span class="number">24.0</span>, <span class="number">2</span>)</span><br><span class="line">            sleepTime.<span class="built_in">append</span>(sleepTimeValue)</span><br><span class="line">            awakeTime.<span class="built_in">append</span>(awakeTimeValue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dateTime, sleepTime, awakeTime</span><br></pre></td></tr></table></figure><p>数据涵盖了 <code>2020-10-19</code> 到 <code>2020-12-06</code> 的数据，可以看到我的睡眠分布非常不均衡，不仅仅是入睡时间的不均衡，起床时间的不均衡，还包括睡眠时长的不均衡。另外，大多数的入睡时间都在12点以后，很少在12点前就睡了的，这个一方面是之前作息极度不规律，另一方面现在有时候看书容易看晚了。</p><p>所以12月的一个任务是，将整个图形向下拉一个小时，以11点为起点，7点为终点的睡眠时间，而且两条曲线应该日渐平缓，方差不要过大，让自己的睡眠真正的规律起来。</p><div id="echarts2471" style="width: 100%;height: 600px;margin: 0 auto"></div><script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script><script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('echarts2471'));  // 指定图表的配置项和数据  var dateTime = ['2020-10-19', '2020-10-20', '2020-10-21', '2020-10-22', '2020-10-23', '2020-10-24', '2020-10-25', '2020-10-26', '2020-10-27', '2020-10-28', '2020-10-29', '2020-10-30', '2020-10-31', '2020-11-01', '2020-11-01', '2020-11-03', '2020-11-17', '2020-11-19', '2020-11-20', '2020-11-21', '2020-11-22', '2020-11-23', '2020-11-24', '2020-11-25', '2020-11-26', '2020-11-27', '2020-11-28', '2020-11-29', '2020-11-30', '2020-12-01', '2020-12-02', '2020-12-03', '2020-12-04', '2020-12-05', '2020-12-06'];var sleepTime = [-0.17, 0.57, 1.13, -0.88, 0.65, 0.77, 1.62, 0.1, 0.8, 0.95, 1.12, 0.27, 0.62, -0.05, 0.0, -1.63, 0.0, -0.55, 3.12, 0.33, 1.77, -0.7, 0.28, -0.2, 1.42, 0.38, -1.0, -0.95, -0.18, 4.03, -0.55, 0.58, 0.38, 1.13, -0.08];var awakeTime = [8.78, 5.13, 8.9, 3.32, 8.38, 10.77, 9.32, 6.15, 6.92, 8.32, 9.27, 6.62, 4.18, 3.87, 0.0, 3.5300000000000002, 0.0, 7.57, 7.95, 7.08, 9.85, 7.13, 5.42, 3.52, 8.3, 8.52, 8.03, 7.8, 8.67, 7.72, 7.83, 6.82, 4.85, 9.28, 7.38];var awakeTimeBar = [];for (let i = 0; i < sleepTime.length; ++i) {    var awakeTimeValue = awakeTime[i];    if (sleepTime[i] > 0) {        awakeTimeValue = awakeTime[i] - sleepTime[i];     }    awakeTimeBar.push(awakeTimeValue);}option = {    title: {        text: '睡眠监控'     },    tooltip: {        trigger: 'axis',        formatter: function(params) {            function getHourMinute(timeValue) {                if (timeValue < 0) timeValue = 24 + timeValue;                var m = Math.floor((timeValue % 1) * 60);                m = m.toString().padStart(2, '0');                var h = Math.floor(timeValue);                return {                    hour: h,                     minute: m                }            }                        var sleepValue = params[0].data;            var awakeValue = params[1].data;            if (sleepValue > 0) {                awakeValue = sleepValue + awakeValue;            }            var sleepTime = getHourMinute(sleepValue);            var awakeTime = getHourMinute(awakeValue);            var totalTime = getHourMinute(awakeValue - sleepValue);            return params[0].name + '<br />'                + params[0].seriesName + ": " + sleepTime.hour + ":" + sleepTime.minute + '<br />'                + params[1].seriesName + ": " + awakeTime.hour + ":" + awakeTime.minute + '<br />'                +  "睡眠时长: " + totalTime.hour + ":" + totalTime.minute;        }    },    toolbox: {        feature: {            dataView: {show: true, readOnly: false},            restore: {show: true},            saveAsImage: {show: true}        }    },    legend: {        data: ['入睡时间', '起床时间', '睡眠时间']    },    xAxis: [        {            type: 'category',            data: dateTime,            axisPointer: {                type: 'shadow'            }        }    ],    yAxis: [        {            type: 'value',            axisLine: {                show: false            },            name: '时间',            axisLabel: {                formatter: function (h) {                    h = Math.floor(h);                    if (h < 0) {                        return h + 24 + ':00';                    } else {                         return h + ':00';                    }                 },                 margin: 20            }        },        {            type: 'value',            axisLine: {            show: false            },            min: 0,            max: 10,            name: '时长/小时'        }    ],    series: [        {            name: '入睡时间',            type: 'line',            data: sleepTime        },        {            name: '起床时间',            type: 'line',            data: awakeTime        },        {            type: 'bar',            stack: '总量',            data: sleepTime,            itemStyle: {                normal: {                    color: function(params) {                        if (params.data > 0) return 'rgba(0,0,0,0)';                        else return '#2F4554'                    }                }            }        },        {            type: 'bar',            stack: '总量',            data: awakeTimeBar,            itemStyle: {                normal: {                    color: function(params) {                       return '#2F4554'                    }                }            }        }    ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);</script><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h3 id="Salesforce-收购-Slack"><a href="#Salesforce-收购-Slack" class="headerlink" title="Salesforce 收购 Slack"></a>Salesforce 收购 Slack</h3><h3 id="深圳新房代持"><a href="#深圳新房代持" class="headerlink" title="深圳新房代持"></a>深圳新房代持</h3><h3 id="孟晚舟被捕两周年"><a href="#孟晚舟被捕两周年" class="headerlink" title="孟晚舟被捕两周年"></a>孟晚舟被捕两周年</h3><h3 id="Gartner-发布报告"><a href="#Gartner-发布报告" class="headerlink" title="Gartner 发布报告"></a>Gartner 发布报告</h3><h3 id="社区买菜热战正酣"><a href="#社区买菜热战正酣" class="headerlink" title="社区买菜热战正酣"></a>社区买菜热战正酣</h3><p>阿里充值十绘团</p><p>美团财报出炉</p><h3 id="虾米音乐将关闭"><a href="#虾米音乐将关闭" class="headerlink" title="虾米音乐将关闭"></a>虾米音乐将关闭</h3><h3 id="11月PMI发布"><a href="#11月PMI发布" class="headerlink" title="11月PMI发布"></a>11月PMI发布</h3><h3 id="华晨债务风波"><a href="#华晨债务风波" class="headerlink" title="华晨债务风波"></a>华晨债务风波</h3><h3 id="量子计算九章发布"><a href="#量子计算九章发布" class="headerlink" title="量子计算九章发布"></a>量子计算九章发布</h3><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像燃烧的火球在天边下坠，这是今天旁晚的晚霞，从没拍到过这样的烟云。这里是「朝花夕拾」第二十七期 &lt;code&gt;远离他们&lt;/code&gt;，原谅我的起名无能，我只是觉得这首歌很好听。最近开始捡起了阅读，不再是刷着手机睡觉，而是看着Kindle入眠。相比之前，感觉自己的状态好了很多，也越来越觉得以前从信息流中漫无目的滑过的浅薄。远离他们，远离浮躁、远离喧嚣、远离无用的信息流，沉淀下来，做些有意义的事情（强行点题，手工狗头） &lt;/p&gt;

    &lt;div id=&quot;aplayer-CnMFcXPz&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;1447573210&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-12-05_drop.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="阅读" scheme="http://houmin.cc/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="量子计算" scheme="http://houmin.cc/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio Pilot Agent</title>
    <link href="http://houmin.cc/posts/2d9a22d4/"/>
    <id>http://houmin.cc/posts/2d9a22d4/</id>
    <published>2020-11-29T11:43:44.000Z</published>
    <updated>2020-12-15T12:34:34.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><a id="more"></a><h2 id="pilot-agent-是什么？"><a href="#pilot-agent-是什么？" class="headerlink" title="pilot-agent 是什么？"></a>pilot-agent 是什么？</h2><blockquote><p>　当我们执行 <code>kubectl apply -f &lt;(~istioctl kube-inject -f sleep.yaml)</code>的时候，k8s就会帮我们建立3个容器。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz9cffi0prthtem44cp9z ~]# docker ps |grep sleep</span><br><span class="line">8e0de7294922        istio<span class="built_in">/proxy </span>                                                              </span><br><span class="line">ccddc800b2a2        registry.cn-shenzhen.aliyuncs.com/jukylin/sleep                          </span><br><span class="line">990868aa4a42        registry-vpc.cn-shenzhen.aliyuncs.com/acs/pause-amd64:3.0</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>在这3个容器中，我们关注<code>istio/proxy</code>。这个容器运行着2个服务。<code>pilot-agent</code>就是接下来介绍的：如何管理envoy的生命周期。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>izwz9cffi0prthtem44cp9z ~]# docker exec -it <span class="number">8e0</span>de7294922 ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line"><span class="number">1337</span>         <span class="number">1</span>     <span class="number">0</span>  <span class="number">0</span> May09 ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">49</span> /usr/local/bin/pilot-agent proxy</span><br><span class="line"><span class="number">1337</span>       <span class="number">567</span>     <span class="number">1</span>  <span class="number">1</span> <span class="number">09</span>:<span class="number">18</span> ?        <span class="number">00</span>:<span class="number">04</span>:<span class="number">42</span> /usr/local/bin/envoy -c /etc/ist</span><br></pre></td></tr></table></figure><h2 id="为什么要用pilot-agent？"><a href="#为什么要用pilot-agent？" class="headerlink" title="为什么要用pilot-agent？"></a>为什么要用pilot-agent？</h2><blockquote><p>envoy不直接和k8s，Consul，Eureka等这些平台交互，所以需要其他服务与它们对接，管理配置，pilot-agent就是其中一个 <strong>【控制面板】</strong>。</p></blockquote><h2 id="启动envoy"><a href="#启动envoy" class="headerlink" title="启动envoy"></a>启动envoy</h2><h4 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h4><blockquote><p>在启动前 pilot-agent 会生成一个配置文件：/etc/istio/proxy/envoy-rev0.json：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/pkg/proxy/envoy/v1/config.<span class="keyword">go</span> #<span class="number">88</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildConfig</span><span class="params">(config meshconfig.ProxyConfig, pilotSAN []<span class="keyword">string</span>)</span> *<span class="title">Config</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文件的具体内容可以直接查看容器里面的文件</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="number">8</span>e0de7294922 cat <span class="regexp">/etc/i</span>stio<span class="regexp">/proxy/</span>envoy-rev0.json</span><br></pre></td></tr></table></figure><blockquote><p>关于配置内容的含义可以看<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview" target="_blank" rel="external nofollow noopener noreferrer">官方的文档</a></p></blockquote><h4 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h4><blockquote><p>一个二进制文件启动总会需要一些参数，envoy也不例外。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/pkg/proxy/envoy/v1/watcher.<span class="keyword">go</span> #<span class="number">274</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxy envoy)</span> <span class="title">args</span><span class="params">(fname <span class="keyword">string</span>, epoch <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> startupArgs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>envoy启动参数可以通过 <code>docker logs 8e0de7294922</code> 查看，下面是从终端截取envoy的参数。了解具体的参数含义<a href="https://www.envoyproxy.io/docs/envoy/latest/operations/cli" target="_blank" rel="external nofollow noopener noreferrer">官网文档</a>。</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c /etc/istio/proxy/envoy-rev0.json --<span class="built_in">restart</span>-epoch <span class="number">0</span></span><br><span class="line">--drain-<span class="built_in">time</span>-s <span class="number">45</span> --parent-shutdown-<span class="built_in">time</span>-s <span class="number">60</span></span><br><span class="line">--service-cluster sleep </span><br><span class="line">--service-node sidecar~<span class="number">172.00</span><span class="number">.00</span><span class="number">.000</span>~sleep-<span class="number">55b5877479</span>-rwcct.default~default.svc.cluster.<span class="built_in">local</span> </span><br><span class="line">--<span class="built_in">max</span>-obj-name-len <span class="number">189</span> -l info --v2-config-only</span><br></pre></td></tr></table></figure><h4 id="启动envoy-1"><a href="#启动envoy-1" class="headerlink" title="启动envoy"></a>启动envoy</h4><blockquote><p>pilot-agent 使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec.<span class="keyword">Command</span></span><br></pre></td></tr></table></figure><p>启动envoy，并且会监听envoy的运行状态（如果envoy非正常退出，status 返回非nil，pilot-agent会有策略把envoy重新启动）。</p><p><code>proxy.config.BinaryPath</code> 为envoy二进制文件路径：/usr/local/bin/envoy。</p><p><code>args</code> 为上面介绍的envoy启动参数。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/pkg/proxy/envoy/v1/watcher.<span class="keyword">go</span> #<span class="number">353</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxy envoy)</span> <span class="title">Run</span><span class="params">(config <span class="keyword">interface</span>&#123;&#125;, epoch <span class="keyword">int</span>, abort &lt;-<span class="keyword">chan</span> error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* #nosec */</span></span><br><span class="line">    cmd := exec.Command(proxy.config.BinaryPath, args...)</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    <span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      done &lt;- cmd.Wait()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-abort:</span><br><span class="line">      ......</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-done:</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="热更新envoy"><a href="#热更新envoy" class="headerlink" title="热更新envoy"></a>热更新envoy</h2><blockquote><p>在这里我们只讨论pilot-agent如何让envoy热更新，至于如何去触发这步会在后面的文章介绍。</p></blockquote><h4 id="envoy热更新策略"><a href="#envoy热更新策略" class="headerlink" title="envoy热更新策略"></a>envoy热更新策略</h4><p><img alt="image" data-src="https://segmentfault.com/img/remote/1460000015171628?w=1069&amp;h=416"></p><blockquote><p>想详细了解envoy的热更新策略可以看官网博客</p><p>Envoy hot restart</p><p>。</p><p>简单介绍下envoy热更新步骤：</p></blockquote><ol><li>启动另外一个envoy2进程（Secondary process）</li><li>envoy2通知envoy1（Primary process）关闭其管理的端口，由envoy2接管</li><li>通过UDS把envoy1可用的listen sockets拿过来</li><li>envoy2初始化成功，通知envoy1在一段时间内（<code>drain-time-s</code>）优雅关闭正在工作的请求</li><li>到了时间（<code>parent-shutdown-time-s</code>），envoy2通知envoy1自行关闭</li><li>envoy2升级为envoy1</li></ol><blockquote><p>从上面的执行步骤来看，poilt-agent只负责启动另一个envoy进程，其他由envoy自行处理。</p></blockquote><h4 id="什么时候进行热更新？"><a href="#什么时候进行热更新？" class="headerlink" title="什么时候进行热更新？"></a>什么时候进行热更新？</h4><blockquote><p>在poilt-agent启动的时候，会监听<code>/etc/certs/</code>目录下的文件，如果这个目录下的文件被修改或删除，poilt-agent就会通知envoy进行热更新。至于如何触发对这些文件进行修改和删除会在接下来的文章介绍。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/pkg/proxy/envoy/v1/watcher.<span class="keyword">go</span> #<span class="number">177</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watchCerts</span><span class="params">(ctx context.Context, certsDirs []<span class="keyword">string</span>, watchFileEventsFn watchFileEventsFn,</span></span></span><br><span class="line"><span class="function"><span class="params">    minDelay time.Duration, updateFunc <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    fw, err := fsnotify.NewWatcher()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warnf(<span class="string">"failed to create a watcher for certificate files: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fw.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Warnf(<span class="string">"closing watcher encounters an error %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch all directories</span></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> certsDirs &#123;</span><br><span class="line">        <span class="keyword">if</span> err := fw.Watch(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Warnf(<span class="string">"watching %s encounters an error %v"</span>, d, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    watchFileEventsFn(ctx, fw.Event, minDelay, updateFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="热更新启动参数"><a href="#热更新启动参数" class="headerlink" title="热更新启动参数"></a>热更新启动参数</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c /etc/istio/proxy/envoy-rev1.json --restart-epoch <span class="number">1</span></span><br><span class="line">--drain-time-s <span class="number">45</span> --parent-shutdown-time-s <span class="number">60</span></span><br><span class="line">--service-cluster sleep --service-node</span><br><span class="line">sidecar~<span class="number">172.00</span><span class="number">.00</span><span class="number">.000</span>~sleep<span class="number">-898</span>b65f84-pnsxr.<span class="section">default</span>~<span class="section">default</span>.svc.cluster.local </span><br><span class="line">--max-obj-name-len <span class="number">189</span> -l info</span><br><span class="line">--v2-config-only</span><br></pre></td></tr></table></figure><blockquote><p>热更新启动参数和第一次启动参数的不同的地方是 -c 和 —restart-epoch，其实-c 只是配置文件名不同，它们的内容是一样的。—restart-epoch 每次进行热更新的时候都会自增1，用于判断是进行热更新还是打开一个存在的envoy（这里的意思应该是第一次打开envoy）<br><a href="https://www.envoyproxy.io/docs/envoy/latest/operations/cli#cmdoption-restart-epoch" target="_blank" rel="external nofollow noopener noreferrer">具体看官方描述</a></p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/pkg/proxy/agent<span class="selector-class">.go</span> <span class="number">#258</span></span><br><span class="line">func (<span class="selector-tag">a</span> *agent) reconcile() &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// discover and increment the latest running epoch</span></span><br><span class="line">    epoch := <span class="selector-tag">a</span>.latestEpoch() + <span class="number">1</span></span><br><span class="line">    <span class="comment">// buffer aborts to prevent blocking on failing proxy</span></span><br><span class="line">    abortCh := make(chan error, MaxAborts)</span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-class">.epochs</span>[epoch] = <span class="selector-tag">a</span>.desiredConfig</span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-class">.abortCh</span>[epoch] = abortCh</span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-class">.currentConfig</span> = <span class="selector-tag">a</span>.desiredConfig</span><br><span class="line">    go <span class="selector-tag">a</span>.waitForExit(<span class="selector-tag">a</span><span class="selector-class">.desiredConfig</span>, epoch, abortCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从终端截取触发热更新的日志"><a href="#从终端截取触发热更新的日志" class="headerlink" title="从终端截取触发热更新的日志"></a>从终端截取触发热更新的日志</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-24</span>T13:<span class="number">59</span>:<span class="number">35.513160</span>Z    info    watchFileEvents: <span class="string">"/etc/certs//..2018_04_24_13_59_35.824521609"</span>: CREATE</span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-24</span>T13:<span class="number">59</span>:<span class="number">35.513228</span>Z    info    watchFileEvents: <span class="string">"/etc/certs//..2018_04_24_13_59_35.824521609"</span>: MODIFY|ATTRIB</span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-24</span>T13:<span class="number">59</span>:<span class="number">35.513283</span>Z    info    watchFileEvents: <span class="string">"/etc/certs//..data_tmp"</span>: RENAME</span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-24</span>T13:<span class="number">59</span>:<span class="number">35.513347</span>Z    info    watchFileEvents: <span class="string">"/etc/certs//..data"</span>: CREATE</span><br><span class="line"><span class="number">2018</span><span class="number">-04</span><span class="number">-24</span>T13:<span class="number">59</span>:<span class="number">35.513372</span>Z    info    watchFileEvents: <span class="string">"/etc/certs//..2018_04_24_04_30_11.964751916"</span>: DELETE</span><br></pre></td></tr></table></figure><h2 id="抢救envoy"><a href="#抢救envoy" class="headerlink" title="抢救envoy"></a>抢救envoy</h2><blockquote><p>envoy是一个服务，既然是服务都不可能保证100%的可用，如果envoy不幸运宕掉了，那么pilot-agent如何进行抢救，保证envoy高可用？</p></blockquote><h4 id="获取退出状态"><a href="#获取退出状态" class="headerlink" title="获取退出状态"></a>获取退出状态</h4><blockquote><p>在上面提到pilot-agent启动envoy后，会监听envoy的退出状态，发现非正常退出状态，就会抢救envoy。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxy envoy)</span> <span class="title">Run</span><span class="params">(config <span class="keyword">interface</span>&#123;&#125;, epoch <span class="keyword">int</span>, abort &lt;-<span class="keyword">chan</span> error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Set if the caller is monitoring envoy, for example in tests or if envoy runs in same</span></span><br><span class="line">    <span class="comment">// container with the app.</span></span><br><span class="line">    <span class="keyword">if</span> proxy.errChan != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Caller passed a channel, will wait itself for termination</span></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        proxy.errChan &lt;- cmd.Wait()</span><br><span class="line">      &#125;()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      done &lt;- cmd.Wait()</span><br><span class="line">    &#125;()</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抢救envoy-1"><a href="#抢救envoy-1" class="headerlink" title="抢救envoy"></a>抢救envoy</h4><blockquote><p>使用 kill -9 可以模拟envoy非正常退出状态。当出现非正常退出，pilot-agent的抢救机制会被触发。如果第一次抢救成功，那当然是好，如果失败了，pilot-agent会继续抢救，最多抢救10次，每次间隔时间为 2 n <em>100</em> time.Millisecond。超过10次都没有救活，pilit-agent就会放弃抢救，宣布死亡，并且退出istio/proxy，让k8s重新启动一个新容器。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/pkg/proxy/agent.go #164</span><br><span class="line">func (a *agent) Run(ctx context.Context) &#123;</span><br><span class="line">  <span class="params">...</span><span class="params">...</span></span><br><span class="line">  for &#123;</span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="params">...</span><span class="params">...</span></span><br><span class="line">    <span class="keyword">case</span> status := &lt;<span class="params">-a.statusCh</span>:</span><br><span class="line">        <span class="params">...</span><span class="params">...</span></span><br><span class="line">      <span class="keyword">if</span> status.err == errAbort &#123;</span><br><span class="line">        <span class="comment">//pilot-agent通知退出 或 envoy非正常退出</span></span><br><span class="line">        <span class="keyword">log</span>.Infof(<span class="string">"Epoch %d aborted"</span>, status.epoch)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> status.err != nil &#123;</span><br><span class="line">        <span class="comment">//envoy非正常退出</span></span><br><span class="line">        <span class="keyword">log</span>.Warnf(<span class="string">"Epoch %d terminated with an error: %v"</span>, status.epoch, status.err)</span><br><span class="line">                <span class="params">...</span><span class="params">...</span></span><br><span class="line">        a.abortAll()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正常退出</span></span><br><span class="line">        <span class="keyword">log</span>.Infof(<span class="string">"Epoch %d exited normally"</span>, status.epoch)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="params">...</span><span class="params">...</span></span><br><span class="line">    <span class="keyword">if</span> status.err != nil &#123;</span><br><span class="line">      <span class="comment">// skip retrying twice by checking retry restart delay</span></span><br><span class="line">      <span class="keyword">if</span> a.retry.restart == nil &#123;</span><br><span class="line">        <span class="keyword">if</span> a.retry.budget &gt; <span class="number">0</span> &#123;</span><br><span class="line">          delayDuration := a.retry.InitialInterval * (<span class="number">1</span> &lt;&lt; uint(a.retry.MaxRetries<span class="params">-a.retry.budget</span>))</span><br><span class="line">          restart := time.Now().Add(delayDuration)</span><br><span class="line">          a.retry.restart = &amp;restart</span><br><span class="line">          a.retry.budget = a.retry.budget - <span class="number">1</span></span><br><span class="line">          <span class="keyword">log</span>.Infof(<span class="string">"Epoch %d: set retry delay to %v, budget to %d"</span>, status.epoch, delayDuration, a.retry.budget)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//宣布死亡，退出istio/proxy</span></span><br><span class="line">          <span class="keyword">log</span>.Error(<span class="string">"Permanent error: budget exhausted trying to fulfill the desired configuration"</span>)</span><br><span class="line">          a.proxy.Panic(a.desiredConfig)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">log</span>.Debugf(<span class="string">"Epoch %d: restart already scheduled"</span>, status.epoch)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;<span class="params">-time.After</span>(delay):</span><br><span class="line">        <span class="params">...</span><span class="params">...</span></span><br><span class="line">    <span class="keyword">case</span> _, more := &lt;<span class="params">-ctx.Done</span>():</span><br><span class="line">        <span class="params">...</span><span class="params">...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">istio.io/istio/pilot/pkg/proxy/agent.go #72</span><br><span class="line"><span class="built_in">var</span> (</span><br><span class="line">  errAbort = errors.<span class="literal">New</span>(<span class="string">"epoch aborted"</span>)</span><br><span class="line">  <span class="comment">// DefaultRetry configuration for proxies</span></span><br><span class="line">  DefaultRetry = Retry&#123;</span><br><span class="line">    MaxRetries:      <span class="number">10</span>,</span><br><span class="line">    InitialInterval: <span class="number">200</span> * time.Millisecond,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="抢救日志"><a href="#抢救日志" class="headerlink" title="抢救日志"></a>抢救日志</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">6</span>: <span class="keyword">set</span> retry <span class="built_in">delay</span> <span class="keyword">to</span> <span class="number">200</span>ms, budget <span class="keyword">to</span> <span class="number">9</span></span><br><span class="line">Epoch <span class="number">6</span>: <span class="keyword">set</span> retry <span class="built_in">delay</span> <span class="keyword">to</span> <span class="number">400</span>ms, budget <span class="keyword">to</span> <span class="number">8</span></span><br><span class="line">Epoch <span class="number">6</span>: <span class="keyword">set</span> retry <span class="built_in">delay</span> <span class="keyword">to</span> <span class="number">800</span>ms, budget <span class="keyword">to</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="优雅关闭envoy"><a href="#优雅关闭envoy" class="headerlink" title="优雅关闭envoy"></a>优雅关闭envoy</h2><p><img alt="image" data-src="https://segmentfault.com/img/remote/1460000015171629?w=778&amp;h=294"></p><blockquote><p>服务下线或升级我们都希望它们能很平缓的进行，让用户无感知 ，避免打扰用户。这就要服务收到退出通知后，处理完正在执行的任务才关闭，而不是直接关闭。envoy是否支持优雅关闭？这需要k8s，pilot-agent也支持这种玩法。因为这存在一种关联关系k8s管理pilot-agent，pilot-agent管理envoy。</p></blockquote><h4 id="k8s让服务优雅退出"><a href="#k8s让服务优雅退出" class="headerlink" title="k8s让服务优雅退出"></a>k8s让服务优雅退出</h4><blockquote><p>网上有篇博客总结了<a href="https://pracucci.com/graceful-shutdown-of-kubernetes-pods.html" target="_blank" rel="external nofollow noopener noreferrer">k8s优雅关闭pods</a>，我这边简单介绍下优雅关闭流程：</p></blockquote><ol><li>k8s 发送 <strong>SIGTERM</strong> 信号到pods下所有服务的1号进程</li><li>服务接收到信号后，优雅关闭任务，并退出</li><li>过了一段时间（default 30s）,如果服务没有退出，k8s会发送 <strong>SIGKILL</strong> 信号，让容器强制退出。</li></ol><h4 id="pilot-agent-让envoy优雅退出"><a href="#pilot-agent-让envoy优雅退出" class="headerlink" title="pilot-agent 让envoy优雅退出"></a>pilot-agent 让envoy优雅退出</h4><ul><li>pilot-agent接收k8s信号</li></ul><blockquote><p>pilot-agent会接收syscall.SIGINT, syscall.SIGTERM，这2个信号都可以达到优雅关闭envoy的效果。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pkg/cmd/cmd.<span class="keyword">go</span> #<span class="number">29</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitSignal</span><span class="params">(stop <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    &lt;-sigs</span><br><span class="line">    <span class="built_in">close</span>(stop)</span><br><span class="line">    _ = log.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通知子服务关闭envoy</li></ul><blockquote><p>在golang有一个上下文管理包 <code>context</code>，这个包通过广播的方式通知各子服务执行关闭操作。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">istio.io/istio/pilot/cmd/pilot-agent/main.<span class="keyword">go</span> #<span class="number">242</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> watcher.Run(ctx)</span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">cmd.WaitSignal(stop)</span><br><span class="line">&lt;-stop</span><br><span class="line"><span class="comment">//通知子服务</span></span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line">istio.io/istio/pilot/pkg/proxy/agent.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *agent)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//接收到主服务信息通知envoy退出</span></span><br><span class="line">    <span class="keyword">case</span> _, more := &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">if</span> !more &#123;</span><br><span class="line">        a.terminate()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istio.io/istio/pilot/pkg/proxy/envoy/v1/watcher.<span class="keyword">go</span> #<span class="number">297</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxy envoy)</span> <span class="title">Run</span><span class="params">(config <span class="keyword">interface</span>&#123;&#125;, epoch <span class="keyword">int</span>, abort &lt;-<span class="keyword">chan</span> error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-abort:</span><br><span class="line">      log.Warnf(<span class="string">"Aborting epoch %d"</span>, epoch)</span><br><span class="line">      <span class="comment">//发送 KILL信号给envoy</span></span><br><span class="line">      <span class="keyword">if</span> errKill := cmd.Process.Kill(); errKill != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warnf(<span class="string">"killing epoch %d caused an error %v"</span>, epoch, errKill)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面展示了pilot-agent从k8s接收信号到通知envoy关闭的过程，这个过程说明了poilt-agent也是支持优雅关闭。但最终envoy并不能进行优雅关闭，这和pilot-agent发送KILL信号没关系，这是因为envoy本身就不支持。</p></blockquote><h4 id="envoy优雅关闭"><a href="#envoy优雅关闭" class="headerlink" title="envoy优雅关闭"></a>envoy优雅关闭</h4><ul><li>遗憾通知</li></ul><blockquote><p>来到这里很遗憾通知你envoy自己不能进行优雅关闭，envoy会接收SIGTERM，SIGHUP，SIGCHLD，SIGUSR1这4个信号，但是这4个都与优雅无关，这4个信号的作用可看<a href="https://www.envoyproxy.io/docs/envoy/latest/operations/hot_restarter" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>。当然官方也注意到这个问题，可以到github了解一下<a href="https://github.com/envoyproxy/envoy/issues/2920" target="_blank" rel="external nofollow noopener noreferrer">2920</a> <a href="https://github.com/envoyproxy/envoy/pull/3307" target="_blank" rel="external nofollow noopener noreferrer">3307</a>。</p></blockquote><ul><li>替代方案</li></ul><blockquote><p>其实使用优雅关闭想达到的目的是：让服务平滑升级，减少对用户的影响。所以我们可以用<a href="https://kubernetes.feisky.xyz/zh/apps/istio-traffic-management.html#金丝雀部署" target="_blank" rel="external nofollow noopener noreferrer">金丝雀部署</a>来实现，并非一定要envoy实现。大致的流程：</p></blockquote><ol><li>定义服务的旧版本（v1），新版本（v2）</li><li>发布新版本</li><li>将流量按照梯度的方式，慢慢迁移到v2</li><li>迁移完成，运行一段时间，没问题就关闭v1</li></ol><ul><li>golang 优雅退出HTTP服务</li></ul><blockquote><p>借此机会了解下golang的优雅关闭，golang在1.8版本的时候就支持这个特性</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">net/http/server.<span class="keyword">go</span> #<span class="number">2487</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  atomic.AddInt32(&amp;srv.inShutdown, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">defer</span> atomic.AddInt32(&amp;srv.inShutdown, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  srv.mu.Lock()</span><br><span class="line">  <span class="comment">// 把监听者关掉</span></span><br><span class="line">  lnerr := srv.closeListenersLocked()</span><br><span class="line">  srv.closeDoneChanLocked()</span><br><span class="line">    <span class="comment">//执行开发定义的函数如果有</span></span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> srv.onShutdown &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">  &#125;</span><br><span class="line">    srv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定时查询是否有未关闭的链接</span></span><br><span class="line">  ticker := time.NewTicker(shutdownPollInterval)</span><br><span class="line">  <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> srv.closeIdleConns() &#123;</span><br><span class="line">      <span class="keyword">return</span> lnerr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实golang的关闭机制和envoy在github上讨论优雅关闭机制很相似：</p></blockquote><h6 id="golang机制"><a href="#golang机制" class="headerlink" title="golang机制"></a>golang机制</h6><ol><li>关闭监听者（<code>ln, err := net.Listen(&quot;tcp&quot;, addr)</code>，向ln赋nil）</li><li>定时查询是否有未关闭的链接</li><li>所有链接都是退出，服务退出</li></ol><h6 id="envoy机制："><a href="#envoy机制：" class="headerlink" title="envoy机制："></a>envoy机制：</h6><ol><li>ingress listeners stop accepting new connections (clients see TCP connection refused) but continues to service existing connections. egress listeners are completely unaffected</li><li>configurable delay to allow workload to finish servicing existing connections</li><li>envoy (and workload) both terminate</li></ol><h3 id="生成-sidecar-配置"><a href="#生成-sidecar-配置" class="headerlink" title="生成 sidecar 配置"></a>生成 sidecar 配置</h3><p>sidecar 的配置主要在 pilot-agent 的 init 方法与 proxy 命令处理流程的前半部分生成。其中 init 方法为 pilot-agent 二进制的命令行配置大量的 flag 与默认值，而 proxy 命令处理流程则负责将这些 flag 组装成为 ProxyConfig 对象以启动 <code>Envoy</code>。下面分析几个相对重要的配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 语言，源码摘自 pilot-agent，role 角色定义</span></span><br><span class="line">role = &amp;model.Proxy&#123;&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ClusterID 用于指代 proxy 所在集群名称</span></span><br><span class="line">    ClusterID <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type 用于标记 proxy 运行模式</span></span><br><span class="line">    Type NodeType</span><br><span class="line"></span><br><span class="line">    IPAddresses []<span class="keyword">string</span></span><br><span class="line">    ID <span class="keyword">string</span></span><br><span class="line">    DNSDomain <span class="keyword">string</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>role 默认的对象为 proxy，关键参数如下：</p><ul><li>Type：pilot-agent 的 <code>role</code> 有两种运行模式。根据 <code>role.Type</code> 变量定义，最新版本有2个类型， <code>sidecar</code>、<code>router</code> 。默认是 <code>sidecar</code>。</li><li>IPAddress， ID：可以接受参数，依据注册中心的类型，给予默认值。默认处理方式是 Kubernetes。在 Kubernetes 默认值下，IPAddress 默认为 <code>INSTANCE_IP</code>，ID 默认为 <code>POD_NAME</code>，DNSDomain 默认为 <code>default.svc.cluster.local</code>。</li><li><code>istio</code>可以对接的第三方注册中心有 Kubernetes、Consul、MCP、Mock。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 语言，源码摘自 pilot-agent ，envoy 启动代理及监听器</span></span><br><span class="line">envoyProxy := envoy.NewProxy(envoy.ProxyConfig&#123;</span><br><span class="line">                Config:              proxyConfig,            <span class="comment">//Envoy 的配置，如目录等</span></span><br><span class="line">                Node:                role.ServiceNode(),    <span class="comment">//role 的字符串拼接 node.Type~ip~ID~DNSDomain 格式</span></span><br><span class="line">                NodeIPs:             role.IPAddresses,</span><br><span class="line">                PodName:             podName,</span><br><span class="line">                PodNamespace:        podNamespace,</span><br><span class="line">                PodIP:               podIP,</span><br><span class="line">                ...</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// envoy 的代理</span></span><br><span class="line">agent := envoy.NewAgent(envoyProxy, features.TerminationDrainDuration())</span><br><span class="line"></span><br><span class="line"><span class="comment">// envoy 的监控和程序，会监听证书变化和启动 envoy </span></span><br><span class="line">watcher := envoy.NewWatcher(tlsCerts, agent.Restart)</span><br><span class="line"><span class="keyword">go</span> watcher.Run(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听停止信号</span></span><br><span class="line"><span class="keyword">go</span> cmd.WaitSignalFunc(cancel)</span><br><span class="line"></span><br><span class="line"><span class="comment">// envoy 主循环，阻塞等待停止信号</span></span><br><span class="line"><span class="keyword">return</span> agent.Run(ctx)</span><br></pre></td></tr></table></figure><p><code>Envoy</code>配置文件及命令行参数主要有2个：</p><ul><li><code>Envoy</code>的启动目录默认为<code>/usr/local/bin/envoy</code></li><li><code>Envoy</code>的启动参数相关代码在<code>func (e *envoy) args</code>中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 语言，源码摘自 pilot-agent ，envoy 启动参数</span></span><br><span class="line">startupArgs := []<span class="keyword">string</span>&#123;<span class="string">"-c"</span>, fname,</span><br><span class="line">        <span class="string">"--restart-epoch"</span>, fmt.Sprint(epoch),</span><br><span class="line">        <span class="string">"--drain-time-s"</span>, fmt.Sprint(<span class="keyword">int</span>(convertDuration(e.Config.DrainDuration) / time.Second)),</span><br><span class="line">        <span class="string">"--parent-shutdown-time-s"</span>, fmt.Sprint(<span class="keyword">int</span>(convertDuration(e.Config.ParentShutdownDuration) / time.Second)),</span><br><span class="line">        <span class="string">"--service-cluster"</span>, e.Config.ServiceCluster,</span><br><span class="line">        <span class="string">"--service-node"</span>, e.Node,</span><br><span class="line">        <span class="string">"--max-obj-name-len"</span>, fmt.Sprint(e.Config.StatNameLength),</span><br><span class="line">        <span class="string">"--local-address-ip-version"</span>, proxyLocalAddressType,</span><br><span class="line">        <span class="string">"--log-format"</span>, fmt.Sprintf(<span class="string">"[Envoy (Epoch %d)] "</span>, epoch) + <span class="string">"[%Y-%m-%d %T.%e][%t][%l][%n] %v"</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Envoy</code>启动参数关键释义：</p><ul><li><code>–restart-epoch</code>：<code>epoch</code> 决定了<code>Envoy</code>热重启的顺序，第一个 <code>Envoy</code>进程对应的 <code>epoch</code> 为0，后面新建的 <code>Envoy</code>进程对应 <code>epoch</code> 顺序递增1</li><li><code>–drain-time-s</code>：在 <code>pilot-agent init</code> 函数中指定默认值为2秒，可通过 <code>pilot-agent proxy</code> 命令的 <code>drainDuration flag</code> 指定</li><li><code>–parent-shutdown-time-s</code>：在 <code>pilot-agent init</code> 函数中指定默认值为3秒，可通过 <code>pilot-agent proxy</code> 命令的 <code>parentShutdownDuration flag</code> 指定</li><li><code>–service-cluster</code>：在 <code>pilot-agent init</code> 函数中指定默认值为 <code>istio-proxy</code> ，可通 <code>pilot-agent proxy</code> 命令的 <code>serviceCluster flag</code> 指定</li><li><code>–service-node</code>：将 <code>role</code> 的字符串拼接成 <code>node.Type~ip~ID~DNSDomain</code> 格式</li></ul><h3 id="Sidecar-的启动与监控"><a href="#Sidecar-的启动与监控" class="headerlink" title="Sidecar 的启动与监控"></a>Sidecar 的启动与监控</h3><ul><li>创建 <code>envoy</code> 对象，结构体包含 <code>proxyConfig</code>、<code>role.serviceNode</code>、<code>loglevel</code> 和 <code>pilotSAN（service account name）</code>等。</li><li>创建 <code>agent</code> 对象，包含前面创建的 <code>envoy</code> 结构体，一个 <code>epochs</code> 的 <code>map</code>，1个 <code>channel</code>：<code>statusCh</code>。</li><li>创建 <code>watcher</code> ，包含证书和 <code>agent.Restart</code> 方法并启动协程执行 <code>watcher.Run</code>。</li><li><code>watcher.Run</code> 首先执行 <code>agent.Restart</code>，启动 <code>Envoy</code>。然后启动协程调用 <code>watchCerts</code> ，用于监控各种证书，如果证书文件发生变化，则重新生成证书签名并重启 Envoy。</li><li>创建 <code>context</code>，启动协程调用 <code>cmd.WaitSignalFunc</code> 以等待进程接收到 <code>SIGINT, SIGTERM</code> 信号，接受到信号之后通过 <code>context</code> 通知 <code>agent</code>，<code>agent</code> 接到通知后调用 <code>terminate</code> 来 kill 所有 <code>Envoy</code>进程，并退出 <code>agent</code> 进程</li><li><code>agent.Run</code> 主进程堵塞，监听 <code>statusCh</code>，这里的 <code>status</code> 其实就是 <code>exitStatus</code>，在监听到 <code>exitStatus</code> 后，会删除当前 <code>epochs</code> 中的 <code>channel</code> 资源。</li></ul><h2 id="pilot-agent"><a href="#pilot-agent" class="headerlink" title="pilot-agent"></a>pilot-agent</h2><p><img alt="img" data-src="https://qiankunli.github.io/public/upload/mesh/pilot_agent.png"></p><ol><li><p>所谓sidecar 容器， 不是直接基于envoy 制作镜像，容器启动后，entrypoint 也是envoy 命令</p></li><li><p>sidecar 容器的entrypoint 是 <code>/usr/local/bin/pilot-agent proxy</code>，首先生成 一个envoyxx.json 文件，然后 使用 exec.Command启动envoy</p></li><li><p>进入sidecar 容器，<code>ps -ef</code> 一下， 是两个进程</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 具体明令参数 未展示</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line"><span class="number">1337</span>         <span class="number">1</span>     <span class="number">0</span>  <span class="number">0</span> May09 ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">49</span> /usr/local/bin/pilot-agent proxy</span><br><span class="line"><span class="number">1337</span>       <span class="number">567</span>     <span class="number">1</span>  <span class="number">1</span> <span class="number">09</span>:<span class="number">18</span> ?        <span class="number">00</span>:<span class="number">04</span>:<span class="number">42</span> /usr/local/bin/envoy -c envoyxx.json</span><br></pre></td></tr></table></figure></li></ol><p>为什么要用pilot-agent？负责Envoy的生命周期管理（生老病死）</p><ol><li>启动envoy</li><li>热更新envoy，poilt-agent只负责启动另一个envoy进程，其他由新旧两个envoy自行处理</li><li>抢救envoy</li><li>优雅关闭envoy</li></ol><h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000015171622" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000015171622</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;script class=&quot;meting-secondary-script-marker&quot; src=&quot;/assets/js/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h2 id=&quot;pilot-agent-是什么？&quot;&gt;&lt;a href=&quot;#pilot-agent-是什么？&quot; class=&quot;headerlink&quot; title=&quot;pilot-agent 是什么？&quot;&gt;&lt;/a&gt;pilot-agent 是什么？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;　当我们执行 &lt;code&gt;kubectl apply -f &amp;lt;(~istioctl kube-inject -f sleep.yaml)&lt;/code&gt;的时候，k8s就会帮我们建立3个容器。&lt;/p&gt;
&lt;/blockquote&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@izwz9cffi0prthtem44cp9z ~]# docker ps |grep sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8e0de7294922        istio&lt;span class=&quot;built_in&quot;&gt;/proxy &lt;/span&gt;                                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ccddc800b2a2        registry.cn-shenzhen.aliyuncs.com/jukylin/sleep                          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;990868aa4a42        registry-vpc.cn-shenzhen.aliyuncs.com/acs/pause-amd64:3.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
      <category term="pilot" scheme="http://houmin.cc/tags/pilot/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio Pilot Discovery</title>
    <link href="http://houmin.cc/posts/b9ef321a/"/>
    <id>http://houmin.cc/posts/b9ef321a/</id>
    <published>2020-11-29T11:04:40.000Z</published>
    <updated>2020-12-16T07:54:54.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Pilot</code> 作为 <code>Istio</code> 控制面流量管理的核心组件，为整个服务网格提供了<strong>标准的独立与各种平台的服务模型</strong>，支持从 Kubernetes、Consul 等多种平台获取服务发现功能，支持用户通过 <code>VirtualService</code>、<code>Gateway</code>等API定制服务间的流量管理规则，并将这些配置信息转化为统一的服务发现和流量控制模型，以 xDS 方式下发到数据面。</p><a id="more"></a><p><code>pilot-discovery</code> 扮演服务注册中心、<code>istio</code>控制平面到 <code>sidecar</code>之间的桥梁作用，负责将服务信息和配置数据转换为xDS接口的标准数据结构，通过gRPC下发到数据面的Envoy。</p><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_input_output.png"></p><p>目前Pilot的输入包括两部分数据来源：</p><ul><li>服务数据： 来源于各个服务注册表(Service Registry)，例如Kubernetes中注册的Service，Consul Catalog中的服务等。<code>Pilot</code> 监控服务注册中心（如 Kubernetes）的服务注册情况。在 Kubernetes 环境下，会监控 <code>service</code>、<code>endpoint</code>、<code>pod</code>、<code>node</code> 等资源信息。</li><li>配置规则： 各种配置规则，包括路由规则及流量管理规则等，通过Kubernetes CRD(Custom Resources Definition)形式定义并存储在Kubernetes中。<code>Pilot</code> 会监控 <code>istio</code>控制面信息变化，在 Kubernetes 环境下，会监控包括 <code>RouteRule</code>、 <code>VirtualService</code>、<code>Gateway</code>、<code>EgressRule</code>、<code>ServiceEntry</code> 等以 Kubernetes <code>CRD</code>形式存在的 <code>istio</code>控制面配置信息。</li></ul><p>Pilot的输出为符合xDS接口的数据面配置数据，并通过gRPC Streaming接口将配置数据推送到数据面的Envoy中。</p><h2 id="获取配置和服务数据"><a href="#获取配置和服务数据" class="headerlink" title="获取配置和服务数据"></a>获取配置和服务数据</h2><p>底层平台 多种多样，istio 抽象一套自己的数据模型（<code>pilot/pkg/model</code>）及数据存取接口，以屏蔽底层平台。</p><h3 id="服务数据部分"><a href="#服务数据部分" class="headerlink" title="服务数据部分"></a>服务数据部分</h3><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_discovery.png"></p><p>中间Abstract Model 层 实现如下</p><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_service_object.png"></p><p>Service describes an Istio service (e.g., catalog.mystore.com:8080)Each service has a fully qualified domain name (FQDN) and one or more ports where the service is listening for connections. Service用于表示Istio服务网格中的一个服务（例如 catalog.mystore.com:8080)。每一个服务有一个全限定域名(FQDN)和一个或者多个接收客户端请求的监听端口。</p><p>SercieInstance中存放了服务实例相关的信息，一个Service可以对应到一到多个Service Instance，Istio在收到客户端请求时，会根据该Service配置的LB策略和路由规则从可用的Service Instance中选择一个来提供服务。</p><p>ServiceDiscovery抽象了一个服务发现的接口，所有接入istio 的平台应提供该接口实现。</p><p>Controller抽象了一个Service Registry变化通知的接口，该接口会将Service及Service Instance的增加，删除，变化等消息通知给ServiceHandler(也就是一个func)。<strong>调用Controller的Run方法后，Controller会一直执行，将监控Service Registry的变化，并将通知到注册到Controller中的ServiceHandler中</strong>。</p><p>由上图可知，底层平台 接入时必须实现 ServiceDiscovery 和 Controller，提供Service 数据，并在Service 变动时 执行handler。 整个流程 由Controller.Run 触发，将平台数据 同步and 转换到 istio 内部数据模型（ServiceDiscovery实现），若数据有变化，则触发handler。</p><h3 id="配置数据部分"><a href="#配置数据部分" class="headerlink" title="配置数据部分"></a>配置数据部分</h3><p><code>ConfigController</code> 是 <code>Pilot</code>实现配置信息监控与处理的核心，它关联的几个关键的结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 语言，源码摘自 pilot-discovery，pilot-discovery 实现配置监听的关键部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储 route rule、virtualservice 等流量配置信息</span></span><br><span class="line"><span class="keyword">type</span> ConfigStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Schemas() collection.Schemas</span><br><span class="line">    Get(typ resource.GroupVersionKind, name, namespace <span class="keyword">string</span>) *Config</span><br><span class="line">    List(typ resource.GroupVersionKind, namespace <span class="keyword">string</span>) ([]Config, error)</span><br><span class="line">    Create(config Config) (revision <span class="keyword">string</span>, err error)</span><br><span class="line">    Update(config Config) (newRevision <span class="keyword">string</span>, err error)</span><br><span class="line">    Delete(typ resource.GroupVersionKind, name, namespace <span class="keyword">string</span>) error</span><br><span class="line">    Version() <span class="keyword">string</span></span><br><span class="line">    GetResourceAtVersion(version <span class="keyword">string</span>, key <span class="keyword">string</span>) (resourceVersion <span class="keyword">string</span>, err error)</span><br><span class="line">    GetLedger() ledger.Ledger</span><br><span class="line">    SetLedger(ledger.Ledger) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展了 ConfigStore 存储，并提供资源处理的注册函数，使用此函数注册后，资源变更会回调 handler 处理</span></span><br><span class="line"><span class="keyword">type</span> ConfigStoreCache <span class="keyword">interface</span> &#123;</span><br><span class="line">    RegisterEventHandler(kind resource.GroupVersionKind, handler <span class="function"><span class="keyword">func</span><span class="params">(Config, Config, Event)</span>)</span></span><br><span class="line">    Run(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    HasSynced() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//controller 实现了 ConfigStore 接口和 ConfigStoreCache 接口</span></span><br><span class="line"><span class="keyword">type</span> controller <span class="keyword">struct</span> &#123;</span><br><span class="line">    client *Client</span><br><span class="line">    queue  queue.Instance</span><br><span class="line">    kinds  <span class="keyword">map</span>[resource.GroupVersionKind]*cacheHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// controller 的 queue 的类型，包装了 Task 任务</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">interface</span> &#123;</span><br><span class="line">    Push(task Task)</span><br><span class="line">    Run(&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//initServiceControllers 下的 kubernets 下的 Controller ，由 initKubeRegistry 创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(client kubernetes.Interface, options Options)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">    c := &amp;Controller&#123;</span><br><span class="line">        client:                     client,</span><br><span class="line">        queue:                      queue.NewQueue(<span class="number">1</span> * time.Second),</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    registerHandlers(c.services, c.queue, <span class="string">"Services"</span>, c.onServiceEvent)</span><br></pre></td></tr></table></figure><p><code>ConfigController</code> 用于处理 <code>istio</code>流控 <code>CRD</code>, 如 <code>VirtualService</code>、<code>DestinationRule</code> 等。</p><ul><li><code>ConfigStore</code> 对象利用 client-go 库从 Kubernetes 获取 <code>RouteRule</code>、<code>VirtualService</code> 等 <code>CRD</code>形式存在控制面信息，转换为 <code>model</code> 包下的 Config 对象，对外提供 <code>Get</code>、<code>List</code>、<code>Create</code>、<code>Update</code>、<code>Delete</code> 等 CRUD 服务。</li><li><code>ConfigStoreCache</code> 则主要扩展了：注册 Config 变更事件处理函数 <code>RegisterEventHandler</code> 、开始处理流程的 <code>Run</code> 方法。</li></ul><p><code>Pilot</code>中，目前实现了 <code>ConfigStoreCache</code> 的 <code>controller</code> 主要有以下五种：</p><ul><li><code>crd/controller/controller.go</code></li><li><code>serviceregistry/mcp/controller.go</code></li><li><code>kube/gateway/controller.go</code></li><li><code>kube/ingress/controller.go</code></li><li><code>memory/controller.go</code></li></ul><p>其中比较关键的是 <code>crd controller</code>。<code>CRD</code>是 <code>CustomResourceDefinition</code> 的缩写 ，<code>CRD</code>Contriller 利用 <code>SharedIndexInformer</code> 实现对 <code>CRD</code>资源的 <code>list/watch</code>。将 <code>Add</code>、<code>Update</code>、<code>Delete</code> 事件涉及到的 <code>CRD</code>资源对象封装为一个 Task ，并 push 到 <code>ConfigController</code> 的 <code>queue</code> 里，<code>queue</code> 队列始终处于监听状态，只要队列中有内容，就会回调 <code>task</code> 函数执行。关键代码的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 语言，源码摘自 pilot-discovery，pilot-discovery 实现配置监听的关键部分，接上一段代码中的 registerHandlers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerHandlers</span><span class="params">(informer cache.SharedIndexInformer, q queue.Instance, otype <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    handler <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;, model.Event)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    informer.AddEventHandler(</span><br><span class="line">        cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                q.Push(...)</span><br><span class="line">                ...</span><br><span class="line">            &#125;,</span><br><span class="line">            UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                q.Push(...)</span><br><span class="line">                ...</span><br><span class="line">            &#125;,</span><br><span class="line">            DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                q.Push(...)</span><br><span class="line">                ...</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//queue 的实现，始终等待执行 task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queueImpl)</span> <span class="title">Run</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(q.tasks) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        task, q.tasks = q.tasks[<span class="number">0</span>], q.tasks[<span class="number">1</span>:]</span><br><span class="line">        task()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_config_object.png"></p><p>ConfigStore describes a set of platform agnostic APIs that must be supported by the underlying platform to store and retrieve Istio configuration. ConfigStore定义一组平台无关的，但是底层平台（例如K8S）必须支持的API，通过这些API可以存取Istio配置信息每个配置信息的键，由type + name + namespace的组合构成，确保每个配置具有唯一的键。写操作是异步执行的，也就是说Update后立即Get可能无法获得最新结果。</p><p>ConfigStoreCache表示ConfigStore的本地完整复制的缓存，此缓存主动和远程存储保持同步，并且在获取更新时提供提供通知机制。为了获得通知，事件处理器必须在Run之前注册，缓存需要在Run之后有一个初始的同步延迟。</p><p>IstioConfigStore扩展ConfigStore，增加一些针对Istio资源的操控接口</p><p>由上图可知，底层平台 接入时必须实现 ConfigStoreCache，提供Config 数据，并在Config 变动时 执行handler。 整个流程 由ConfigStoreCache.Run 触发，将平台数据 同步and 转换到 istio 内部数据模型（ConfigStore实现），若数据有变化，则触发handler。</p><h3 id="Environment-聚合"><a href="#Environment-聚合" class="headerlink" title="Environment 聚合"></a>Environment 聚合</h3><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_environment_object.png"></p><p>Environment provides an aggregate environmental API for Pilot. Environment为Pilot提供聚合的环境性的API</p><p>由上文可知，启动时，向 Controller 和 ConfigStoreCache 注册handler，执行 ConfigStoreCache.Run 和 Controller.Run，便可以同步 service 和config 数据，并在数据变动时 触发handler 执行。<strong>pilot数据输入的部分就解决了</strong></p><p><img alt="img" data-src="https://qiankunli.github.io/public/upload/mesh/pilot_component.svg"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>pilot-discovery 关键实现逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go 语言，源码摘自 pilot-discovery，pilot-discovery 初始化及启动的关键部分，省去异常处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 discoveryServer 对象并启动</span></span><br><span class="line">discoveryServer, err := bootstrap.NewServer(serverArgs)</span><br><span class="line">discoveryServer.Start(stop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// discoveryServer 对象的具体创建方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(args *PilotArgs)</span> <span class="params">(\*Server, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//环境变量</span></span><br><span class="line">    e := &amp;model.Environment&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    s := &amp;Server&#123;</span><br><span class="line">        clusterID:      getClusterID(args),                                <span class="comment">//集群id</span></span><br><span class="line">        environment:    e,                                                <span class="comment">//环境变量</span></span><br><span class="line">        EnvoyXdsServer: envoyv2.NewDiscoveryServer(e, args.Plugins),     <span class="comment">//Pilot 针对 Envoy v2 xds APIs 的 gRPC 实现，用于通知 envoy 配置更新</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.initKubeClient(args)</span><br><span class="line">    s.initMeshConfiguration(args, fileWatcher)        </span><br><span class="line">    s.initConfigController(args)                    </span><br><span class="line">    s.initServiceControllers(args)</span><br><span class="line">    s.initDiscoveryService(args)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">gRPC服务启动</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Start</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.grpcServer.Serve(s.GRPCListener)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pilot-discovery 的初始化主要在 pilot-discovery 的 <code>init</code> 方法和在 <code>discovery</code> 命令处理流程中调用的 <code>bootstrap.NewServer</code> 完成，关键步骤如下：</p><ul><li>创建 <code>Kubernetes apiserver client</code>（initKubeClient），可以在 pilot-discovery 的 <code>discovery</code> 命令的 <code>kubeconfig flag</code> 中提供文件路径，默认为空。</li><li>读取 <code>mesh</code> 配置（initMeshConfiguration），包含 <code>MixerCheckServer</code>、<code>MixerReportServer</code>、<code>ProxyListenPort</code>、<code>RdsRefreshDelay</code>、<code>MixerAddress</code> 等一些列配置，默认 <code>mesh</code> 配置文件”/etc/<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">istio</a>/config/mesh”。</li><li>初始化与配置存储中心的连接（initConfigController 方法）对 <code>istio</code>做出的各种配置，比如 <code>route rule</code>、<code>virtualservice</code> 等，需要保存在配置存储中心（config store）内。</li><li>配置与服务注册中心（service registry）的连接（initServiceControllers 方法）</li><li>初始化 discovery 服务（initDiscoveryService），将 discovery 服务注册为 Config Controller 和 <code>Service</code> Controller 的 Event Handler，监听配置和服务变化消息。</li><li>启动 gRPC Server 并接收来自 <code>Envoy</code>端的连接请求。</li><li>接收 <code>sidecar</code>端的 xDS 请求，从 Config Controller、<code>Service</code> Controller 中获取配置和服务信息，生成响应消息发送给 <code>sidecar</code>。</li><li>监听来自 Config Controller 、<code>Service</code> Controller 的变化消息，并将配置、服务变化内容通过 xDS 接口推送到 <code>sidecar</code>。</li></ul><p>启动命令示例：<code>/usr/local/bin/pilot-discovery discovery --monitoringAddr=:15014 --log_output_level=default:info --domain cluster.local --secureGrpcAddr --keepaliveMaxServerConnectionAge 30m</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bootstrap</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(args *PilotArgs)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    s.initKubeClient(args)</span><br><span class="line">    s.initMeshConfiguration(args, fileWatcher)</span><br><span class="line">    s.initMeshNetworks(args, fileWatcher)</span><br><span class="line">    s.initCertController(args)</span><br><span class="line">    s.initConfigController(args)</span><br><span class="line">    s.initServiceControllers(args)</span><br><span class="line">    s.initDiscoveryService(args)</span><br><span class="line">    s.initMonitor(args.DiscoveryOptions.MonitoringAddr)</span><br><span class="line">    s.initClusterRegistries(args)</span><br><span class="line">    s.initDNSListener(args)</span><br><span class="line">    <span class="comment">// Will run the sidecar injector in pilot.Only operates if /var/lib/istio/inject exists</span></span><br><span class="line">    s.initSidecarInjector(args)</span><br><span class="line">    s.initSDSCA(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动的逻辑很多，但从config+service+grcServer 视角看 启动代码的核心如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(args *PilotArgs)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> s.configController.Run(stop)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> serviceControllers.Run(stop)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ## DiscoveryServer 注册config/service 事件handler</span><br><span class="line">    s.initEventHandlers()&#123;</span><br><span class="line">        s.ServiceController().AppendServiceHandler(serviceHandler)</span><br><span class="line">        s.ServiceController().AppendInstanceHandler(instanceHandler)</span><br><span class="line">        s.configController.RegisterEventHandler(descriptor.Type, configHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    s.initGrpcServer(args.KeepaliveOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理xds请求"><a href="#处理xds请求" class="headerlink" title="处理xds请求"></a>处理xds请求</h2><p>如果golang 里有类似 tomcat、springmvc 的组件，那源码看起来就很简单了。</p><p><img alt="img" data-src="https://qiankunli.github.io/public/upload/mesh/pilot_discovery_overview.png"></p><p>envoy 通过grpc 协议与 pilot-discovery 交互，因此首先找 ads.proto 文件</p><p><a href="https://github.com/envoyproxy/data-plane-api/blob/master/envoy/service/discovery/v2/ads.proto" target="_blank" rel="external nofollow noopener noreferrer">ads.proto</a></p><p>基于ads.proto 生成 ads.pb.go 文件<code>github.com/envoyproxy/go-control-plane/envoy/service/discovery/v2/ads.pb.go</code> 其中定义了 服务接口 AggregatedDiscoveryServiceServer，其实现类 DiscoveryServer，DiscoveryServer 方法分散于多个go 文件中</p><p><img alt="img" data-src="https://qiankunli.github.io/public/upload/mesh/pilot_discovery_server.png"></p><p>DiscoveryServer 通过Environment 间接持有了 config和 service 数据。此外， pilot-discovery Server启动时便 为DiscoveryServer 注册了config service 变更处理函数，<strong>不管config/service 如何变更，都会触发 DiscoveryServer.ConfigUpdate</strong>。</p><p>代码中 Server.EnvoyXdsServer 就是DiscoveryServer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initEventHandlers</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Flush cached discovery responses whenever services configuration change.</span></span><br><span class="line">    serviceHandler := <span class="function"><span class="keyword">func</span><span class="params">(svc *model.Service, _ model.Event)</span></span> &#123;</span><br><span class="line">        pushReq := &amp;model.PushRequest&#123;...&#125;</span><br><span class="line">        s.EnvoyXdsServer.ConfigUpdate(pushReq)</span><br><span class="line">    &#125;</span><br><span class="line">    s.ServiceController().AppendServiceHandler(serviceHandler)</span><br><span class="line">    instanceHandler := <span class="function"><span class="keyword">func</span><span class="params">(si *model.ServiceInstance, _ model.Event)</span></span> &#123;</span><br><span class="line">        s.EnvoyXdsServer.ConfigUpdate(&amp;model.PushRequest&#123;...&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    s.ServiceController().AppendInstanceHandler(instanceHandler)</span><br><span class="line">    <span class="keyword">if</span> s.configController != <span class="literal">nil</span> &#123;</span><br><span class="line">        configHandler := <span class="function"><span class="keyword">func</span><span class="params">(old, curr model.Config, _ model.Event)</span></span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            s.EnvoyXdsServer.ConfigUpdate(pushReq)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, descriptor := <span class="keyword">range</span> schemas.Istio &#123;</span><br><span class="line">            s.configController.RegisterEventHandler(descriptor.Type, configHandler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>Proxy contains information about an specific instance of a proxy (envoy sidecar, gateway,etc). The Proxy is initialized when a sidecar connects to Pilot, and populated from ‘node’ info in the protocol as well as data extracted from registries. proxy struct是sidecar 在 pilot 内的一个表示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    ClusterID <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Type specifies the node type. First part of the ID.</span></span><br><span class="line">    Type NodeType</span><br><span class="line">    IPAddresses []<span class="keyword">string</span></span><br><span class="line">    ID <span class="keyword">string</span></span><br><span class="line">    Locality *core.Locality</span><br><span class="line">    <span class="comment">// DNSDomain defines the DNS domain suffix for short hostnames (e.g.</span></span><br><span class="line">    <span class="comment">// "default.svc.cluster.local")</span></span><br><span class="line">    DNSDomain <span class="keyword">string</span></span><br><span class="line">    ConfigNamespace <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Metadata key-value pairs extending the Node identifier</span></span><br><span class="line">    Metadata *NodeMetadata</span><br><span class="line">    <span class="comment">// the sidecarScope associated with the proxy</span></span><br><span class="line">    SidecarScope *SidecarScope</span><br><span class="line">    <span class="comment">// The merged gateways associated with the proxy if this is a Router</span></span><br><span class="line">    MergedGateway *MergedGateway</span><br><span class="line">    <span class="comment">// service instances associated with the proxy</span></span><br><span class="line">    ServiceInstances []*ServiceInstance</span><br><span class="line">    <span class="comment">// labels associated with the workload</span></span><br><span class="line">    WorkloadLabels labels.Collection</span><br><span class="line">    <span class="comment">// Istio version associated with the Proxy</span></span><br><span class="line">    IstioVersion *IstioVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="envoy-向pilot-发送请求"><a href="#envoy-向pilot-发送请求" class="headerlink" title="envoy 向pilot 发送请求"></a>envoy 向pilot 发送请求</h3><p>grpc 请求通过 <code>StreamAggregatedResources</code> 来处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream ads.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    peerInfo, ok := peer.FromContext(stream.Context())</span><br><span class="line">    ...</span><br><span class="line">    con := newXdsConnection(peerAddr, stream)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// xds请求消息接收，接收后存放到reqChannel中</span></span><br><span class="line">    reqChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> *xdsapi.DiscoveryRequest, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> receiveThread(con, reqChannel, &amp;receiveError)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> discReq, ok := &lt;-reqChannel:</span><br><span class="line">            <span class="keyword">switch</span> discReq.TypeUrl &#123;</span><br><span class="line">            <span class="keyword">case</span> ClusterType:</span><br><span class="line">                ...</span><br><span class="line">                err := s.pushCds(con, s.globalPushContext(), versionInfo())</span><br><span class="line">            <span class="keyword">case</span> ListenerType:</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">case</span> RouteType:</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">case</span> EndpointType:</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> pushEv := &lt;-con.pushChannel:</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StreamAggregatedResources 函数的for循环是无限循环流程，这里会监控两个channel 通道的消息，一个是reqChannel的新连接消息， 一个是pushChannel的配置变更消息。reqChannel 接收到新数据时，会从reqChannel 取出xds 请求消息discReq， 然后根据不同类型的xds请求，调用相应的xds下发逻辑。在v2版本的xds 协议实现中，<strong>为了保证多个xds数据下发的顺序，lds、rds、cds和eds 等所有的交互均在一个grpc 连接上完成</strong>，因此StreamAggregatedResources 接收到第一个请求时，会将连接保存起来，供后续配置变更时使用。</p><p>DiscoveryServer 收到 ClusterType 的请求要生成 cluster 数据响应</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">pushCds</span><span class="params">(con *XdsConnection, push *model.PushContext, version <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    rawClusters := s.generateRawClusters(con.node, push)</span><br><span class="line">    ...</span><br><span class="line">    response := con.clusters(rawClusters, push.Version)</span><br><span class="line">    err := con.send(response)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cluster 数据实际由ConfigGenerator 生成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> (<span class="selector-tag">s</span> *<span class="selector-tag">DiscoveryServer</span>) <span class="selector-tag">generateRawClusters</span>(<span class="selector-tag">node</span> *<span class="selector-tag">model</span><span class="selector-class">.Proxy</span>, <span class="selector-tag">push</span> *<span class="selector-tag">model</span><span class="selector-class">.PushContext</span>) <span class="selector-attr">[]</span>*<span class="selector-tag">xdsapi</span><span class="selector-class">.Cluster</span> &#123;</span><br><span class="line">    <span class="attribute">rawClusters </span>:= s.ConfigGenerator.<span class="built_in">BuildClusters</span>(node, push)</span><br><span class="line">    ...</span><br><span class="line">    return rawClusters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据来自PushContext.Services 方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> (<span class="selector-tag">configgen</span> *<span class="selector-tag">ConfigGeneratorImpl</span>) <span class="selector-tag">buildOutboundClusters</span>(<span class="selector-tag">proxy</span> *<span class="selector-tag">model</span><span class="selector-class">.Proxy</span>, <span class="selector-tag">push</span> *<span class="selector-tag">model</span><span class="selector-class">.PushContext</span>) <span class="selector-attr">[]</span>*<span class="selector-tag">apiv2</span><span class="selector-class">.Cluster</span> &#123;</span><br><span class="line">    <span class="attribute">clusters </span>:= <span class="built_in">make</span>([]*apiv2.Cluster, <span class="number">0</span>)</span><br><span class="line">    networkView := model.<span class="built_in">GetNetworkView</span>(proxy)</span><br><span class="line">    for _, service := range push.<span class="built_in">Services</span>(proxy) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">clusters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cluster 数据来自 PushContext的privateServicesByNamespace 和 publicServices， 通过代码可以发现，它们都是初始化时从model.Environment 取Service 数据的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (ps *PushContext) Services(proxy *Proxy) []*Service &#123;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    out := make([]*Service, 0)</span><br><span class="line">    <span class="keyword">if</span><span class="built_in"> proxy </span>== <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, privateServices := range ps.privateServicesByNamespace &#123;</span><br><span class="line">            out = append(out, privateServices<span class="built_in">..</span>.)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out = append(out, ps.privateServicesByNamespace[proxy.ConfigNamespace]<span class="built_in">..</span>.)</span><br><span class="line">    &#125;</span><br><span class="line">    out = append(out, ps.publicServices<span class="built_in">..</span>.)</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pilot-监控到配合变化-将数据推给envoy"><a href="#pilot-监控到配合变化-将数据推给envoy" class="headerlink" title="pilot 监控到配合变化 将数据推给envoy"></a>pilot 监控到配合变化 将数据推给envoy</h3><p>istio 收到变更事件并没有立即处理，而是创建一个定时器事件，通过定时器事件延迟一段时间。这样做的初衷：</p><ol><li>减少配置变更的下发频率（会对多次变更进行合并），进而减少pilot 和 envoy 的通信开销（毕竟是广播，每一个envoy 都要发）</li><li>延迟对配置变更消息的处理， 可以保证配置下发时变更的完整性</li></ol><p>config 或 service 数据变更触发 DiscoveryServer.ConfigUpdate 发送请求到 pushChannel</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">ConfigUpdate</span><span class="params">(req *model.PushRequest)</span> &#123;</span></span><br><span class="line">    inboundConfigUpdates.Increment()</span><br><span class="line">    s.pushChannel &lt;- req</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DiscoveryServer 启动时 触发了handleUpdates 负责DiscoveryServer.pushChannel 的消费</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (s *DiscoveryServer) <span class="constructor">Start(<span class="params">stopCh</span> &lt;-<span class="params">chan</span> <span class="params">struct</span>&#123;&#125;)</span> &#123;</span><br><span class="line">    go s.handle<span class="constructor">Updates(<span class="params">stopCh</span>)</span></span><br><span class="line">    go s.periodic<span class="constructor">RefreshMetrics(<span class="params">stopCh</span>)</span></span><br><span class="line">    go s.send<span class="constructor">Pushes(<span class="params">stopCh</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleUpdates 触发 debounce(防抖动)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数ch实际是 pushChannel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">debounce</span><span class="params">(ch <span class="keyword">chan</span> *model.PushRequest, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, pushFn <span class="keyword">func</span>(req *model.PushRequest)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req *model.PushRequest</span><br><span class="line">    pushWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 符合一定条件 执行 pushFn</span></span><br><span class="line">        <span class="keyword">go</span> push(req)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-freeCh:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> r := &lt;-ch:</span><br><span class="line">            ...</span><br><span class="line">            req = req.Merge(r)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeChan:</span><br><span class="line">            <span class="keyword">if</span> free &#123;</span><br><span class="line">                pushWorker()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pushFn 实际是DiscoveryServer.Push ==&gt; AdsPushAll ==&gt; startPush 将数据塞入 PushQueue中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (s *DiscoveryServer) <span class="constructor">Push(<span class="params">req</span> <span class="operator">*</span><span class="params">model</span>.PushRequest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">        req.Push = s.global<span class="constructor">PushContext()</span></span><br><span class="line">        go s.<span class="constructor">AdsPushAll(<span class="params">versionInfo</span>()</span>, req)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    req.Push = push</span><br><span class="line">    go s.<span class="constructor">AdsPushAll(<span class="params">versionLocal</span>, <span class="params">req</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DiscoveryServer 启动时 触发sendPushes ，负责消费PushQueue ==&gt; doSendPushes 最终发给每一个envoy/conneciton 的pushChannel ，envoy/conneciton 的pushChannel 的消费逻辑在DiscoveryServer.StreamAggregatedResources的for 循环中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream ads.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> discReq, ok := &lt;-reqChannel:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> pushEv := &lt;-con.pushChannel:</span><br><span class="line">            err := s.pushConnection(con, pushEv)</span><br><span class="line">    pushEv.done()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><img alt="img" data-src="https://qiankunli.github.io/public/upload/mesh/pilot_package.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhonghua.io/2019/05/12/istio-analysis-4" target="_blank" rel="external nofollow noopener noreferrer">https://zhonghua.io/2019/05/12/istio-analysis-4</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Pilot&lt;/code&gt; 作为 &lt;code&gt;Istio&lt;/code&gt; 控制面流量管理的核心组件，为整个服务网格提供了&lt;strong&gt;标准的独立与各种平台的服务模型&lt;/strong&gt;，支持从 Kubernetes、Consul 等多种平台获取服务发现功能，支持用户通过 &lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;Gateway&lt;/code&gt;等API定制服务间的流量管理规则，并将这些配置信息转化为统一的服务发现和流量控制模型，以 xDS 方式下发到数据面。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot-arch.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
      <category term="pilot" scheme="http://houmin.cc/tags/pilot/"/>
    
      <category term="discovery" scheme="http://houmin.cc/tags/discovery/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio Pilot</title>
    <link href="http://houmin.cc/posts/df7a23a6/"/>
    <id>http://houmin.cc/posts/df7a23a6/</id>
    <published>2020-11-29T04:00:56.000Z</published>
    <updated>2020-12-15T12:28:08.880Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Pilot</code> 作为 <code>Istio</code> 控制面流量管理的核心组件，为整个服务网格提供了<strong>标准的独立与各种平台的服务模型</strong>，支持从 Kubernetes、Consul 等多种平台获取服务发现功能，支持用户通过 <code>VirtualService</code>、<code>Gateway</code>等API定制服务间的流量管理规则，并将这些配置信息转化为统一的服务发现和流量控制模型，以 xDS 方式下发到数据面。</p><a id="more"></a><p>在组件拓扑中, Pod <code>istio-pilot</code>包括<code>istio-proxy</code>(sidecar)和<code>discovery</code>2个容器, pilot核心能力由容器 <code>discovery</code>中执行的命令<code>pilot-discovery discovery</code>提供.</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot.png"></p><p>图中实线连线表示控制流，虚线连线表示数据流。带 <code>[pilot]</code> 的组件表示为 <code>Pilot</code>组件，图中关键的组件如下：</p><ul><li>Discovery service：即 pilot-discovery，主要功能是从 <code>Service</code> provider（如 kubernetes 或者 consul ）中获取服务信息，从 Kubernetes API Server 中获取流量规则（Kubernetes <code>CRD</code>Resource），并将服务信息和流量规则转化为数据面可以理解的格式，通过标准的数据面 API 下发到网格中的各个 <code>sidecar</code>中。</li><li>agent：即 pilot-agent 组件，该进程根据 Kubernetes API Server 中的配置信息生成 <code>Envoy</code>的配置文件，负责启动、监控 <code>sidecar</code>进程。</li><li>proxy：既 <code>sidecar</code>proxy，是所有服务的流量代理，直接连接 pilot-discovery ，间接地从 Kubernetes 等服务注册中心获取集群中微服务的注册情况。</li><li>service A/B：使用了 <code>istio</code>的应用，如 <code>Service</code> A/B，的进出网络流量会被 proxy 接管。</li></ul><p>下面介绍下 <code>Pilot</code>相关的组件 pilot-agent、pilot-discovery 的关键实现。</p><h2 id="pilot-agent"><a href="#pilot-agent" class="headerlink" title="pilot-agent"></a>pilot-agent</h2><p>pilot-agent 负责的主要工作如下：</p><ul><li>生成 <code>sidecar</code>的配置</li><li>sidecar 的启动与监控</li></ul><h2 id="pilot-discovery"><a href="#pilot-discovery" class="headerlink" title="pilot-discovery"></a>pilot-discovery</h2><p><code>pilot-discovery</code> 扮演服务注册中心、<code>istio</code>控制平面到 <code>sidecar</code>之间的桥梁作用，负责将服务信息和配置数据转换为xDS接口的标准数据结构，通过gRPC下发到数据面的Envoy。</p><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_input_output.png"></p><p>目前Pilot的输入包括两部分数据来源：</p><ul><li>服务数据： 来源于各个服务注册表(Service Registry)，例如Kubernetes中注册的Service，Consul Catalog中的服务等。<code>Pilot</code> 监控服务注册中心（如 Kubernetes）的服务注册情况。在 Kubernetes 环境下，会监控 <code>service</code>、<code>endpoint</code>、<code>pod</code>、<code>node</code> 等资源信息。</li><li>配置规则： 各种配置规则，包括路由规则及流量管理规则等，通过Kubernetes CRD(Custom Resources Definition)形式定义并存储在Kubernetes中。<code>Pilot</code> 会监控 <code>istio</code>控制面信息变化，在 Kubernetes 环境下，会监控包括 <code>RouteRule</code>、 <code>VirtualService</code>、<code>Gateway</code>、<code>EgressRule</code>、<code>ServiceEntry</code> 等以 Kubernetes <code>CRD</code>形式存在的 <code>istio</code>控制面配置信息。</li></ul><p>Pilot的输出为符合xDS接口的数据面配置数据，并通过gRPC Streaming接口将配置数据推送到数据面的Envoy中。</p><p>代码、配置、架构一体化视角 <a href="https://mp.weixin.qq.com/s/hq9KTc9fm8Nou8hXmqdKuw" target="_blank" rel="external nofollow noopener noreferrer">深入解读Service Mesh背后的技术细节</a></p><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_package.jpeg"></p><p>从协议视角看pilot-discovery</p><p><img alt data-src="https://qiankunli.github.io/public/upload/mesh/pilot_protocol_overview.png"></p><h3 id="Config-Controller"><a href="#Config-Controller" class="headerlink" title="Config Controller"></a>Config Controller</h3><p>Config Controller用于管理各种配置数据，包括用户创建的流量管理规则和策略。Istio目前支持三种类型的Config Controller：</p><ul><li>Kubernetes：使用Kubernetes来作为配置数据的存储，该方式直接依附于Kubernetes强大的CRD机制来存储配置数据，简单方便，是Istio最开始使用的配置存储方案。</li><li>MCP (Mesh Configuration Protocol)：使用Kubernetes来存储配置数据导致了Istio和Kubernetes的耦合，限制了Istio在非Kubernetes环境下的运用。为了解决该耦合，Istio社区提出了MCP，MCP定义了一个向Istio控制面下发配置数据的标准协议，Istio Pilot作为MCP Client，任何实现了MCP协议的Server都可以通过MCP协议向Pilot下发配置，从而解除了Istio和Kubernetes的耦合。如果想要了解更多关于MCP的内容，请参考文后的链接。</li><li>Memory：一个在内存中的Config Controller实现，主要用于测试。</li></ul><p>目前Istio的配置包括：</p><ul><li>Virtual Service: 定义流量路由规则。</li><li>Destination Rule: 定义和一个服务或者subset相关的流量处理规则，包括负载均衡策略，连接池大小，断路器设置，subset定义等等。</li><li>Gateway: 定义入口网关上对外暴露的服务。</li><li>Service Entry: 通过定义一个Service Entry可以将一个外部服务手动添加到服务网格中。</li><li>Envoy Filter: 通过Pilot在Envoy的配置中添加一个自定义的Filter。</li></ul><h3 id="Service-Controller"><a href="#Service-Controller" class="headerlink" title="Service Controller"></a>Service Controller</h3><p>Service Controller用于管理各种Service Registry，提出服务发现数据，目前Istio支持的Service Registry包括：</p><ul><li>Kubernetes：对接Kubernetes Registry，可以将Kubernetes中定义的Service和Instance采集到Istio中。</li><li>Consul： 对接Consul Catalog，将Consul中定义的Service采集到Istio中。</li><li>MCP： 和MCP config controller类似，从MCP Server中获取Service和Service Instance。</li><li>Memory： 一个内存中的Service Controller实现，主要用于测试。</li></ul><h3 id="Discovery-Service"><a href="#Discovery-Service" class="headerlink" title="Discovery Service"></a>Discovery Service</h3><p>Discovery Service中主要包含下述逻辑：</p><ul><li>启动gRPC Server并接收来自Envoy端的连接请求。</li><li>接收Envoy端的xDS请求，从Config Controller和Service Controller中获取配置和服务信息，生成响应消息发送给Envoy。</li><li>监听来自Config Controller的配置变化消息和来自Service Controller的服务变化消息，并将配置和服务变化内容通过xDS接口推送到Envoy。（备注：目前Pilot未实现增量变化推送，每次变化推送的是全量配置，在网格中服务较多的情况下可能会有性能问题）。</li></ul><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>Pilot-Disocvery包括以下主要的几个业务流程：</p><h3 id="初始化Pilot-Discovery的各个主要组件"><a href="#初始化Pilot-Discovery的各个主要组件" class="headerlink" title="初始化Pilot-Discovery的各个主要组件"></a>初始化Pilot-Discovery的各个主要组件</h3><p>Pilot-Discovery命令的入口为pilot/cmd/pilot-discovery/main.go中的main方法，在该方法中创建Pilot Server,Server代码位于文件pilot/pkg/bootstrap/server.go中。Server主要做了下面一些初始化工作：</p><ul><li>创建并初始化Config Controller。</li><li>创建并初始化Service Controller。</li><li>创建并初始化Discovery Server，Pilot中创建了基于Envoy V1 API的HTTP Discovery Server和基于Envoy V2 API的GPRC Discovery Server。由于V1已经被废弃，本文将主要分析V2 API的gRPC Discovery Server。</li><li>将Discovery Server注册为Config Controller和Service Controller的Event Handler，监听配置和服务变化消息。</li></ul><p><img alt data-src="https://www.servicemesher.com/blog/201910-pilot-code-deep-dive/pilot-discovery-initialization.svg"></p><h3 id="创建gRPC-Server并接收Envoy的连接请求"><a href="#创建gRPC-Server并接收Envoy的连接请求" class="headerlink" title="创建gRPC Server并接收Envoy的连接请求"></a>创建gRPC Server并接收Envoy的连接请求</h3><p>Pilot Server创建了一个gRPC Server，用于监听和接收来自Envoy的xDS请求。pilot/pkg/proxy/envoy/v2/ads.go 中的 DiscoveryServer.StreamAggregatedResources方法被注册为gRPC Server的服务处理方法。</p><p>当gRPC Server收到来自Envoy的连接时，会调用DiscoveryServer.StreamAggregatedResources方法，在该方法中创建一个XdsConnection对象，并开启一个goroutine从该connection中接收客户端的xDS请求并进行处理；如果控制面的配置发生变化，Pilot也会通过该connection把配置变化主动推送到Envoy端。</p><p><img alt data-src="https://www.servicemesher.com/blog/201910-pilot-code-deep-dive/pilot-discovery-receive-connection.svg"></p><h3 id="配置变化后向Envoy推送更新"><a href="#配置变化后向Envoy推送更新" class="headerlink" title="配置变化后向Envoy推送更新"></a>配置变化后向Envoy推送更新</h3><p>这是Pilot中最复杂的一个业务流程，主要是因为代码中采用了多个channel和queue对变化消息进行合并和转发。该业务流程如下：</p><ol><li>Config Controller或者Service Controller在配置或服务发生变化时通过回调方法通知Discovery Server，Discovery Server将变化消息放入到Push Channel中。</li><li>Discovery Server通过一个goroutine从Push Channel中接收变化消息，将一段时间内连续发生的变化消息进行合并。如果超过指定时间没有新的变化消息，则将合并后的消息加入到一个队列Push Queue中。</li><li>另一个goroutine从Push Queue中取出变化消息，生成XdsEvent，发送到每个客户端连接的Push Channel中。</li><li>在DiscoveryServer.StreamAggregatedResources方法中从Push Channel中取出XdsEvent，然后根据上下文生成符合xDS接口规范的DiscoveryResponse，通过gRPC推送给Envoy端。（gRPC会为每个client连接单独分配一个goroutine来进行处理，因此不同客户端连接的StreamAggregatedResources处理方法是在不同goroutine中处理的）</li></ol><p><img alt data-src="https://www.servicemesher.com/blog/201910-pilot-code-deep-dive/pilot-discovery-push-changes.svg"></p><h3 id="响应Envoy主动发起的xDS请求"><a href="#响应Envoy主动发起的xDS请求" class="headerlink" title="响应Envoy主动发起的xDS请求"></a>响应Envoy主动发起的xDS请求</h3><p>Pilot和Envoy之间建立的是一个双向的Streaming gRPC服务调用，因此Pilot可以在配置变化时向Envoy推送，Envoy也可以主动发起xDS调用请求获取配置。Envoy主动发起xDS请求的流程如下：</p><ol><li>Envoy通过创建好的gRPC连接发送一个DiscoveryRequest</li><li>Discovery Server通过一个goroutine从XdsConnection中接收来自Envoy的DiscoveryRequest，并将请求发送到ReqChannel中</li><li>Discovery Server的另一个goroutine从ReqChannel中接收DiscoveryRequest，根据上下文生成符合xDS接口规范的DiscoveryResponse，然后返回给Envoy。</li></ol><p><img alt data-src="https://www.servicemesher.com/blog/201910-pilot-code-deep-dive/pilot-discovery-client-request.svg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.sel.zju.edu.cn/?p=831" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh 深度学习系列（一）| istio pilot-agent 模块分析</a></li><li><a href="http://www.sel.zju.edu.cn/?p=825" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh 深度学习系列（二）| istio pilot 模块分析</a></li><li><a href="http://www.sel.zju.edu.cn/?p=761" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh 深度学习系列（三）| xds 协议解密</a></li><li><a href="https://www.cnblogs.com/YaoDD/p/11391342.html" target="_blank" rel="external nofollow noopener noreferrer">深入理解 Istio 核心组件之 Pilot</a></li><li><a href="https://www.servicemesher.com/blog/istio-service-mesh-source-code-pilot-agent-deepin/" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh 深度学习系列 part1—istio 源码分析之 pilot-agent 模块分析</a></li><li><a href="https://www.servicemesher.com/blog/istio-analysis-4/" target="_blank" rel="external nofollow noopener noreferrer">Istio 庖丁解牛四：pilot discovery</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Pilot&lt;/code&gt; 作为 &lt;code&gt;Istio&lt;/code&gt; 控制面流量管理的核心组件，为整个服务网格提供了&lt;strong&gt;标准的独立与各种平台的服务模型&lt;/strong&gt;，支持从 Kubernetes、Consul 等多种平台获取服务发现功能，支持用户通过 &lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;Gateway&lt;/code&gt;等API定制服务间的流量管理规则，并将这些配置信息转化为统一的服务发现和流量控制模型，以 xDS 方式下发到数据面。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
      <category term="pilot" scheme="http://houmin.cc/tags/pilot/"/>
    
  </entry>
  
  <entry>
    <title>晚安</title>
    <link href="http://houmin.cc/posts/74fda535/"/>
    <id>http://houmin.cc/posts/74fda535/</id>
    <published>2020-11-28T11:23:16.000Z</published>
    <updated>2020-12-06T16:11:55.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>遵守上周的约定，这周总算是定期发布了2020年「朝花夕拾」的第二十六期 <code>晚安</code>，在上期的记录中，我告诉自己要搭建起自己的睡眠数据监控系统，这周我来介绍下我是如何折腾的。封面来自今天在家拍摄的晚霞，晚安，希望大家都能够睡个好觉。</p>    <div id="aplayer-dwUZXipF" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="439122551" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>在例行每周数据回顾之前，先来看看这周拍摄的光影，仍旧没有出门，但是天朗气清留下了美丽的晚霞，并且抓到了太阳落山的全程。</p><p><img alt="白昼越来越短，黑夜越来越长，下午四点半在家里拍摄，不一会儿太阳就开始触碰山尖" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_sunset-3.png"></p><p><img alt="知春西里一号楼十六层，这个机位也还不错，但是如果能够上楼顶就更好了，下次问问" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_sunset-2.png"></p><p><img alt="将近五点，太阳已经全部落山，整个过程就两三分钟" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_sunset-1.png"></p><p><img alt="落日的同时，人间烟火，我就在这样的小格子里面的一间" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_smoke.png"></p><p>接下来，继续每周的数据回顾，首先是 <code>RescueTime</code>：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_rescue-time.png"></p><p>可以看到，相比于上周，这周总的生产力是要提升的。这周基本实践了上周的策略，工作时间专门找独立时间来处理企业微信上面的消息，而不是一直在线。因为如果真的有什么很要紧的工作的话，打我电话啊，反正我也在企业微信上面置顶了信息。真的，要求时刻在线，时刻能够回复消息对于精力的耗费太大了，这个方法继续坚持。</p><p>因为临近月末，对于每个数据监控，现在也增加月末的数据总结，我们看看 <code>RescueTime</code> 的 11月数据：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_rescue-time-nov.png"></p><p>可以看到，<code>Distracting Time</code> 从月初相对较大的比例，到月末有了一个明显的减少。这是为什么呢？因为我的 <code>Kindle</code> 到货了 ：）开个玩笑，其实从一个多月以前开始，就一直想着要减少自己无意义刷手机的行为。我对自己的这个行为深恶痛绝，但是一直没有根治过，也许是为了放松，但是经常性的在几个App之间切换而无所得，反而有的是巨大的空虚感。其中尤其以微博、微信朋友圈等App为甚。其实也是能够从这些渠道获取一些有效信息的，但是在我看来成本太大，所以我关闭了微信朋友圈、卸载了微博，并不是永远不再使用，至少这个冬天，我想要让自己沉下心来，扎扎实实做一些记录，做一些积淀。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_rescue-time-sep.png"></p><p>如果说11月份的数据还不够明显的话，可以看看9月份的数据，在工作之余，微博、微信、B站这几个是耗时最多的应用（10月因为有段时间去旅行了，所以数据并没有那么明显）。虽然卸载了微博、关闭了朋友圈，但是像 <code>The Social Dilemma</code> 中描述的很像，这个过程有一个戒断反应，有时候你会控制不住自己去把它们找回来。每次这个时候你要想一想，那里到底有什么那么重要的东西，让你不得不去开启它们呢？现在的我仍然处于戒断反应之中，过去的一个星期重新下载了微博一次、重新开启了朋友圈5次，虽然之后都卸载关闭了，但是仍然在和自己较量中。加油吧，希望下周总结的时候这个数据能够有改进。</p><p>不刷微博微信后，你的信息源何来呢？当我问出这个问题的时候，足以反映出一个问题：你是多么的害怕和这个世界隔离。但是真的会隔离吗，我依旧会在休息空隙看微信订阅号。但是下班回家后我不会再看手机消息了，因为平时下班比较晚，到家基本上就10点了，如果像以前那样每次都刷刷手机，基本上一个小时就过去了。这看起来是一个还可以接受的时间，实际上随着自己每天心情的状态改变，加上各种杂七杂八的事情，经常会拖到凌晨十二点半，甚至有时候到一两点。现在的做法很简单，到家后直接手机关机，直接拿起 Kindle 看书，看累了就睡觉。</p><p>关于 Kindle 看书，实际上还有很多问题没有解决。因为很久没有专门的时间看书了（读研后？），现在看书也没有一个明确的门类清单，有时候也没能够很专注其中。关于这个问题，希望下周能够有一个决断。</p><p>话题扯远了，我们继续回顾数据，<code>Google Calendar</code> 的每日总结现在仍然搁置，下周得有个交代了，你拖更太久了 ：）接下来看 <code>Forest</code>，</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Forest - Nov 22 ~ Nov 28, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_forest.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Forest November" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_forest-nov.jpg"></div></div></div></div><p>健身是另一大事宜，这周跑步情况与上周相比基本持平，还在找回节奏的过程中，下周希望可以破四。回顾十一月的跑步情况，在数据监控回归之后总算维持了稳定。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Running - Nov 22 ~ Nov 28, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_running.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Running November" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_running-nov.jpg"></div></div></div></div><hr><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h3 id="嫦娥五号发射成功"><a href="#嫦娥五号发射成功" class="headerlink" title="嫦娥五号发射成功"></a>嫦娥五号发射成功</h3><ul><li>背景：2020年11月24日，中国的首个月球采样返回任务「嫦娥五号」发射成功</li><li>分析：这是中国的第六次探月人物，也是人类时隔44年将再次从月球带回岩石和土壤样品，上一次月球采样返回任务，还是1976年苏联的月球24号。</li></ul><h3 id="伊朗核科学家被暗杀"><a href="#伊朗核科学家被暗杀" class="headerlink" title="伊朗核科学家被暗杀"></a>伊朗核科学家被暗杀</h3><ul><li>背景：2020年11月27日，伊朗核计划负责人<strong>法赫里扎德</strong>近被暗杀身亡。据路透社报道，伊朗当天在写给联合国秘书长古特雷斯和联合国安理会的信中称，有“强烈迹象表明以色列对暗杀一名伊朗科学家负有责任”，伊朗保留自卫的权利。</li><li>跟进：西方普遍认为，这是美国和以色列主使，具体执行的是以色列情报机构<strong>摩萨德</strong></li><li>分析：这是继年初<strong>苏莱曼尼</strong>被美军无人机导弹猎杀后，伊朗核心人物遭到暗杀事件。拜登政府已经表态重返伊朗核协议，也就是说相对于特朗普政府美国的中东政策将会大幅转变。这个关头以色列暗杀<strong>法赫里扎德</strong>，再加上几天前 <strong>内塔尼亚胡</strong> <a href="https://link.zhihu.com/?target=https%3A//www.guancha.cn/internation/2020_11_28_572864.shtml" rel="external nofollow noopener noreferrer" target="_blank">访问了沙特阿拉伯</a>，舆论分析是 <strong>内塔尼亚胡</strong> 在给美国新一任政府传递信息，希望美国能够继续遏制伊朗。</li></ul><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>总算聊到了今天的主题「睡眠」，其实刚才也在社交网络戒断的时候也提到了无意义刷手机对于睡眠的影响。为了有一个更加健康的睡眠，为了自己的生活更有节奏，还是希望自己能够记录自己的睡眠数据，从而能够更好的指导自己的生活。</p><p>睡眠数据中，最最基本的维度就是每天何时入睡、何时苏醒。当然你可以自己手动记录在相应的手机App上，但是这种方法太考验人的毅力了，我们需要一种无侵入式的记录方式。那么这种情况下的解决思路就是智能穿戴设备，比如智能手环、智能手表等，通过再添加一些传感器让硬件来解放人。</p><p>令人开心的是，事实上我已经佩戴 <code>小米手环3</code> 将近两年了，而小米也有 <code>小米运动</code> App 来对数据做专门的统计。然而令人失望的是，小米运动的睡眠数据统计做的极烂，我想要看到一周的每天何时起床何时苏醒都看不到，只能够看到一些可能都不是很准的深睡时间、浅睡时间。也许这些数据以后会很有用，但是我现阶段只想看入睡和苏醒时间。</p><p>接下来我又找到了小米手机自带的 <code>健康</code> 和 <code>小米穿戴</code> 两个应用，这两个数据统计做的还不错，但是不支持 <code>小米手环3</code>，只支持小米手环4和小米手环5。雷布斯你个倒霉孩子，又想骗我买新设备，还真别说我还真动了这个念头，毕竟也不贵。可是最重要的是过去两年的数据啊。哼哼，雷布斯你难不倒我的，我在 <a href="https://www.zhihu.com/question/34255518/answer/1187679143" target="_blank" rel="external nofollow noopener noreferrer">知乎的这个回答</a> 发现了这个 <a href="https://user.huami.com/hm_account/2.0.0/index.html?v=3.7.38&amp;platform_app=com.xiaomi.hm.health#/chooseDestory" target="_blank" rel="external nofollow noopener noreferrer">链接</a> ，在这里你可以导出你手环中所有的数据。</p><p>话不多说，睡眠数据以CSV格式保存，格式如下，我的数据是从 <code>2019年11月21日</code> 开始算起的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date,lastSyncTime,deepSleepTime,shallowSleepTime,wakeTime,start,stop</span><br><span class="line">2019-01-21,1548087470,119,372,22,1547998080,1548028860</span><br><span class="line">2019-01-22,1548173888,114,388,40,1548084300,1548116820</span><br><span class="line">2019-01-23,1548260294,120,347,45,1548174000,1548204720</span><br><span class="line">2019-01-24,1548346721,95,145,16,1548263280,1548278640</span><br></pre></td></tr></table></figure><p>其中的几个字段意义如下：</p><ul><li>lastSyncTime：上次数据同步时间</li><li><code>deepSleepTime</code>：深睡的时间</li><li><code>shallowSleepTime</code>：浅睡的时间</li><li><code>wakeTime</code>：清醒的时间</li><li><code>start</code>：每天晚上的入睡时间</li><li><code>stop</code>：每天早上起来的时间</li></ul><p>其中最关键的就是 <code>start</code> 和 <code>stop</code> 字段，有了这两个数据，我就可以基本统计出过去两年里面的睡眠模式了。<a href="http://zhangwenli.com/blog/2015/12/26/sleeping-analysis/" target="_blank" rel="external nofollow noopener noreferrer">这里</a> 是一个程序媛小姐姐在五年前（嗯很久远了）统计的睡眠数据，还用 <code>ECharts</code> 很漂亮的可视化了出来。</p><p>【今天晚上又到了睡觉的时间，明天早上补完后面的部分吧，我一定会回来的！—— 2020.11.28 22:00】</p><p>雷布斯你放心，下一款最新的小米手环我一定会支持你的。</p><p>【周日出去浪了，今天把上期朝花夕拾剩余的部分给补起来 —— 2020.11.30 17:00】</p><p>参考 <a href="http://zhangwenli.com/blog/2015/12/26/sleeping-analysis/" target="_blank" rel="external nofollow noopener noreferrer">这里</a>  的数据可视化，我简单的分析了入睡时间和起床时间，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Scatter</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line">datafile = <span class="string">"sleep.csv"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(timestamp)</span>:</span></span><br><span class="line">    timeStamp = float(timestamp)</span><br><span class="line">    timeArray = time.localtime(timeStamp)</span><br><span class="line">    sleepDate = time.strftime(<span class="string">"%Y-%m-%d"</span>, timeArray)</span><br><span class="line">    <span class="keyword">return</span> sleepDate, timeArray.tm_hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_csv</span><span class="params">(datafile)</span>:</span></span><br><span class="line">    dateTime = []</span><br><span class="line">    sleepTime = []</span><br><span class="line">    awakeTime = []</span><br><span class="line">    <span class="keyword">with</span> open(datafile, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        r = csv.DictReader(f)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> r:</span><br><span class="line">            <span class="keyword">if</span> line[<span class="string">"deepSleepTime"</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            start, stop = line[<span class="string">"start"</span>], line[<span class="string">"stop"</span>]</span><br><span class="line">            _, pStart = get_time(start)</span><br><span class="line">            pDate, pStop = get_time(stop)</span><br><span class="line">            dateTime.append(pDate)</span><br><span class="line">            sleepTime.append(pStart)</span><br><span class="line">            awakeTime.append(pStop)</span><br><span class="line">    <span class="keyword">return</span> dateTime, sleepTime, awakeTime</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dateTime, sleepTime, awakeTime = parse_csv(datafile)</span><br><span class="line">    scatter = Scatter()</span><br><span class="line">    scatter.add_xaxis(dateTime)</span><br><span class="line">    <span class="comment">#scatter.add_yaxis("入睡时间", sleepTime)</span></span><br><span class="line">    scatter.add_yaxis(<span class="string">"起床时间"</span>, awakeTime)</span><br><span class="line">    scatter.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">"睡眠时间统计"</span>))</span><br><span class="line">    scatter.render()</span><br></pre></td></tr></table></figure><p>这里的数据分析非常浅显，首先入睡时间和起床时间只是从小时维度做了分析，粒度很粗。然后也没有进一步的按周、按月来分析，没有分析每天的睡眠时间，下次有时间搞一搞吧。</p><p>首先看入睡时间，可以看到，入睡时间分布最多的就是0点，也就是凌晨的时候，其次23点和1点也很频繁。11点之前睡很少很少，居然还有21点睡的？我不记得有过这种时刻，难道是手环统计误差？</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-30_sleep-time.png"></p><p>接下来看起床时间，最广泛的分布是在早上8点-9点这个范围，9点和10点的数据也不少，最可怕的是居然有一天睡到了12点，看了下那是 <code>2019-12-21</code>，那是周六的早上，你真的挺懒的：）</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-30_awake-time.png"></p><p>检讨下自己，这个作息真的不太健康，完全暴露了你的懒惰：）下周开始，每周的睡眠数据将会更新到「记录」模块，看看自己能不能做的更好。</p><p>【2020.12.06】更新了画图脚本，得出过去两年睡眠数据可视化如下：</p><div id="echarts568" style="width: 100%;height: 600px;margin: 0 auto"></div><script type="text/javascript" src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"></script><script type="text/javascript" src="http://gallery.echartsjs.com/dep/echarts/map/js/china.js"></script><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('echarts568'));  // 指定图表的配置项和数据  option = {    title: {        text: '睡眠监控'     },    tooltip: {        trigger: 'axis',        formatter: function(params) {            function getHourMinute(timeValue) {                if (timeValue < 0) timeValue = 24 + timeValue;                var m = Math.floor((timeValue % 1) * 60);                m = m.toString().padStart(2, '0');                var h = Math.floor(timeValue);                return {                    hour: h,                     minute: m                }            }                        var sleepTime = getHourMinute(params[0].data)            var awakeTime = getHourMinute(params[1].data)            return params[0].seriesName + ": " + sleepTime.hour + ":" + sleepTime.minute + '<br />'                + params[1].seriesName + ": " + awakeTime.hour + ":" + awakeTime.minute + '<br />'                +  params[2].seriesName + ": " + params[2].data + '小时';        }    },    toolbox: {        feature: {            dataView: {show: true, readOnly: false},            restore: {show: true},            saveAsImage: {show: true}        }    },    legend: {        data: ['入睡时间', '起床时间']    },    xAxis: [        {            type: 'category',            data: ['2019-01-15', '2019-01-16', '2019-01-17', '2019-01-18', '2019-01-19', '2019-01-21', '2019-01-22', '2019-01-23', '2019-01-24', '2019-01-25', '2019-01-26', '2019-01-27', '2019-01-28', '2019-01-28', '2019-01-30', '2019-01-31', '2019-01-31', '2019-02-02', '2019-02-03', '2019-02-04', '2019-02-05', '2019-02-05', '2019-02-06', '2019-02-07', '2019-02-08', '2019-02-09', '2019-02-10', '2019-02-11', '2019-02-13', '2019-02-14', '2019-02-15', '2019-02-16', '2019-02-17', '2019-02-18', '2019-02-19', '2019-02-20', '2019-02-21', '2019-02-22', '2019-02-23', '2019-02-24', '2019-02-25', '2019-02-26', '2019-02-27', '2019-02-28', '2019-03-01', '2019-03-02', '2019-03-03', '2019-03-04', '2019-03-05', '2019-03-06', '2019-03-07', '2019-03-08', '2019-03-09', '2019-03-10', '2019-03-11', '2019-03-12', '2019-03-13', '2019-03-14', '2019-03-15', '2019-03-16', '2019-03-17', '2019-03-18', '2019-03-19', '2019-03-20', '2019-03-21', '2019-03-22', '2019-03-23', '2019-03-24', '2019-03-25', '2019-03-26', '2019-03-27', '2019-03-28', '2019-03-29', '2019-03-30', '2019-03-31', '2019-04-01', '2019-04-02', '2019-04-02', '2019-04-04', '2019-04-04', '2019-04-05', '2019-04-07', '2019-04-08', '2019-04-09', '2019-04-10', '2019-04-11', '2019-04-12', '2019-04-13', '2019-04-14', '2019-04-15', '2019-04-15', '2019-04-17', '2019-04-18', '2019-04-19', '2019-04-20', '2019-04-21', '2019-04-21', '2019-04-23', '2019-04-24', '2019-04-25', '2019-04-26', '2019-04-27', '2019-04-28', '2019-04-28', '2019-04-30', '2019-05-01', '2019-05-02', '2019-05-03', '2019-05-04', '2019-05-05', '2019-05-05', '2019-05-07', '2019-05-07', '2019-05-09', '2019-05-09', '2019-05-10', '2019-05-11', '2019-05-13', '2019-05-14', '2019-05-15', '2019-05-16', '2019-05-16', '2019-05-18', '2019-05-19', '2019-05-20', '2019-05-21', '2019-05-22', '2019-05-23', '2019-05-24', '2019-05-24', '2019-05-26', '2019-05-27', '2019-05-27', '2019-05-29', '2019-05-29', '2019-05-31', '2019-06-01', '2019-06-02', '2019-06-03', '2019-06-04', '2019-06-05', '2019-06-06', '2019-06-07', '2019-06-08', '2019-06-09', '2019-06-10', '2019-06-11', '2019-06-12', '2019-06-13', '2019-06-14', '2019-06-15', '2019-06-16', '2019-06-17', '2019-06-18', '2019-06-19', '2019-06-19', '2019-06-21', '2019-06-21', '2019-06-22', '2019-06-24', '2019-06-25', '2019-06-26', '2019-06-26', '2019-06-28', '2019-06-29', '2019-06-30', '2019-07-01', '2019-07-02', '2019-07-03', '2019-07-04', '2019-07-05', '2019-07-06', '2019-07-07', '2019-07-08', '2019-07-08', '2019-07-09', '2019-07-11', '2019-07-12', '2019-07-13', '2019-07-14', '2019-07-15', '2019-07-16', '2019-07-17', '2019-07-18', '2019-07-18', '2019-07-20', '2019-07-30', '2019-08-01', '2019-08-02', '2019-08-03', '2019-08-04', '2019-08-04', '2019-08-06', '2019-08-07', '2019-08-08', '2019-08-09', '2019-08-10', '2019-08-10', '2019-08-12', '2019-08-13', '2019-08-14', '2019-08-15', '2019-08-15', '2019-08-17', '2019-08-18', '2019-08-19', '2019-08-19', '2019-08-21', '2019-08-22', '2019-08-22', '2019-08-24', '2019-08-25', '2019-08-26', '2019-08-27', '2019-08-27', '2019-08-29', '2019-08-30', '2019-08-31', '2019-09-01', '2019-09-02', '2019-09-02', '2019-09-04', '2019-09-04', '2019-09-05', '2019-09-07', '2019-09-08', '2019-09-09', '2019-09-09', '2019-09-11', '2019-09-12', '2019-09-13', '2019-09-14', '2019-09-15', '2019-09-16', '2019-09-17', '2019-09-17', '2019-09-19', '2019-09-19', '2019-09-21', '2019-09-22', '2019-09-23', '2019-09-24', '2019-09-24', '2019-09-26', '2019-09-26', '2019-09-28', '2019-09-29', '2019-09-30', '2019-10-01', '2019-10-01', '2019-10-02', '2019-10-03', '2019-10-04', '2019-10-14', '2019-10-15', '2019-10-17', '2019-10-18', '2019-10-19', '2019-10-20', '2019-10-21', '2019-10-22', '2019-10-23', '2019-10-24', '2019-10-25', '2019-10-26', '2019-10-27', '2019-10-28', '2019-10-29', '2019-10-30', '2019-10-31', '2019-11-01', '2019-11-02', '2019-11-03', '2019-11-04', '2019-11-05', '2019-11-06', '2019-11-07', '2019-11-07', '2019-11-09', '2019-11-10', '2019-11-11', '2019-11-11', '2019-11-13', '2019-11-14', '2019-11-15', '2019-11-16', '2019-11-17', '2019-11-18', '2019-11-19', '2019-11-20', '2019-11-21', '2019-11-22', '2019-11-23', '2019-11-24', '2019-11-25', '2019-11-26', '2019-11-27', '2019-11-28', '2019-11-29', '2019-11-30', '2019-12-01', '2019-12-02', '2019-12-03', '2019-12-04', '2019-12-05', '2019-12-06', '2019-12-07', '2019-12-08', '2019-12-09', '2019-12-10', '2019-12-11', '2019-12-11', '2019-12-13', '2019-12-14', '2019-12-15', '2019-12-16', '2019-12-17', '2019-12-18', '2019-12-19', '2019-12-20', '2019-12-21', '2019-12-22', '2019-12-22', '2019-12-24', '2019-12-25', '2019-12-26', '2019-12-27', '2019-12-28', '2019-12-29', '2019-12-29', '2019-12-31', '2020-01-01', '2020-01-02', '2020-01-03', '2020-01-04', '2020-01-05', '2020-01-06', '2020-01-07', '2020-01-08', '2020-01-09', '2020-01-09', '2020-01-11', '2020-01-12', '2020-01-13', '2020-01-14', '2020-01-15', '2020-01-16', '2020-01-17', '2020-01-18', '2020-01-19', '2020-01-20', '2020-01-21', '2020-01-22', '2020-01-23', '2020-01-24', '2020-01-25', '2020-01-26', '2020-01-27', '2020-01-28', '2020-01-29', '2020-01-30', '2020-01-31', '2020-02-01', '2020-02-02', '2020-02-02', '2020-02-03', '2020-02-04', '2020-06-30', '2020-07-01', '2020-07-02', '2020-07-02', '2020-07-03', '2020-07-05', '2020-07-05', '2020-07-06', '2020-07-07', '2020-07-08', '2020-07-10', '2020-07-10', '2020-07-11', '2020-07-12', '2020-07-13', '2020-07-14', '2020-07-15', '2020-07-16', '2020-07-17', '2020-07-18', '2020-07-19', '2020-07-20', '2020-07-21', '2020-07-22', '2020-07-23', '2020-07-24', '2020-07-25', '2020-07-26', '2020-07-27', '2020-07-28', '2020-07-29', '2020-07-30', '2020-07-31', '2020-08-01', '2020-08-02', '2020-08-03', '2020-08-04', '2020-08-06', '2020-08-06', '2020-08-07', '2020-08-08', '2020-08-09', '2020-08-11', '2020-08-12', '2020-08-12', '2020-08-13', '2020-08-14', '2020-08-15', '2020-08-17', '2020-08-18', '2020-08-18', '2020-08-19', '2020-08-20', '2020-08-21', '2020-08-22', '2020-08-23', '2020-08-24', '2020-08-25', '2020-08-27', '2020-08-27', '2020-08-29', '2020-08-29', '2020-08-30', '2020-08-31', '2020-09-01', '2020-09-02', '2020-09-03', '2020-09-05', '2020-09-05', '2020-09-07', '2020-09-07', '2020-09-08', '2020-09-10', '2020-09-11', '2020-09-12', '2020-09-13', '2020-09-13', '2020-09-15', '2020-09-15', '2020-09-17', '2020-09-18', '2020-09-19', '2020-09-19', '2020-09-20', '2020-09-21', '2020-09-22', '2020-09-23', '2020-09-24', '2020-09-25', '2020-09-26', '2020-09-27', '2020-09-29', '2020-09-30', '2020-09-30', '2020-10-02', '2020-10-03', '2020-10-03', '2020-10-05', '2020-10-05', '2020-10-06', '2020-10-08', '2020-10-09', '2020-10-09', '2020-10-11', '2020-10-11', '2020-10-13', '2020-10-14', '2020-10-15', '2020-10-16', '2020-10-17', '2020-10-17', '2020-10-19', '2020-10-20', '2020-10-21', '2020-10-22', '2020-10-23', '2020-10-24', '2020-10-25', '2020-10-26', '2020-10-27', '2020-10-28', '2020-10-29', '2020-10-30', '2020-10-31', '2020-11-01', '2020-11-01', '2020-11-03', '2020-11-17', '2020-11-19', '2020-11-20', '2020-11-21', '2020-11-22', '2020-11-23', '2020-11-24', '2020-11-25', '2020-11-26', '2020-11-27', '2020-11-28'],            axisPointer: {                type: 'shadow'            }        }    ],    yAxis: [        {            type: 'value',            axisLine: {                show: false            },            name: '小时',            axisLabel: {                formatter: function (h) {                    h = Math.floor(h);                    if (h < 0) {                        return h + 24 + ':00';                    } else {                         return h + ':00';                    }                 },                 margin: 20            }        }    ],    series: [        {            name: '入睡时间',            type: 'line',            data: [0.0, 0.0, 0.0, 0.0, 0.0, -0.53, -0.58, 0.33, 1.13, 0.2, -0.27, 2.82, -0.67, 0.0, 0.8, 1.98, 0.0, -2.05, 0.58, 0.07, 0.17, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.57, 1.9300000000000002, 0.83, 0.12, 0.37, 0.57, 0.1, 0.47, 0.33, 1.92, 1.72, 0.35, 0.67, 0.35, 0.57, 0.93, 1.07, 1.17, -0.72, 0.95, -0.32, 0.18, 0.45, 0.27, 0.0, 1.37, -0.1, 0.22, 0.52, 0.42, 0.85, 0.88, 0.32, 0.1, -0.17, -1.08, 1.83, -0.8, 0.02, -0.25, -0.07, -0.72, -0.93, 0.0, 0.72, -0.77, 0.07, 0.52, -0.35, 0.0, -1.97, 0.0, 0.0, -1.77, 1.45, 0.3, 0.17, 3.98, 0.1, 0.58, -0.67, -0.45, 0.0, 2.02, -0.3, 0.78, 0.63, 0.33, 0.0, 2.32, -0.17, 1.33, -0.9, 1.83, 0.32, 0.0, -0.48, -0.42, 0.6, -1.3, 1.08, 0.48, 0.0, 3.1, 0.0, 1.5, 0.0, 0.0, 0.0, 1.67, -0.22, 0.47, 1.37, 0.0, -0.87, -0.8, -0.47, -0.48, 0.33, 0.0, 0.33, 0.0, -1.52, 0.98, 0.0, 0.17, 0.0, 0.55, 2.2800000000000002, -0.72, -0.32, -0.15, 0.87, 1.1, 1.9300000000000002, 0.35, -3.52, 1.05, 0.53, 0.33, 0.28, 3.0, 0.5, 1.22, 0.82, 1.28, 1.87, 0.0, -0.4, 0.0, 0.0, -0.27, -1.53, 1.08, 0.0, -0.12, 1.48, 0.37, 0.35, -0.22, 0.48, -0.03, 0.53, 1.33, -0.93, 0.27, 0.0, 0.0, 0.73, 0.58, 0.7, 0.62, 0.42, 0.82, 0.68, 0.67, 0.0, 0.62, 0.0, 0.63, 0.12, 1.07, 1.48, 0.0, 0.85, 0.75, 0.62, 0.65, 0.6, 0.0, 1.03, 1.22, 0.63, 0.87, 0.0, 0.97, 1.78, 1.55, 0.0, 0.38, 0.78, 0.0, 3.12, 0.9, 0.73, 0.57, 0.0, 0.72, 0.08, 0.58, 1.1, 0.7, 0.0, -0.17, 0.0, 0.0, -2.13, 2.7800000000000002, 0.37, 0.0, 0.63, 1.43, -2.12, 0.57, 0.85, 2.27, 1.8, 0.0, -3.08, 0.0, 2.38, 1.45, 3.65, 0.58, 0.0, 0.87, 0.0, 1.65, -0.6, 0.15, 1.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.62, 2.27, 2.1, 0.28, -0.48, -1.08, 1.35, 1.3, 1.62, -0.2, 0.47, -0.1, 1.28, 0.93, 2.0, 1.25, -0.32, 0.65, 1.27, 2.03, 3.92, 1.13, 0.0, 0.75, 0.85, 0.82, 0.0, 0.87, 0.53, 1.13, 0.62, 2.58, 1.55, 0.8, 1.3, 1.3, 0.87, 0.57, 2.92, 1.37, 0.02, 0.3, 1.42, -0.37, 0.93, 2.18, 1.18, 1.38, 0.57, 0.38, -0.35, 0.8, 0.45, 1.5699999999999998, 0.82, 0.98, 0.0, 1.17, 0.5, 0.93, 0.92, 4.65, 0.23, 5.32, -0.47, 2.25, 0.67, 0.0, 0.37, 2.08, 1.83, 1.12, 0.45, -0.6, 0.0, 1.42, 4.35, -0.42, 1.43, -0.08, 0.42, 0.73, 0.75, 1.17, 0.82, 0.0, 2.67, 2.83, 0.93, 0.8, -0.28, -0.15, 0.65, 1.2, 0.17, -2.05, 0.55, 0.33, 0.48, 0.75, 1.63, -0.77, 1.87, 1.33, 1.5, 0.9, 0.97, 0.22, 0.47, 0.0, 0.0, 0.0, 0.7, -0.42, -0.1, 0.0, 0.0, 4.1, 0.0, 0.0, 0.0, 0.0, 0.13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.82, 0.0, 0.0, 0.0, 0.0, -0.38, -0.72, 0.0, 0.0, 0.0, 0.0, 0.27, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.18, 0.0, -0.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.82, 0.0, -1.68, 0.0, 0.0, -0.07, 0.65, 0.32, -0.68, 0.0, 5.12, 0.0, -0.17, -0.53, 5.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.07, 2.07, 0.0, 1.13, 3.45, 0.0, -1.65, 0.0, 0.0, 0.75, 1.25, 0.0, 3.45, 0.0, 0.25, 1.22, 1.62, 0.43, 1.98, 0.0, -0.17, 0.57, 1.13, -0.88, 0.65, 0.77, 1.62, 0.1, 0.8, 0.95, 1.12, 0.27, 0.62, -0.05, 0.0, -1.63, 0.0, -0.55, 3.12, 0.33, 1.77, -0.7, 0.28, -0.2, 1.42, 0.38, -1.0]        },        {            name: '起床时间',            type: 'line',            data: [0.0, 0.0, 0.0, 0.0, 0.0, 8.02, 8.45, 8.87, 5.4, 8.72, 9.37, 9.87, 8.38, 0.0, 5.58, 6.42, 0.0, 7.63, 7.1, 8.1, 7.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 7.92, 8.7, 5.33, 8.27, 8.8, 8.93, 6.02, 8.15, 8.92, 7.82, 9.03, 9.03, 9.38, 6.32, 8.68, 8.78, 9.25, 7.52, 9.2, 7.6, 3.9, 8.25, 8.27, 8.5, 8.9, 8.53, 9.07, 7.93, 9.13, 5.88, 9.05, 6.6, 8.88, 9.17, 8.52, 8.98, 8.95, 4.98, 8.22, 8.83, 6.77, 9.37, 7.4, 8.27, 8.15, 9.12, 10.33, 9.03, 6.32, 0.0, 6.0, 0.0, 0.0, 7.15, 7.92, 7.72, 7.9, 8.57, 8.23, 7.58, 8.5, 8.45, 0.0, 8.07, 8.3, 8.3, 9.12, 8.3, 0.0, 8.32, 8.37, 7.85, 7.13, 8.63, 5.38, 0.0, 8.78, 4.78, 6.93, 6.93, 7.9, 9.02, 0.0, 7.97, 0.0, 7.82, 0.0, 0.0, 0.0, 8.48, 6.97, 8.22, 8.3, 0.0, 6.93, 6.93, 5.42, 7.65, 7.1, 7.38, 5.38, 0.0, 4.43, 7.62, 0.0, 8.17, 0.0, 6.92, 10.38, 9.58, 7.8, 7.92, 7.67, 8.13, 10.55, 8.87, 5.08, 4.77, 5.63, 8.02, 8.6, 8.87, 8.9, 8.95, 8.57, 8.88, 8.77, 0.0, 3.67, 0.0, 0.0, 8.23, 8.07, 7.97, 0.0, 8.53, 7.92, 8.57, 3.7199999999999998, 4.82, 8.0, 3.92, 9.17, 7.38, 8.88, 8.83, 0.0, 0.0, 8.4, 8.93, 9.0, 8.25, 8.73, 8.85, 8.72, 8.88, 0.0, 9.77, 0.0, 7.83, 8.92, 8.78, 5.02, 0.0, 6.75, 4.43, 9.13, 5.75, 8.68, 0.0, 8.43, 8.93, 6.22, 5.47, 0.0, 8.55, 6.65, 6.13, 0.0, 5.82, 5.8, 0.0, 8.65, 10.42, 8.95, 8.55, 0.0, 8.35, 8.5, 8.7, 9.02, 8.88, 0.0, 3.7, 0.0, 0.0, 8.78, 6.63, 8.05, 0.0, 8.32, 8.08, 4.5, 8.55, 7.98, 4.87, 5.68, 0.0, 0.17, 0.0, 7.32, 9.15, 8.7, 8.67, 0.0, 5.57, 0.0, 9.0, 4.72, 6.9, 4.18, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 8.92, 8.97, 6.05, 9.75, 8.48, 7.73, 5.62, 5.53, 9.67, 9.05, 5.38, 8.98, 7.43, 4.47, 8.92, 4.28, 6.08, 8.8, 5.7, 10.05, 10.03, 9.93, 0.0, 9.35, 8.93, 9.47, 0.0, 7.83, 7.93, 5.25, 8.87, 5.6, 9.87, 4.25, 6.68, 4.18, 8.95, 7.0, 5.38, 3.9, 9.52, 8.9, 10.72, 7.62, 10.82, 11.45, 9.47, 10.97, 6.85, 9.75, 8.42, 5.63, 9.2, 9.8, 10.12, 5.4, 0.0, 6.2, 5.55, 4.65, 5.75, 8.95, 9.03, 10.73, 7.02, 12.83, 6.92, 0.0, 9.48, 6.0, 10.53, 9.1, 8.72, 8.05, 0.0, 11.12, 6.82, 9.53, 5.73, 9.83, 8.43, 6.15, 8.65, 8.55, 9.0, 0.0, 10.68, 9.75, 9.45, 6.43, 6.08, 9.23, 8.38, 10.33, 4.88, 8.08, 5.87, 7.75, 10.05, 9.32, 10.97, 8.52, 10.28, 10.65, 6.47, 6.13, 9.75, 7.83, 9.83, 0.0, 0.0, 0.0, 7.53, 6.78, 4.05, 0.0, 0.0, 6.45, 0.0, 0.0, 0.0, 0.0, 3.52, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 7.17, 0.0, 0.0, 0.0, 0.0, 8.03, 7.7, 0.0, 0.0, 0.0, 0.0, 7.8, 7.85, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 7.42, 0.0, 7.75, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.18, 0.0, 0.9, 0.0, 0.0, 8.32, 8.18, 3.68, 4.12, 0.0, 6.67, 0.0, 8.7, 8.15, 8.42, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 8.42, 8.13, 0.0, 4.42, 5.77, 0.0, 6.87, 0.0, 0.0, 6.12, 9.52, 0.0, 9.68, 0.0, 8.58, 9.02, 5.87, 8.78, 8.85, 0.0, 8.78, 5.13, 8.9, 3.32, 8.38, 10.77, 9.32, 6.15, 6.92, 8.32, 9.27, 6.62, 4.18, 3.87, 0.0, 3.5300000000000002, 0.0, 7.57, 7.95, 7.08, 9.85, 7.13, 5.42, 3.52, 8.3, 8.52, 8.03]        }    ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);</script><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>有研究表明人睡眠存在一个生物节律，即由4-5个睡眠周期组成，每一个周期又分为5个阶段，由两个时相组成：非快速眼动睡眠相NREM（前4期）和快速眼动睡眠REM（在睡眠70-90分钟后出现）。每个周期持续90分钟左右，每晚可出现4-5个周期。</p><h3 id="非快速眼动睡眠相NREM"><a href="#非快速眼动睡眠相NREM" class="headerlink" title="非快速眼动睡眠相NREM"></a>非快速眼动睡眠相NREM</h3><p>此睡眠相主要由入眠期、浅睡和中睡期组成，可以伴有少量的深睡期。</p><h4 id="入睡期"><a href="#入睡期" class="headerlink" title="入睡期"></a>入睡期</h4><p>是睡眠的开始，昏昏欲睡的感觉就属于这一阶段。此时脑波开始变化，频率渐缓，振幅渐小。此阶段是清醒和睡眠之间的转换期，人非常容易醒来，约占睡眠总时间的10%。</p><h4 id="浅睡期和中睡期"><a href="#浅睡期和中睡期" class="headerlink" title="浅睡期和中睡期"></a>浅睡期和中睡期</h4><p>开始正式睡眠。此时脑波渐呈不规律进行，频率与振幅忽大忽小，其中偶尔会出现被称为“睡眠锭”的高频、大波幅脑波，以及被称为“K结”的低频、很大波幅脑波。此期容易觉醒，入睡困难者，常自行惊醒，约占整个睡眠期的50%。</p><h4 id="深睡期"><a href="#深睡期" class="headerlink" title="深睡期"></a>深睡期</h4><p>沉睡阶段，被试不易被叫醒。此时脑波变化很大，频率只有每秒1~2周，为<strong>慢波睡眠</strong>，但振幅增加较大，呈现变化缓慢的曲线。此期睡眠深，觉醒相当困难，在每个睡眠周期中约持续30分钟，然后进入快速眼动睡眠。</p><p>这四个阶段的睡眠均不出现眼球快速跳动现象，故统称为<strong>非快速眼动睡眠</strong>（non－rapideyemovementsleep，简称<strong>NREM</strong>。</p><p><img alt="睡眠周期" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-30_sleep-hypnogram.svg"></p><h3 id="快速动眼期REM"><a href="#快速动眼期REM" class="headerlink" title="快速动眼期REM"></a>快速动眼期REM</h3><p>这一阶段以深睡眠为主，脑波迅速改变，出现与清醒状态时的脑波相似的高频率、低波幅脑波，但其中会有特点鲜明的锯齿状波。睡眠者通常会有翻身的动作，并很容易惊醒，似乎又进入阶段1的睡眠，但实际是进入了一个被称为<strong>快速眼动睡眠</strong>（rapideyemovementsleep，简称<strong>REM</strong>）的睡眠阶段。因为，此时除了脑波的改变之外，被试的眼球会呈现快速跳动现象。如果此时将其唤醒，大部分人报告说正在做梦。因此，REM就成为睡眠第五个阶段的重要特征，也成为心理学家研究做梦的重要根据。</p><p>在整个睡眠周期中，NREM与REM有规律地交替出现，两种不同时相睡眠各出现一次为一个睡眠期。入睡后必须先经过NREM阶段，才能进入REM阶段，而人体只有在经过了REM阶段后才有真正睡过觉的感觉，体能才能得到很好的恢复。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遵守上周的约定，这周总算是定期发布了2020年「朝花夕拾」的第二十六期 &lt;code&gt;晚安&lt;/code&gt;，在上期的记录中，我告诉自己要搭建起自己的睡眠数据监控系统，这周我来介绍下我是如何折腾的。封面来自今天在家拍摄的晚霞，晚安，希望大家都能够睡个好觉。&lt;/p&gt;

    &lt;div id=&quot;aplayer-dwUZXipF&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;439122551&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-28_sunset-2.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="sleep" scheme="http://houmin.cc/tags/sleep/"/>
    
      <category term="嫦娥五号" scheme="http://houmin.cc/tags/%E5%AB%A6%E5%A8%A5%E4%BA%94%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio Sidecar Injector</title>
    <link href="http://houmin.cc/posts/8607f22d/"/>
    <id>http://houmin.cc/posts/8607f22d/</id>
    <published>2020-11-27T12:18:11.000Z</published>
    <updated>2020-12-16T08:04:56.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天我们分析下istio-sidecar-injector 组件</p><a id="more"></a><p><img alt="img" data-src="https://zhongfox-blogimage-1256048497.cos.ap-guangzhou.myqcloud.com/2020-02-23-093513.jpg"></p><p>用户空间的Pod要想加入mesh, 首先需要注入sidecar 容器, istio 提供了2种方式实现注入:</p><ul><li>自动注入: 利用 <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes Dynamic Admission Webhooks</a> 对 新建的pod 进行注入: initContainer + sidecar</li><li>手动注入: 使用命令<code>istioctl kube-inject</code></li></ul><p>「注入」本质上就是修改Pod的资源定义, 添加相应的sidecar容器定义, 内容包括2个新容器:</p><ul><li>名为<code>istio-init</code>的initContainer: 通过配置iptables来劫持Pod中的流量</li><li>名为<code>istio-proxy</code>的sidecar容器: 两个进程pilot-agent和envoy, pilot-agent 进行初始化并启动envoy</li></ul><p><img alt="img" data-src="https://ws4.sinaimg.cn/large/006tKfTcgy1g187flw0dmj30wq0grn0b.jpg"></p><hr><h2 id="1-Dynamic-Admission-Control"><a href="#1-Dynamic-Admission-Control" class="headerlink" title="1. Dynamic Admission Control"></a>1. Dynamic Admission Control</h2><p>kubernetes 的准入控制(Admission Control)有2种:</p><ul><li>Built in Admission Control: 这些Admission模块可以选择性地编译进api server, 因此需要修改和重启kube-apiserver</li><li>Dynamic Admission Control: 可以部署在kube-apiserver之外, 同时无需修改或重启kube-apiserver.</li></ul><p>其中, Dynamic Admission Control 包含2种形式:</p><ul><li>Admission Webhooks: 该controller 提供http server, 被动接受kube-apiserver分发的准入请求.</li><li>Initializers: 该controller主动list and watch 关注的资源对象, 对watch到的未初始化对象进行相应的改造.</li></ul><p>其中, Admission Webhooks 又包含2种准入控制:</p><ul><li>ValidatingAdmissionWebhook</li><li>MutatingAdmissionWebhook</li></ul><p>istio 使用了MutatingAdmissionWebhook来实现对用户Pod的注入, 首先需要保证以下条件满足:</p><ul><li>确保 kube-apiserver 启动参数 开启了 MutatingAdmissionWebhook</li><li>给namespace 增加 label: <code>kubectl label namespace default istio-injection=enabled</code></li><li>同时还要保证 kube-apiserver 的 aggregator layer 开启: <code>--enable-aggregator-routing=true</code> 且证书和api server连通性正确设置.</li></ul><p>另外还需要一个配置对象, 来告诉kube-apiserver istio关心的资源对象类型, 以及webhook的服务地址. 如果使用helm安装istio, 配置对象已经添加好了, 查阅MutatingWebhookConfiguration:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">mutatingWebhookConfiguration</span> <span class="string">-oyaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1beta1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line">  <span class="attr">webhooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">clientConfig:</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">istio-sidecar-injector</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/inject</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sidecar-injector.istio.io</span></span><br><span class="line">    <span class="attr">namespaceSelector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">istio-injection:</span> <span class="string">enabled</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">      <span class="attr">apiVersions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">operations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CREATE</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br></pre></td></tr></table></figure><p>该配置告诉kube-apiserver: 命名空间istio-system 中的服务 <code>istio-sidecar-injector</code>(默认443端口), 通过路由<code>/inject</code>, 处理<code>v1/pods</code>的CREATE, 同时pod需要满足命名空间<code>istio-injection: enabled</code>, 当有符合条件的pod被创建时, kube-apiserver就会对该服务发起调用, 服务返回的内容正是添加了sidecar注入的pod定义.</p><hr><h2 id="2-Sidecar-注入内容分析"><a href="#2-Sidecar-注入内容分析" class="headerlink" title="2. Sidecar 注入内容分析"></a>2. Sidecar 注入内容分析</h2><p>查看Pod <code>istio-sidecar-injector</code>的yaml定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%kubectl -n istio-system <span class="builtin-name">get</span> pod istio-sidecar-injector-5f7894f54f-w7f9v -oyaml</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /etc/istio/inject</span><br><span class="line">      name: inject-config</span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - configMap:</span><br><span class="line">      items:</span><br><span class="line">      - key: config</span><br><span class="line">        path: config</span><br><span class="line">      name: istio-sidecar-injector</span><br><span class="line">    name: inject-config</span><br></pre></td></tr></table></figure><p>可以看到该Pod利用<a href="https://kubernetes.io/docs/concepts/storage/volumes/#projected" target="_blank" rel="external nofollow noopener noreferrer">projected volume</a>将<code>istio-sidecar-injector</code>这个config map 的config挂到了自己容器路径<code>/etc/istio/inject/config</code>, 该config map 内容正是注入用户空间pod所需的模板.</p><p>如果使用helm安装istio, 该 configMap 模板源码位于: <a href="https://github.com/istio/istio/blob/master/install/kubernetes/helm/istio/templates/sidecar-injector-configmap.yaml" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/istio/istio/blob/master/install/kubernetes/helm/istio/templates/sidecar-injector-configmap.yaml</a>.</p><p>该config map 是在安装istio时添加的, kubernetes 会自动维护 projected volume的更新, 因此 容器 <code>sidecar-injector</code>只需要从本地文件直接读取所需配置.</p><p>高级用户可以按需修改这个模板内容.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n istio-system <span class="builtin-name">get</span> configmap istio-sidecar-injector <span class="attribute">-o</span>=jsonpath='&#123;.data.config&#125;<span class="string">'</span></span><br></pre></td></tr></table></figure><p>查看该configMap, <code>data.config</code>包含以下内容(简化):</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">policy</span>: enabled <span class="comment">// 是否开启自动注入</span></span><br><span class="line"><span class="attribute">template</span>: |-    <span class="comment">// 使用go template 定义的pod patch</span></span><br><span class="line">  <span class="attribute">initContainers</span>:</span><br><span class="line">  [[ if ne (annotation .ObjectMeta <span class="built_in">`sidecar.istio.io/interceptionMode`</span> .ProxyConfig.InterceptionMode) <span class="string">"NONE"</span> ]]</span><br><span class="line">  - <span class="attribute">name</span>: istio-init</span><br><span class="line">    <span class="attribute">image</span>: <span class="string">"docker.io/istio/proxy_init:1.1.0"</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="attribute">securityContext</span>:</span><br><span class="line">      <span class="attribute">capabilities</span>:</span><br><span class="line">        <span class="attribute">add</span>:</span><br><span class="line">        - NET_ADMIN</span><br><span class="line">    ......</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: istio-proxy</span><br><span class="line">    <span class="attribute">args</span>:</span><br><span class="line">    - proxy</span><br><span class="line">    - sidecar</span><br><span class="line">    ......</span><br><span class="line">    <span class="attribute">image</span>: [[ annotation .ObjectMeta <span class="built_in">`sidecar.istio.io/proxyImage`</span>  <span class="string">"docker.io/istio/proxyv2:1.1.0"</span>  ]]</span><br><span class="line">    ......</span><br><span class="line">    <span class="attribute">readinessProbe</span>:</span><br><span class="line">      <span class="attribute">httpGet</span>:</span><br><span class="line">        <span class="attribute">path</span>: /healthz/ready</span><br><span class="line">        <span class="attribute">port</span>: [[ annotation .ObjectMeta <span class="built_in">`status.sidecar.istio.io/port`</span>  <span class="number">0</span>  ]]</span><br><span class="line">    ......</span><br><span class="line">    <span class="attribute">securityContext</span>:</span><br><span class="line">      <span class="attribute">capabilities</span>:</span><br><span class="line">        <span class="attribute">add</span>:</span><br><span class="line">        - NET_ADMIN</span><br><span class="line">      <span class="attribute">runAsGroup</span>: <span class="number">1337</span></span><br><span class="line">  ......</span><br><span class="line">    <span class="attribute">volumeMounts</span>:</span><br><span class="line">    ......</span><br><span class="line">    - <span class="attribute">mountPath</span>: /etc/istio/proxy</span><br><span class="line">      <span class="attribute">name</span>: istio-envoy</span><br><span class="line">    - <span class="attribute">mountPath</span>: /etc/certs/</span><br><span class="line">      <span class="attribute">name</span>: istio-certs</span><br><span class="line">      <span class="attribute">readOnly</span>: true</span><br><span class="line">      ......</span><br><span class="line">  <span class="attribute">volumes</span>:</span><br><span class="line">  ......</span><br><span class="line">  - <span class="attribute">emptyDir</span>:</span><br><span class="line">      <span class="attribute">medium</span>: Memory</span><br><span class="line">    <span class="attribute">name</span>: istio-envoy</span><br><span class="line">  - <span class="attribute">name</span>: istio-certs</span><br><span class="line">    <span class="attribute">secret</span>:</span><br><span class="line">      <span class="attribute">optional</span>: true</span><br><span class="line">      [[ if eq .Spec.ServiceAccountName <span class="string">""</span> -]]</span><br><span class="line">      <span class="attribute">secretName</span>: istio.default</span><br><span class="line">      [[ else -]]</span><br><span class="line">      <span class="attribute">secretName</span>: [[ printf <span class="string">"istio.%s"</span> .Spec.ServiceAccountName ]]</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>对istio-init生成的部分参数分析:</p><ul><li><code>-u 1337</code> 排除用户ID为1337，即Envoy自身的流量</li><li>解析用户容器<code>.Spec.Containers</code>, 获得容器的端口列表, 传入<code>-b</code>参数(入站端口控制)</li><li>指定要从重定向到 Envoy 中排除（可选）的入站端口列表, 默认写入<code>-d 15020</code>, 此端口是sidecar的status server</li><li>赋予该容器<code>NET_ADMIN</code> 能力, 允许容器istio-init进行网络管理操作</li></ul><p>对istio-proxy 生成的部分参数分析:</p><ul><li>启动参数<code>proxy sidecar xxx</code>用以定义该节点的代理类型(NodeType)</li><li>默认的status server 端口<code>--statusPort=15020</code></li><li>解析用户容器<code>.Spec.Containers</code>, 获取用户容器的application Ports, 然后设置到sidecar的启动参数<code>--applicationPorts</code>中, 该参数会最终传递给envoy, 用以确定哪些端口流量属于该业务容器.</li><li>设置<code>/healthz/ready</code> 作为该代理的readinessProbe</li><li>同样赋予该容器<code>NET_ADMIN</code>能力</li></ul><p>另外<code>istio-sidecar-injector</code>还给容器<code>istio-proxy</code>挂了2个volumes:</p><ul><li><p>名为<code>istio-envoy</code>的emptydir volume, 挂载到容器目录<code>/etc/istio/proxy</code>, 作为envoy的配置文件目录</p></li><li><p>名为<code>istio-certs</code>的secret volume, 默认secret名为<code>istio.default</code>, 挂载到容器目录<code>/etc/certs/</code>, 存放相关的证书, 包括服务端证书, 和可能的mtls客户端证书</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% kubectl exec productpage-v1-6597cb5df9-xlndw -c istio-proxy -- <span class="keyword">ls</span> <span class="string">/etc/certs/</span></span><br><span class="line">cert-chain.pem</span><br><span class="line">key.pem</span><br><span class="line">root-cert.pem</span><br></pre></td></tr></table></figure></li></ul><p>后续文章探究sidecar <code>istio-proxy</code>会对其进一步分析.</p><hr><h2 id="3-istio-sidecar-injector-webhook-源码分析"><a href="#3-istio-sidecar-injector-webhook-源码分析" class="headerlink" title="3. istio-sidecar-injector-webhook 源码分析"></a>3. istio-sidecar-injector-webhook 源码分析</h2><ul><li>镜像Dockerfile: <code>istio/pilot/docker/Dockerfile.sidecar_injector</code></li><li>启动命令: <code>/sidecar-injector</code></li><li>命令源码: <code>istio/pilot/cmd/sidecar-injector</code></li></ul><p>容器中命令/sidecar-injector启动参数如下:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="symbol">args:</span></span></span><br><span class="line"><span class="ruby">  - --caCertFile=<span class="regexp">/etc/istio</span><span class="regexp">/certs/root</span>-cert.pem</span></span><br><span class="line"><span class="ruby">  - --tlsCertFile=<span class="regexp">/etc/istio</span><span class="regexp">/certs/cert</span>-chain.pem</span></span><br><span class="line"><span class="ruby">  - --tlsKeyFile=<span class="regexp">/etc/istio</span><span class="regexp">/certs/key</span>.pem</span></span><br><span class="line"><span class="ruby">  - --injectConfig=<span class="regexp">/etc/istio</span><span class="regexp">/inject/config</span></span></span><br><span class="line"><span class="ruby">  - --meshConfig=<span class="regexp">/etc/istio</span><span class="regexp">/config/mesh</span></span></span><br><span class="line"><span class="ruby">  - --healthCheckInterval=<span class="number">2</span>s</span></span><br><span class="line"><span class="ruby">  - --healthCheckFile=<span class="regexp">/health</span></span></span><br></pre></td></tr></table></figure><p><code>sidecar-injector</code> 的核心数据模型是 <code>Webhook</code>struct, 注入配置sidecarConfig包括注入模板以及注入开关和规则:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Webhook <span class="keyword">struct</span> &#123;</span><br><span class="line">mu                     sync.RWMutex</span><br><span class="line">sidecarConfig          *Config <span class="comment">// 注入配置: 模板,开关,规则</span></span><br><span class="line">sidecarTemplateVersion <span class="keyword">string</span></span><br><span class="line">meshConfig             *meshconfig.MeshConfig</span><br><span class="line"></span><br><span class="line">healthCheckInterval time.Duration</span><br><span class="line">healthCheckFile     <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">server     *http.Server</span><br><span class="line">meshFile   <span class="keyword">string</span></span><br><span class="line">configFile <span class="keyword">string</span>            <span class="comment">// 注入内容路径, 从启动参数injectConfig中获取</span></span><br><span class="line">watcher    *fsnotify.Watcher <span class="comment">// 基于文件系统的notifications</span></span><br><span class="line">certFile   <span class="keyword">string</span></span><br><span class="line">keyFile    <span class="keyword">string</span></span><br><span class="line">cert       *tls.Certificate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">Policy InjectionPolicy <span class="string">`json:"policy"`</span></span><br><span class="line">Template <span class="keyword">string</span> <span class="string">`json:"template"`</span></span><br><span class="line">NeverInjectSelector []metav1.LabelSelector <span class="string">`json:"neverInjectSelector"`</span></span><br><span class="line">AlwaysInjectSelector []metav1.LabelSelector <span class="string">`json:"alwaysInjectSelector"`</span></span><br><span class="line">&#125;</span><br><span class="line">sidecar-injector<span class="string">` 的root cmd 会创建一个`</span>Webhook<span class="string">`, 该struct包含一个http server, 并将路由`</span>/inject<span class="string">`注册到处理器函数`</span>serveInject</span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(c *cobra.Command, _ []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    wh, err := inject.NewWebhook(parameters)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">go</span> wh.Run(stop)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWebhook</span><span class="params">(p WebhookParameters)</span> <span class="params">(*Webhook, error)</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">watcher, err := fsnotify.NewWatcher()</span><br><span class="line"><span class="comment">// watch the parent directory of the target files so we can catch</span></span><br><span class="line"><span class="comment">// symlink updates of k8s ConfigMaps volumes.</span></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;p.ConfigFile, p.MeshFile, p.CertFile, p.KeyFile&#125; &#123;</span><br><span class="line">watchDir, _ := filepath.Split(file)</span><br><span class="line"><span class="keyword">if</span> err := watcher.Watch(watchDir); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"could not watch %v: %v"</span>, file, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">h := http.NewServeMux()</span><br><span class="line">h.HandleFunc(<span class="string">"/inject"</span>, wh.serveInject)</span><br><span class="line">wh.server.Handler = h</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Webhook#Run</code>方法会启动该http server, 并负责响应配置文件的更新:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wh *Webhook)</span> <span class="title">Run</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wh.server.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">......</span><br><span class="line">&#125;()</span><br><span class="line">......</span><br><span class="line"><span class="keyword">var</span> timerC &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-timerC:</span><br><span class="line">timerC = <span class="literal">nil</span></span><br><span class="line">sidecarConfig, meshConfig, err := loadConfig(wh.configFile, wh.meshFile)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> event := &lt;-wh.watcher.Event:</span><br><span class="line"><span class="comment">// use a timer to debounce configuration updates</span></span><br><span class="line"><span class="keyword">if</span> (event.IsModify() || event.IsCreate()) &amp;&amp; timerC == <span class="literal">nil</span> &#123;</span><br><span class="line">timerC = time.After(watchDebounceDelay)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Webhook#Run</code>首先会启动处理注入请求的http server, 下面的for循环主要是处理2个配置文件的更新操作, select 里使用了一个timer(并不是ticker), 咋一看像是简单的定时更新配置文件, 其实不然. 配置文件更新事件由<code>wh.watcher</code>进行接收, 然后才会启动timer, 这里用到了第三方库<a href="https://github.com/howeyc/fsnotify" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/howeyc/fsnotify</a>, 这是一个基于文件系统的notification. 这里使用timer限制在一个周期(watchDebounceDelay)里面最多重新加载一次配置文件, 避免在配置文件频繁变化的情况下多次触发不必要的loadConfig</p><blockquote><p>use a timer to debounce configuration updates</p></blockquote><p><code>Webhook.serveInject</code> 会调用<code>Webhook#inject</code>, 最终的模板处理函数是<code>injectionData</code>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhonghua.io/2019/03/19/istio-analysis-2/" target="_blank" rel="external nofollow noopener noreferrer">https://zhonghua.io/2019/03/19/istio-analysis-2/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们分析下istio-sidecar-injector 组件&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2019-10-18_city.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="webhook" scheme="http://houmin.cc/tags/webhook/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="sidecar" scheme="http://houmin.cc/tags/sidecar/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Envoy Sidecar 流量劫持</title>
    <link href="http://houmin.cc/posts/1f0c8567/"/>
    <id>http://houmin.cc/posts/1f0c8567/</id>
    <published>2020-11-27T02:51:27.000Z</published>
    <updated>2020-12-15T11:35:12.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在讲解 Istio 如何将 Envoy 代理注入到应用程序 Pod 中之前，我们需要先了解以下几个概念：</p><ul><li>Sidecar 模式：容器应用模式之一，Service Mesh 架构的一种实现方式。</li><li>Init 容器：Pod 中的一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。</li><li>iptables：流量劫持是通过 iptables 转发实现的。</li></ul><a id="more"></a><p>查看目前 <code>productpage-v1-745ffc55b7-2l2lw</code> Pod 中运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n default get pod productpage-v1-745ffc55b7-2l2lw -o=jsonpath=<span class="string">'&#123;..spec.containers[*].name&#125;'</span></span><br><span class="line">productpage istio-proxy</span><br></pre></td></tr></table></figure><p><code>productpage</code> 即应用容器，<code>istio-proxy</code> 即 Envoy 代理的 sidecar 容器。另外该 Pod 中实际上还运行过一个 Init 容器，因为它执行结束就自动终止了，所以我们看不到该容器的存在。关注 <code>jsonpath</code> 的用法请参考 <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/" target="_blank" rel="external nofollow noopener noreferrer">JSONPath Support</a>。</p><h2 id="Sidecar-模式"><a href="#Sidecar-模式" class="headerlink" title="Sidecar 模式"></a>Sidecar 模式</h2><p>在了解 Istio 使用 Sidecar 注入之前，需要先说明下什么是 Sidecar 模式。Sidecar 是容器应用模式的一种，也是在 Service Mesh 中发扬光大的一种模式，详见 <a href="http://www.servicemesher.com/blog/service-mesh-architectures/" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh 架构解析</a>，其中详细描述了<strong>节点代理</strong>和 <strong>Sidecar</strong> 模式的 Service Mesh 架构。</p><p>使用 Sidecar 模式部署服务网格时，无需在节点上运行代理（因此您不需要基础结构的协作），但是集群中将运行多个相同的 Sidecar 副本。从另一个角度看：我可以为一组微服务部署到一个服务网格中，你也可以部署一个有特定实现的服务网格。在 Sidecar 部署方式中，你会为每个应用的容器部署一个伴生容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边运行一个 Sidecar 容器，可以理解为两个容器共享存储、网络等资源，可以广义的将这个注入了 Sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。</p><p>例如下图 <a href="https://jimmysong.io/posts/sofamesh-and-mosn-proxy-sidecar-service-mesh-by-ant-financial/" target="_blank" rel="external nofollow noopener noreferrer">SOFAMesh &amp; SOFA MOSN—基于Istio构建的用于应对大规模流量的Service Mesh解决方案</a>的架构图中描述的，MOSN 作为 Sidecar 的方式和应用运行在同一个 Pod 中，拦截所有进出应用容器的流量，<a href="https://github.com/alipay/sofa-mesh" target="_blank" rel="external nofollow noopener noreferrer">SOFAMesh</a> 兼容 Istio，其中使用 Go 语言开发的 <a href="https://github.com/alipay/sofa-mosn" target="_blank" rel="external nofollow noopener noreferrer">SOFAMosn</a> 替换了 Envoy。</p><p><img alt="SOFAMesh架构图" data-src="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/006y8mN6ly1g81hmkxqxaj30va0qg758.jpg"></p><p><strong>注意</strong>：下文中所指的 Sidecar 都是指的 Envoy 代理容器。</p><h2 id="Init-容器"><a href="#Init-容器" class="headerlink" title="Init 容器"></a>Init 容器</h2><p>Init 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。</p><p>一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。</p><p>Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。</p><p>在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 <code>restartPolicy</code> 指定的策略进行重试。然而，如果 Pod 的 <code>restartPolicy</code> 设置为 Always，Init 容器失败时会使用 <code>RestartPolicy</code> 策略。</p><p>在所有的 Init 容器没有成功之前，Pod 将不会变成 <code>Ready</code> 状态。Init 容器的端口将不会在 Service 中进行聚集。 正在初始化中的 Pod 处于 <code>Pending</code> 状态，但应该会将 <code>Initializing</code> 状态设置为 true。Init 容器运行完成以后就会自动终止。</p><p>关于 Init 容器的详细信息请参考 <a href="https://jimmysong.io/kubernetes-handbook/concepts/init-containers.html" target="_blank" rel="external nofollow noopener noreferrer">Init 容器 - Kubernetes 中文指南/云原生应用架构实践手册</a>。</p><h2 id="Sidecar-注入示例分析"><a href="#Sidecar-注入示例分析" class="headerlink" title="Sidecar 注入示例分析"></a>Sidecar 注入示例分析</h2><p>我们看下 Istio 官方示例 <code>bookinfo</code> 中 <code>productpage</code> 的 YAML 配置，关于 <code>bookinfo</code> 应用的详细 YAML 配置请参考 <a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/yaml/istio-bookinfo/bookinfo.yaml" target="_blank" rel="external nofollow noopener noreferrer">bookinfo.yaml</a>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9080</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage-v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">istio/examples-bookinfo-productpage-v1:1.8.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9080</span></span><br></pre></td></tr></table></figure><p>再查看下 <code>productpage</code> 容器的 <a href="https://github.com/istio/istio/blob/master/samples/bookinfo/src/productpage/Dockerfile" target="_blank" rel="external nofollow noopener noreferrer">Dockerfile</a>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> productpage.py /opt/microservices/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> templates /opt/microservices/templates</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt /opt/microservices/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9080</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/microservices</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python productpage.py 9080</span></span><br></pre></td></tr></table></figure><p>我们看到 <code>Dockerfile</code> 中没有配置 <code>ENTRYPOINT</code>，所以 <code>CMD</code> 的配置 <code>python productpage.py 9080</code> 将作为默认的 <code>ENTRYPOINT</code>，记住这一点，再看下注入 sidecar 之后的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl kube-inject -f yaml/istio-bookinfo/bookinfo.yaml</span><br></pre></td></tr></table></figure><p>我们只截取其中与 <code>productpage</code> 相关的 <code>Service</code> 和 <code>Deployment</code> 配置部分。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9080</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage-v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/status:</span> <span class="string">'&#123;"version":"fde14299e2ae804b95be08e0f2d171d466f47983391c00519bbf01392d9ad6bb","initContainers":["istio-init"],"containers":["istio-proxy"],"volumes":["istio-envoy","istio-certs"],"imagePullSecrets":null&#125;'</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">istio/examples-bookinfo-productpage-v1:1.8.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">proxy</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sidecar</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--configPath</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/etc/istio/proxy</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--binaryPath</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/usr/local/bin/envoy</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--serviceCluster</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">productpage</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--drainDuration</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">45s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--parentShutdownDuration</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">1m0s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--discoveryAddress</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">istio-pilot.istio-system:15007</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--discoveryRefreshDelay</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">1s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--zipkinAddress</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">zipkin.istio-system:9411</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--connectTimeout</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">10s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--statsdUdpAddress</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">istio-statsd-prom-bridge.istio-system:9125</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--proxyAdminPort</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"15000"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--controlPlaneAuthPolicy</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">NONE</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">INSTANCE_IP</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ISTIO_META_POD_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ISTIO_META_INTERCEPTION_MODE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">REDIRECT</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jimmysong/istio-release-proxyv2:1.0.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">istio-proxy</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">10m</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsUser:</span> <span class="number">1337</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/istio/proxy</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">istio-envoy</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/certs/</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">istio-certs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-p</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"15001"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-u</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"1337"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-m</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">REDIRECT</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-i</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'*'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-x</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-b</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">9080</span><span class="string">,</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jimmysong/istio-release-proxy_init:1.0.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">istio-init</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">emptyDir:</span></span><br><span class="line">          <span class="attr">medium:</span> <span class="string">Memory</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">istio-envoy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">istio-certs</span></span><br><span class="line">        <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">istio.default</span></span><br><span class="line"><span class="attr">status:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们看到 Service 的配置没有变化，所有的变化都在 <code>Deployment</code> 里，Istio 给应用 Pod 注入的配置主要包括：</p><ul><li>Init 容器 <code>istio-init</code>：用于给 Sidecar 容器即 Envoy 代理做初始化，设置 iptables 端口转发</li><li>Envoy sidecar 容器 <code>istio-proxy</code>：运行 Envoy 代理</li></ul><p>接下来将分别解析下这两个容器。</p><h3 id="Init-容器解析"><a href="#Init-容器解析" class="headerlink" title="Init 容器解析"></a>Init 容器解析</h3><p>Istio 在 Pod 中注入的 Init 容器名为 <code>istio-init</code>，我们在上面 Istio 注入完成后的 YAML 文件中看到了该容器的启动参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p 15001 -u 1337 -m REDIRECT -i <span class="string">'*'</span> -x <span class="string">""</span> -b 9080 -d <span class="string">""</span></span><br></pre></td></tr></table></figure><p>我们再检查下该容器的 <a href="https://github.com/istio/istio/blob/master/pilot/docker/Dockerfile.proxy_init" target="_blank" rel="external nofollow noopener noreferrer">Dockerfile</a> 看看 <code>ENTRYPOINT</code> 是什么以确定启动时执行的命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:xenial</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    iproute2 \</span></span><br><span class="line"><span class="bash">    iptables \</span></span><br><span class="line"><span class="bash"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> istio-iptables.sh /usr/<span class="built_in">local</span>/bin/</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/local/bin/istio-iptables.sh"</span>]</span></span><br></pre></td></tr></table></figure><p>我们看到 <code>istio-init</code> 容器的入口是 <code>/usr/local/bin/istio-iptables.sh</code> 脚本，再按图索骥看看这个脚本里到底写的什么，该脚本的位置在 Istio 源码仓库的 <a href="https://github.com/istio/istio/blob/master/tools/deb/istio-iptables.sh" target="_blank" rel="external nofollow noopener noreferrer">tools/deb/istio-iptables.sh</a>，一共 300 多行，就不贴在这里了。下面我们就来解析下这个启动脚本。</p><h3 id="Init-容器启动入口"><a href="#Init-容器启动入口" class="headerlink" title="Init 容器启动入口"></a>Init 容器启动入口</h3><p>Init 容器的启动入口是 <code>/usr/local/bin/istio-iptables.sh</code> 脚本，该脚本的用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ istio-iptables.sh -p PORT -u UID -g GID [-m mode] [-b ports] [-d ports] [-i CIDR] [-x CIDR] [-h]</span><br><span class="line">  -p: 指定重定向所有 TCP 流量的 Envoy 端口（默认为 <span class="variable">$ENVOY_PORT</span> = 15001）</span><br><span class="line">  -u: 指定未应用重定向的用户的 UID。通常，这是代理容器的 UID（默认为 <span class="variable">$ENVOY_USER</span> 的 uid，istio_proxy 的 uid 或 1337）</span><br><span class="line">  -g: 指定未应用重定向的用户的 GID。（与 -u param 相同的默认值）</span><br><span class="line">  -m: 指定入站连接重定向到 Envoy 的模式，“REDIRECT” 或 “TPROXY”（默认为 <span class="variable">$ISTIO_INBOUND_INTERCEPTION_MODE</span>)</span><br><span class="line">  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 <span class="variable">$ISTIO_INBOUND_PORTS</span>）</span><br><span class="line">  -d: 指定要从重定向到 Envoy 中排除（可选）的入站端口列表，以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 <span class="variable">$ISTIO_LOCAL_EXCLUDE_PORTS</span>）</span><br><span class="line">  -i: 指定重定向到 Envoy（可选）的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 <span class="variable">$ISTIO_SERVICE_CIDR</span>）</span><br><span class="line">  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 <span class="variable">$ISTIO_SERVICE_EXCLUDE_CIDR</span>）。</span><br><span class="line"></span><br><span class="line">环境变量位于 <span class="variable">$ISTIO_SIDECAR_CONFIG</span>（默认在：/var/lib/istio/envoy/sidecar.env）</span><br></pre></td></tr></table></figure><p>通过查看该脚本你将看到，以上传入的参数都会重新组装成 <a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="external nofollow noopener noreferrer"><code>iptables</code> 命令</a>的参数。</p><p>再参考 <code>istio-init</code> 容器的启动参数，完整的启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/bin/istio-iptables.sh -p 15001 -u 1337 -m REDIRECT -i <span class="string">'*'</span> -x <span class="string">""</span> -b 9080 -d <span class="string">""</span></span><br></pre></td></tr></table></figure><p>该容器存在的意义就是让 Envoy 代理可以拦截所有的进出 Pod 的流量，即将入站流量重定向到 Sidecar，再拦截应用容器的出站流量经过 Sidecar 处理后再出站。</p><p><strong>命令解析</strong></p><p>这条启动命令的作用是：</p><ul><li>将应用容器的所有流量都转发到 Envoy 的 15001 端口。</li><li>使用 <code>istio-proxy</code> 用户身份运行， UID 为 1337，即 Envoy 所处的用户空间，这也是 <code>istio-proxy</code> 容器默认使用的用户，见 YAML 配置中的 <code>runAsUser</code> 字段。</li><li>使用默认的 <code>REDIRECT</code> 模式来重定向流量。</li><li>将所有出站流量都重定向到 Envoy 代理。</li><li>将所有访问 9080 端口（即应用容器 <code>productpage</code> 的端口）的流量重定向到 Envoy 代理。</li></ul><p>因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 Sidecar 容器中。</p><h3 id="istio-proxy-容器解析"><a href="#istio-proxy-容器解析" class="headerlink" title="istio-proxy 容器解析"></a>istio-proxy 容器解析</h3><p>为了查看 iptables 配置，我们需要登陆到 Sidecar 容器中使用 root 用户来查看，因为 <code>kubectl</code> 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 <code>productpage</code> Pod 所在的主机上使用 <code>docker</code> 命令登陆容器中查看。</p><p>查看 <code>productpage</code> Pod 所在的主机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n default get pod -l app=productpage -o wide</span><br><span class="line">NAME                              READY     STATUS    RESTARTS   AGE       IP             NODE</span><br><span class="line">productpage-v1-745ffc55b7-2l2lw   2/2       Running   0          1d        172.33.78.10   node3</span><br></pre></td></tr></table></figure><p>从输出结果中可以看到该 Pod 运行在 <code>node3</code> 上，使用 <code>vagrant</code> 命令登陆到 <code>node3</code> 主机中并切换为 root 用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant ssh node3</span><br><span class="line">$ sudo -i</span><br></pre></td></tr></table></figure><p>查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给 <code>istio-iptables.sh</code> 传递的参数中指定将入站流量重定向到 Envoy 的模式为 “REDIRECT”，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 <code>TPROXY</code> 还会有 <code>mangle</code> 表配置。<code>iptables</code> 命令的详细用法请参考 <a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="external nofollow noopener noreferrer">iptables</a>，规则配置请参考 <a href="http://www.zsythink.net/archives/1517" target="_blank" rel="external nofollow noopener noreferrer">iptables 规则配置</a>。</p><h2 id="理解-iptables"><a href="#理解-iptables" class="headerlink" title="理解 iptables"></a>理解 iptables</h2><p><code>iptables</code> 是 Linux 内核中的防火墙软件 netfilter 的管理工具，位于用户空间，同时也是 netfilter 的一部分。Netfilter 位于内核空间，不仅有网络地址转换的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。</p><p>在了解 Init 容器初始化的 iptables 之前，我们先来了解下 iptables 和规则配置。</p><p>下图展示了 iptables 调用链。</p><p><img alt="iptables 调用链" data-src="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/iptables_packetflow.png"></p><h3 id="iptables-中的表"><a href="#iptables-中的表" class="headerlink" title="iptables 中的表"></a>iptables 中的表</h3><p>Init 容器中使用的的 iptables 版本是 <code>v1.6.0</code>，共包含 5 张表：</p><ol><li><code>raw</code> 用于配置数据包，<code>raw</code> 中的数据包不会被系统跟踪。</li><li><code>filter</code> 是用于存放所有与防火墙相关操作的默认表。</li><li><code>nat</code> 用于 <a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="external nofollow noopener noreferrer">网络地址转换</a>（例如：端口转发）。</li><li><code>mangle</code> 用于对特定数据包的修改（参考<a href="https://en.wikipedia.org/wiki/Mangled_packet" target="_blank" rel="external nofollow noopener noreferrer">损坏数据包</a>）。</li><li><code>security</code> 用于<a href="https://wiki.archlinux.org/index.php/Security#Mandatory_access_control" target="_blank" rel="external nofollow noopener noreferrer">强制访问控制</a> 网络规则。</li></ol><p><strong>注</strong>：在本示例中只用到了 <code>nat</code> 表。</p><p>不同的表中的具有的链类型如下表所示：</p><div class="table-container"><table><thead><tr><th>规则名称</th><th>raw</th><th>filter</th><th>nat</th><th>mangle</th><th>security</th></tr></thead><tbody><tr><td>PREROUTING</td><td>✓</td><td></td><td>✓</td><td>✓</td><td></td></tr><tr><td>INPUT</td><td></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>OUTPUT</td><td></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>POSTROUTING</td><td></td><td></td><td>✓</td><td>✓</td><td></td></tr><tr><td>FORWARD</td><td>✓</td><td>✓</td><td></td><td>✓</td><td>✓</td></tr></tbody></table></div><p>下图是 iptables 的调用链顺序。</p><p><img alt="iptables 调用链顺序" data-src="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/iptables-chains.jpg"></p><p>关于 iptables 的详细介绍请参考<a href="https://www.aliang.org/Linux/iptables.html" target="_blank" rel="external nofollow noopener noreferrer">常见 iptables 使用规则场景整理</a>。</p><h3 id="iptables-命令"><a href="#iptables-命令" class="headerlink" title="iptables 命令"></a>iptables 命令</h3><p><code>iptables</code> 命令的主要用途是修改这些表中的规则。<code>iptables</code> 命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables [-t 表名] 命令选项［链名]［条件匹配］[-j 目标动作或跳转］</span><br></pre></td></tr></table></figure><p>Init 容器中的 <code>/istio-iptables.sh</code> 启动入口脚本就是执行 iptables 初始化的。</p><h3 id="理解-iptables-规则"><a href="#理解-iptables-规则" class="headerlink" title="理解 iptables 规则"></a>理解 iptables 规则</h3><p>查看 <code>istio-proxy</code> 容器中的默认的 iptables 规则，默认查看的是 filter 表中的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -L -v</span><br><span class="line">Chain INPUT (policy ACCEPT 350K packets, 63M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 18M packets, 1916M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><p>我们看到三个默认的链，分别是 INPUT、FORWARD 和 OUTPUT，每个链中的第一行输出表示链名称（在本例中为INPUT/FORWARD/OUTPUT），后跟默认策略（ACCEPT）。</p><p>每条链中都可以添加多条规则，规则是按照顺序从前到后执行的。我们来看下规则的表头定义。</p><ul><li><strong>pkts</strong>：处理过的匹配的报文数量</li><li><strong>bytes</strong>：累计处理的报文大小（字节数）</li><li><strong>target</strong>：如果报文与规则匹配，指定目标就会被执行。</li><li><strong>prot</strong>：协议，例如 <code>tdp</code>、<code>udp</code>、<code>icmp</code> 和 <code>all</code>。</li><li><strong>opt</strong>：很少使用，这一列用于显示 IP 选项。</li><li><strong>in</strong>：入站网卡。</li><li><strong>out</strong>：出站网卡。</li><li><strong>source</strong>：流量的源 IP 地址或子网，后者是 <code>anywhere</code>。</li><li><strong>destination</strong>：流量的目的地 IP 地址或子网，或者是 <code>anywhere</code>。</li></ul><p>还有一列没有表头，显示在最后，表示规则的选项，作为规则的扩展匹配条件，用来补充前面的几列中的配置。<code>prot</code>、<code>opt</code>、<code>in</code>、<code>out</code>、<code>source</code> 和 <code>destination</code> 和显示在 <code>destination</code> 后面的没有表头的一列扩展条件共同组成匹配规则。当流量匹配这些规则后就会执行 <code>target</code>。</p><p>关于 iptables 规则请参考<a href="https://www.aliang.org/Linux/iptables.html" target="_blank" rel="external nofollow noopener noreferrer">常见iptables使用规则场景整理</a>。</p><p><strong>target 支持的类型</strong></p><p><code>target</code> 类型包括 ACCEPT<code>、REJECT</code>、<code>DROP</code>、<code>LOG</code> 、<code>SNAT</code>、<code>MASQUERADE</code>、<code>DNAT</code>、<code>REDIRECT</code>、<code>RETURN</code> 或者跳转到其他规则等。只要执行到某一条链中只有按照顺序有一条规则匹配后就可以确定报文的去向了，除了 <code>RETURN</code> 类型，类似编程语言中的 <code>return</code> 语句，返回到它的调用点，继续执行下一条规则。<code>target</code> 支持的配置详解请参考 <a href="http://www.zsythink.net/archives/1199" target="_blank" rel="external nofollow noopener noreferrer">iptables 详解（1）：iptables 概念</a>。</p><p>从输出结果中可以看到 Init 容器没有在 iptables 的默认链路中创建任何规则，而是创建了新的链路。</p><h2 id="查看-iptables-nat-表中注入的规则"><a href="#查看-iptables-nat-表中注入的规则" class="headerlink" title="查看 iptables nat 表中注入的规则"></a>查看 iptables nat 表中注入的规则</h2><p>Init 容器通过向 iptables nat 表中注入转发规则来劫持流量的，下图显示的是 productpage 服务中的 iptables 流量劫持的详细过程。</p><p><img alt="Envoy sidecar 流量劫持与路由转发示意图" data-src="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/istio-envoy-sidecar-traffic-injection.jpg"></p><p>Init 容器启动时命令行参数中指定了 <code>REDIRECT</code> 模式，因此只创建了 NAT 表规则，接下来我们查看下 NAT 表中创建的规则，这是全文中的<strong>重点部分</strong>，前面讲了那么多都是为它做铺垫的。下面是查看 nat 表中的规则，其中链的名字中包含 <code>ISTIO</code> 前缀的是由 Init 容器注入的，规则匹配是根据下面显示的顺序来执行的，其中会有多次跳转。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 NAT 表中规则配置的详细信息</span></span><br><span class="line">$ iptables -t nat -L -v</span><br><span class="line"><span class="comment"># PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    2   120 ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链</span></span><br><span class="line">Chain INPUT (policy ACCEPT 2 packets, 120 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上</span></span><br><span class="line">Chain OUTPUT (policy ACCEPT 41146 packets, 3845K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   93  5580 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># POSTROUTING 链：所有数据包流出网卡时都要先进入POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 41199 packets, 3848K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_INBOUND 链：将所有目的地为 9080 端口的入站流量重定向到 ISTIO_IN_REDIRECT 链上</span></span><br><span class="line">Chain ISTIO_INBOUND (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    2   120 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere             tcp dpt:9080</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15001 端口，至此成功的拦截了流量到 Envoy </span></span><br><span class="line">Chain ISTIO_IN_REDIRECT (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    2   120 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_OUTPUT 链：选择需要重定向到 Envoy（即本地） 的出站流量，所有非 localhost 的流量全部转发到 ISTIO_REDIRECT。为了避免流量在该 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 ISTIO_OUTPUT 规则之后就进入下一条链 POSTROUTING。如果目的地非 localhost 就跳转到 ISTIO_REDIRECT；如果流量是来自 istio-proxy 用户空间的，那么就跳出该链，返回它的调用链继续执行下一条规则（OUPT 的下一条规则，无需对流量进行处理）；所有的非 istio-proxy 用户空间的目的地是 localhost 的流量就跳转到 ISTIO_REDIRECT</span></span><br><span class="line">Chain ISTIO_OUTPUT (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 ISTIO_REDIRECT  all  --  any    lo      anywhere            !localhost</span><br><span class="line">   40  2400 RETURN     all  --  any    any     anywhere             anywhere             owner UID match istio-proxy</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match istio-proxy</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             localhost</span><br><span class="line">   53  3180 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_REDIRECT 链：将所有流量重定向到 Envoy（即本地） 的 15001 端口</span></span><br><span class="line">Chain ISTIO_REDIRECT (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   53  3180 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001</span><br></pre></td></tr></table></figure><p><code>iptables</code> 显示的链的顺序，即流量规则匹配的顺序。其中要特别注意 <code>ISTIO_OUTPUT</code> 链中的规则配置。为了避免流量一直在 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 <code>ISTIO_OUTPUT</code> 规则之后就进入下一条链 <code>POSTROUTING</code>。</p><p><code>ISTIO_OUTPUT</code> 链规则匹配的详细过程如下：</p><ul><li>如果目的地非 localhost 就跳转到 ISTIO_REDIRECT 链</li><li>所有来自 istio-proxy 用户空间的非 localhost 流量跳转到它的调用点 <code>OUTPUT</code> 继续执行 <code>OUTPUT</code> 链的下一条规则，因为 <code>OUTPUT</code> 链中没有下一条规则了，所以会继续执行 <code>POSTROUTING</code> 链然后跳出 iptables，直接访问目的地</li><li>如果流量不是来自 istio-proxy 用户空间，又是对 localhost 的访问，那么就跳出 iptables，直接访问目的地</li><li>其它所有情况都跳转到 <code>ISTIO_REDIRECT</code> 链</li></ul><p>其实在最后这条规则前还可以增加 IP 地址过滤，让某些 IP 地址段不通过 Envoy 代理。</p><p>以上 iptables 规则都是 Init 容器启动的时使用 <a href="https://github.com/istio/istio/blob/master/tools/deb/istio-iptables.sh" target="_blank" rel="external nofollow noopener noreferrer">istio-iptables.sh</a> 脚本生成的，详细过程可以查看该脚本。</p><h2 id="查看-Envoy-运行状态"><a href="#查看-Envoy-运行状态" class="headerlink" title="查看 Envoy 运行状态"></a>查看 Envoy 运行状态</h2><p>首先查看 <code>proxyv2</code> 镜像的 <a href="https://github.com/istio/istio/blob/master/pilot/docker/Dockerfile.proxyv2" target="_blank" rel="external nofollow noopener noreferrer">Dockerfile</a>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> istionightly/base_debug</span><br><span class="line"><span class="keyword">ARG</span> proxy_version</span><br><span class="line"><span class="keyword">ARG</span> istio_version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Envoy</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> envoy /usr/<span class="built_in">local</span>/bin/envoy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用环境变量的方式明文指定 proxy 的版本/功能</span></span><br><span class="line"><span class="keyword">ENV</span> ISTIO_META_ISTIO_PROXY_VERSION <span class="string">"1.1.0"</span></span><br><span class="line"><span class="comment"># 使用环境变量的方式明文指定 proxy 明确的 sha，用于指定版本的配置和调试</span></span><br><span class="line"><span class="keyword">ENV</span> ISTIO_META_ISTIO_PROXY_SHA $proxy_version</span><br><span class="line"><span class="comment"># 环境变量，指定明确的构建号，用于调试</span></span><br><span class="line"><span class="keyword">ENV</span> ISTIO_META_ISTIO_VERSION $istio_version</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> pilot-agent /usr/<span class="built_in">local</span>/bin/pilot-agent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> envoy_pilot.yaml.tmpl /etc/istio/proxy/envoy_pilot.yaml.tmpl</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> envoy_policy.yaml.tmpl /etc/istio/proxy/envoy_policy.yaml.tmpl</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> envoy_telemetry.yaml.tmpl /etc/istio/proxy/envoy_telemetry.yaml.tmpl</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> istio-iptables.sh /usr/<span class="built_in">local</span>/bin/istio-iptables.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> envoy_bootstrap_v2.json /var/lib/istio/envoy/envoy_bootstrap_tmpl.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 755 /usr/<span class="built_in">local</span>/bin/envoy /usr/<span class="built_in">local</span>/bin/pilot-agent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 istio-proxy 用户加入 sudo 权限以允许执行 tcpdump 和其他调试命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> useradd -m --uid 1337 istio-proxy &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">"istio-proxy ALL=NOPASSWD: ALL"</span> &gt;&gt; /etc/sudoers &amp;&amp; \</span></span><br><span class="line"><span class="bash">    chown -R istio-proxy /var/lib/istio</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pilot-agent 来启动 Envoy</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/local/bin/pilot-agent"</span>]</span></span><br></pre></td></tr></table></figure><p>该容器的启动入口是 <code>pilot-agent</code> 命令，根据 YAML 配置中传递的参数，详细的启动命令入下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/pilot-agent proxy sidecar --configPath /etc/istio/proxy --binaryPath /usr/<span class="built_in">local</span>/bin/envoy --serviceCluster productpage --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istio-pilot.istio-system:15007 --discoveryRefreshDelay 1s --zipkinAddress zipkin.istio-system:9411 --connectTimeout 10s --statsdUdpAddress istio-statsd-prom-bridge.istio-system:9125 --proxyAdminPort 15000 --controlPlaneAuthPolicy NONE</span><br></pre></td></tr></table></figure><p>主要配置了 Envoy 二进制文件的位置、服务发现地址、服务集群名、监控指标上报地址、Envoy 的管理端口、热重启时间等，详细用法请参考 <a href="https://istio.io/docs/reference/commands/pilot-agent/" target="_blank" rel="external nofollow noopener noreferrer">Istio官方文档 pilot-agent 的用法</a>。</p><p><code>pilot-agent</code> 是容器中 PID 为 1 的启动进程，它启动时又创建了一个 Envoy 进程，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/envoy -c /etc/istio/proxy/envoy-rev0.json --restart-epoch 0 --drain-time<span class="_">-s</span> 45 --parent-shutdown-time<span class="_">-s</span> 60 --service-cluster productpage --service-node sidecar~172.33.78.10~productpage-v1-745ffc55b7-2l2lw.default~default.svc.cluster.local --max-obj-name-len 189 -l warn --v2-config-only</span><br></pre></td></tr></table></figure><p>我们分别解释下以上配置的意义。</p><ul><li><code>-c /etc/istio/proxy/envoy-rev0.json</code>：配置文件，支持 <code>.json</code>、<code>.yaml</code>、<code>.pb</code> 和 <code>.pb_text</code> 格式，<code>pilot-agent</code> 启动的时候读取了容器的环境变量后创建的。</li><li><code>--restart-epoch 0</code>：Envoy 热重启周期，第一次启动默认为 0，每热重启一次该值加 1。</li><li><code>--drain-time-s 45</code>：热重启期间 Envoy 将耗尽连接的时间。</li><li><code>--parent-shutdown-time-s 60</code>： Envoy 在热重启时关闭父进程之前等待的时间。</li><li><code>--service-cluster productpage</code>：Envoy 运行的本地服务集群的名字。</li><li><code>--service-node sidecar~172.33.78.10~productpage-v1-745ffc55b7-2l2lw.default~default.svc.cluster.local</code>：定义 Envoy 运行的本地服务节点名称，其中包含了该 Pod 的名称、IP、DNS 域等信息，根据容器的环境变量拼出来的。</li><li><code>-max-obj-name-len 189</code>：cluster/route_config/listener 中名称字段的最大长度（以字节为单位）</li><li><code>-l warn</code>：日志级别</li><li><code>--v2-config-only</code>：只解析 v2 引导配置文件</li></ul><p>详细配置请参考 <a href="http://www.servicemesher.com/envoy/operations/cli.html" target="_blank" rel="external nofollow noopener noreferrer">Envoy 的命令行选项</a>。</p><p>查看 Envoy 的配置文件 <code>/etc/istio/proxy/envoy-rev0.json</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"node"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"sidecar~172.33.78.10~productpage-v1-745ffc55b7-2l2lw.default~default.svc.cluster.local"</span>,</span><br><span class="line">    <span class="attr">"cluster"</span>: <span class="string">"productpage"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">          <span class="attr">"INTERCEPTION_MODE"</span>: <span class="string">"REDIRECT"</span>,</span><br><span class="line">          <span class="attr">"ISTIO_PROXY_SHA"</span>: <span class="string">"istio-proxy:6166ae7ebac7f630206b2fe4e6767516bf198313"</span>,</span><br><span class="line">          <span class="attr">"ISTIO_PROXY_VERSION"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">          <span class="attr">"ISTIO_VERSION"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">          <span class="attr">"POD_NAME"</span>: <span class="string">"productpage-v1-745ffc55b7-2l2lw"</span>,</span><br><span class="line">      <span class="attr">"istio"</span>: <span class="string">"sidecar"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"stats_config"</span>: &#123;</span><br><span class="line">    <span class="attr">"use_all_default_tags"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"admin"</span>: &#123;</span><br><span class="line">    <span class="attr">"access_log_path"</span>: <span class="string">"/dev/stdout"</span>,</span><br><span class="line">    <span class="attr">"address"</span>: &#123;</span><br><span class="line">      <span class="attr">"socket_address"</span>: &#123;</span><br><span class="line">        <span class="attr">"address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"port_value"</span>: <span class="number">15000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dynamic_resources"</span>: &#123;</span><br><span class="line">    <span class="attr">"lds_config"</span>: &#123;</span><br><span class="line">        <span class="attr">"ads"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"cds_config"</span>: &#123;</span><br><span class="line">        <span class="attr">"ads"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ads_config"</span>: &#123;</span><br><span class="line">      <span class="attr">"api_type"</span>: <span class="string">"GRPC"</span>,</span><br><span class="line">      <span class="attr">"refresh_delay"</span>: &#123;<span class="attr">"seconds"</span>: <span class="number">1</span>, <span class="attr">"nanos"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">      <span class="attr">"grpc_services"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"envoy_grpc"</span>: &#123;</span><br><span class="line">            <span class="attr">"cluster_name"</span>: <span class="string">"xds-grpc"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"static_resources"</span>: &#123;</span><br><span class="line">    <span class="attr">"clusters"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xds-grpc"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"STRICT_DNS"</span>,</span><br><span class="line">    <span class="attr">"connect_timeout"</span>: &#123;<span class="attr">"seconds"</span>: <span class="number">10</span>, <span class="attr">"nanos"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="attr">"lb_policy"</span>: <span class="string">"ROUND_ROBIN"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"hosts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">"socket_address"</span>: &#123;<span class="attr">"address"</span>: <span class="string">"istio-pilot.istio-system"</span>, <span class="attr">"port_value"</span>: <span class="number">15010</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"circuit_breakers"</span>: &#123;</span><br><span class="line">        <span class="attr">"thresholds"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"priority"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"max_connections"</span>: <span class="string">"100000"</span>,</span><br><span class="line">        <span class="attr">"max_pending_requests"</span>: <span class="string">"100000"</span>,</span><br><span class="line">        <span class="attr">"max_requests"</span>: <span class="string">"100000"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"priority"</span>: <span class="string">"high"</span>,</span><br><span class="line">        <span class="attr">"max_connections"</span>: <span class="string">"100000"</span>,</span><br><span class="line">        <span class="attr">"max_pending_requests"</span>: <span class="string">"100000"</span>,</span><br><span class="line">        <span class="attr">"max_requests"</span>: <span class="string">"100000"</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"upstream_connection_options"</span>: &#123;</span><br><span class="line">      <span class="attr">"tcp_keepalive"</span>: &#123;</span><br><span class="line">        <span class="attr">"keepalive_time"</span>: <span class="number">300</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"http2_protocol_options"</span>: &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"zipkin"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"STRICT_DNS"</span>,</span><br><span class="line">        <span class="attr">"connect_timeout"</span>: &#123;</span><br><span class="line">          <span class="attr">"seconds"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"lb_policy"</span>: <span class="string">"ROUND_ROBIN"</span>,</span><br><span class="line">        <span class="attr">"hosts"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"socket_address"</span>: &#123;<span class="attr">"address"</span>: <span class="string">"zipkin.istio-system"</span>, <span class="attr">"port_value"</span>: <span class="number">9411</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"tracing"</span>: &#123;</span><br><span class="line">    <span class="attr">"http"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"envoy.zipkin"</span>,</span><br><span class="line">      <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"collector_cluster"</span>: <span class="string">"zipkin"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">"stats_sinks"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"envoy.statsd"</span>,</span><br><span class="line">      <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"address"</span>: &#123;</span><br><span class="line">          <span class="attr">"socket_address"</span>: &#123;<span class="attr">"address"</span>: <span class="string">"10.254.109.175"</span>, <span class="attr">"port_value"</span>: <span class="number">9125</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是使用 Istio 管理的 bookinfo 示例的访问请求路径图。</p><p><img alt="Istio bookinfo" data-src="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/006tNbRwgy1fvlwjd3302j31bo0ro0x5.jpg"></p><p>对照 bookinfo 示例的 productpage 的查看建立的连接。在 <code>productpage-v1-745ffc55b7-2l2lw</code> Pod 的 <code>istio-proxy</code> 容器中使用 root 用户查看打开的端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i</span><br><span class="line">COMMAND PID        USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">envoy    11 istio-proxy    9u  IPv4  73951      0t0  TCP localhost:15000 (LISTEN) <span class="comment"># Envoy admin 端口</span></span><br><span class="line">envoy    11 istio-proxy   17u  IPv4  74320      0t0  TCP productpage-v1-745ffc55b7-2l2lw:46862-&gt;istio-pilot.istio-system.svc.cluster.local:15010 (ESTABLISHED) <span class="comment"># 15010：istio-pilot 的 grcp-xds 端口</span></span><br><span class="line">envoy    11 istio-proxy   18u  IPv4  73986      0t0  UDP productpage-v1-745ffc55b7-2l2lw:44332-&gt;istio-statsd-prom-bridge.istio-system.svc.cluster.local:9125 <span class="comment"># 给 Promethues 发送 metric 的端口</span></span><br><span class="line">envoy    11 istio-proxy   52u  IPv4  74599      0t0  TCP *:15001 (LISTEN) <span class="comment"># Envoy 的监听端口</span></span><br><span class="line">envoy    11 istio-proxy   53u  IPv4  74600      0t0  UDP productpage-v1-745ffc55b7-2l2lw:48011-&gt;istio-statsd-prom-bridge.istio-system.svc.cluster.local:9125 <span class="comment"># 给 Promethues 发送 metric 端口</span></span><br><span class="line">envoy    11 istio-proxy   54u  IPv4 338551      0t0  TCP productpage-v1-745ffc55b7-2l2lw:15001-&gt;172.17.8.102:52670 (ESTABLISHED) <span class="comment"># 52670：Ingress gateway 端口</span></span><br><span class="line">envoy    11 istio-proxy   55u  IPv4 338364      0t0  TCP productpage-v1-745ffc55b7-2l2lw:44046-&gt;172.33.78.9:9091 (ESTABLISHED) <span class="comment"># 9091：istio-telemetry 服务的 grpc-mixer 端口</span></span><br><span class="line">envoy    11 istio-proxy   56u  IPv4 338473      0t0  TCP productpage-v1-745ffc55b7-2l2lw:47210-&gt;zipkin.istio-system.svc.cluster.local:9411 (ESTABLISHED) <span class="comment"># 9411: zipkin 端口</span></span><br><span class="line">envoy    11 istio-proxy   58u  IPv4 338383      0t0  TCP productpage-v1-745ffc55b7-2l2lw:41564-&gt;172.33.84.8:9080 (ESTABLISHED) <span class="comment"># 9080：details-v1 的 http 端口</span></span><br><span class="line">envoy    11 istio-proxy   59u  IPv4 338390      0t0  TCP productpage-v1-745ffc55b7-2l2lw:54410-&gt;172.33.78.5:9080 (ESTABLISHED) <span class="comment"># 9080：reivews-v2 的 http 端口</span></span><br><span class="line">envoy    11 istio-proxy   60u  IPv4 338411      0t0  TCP productpage-v1-745ffc55b7-2l2lw:35200-&gt;172.33.84.5:9091 (ESTABLISHED) <span class="comment"># 9091:istio-telemetry 服务的 grpc-mixer 端口</span></span><br><span class="line">envoy    11 istio-proxy   62u  IPv4 338497      0t0  TCP productpage-v1-745ffc55b7-2l2lw:34402-&gt;172.33.84.9:9080 (ESTABLISHED) <span class="comment"># reviews-v1 的 http 端口</span></span><br><span class="line">envoy    11 istio-proxy   63u  IPv4 338525      0t0  TCP productpage-v1-745ffc55b7-2l2lw:50592-&gt;172.33.71.5:9080 (ESTABLISHED) <span class="comment"># reviews-v3 的 http 端口</span></span><br></pre></td></tr></table></figure><p>从输出级过上可以验证 Sidecar 是如何接管流量和与 istio-pilot 通信，及向 Mixer 做遥测数据汇聚的。感兴趣的读者可以再去看看其他几个服务的 istio-proxy 容器中的 iptables 和端口信息。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://jimmysong.io/posts/sofamesh-and-mosn-proxy-sidecar-service-mesh-by-ant-financial" target="_blank" rel="external nofollow noopener noreferrer">SOFAMesh &amp; SOFA MOSN—基于Istio构建的用于应对大规模流量的Service Mesh解决方案 - jimmysong.io</a></li><li><a href="https://jimmysong.io/kubernetes-handbook/concepts/init-containers.html" target="_blank" rel="external nofollow noopener noreferrer">Init 容器 - Kubernetes 中文指南/云原生应用架构实践手册 - jimmysong.io</a></li><li><a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/" target="_blank" rel="external nofollow noopener noreferrer">JSONPath Support - kubernetes.io</a></li><li><a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="external nofollow noopener noreferrer">iptables 命令使用说明 - wangchujiang.com</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules" target="_blank" rel="external nofollow noopener noreferrer">How To List and Delete Iptables Firewall Rules - digitalocean.com</a></li><li><a href="https://www.cnblogs.com/fhefh/archive/2011/04/04/2005249.html" target="_blank" rel="external nofollow noopener noreferrer">一句一句解说 iptables的详细中文手册 - cnblog.com</a></li><li><a href="https://www.aliang.org/Linux/iptables.html" target="_blank" rel="external nofollow noopener noreferrer">常见iptables使用规则场景整理 - aliang.org</a></li></ul><h1 id="Sidecar-注入及透明流量劫持"><a href="#Sidecar-注入及透明流量劫持" class="headerlink" title="Sidecar 注入及透明流量劫持"></a>Sidecar 注入及透明流量劫持</h1><p>本节将为大家介绍以下内容：</p><ul><li>什么是 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 模式和它的优势在哪里。</li><li><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中是如何做 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 注入的？</li><li><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> proxy 是如何做透明流量劫持的？</li></ul><h2 id="Sidecar-模式-1"><a href="#Sidecar-模式-1" class="headerlink" title="Sidecar 模式"></a>Sidecar 模式</h2><p>将应用程序的功能划分为单独的进程运行在同一个最小调度单元中（例如 Kubernetes 中的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a>）可以被视为 <strong><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 模式</strong>。如下图所示，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 模式允许您在应用程序旁边添加更多功能，而无需额外第三方组件配置或修改应用程序代码。</p><p><a href="https://www.servicemesher.com/istio-handbook/images/sidecar-pattern.jpg" target="_blank" rel="external nofollow noopener noreferrer"><img alt="Sidecar 模式示意图" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/sidecar-pattern.jpg"></a>图 2.3.2.1.1：<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 模式示意图</p><p>就像连接了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 的三轮摩托车一样，在软件架构中， <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 连接到父应用并且为其添加扩展或者增强功能。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观察性、监控、日志记录、配置、断路器等功能。</p><h3 id="使用-Sidecar-模式的优势"><a href="#使用-Sidecar-模式的优势" class="headerlink" title="使用 Sidecar 模式的优势"></a>使用 Sidecar 模式的优势</h3><p>使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 副本。在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 部署方式中，每个应用的容器旁都会部署一个伴生容器（如 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 或 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#mosn" target="_blank" rel="external nofollow noopener noreferrer">MOSN</a>），这个容器称之为 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 容器。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 接管进出应用容器的所有流量。在 Kubernetes 的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 中，在原有的应用容器旁边注入一个 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 容器的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 理解为一台主机，两个容器共享主机资源。</p><p>因其独特的部署结构，使得 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 模式具有以下优势：</p><ul><li>将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。</li><li>因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。</li><li><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 可独立升级，降低应用程序代码和底层平台的耦合度。</li></ul><h2 id="Istio-中的-sidecar-注入"><a href="#Istio-中的-sidecar-注入" class="headerlink" title="Istio 中的 sidecar 注入"></a>Istio 中的 sidecar 注入</h2><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中提供了以下两种 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 注入方式：</p><ul><li>使用 <code>istioctl</code> 手动注入。</li><li>基于 Kubernetes 的 <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" target="_blank" rel="external nofollow noopener noreferrer">突变 webhook 入驻控制器（mutating webhook addmission controller</a> 的自动 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 注入方式。</li></ul><p>不论是手动注入还是自动注入，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 的注入过程都需要遵循如下步骤：</p><ol><li>Kubernetes 需要了解待注入的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 所连接的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 集群及其配置；</li><li>Kubernetes 需要了解待注入的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 容器本身的配置，如镜像地址、启动参数等；</li><li>Kubernetes 根据 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 注入模板和以上配置填充 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 的配置参数，将以上配置注入到应用容器的一侧；</li></ol><p>使用下面的命令可以手动注入 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl kube-inject -f <span class="variable">$&#123;YAML_FILE&#125;</span> | kuebectl apply -f -</span><br></pre></td></tr></table></figure><p>该命令会使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 内置的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 配置来注入，下面使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a>详细配置请参考 <a href="https://istio.io/docs/setup/additional-setup/sidecar-injection/#manual-sidecar-injection" target="_blank" rel="external nofollow noopener noreferrer">Istio 官网</a>。</p><p>注入完成后您将看到 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 为原有 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">pod</a> template 注入了 <code>initContainer</code> 及 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> proxy相关的配置。</p><h3 id="Init-容器-1"><a href="#Init-容器-1" class="headerlink" title="Init 容器"></a>Init 容器</h3><p>Init 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。</p><p>一个 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 和运行应用容器。</p><p>Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。</p><p>在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 的 <code>restartPolicy</code> 指定的策略进行重试。然而，如果 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 的 <code>restartPolicy</code> 设置为 Always，Init 容器失败时会使用 <code>RestartPolicy</code> 策略。</p><p>在所有的 Init 容器没有成功之前，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 将不会变成 <code>Ready</code> 状态。Init 容器的端口将不会在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#service" target="_blank" rel="external nofollow noopener noreferrer">Service</a> 中进行聚集。 正在初始化中的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 处于 <code>Pending</code> 状态，但应该会将 <code>Initializing</code> 状态设置为 true。Init 容器运行完成以后就会自动终止。</p><p>关于 Init 容器的详细信息请参考 <a href="https://jimmysong.io/kubernetes-handbook/concepts/init-containers.html" target="_blank" rel="external nofollow noopener noreferrer">Init 容器 - Kubernetes 中文指南/云原生应用架构实践手册</a>。</p><h2 id="Sidecar-注入示例分析-1"><a href="#Sidecar-注入示例分析-1" class="headerlink" title="Sidecar 注入示例分析"></a>Sidecar 注入示例分析</h2><p>以 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 官方提供的 <code>bookinfo</code> 中 <code>productpage</code> 的 YAML 为例，关于 <code>bookinfo</code> 应用的详细 YAML 配置请参考 <a href="https://github.com/istio/istio/blob/master/samples/bookinfo/platform/kube/bookinfo.yaml" target="_blank" rel="external nofollow noopener noreferrer">bookinfo.yaml</a>。</p><p>下文将从以下几个方面讲解：</p><ul><li><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 容器的注入</li><li>iptables 规则的创建</li><li>路由的详细过程</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage-v1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">bookinfo-productpage</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.io/istio/examples-bookinfo-productpage-v1:1.15.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>再查看下 <code>productpage</code> 容器的 <a href="https://github.com/istio/istio/blob/master/samples/bookinfo/src/productpage/Dockerfile" target="_blank" rel="external nofollow noopener noreferrer">Dockerfile</a>。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">4</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="built_in">test</span>-requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -r <span class="built_in">test</span>-requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> productpage.py /opt/microservices/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> tests/unit/* /opt/microservices/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> templates /opt/microservices/templates</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> static /opt/microservices/static</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt /opt/microservices/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> flood_factor</span><br><span class="line"><span class="keyword">ENV</span> FLOOD_FACTOR $&#123;flood_factor:-<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9080</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/microservices</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> python -m unittest discover</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"productpage.py"</span>, <span class="string">"9080"</span>]</span></span><br></pre></td></tr></table></figure><p>我们看到 <code>Dockerfile</code> 中没有配置 <code>ENTRYPOINT</code>，所以 <code>CMD</code> 的配置 <code>python productpage.py 9080</code> 将作为默认的 <code>ENTRYPOINT</code>，记住这一点，再看下注入 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 之后的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br></pre></td></tr></table></figure><p>我们只截取其中与 <code>productpage</code> 相关的 <code>Deployment</code> 配置中的部分 YAML 配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">image:</span> <span class="string">docker.io/istio/examples-bookinfo-productpage-v1:1.15.0</span> <span class="comment"># 应用镜像</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">productpage</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9080</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">proxy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sidecar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--domain</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">$(POD_NAMESPACE).svc.cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--configPath</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/etc/istio/proxy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--binaryPath</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/usr/local/bin/envoy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--serviceCluster</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">productpage.$(POD_NAMESPACE)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--drainDuration</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">45s</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--parentShutdownDuration</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">1m0s</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--discoveryAddress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istiod.istio-system.svc:15012</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--zipkinAddress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zipkin.istio-system:9411</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--proxyLogLevel=warning</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--proxyComponentLogLevel=misc:error</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--connectTimeout</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">10s</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--proxyAdminPort</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15000"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--concurrency</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"2"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--controlPlaneAuthPolicy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">NONE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--dnsRefreshRate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">300s</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--statusPort</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15020"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--trust-domain=cluster.local</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--controlPlaneBootstrap=false</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker.io/istio/proxyv2:1.5.1</span> <span class="comment"># sidecar proxy</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-proxy</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">15090</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http-envoy-prom</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio-iptables</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-p</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15001"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-z</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"15006"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-u</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"1337"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-m</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">REDIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-i</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'*'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-x</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-b</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">'*'</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-d</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">15090</span><span class="string">,15020</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker.io/istio/proxyv2:1.5.1</span> <span class="comment"># init 容器</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-init</span></span><br></pre></td></tr></table></figure><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 给应用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 注入的配置主要包括：</p><ul><li>Init 容器 <code>istio-init</code>：用于 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">pod</a> 中设置 iptables 端口转发</li><li><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 容器 <code>istio-proxy</code>：运行 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 代理，如 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 或 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#mosn" target="_blank" rel="external nofollow noopener noreferrer">MOSN</a></li></ul><p>接下来将分别解析下这两个容器。</p><h2 id="Init-容器解析-1"><a href="#Init-容器解析-1" class="headerlink" title="Init 容器解析"></a>Init 容器解析</h2><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">pod</a> 中注入的 Init 容器名为 <code>istio-init</code>，我们在上面 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 注入完成后的 YAML 文件中看到了该容器的启动命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i <span class="string">'*'</span> -x <span class="string">""</span> -b <span class="string">'*'</span> -d 15090,15020</span><br></pre></td></tr></table></figure><p>我们再检查下该容器的 <a href="https://github.com/istio/istio/blob/master/pilot/docker/Dockerfile.proxyv2" target="_blank" rel="external nofollow noopener noreferrer">Dockerfile</a> 看看 <code>ENTRYPOINT</code> 是怎么确定启动时执行的命令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的内容省略</span></span><br><span class="line"><span class="comment"># The pilot-agent will bootstrap Envoy.</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/local/bin/pilot-agent"</span>]</span></span><br></pre></td></tr></table></figure><p>我们看到 <code>istio-init</code> 容器的入口是 <code>/usr/local/bin/istio-iptables</code> 命令行，该命令行工具的代码的位置在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 源码仓库的 <a href="https://github.com/istio/istio/tree/master/tools/istio-iptables" target="_blank" rel="external nofollow noopener noreferrer">tools/istio-iptables</a> 目录。</p><p>注意：在 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 1.1 版本时还是使用 <code>isito-iptables.sh</code> 命令行来操作 IPtables。</p><h3 id="Init-容器启动入口-1"><a href="#Init-容器启动入口-1" class="headerlink" title="Init 容器启动入口"></a>Init 容器启动入口</h3><p>Init 容器的启动入口是 <code>istio-iptables</code> 命令行，该命令行工具的用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ istio-iptables [flags]</span><br><span class="line">  -p: 指定重定向所有 TCP 流量的 sidecar 端口（默认为 <span class="variable">$ENVOY_PORT</span> = 15001）</span><br><span class="line">  -m: 指定入站连接重定向到 sidecar 的模式，“REDIRECT” 或 “TPROXY”（默认为 <span class="variable">$ISTIO_INBOUND_INTERCEPTION_MODE</span>)</span><br><span class="line">  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 <span class="variable">$ISTIO_INBOUND_PORTS</span>）</span><br><span class="line">  -d: 指定要从重定向到 sidecar 中排除的入站端口列表（可选），以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 <span class="variable">$ISTIO_LOCAL_EXCLUDE_PORTS</span>）</span><br><span class="line">  -o：逗号分隔的出站端口列表，不包括重定向到 Envoy 的端口。</span><br><span class="line">  -i: 指定重定向到 sidecar 的 IP 地址范围（可选），以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 <span class="variable">$ISTIO_SERVICE_CIDR</span>）</span><br><span class="line">  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 <span class="variable">$ISTIO_SERVICE_EXCLUDE_CIDR</span>）。</span><br><span class="line">  -k：逗号分隔的虚拟接口列表，其入站流量（来自虚拟机的）将被视为出站流量。</span><br><span class="line">  -g：指定不应用重定向的用户的 GID。(默认值与 -u param 相同)</span><br><span class="line">  -u：指定不应用重定向的用户的 UID。通常情况下，这是代理容器的 UID（默认值是 1337，即 istio-proxy 的 UID）。</span><br><span class="line">  -z: 所有进入 pod/VM 的 TCP 流量应被重定向到的端口（默认 <span class="variable">$INBOUND_CAPTURE_PORT</span> = 15006）。</span><br></pre></td></tr></table></figure><p>以上传入的参数都会重新组装成 <a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="external nofollow noopener noreferrer"><code>iptables</code> </a>规则，关于该命令的详细用法请访问 <a href="https://github.com/istio/istio/blob/master/tools/istio-iptables/pkg/cmd/root.go" target="_blank" rel="external nofollow noopener noreferrer">tools/istio-iptables/pkg/cmd/root.go</a>。</p><p>该容器存在的意义就是让 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 代理可以拦截所有的进出 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">pod</a> 的流量，15090 端口（<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#mixer" target="_blank" rel="external nofollow noopener noreferrer">Mixer</a> 使用）和 15092 端口（Ingress Gateway）除外的所有入站（inbound）流量重定向到 15006 端口（<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a>），再拦截应用容器的出站（outbound）流量经过 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 处理（通过 15001 端口监听）后再出站。关于 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中端口用途请参考 <a href="https://istio.io/zh/docs/ops/deployment/requirements/" target="_blank" rel="external nofollow noopener noreferrer">Istio 官方文档</a>。</p><p><strong>命令解析</strong></p><p>这条启动命令的作用是：</p><ul><li>将应用容器的所有流量都转发到 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 的 15006 端口。</li><li>使用 <code>istio-proxy</code> 用户身份运行， UID 为 1337，即 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 所处的用户空间，这也是 <code>istio-proxy</code> 容器默认使用的用户，见 YAML 配置中的 <code>runAsUser</code> 字段。</li><li>使用默认的 <code>REDIRECT</code> 模式来重定向流量。</li><li>将所有出站流量都重定向到 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 代理（通过 15001 端口）。</li></ul><p>因为 Init 容器初始化完毕后就会自动终止，因为我们无法登陆到容器中查看 iptables 信息，但是 Init 容器初始化结果会保留到应用容器和 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 容器中。</p><h2 id="iptables-注入解析"><a href="#iptables-注入解析" class="headerlink" title="iptables 注入解析"></a>iptables 注入解析</h2><p>为了查看 iptables 配置，我们需要登陆到 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 容器中使用 root 用户来查看，因为 <code>kubectl</code> 无法使用特权模式来远程操作 docker 容器，所以我们需要登陆到 <code>productpage</code> <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">pod</a> 所在的主机上使用 <code>docker</code> 命令登陆容器中查看。</p><p>如果您使用 minikube 部署的 Kubernetes，可以直接登录到 minikube 的虚拟机中并切换为 root 用户。查看 iptables 配置，列出 NAT（网络地址转换）表的所有规则，因为在 Init 容器启动的时候选择给 <code>istio-iptables</code> 传递的参数中指定将入站流量重定向到 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 的模式为 <code>REDIRECT</code>，因此在 iptables 中将只有 NAT 表的规格配置，如果选择 <code>TPROXY</code> 还会有 <code>mangle</code> 表配置。<code>iptables</code> 命令的详细用法请参考 <a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="external nofollow noopener noreferrer">iptables</a>，规则配置请参考 <a href="http://www.zsythink.net/archives/1517" target="_blank" rel="external nofollow noopener noreferrer">iptables 规则配置</a>。</p><p>我们仅查看与 <code>productpage</code> 有关的 iptables 规则如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 minikube 并切换为 root 用户，minikube 默认用户为 docker</span></span><br><span class="line">$ minikube ssh</span><br><span class="line">$ sudo -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 productpage pod 的 istio-proxy 容器中的进程</span></span><br><span class="line">$ docker top `docker ps|grep <span class="string">"istio-proxy_productpage"</span>|cut -d <span class="string">" "</span> -f1`</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">1337                10576               10517               0                   08:09               ?                   00:00:07            /usr/<span class="built_in">local</span>/bin/pilot-agent proxy sidecar --domain default.svc.cluster.local --configPath /etc/istio/proxy --binaryPath /usr/<span class="built_in">local</span>/bin/envoy --serviceCluster productpage.default --drainDuration 45s --parentShutdownDuration 1m0s --discoveryAddress istiod.istio-system.svc:15012 --zipkinAddress zipkin.istio-system:9411 --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --connectTimeout 10s --proxyAdminPort 15000 --concurrency 2 --controlPlaneAuthPolicy NONE --dnsRefreshRate 300s --statusPort 15020 --trust-domain=cluster.local --controlPlaneBootstrap=<span class="literal">false</span></span><br><span class="line">1337                10660               10576               0                   08:09               ?                   00:00:33            /usr/<span class="built_in">local</span>/bin/envoy -c /etc/istio/proxy/envoy-rev0.json --restart-epoch 0 --drain-time<span class="_">-s</span> 45 --parent-shutdown-time<span class="_">-s</span> 60 --service-cluster productpage.default --service-node sidecar~172.17.0.16~productpage-v1-7f44c4d57c-ksf9b.default~default.svc.cluster.local --max-obj-name-len 189 --<span class="built_in">local</span>-address-ip-version v4 --<span class="built_in">log</span>-format [Envoy (Epoch 0)] [%Y-%m-%d %T.%e][%t][%l][%n] %v -l warning --component-log-level misc:error --concurrency 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 nsenter 进入 sidecar 容器的命名空间（以上任何一个都可以）</span></span><br><span class="line">$ nsenter -n --target 10660</span><br></pre></td></tr></table></figure><p>在该进程的命名空间下查看其 iptables 规则链。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 NAT 表中规则配置的详细信息。</span></span><br><span class="line">$ iptables -t nat -L -v</span><br><span class="line"><span class="comment"># PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上。</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 2701 packets, 162K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 2701  162K ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链。</span></span><br><span class="line">Chain INPUT (policy ACCEPT 2701 packets, 162K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上。</span></span><br><span class="line">Chain OUTPUT (policy ACCEPT 79 packets, 6761 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">   15   900 ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># POSTROUTING 链：所有数据包流出网卡时都要先进入POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理。</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 79 packets, 6761 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_INBOUND 链：将所有入站流量重定向到 ISTIO_IN_REDIRECT 链上，目的地为 15090（mixer 使用）和 15020（Ingress gateway 使用，用于 Pilot 健康检查）端口的流量除外，发送到以上两个端口的流量将返回 iptables 规则链的调用点，即 PREROUTING 链的后继 POSTROUTING。</span></span><br><span class="line">Chain ISTIO_INBOUND (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">    2   120 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090</span><br><span class="line"> 2699  162K RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 sidecar 中。</span></span><br><span class="line">Chain ISTIO_IN_REDIRECT (3 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_OUTPUT 链：选择需要重定向到 Envoy（即本地） 的出站流量，所有非 localhost 的流量全部转发到 ISTIO_REDIRECT。为了避免流量在该 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 ISTIO_OUTPUT 规则之后就进入下一条链 POSTROUTING。如果目的地非 localhost 就跳转到 ISTIO_REDIRECT；如果流量是来自 istio-proxy 用户空间的，那么就跳出该链，返回它的调用链继续执行下一条规则（OUTPUT 的下一条规则，无需对流量进行处理）；所有的非 istio-proxy 用户空间的目的地是 localhost 的流量就跳转到 ISTIO_REDIRECT。</span></span><br><span class="line">Chain ISTIO_OUTPUT (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 RETURN     all  --  any    lo      127.0.0.6            anywhere</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337</span><br><span class="line">   15   900 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             localhost</span><br><span class="line">    0     0 ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line"><span class="comment"># ISTIO_REDIRECT 链：将所有流量重定向到 Sidecar（即本地） 的 15001 端口。</span></span><br><span class="line">Chain ISTIO_REDIRECT (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001</span><br></pre></td></tr></table></figure><p>下图展示的是 <code>productpage</code> 服务请求访问 <code>http://reviews.default.svc.cluster.local:9080/</code>，当流量进入 <code>reviews</code> 服务内部时，<code>reviews</code> 服务内部的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> proxy 是如何做流量拦截和路由转发的。</p><p><a href="https://www.servicemesher.com/istio-handbook/images/envoy-sidecar-traffic-interception.png" target="_blank" rel="external nofollow noopener noreferrer"><img alt="Sidecar 流量劫持示意图" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/envoy-sidecar-traffic-interception.png"></a>图 2.3.2.1.2：<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 流量劫持示意图</p><p>第一步开始时，<code>productpage</code> <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a> 中的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 已经通过 EDS 选择出了要请求的 <code>reviews</code> 服务的一个 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pod" target="_blank" rel="external nofollow noopener noreferrer">Pod</a>，知晓了其 IP 地址，发送 TCP 连接请求。</p><p><code>reviews</code> 服务有三个版本，每个版本有一个实例，三个版本中的 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 工作步骤类似，关于 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> proxy 是如何做流量路由的请参阅本书流量路由章节。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节使用了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 官方提供的 bookinfo 示例，按图索骥得带领读者了解了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 注入、iptables 透明流量劫持背后的实现细节。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">Sidecar</a> 模式和流量透明劫持是 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 服务网格的特色和基础功能，理解该功能的背后过程及实现细节，将有助于大家理解 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#service-mesh" target="_blank" rel="external nofollow noopener noreferrer">service mesh</a> 的原理和本书后面章节中的内容，因此希望读者可以在自己的环境中从头来试验一遍以加深理解。</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://istio.io/docs/ops/diagnostic-tools/proxy-cmd/" target="_blank" rel="external nofollow noopener noreferrer">Debugging Envoy and Istiod</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲解 Istio 如何将 Envoy 代理注入到应用程序 Pod 中之前，我们需要先了解以下几个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sidecar 模式：容器应用模式之一，Service Mesh 架构的一种实现方式。&lt;/li&gt;
&lt;li&gt;Init 容器：Pod 中的一种专用的容器，在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。&lt;/li&gt;
&lt;li&gt;iptables：流量劫持是通过 iptables 转发实现的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/006y8mN6ly1g81hmkxqxaj30va0qg758.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="sidecar" scheme="http://houmin.cc/tags/sidecar/"/>
    
      <category term="iptables" scheme="http://houmin.cc/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Sidecar Hot Restart</title>
    <link href="http://houmin.cc/posts/dc2ceb3/"/>
    <id>http://houmin.cc/posts/dc2ceb3/</id>
    <published>2020-11-26T07:25:42.000Z</published>
    <updated>2020-12-15T11:35:01.273Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Service Mesh 中 Sidecar 运维一直是一个比较棘手的问题，数据平面的 Sidecar 升级是常有的事情，如何在升级 Sidecar（MOSN）的时候而不影响业务，对于存量的长连接如何迁移，本文将为你介绍 MOSN 的解决之道。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文介绍 MOSN 支持平滑升级的原因和解决方案，对于平滑升级的一些基础概念，大家可以通过 <a href="https://ms2008.github.io/2019/12/28/hot-upgrade/" target="_blank" rel="external nofollow noopener noreferrer">Nginx vs Enovy vs Mosn 平滑升级原理解析</a>了解。</p><p>先简单介绍一下为什么 Nginx 和 Envoy 不需要具备 MOSN 这样的连接无损迁移方案，主要还是跟业务场景相关，Nginx 和 Envoy 主要支持的是 HTTP1 和 HTTP2 协议，HTTP1使用 connection: Close，HTTP2 使用 Goaway Frame 都可以让 Client 端主动断链接，然后新建链接到新的 New process，但是针对 Dubbo、SOFA PRC 等常见的多路复用协议，它们是没有控制帧，Old process 的链接如果断了就会影响请求的。</p><p>一般的升级做法就是切走应用的流量，比如自己UnPub掉服务，等待一段时间没有请求之后，升级MOSN，升级好之后再Pub服务，整个过程比较耗时，并且会有一段时间是不提供服务的，还要考虑应用的水位，在大规模场景下，就很难兼顾评估。MOSN 为了满足自身业务场景，开发了长连接迁移方案，把这条链接迁移到 New process 上，整个过程对 Client 透明，不需要重新建链接，达到请求无损的平滑升级。</p><p><img alt="MOSN 的请求无损的平滑升级过程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/reqeust-smooth-upgrade-process.png"></p><h2 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h2><p><img alt="正常流程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/normal-process.png"></p><ol><li>Client 发送请求 Request 到 MOSN</li><li>MOSN 转发请求 Request 到 Server</li><li>Server 回复响应 Response 到 MOSN</li><li>MOSN 回复响应 Response 到 Client</li></ol><p>上图简单介绍了一个请求的正常流程，我们后面需要迁移的是 TCP1 链接，也就是 Client 到 MOSN 的连接，MOSN 到 Server 的链接 TCP2 不需要迁移，因为 MOSN 访问 Server 是根据 LoadBalance 选择，我们可以主动控制断链建链。</p><h2 id="平滑升级流程"><a href="#平滑升级流程" class="headerlink" title="平滑升级流程"></a>平滑升级流程</h2><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>有两个方式可以触发平滑升级流程：</p><ol><li>MOSN 对 SIGHUP 做了监听，发送 SIGHUP 信号给 MOSN 进程，通过 ForkExec 生成一个新的 MOSN 进程。</li><li>直接重新启动一个新 MOSN 进程。</li></ol><p>为什么提供两种方式？最开始我们支持的是方法1，也就是 nginx 和 Envoy 使用的方式，这个在虚拟机或者容器内替换 MOSN 二级制来升级是可行的，但是我们的场景需要满足容器间的升级，所以需要新拉起一个容器，就需要重新启动一个新的 MOSN 进程来做平滑升级，所以后续又支持了方法2。容器间升级还需要 operator 的支持，本文不展开叙述。</p><h3 id="交互流程"><a href="#交互流程" class="headerlink" title="交互流程"></a>交互流程</h3><p><img alt="交互流程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/interaction-process.png"></p><p><img alt="交互流程时序图" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/interaction-process-timeline.png"></p><p>首先，老的 MOSN 在启动最后阶段会启动一个协程运行 <code>ReconfigureHandler()</code> 函数监听一个 Domain Socket（<code>reconfig.sock</code>）, 该接口的作用是让新的 MOSN 来感知是否存在老的 MOSN。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReconfigureHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">"unix"</span>, types.ReconfigureDomainSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        uc, err := ul.AcceptUnix()</span><br><span class="line">        _, err = uc.Write([]<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;)</span><br><span class="line">        reconfigure(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发平滑升级流程的两种方式最终都是启动一个新的 MOSN 进程，然后调用<code>GetInheritListeners()</code>，通过 <code>isReconfigure()</code> 函数来判断本机是否存在一个老的 MOSN（就是判断是否存在 <code>reconfig.sock</code> 监听），如果存在一个老的 MOSN，就进入迁移流程，反之就是正常的启动流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留了核心流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInheritListeners</span><span class="params">()</span> <span class="params">([]net.Listener, net.Conn, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !isReconfigure() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l, err := net.Listen(<span class="string">"unix"</span>, types.TransferListenDomainSocket)</span><br><span class="line">    uc, err := ul.AcceptUnix()</span><br><span class="line">    _, oobn, _, _, err := uc.ReadMsgUnix(buf, oob)</span><br><span class="line">    file := os.NewFile(fd, <span class="string">""</span>)</span><br><span class="line">    fileListener, err := net.FileListener(file)</span><br><span class="line">    <span class="keyword">return</span> listeners, uc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果进入迁移流程，新的 MOSN 将监听一个新的 Domain Socket（<code>listen.sock</code>），用于老的 MOSN 传递 listen FD 到新的 MOSN。FD 的传递使用了sendMsg 和 recvMsg。在收到 listen FD 之后，调用 <code>net.FileListener()</code> 函数生产一个 Listener。此时，新老 MOSN 都同时拥有了相同的 Listen 套接字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileListener returns a copy of the network listener corresponding</span></span><br><span class="line"><span class="comment">// to the open file f.</span></span><br><span class="line"><span class="comment">// It is the caller's responsibility to close ln when finished.</span></span><br><span class="line"><span class="comment">// Closing ln does not affect f, and closing f does not affect ln.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileListener</span><span class="params">(f *os.File)</span> <span class="params">(ln Listener, err error)</span></span> &#123;</span><br><span class="line">    ln, err = fileListener(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = &amp;OpError&#123;Op: <span class="string">"file"</span>, Net: <span class="string">"file+net"</span>, Source: <span class="literal">nil</span>, Addr: fileAddr(f.Name()), Err: err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的迁移和 Nginx 还是有一些区别，Nginx 是 fork 的方式，子进程自动就继承了 listen FD，MOSN 是新启动的进程，不存在父子关系，所以需要通过 sendMsg 的方式来传递。</p><p>在进入迁移流程和 Listen 的迁移过程中，一共使用了两个 Domain Socket：</p><ul><li><code>reconfig.sock</code> 是 Old MOSN 监听，用于 New MOSN 来判断是否存在</li><li><code>listen.sock</code> 是 New MOSN 监听，用于 Old MOSN 传递 listen FD</li></ul><p>两个 sock 其实是可以复用的，也可以用 <code>reconfig.sock</code> 进行 listen 的传递，由于一些历史原因搞了两个，后续可以优化为一个，让代码更精简易读。</p><p>这儿再看看 Old MOSN 的处理，在收到 New MOSN 的通知之后，将进入<code>reconfigure(false)</code> 流程，首先就是调用 <code>sendInheritListeners()</code> 传递 listen FD，原因上面内容已经描述，最后调用 <code>WaitConnectionsDone()</code> 进入存量长链接的迁移流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留了核心流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconfigure</span><span class="params">(start <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> start &#123;</span><br><span class="line">        startNewMosn()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// transfer listen fd</span></span><br><span class="line">    <span class="keyword">if</span> notify, err = sendInheritListeners(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Wait for all connections to be finished</span></span><br><span class="line">    WaitConnectionsDone(GracefulTimeout)</span><br><span class="line"></span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Listen FD 迁移之后，New MOSN 通过配置启动，然后在最后启动一个协程运行<code>TransferServer()</code>，将监听一个新的 <code>DomainSocket（conn.sock）</code>，用于后续接收 Old MOSN 的长连接迁移。迁移的函数是 <code>transferHandler()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TransferServer</span><span class="params">(handler types.ConnectionHandler)</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">"unix"</span>, types.TransferConnDomainSocket)</span><br><span class="line"></span><br><span class="line">    utils.GoWithRecover(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            c, err := l.Accept()</span><br><span class="line">            <span class="keyword">go</span> transferHandler(c, handler, &amp;transferMap)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Old MOSN 将通过 <code>transferRead()</code> 和 <code>transferWrite()</code> 进入最后的长链接迁移流程，下面主要分析这块内容。</p><h3 id="长连接迁移流程"><a href="#长连接迁移流程" class="headerlink" title="长连接迁移流程"></a>长连接迁移流程</h3><p><img alt="长连接迁移过程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/long-connection-migrating-process.png"></p><p>首先先粗略看一下新请求的迁移流程。</p><ol><li>Client 发送请求到 MOSN</li><li>MOSN 通过 domain socket(conn.sock) 把 TCP1 的 FD 和连接的状态数据发送给 New MOSN</li><li>New MOSN 接受 FD 和请求数据创建新的 Conection 结构，然后把 Connection id 传给 MOSN，New MOSN 此时就拥有了 TCP1 的一个拷贝。</li><li>New MOSN 通过 LB 选取一个新的 Server，建立 TCP3 连接，转发请求到 Server</li><li>Server 回复响应到 New MOSN</li><li>New MOSN 通过 MOSN 传递来的 TCP1 的拷贝，回复响应到 Client</li></ol><p>之前的 <code>WaitConnectionsDone()</code> 函数中，<code>s.stopChan</code> 已经关闭，在链接的 ReadLoop 中，将设置一个 <code>[TransferTimeout, 2 * TransferTimeout]</code> 的随机时间进入迁移流程，随机数主要是为了打散每个 Client 的 TCP 连接迁移时机，让迁移更平滑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span> <span class="title">startReadLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> transferTime time.Time</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.stopChan:</span><br><span class="line">            <span class="keyword">if</span> transferTime.IsZero() &#123;</span><br><span class="line">                <span class="keyword">if</span> c.transferCallbacks != <span class="literal">nil</span> &amp;&amp; c.transferCallbacks() &#123;</span><br><span class="line">                    randTime := time.Duration(rand.Intn(<span class="keyword">int</span>(TransferTimeout.Nanoseconds())))</span><br><span class="line">                    transferTime = time.Now().Add(TransferTimeout).Add(randTime)</span><br><span class="line">                    log.DefaultLogger.Infof(<span class="string">"[network] [read loop] transferTime: Wait %d Second"</span>, (TransferTimeout+randTime)/<span class="number">1e9</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// set a long time, not transfer connection, wait mosn exit.</span></span><br><span class="line">                    transferTime = time.Now().Add(<span class="number">10</span> * TransferTimeout)</span><br><span class="line">                    log.DefaultLogger.Infof(<span class="string">"[network] [read loop] not support transfer connection, Connection = %d, Local Address = %+v, Remote Address = %+v"</span>,</span><br><span class="line">                        c.id, c.rawConnection.LocalAddr(), c.RemoteAddr())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> transferTime.Before(time.Now()) &#123;</span><br><span class="line">                    c.transfer()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>在等待一个随机时间之后，<code>c.tranfer()</code> 将进入迁移流程，<code>c.notifyTransfer()</code> 的作用是暂停 write 操作，在迁移 read 操作的时候，不能有 write 操作，因为两个进程 MOSN 同时都做 write，会导致数据错乱。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *connection)</span> <span class="title">transfer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.notifyTransfer()</span><br><span class="line">    id, _ := transferRead(c)</span><br><span class="line">    c.transferWrite(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入的是 <code>transferRead()</code>，这个函数的作用就是把连接的 FD 和状态数据通过 <code>conn.sock</code>传递给 New MOSN，跟之前迁移 Listen FD 时方式一样，NEW MOSN 在成功处理之后会返回一个 ID，这个 ID 是 NEW MOSN 新建立的 Connection ID，这个 ID 后面会用到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old mosn transfer readloop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transferRead</span><span class="params">(c *connection)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">    unixConn, err := net.Dial(<span class="string">"unix"</span>, types.TransferConnDomainSocket)</span><br><span class="line"></span><br><span class="line">    file, tlsConn, err := transferGetFile(c)</span><br><span class="line"></span><br><span class="line">    uc := unixConn.(*net.UnixConn)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// send type and TCP FD</span></span><br><span class="line">    err = transferSendType(uc, file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// send header + buffer + TLS</span></span><br><span class="line">    err = transferReadSendData(uc, tlsConn, c.readBuffer, log.DefaultLogger)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// recv ID</span></span><br><span class="line">    id := transferRecvID(uc)</span><br><span class="line">    <span class="keyword">return</span> id, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造了一个简单的读迁移协议, 主要包括了 TCP 原始数据长度，TLS 数据长度，TCP 原始数据，TLS 数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  transfer read protocol</span></span><br><span class="line"><span class="comment"> *  header (8 bytes) + (readBuffer data) + TLS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0                       4                       8</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * |      data length      |     TLS length        |</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * |                     data                      |</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * |                     TLS                       |</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure><p>现在看下 New MOSN 收到迁移请求之后的处理，它会针对每个迁移请求会启动一个协程运行 <code>transferHandler()</code> 函数, 函数会根据读取的协议判断是读迁移还是写迁移，我们这儿先介绍读迁移，New MOSN 会调用 transferNewConn 把 Old MOSN 传递过来的 FD 和数据包重新生成一个新的 Connection 结构体，并把生成的新的 connection ID 传递给 Old MOSN。</p><p>此后，New MOSN 将从该 TCP 连接读取数据，开始正常的业务请求流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transferHandler</span><span class="params">(c net.Conn, handler types.ConnectionHandler, transferMap *sync.Map)</span></span> &#123;</span><br><span class="line">    <span class="comment">// recv type</span></span><br><span class="line">    conn, err := transferRecvType(uc)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.DefaultLogger.Errorf(<span class="string">"[network] [transfer] [handler] transferRecvType error :%v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> conn != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// transfer read</span></span><br><span class="line">        <span class="comment">// recv header + buffer</span></span><br><span class="line">        dataBuf, tlsBuf, err := transferReadRecvData(uc)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.DefaultLogger.Errorf(<span class="string">"[network] [transfer] [handler] transferRecvData error :%v"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        connection := transferNewConn(conn, dataBuf, tlsBuf, handler, transferMap)</span><br><span class="line">        <span class="keyword">if</span> connection != <span class="literal">nil</span> &#123;</span><br><span class="line">            transferSendID(uc, connection.id)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transferSendID(uc, transferErr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// transfer write</span></span><br><span class="line">        <span class="comment">// recv header + buffer</span></span><br><span class="line">        id, buf, err := transferWriteRecvData(uc)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.DefaultLogger.Errorf(<span class="string">"[network] [transfer] [handler] transferRecvData error :%v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        connection := transferFindConnection(transferMap, <span class="keyword">uint64</span>(id))</span><br><span class="line">        <span class="keyword">if</span> connection == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.DefaultLogger.Errorf(<span class="string">"[network] [transfer] [handler] transferFindConnection failed, id = %d"</span>, id)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        err = transferWriteBuffer(connection, buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.DefaultLogger.Errorf(<span class="string">"[network] [transfer] [handler] transferWriteBuffer error :%v"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，Old MOSN 不再读取该 TCP1 连接上的数据，全部由 New MOSN 来读取 TCP1 上的数据并处理，对于新的请求，整个迁移过程就已经完成。</p><h3 id="残留响应迁移流程"><a href="#残留响应迁移流程" class="headerlink" title="残留响应迁移流程"></a>残留响应迁移流程</h3><p><img alt="残留响应迁移过程" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/remaining-responses-migrating-process.png"></p><p>大家想想为什么还有残留响应的迁移流程？因为多路复用协议，在之前读连接迁移流程的时候，TCP2 上还有之前残留的响应需要回复给Client，如果同时 MOSN 和 New MOSN 都进行 Write 操作 TCP1，数据可能会乱序，所以需要让New MOSN来统一处理之前 TCP2 上残留的响应。</p><ol><li>Server 回复残留的响应到 MOSN</li><li>MOSN 把之前从 New MOSN 获取的 Connection id 和响应数据，通过 domain socket(conn.sock) 传递给 New MOSN</li><li>New MOSN 通过 id 查询 TCP1 连接，回复响应到 Client</li></ol><p>在 <code>transferRead()</code> 之后，就进入了 <code>transferWrite()</code> 阶段，该阶段会把需要 write 的数据包和之前 New MOSN 传回来的 Connection ID 一并传给 New MOSN。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old mosn transfer writeloop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transferWrite</span><span class="params">(c *connection, id <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    unixConn, err := net.Dial(<span class="string">"unix"</span>, types.TransferConnDomainSocket)</span><br><span class="line"></span><br><span class="line">    uc := unixConn.(*net.UnixConn)</span><br><span class="line">    err = transferSendType(uc, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build net.Buffers to IoBuffer</span></span><br><span class="line">    buf := transferBuildIoBuffer(c)</span><br><span class="line">    <span class="comment">// send header + buffer</span></span><br><span class="line">    err = transferWriteSendData(uc, <span class="keyword">int</span>(id), buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.DefaultLogger.Errorf(<span class="string">"[network] [transfer] [write] transferWrite failed: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造了一个简单的写迁移协议, 主要包括了TCP原始数据长度, connection ID，TCP原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  transfer write protocol</span></span><br><span class="line"><span class="comment"> *  header (8 bytes) + (writeBuffer data)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0                       4                       8</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * |      data length      |    connection  ID     |</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * |                     data                      |</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+-----+-----+-----+-----+-----+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>在New MOSN的transferHandler()函数中，会判断出写迁移协议，然后 <code>transferFindConnection()</code> 函数通过 connection ID 找到 TCP1 连接，然后直接把数据写入即可。</p><p>这儿需要说明一点，新请求Request的转发已经使用了 TCP3，TCP2 上只会有之前请求的 Response 响应，如果在整个迁移期间 2 * TransferTimeout 都没有回复响应，那么这个请求将会超时失败。</p><h3 id="连接状态数据"><a href="#连接状态数据" class="headerlink" title="连接状态数据"></a>连接状态数据</h3><p>在连接迁移时，除了TCP FD的迁移，还有连接状态的迁移，这样New MOSN才知道怎样去初始化这个新的连接。</p><p>主要有如下几个状态：</p><p><strong>读缓存</strong></p><p>表示在迁移时，已经从 TCP 读取的数据，还没有被应用层处理的数据。</p><p><strong>写数据</strong></p><p>在迁移之后，MOSN 收到的响应数据。</p><p><strong>TLS状态迁移</strong></p><p>如果是 TLS 加密请求，需要迁移 TLS 的状态，有如下状态需要迁移：</p><ol><li>加密秘钥</li><li>Seq序列</li><li>读缓存数据（加密和未加密）</li><li>cipher类型</li><li>TLS版本</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TransferTLSInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Vers         <span class="keyword">uint16</span></span><br><span class="line">    CipherSuite  <span class="keyword">uint16</span></span><br><span class="line">    MasterSecret []<span class="keyword">byte</span></span><br><span class="line">    ClientRandom []<span class="keyword">byte</span></span><br><span class="line">    ServerRandom []<span class="keyword">byte</span></span><br><span class="line">    InSeq        [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    OutSeq       [<span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line">    RawInput     []<span class="keyword">byte</span></span><br><span class="line">    Input        []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>长连接的 FD 迁移是比较常规的操作，sendMsg 和 connection repair 都可以。</p><p>在整个过程中最麻烦的是应用层数据的迁移，一般想法就是把应用层的数据结构等都迁移到新的进程，比如已经读取的协议 HEAD 等结构体，但这就导致你的迁移过程会很复杂，每个协议都需要单独处理。</p><p>MOSN 的方案是把迁移放到了 IO 层，不关心应用层具体是什么协议，我们迁移最原始的 TCP 数据包，然后让 New MOSN 来 codec 这个数据包来拼装 HEAD 等结构体，这个过程是标准的处理流程了，这样就保证迁移对整个协议解析是透明的，只要这个协议是无状态的，这个迁移框架就可以自动支持。</p><p>最后的残留响应迁移流程可能不太好理解，为什么不等所有响应完成之后才开始迁移，就不需要这个流程了？是因为在多路复用协议场景下，请求一直在发送，你不能总是找到一个时间点所有响应都完成了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mosn.io/docs/concept/smooth-upgrade/" target="_blank" rel="external nofollow noopener noreferrer">https://mosn.io/docs/concept/smooth-upgrade/</a></li><li><a href="https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5" target="_blank" rel="external nofollow noopener noreferrer">https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5</a></li><li><a href="https://segmentfault.com/a/1190000018182418" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000018182418</a></li><li><a href="https://mp.weixin.qq.com/s/lo23CB0Ibp2VEkBT_VgPsg" target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/lo23CB0Ibp2VEkBT_VgPsg</a></li><li><a href="https://iwiki.woa.com/pages/viewpage.action?pageId=310748830" target="_blank" rel="external nofollow noopener noreferrer">https://iwiki.woa.com/pages/viewpage.action?pageId=310748830</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Service Mesh 中 Sidecar 运维一直是一个比较棘手的问题，数据平面的 Sidecar 升级是常有的事情，如何在升级 Sidecar（MOSN）的时候而不影响业务，对于存量的长连接如何迁移，本文将为你介绍 MOSN 的解决之道。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/interaction-process.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="sidecar" scheme="http://houmin.cc/tags/sidecar/"/>
    
      <category term="hot restart" scheme="http://houmin.cc/tags/hot-restart/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Envoy 入门</title>
    <link href="http://houmin.cc/posts/7beb34d2/"/>
    <id>http://houmin.cc/posts/7beb34d2/</id>
    <published>2020-11-25T04:15:08.000Z</published>
    <updated>2020-12-15T11:25:17.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Envoy</code> 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 <code>Envoy</code>没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，<code>Envoy</code>也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。</p><a id="more"></a><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img alt="Envoy Architecture" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p><p>首先介绍Envoy中的一些基本概念：</p><ul><li>Downstream：下游主机，指连接到Envoy的主机，这些主机用来发送请求并接受响应。</li><li>Upstream：上游主机，指接收来自Envoy连接和请求的主机，并返回响应。</li><li>Listener：服务或程序的监听器， Envoy暴露一个或多个监听器监听下游主机的请求，当监听到请求时，通过Filter Chain把对请求的处理全部抽象为Filter， 例如ReadFilter、WriteFilter、HttpFilter等。</li><li>Cluster：服务提供集群，指Envoy连接的一组逻辑相同的上游主机。Envoy通过服务发现功能来发现集群内的成员，通过负载均衡功能将流量路由到集群的各个成员。</li><li>xDS：xDS中的x是一个代词，类似云计算里的XaaS可以指代IaaS、PaaS、SaaS等。DS为Discovery Service，即发现服务的意思。xDS包括CDS（cluster discovery service）、RDS（route discovery service）、EDS（endpoint discovery service）、ADS（aggregated discovery service），其中ADS称为聚合的发现服务，是对CDS、RDS、LDS、EDS服务的统一封装，解决CDS、RDS、LDS、EDS信息更新顺序依赖的问题，从而保证以一定的顺序同步各类配置信息。以上Endpoint、Cluster、Route的概念介绍如下：<ul><li>Endpoint：一个具体的“应用实例”，类似于Kubernetes中的一个Pod；</li><li>Cluster：可以理解“应用集群”，对应提供相同服务的一个或多个Endpoint， 类似Kubernetes中Service概念，即一个Service提供多个相同服务的Pod；</li><li>Route：当我们做金丝雀发布部署时，同一个服务会有多个版本，这时需要Route规则规定请求如何路由到其中的某个版本上。</li></ul></li></ul><p>xDS模块的功能是通过Envoy API V1（基于HTTP）或V2（基于gRPC）实现一个服务端将配置信息暴露给上游主机，等待上游主机的拉取。</p><p>Envoy正常的工作流程为Host A（下游主机）发送请求至上游主机（Host B、Host C、Host D等），Envoy通过Listener监听到有下游主机的请求，收到请求后的Envoy将所有请求流量劫持至Envoy内部，并将请求内容抽象为Filter Chains路由至某个上游主机中从而实现路由转发及负载均衡能力。</p><p>Envoy为了实现流量代理能力通常需要一个统一的配置文件来记录信息以便启动时加载，在Envoy中启动配置文件有静态配置和动态配置两种方式。静态配置是将配置信息写入文件中，启动时直接加载，动态配置通过xDS实现一个Envoy的服务端（可以理解为以API接口对外实现服务发现能力）。</p><h3 id="Network-Topology"><a href="#Network-Topology" class="headerlink" title="Network Topology"></a>Network Topology</h3><p>Envoy作为Service Mesh中的 sidecar 代理，请求可以通过 ingress 或者 egress listener 到达 envoy。</p><ul><li>Ingress Listener 负责从服务网格中其他节点接受请求，并将请求转发到本地应用。本地应用的响应之后通过 Envoy 转发到 downstream。</li><li>Egress Listener 负责从本地应用接受请求，并将请求转发到服务网格中的其他节点。</li></ul><p><img alt="Service Mesh" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-service-mesh.svg"></p><p>除了服务网格外，Envoy还可以用作很多其他的请求，比如作为内部的负载均衡器：</p><p><img alt="Internal Load Balancer" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-ilb.svg"></p><p>或者作为网络边缘的 <code>ingress/egress</code> 代理：</p><p><img alt="Ingress/Egress Proxy on Network Edge" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-edge.svg"></p><p>在实际应用中，Envoy一般会发挥上述多种功能，一个网络请求路径中可能会通过多个Envoy：</p><p><img alt="Hybrid Envoy" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-hybrid.svg"></p><p>为了可靠性和可扩充性，Envoy可能会被配置成多层拓扑的形式：</p><p><img alt="Envoy Tiered" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-topology-tiered.svg"></p><h3 id="High-Level-Architecture"><a href="#High-Level-Architecture" class="headerlink" title="High Level Architecture"></a>High Level Architecture</h3><p>Envoy中服务请求处理过程可以大致分为两个部分：</p><ul><li>Listener 子系统：处理来自 downstream 的请求。</li><li>Cluster 子系统：负责选择和配置 upstream 连接。</li></ul><p><img alt="High Level Architecture" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-architecture.svg"></p><p>Envoy采用了基于事件的线程模型：</p><ul><li>一个主线程负责server的生命周期，配置处理，统计等</li><li>多个worker线程负责处理请求。</li></ul><p>所有的线程都运行在一个基于 <a href="https://libevent.org/" target="_blank" rel="external nofollow noopener noreferrer">libevent</a> 的事件循环中，任何 downstream 的 TCP连接都会被分配一个 work 线程来处理</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Envoy 进程中运行着一系列 <code>Inbound/Outbound</code> 监听器（Listener），<code>Inbound</code> 代理入站流量，<code>Outbound</code> 代理出站流量。Listener 的核心就是过滤器链（FilterChain），链中每个过滤器都能够控制流量的处理流程。过滤器链中的过滤器分为两个类别：</p><ul><li><strong>网络过滤器</strong>（Network Filters）: 工作在 <code>L3/L4</code>，是 Envoy 网络连接处理的核心，处理的是原始字节，分为 <code>Read</code>、<code>Write</code> 和 <code>Read/Write</code> 三类。</li><li><strong>HTTP 过滤器</strong>（HTTP Filters）: 工作在 <code>L7</code>，由特殊的网络过滤器 <code>HTTP connection manager</code> 管理，专门处理 <code>HTTP1/HTTP2/gRPC</code> 请求。它将原始字节转换成 <code>HTTP</code> 格式，从而可以对 <code>HTTP</code> 协议进行精确控制。</li></ul><p>除了 <code>HTTP connection manager</code> 之外，还有一种特别的网络过滤器叫 <code>Thrift Proxy</code>。<code>Thrift</code> 是一套包含序列化功能和支持服务通信的 RPC 框架，详情参考<a href="https://zh.wikipedia.org/wiki/Thrift" target="_blank" rel="external nofollow noopener noreferrer">维基百科</a>。Thrift Proxy 管理了两个 Filter：<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/router_filter" target="_blank" rel="external nofollow noopener noreferrer">Router</a> 和 <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/other_protocols/thrift_filters/rate_limit_filter" target="_blank" rel="external nofollow noopener noreferrer">Rate Limit</a>。</p><p>除了过滤器链之外，还有一种过滤器叫<strong>监听器过滤器</strong>（Listener Filters），它会在过滤器链之前执行，用于操纵连接的<strong>元数据</strong>。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 <code>UDP</code> 时，就可以指定 UDP 监听器过滤器。根据上面的分类，Envoy 过滤器的架构如下图所示：</p><p><img alt="img" data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504224710.png"></p><h2 id="Request-Flow"><a href="#Request-Flow" class="headerlink" title="Request Flow"></a>Request Flow</h2><h3 id="Listener-TCP-Accept"><a href="#Listener-TCP-Accept" class="headerlink" title="Listener TCP Accept"></a>Listener TCP Accept</h3><p><img alt="Listener TCP Accept" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listeners.svg"></p><h3 id="Listener-filter-chains-and-network-filter-chain-matching"><a href="#Listener-filter-chains-and-network-filter-chain-matching" class="headerlink" title="Listener filter chains and network filter chain matching"></a>Listener filter chains and network filter chain matching</h3><p><img alt="Listener Filter Chains" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-listener-filters.svg"></p><p><img alt="../_images/lor-filter-chain-match.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-filter-chain-match.svg"></p><h3 id="TLS-transport-socket-decryption"><a href="#TLS-transport-socket-decryption" class="headerlink" title="TLS transport socket decryption"></a>TLS transport socket decryption</h3><p><img alt="../_images/lor-transport-socket.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-transport-socket.svg"></p><h3 id="Network-filter-chain-processing"><a href="#Network-filter-chain-processing" class="headerlink" title="Network filter chain processing"></a>Network filter chain processing</h3><p><img alt="../_images/lor-network-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-filters.svg"></p><p><img alt="../_images/lor-network-read.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-read.svg"></p><p><img alt="../_images/lor-network-write.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-network-write.svg"></p><h3 id="HTTP-2-codec-encoding"><a href="#HTTP-2-codec-encoding" class="headerlink" title="HTTP/2 codec encoding"></a>HTTP/2 codec encoding</h3><h3 id="TLS-transport-socket-encryption"><a href="#TLS-transport-socket-encryption" class="headerlink" title="TLS transport socket encryption"></a>TLS transport socket encryption</h3><p><img alt="../_images/lor-http-filters.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-filters.svg"></p><p><img alt="../_images/lor-http.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http.svg"></p><p><img alt="../_images/lor-http-decode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-decode.svg"></p><p><img alt="../_images/lor-http-encode.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-http-encode.svg"></p><p><img alt="../_images/lor-route-config.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-route-config.svg"></p><h3 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h3><p><img alt="../_images/lor-lb.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-lb.svg"></p><h3 id="Response-path-and-HTTP-lifecycle"><a href="#Response-path-and-HTTP-lifecycle" class="headerlink" title="Response path and HTTP lifecycle"></a>Response path and HTTP lifecycle</h3><p><img alt="../_images/lor-client.svg" data-src="https://www.envoyproxy.io/docs/envoy/latest/_images/lor-client.svg"></p><h3 id="Post-request-processing"><a href="#Post-request-processing" class="headerlink" title="Post-request processing"></a>Post-request processing</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.aliyun.com/article/606655" target="_blank" rel="external nofollow noopener noreferrer">https://developer.aliyun.com/article/606655</a></li><li><a href="https://www.cnblogs.com/popsuper1982/p/9841978.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/popsuper1982/p/9841978.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Envoy&lt;/code&gt; 是一款由 Lyft 开源的高性能数据和服务代理软件，使用现代 C++ 开发，提供四层和七层网络代理能力。尽管在设计之初 &lt;code&gt;Envoy&lt;/code&gt;没有将性能作为最终的目标，而是更加强调模块化、易测试、易开发等特性，可它仍旧拥有足可媲美 Nginx 等经典代理软件的超高性能。在保证性能的同时，&lt;code&gt;Envoy&lt;/code&gt;也提供了强大的流量治理能力和可观察性。其独创的 xDS 协议则成为了构建 Service Mesh 通用数据面 API（UPDA）的基石。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio 流量控制</title>
    <link href="http://houmin.cc/posts/151719f0/"/>
    <id>http://houmin.cc/posts/151719f0/</id>
    <published>2020-11-24T08:47:28.000Z</published>
    <updated>2020-12-02T11:40:50.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 <a href="../22cae0b8">Istio 入门</a> 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。</p><a id="more"></a><p><img alt="Istio Architecture" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h2 id="路由和流量转移"><a href="#路由和流量转移" class="headerlink" title="路由和流量转移"></a>路由和流量转移</h2><p>Istio 为了控制服务请求，引入了服务版本（version）的概念，可以通过版本这一标签将服务进行区分。版本的设置是非常灵活的，以下是几种典型的设置方式：</p><ul><li>根据服务的迭代编号进行定义（如 v1、v2 版本）</li><li>根据部署环境进行定义（比如 dev、staging、production）</li><li>自定义的任何用于区分服务的某种标记</li></ul><p>通过版本标签，Istio 就可以定义灵活的路由规则来控制流量，上面提到的金丝雀发布这类应用场景就很容易实现了。</p><p>下图展示了使用服务版本实现路由分配的例子。服务版本定义了版本号（v1.5、v2.0-alpha）和环境（us-prod、us-staging）两种信息。服务 B 包含了 4 个 Pod，其中 3 个是部署在生产环境的 v1.5 版本，而 Pod4 是部署在预生产环境的 v2.0-alpha 版本。运维人员可以根据服务版本来指定路由规则，使 99% 的流量流向 v1.5 版本，而 1% 的流量进入 v2.0-alpha 版本。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_istio-routing.png"></p><p>除了上面介绍的服务间流量控制外，还能控制与网格边界交互的流量。可以在系统的入口和出口处部署 Sidecar 代理，让所有流入和流出的流量都由代理进行转发。负责入和出的代理就叫做入口网关和出口网关，它们把守着进入和流出网格的流量。下图展示了 Ingress 和 Egress 在请求流中的位置，有了他们俩，也就可以控制出入网格的流量了。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_istio-gateway.png"></p><p>Istio 还能设置流量策略。比如可以对连接池相关的属性进行设置，通过修改最大连接等参数，实现对请求负载的控制。还可以对负载均衡策略进行设置，在轮询、随机、最少访问等方式之间进行切换。还能设置异常探测策略，将满足异常条件的实例从负载均衡池中摘除，以保证服务的稳定性。</p><hr><p>Istio 的流量路由规则可以让您很容易的控制服务之间的流量和 API 调用。Istio 在服务层面提供了断路器，超时，重试等功能，通过这些功能可以简单地实现 A/B 测试，金丝雀发布，基于百分比的流量分割等，此外还提供了开箱即用的故障恢复功能，用于增加应用的健壮性，以应对服务故障或网络故障。这些功能都可以通过 Istio 的流量管理 API 添加流量配置来实现。</p><p>跟其他 Istio 配置一样，流量管理 API 也使用 CRD 指定。本小节主要介绍下面几个典型的流量管理 API 资源，以及这些 API 的功能和使用示例。</p><h3 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h3><p>VirtualService 由一组 <strong>路由规则</strong> 组成，描述了 <strong>用户请求的目标地址</strong> 到 <strong>服务网格中实际工作负载</strong> 之间的映射。在这个映射中，VirtualService提供了丰富的配置方式，可以为发送到这些 Workloads 的流量指定不同的路由规则。对应于具体的配置，用户请求的目标地址用 <code>hosts</code> 字段来表示，网格内的实际负载由每个 <code>route</code> 配置项中的 <code>destination</code> 字段指定。</p><pre class="mermaid">graph LRsubgraph VirtualServiceClientRequests -- DifferentTrafficRoutingRules --> DestinationWorkloadsHosts -- DifferentTrafficRoutingRules --> RouteDestinationend</pre><p>VirtualService 通过解耦 <strong>用户请求的目标地址</strong> 和 <strong>真实响应请求的目标工作负载</strong>，为服务提供了合适的统一抽象层，而由此演化设计的配置模型为管理这方面提供了一致的环境。对于原生 Kubernetes 而言，只有在 Ingress 处有这种路由规则的定义，对于集群内部不同Service的不同版本之间，并没有类似 VirtualService 的定义。</p><p>使用 VirtualService，可以为一个或多个主机名指定流量行为。在 VirtualService 中使用路由规则，告诉 Envoy如何发送 VirtualService 的流量到适当的目标。路由目标可以是相同服务的不同版本，或者是完全不同的服务。</p><p>一个典型的应用场景是将流量发送到被指定为服务子集的服务的不同版本。客户端将 VirtualService 视为一个单一实体，将请求发送至 VirtualService 主机，然后 Envoy 根据 VirtualService 规则把流量路由到不同的版本中。</p><p>这种方式可以方便地创建一种金丝雀的发布策略实现新版本流量的平滑比重升级。流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。相比之下，类似 Kubernetes 的容器调度平台仅支持基于部署中实例扩缩容比重的流量分发，那样会日趋复杂化。关于使用VirtualService实现金丝雀部署，可以参考 <a href="https://istio.io/latest/blog/2017/0.1-canary/" target="_blank" rel="external nofollow noopener noreferrer">Canary</a> 。</p><p>VirtualService 也提供了如下功能。</p><ul><li>通过单个 VirtualService 处理多个应用程序服务。例如，如果您的服务网格使用是 Kubernetes，您可以配置一个 VirtualService 来处理一个特定命名空间的所有服务。将单一的 VirtualService 映射为多个“真实”的服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。您的路由规则可以指定“请求到 <code>monolith.com</code> 的 URLs 跳转至 <code>microservice A</code> 中”。</li><li>和 Gateway  一起配置流量规则来控制入口和出口流量。</li></ul><p>在一些应用场景中，由于指定服务子集，需要配置 DestinationRule 来使用这些功能。在不同的对象中指定服务子集以及其他特定的目标策略可以帮助您在不同的 VirtualService 中清晰地复用这些功能。</p><p>下面的 VirtualService 根据是否来自于特定用户路由请求到不同的服务版本中（如果请求来自用户 <code>jason</code> ，则访问 <code>v2</code> 版本的 <code>reviews</code>，否则访问 <code>v3</code> 版本）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>下面对这些字段依次解释：</p><h4 id="Hosts"><a href="#Hosts" class="headerlink" title="Hosts"></a>Hosts</h4><p>用来配置 Downstream 访问的可寻址地址，也就是用户请求的目标地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">reviews</span></span><br></pre></td></tr></table></figure><ul><li>VirtualService 主机名可以是 IP 地址、 DNS 域名、完全限定域名（FQDN)</li><li>也可以是 依赖于平台的一个简称（例如 Kubernetes 服务的短名称）</li><li>也可以使用通配符 <code>*</code>前缀，创建一组匹配所有服务的路由规则</li><li>VirtualService 的 <code>hosts</code> 实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址。这可以为没有路由到网格内部的虚拟主机建模。</li></ul><h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><p><code>http</code> 字段用来配置路由规则，通常情况下配置一组路由规则，当请求到来时，自上而下依次进行匹配，直到匹配成功后跳出匹配。它可以对请求的 uri、method、authority、headers、port、queryParams 以及是否对 uri 大小写敏感等进行配置。</p><blockquote><p>除了HTTP协议，也可以使用 <code>tcp</code> 和 <code>tls</code> 片段为 <a href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#TCPRoute" target="_blank" rel="external nofollow noopener noreferrer">TCP</a> 和未终止的 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#TLSRoute" target="_blank" rel="external nofollow noopener noreferrer">TLS</a> 流量设置路由规则</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">end-user:</span></span><br><span class="line">        <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">  <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>我们推荐在每个 VirtualService 中配置一条默认「无条件的」或者基于权重的规则以确保 VirtualService 至少有一条匹配的路由。</p><h5 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h5><p>路由片段的 <code>destination</code> 字段指定符合匹配条件的流量目标地址。这里不像 VirtualService 的 <code>hosts</code>，Destination 的 <code>host</code> 必须是存在于 Istio 服务注册中心的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。这个目标地址可以是代理的网格服务或者作为服务入口加入的非网格服务。下面的场景中我们运行在 Kubernetes 平台上，主机名是 Kubernetes 的服务名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">subset:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">*Note for Kubernetes users*: When short names are used (e.g. "reviews" instead of "reviews.default.svc.cluster.local"), Istio will interpret the short name based on the namespace of the rule, not the service. A rule in the "default" namespace containing a host "reviews will be interpreted as "reviews.default.svc.cluster.local", irrespective of the actual namespace associated with the reviews service. To avoid potential misconfiguration, it is recommended to always use fully qualified domain names over short names.</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>路由规则是将特定流量子集路由到特定目标地址的强大工具。可以在流量端口、<code>header</code> 字段、 URL 等内容上设置匹配条件。例如，下面的VirtualService 使用户发送流量到两个独立的服务，ratings and reviews， 就好像它们是 <code>http://bookinfo.com/</code> 这个更大的 VirtualService 的一部分。VirtualService 规则根据请求的 URL 和指向适当服务的请求匹配流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bookinfo.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/ratings</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br></pre></td></tr></table></figure><p>对于匹配条件，您可以使用确定的值，一条前缀、或者一条正则表达式。</p><p>您可以使用 <code>AND</code> 向同一个 <code>match</code> 块添加多个匹配条件， 或者使用 <code>OR</code> 向同一个规则添加多个 <code>match</code> 块。对于任意给定的 VirtualService ，您可以配置多条路由规则。这可以使您的路由条件在一个单独的 VirtualService 中基于业务场景的复杂度来进行相应的配置。可以在 <a href="https://istio.io/docs/reference/config/networking/virtual-service/#HTTPMatchRequest" target="_blank" rel="external nofollow noopener noreferrer">HTTPMatchRequest 参考</a>中查看匹配条件字段和他们可能的值。</p><p>再者进一步使用匹配条件，您可以使用基于“权重”百分比分发流量。这在 A/B 测试和金丝雀部署中非常有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">75</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>您也可以使用路由规则在流量上执行一些操作，例如</p><ul><li>扩展或者删除 <code>headers</code></li><li>重写 URL</li><li>为调用这个目标地址设置重试策略</li></ul><h3 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h3><p><code>DestinationRule</code> 是 Istio 流量路由功能的重要组成部分。一个 <code>VirtualService</code> 可以看作是如何将流量分发到给定的目标地址，然后调用 <code>DestinationRule</code> 来配置分发到该目标地址的流量。<code>DestinationRule</code> 在 <code>VirtualService</code> 的路由规则之后起作用(即在 <code>VirtualService</code> 的 <code>match</code> -&gt; <code>route</code> -&gt; <code>destination</code> 之后起作用，此时流量已经分发到真实的 <code>Service</code> 上)，应用于真实的目标地址。</p><p>特别地，可以使用 <code>DestinationRule</code> 来指定命名的服务子集，例如根据版本对服务的实例进行分组，然后通过 <code>VirtualService</code> 的路由规则中的服务子集将控制流量分发到不同服务的实例中。</p><p><code>DestinationRule</code> 允许在调用完整的目标服务或特定的服务子集(如倾向使用的负载均衡模型，TLS 安全模型或断路器)时自定义 Envoy流量策略。Istio 默认会使用轮询策略，此外 Istio 也支持如下负载均衡模型，可以在 <code>DestinationRule</code> 中使用这些模型，将请求分发到特定的服务或服务子集。</p><ul><li>Random：将请求转发到一个随机的实例上</li><li>Weighted：按照指定的百分比将请求转发到实例上</li><li>Least requests：将请求转发到具有最少请求数目的实例上</li></ul><p>下面的 <code>DestinationRule</code> 使用不同的负载均衡策略为 my-svc 目的服务配置了3个不同的 Subset</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-destination-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">my-svc</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span>     <span class="comment">#默认的负载均衡策略模型为随机</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">RANDOM</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>  <span class="comment">#subset1，将流量转发到具有标签 version:v1 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span>  <span class="comment">#subset2，将流量转发到具有标签 version:v2 的 deployment 对应的服务上,指定负载均衡为轮询</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span>   <span class="comment">#subset3，将流量转发到具有标签 version:v3 的 deployment 对应的服务上</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>每个子集由一个或多个 <code>labels</code> 定义，对应 Kubernetes 中的对象(如 <code>Pod</code> )的 key/value 对。这些标签定义在 Kubernetes 服务的 deployment 的 metadata 中，用于标识不同的版本。</p><p>除了定义子集外，<code>DestinationRule</code> 还定义了该目的地中所有子集的默认流量策略，以及仅覆盖该子集的特定策略。默认的策略定义在 <code>subset</code> 字段之上，为 <code>v1</code> 和 <code>v3</code> 子集设置了随机负载均衡策略，在 <code>v2</code> 策略中使用了轮询负载均衡。</p><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Gateway 用于管理进出网格的流量，指定可以进入或离开网格的流量。Gateway 配置应用于网格边缘的独立的 Envoy代理上，而不是服务负载的 Envoy 代理上。</p><p>与其他控制进入系统的流量的机制(如 Kubernetes Ingress API)不同，Istio gateway 允许利用 Istio 的流量路由的强大功能和灵活性。Istio 的 gateway 资源仅允许配置 4-6 层的负载属性，如暴露的端口，TLS 配置等等，但结合 Istio 的 <code>VirtualService</code>，就可以像管理 Istio 网格中的其他数据面流量一样管理 Gateway 的流量。</p><p>Gateway 主要用于管理 Ingress 流量，但也可以配置 Egress Gateway。通过 Egress Gateway 可以配置流量离开网格的特定节点，限制哪些服务可以访问外部网络，或通过 Egress 安全控制来提高网格的安全性。Gateway 可以用于配置为一个纯粹的内部代理。</p><p>Istio (通过 <code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code> 参数)提供了一些预配置的 Gateway 代理，<code>default</code> profile 下仅会部署 Ingress Gateway。Gateway 可以通过部署文件进行部署，也可以单独部署。</p><p>下面是 <code>default</code> profile 默认安装的 Ingress</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get gw</span><br><span class="line">NAME               AGE</span><br><span class="line">bookinfo-gateway   28h</span><br></pre></td></tr></table></figure><p>可以看到该 ingress 就是一个普通的 <code>Pod</code>，该 <code>Pod</code> 仅包含一个 Istio-proxy 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n istio-system |grep ingress</span><br><span class="line">istio-ingressgateway-64f6f9d5c6-qrnw2 1/1 Running 0 4d20h</span><br></pre></td></tr></table></figure><p>下面是一个 Gateway 的例子，用于配置外部 HTTPS 的 ingress 流量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-host-gwy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>              <span class="comment">#指定 gateway 配置下发的代理，如具有标签 app: my-gateway-controller 的 pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-gateway-controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span>                <span class="comment">#gateway pod 暴露的端口信息</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span>                <span class="comment">#外部流量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/tmp/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/tmp/tls.key</span></span><br></pre></td></tr></table></figure><p>上述 Gateway 配置允许来自 <code>ext-host.example.com</code> 流量进入网格的 443 端口，但没有指定该流量的路由。(此时流量只能进入网格，但没有指定处理该流量的服务，因此需要与 <code>VirtualService</code> 进行绑定)</p><p>为了为 Gateway 指定路由，需要通过 <code>VirtualService</code> 的 <code>Gateway</code> 字段，将 <code>Gateway</code> 绑定到一个 <code>VirtualService</code> 上，将来自 <code>ext-host.example.com</code> 流量引入一个 <code>VirtualService</code>，<code>hosts</code> 可以是通配符，表示引入匹配到的流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">virtual-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">  <span class="attr">gateways:</span>        <span class="comment">#将 gateway "ext-host-gwy" 绑定到 virtual service "virtual-svc"上</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host-gwy</span></span><br></pre></td></tr></table></figure><p>Egress Gateway 提供了对网格的出口流量进行统一管控的功能，在安装 Istio 时默认是不开启的。可以使用以下命令查看是否开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod -l istio=egressgateway -n istio-system</span></span><br></pre></td></tr></table></figure><p>若没有开启，使用以下命令添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl manifest apply --<span class="built_in">set</span> values.global.istioNamespace=istio-system \</span><br><span class="line">    --<span class="built_in">set</span> values.gateways.istio-egressgateway.enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Egress Gateway 的一个简单示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-egressgateway</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">egressgateway</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">edition.cnn.com</span></span><br></pre></td></tr></table></figure><p>可以看出，与 Ingress Gateway 不同，Egress Gateway 使用有 <code>istio: egressgateway</code> 标签的 Pod 来代理流量，实际上这也是一个 Envoy 代理。当网格内部需要访问 <code>edition.cnn.com</code> 这个地址时，流量将会统一先转发到 Egress Gateway 上，再由 Egress Gateway 将流量转发到 <code>edition.cnn.com</code> 上。</p><h3 id="ServiceEntry"><a href="#ServiceEntry" class="headerlink" title="ServiceEntry"></a>ServiceEntry</h3><p>Istio 支持对接 Kubernetes、Consul 等多种不同的注册中心，控制平面<code>Pilot</code>启动时，会从指定的注册中心获取 <code>Service Mesh</code> 集群的服务信息和实例列表，并将这些信息进行处理和转换，然后通过 xDS 下发给对应的数据平面，保证服务之间可以互相发现并正常访问。</p><p>同时，由于这些服务和实例信息都来源于服务网格内部，Istio 无法从注册中心直接获取网格外的服务，导致不利于网格内部与外部服务之间的通信和流量管理。为此，Istio 引入 ServiceEntry 实现对外通信和管理。</p><p>使用 ServiceEntry 可以将外部的服务条目添加到 Istio 内部的服务注册表中，以便让网格中的服务能够访问并路由到这些手动指定的服务。ServiceEntry 描述了服务的属性（DNS 名称、VIP、端口、协议、端点）。这些服务可能是位于网格外部（如，web APIs），也可能是处于网格内部但不属于平台服务注册表中的条目（如，需要和 Kubernetes 服务交互的一组虚拟机服务）。</p><h4 id="ServiceEntry-示例和属性介绍"><a href="#ServiceEntry-示例和属性介绍" class="headerlink" title="ServiceEntry 示例和属性介绍"></a>ServiceEntry 示例和属性介绍</h4><p>对于网格外部的服务，下面的 ServiceEntry 示例表示网格内部的应用通过 https 访问外部的 API。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">www.google.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure><p>对于在网格内部但不属于平台服务注册表的服务，使用下面的示例可以将一组在非托管 VM 上运行的 MongoDB 实例添加到 Istio 的注册中心，以便可以将这些服务视为网格中的任何其他服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-svc-mongocluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mymongodb.somedomain</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.192</span><span class="number">.192</span><span class="number">.192</span><span class="string">/24</span> <span class="comment"># VIPs</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">27018</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">MONGO</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_INTERNAL</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">STATIC</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">3.3</span><span class="number">.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p>结合上面给出的示例，这里对 ServiceEntry 涉及的关键属性解释如下：</p><ul><li><code>hosts</code>: 表示与该 ServiceEntry 相关的主机名，可以是带有通配符前缀的 DNS 名称。</li><li><code>address</code>: 与服务相关的虚拟 IP 地址，可以是 CIDR 前缀的形式。</li><li><code>ports</code>: 和外部服务相关的端口，如果外部服务的 endpoints 是 Unix socket 地址，这里必须只有一个端口。</li><li><code>location</code>: 用于指定该服务属于网格内部（MESH_INTERNAL）还是外部（MESH_EXTERNAL）。</li><li><code>resolution</code>: 主机的服务发现模式，可以是 NONE、STATIC、DNS。</li><li><code>endpoints</code>: 与服务相关的一个或多个端点。</li><li><code>exportTo</code>: 用于控制 ServiceEntry 跨命名空间的可见性，这样就可以控制在一个命名空间下定义的资源对象是否可以被其他命名空间下的 <code>Sidecar</code>、Gateway 和 VirtualService 使用。目前支持两种选项，”.” 表示仅应用到当前命名空间，”*” 表示应用到所有命名空间。</li></ul><h4 id="使用-ServiceEntry-访问外部服务"><a href="#使用-ServiceEntry-访问外部服务" class="headerlink" title="使用 ServiceEntry 访问外部服务"></a>使用 ServiceEntry 访问外部服务</h4><p>Istio 提供了三种访问外部服务的方法：</p><ol><li>允许 <code>Sidecar</code> 将请求传递到未在网格内配置过的任何外部服务。使用这种方法时，无法监控对外部服务的访问，也不能利用 Istio 的流量控制功能。</li><li>配置 ServiceEntry 以提供对外部服务的受控访问。这是 Istio 官方推荐使用的方法。</li><li>对于特定范围的 IP，完全绕过 <code>Sidecar</code>。仅当出于性能或其他原因无法使用 <code>Sidecar</code> 配置外部访问时，才建议使用该配置方法。</li></ol><p>这里，我们重点讨论第 2 种方式，也就是使用 ServiceEntry 完成对网格外部服务的受控访问。</p><p>对于 <code>Sidecar</code> 对外部服务的处理方式，Istio 提供了两种选项:</p><ul><li><code>ALLOW_ANY</code>：默认值，表示 Istio 代理允许调用未知的外部服务。上面的第一种方法就使用了该配置项。</li><li><code>REGISTRY_ONLY</code>：Istio 代理会阻止任何没有在网格中定义的 HTTP 服务或 ServiceEntry 的主机。</li></ul><p>可以使用下面的命令查看当前所使用的模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | grep -o <span class="string">"mode: ALLOW_ANY"</span></span><br><span class="line">mode: ALLOW_ANY</span><br></pre></td></tr></table></figure><p>如果当前使用的是 <code>ALLOW_ANY</code> 模式，可以使用下面的命令切换为 <code>REGISTRY_ONLY</code> 模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get configmap istio -n istio-system -o yaml | sed <span class="string">'s/mode: ALLOW_ANY/mode: REGISTRY_ONLY/g'</span> | kubectl replace -n istio-system -f -</span><br><span class="line">configmap <span class="string">"istio"</span> replaced</span><br></pre></td></tr></table></figure><p>在 <code>REGISTRY_ONLY</code> 模式下，需要使用 ServiceEntry 才能完成对外部服务的访问。当创建如下的 ServiceEntry 时，服务网格内部的应用就可以正常访问 httpbin.org 服务了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br></pre></td></tr></table></figure><h4 id="管理外部流量"><a href="#管理外部流量" class="headerlink" title="管理外部流量"></a>管理外部流量</h4><p>使用 ServiceEntry 可以使网格内部服务发现并访问外部服务，除此之外，还可以对这些到外部服务的流量进行管理。结合 VirtualService 为对应的 ServiceEntry 配置外部服务访问规则，如请求超时、故障注入等，实现对指定服务的受控访问。</p><p>下面的示例就是为外部服务 httpbin.org 设置了超时时间，当请求时间超过 3s 时，请求就会直接中断，避免因外部服务访问时延过高而影响内部服务的正常运行。由于外部服务的稳定性通常无法管控和监测，这种超时机制对内部服务的正常运行具有重要意义。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpbin-ext</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">timeout:</span> <span class="string">3s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">        <span class="attr">weight:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>同样的，我们也可以为 ServiceEntry 设置故障注入规则，为系统测试提供基础。下面的示例表示为所有访问 <code>httpbin.org</code> 服务的请求注入一个403错误。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">httpbin-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">hosts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">httpbin.org</span></span><br><span class="line"> <span class="attr">http:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">       <span class="attr">host:</span> <span class="string">httpbin.org</span></span><br><span class="line">   <span class="attr">fault:</span></span><br><span class="line">     <span class="attr">abort:</span></span><br><span class="line">       <span class="attr">percent:</span> <span class="number">100</span></span><br><span class="line">       <span class="attr">httpStatus:</span> <span class="number">403</span></span><br></pre></td></tr></table></figure><h3 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h3><p>在默认的情况下，Istio 中所有 Pod 中的 Envoy 代理都是可以被寻址的。然而在某些场景下，我们为了做资源隔离，希望只访问某些 Namespace 下的资源。这个时候，我们就可以使用 Sidecar配置来实现。下面是一个简单的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sidecar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"./*"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"istio-system/*"</span></span><br></pre></td></tr></table></figure><p>该示例就规定了在命名空间为 bookinfo 下的所有服务仅可以访问本命名空间下的服务以及 <code>istio-system</code> 命名空间下的服务。</p><h2 id="弹性功能"><a href="#弹性功能" class="headerlink" title="弹性功能"></a>弹性功能</h2><p>除了最核心的路由和流量转移功能外，Istio 还提供了一定的弹性功能，目前支持超时、重试和熔断。</p><h3 id="Request-Timeouts"><a href="#Request-Timeouts" class="headerlink" title="Request Timeouts"></a>Request Timeouts</h3><p>如果程序请求长时间无法返回结果，则需要设置超时机制，超过设置的时间则返回错误信息。这样做既可以节约等待时消耗的资源，也可以避免由于级联错误引起的一系列问题。</p><p>设置超时的方式也有很多种，比如通过修改代码在应用程序侧设置请求超时时间，但是这样很不灵活，也容易出现遗漏的现象，而 Istio 则可以在基础设施层解决这一问题。在 Istio 里添加超时非常简单，只需要在路由配置里添加 <code>timeout</code> 这个关键字就可以实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><h3 id="Retries"><a href="#Retries" class="headerlink" title="Retries"></a>Retries</h3><p>在网络环境不稳定的情况下，会出现暂时的网络不可达现象，这时需要重试机制，通过多次尝试来获取正确的返回信息。重试逻辑可以写业务代码中，比如 Bookinfo 应用中的<code>productpage</code>服务就存在硬编码重试，而 Istio 可以通过简单的配置来实现重试功能，让开发人员无需关注重试部分的代码实现，专心实现业务代码。在 Istio 里添加超时和重试都非常简单，只需要在路由配置里添 <code>retry</code> 这个关键字就可以实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">2s</span></span><br></pre></td></tr></table></figure><h3 id="Circuit-Breaking"><a href="#Circuit-Breaking" class="headerlink" title="Circuit Breaking"></a>Circuit Breaking</h3><p>熔断是一种非常有用的过载保护手段，可以避免服务的级联失败。在熔断器中，设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。熔断适用于在负载均衡池中的“真实”网格目标地址，可以在 DestinationRule 中配置熔断器阈值，让配置适用于服务中的每个主机。</p><p>Istio 里面的熔断需要在自定义资源 <code>DestinationRule</code> 的 <code>TrafficPolicy</code> 里进行设置。下面的示例将 v1 子集的<code>reviews</code>服务工作负载的并发连接数限制为 100：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">connectionPool:</span></span><br><span class="line">        <span class="attr">tcp:</span></span><br><span class="line">          <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Istio 还提供了对流量进行调试的能力，包括故障注入和流量镜像。对流量进行调试可以让系统具有更好的容错能力，也方便我们在问题排查时通过调试来快速定位原因所在。</p><h3 id="Fault-Injection"><a href="#Fault-Injection" class="headerlink" title="Fault Injection"></a>Fault Injection</h3><p>在一个微服务架构的系统中，为了让系统达到较高的健壮性要求，通常需要对系统做定向错误测试。比如电商中的订单系统、支付系统等若出现故障那将是非常严重的生产事故，因此必须在系统设计前期就需要考虑多样性的异常故障并对每一种异常设计完善的恢复策略或优雅的回退策略，尽全力规避类似事故的发生，使得当系统发生故障时依然可以正常运作。而在这个过程中，服务故障模拟一直以来是一个非常繁杂的工作，于是在这样的背景下就衍生出了故障注入技术手段，故障注入是用来模拟上游服务请求响应异常行为的一种手段。通过人为模拟上游服务请求的一些故障信息来检测下游服务的故障策略是否能够承受这些故障并进行自我恢复。</p><p>Istio 提供了一种无侵入式的故障注入机制，让开发测试人员在不用调整服务程序的前提下，通过配置即可完成对服务的异常模拟。Istio 1.5 仅支持网络层的故障模拟，即支持模拟上游服务的处理时长、服务异常状态、自定义响应状态码等故障信息，暂不支持对于服务主机内存、CPU 等信息故障的模拟。他们都是通过配置上游主机的 VirtualService 来实现的。当我们在 VirtualService 中配置了故障注入时，上游服务的 Envoy代理在拦截到请求之后就会做出相应的响应。</p><p>目前，Istio 提供两种类型的故障注入，abort 类型与 delay 类型。</p><ul><li><strong>abort</strong>：非必配项，配置一个 Abort 类型的对象。用来注入请求异常类故障。简单的说，就是用来模拟上游服务对请求返回指定异常码时，当前的服务是否具备处理能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-faultabort" target="_blank" rel="external nofollow noopener noreferrer">config.filter.http.fault.v2.FaultAbort</a> 配置项，当 VirtualService 资源应用时，Envoy将会该配置加载到过滤器中并处理接收到的流量。</li><li><strong>delay</strong>：非必配项，配置一个 Delay 类型的对象。用来注入延时类故障。通俗一点讲，就是人为模拟上游服务的响应时间，测试在高延迟的情况下，当前的服务是否具备容错容灾的能力。它对应于 Envoy过滤器中的 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/fault/v2/fault.proto#envoy-api-msg-config-filter-fault-v2-faultdelay" target="_blank" rel="external nofollow noopener noreferrer">config.filter.fault.v2.FaultDelay</a> 配置型，同样也是在应用 Istio 的 VirtualService 资源时，Envoy将该配置加入到过滤器中。</li></ul><p>实际上，Istio 的故障注入正是基于 Envoy的 config.filter.http.fault.v2.HTTPFault 过滤器实现的，它的局限性也来自于 Envoy故障注入机制的局限性。对于 Envoy的 HttpFault 的详细介绍请参考 <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/fault/v2/fault.proto#envoy-api-msg-config-filter-http-fault-v2-httpfault" target="_blank" rel="external nofollow noopener noreferrer">Envoy 文档</a>。对比 Istio 故障注入的配置项与 Envoy故障注入的配置项，不难发现，Istio 简化了对于故障控制的手段，去掉了 Envoy中通过 HTTP header 控制故障注入的配置。</p><h4 id="HTTPFaultInjection-Abort"><a href="#HTTPFaultInjection-Abort" class="headerlink" title="HTTPFaultInjection.Abort"></a>HTTPFaultInjection.Abort</h4><ul><li><strong>httpStatus</strong>：必配项，是一个整型的值。表示注入 HTTP 请求的故障状态码。</li><li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li><li><strong>percent</strong>：已经废弃的一个配置，与 percentage 配置功能一样，已经被 percentage 代替。</li></ul><p>如下的配置表示对 <code>v1</code> 版本的 <code>ratings.prod.svc.cluster.local</code> 服务访问的时候进行故障注入，<code>0.1</code>表示有千分之一的请求被注入故障， <code>400</code> 表示故障为该请求的 HTTP 响应码为 <code>400</code> 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">abort:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">httpStatus:</span> <span class="number">400</span></span><br></pre></td></tr></table></figure><h4 id="HTTPFaultInjection-Delay"><a href="#HTTPFaultInjection-Delay" class="headerlink" title="HTTPFaultInjection.Delay"></a>HTTPFaultInjection.Delay</h4><ul><li><strong>fixedDelay</strong>：必配项，表示请求响应的模拟处理时间。格式为：<code>1h/1m/1s/1ms</code>， 不能小于 <code>1ms</code>。</li><li><strong>percentage</strong>：非必配项，是一个 Percent 类型的值。表示对多少请求进行故障注入。如果不指定该配置，那么所有请求都将会被注入故障。</li><li><strong>percent</strong>：已经废弃的一个配置，与 <code>percentage</code> 配置功能一样，已经被 <code>percentage</code> 代替。</li></ul><p>如下的配置表示对 <code>v1</code> 版本的 <code>reviews.prod.svc.cluster.local</code> 服务访问的时候进行延时故障注入，<code>0.1</code> 表示有千分之一的请求被注入故障，<code>5s</code> 表示<code>reviews.prod.svc.cluster.local</code> 延时 <code>5s</code>返回。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews-route</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews.prod.svc.cluster.local</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure><h3 id="Mirroring"><a href="#Mirroring" class="headerlink" title="Mirroring"></a>Mirroring</h3><p>流量镜像（Mirroring / traffic-shadow），也叫作影子流量，就是通过复制一份请求并把它发送到镜像服务，从而实现流量的复制功能。流量镜像的主要应用场景有以下几种：最主要的就是进行<strong>线上问题排查</strong>。</p><p>一般情况下，因为系统环境，特别是数据环境、用户使用习惯等问题，我们很难在开发环境中模拟出真实的生产环境中出现的棘手问题，同时生产环境也不能记录太过详细的日志，因此很难定位到问题。有了流量镜像，我们就可以把真实的请求发送到镜像服务，再打开 debug 日志来查看详细的信息。除此以外，还可以通过它来观察生产环境的请求处理能力，比如在镜像服务进行压力测试。也可以将复制的请求信息用于数据分析。流量镜像在 Istio 里实现起来也非常简单，只需要在路由配置中通添加<code>mirror</code>关键字即可。</p><h4 id="流量镜像能够为我们带来什么"><a href="#流量镜像能够为我们带来什么" class="headerlink" title="流量镜像能够为我们带来什么"></a>流量镜像能够为我们带来什么</h4><p>很多情况下，当我们对服务做了重构，或者我们对项目做了重大优化时，怎么样保证服务是健壮的呢？在传统的服务里，我们只能通过大量的测试，模拟在各种情况下服务的响应情况。虽然也有手工测试、自动化测试、压力测试等一系列手段去检测它，但是测试本身就是一个样本化的行为，即使测试人员再完善它的测试样例，无法全面的表现出线上服务的一个真实流量形态。往往当项目发布之后，总会出现一些意外，比如你服务里收到客户使用的某些数据库不认识的特殊符号，再比如用户在本该输入日期的输入框中输入了 “—” 字样的字符，又比如用户使用乱码替换你的 token 值批量恶意攻击服务等等，这样的情况屡见不鲜。数据的多样性，复杂性决定了开发人员在开发阶段根本是无法考虑周全的。</p><p>而流量镜像的设计，让这类问题得到了最大限度的解决。流量镜像讲究的不再是使用少量样本去评估一个服务的健壮性，而是在不影响线上坏境的前提下将线上流量持续的镜像到我们的预发布坏境中去，让重构后的服务在上线之前就结结实实地接受一波真实流量的冲击与考验，让所有的风险全部暴露在上线前夕，通过不断的暴露问题，解决问题让服务在上线前夕就拥有跟线上服务一样的健壮性。由于测试坏境使用的是真实流量，所以不管从流量的多样性，真实性，还是复杂性上都将能够得以展现，同时预发布服务也将表现出其最真实的处理能力和对异常的处理能力。运用这种模式，一方面，我们将不会再跟以前一样在发布服务前夕内心始终忐忑不安，只能祈祷上线之后不会出现问题。另一方面，当大量的流量流入重构服务之后，开发过程中难以评估的性能问题也将完完整整的暴露出来，此时开发人员将会考虑它服务的性能，测试人员将会更加完善他们的测试样例。通过暴露问题，解决问题，再暴露问题，再解决问题的方式循序渐进地完善预发布服务来增加我们上线的成功率。同时也变相的促进我们开发测试人员技能水平的提高。</p><p>当然，流量镜像的作用不仅仅只是解决上面这样的场景问题，我们可以根据它的特性，解决更多的问题。比如，假如我们在上线后突然发现一个线上问题，而这个问题在测试坏境中始终不能复现。那么这个时候我们就能利用它将异常流量镜像到一个分支服务中去，然后我们可以随意在这个分支服务上进行分析调试，这里所说的分支服务，可以是原服务的只用于问题分析而不处理正式业务的副本服务，也可以是一个只收集镜像流量的组件类服务。又比如突然需要收集某个时间段某些流量的特征数据做分析，像这种临时性的需求，使用流量镜像来处理非常合适，既不影响线上服务的正常运转，也达到了收集分析的目的。</p><h4 id="流量镜像的实现原理"><a href="#流量镜像的实现原理" class="headerlink" title="流量镜像的实现原理"></a>流量镜像的实现原理</h4><p>实际上在 Istio 中，服务间的通讯都是被 Envoy代理拦截并处理的， Istio 流量镜像的设计也是基于 Envoy特性实现的。它的流量转发如下图所示。可以看到，当流量进入到<code>Service A</code>时，因为在<code>Service A</code>的 Envoy代理上配置了流量镜像规则，那么它首先会将原始流量转发到<code>v1</code>版本的 <code>Service B</code>服务子集中去 。同时也会将相同的流量复制一份，异步地发送给<code>v2</code>版本的<code>Service B</code> 服务子集中去，可以明显的看到，<code>Service A</code> 发送完镜像流量之后并不关心它的响应情况。</p><p>在很多情况下，我们需要将真实的流量数据与镜像流量数据进行收集并分析，那么当我们收集完成后应该怎样区分哪些是真实流量，哪些是镜像流量呢？ 实际上，Envoy团队早就考虑到了这样的场景，他们为了区分镜像流量与真实流量，在镜像流量中修改了请求标头中 <code>host</code> 值来标识，它的修改规则是：在原始流量请求标头中的 <code>host</code> 属性值拼接上<code>“-shadow”</code> 字样作为镜像流量的 <code>host</code> 请求标头。</p><p>为了能够更清晰的对比出原始流量与镜像流量的区别，我们使用以下的一个示例来说明：</p><p>如下图所示，我们发起一个<code>http://istio.gateway.xxxx.tech/serviceB/request/info</code>的请求，请求首先进入了<code>istio-ingressgateway</code> ，它是一个 Istio 的 Gateway 资源类型的服务，它本身就是一个 Envoy代理。在这个例子里，就是它对流量进行了镜像处理。可以看到，它将流量转发给<code>v1</code>版本<code>Service B</code>服务子集的同时也复制了一份流量发送到了<code>v2</code>版本的<code>Service B</code>服务子集中去。</p><p><img alt="concepts-traffic-shadow-request" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-request.png"></p><p>在上面的请求链中，请求标头数据有什么变化呢？下图收集了它们请求标头中的所有信息，可以明显的对比出正式流量与镜像流量请求标头中<code>host</code>属性的区别（部分相同的属性值过长，这里只截取了前半段）。从图中我们可以看出，首先就是host属性值的不同，而区别就是多了一个<code>“-shadow”</code>的后缀。再者发现<code>x-forwarded-for</code>属性也不相同，<code>x-forwarded-for</code>协议头的格式是：<code>x-forwarded-for: client1, proxy1, proxy2</code>， 当流量经过 Envoy代理时这个协议头将会把代理服务的 IP 添加进去。实例中<code>10.10.2.151</code>是我们云主机的 IP，而<code>10.10.2.121</code>是<code>isito-ingressgateway</code>所对应<code>Pod</code>的 IP 。从这里也能看到，镜像流量是由<code>istio-ingressgatway</code>发起的。除了这两个请求标头的不同，其他配置项是完全一样的。</p><p><img alt="concepts-traffic-shadow-header" data-src="https://www.servicemesher.com/istio-handbook/images/concepts-traffic-shadow-header.png"></p><h4 id="流量镜像的配置"><a href="#流量镜像的配置" class="headerlink" title="流量镜像的配置"></a>流量镜像的配置</h4><p>上面我们介绍了流量镜像的原理及使用场景，接下来我们再介绍下流量的镜像如何配置才能生效。在 Istio 架构里，镜像流量是借助于 VirtualService 这个资源中的 <code>HTTPRoute</code> 配置项的<code>mirror</code>与<code>mirrorPercent</code>这两项子配置项来实现的，这两个配置项的定义也是非常的简单。</p><ul><li><strong>mirror</strong>：配置一个 Destination 类型的对象，这里就是我们镜像流量转发的服务地址。具体的 <strong>VirtualService</strong> 配置与<strong>DestinationRule</strong> 对象配置属性请参考相关介绍页。</li><li><strong>mirrorPercent</strong>：配置一个数值，这个配置项用来指定有多少的原始流量将被转发到镜像流量服务中去，它的有效值为<code>0~100</code>，如果配置成<code>0</code>则表示不发送镜像流量。</li></ul><p>下面的例子就是我们在示例中使用到的<code>Service B</code>的镜像流量配置，其中，<code>mirror.host</code>配置项是配置一个域名或者在Istio 注册表中注册过的服务名称，可以看到，该配置指定了镜像流量需要发送的目标服务地址为<code>serviceB</code>。<code>mirror.subset</code>配置项配置一个<code>Service B</code>服务的服务子集名称 ，指定了要将镜像流量镜像到<code>v2</code>版本的<code>Service B</code>服务子集中去。<code>mirror_percent</code>配置将<code>100%</code>的真实流量进行镜像发送。所以下面的配置整体表示当流量到来时，将请求转发到<code>v1</code>版本的<code>service B</code>服务子集中，再以镜像的方式发送到<code>v2</code>版本的<code>service B</code>服务上一份，并将真实流量全部镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">istio.gateway.xxxx.tech</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingressgateway.istio-system.svc.cluster.local</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/serviceB</span></span><br><span class="line">    <span class="attr">rewrite:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">mirror:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">mirror_percent:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p><code>service B</code> 服务对应的 DestinationRule 配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">serviceB</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流量控制是指对系统流量的管控，包括了对网格入口的流量、网格出口的流量以及在网格内部微服务间相互调用流量的控制。在 &lt;a href=&quot;../22cae0b8&quot;&gt;Istio 入门&lt;/a&gt; 中我们知道，Istio 架构在逻辑上分为 Control plane 和 Data plane，Control plane 负责整体管理和配置代理， Data plane 负责网格内所有微服务间的网络通信，同时还收集报告网络请求的遥测数据等。流量控制是在 Data plane 层实现。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo.svg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="网络" scheme="http://houmin.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="envoy" scheme="http://houmin.cc/tags/envoy/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】Istio 入门</title>
    <link href="http://houmin.cc/posts/22cae0b8/"/>
    <id>http://houmin.cc/posts/22cae0b8/</id>
    <published>2020-11-23T02:44:08.000Z</published>
    <updated>2020-11-27T02:46:29.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p><a id="more"></a><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>微服务应用最大的痛点就是处理服务间的通信，而这一问题的核心其实就是流量管理。首先我们来看看传统的微服务应用在没有 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#service-mesh" target="_blank" rel="external nofollow noopener noreferrer">Service Mesh</a> 介入的情况下，是如何完成诸如金丝雀发布这样的路由功能的。我们假设不借助任何现成的第三方框架，一个最简单的实现方法，就是在服务间添加一个负载均衡（比如 Nginx）做代理，通过修改配置的权重来分配流量。这种方式使得对流量的管理和基础设施绑定在了一起，难以维护。</p><p>而使用 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 就可以轻松的实现各种维度的流量控制。下图是典型的金丝雀发布策略：根据权重把 5% 的流量路由给新版本，如果服务正常，再逐渐转移更多的流量到新版本。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的流量控制功能主要分为三个方面：</p><ul><li>请求路由和流量转移</li><li>弹性功能，包括熔断、超时、重试</li><li>调试能力，包括故障注入和流量镜像</li></ul><p>关于流量控制的更多内容，参考 <a href="../151719f0">Istio流量控制</a></p><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><p>安全对于微服务这样的分布式系统来说至关重要。与单体应用在进程内进行通信不同，网络成为了服务间通信的纽带，这使得它对安全有了更迫切的需求。比如为了抵御外来攻击，我们需要对流量进行加密；为保证服务间通信的可靠性，需要使用mTLS的方式进行交互；为控制不同身份的访问，需要设置不同粒度的授权策略。作为一个服务网格，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 提供了一整套完整的安全解决方案。它可以以透明的方式，为我们的微服务应用添加安全策略。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 中的安全架构是由多个组件协同完成的。Citadel 是负责安全的主要组件，用于密钥和证书的管理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 会将安全策略配置分发给 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 代理；<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#envoy" target="_blank" rel="external nofollow noopener noreferrer">Envoy</a> 执行安全策略来实现访问控制。下图展示了 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的安全架构和运作流程。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-secure-arch.svg"></p><p>关于安全管理的更多内容，参考 <a href="../">Istio安全管理</a></p><h3 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h3><p>面对复杂的应用环境和不断扩展的业务需求，即使再完备的测试也难以覆盖所有场景，无法保证服务不会出现故障。正因为如此，才需要“可观察性”来对服务的运行时状态进行监控、上报、分析，以提高服务可靠性。具有可观察性的系统，可以在服务出现故障时大大降低问题定位的难度，甚至可以在出现问题之前及时发现问题以降低风险。具体来说，可观察性可以：</p><ul><li>及时反馈异常或者风险使得开发人员可以及时关注、修复和解决问题（告警）；</li><li>出现问题时，能够帮助快速定位问题根源并解决问题，以减少服务损失（减损）；</li><li>收集并分析数据，以帮助开发人员不断调整和改善服务（持续优化）。</li></ul><p>而在微服务治理之中，随着服务数量大大增加，服务拓扑不断复杂化，可观察性更是至关重要。<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 自然也不可能缺少对可观察性的支持。它会为所有的服务间通信生成详细的遥测数据，使得网格中每个服务请求都可以被观察和跟踪。开发人员可以凭此定位故障，维护和优化相关服务。而且，这一特性的引入无需侵入被观察的服务。</p><p><a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 一共提供了三种不同类型的数据从不同的角度支撑起其可观察性：</p><ul><li>指标（Metrics）</li><li>日志（Access Logs）</li><li>分布式追踪（Distributed Traces）</li></ul><p>关于可观测行的更多内容，参考 <a href="../">Istio可观测性</a></p><h2 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h2><p>Istio的架构由<strong>控制平面</strong>和<strong>数据平面</strong>两个部分组成。</p><ul><li>数据平面：由整个网格内的sidecar代理组成，每个sidecar代理会接管流入和流出服务的流量，并配合控制平面完成流量控制等方面的内容。</li><li>控制平面：负责控制和管理数据平面的sidecar代理，完成配置的分发、服务发现和授权鉴权等功能。</li></ul><p>控制平面是 Istio 在原有服务网格产品上，首次提出的架构，实现了对于数据平面的统一管理。</p><p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><h4 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h4><p><code>Pilot</code> 组件的主要功能是将路由规则等配置信息转换为 sidecar 可以识别的信息，并下发给数据平面。可以把它简单的理解为是一个<strong>配置分发器</strong>（dispatcher），并辅助 sidecar 完成流量控制相关的功能。它管理sidecar代理之间的路由流量规则，并配置故障恢复功能，如超时、重试和熔断。</p><p><img alt="Istio Pilot Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-pilot-arch.svg"></p><p>上图显示了Pilot的基本架构，它主要由以下几个部分组成：</p><h5 id="Abstract-Model"><a href="#Abstract-Model" class="headerlink" title="Abstract Model"></a>Abstract Model</h5><p>为了实现对不同服务注册中心 （Kubernetes、consul） 的支持，<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#pilot" target="_blank" rel="external nofollow noopener noreferrer">Pilot</a> 需要对不同的输入来源的数据有一个统一的存储格式，也就是抽象模型。抽象模型中定义的关键成员包括 HostName（Service名称）、Ports（Service端口）、Address（Service ClusterIP）、Resolution （负载均衡策略） 等。</p><h5 id="Platform-Adapters"><a href="#Platform-Adapters" class="headerlink" title="Platform Adapters"></a>Platform Adapters</h5><p>借助平台适配器 Pilot 可以实现服务注册中心数据到抽象模型之间的数据转换。例如 Pilot 中的 Kubernetes 适配器通过 Kubernetes API 服务器得到 Kubernetes 中 Service 和 Pod 的相关信息，然后翻译为抽象模型提供给 Pilot 使用。通过平台适配器模式，Pilot 还可以从 Consul 等平台中获取服务信息，还可以开发适配器将其他提供服务发现的组件集成到 Pilot 中。</p><h5 id="xDS-API"><a href="#xDS-API" class="headerlink" title="xDS API"></a>xDS API</h5><p>Pilot 使用了一套起源于 Envoy 项目的标准数据面 API 来将服务信息和流量规则下发到数据面的 sidecar 中。这套标准数据面 API，也叫 xDS。Sidecar 通过 xDS API 可以动态获取 Listener （监听器）、Route （路由）、<a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#cluster" target="_blank" rel="external nofollow noopener noreferrer">Cluster</a> （集群）及 Endpoint （集群成员）配置：</p><ul><li>LDS，Listener 发现服务：Listener 监听器控制 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#sidecar" target="_blank" rel="external nofollow noopener noreferrer">sidecar</a> 启动端口监听（目前只支持 TCP 协议），并配置 L3/L4 层过滤器，当网络连接达到后，配置好的网络过滤器堆栈开始处理后续事件。</li><li>RDS，Router 发现服务：用于 HTTP 连接管理过滤器动态获取路由配置，路由配置包含 HTTP 头部修改（增加、删除 HTTP 头部键值），virtual hosts （虚拟主机），以及 virtual hosts 定义的各个路由条目。</li><li>CDS，Cluster发现服务：用于动态获取 Cluster 信息。</li><li>EDS，Endpoint 发现服务：用于动态维护端点信息，端点信息中还包括负载均衡权重、金丝雀状态等，基于这些信息，Sidecar 可以做出智能的负载均衡决策。</li></ul><h5 id="User-API"><a href="#User-API" class="headerlink" title="User API"></a>User API</h5><p>Pilot 还定义了一套用户 API， 用户 API 提供了面向业务的高层抽象，可以被运维人员理解和使用。</p><p>运维人员使用该 API 定义流量规则并下发到 Pilot，这些规则被 Pilot 翻译成数据面的配置，再通过标准数据面 API 分发到 sidecar 实例，可以在运行期对微服务的流量进行控制和调整。</p><p>通过运用不同的流量规则，可以对网格中微服务进行精细化的流量控制，如按版本分流、断路器、故障注入、灰度发布等。</p><p>关于 Pilot 的具体实现，可以参考 <a href="../">Istio Pilot 模块分析</a></p><h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><p><code>Citadel</code> 是 Istio 中专门负责安全的组件，内置有身份和证书管理功能，可以实现较为强大的授权和认证等操作，在1.5 版本之后取消了独立进程，作为一个模块被整合在 istiod 中。</p><p>总体来说，Istio 在安全架构方面主要包括以下内容：</p><ul><li>证书签发机构（CA）负责密钥和证书管理</li><li>API 服务器将安全配置分发给数据平面</li><li>客户端、服务端通过代理安全通信</li><li>Envoy 代理管理遥测和审计</li></ul><p>Istio 的身份标识模型使用一级服务标识来确定请求的来源，它可以灵活的标识终端用户、工作负载等。在平台层面，Istio 可以使用类似于服务名称来标识身份，或直接使用平台提供的服务标识。比如 Kubernetes 的 ServiceAccount，AWS IAM 用户、角色账户等。</p><p>在身份和证书管理方面，Istio 使用 X.509 证书，并支持密钥和证书的自动轮换。从 1.1 版本开始，Istio 开始支持安全发现服务器（SDS），随着不断的完善和增强，1.5 版本 SDS 已经成为默认开启的组件。Citadel 以前有两个功能：将证书以 Secret 的方式挂载到命名空间里；通过 SDS gRPC 接口与 nodeagent（已废弃）通信。目前 Citadel 只需要完成与 SDS 相关的工作，其他功能被移动到了 istiod 中。</p><p>关于Citadel的更多内容，参考 <a href="../">Istio安全管理</a></p><h4 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h4><p><code>Galley</code> 是 Istio 1.1 版本中新增加的组件，其目的是将 <code>Pilot</code> 和底层平台（如 Kubernetes）进行解耦。它分担了原本 <code>Pilot</code> 的一部分功能，主要负责配置的验证、提取和处理等功能。</p><h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><p>Istio 数据平面核心是以 sidecar 模式运行的智能代理。Sidecar 模式将数据平面核心组件部署到单独的流程或容器中，以提供隔离和封装。Sidecar 应用与父应用程序共享相同的生命周期，与父应用程序一起创建和退出。Sidecar 应用附加到父应用程序，并为应用程序提供额外的特性支持。</p><p>如下图所示，数据平面的 sidecar 代理可以调节和控制微服务之间所有的网络通信，每个服务 Pod 启动时会伴随启动 <code>istio-init</code> 和 proxy 容器。 </p><ul><li><code>istio-init</code> 容器主要功能是初始化 Pod 网络和对 Pod设置 iptable 规则，设置完成后自动结束。</li><li>Proxy 容器会启动两个服务：<code>istio-agent</code> 以及网络代理组件<ul><li><code>istio-agent</code>  的作用是同步管理数据，启动并管理网络代理服务进程，上报遥测数据</li><li>网络代理组件则根据管理策略完成流量管控、生成遥测数据。</li></ul></li></ul><p>数据平面真正触及到对网络数据包的相关操作，是上层控制平面策略的具体执行者。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-data-plane-arch.png"></p><p>Envoy 是 Istio 中默认的数据平面 Sidecar 代理，关于 Sidecar 是如何实现自动注入和流量劫持，以及Sidecar的流量路由机制如何实现，更多可参考 <a href="../">Envoy系列文章</a> 。</p><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>这里介绍在 Kubernetes 环境下安装 Istio，在开始之前，你需要有一个 Kubernetes 运行环境。</p><p>从 Istio v1.7 版本开始，Istio官方推荐使用 istioctl 安装。下面是安装步骤：</p><ul><li>在 <a href="https://github.com/istio/istio/releases" target="_blank" rel="external nofollow noopener noreferrer">Istio release</a> 页面下载与操作系统匹配的安装包，并将其解压。这里可以直接用Istio提供的脚本：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/istio/istio/release-1.7/release/downloadIstioCandidate.sh | sh -</span><br><span class="line">$  [root@VM-1-28-centos istio]<span class="comment"># ls </span></span><br><span class="line">istio-1.7.0  istio-1.7.0-linux-amd64.tar.gz</span><br><span class="line">$ [root@VM-1-28-centos istio]<span class="built_in">cd</span> istio-1.7.0</span><br><span class="line">$ [root@VM-1-28-centos istio-1.7.0]<span class="comment"># tree -L 2</span></span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── istioctl</span><br><span class="line">├── LICENSE</span><br><span class="line">├── manifests</span><br><span class="line">│   ├── charts</span><br><span class="line">│   ├── deploy</span><br><span class="line">│   ├── examples</span><br><span class="line">│   └── profiles</span><br><span class="line">├── manifest.yaml</span><br><span class="line">├── README.md</span><br><span class="line">├── samples</span><br><span class="line">│   ├── addons</span><br><span class="line">│   ├── bookinfo</span><br><span class="line">│   ├── certs</span><br><span class="line">│   ├── cross-network-gateway</span><br><span class="line">│   ├── custom-bootstrap</span><br><span class="line">│   ├── external</span><br><span class="line">│   ├── fortio</span><br><span class="line">│   ├── health-check</span><br><span class="line">│   ├── helloworld</span><br><span class="line">│   ├── httpbin</span><br><span class="line">│   ├── https</span><br><span class="line">│   ├── kubernetes-blog</span><br><span class="line">│   ├── operator</span><br><span class="line">│   ├── rawvm</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── security</span><br><span class="line">│   ├── sleep</span><br><span class="line">│   ├── tcp-echo</span><br><span class="line">│   └── websockets</span><br><span class="line">└── tools</span><br><span class="line">    ├── certs</span><br><span class="line">    ├── convert_RbacConfig_to_ClusterRbacConfig.sh</span><br><span class="line">    ├── dump_kubernetes.sh</span><br><span class="line">    ├── _istioctl</span><br><span class="line">    └── istioctl.bash</span><br><span class="line"></span><br><span class="line">27 directories, 9 files</span><br></pre></td></tr></table></figure><p>安装目录内容： </p><div class="table-container"><table><thead><tr><th>目录</th><th>包含内容</th></tr></thead><tbody><tr><td><code>bin</code></td><td>包含 istioctl 的客户端文件</td></tr><tr><td><code>manifests</code></td><td>包含 各种部署的 manifests</td></tr><tr><td><code>samples</code></td><td>包含示例应用程序</td></tr><tr><td><code>tools</code></td><td>包含用于性能测试和在本地机器上进行测试的脚本</td></tr></tbody></table></div><ul><li>将<code>istioctl</code>客户端路径加入 <code>$PATH</code> 中，从而可以使用 istioctl 命令行工具</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(<span class="built_in">pwd</span>)/bin</span><br></pre></td></tr></table></figure><ul><li>安装 <code>demo</code> 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl install --<span class="built_in">set</span> profile=demo</span><br><span class="line">✔ Istio core installed</span><br><span class="line">✔ Istiod installed</span><br><span class="line">✔ Egress gateways installed</span><br><span class="line">✔ Ingress gateways installed</span><br><span class="line">✔ Installation complete</span><br></pre></td></tr></table></figure><ul><li>添加一个Namespace Label，使得之后在部署你的应用的时候，istio会自动注入Envoy sidecar 代理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label namespace default istio-injection=enabled</span><br></pre></td></tr></table></figure><h3 id="部署-Bookinfo"><a href="#部署-Bookinfo" class="headerlink" title="部署 Bookinfo"></a>部署 Bookinfo</h3><p>Bookinfo 是 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 社区官方推荐的示例应用之一。它可以用来演示多种 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 的特性，并且它是一个异构的微服务应用。该应用由四个单独的微服务构成。 这个应用模仿了在线书店，可以展示书店中书籍的信息。例如页面上会显示一本书的描述，书籍的细节（ ISBN、页数等），以及关于这本书的一些评论。</p><p>Bookinfo 应用分为四个单独的微服务， 这些服务对 <a href="https://www.servicemesher.com/istio-handbook/GLOSSARY.html#istio" target="_blank" rel="external nofollow noopener noreferrer">Istio</a> 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个不同语言编写的服务构成，并且其中有一个应用会包含多个版本。</p><ul><li><code>productpage</code> 会调用 <code>details</code> 和 <code>reviews</code> 两个微服务，用来生成页面。</li><li><code>details</code> 中包含了书籍的信息。</li><li><code>reviews</code> 中包含了书籍相关的评论。它还会调用 <code>ratings</code> 微服务。</li><li><code>ratings</code> 中包含了由书籍评价组成的评级信息。</li></ul><p><code>reviews</code> 微服务有 3 个版本，可用来展示各服务之间的不同的调用链路：</p><ul><li>v1 版本不会调用 <code>ratings</code> 服务。</li><li>v2 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul><p>下图展示了这个应用的端到端架构：</p><p><img alt="Bookinfo Application without Istio" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-bookinfo-noistio.svg"></p><ul><li>部署示例应用程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details unchanged</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings unchanged</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews unchanged</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage unchanged</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure><ul><li>之后应用起来，当每个Pod状态变为Ready的时候，sidecar也部署成功。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">details       ClusterIP   172.18.252.45    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">kubernetes    ClusterIP   172.18.252.1     &lt;none&gt;        443/TCP    51d</span><br><span class="line">productpage   ClusterIP   172.18.253.238   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">ratings       ClusterIP   172.18.254.131   &lt;none&gt;        9080/TCP   97s</span><br><span class="line">reviews       ClusterIP   172.18.255.63    &lt;none&gt;        9080/TCP   97s</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5974b67c8-z67st        2/2     Running   0          2m8s</span><br><span class="line">productpage-v1-797898bc54-frzdz   2/2     Running   0          2m8s</span><br><span class="line">ratings-v1-c6cdf8d98-xmhz8        2/2     Running   0          2m8s</span><br><span class="line">reviews-v1-8bdc65f7b-mjktx        2/2     Running   0          2m8s</span><br><span class="line">reviews-v2-868d77d678-4dzmn       2/2     Running   0          2m8s</span><br><span class="line">reviews-v3-6c9b646cb4-5tp9q       2/2     Running   0          2m8s</span><br></pre></td></tr></table></figure><ul><li>查看应用是否成功运行，通过给productpage发送请求，查看其返回</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> <span class="string">"<span class="variable">$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')</span>"</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">"&lt;title&gt;.*&lt;/title&gt;"</span></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><h3 id="集群外部访问应用"><a href="#集群外部访问应用" class="headerlink" title="集群外部访问应用"></a>集群外部访问应用</h3><p>到现在，Bookinfo 应用已经成功部署，我们在集群内部也已经可以访问，但是在集群外部还不能够访问。为了使得外部能够访问应用程序，我们需要创建一个<a href="https://istio.io/latest/docs/concepts/traffic-management/#gateways" target="_blank" rel="external nofollow noopener noreferrer">Istio Ingress Gateway</a>。</p><ul><li>将应用于istio gateway关联</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure><ul><li>确保配置上没有问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl analyze</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure><ul><li>确定Ingress的IP和Ports</li></ul><p>通过下面的命令来设置 <code>INGRESS_HOST</code> 和 <code>INGRESS_PORT</code>环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   172.18.252.12   49.233.242.233   15021:32663/TCP,80:31968/TCP,443:31588/TCP,31400:32002/TCP,15443:30652/TCP   18m</span><br></pre></td></tr></table></figure><p>这里显示 <code>EXTERNAL_IP</code> 已经变设置，表明当前环境下有一个可以使用的外部负载均衡器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="http2")].port&#125;'</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">'&#123;.spec.ports[?(@.name=="https")].port&#125;'</span>)</span><br></pre></td></tr></table></figure><ul><li>设定GATEWAY_URL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GATEWAY_URL</span></span><br><span class="line">49.233.242.233:80</span><br></pre></td></tr></table></figure><ul><li>确认外部访问是否成功：在浏览器直接访问 <code>http://&lt;GATE_WAYURL&gt;/productpage</code> 来访问Bookinfo应用</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-external-access.png"></p><h3 id="查看Dashboard"><a href="#查看Dashboard" class="headerlink" title="查看Dashboard"></a>查看Dashboard</h3><p>Istio集成了 <a href="https://istio.io/latest/docs/ops/integrations/" target="_blank" rel="external nofollow noopener noreferrer">一些</a> 遥测应用，他们可以帮助你对你的服务网格有直观的认识、展示网格的拓扑、分析网格的健康状态</p><ul><li>安装Kiali </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f samples/addons</span><br><span class="line">$ <span class="keyword">while</span> ! kubectl <span class="built_in">wait</span> --<span class="keyword">for</span>=condition=available --timeout=600s deployment/kiali -n istio-system; <span class="keyword">do</span> sleep 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>访问Kiali</li></ul><p>官方教程指示使用 <code>istioctl dashboard kiali</code> 命令来打开浏览器访问 Kiali服务，但是我的 Kubernetes 集群在服务器上，这样显然不行，不要将 Kiali 服务暴露给外部。因为之前集群已经安装了 Traefik ，所以可以使用 Ingress来暴露。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kiali</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/kiali</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kiali</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">20001</span></span><br></pre></td></tr></table></figure><p>在命令行创建Ingress，打开浏览器访问 <code>http://&lt;NodeIP&gt;:&lt;TraefikWebNodePort&gt;/kiali</code> 即可访问Kiali</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_traefik-kiali.png"></p><p>在左侧导航栏点击Graph，选择default的命名空间，可以看到 <code>Bookinfo</code> 应用中各个服务间的关系：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-kiali.png"></p><p>到此为止，你的Istio和相关的服务已经在集群中完好的部署，关于其具体功能演示，参照 <a href="../151719f0">Istio流量控制</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://istio.io/latest/docs/setup/getting-started" target="_blank" rel="external nofollow noopener noreferrer">https://istio.io/latest/docs/setup/getting-started</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Istio 是一个完全开源的服务网格，以透明的方式构建在现有的分布式应用中。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使你能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="istio" scheme="http://houmin.cc/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>【Service Mesh】开篇</title>
    <link href="http://houmin.cc/posts/ac3e3d15/"/>
    <id>http://houmin.cc/posts/ac3e3d15/</id>
    <published>2020-11-22T06:24:34.000Z</published>
    <updated>2020-11-27T02:46:55.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>Service Mesh 是一个<strong>基础设施层</strong>，用于处理<strong>服务到服务间</strong>的网络通信。<strong>云原生应用</strong>有着复杂的服务拓扑，Service Mesh负责在这些<strong>网络拓扑中实现请求的可靠传递</strong>。在实践中，Service Mesh通常实现为一组轻量级的<strong>网络代理</strong>，它们与应用程序部署在一起，但是<strong>对应用保持透明</strong>。</p></blockquote><p>本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。</p><a id="more"></a><h2 id="历史演进"><a href="#历史演进" class="headerlink" title="历史演进"></a>历史演进</h2><p>随着行业需求的推动，互联网服务从最早的仅有少数几台的大型服务器演变到成百上千的小型服务，服务架构也从最早期的单体式（Monolithic）到分布式（Distributed），再到微服务（Microservices）、容器化（Containerization）、容器编排（Container Orchestration），最后到服务网格（Service Mesh）、无服务器（Serverless）。</p><p>总结分布式系统的演进过程，我们可以看到一种通用的发展规律：</p><ul><li>首先是对每种情况提出临时解决方案</li><li>然后是更复杂的解决方案，类似于 library 以实现统一复用</li><li>随着对问题有更多的了解，开始将这些解决方案落实到 platform</li></ul><p>接下来我们会回顾从早期TCP/IP协议栈的广泛应用，到微服务时代从容器编排到服务网格的演进过程，并再次体会上述规律。</p><h3 id="计算机网络系统的演进"><a href="#计算机网络系统的演进" class="headerlink" title="计算机网络系统的演进"></a>计算机网络系统的演进</h3><p>从多台计算机开始通信以来，服务间通信是应用最为广泛的模式。以下图为例，ServiceA 和 ServiceB 可以是我们提供应用的服务端与客户端。在开发者开发这些服务的时候，需要借助底层的网络硬件和协议进行通信。这张图只是一个简化的师徒，省略了在代码操作的数据和通过线路发送接收的电信号之间转换的很多层。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc.png"></p><p>更加具体一点，把底层的网络协议栈加入，我们会看到下图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-svc2svc-stack.png"></p><p>从上世纪50年代起，上述的模型就一直在使用。最开始，由于计算机系统规模相对较小，每个节点之间的链路协议都是经过专门设计和维护的。随着计算机规模的迅速扩大，很多个小的网络系统开始连接起来。在这个过程中，不同主机间如何找到彼此，跨网络间如何路由转发，如何实现流量控制等问题，成了摆在网络系统设计人员面前亟需解决的难题。</p><p>为了实现各个网络节点的路由转发，屏蔽链路层协议，人们发明了IP网络协议。然而，IP网络协议还不能够解决流量控制的问题。这里的流量控制，值得是防止一台服务器发送过多的数据包，超出下游服务器的处理能力。在最开始，编写网络服务和应用程序的开发者来负责处理上述流量控制的问题。这就意味着在编写应用程序过程中，网络处理的逻辑和应用自身的业务逻辑被耦合在一起，如下图所示。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-flow-control.png"></p><p>然而，这种每个开发人员都要去考虑流量处理等传输层的问题太过复杂，程序开发的成本太高。随着技术的快速发展，流量处理和其他网络问题相关的解决方案被整合到网络协议栈，TCP/IP席卷了世界，成为互联网事实上的协议标准。流量控制等网络问题的代码仍在，但是你不再需要自己去开发与维护这段代码，而是直接调用系统提供的网络协议栈。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-tcp.png"></p><h3 id="微服务架构的演进"><a href="#微服务架构的演进" class="headerlink" title="微服务架构的演进"></a>微服务架构的演进</h3><p>确定于上世界80年代的TCP/IP网络协议栈和通用的网络模型对于互联网的发展发挥了巨大的作用，极大了促进了互联网应用的繁荣。网络应用的功能逐渐复杂起来，人们把所有的组件都集中在一个应用当中，这即是<code>单体应用 Monolithic</code>。单体应用基于相同技术栈开发、访问共享的数据库、共同部署运维和扩容。同时，组件之间的通信也趋于频繁和耦合，所有的交互都是以函数调用的形式来实现。</p><p>然而，随着互联网的迅猛发展，网络应用中需要添加越来越多的功能，应用的复杂度不断提升，参与软件开发的协作人数也越来越多，单体应用开始爆发出其固有局限性。在这种背景下，微服务的思潮降临，让软件开发重新变得小而美：</p><ul><li>单⼀职责：拆分后的单个微服务，通常只负责单个高内聚自闭环功能，因此很易于开发、理解和维护。</li><li>架构灵活：不同微服务应用之间在技术选型层面几乎是独立的，可以⾃由选择最适合的技术栈。</li><li>部署隔离：相比巨无霸单体应用，单个微服务应用的代码和产物体积大大减少，更容易持续集成和快速部署；同时，通过进程级别的隔离，也不再像单体应用一样只能同生共死，故障隔离效果显著提升。</li><li>独⽴扩展：单体应用时代，某个模块如果存在资源瓶颈（e.g. CPU/内存），只能跟随整个应用一起扩容，白白浪费很多资源。微服务化后，扩展的粒度细化到了微服务级别，可以更精确地按需独立扩展。</li></ul><p>然而，微服务也不是银弹，在微服务落地的过程中，也产生了很多的问题，其中主要的问题就是服务间通信：</p><ul><li><p><strong>如何找到服务的提供⽅？</strong></p><p>微服务通讯必须走远程过程调用（HTTP/REST本质上也属于RPC），当其中一个应用需要消费另一个应用的服务时，无法再像单体应用一样通过简单的进程内机制（e.g. Spring的依赖注入）就能获取到服务实例；你甚至都不知道有没有这个服务方。</p></li><li><p><strong>如何保证远程调⽤的可靠性?</strong></p><p>既然是RPC，那必然要走IP网络，而我们都知道网络（相比计算和存储）是软件世界里最不可靠的东西。虽然有TCP这种可靠传输协议，但频繁丢包、交换机故障甚至电缆被挖断也常有发生；即使网络是好的，如果对方机器宕机了，或者进程负载过高不响应呢？</p></li><li><p><strong>如何降低服务调⽤的延迟？</strong></p><p>网络不只是不可靠，还有延迟的问题。虽然相同系统内的微服务应用通常都部署在一起，同机房内调用延迟很小；但对于较复杂的业务链路，很可能一次业务访问就会包括数十次RPC调用，累积起来的延迟就很可观了。</p></li><li><p><strong>如何保证服务调⽤的安全性？</strong></p><p>网络不只是不可靠和有延迟，还是不安全的。互联网时代，你永远不知道屏幕对面坐的是人还是狗；同样，微服务间通讯时，如果直接走裸的通讯协议，你也永远不知道对端是否真的就是自己人，或者传输的机密信息是否有被中间人偷听。</p></li></ul><h4 id="服务通信：耦合业务逻辑"><a href="#服务通信：耦合业务逻辑" class="headerlink" title="服务通信：耦合业务逻辑"></a>服务通信：耦合业务逻辑</h4><p>就像历史总是会重演，为了解决上述微服务引入的问题，最早需要工程师独立去完成对应的服务，在业务逻辑中实现下列逻辑：</p><ul><li>服务发现（Service Discovery）：解决“我想调用你，如何找到你”的问题。</li><li>服务熔断（Circuit Breaker）：缓解服务之间依赖的不可靠问题。</li><li>负载均衡（Load Balancing）：通过均匀分配流量，让请求处理更加及时。</li><li>安全通讯：包括协议加密（TLS）、身份认证（证书/签名）、访问鉴权（RBAC）等</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service.png"></p><p>然而，随着分布式程度的增加，这些服务的复杂度也越来越高，一些问题不得不考虑：</p><ul><li>重复造轮子：需要编写和维护⼤量非功能性代码，如何集中精力专注业务创新?</li><li>与业务耦合：服务通讯逻辑与业务代码逻辑混在一起，动不动还会遇到点匪夷所思的分布式bug。</li></ul><h4 id="服务通信：独立Library"><a href="#服务通信：独立Library" class="headerlink" title="服务通信：独立Library"></a>服务通信：独立Library</h4><p>为了解决重复造轮子的问题，集成了服务通信中各种问题的Library开始变得十分流行，包括 Apache Dubbo（手动置顶）、Spring Cloud、Netflix OSS、gRPC 等等。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-micro-service-lib.png"></p><p>这些可复用的类库和框架，确确实实带来了质量和效率上的大幅提升，但是也存在着下列问题：</p><ul><li>并非完全透明：程序员们仍然需要正确理解和使⽤这些库，上手成本和出错概率依然很高。</li><li>限制技术选择：使用这些技术后，应用很容易就会被对应的语⾔和框架强绑定（vendor-lock）。</li><li>维护成本高：库版本升级，需要牵连应⽤一起重新构建和部署；麻烦不说，还要祈祷别出故障。</li></ul><h4 id="服务通信：Sidecar"><a href="#服务通信：Sidecar" class="headerlink" title="服务通信：Sidecar"></a>服务通信：Sidecar</h4><p>像网络协议栈发展的过程一样，将大规模分布式服务所需要的功能剥离出来集成到底层平台是一个众望所归的选择。人们通过应用层的协议(例如HTTP)写出了很多复杂的应用程序和服务，甚至不用考虑TCP是如何控制数据包在网络上传输的。这就是我们微服务所需要的，从事服务开发的工程师们可以专注于业务逻辑的开发，避免浪费时间去编写服务基础设施代码或者管理这些库和框架。</p><p>在这个想法下，我们可以得到类似于如下的图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-protocol.png"></p><p>不幸的是，更改协议栈来增加微服务的功能不是一个可行的方案，许多开发者是通过一组代理来实现此功能。这里的设计思想是<strong>服务不需要和下游服务直连，所有的流量都通过该代理透明的来实现对应的功能</strong>。这里的透明代理，通过一种叫做 <code>Sidecar</code> 的模式来运行，Sidecar将上述类库和框架要干的事情从应用中彻底剥离了出来，并统一下沉到了基础设施层，这其中的典型代表就是 Linkerd 和 Envoy。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-sidecar.png"></p><h4 id="服务通信：Service-Mesh"><a href="#服务通信：Service-Mesh" class="headerlink" title="服务通信：Service Mesh"></a>服务通信：Service Mesh</h4><p>在这种模型中，每个服务都会有一个配套的代理SideCar。考虑到服务之间的通信仅仅通过SideCar代理，我们最终得到如下的部署图：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data.png"></p><p>Buoyant的CEO William Morgan ，发现了各个SideCar代理之间互联组成了一个网状网络，<strong>2017初，William为这个网状的平台起了一个<a href="https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/" target="_blank" rel="external nofollow noopener noreferrer">“Service Mesh”的定义</a></strong>。</p><blockquote><p>Service Mesh是一个用于服务和服务之间通信的专用基础设施层。它负责服务请求能够在复杂的服务拓扑(组成了云原生应用)中可靠的进行投递。在实践中，Serivce Mesh的典型实现是作为轻量级网络代理阵列，部署在应用程序旁边，不需要业务进程感知到。</p></blockquote><p>William关于Service Mesh的定义中，最有说服力的一点是，他不再将SideCar代理视为一个独立组件，而是承认了<strong>它们组成的网络像它们自身一样是有价值的</strong></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-data2.png"></p><p>随着很多公司将它们的微服务部署到更复杂的系统运行环境中，例如Kubernetes和Mesos，人们开始使用这些平台提供的工具来实现合适的Serivce Mesh的想法。它们将独立的SideCar代理从独立的工作环境中转移到一个适当的，有集中的控制面。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control.png"></p><p>看下我们的鸟瞰图，服务之间的流量仍然是通过SideCar代理来进行转发，但是控制平面知道每个SideCar实例。控制平面能够让代理实现例如访问控制，指标收集等需要协作完成的事情。Istio是这个模型的典型实现。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh-control2.png"> </p><h2 id="主流实现"><a href="#主流实现" class="headerlink" title="主流实现"></a>主流实现</h2><p>Service Mesh 的主流实现包括：</p><ul><li>Linkerd：背后公司是Buoyant，开发语⾔使用Scala，2016年1⽉15日初次发布，2017年1⽉23日加入CNCF。</li><li>Envoy：背后公司是Lyft，开发语言使用C++ 11，2016年9月13日初次发布，2017年9⽉14日加⼊CNCF。</li><li>Istio：背后公司是Google和IBM，开发语言使用Go，2017年5⽉月10日初次发布。</li><li>Conduit：背后公司也是Buoyant，开发语言使用Rust和Go，2017年12月5日初次发布，现在已经加入了 <code>Linkerd</code> 项目。</li></ul><h3 id="Linkerd"><a href="#Linkerd" class="headerlink" title="Linkerd"></a>Linkerd</h3><p>现在（2020.09.08） <code>Linkerd</code> 已经发展到 2.8 版本，由控制面和数据面组成，详情可以参考 <a href="https://linkerd.io/2/reference/architecture/" target="_blank" rel="external nofollow noopener noreferrer">这里</a></p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_linkerd-control-plane.png"></p><h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p>Envoy是一个高性能的Service Mesh软件，现在主要被用于数据面作为 Sidecar 代理，详情可以参考 <a href="../7beb34d2/">这里</a></p><p><img alt data-src="https://cdn.jsdelivr.net/gh/yangchuansheng/imghosting/img/20200504160047.png"></p><h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Istio是第二代 Service Mesh，第一次提出控制面的概念，详情可以参考 <a href="../22cae0b8/">这里</a></p><p><img alt="Istio Arch" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-10_istio-arch.svg"></p><h3 id="NginMesh"><a href="#NginMesh" class="headerlink" title="NginMesh"></a>NginMesh</h3><p>Service Mesh 最基础的功能毕竟是 sidecar proxy. 提到 proxy 怎么能够少了 nginx? 我想nginx自己也是这么想的吧 毫不意外，nginx也推出了其 service mesh 的开源实现：nginMesh.</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_nginx-sidecar.png"></p><p>不过，与 William Morgan 的死磕策略不同，nginMesh 从一开始就没有想过要做一套完整的第二代Service Mesh 开源方案，而是直接宣布兼容Istio, 作为Istio的 sidecar proxy. 由于 nginx 在反向代理方面广泛的使用，以及运维技术的相对成熟，nginMesh在sidecar proxy领域应该会有一席之地。</p><h2 id="对比Kubernetes原生架构"><a href="#对比Kubernetes原生架构" class="headerlink" title="对比Kubernetes原生架构"></a>对比Kubernetes原生架构</h2><h3 id="Kube-proxy-vs-Sidecar"><a href="#Kube-proxy-vs-Sidecar" class="headerlink" title="Kube-proxy vs Sidecar"></a>Kube-proxy vs Sidecar</h3><p>下图展示的是 Kubernetes 与 Service Mesh 中的的服务访问关系：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_k8s-vs-service-mesh.png"></p><ul><li>Kubernetes 集群的每个节点都部署了一个 <code>kube-proxy</code> 组件，该组件会与 Kubernetes API Server 通信，获取集群中的 <code>Service</code> 信息，然后设置 iptables 规则，直接将对某个 <code>Service</code> 的请求发送到对应的 Endpoint（属于同一组 <code>Service</code> 的 <code>Pod</code>）上。</li><li>Kube-proxy 实现了流量在 Kubernetes <code>Service</code> 多个 <code>Pod</code> 实例间的负载均衡，但是如何对这些 <code>Service</code> 间的流量做细粒度的控制，比如按照百分比划分流量到不同的应用版本（这些应用都属于同一个 <code>Service</code>，但位于不同的 deployment 上），做金丝雀发布（灰度发布）和蓝绿发布？Kubernetes 社区给出了 <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="external nofollow noopener noreferrer">使用 Deployment 做金丝雀发布的方法</a>，该方法本质上就是通过修改 <code>Pod</code> 的 label 来将不同的 <code>Pod</code> 划归到 Deployment 的 <code>Service</code> 上。</li></ul><p><code>kube-proxy</code> 的设置都是全局生效的，无法对每个服务做细粒度的控制，而 <code>Service Mesh</code> 通过 <code>Sidecar</code> proxy 的方式将 Kubernetes 中对流量的控制从 <code>Service</code> 一层抽离出来，可以做更多的扩展。</p><h3 id="Ingress-vs-Gateway"><a href="#Ingress-vs-Gateway" class="headerlink" title="Ingress vs Gateway"></a>Ingress vs Gateway</h3><p> <code>kube-proxy</code> 只能路由 Kubernetes 集群内部的流量，而我们知道 Kubernetes 集群的 <code>Pod</code> 位于 CNI 创建的外网络中，集群外部是无法直接与其通信的，因此 Kubernetes 中创建了 Ingress 这个资源对象，它由位于 Kubernetes 边缘节点（这样的节点可以是很多个也可以是一组）的 Ingress controller 驱动，负责管理 <strong>南北向流量</strong>，Ingress 必须对接各种 Ingress Controller 才能使用，比如 <a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>、<a href="https://traefik.io/" target="_blank" rel="external nofollow noopener noreferrer">traefik</a>。</p><ul><li>Ingress 只适用于 HTTP 流量，使用方式也很简单，只能对 <code>Service</code>、port、HTTP 路径等有限字段匹配来路由流量，这导致它无法路由如 MySQL、Redis 和各种私有 RPC 等 TCP 流量。</li><li>要想直接路由南北向的流量，只能使用 <code>Service</code> 的 LoadBalancer 或 NodePort，前者需要云厂商支持，后者需要进行额外的端口管理。</li><li>有些 Ingress controller 支持暴露 TCP 和 UDP 服务，但是只能使用 <code>Service</code> 来暴露，Ingress 本身是不支持的，例如 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/" target="_blank" rel="external nofollow noopener noreferrer">nginx ingress controller</a>，服务暴露的端口是通过创建 ConfigMap 的方式来配置的。</li></ul><p><code>Istio</code> Gateway 的功能与 Kubernetes Ingress 类似，都是负责集群的南北向流量。<code>Istio</code> <code>Gateway</code> 描述的负载均衡器用于承载进出网格边缘的连接。该规范中描述了一系列开放端口和这些端口所使用的协议、负载均衡的 SNI 配置等内容。Gateway 是一种 CRD 扩展，它同时复用了 <code>Sidecar</code> proxy 的能力，详细配置请参考 <a href="https://istio.io/docs/reference/config/networking/gateway/" target="_blank" rel="external nofollow noopener noreferrer">Istio 官网</a>。</p><h2 id="落地问题"><a href="#落地问题" class="headerlink" title="落地问题"></a>落地问题</h2><p>服务网格的出现带来的变革：</p><p>第一，<strong>微服务治理与业务逻辑的解耦</strong>。服务网格把 SDK 中的<strong>大部分</strong>能力从应用中剥离出来，拆解为独立进程，以 Sidecar 的模式进行部署。服务网格通过将服务通信及相关管控功能从业务程序中分离并下沉到基础设施层，使其和业务系统完全解耦，使开发人员更加专注于业务本身。</p><blockquote><p>注意，这里提到了一个词“大部分”，SDK 中往往还需要保留<strong>协议编解码</strong>的逻辑，甚至在某些场景下还需要一个轻量级的 SDK 来实现细粒度的治理与监控策略。例如，要想实现方法级别的调用链追踪，服务网格则需要业务应用实现 trace ID 的传递，而这部分实现逻辑也可以通过轻量级的 SDK 实现。因此，从代码层面来讲，服务网格并非是零侵入的。</p></blockquote><p>第二，<strong>异构系统的统一治理</strong>。随着新技术的发展和人员更替，在同一家公司中往往会出现不同语言、不同框架的应用和服务，为了能够统一管控这些服务，以往的做法是为每种语言、每种框架都开发一套完整的 SDK，维护成本非常之高，而且给公司的中间件团队带来了很大的挑战。有了服务网格之后，通过将主体的服务治理能力下沉到基础设施，多语言的支持就轻松很多了。只需要提供一个非常轻量级的 SDK，甚至很多情况下都不需要一个单独的 SDK，就可以方便地实现多语言、多协议的统一流量管控、监控等需求。</p><p>此外，服务网格相对于传统微服务框架，还拥有三大技术优势：</p><ul><li>可观察性。因为服务网格是一个专用的基础设施层，所有的服务间通信都要通过它，所以它在技术堆栈中处于独特的位置，以便在服务调用级别上提供统一的遥测指标。这意味着，所有服务都被监控为“黑盒”。服务网格捕获诸如来源、目的地、协议、URL、状态码、延迟、持续时间等线路数据。这本质上等同于 web 服务器日志可以提供的数据，但是服务网格可以为所有服务捕获这些数据，而不仅仅是单个服务的 web 层。需要指出的是，收集数据仅仅是解决微服务应用程序中可观察性问题的一部分。存储与分析这些数据则需要额外能力的机制的补充，然后作用于警报或实例自动伸缩等。</li><li>流量控制。通过 <code>Service Mesh</code>，可以为服务提供智能路由（蓝绿部署、金丝雀发布、A/B test）、超时重试、熔断、故障注入、流量镜像等各种控制能力。而以上这些往往是传统微服务框架不具备，但是对系统来说至关重要的功能。例如，服务网格承载了微服务之间的通信流量，因此可以在网格中通过规则进行故障注入，模拟部分微服务出现故障的情况，对整个应用的健壮性进行测试。由于服务网格的设计目的是有效地将来源请求调用连接到其最优目标服务实例，所以这些流量控制特性是“面向目的地的”。这正是服务网格流量控制能力的一大特点。</li><li>安全。在某种程度上，单体架构应用受其单地址空间的保护。然而，一旦单体架构应用被分解为多个微服务，网络就会成为一个重要的攻击面。更多的服务意味着更多的网络流量，这对黑客来说意味着更多的机会来攻击信息流。而服务网格恰恰提供了保护网络调用的能力和基础设施。服务网格的安全相关的好处主要体现在以下三个核心领域：服务的认证、服务间通讯的加密、安全相关策略的强制执行。</li></ul><p>服务网格带来了巨大变革并且拥有其强大的技术优势，被称为第二代“微服务架构”。然而就像之前说的软件开发没有银弹，传统微服务架构有许多痛点，而服务网格也不例外，也有它的局限性。</p><ul><li>增加了复杂度。服务网格将 <code>Sidecar</code> 代理和其它组件引入到已经很复杂的分布式环境中，会极大地增加整体链路和操作运维的复杂性。</li><li>运维人员需要更专业。在容器编排器（如 Kubernetes）上添加 <code>Istio</code> 之类的服务网格，通常需要运维人员成为这两种技术的专家，以便充分使用二者的功能以及定位环境中遇到的问题。</li><li>延迟。从链路层面来讲，服务网格是一种侵入性的、复杂的技术，可以为系统调用增加显著的延迟。这个延迟是毫秒级别的，但是在特殊业务场景下，这个延迟可能也是难以容忍的。</li><li>平台的适配。服务网格的侵入性迫使开发人员和运维人员适应高度自治的平台并遵守平台的规则。</li></ul><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>展望未来，Kubernetes 正在爆炸式发展，它已经成为企业绿地应用的容器编排的首选。如果说 Kubernetes 已经彻底赢得了市场，并且基于 Kubernetes 的应用程序的规模和复杂性持续增加，那么就会有一个临界点，而服务网格则将是有效管理这些应用程序所必需的。随着服务网格技术的持续发展，其实现产品（如 <code>Istio</code>）的架构与功能的不断优化，服务网格将完全取代传统微服务架构，成为大小企业微服务化和上云改造的首选架构。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="external nofollow noopener noreferrer">https://philcalcado.com/2017/08/03/pattern_service_mesh.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Service Mesh 是一个&lt;strong&gt;基础设施层&lt;/strong&gt;，用于处理&lt;strong&gt;服务到服务间&lt;/strong&gt;的网络通信。&lt;strong&gt;云原生应用&lt;/strong&gt;有着复杂的服务拓扑，Service Mesh负责在这些&lt;strong&gt;网络拓扑中实现请求的可靠传递&lt;/strong&gt;。在实践中，Service Mesh通常实现为一组轻量级的&lt;strong&gt;网络代理&lt;/strong&gt;，它们与应用程序部署在一起，但是&lt;strong&gt;对应用保持透明&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文作为 「Service Mesh」系列开篇，将理清 Service Mesh 的前世今生，通过对其概念与原理的理解，开始上手 Service Mesh的工作。与此同时，我们也会讨论 Service Mesh 在业界当前的应用现状，探讨其落地的难点与痛点。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-09-08_service-mesh.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="service" scheme="http://houmin.cc/tags/service/"/>
    
      <category term="service mesh" scheme="http://houmin.cc/tags/service-mesh/"/>
    
      <category term="sidecar" scheme="http://houmin.cc/tags/sidecar/"/>
    
  </entry>
  
  <entry>
    <title>めぐる季节</title>
    <link href="http://houmin.cc/posts/b0b2b640/"/>
    <id>http://houmin.cc/posts/b0b2b640/</id>
    <published>2020-11-21T11:23:16.000Z</published>
    <updated>2020-11-26T13:36:14.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>经过立冬后的一夜冬雨，北京城满地黄叶堆积，下班路上被冻进口袋的双手真真切地告诉我：冬天真的来了。经过一周的工作，今年冬天的初雪如约而至，这里是2020年「朝花夕拾」第二十五期 <code>めぐる季节</code>，在季节转换间我们继续。</p>    <div id="aplayer-edYsorYn" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="445063" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>又是一年的初雪，本来想着今天去城内好好拍照的，想着在家吃完火锅再去，结果吃完雪已经停了，「小雪」真的名不虚传。很可惜，二十四节气的小雪这次搁置，下次这种机会一定要提前准备，有备无患。毕竟，你在北京呆的时间也没有多少时间了，要抓住每一次机会。</p><p>按照惯例，我们继续每周的数据总结，首先是 <code>RescueTime</code>：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_rescue-time.png"></p><ul><li>精力分散的时间里面，依然是企业微信消耗的时间占比最多。大家都知道工作时间被碎片化是一件非常难受的事情，好不容易进入某项工作的 <code>context</code>，又被企业微信/钉钉等工具打扰，上下文切换耗时太长。相比之下，还是更喜欢邮件一点，因为大家也不期待你能够及时回复，在一段时间内你可以专注你自己的事情。想到一个改进措施，每天花固定的时间来解决需要企业微信来进行沟通相关的事情，比如<code>11:30</code>、<code>5:30</code> 那会，所有要沟通的事情统一解决，下周看看效果。</li><li>相比于上周，这个周末的分散时间好多了，因为周末在学习GPU相关的内容，这也导致这篇「朝花夕拾」晚了四天</li><li>漫无目的刷手机的情况还存在，在改善中，手机知乎就不应该存在，知乎是碰到问题去搜索的，现在推送质量太差，平时阅读可以靠微信公众号和RSS订阅，这周入手了Kindle，是天然的RSS阅读器</li></ul><p>谷歌日历的每天总结还是没跟上，IFFT在印象笔记上的每日总结推送还在继续，下周加上这个维度的总结监测。接下来是Forest专注时间观察，现在对于 <code>Forest</code> 的使用还是太随意化了，每次要专注的时候有时候会忘记种树，还有的时候会去用手机。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_forest.jpg"></p><p>接下来是跑步数据，相比上周的只有一次跑步，这周一周三次跑步算得上一种进步了，但是真正的跑步习惯还没形成，跑步的时候也算不得轻松自在一路坚持下来，下周要继续。毕竟体脂还是有点高的，坚持减肥感受一下自己能够瘦到什么地步。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_running.jpg"></p><p>睡眠数据还没有进入统计，争取下周前能够把这套数据系统搭建起来，不论是购买新的硬件还是基于当前硬件挖数据。</p><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h3 id="区域全面经济合作协定"><a href="#区域全面经济合作协定" class="headerlink" title="区域全面经济合作协定"></a>区域全面经济合作协定</h3><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-15-rcep.jpg"></p><h3 id="华为出售荣耀"><a href="#华为出售荣耀" class="headerlink" title="华为出售荣耀"></a>华为出售荣耀</h3><h3 id="信用债"><a href="#信用债" class="headerlink" title="信用债"></a>信用债</h3><h3 id="蛋壳公寓暴雷"><a href="#蛋壳公寓暴雷" class="headerlink" title="蛋壳公寓暴雷"></a>蛋壳公寓暴雷</h3><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过立冬后的一夜冬雨，北京城满地黄叶堆积，下班路上被冻进口袋的双手真真切地告诉我：冬天真的来了。经过一周的工作，今年冬天的初雪如约而至，这里是2020年「朝花夕拾」第二十五期 &lt;code&gt;めぐる季节&lt;/code&gt;，在季节转换间我们继续。&lt;/p&gt;

    &lt;div id=&quot;aplayer-edYsorYn&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;445063&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_snow.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="小雪" scheme="http://houmin.cc/tags/%E5%B0%8F%E9%9B%AA/"/>
    
      <category term="RECP" scheme="http://houmin.cc/tags/RECP/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】GPU 共享</title>
    <link href="http://houmin.cc/posts/cf391335/"/>
    <id>http://houmin.cc/posts/cf391335/</id>
    <published>2020-11-18T03:11:07.000Z</published>
    <updated>2020-12-08T02:24:52.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>原生的 k8s 基于 <code>Device Plugin</code> 和 <code>Extended Resource</code> 机制实现了在容器中使用GPU，但是只支持GPU的独占使用，不允许在Pod间共享GPU，这大大降低了对集群中GPU的利用率。为了在集群层面共享GPU，我们需要实现GPU资源的隔离与调度，本文将依次介绍阿里的 <a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender" target="_blank" rel="external nofollow noopener noreferrer">GPUShare</a> 与腾讯的 <a href="https://github.com/tkestack/gpu-manager" target="_blank" rel="external nofollow noopener noreferrer">GPUManager</a>，分析其实现机制。</p><a id="more"></a><h2 id="阿里GPUShare"><a href="#阿里GPUShare" class="headerlink" title="阿里GPUShare"></a>阿里GPUShare</h2><p>阿里的 <a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender" target="_blank" rel="external nofollow noopener noreferrer">GPUShare</a> 基于 <a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external nofollow noopener noreferrer">Nvidia Docker2</a> 和他们的 <a href="https://docs.google.com/document/d/1ZgKH_K4SEfdiE_OfxQ836s4yQWxZfSjS288Tq9YIWCA/edit#heading=h.r88v2xgacqr" target="_blank" rel="external nofollow noopener noreferrer">gpu sharing design</a> 设计而实现的，为了使用阿里的GPUShare，首先需要配置Node上的 Docker Runtime 并安装 <code>NVIDIA Docker 2</code>，具体过程可以参考 <a href="../574111db">在Docker中使用GPU</a>。</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="假设条件"><a href="#假设条件" class="headerlink" title="假设条件"></a>假设条件</h4><ul><li>尽管GPU可以从 CUDA Cores 和 GPU Memory 两个维度来衡量GPU的能力，<strong>在推理的场景，我们可以假定CUDA core的数量和GPU  Memory的大小是成比例的</strong></li><li>在模型开发和推理的场景下，<strong>用户申请的GPU资源不超过1个GPU，也就是说 resource limit 是 一个GPU</strong></li><li>每个Node上所有卡的GPU Memory相同，这样可以通过 <code>gpuTotalMemory</code> 和 <code>gpuTotalCount</code> 算出Node上每张卡的GPU Memory</li></ul><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li><p>设计里定义了两种 <code>Extended Resource</code>：</p><ul><li><code>aliyun.com/gpu-mem</code>： 单位从 <code>number of GPUs</code> 变更为 <code>amount of GPU memory in MiB</code>，如果一个Node有多个GPU设备，这里计算的是总的GPU Memory</li><li><code>aliyun.com/gpu-count</code>：对应于Node上的GPU 设备的数目</li></ul></li><li>基于k8s原生的Scheduler Extender、Extended Resource、DevicePlugin机制来实现</li><li>这个方案只实现GPU的共享，不实现算力和显存的隔离，如果想实现隔离，在阿里云可以搭配 <a href="https://www.alibabacloud.com/help/zh/doc-detail/163994.htm" target="_blank" rel="external nofollow noopener noreferrer">cGPU</a> 一起使用</li></ul><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>下图是整个设计的核心组件：</p><ul><li>GPU Share Scheduler Extender：基于k8s scheduler extender机制，作用于调度过程的<code>Filter</code>和<code>Bind</code>阶段，用于决定某个Node上的一个GPU设备是否可以提供足够的GPU Memory，并将GPU分配的结果记录到Pod Spec 的 Annotation中</li><li>GPU Share Device Plugin：基于k8s device plugin机制，根据GPU Share Scheduler Extender记录在Pod Spec的Annotation，实现GPU 设备的 Allocation。</li></ul><p><img alt="GPU Share Design" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_aliyun-gpu-share.jpg"></p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="设备资源报告"><a href="#设备资源报告" class="headerlink" title="设备资源报告"></a>设备资源报告</h4><p><code>GPU Share Device Plugin</code> 基于 <code>nvml</code> 库来查询每个Node上GPU设备的数目和每个GPU设备的GPU Memory。</p><p>这些资源状况被通过 <code>ListAndWatch()</code> 汇报给 Kubelet，然后 kubelet 会上报给 APIServer，这时候执行 <code>kubectl get node</code> 可以看到在 <code>status</code> 看到相关的<code>Extended Resource</code>字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">gpushare:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">172.16</span><span class="number">.1</span><span class="number">.0</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.16</span><span class="number">.1</span><span class="number">.0</span><span class="string">/26</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">qcloud:///800002/ins-hsmsc4x9</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">allocatable:</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-count:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-mem:</span> <span class="string">"22"</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">5926m</span></span><br><span class="line">    <span class="attr">ephemeral-storage:</span> <span class="string">"47438316671"</span></span><br><span class="line">    <span class="attr">hugepages-2Mi:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">54222084Ki</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-count:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">aliyun.com/gpu-mem:</span> <span class="string">"22"</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"6"</span></span><br><span class="line">    <span class="attr">ephemeral-storage:</span> <span class="string">51473868Ki</span></span><br><span class="line">    <span class="attr">hugepages-2Mi:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">57448708Ki</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><h4 id="调度插件扩展"><a href="#调度插件扩展" class="headerlink" title="调度插件扩展"></a>调度插件扩展</h4><p>用户申请GPU的时候，在 Extended Resource 中只填写 <code>gpu-mem</code>，下面部署一个单机版的Tensorflow：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8888</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">            <span class="attr">aliyun.com/gpu-mem:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">jupyter-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8888</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br></pre></td></tr></table></figure><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><p>当kube-scheduler运行完所有的Filter函数后，就会调用 <code>GPU Share Extender</code> 的 Filter 函数。在原生的过滤中，kube-scheduler会计算是否有足够的Extended Resource（算的是总共的GPU Memory），但是不能知道是否某个GPU设备有足够的资源，这时候就需要调度器插件来实现。以下图为例：</p><ul><li>用户申请了8138MiB的GPU Memory，对于原生调度器，N1节点只剩下  (16276 * 2 - 16276 - 12207 = 4069) 的GPU资源，不满足 Extended Resource可用的条件，N1节点被过滤掉</li><li>接下来的N2节点和N3节点剩余的总的资源数都有8138MiB，那么该选择哪一个呢</li><li>在 <code>GPU Share Extender</code> 的过滤中，他需要找到有单个GPU能够满足用户申请的资源，当检查到N2节点的时候，发现虽然总的GPU Memory有8138MiB，但是每个GPU设备都只剩4096MiB了，不能满足单设备8138的需求，所以N2被过滤掉</li><li>扫描到N3节点，发现GPU0满足8138MiB的需求，符合要求</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_aliyun-gpu-share-filter.jpg"></p><blockquote><p><strong>这里有一个问题：当一个Node上有多张卡的时候，Scheduler Extender是如何知道每张卡当前可用的Capacity的呢？</strong></p></blockquote><p>我们看一下Extender在 Filter 阶段执行的函数，对于要创建的Pod，当前Node检查自己拥有的所有可用GPU，一旦有一个GPU的可用显存大于申请的显存，那么当前Node是可以被调度的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if the pod can be allocated on the node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">Assume</span><span class="params">(pod *v1.Pod)</span> <span class="params">(allocatable <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">allocatable = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">n.rwmu.RLock()</span><br><span class="line"><span class="keyword">defer</span> n.rwmu.RUnlock()</span><br><span class="line"></span><br><span class="line">availableGPUs := n.getAvailableGPUs()</span><br><span class="line">reqGPU := <span class="keyword">uint</span>(utils.GetGPUMemoryFromPodResource(pod))</span><br><span class="line">log.Printf(<span class="string">"debug: AvailableGPUs: %v in node %s"</span>, availableGPUs, n.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(availableGPUs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> devID := <span class="number">0</span>; devID &lt; <span class="built_in">len</span>(n.devs); devID++ &#123;</span><br><span class="line">availableGPU, ok := availableGPUs[devID]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">if</span> availableGPU &gt;= reqGPU &#123;</span><br><span class="line">allocatable = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> allocatable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的一个问题是，每个Node可用的GPU显存是如何得到的呢？我们进入到 <code>getAvailableGPUs</code> 继续看：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">getAvailableGPUs</span><span class="params">()</span> <span class="params">(availableGPUs <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">allGPUs := n.getAllGPUs()</span><br><span class="line">usedGPUs := n.getUsedGPUs()</span><br><span class="line">unhealthyGPUs := n.getUnhealthyGPUs()</span><br><span class="line">availableGPUs = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> id, totalGPUMem := <span class="keyword">range</span> allGPUs &#123;</span><br><span class="line"><span class="keyword">if</span> usedGPUMem, found := usedGPUs[id]; found &#123;</span><br><span class="line">availableGPUs[id] = totalGPUMem - usedGPUMem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: available GPU list %v before removing unhealty GPUs"</span>, availableGPUs)</span><br><span class="line"><span class="keyword">for</span> id, _ := <span class="keyword">range</span> unhealthyGPUs &#123;</span><br><span class="line">log.Printf(<span class="string">"info: delete dev %d from availble GPU list"</span>, id)</span><br><span class="line"><span class="built_in">delete</span>(availableGPUs, id)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: available GPU list %v after removing unhealty GPUs"</span>, availableGPUs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> availableGPUs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Scheduler Extender</code> 内部维护了当前Node上所有的GPU显存状态和已经用了的GPU显存状态信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// device index: gpu memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">getUsedGPUs</span><span class="params">()</span> <span class="params">(usedGPUs <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">usedGPUs = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> n.devs &#123;</span><br><span class="line">usedGPUs[dev.idx] = dev.GetUsedGPUMemory()</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: getUsedGPUs: %v in node %s, and devs %v"</span>, usedGPUs, n.name, n.devs)</span><br><span class="line"><span class="keyword">return</span> usedGPUs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// device index: gpu memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">getAllGPUs</span><span class="params">()</span> <span class="params">(allGPUs <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">allGPUs = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> n.devs &#123;</span><br><span class="line">allGPUs[dev.idx] = dev.totalGPUMem</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"info: getAllGPUs: %v in node %s, and dev %v"</span>, allGPUs, n.name, n.devs)</span><br><span class="line"><span class="keyword">return</span> allGPUs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>GetUsedGPUMemory</code>，是<code>Scheduler Extender</code> 内部维护的 <code>DeviceInfo</code> 所记录的，这里的 <code>d.podMap</code> 会在每次Extender执行 <code>Bind</code> 的时候，将对应的Pod添加到对应的Node上的 <code>DeviceInfo</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DeviceInfo)</span> <span class="title">GetUsedGPUMemory</span><span class="params">()</span> <span class="params">(gpuMem <span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"debug: GetUsedGPUMemory() podMap %v, and its address is %p"</span>, d.podMap, d)</span><br><span class="line">d.rwmu.RLock()</span><br><span class="line"><span class="keyword">defer</span> d.rwmu.RUnlock()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> d.podMap &#123;</span><br><span class="line"><span class="keyword">if</span> pod.Status.Phase == v1.PodSucceeded || pod.Status.Phase == v1.PodFailed &#123;</span><br><span class="line">log.Printf(<span class="string">"debug: skip the pod %s in ns %s due to its status is %s"</span>, pod.Name, pod.Namespace, pod.Status.Phase)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gpuMem += utils.GetGPUMemoryFromPodEnv(pod)</span></span><br><span class="line">gpuMem += utils.GetGPUMemoryFromPodAnnotation(pod)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gpuMem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再总结总结，本质上是 <code>Scheduler Extender</code> 维护了一个 <code>devs</code> 这么一个数据结构，使得它可以知道当前Node上每个GPU设备的显存状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeInfo is node level aggregated information.</span></span><br><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">name           <span class="keyword">string</span></span><br><span class="line">node           *v1.Node</span><br><span class="line">devs           <span class="keyword">map</span>[<span class="keyword">int</span>]*DeviceInfo</span><br><span class="line">gpuCount       <span class="keyword">int</span></span><br><span class="line">gpuTotalMemory <span class="keyword">int</span></span><br><span class="line">rwmu           *sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，我们通过ApiServer，只能知道对应Node上的 <code>gpuCount</code> 和 <code>gpuTotalMemory</code>，而不知道每张卡各自的显存的。这个 <code>devs</code> 是怎么初始化得到每张卡的显存信息呢的呢？继续看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create Node Level</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNodeInfo</span><span class="params">(node *v1.Node)</span> *<span class="title">NodeInfo</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"debug: NewNodeInfo() creates nodeInfo for %s"</span>, node.Name)</span><br><span class="line"></span><br><span class="line">devMap := <span class="keyword">map</span>[<span class="keyword">int</span>]*DeviceInfo&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; utils.GetGPUCountInNode(node); i++ &#123;</span><br><span class="line">devMap[i] = newDeviceInfo(i, <span class="keyword">uint</span>(utils.GetTotalGPUMemory(node)/utils.GetGPUCountInNode(node)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(devMap) == <span class="number">0</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"warn: node %s with nodeinfo %v has no devices"</span>,</span><br><span class="line">node.Name,</span><br><span class="line">node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;NodeInfo&#123;</span><br><span class="line">name:           node.Name,</span><br><span class="line">node:           node,</span><br><span class="line">devs:           devMap,</span><br><span class="line">gpuCount:       utils.GetGPUCountInNode(node),</span><br><span class="line">gpuTotalMemory: utils.GetTotalGPUMemory(node),</span><br><span class="line">rwmu:           <span class="built_in">new</span>(sync.RWMutex),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>这里在初始化的时候，默认设定每张GPU卡的显存大小一样，通过平均得到每张卡的心存信息。</strong></p><h5 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h5><ul><li>当调度器发现有Node符合要求，这时候会把Pod和Node Bind到一起，<code>GPU Share Extender</code> 需要做两件事情：<ul><li>根据 <code>binpack</code> 原则找到Node上对应的GPU设备，并将 GPU Device ID记录到 Pod的 Annotation中 <code>ALIYUN_GPU_ID</code>。他也会将Pod使用的GPU Memory记录到Pod Annotation中：<code>ALIYUN_COM_GPU_MEM_POD</code> 和 <code>ALIYUN_COM_GPU_MEM_ASSUME_TIME</code></li><li>Bind the Node and Pod with kubernetes API</li></ul></li><li>如果没有找到合适的Node符合要求，那么就不会做Bind操作</li></ul><p>以下图为例，N1中有4个GPU，其中GPU0（12207），GPU1（8138）、GPU2（4069）和GPU3（16276）, GPU2因为资源不够被过滤掉，剩下的3个GPU根据 Binpack 原则，我们选用GPU1（图里面 Annotation错了，不是0，而是1）</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_aliyun-gpu-share-bind.jpg"></p><p>我们看一看在找GPU设备的时候是如何操作的，可以看到这里通过 <code>candidateGPUMemory &gt; availableGPU</code> 这里实现了 <code>binpack</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate the GPU ID to the pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NodeInfo)</span> <span class="title">allocateGPUID</span><span class="params">(pod *v1.Pod)</span> <span class="params">(candidateDevID <span class="keyword">int</span>, found <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">reqGPU := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line">found = <span class="literal">false</span></span><br><span class="line">candidateDevID = <span class="number">-1</span></span><br><span class="line">candidateGPUMemory := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line">availableGPUs := n.getAvailableGPUs()</span><br><span class="line"></span><br><span class="line">reqGPU = <span class="keyword">uint</span>(utils.GetGPUMemoryFromPodResource(pod))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reqGPU &gt; <span class="keyword">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">log.Printf(<span class="string">"info: reqGPU for pod %s in ns %s: %d"</span>, pod.Name, pod.Namespace, reqGPU)</span><br><span class="line">log.Printf(<span class="string">"info: AvailableGPUs: %v in node %s"</span>, availableGPUs, n.name)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(availableGPUs) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> devID := <span class="number">0</span>; devID &lt; <span class="built_in">len</span>(n.devs); devID++ &#123;</span><br><span class="line">availableGPU, ok := availableGPUs[devID]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">if</span> availableGPU &gt;= reqGPU &#123;</span><br><span class="line"><span class="keyword">if</span> candidateDevID == <span class="number">-1</span> || candidateGPUMemory &gt; availableGPU &#123;</span><br><span class="line">candidateDevID = devID</span><br><span class="line">candidateGPUMemory = availableGPU</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">found = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line">log.Printf(<span class="string">"info: Find candidate dev id %d for pod %s in ns %s successfully."</span>,</span><br><span class="line">candidateDevID,</span><br><span class="line">pod.Name,</span><br><span class="line">pod.Namespace)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"warn: Failed to find available GPUs %d for the pod %s in the namespace %s"</span>,</span><br><span class="line">reqGPU,</span><br><span class="line">pod.Name,</span><br><span class="line">pod.Namespace)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> candidateDevID, found</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kubelet创建Pod"><a href="#Kubelet创建Pod" class="headerlink" title="Kubelet创建Pod"></a>Kubelet创建Pod</h4><p>接下来由Kubelet在创建container前调用 <code>GPU Share Device Plugin</code> 的 <code>Allocate</code> 函数，参数是申请的GPU Memory的数量。</p><p>Pod运行成功后，执行 <code>kubectl get pod</code> 可以看到：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_ASSIGNED:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_ASSUME_TIME:</span> <span class="string">"1606125285243248618"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_DEV:</span> <span class="string">"22"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_IDX:</span> <span class="string">"0"</span></span><br><span class="line">    <span class="attr">ALIYUN_COM_GPU_MEM_POD:</span> <span class="string">"3"</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><ul><li><p>Device Plugin 从 k8s apiserver 拿到所有Pending的Pod中属于GPU Share的Pod，并且按照 AssumedTimestamp排序</p></li><li><p>选择符合Allocation传入的GPU Memory的Pod，如果有多个，选择最早的那个Pod</p></li><li><p>标记 <code>ALIYUN_COM_GPU_MEM_ASSIGNED</code> 为 True</p></li><li><p>把 DeviceID 作为下NVIDIA_VISIBLE_DEVICES环境变量告诉 Nvidia Docker2，并且创建容器</p></li></ul><p><img alt data-src="https://github.com/AliyunContainerService/gpushare-scheduler-extender/raw/master/docs/designs/sequence.jpg"></p><blockquote><p><strong>这里问题是device plugin的allocate接口参数是什么，是否包含pod信息，是否包含pod annotation？</strong></p></blockquote><p>查看 Device Plugin 的代码，这一个申请的GPU Memory的数量让我很疑惑，为何要这么算？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line">podReqGPU += <span class="keyword">uint</span>(<span class="built_in">len</span>(req.DevicesIDs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>Device Plugin</code> 的 <code>DeviceIDs</code> 是如何生成的。这里调用了 <code>nvml library</code> 可以探测到本Node上拥有的GPU有多少个，每个显存是多少。接下来 <code>Device Plugin</code> 会创建一系列的 <code>FakeDeviceID</code>，并将这个DeviceIDs返回给 Kubelet，这就解释了为什么要通过上面的方法计算申请的 GPU Memory，这里的Memory以MiB为单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDevices</span><span class="params">()</span> <span class="params">([]*pluginapi.Device, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line">n, err := nvml.GetDeviceCount()</span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> devs []*pluginapi.Device</span><br><span class="line">realDevNames := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uint</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">d, err := nvml.NewDevice(i)</span><br><span class="line">check(err)</span><br><span class="line"><span class="comment">// realDevNames = append(realDevNames, d.UUID)</span></span><br><span class="line"><span class="keyword">var</span> id <span class="keyword">uint</span></span><br><span class="line">log.Infof(<span class="string">"Deivce %s's Path is %s"</span>, d.UUID, d.Path)</span><br><span class="line">_, err = fmt.Sscanf(d.Path, <span class="string">"/dev/nvidia%d"</span>, &amp;id)</span><br><span class="line">check(err)</span><br><span class="line">realDevNames[d.UUID] = id</span><br><span class="line"><span class="comment">// var KiB uint64 = 1024</span></span><br><span class="line">log.Infof(<span class="string">"# device Memory: %d"</span>, <span class="keyword">uint</span>(*d.Memory))</span><br><span class="line"><span class="keyword">if</span> getGPUMemory() == <span class="keyword">uint</span>(<span class="number">0</span>) &#123;</span><br><span class="line">setGPUMemory(<span class="keyword">uint</span>(*d.Memory))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">uint</span>(<span class="number">0</span>); j &lt; getGPUMemory(); j++ &#123;</span><br><span class="line">fakeID := generateFakeDeviceID(d.UUID, j)</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">log.Infoln(<span class="string">"# Add first device ID: "</span> + fakeID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j == getGPUMemory()<span class="number">-1</span> &#123;</span><br><span class="line">log.Infoln(<span class="string">"# Add last device ID: "</span> + fakeID)</span><br><span class="line">&#125;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     fakeID,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> devs, realDevNames</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下 <code>Device Plugin</code> 是如何找到对应的Pod的，可以看到一旦碰到有Pod申请的GPU显存与Kubelet传入的显存大小一致，那么则找到对应的Pod了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pods, err := getCandidatePods()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Infof(<span class="string">"invalid allocation requst: Failed to find candidate pods due to %v"</span>, err)</span><br><span class="line">   <span class="keyword">return</span> buildErrResponse(reqs, podReqGPU), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">   <span class="keyword">if</span> getGPUMemoryFromPodResource(pod) == podReqGPU &#123;</span><br><span class="line">      log.Infof(<span class="string">"Found Assumed GPU shared Pod %s in ns %s with GPU Memory %d"</span>,</span><br><span class="line">         pod.Name,</span><br><span class="line">         pod.Namespace,</span><br><span class="line">         podReqGPU)</span><br><span class="line">      assumePod = pod</span><br><span class="line">      found = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>getCandidatePods</code>就是List所有Pending的Pod中 Assume Memory的，并且按照时间排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pick up the gpushare pod with assigned status is false, and</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCandidatePods</span><span class="params">()</span> <span class="params">([]*v1.Pod, error)</span></span> &#123;</span><br><span class="line">candidatePods := []*v1.Pod&#123;&#125;</span><br><span class="line">allPods, err := getPendingPodsInNode()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> candidatePods, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> allPods &#123;</span><br><span class="line">current := pod</span><br><span class="line"><span class="keyword">if</span> isGPUMemoryAssumedPod(&amp;current) &#123;</span><br><span class="line">candidatePods = <span class="built_in">append</span>(candidatePods, &amp;current)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> makePodOrderdByAge(candidatePods), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>那么这里有一个问题：如果在同一个Node有两个Pod <poda, podb>，都申请了相同的GPU显存大小，比如3G，那么kubelet是在创建容器的时候，是如何保证两个Pod不混淆的呢？混淆会有问题吗，kubelet建Pod的时候到底是怎么搞的？是谁触发了kubelet创建容器？</poda,></strong></p></blockquote><hr><h2 id="腾讯GPUManager"><a href="#腾讯GPUManager" class="headerlink" title="腾讯GPUManager"></a>腾讯GPUManager</h2><p>GPU Manager 提供一个 All-in-One 的 GPU 管理器，基于 Kubernetes DevicePlugin 插件系统实现，该管理器提供了分配并共享 GPU、GPU 指标查询、容器运行前的 GPU 相关设备准备等功能，支持用户在 Kubernetes 集群中使用 GPU 设备。</p><ul><li><strong>拓扑分配</strong>：提供基于 GPU 拓扑分配功能，当用户分配超过1张 GPU 卡的应用，可以选择拓扑连接最快的方式分配 GPU 设备。</li><li><strong>GPU 共享</strong>：允许用户提交小于1张卡资源的任务，并提供 QoS 保证。</li><li><strong>应用 GPU 指标的查询</strong>：用户可以访问主机端口（默认为 5678）的 <code>/metrics</code> 路径，可以为 Prometheus 提供 GPU 指标的收集功能，访问 <code>/usage</code> 路径可以进行可读性的容器状况查询。</li></ul><h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li><p>设计里定义了两种 <code>Extended Resource</code>：</p><ul><li><code>tencent.com/vcuda-core</code> ： <code>vcuda-core</code>对应的是使用率，单张卡有100个core</li><li><code>tencent.com/vcuda-memory</code> ：<code>vcuda-memory</code> 是显存，每个单位是256MB的显存</li><li>如果申请的资源为50%利用率，7680MB显存，<code>tencent.com/vcuda-core</code> 填写50，<code>tencent.com/vcuda-memory</code> 填写成30</li><li>同样支持原来的独占卡的方式，只需要在core的地方填写100的整数倍，memory值填写大于0的任意值</li></ul></li><li>基于k8s原生的Scheduler Extender、Extended Resource、DevicePlugin机制来实现</li><li>这个方案同时实现GPU的共享与算力和显存的隔离，类似于阿里云 <a href="https://www.alibabacloud.com/help/zh/doc-detail/163994.htm" target="_blank" rel="external nofollow noopener noreferrer">cGPU</a> 加上GPUShare 一起使用</li></ul><h4 id="核心组件-1"><a href="#核心组件-1" class="headerlink" title="核心组件"></a>核心组件</h4><p>GaiaGPU的实现主要分为两个部分：Kubernetes 部分 和 vCUDA 部分</p><ul><li>Kubernetes部分基于 Kubernetes 的 Extended Resources、Device Plugin 和 Scheduler Extender机制，实现了下面两个项目<ul><li><a href="https://github.com/tkestack/gpu-manager" target="_blank" rel="external nofollow noopener noreferrer">GPU Manager </a>：实现为一个 Device Plugin，与 NVIDIA 的 <a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">k8s-device-plugin</a> 相比，不需要额外配置 <code>nvidia-docker2</code>，使用的是原生的 <code>runc</code></li><li><a href="https://github.com/tkestack/gpu-admission" target="_blank" rel="external nofollow noopener noreferrer">GPU Admission</a>：实现为一个Scheduler Extender，注意这里的Extender在论文中没有提到，下图中的GPU Scheduler实现的是topology的选卡，属于现在GPU Manager项目的一部分，与这里的调度器插件无关</li></ul></li><li>vCUDA 部分通过 <a href="https://github.com/tkestack/vcuda-controller" target="_blank" rel="external nofollow noopener noreferrer">vcuda-controller</a> 来实现，作为 NVIDIA 的 CUDA 库的封装</li></ul><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_gaia-gpu-manager.png"></p><h3 id="具体过程-1"><a href="#具体过程-1" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="设备资源上报"><a href="#设备资源上报" class="headerlink" title="设备资源上报"></a>设备资源上报</h4><ul><li>与阿里的 <a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender" target="_blank" rel="external nofollow noopener noreferrer">GPUShare</a> 一样，GPU Manager 在 <code>ListAndWatch</code> 返回给Kubelet的也不是实际的GPU设备，而是 <code>a list of vGPUs</code>，</li><li>GPU被虚拟化为两个资源维度，memory 和 computing resource<ul><li>memory：以256M内存作为单位，每个memory unit叫做 <code>vmemory</code> device</li><li>computing resource：将一个物理GPU划分为100个 <code>vprocessor</code> devices，每个 <code>vprocessor</code> 占有 1%的GPU利用率</li></ul></li><li>用户申请具有GPU的Pod资源Manifest如下：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vcuda</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tensorflow</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">vcuda-test</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">['/usr/local/nvidia/bin/nvidia-smi']</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">tencent.com/vcuda-core:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">tencent.com/vcuda-memory:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">tencent.com/vcuda-core:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">tencent.com/vcuda-memory:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_gaia-device-plugin.png"></p><p> 下面看具体代码，首先是向 <code>kubelet</code> 注册：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *managerImpl)</span> <span class="title">RegisterToKubelet</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">socketFile := filepath.Join(m.config.DevicePluginPath, types.KubeletSocket)</span><br><span class="line">dialOptions := []grpc.DialOption&#123;grpc.WithInsecure(), grpc.WithDialer(utils.UnixDial), grpc.WithBlock(), grpc.WithTimeout(time.Second * <span class="number">5</span>)&#125;</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(socketFile, dialOptions...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pluginapi.NewRegistrationClient(conn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, srv := <span class="keyword">range</span> m.bundleServer &#123;</span><br><span class="line">req := &amp;pluginapi.RegisterRequest&#123;</span><br><span class="line">Version:      pluginapi.Version,</span><br><span class="line">Endpoint:     path.Base(srv.SocketName()),</span><br><span class="line">ResourceName: srv.ResourceName(),</span><br><span class="line">Options:      &amp;pluginapi.DevicePluginOptions&#123;PreStartRequired: <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glog.V(<span class="number">2</span>).Infof(<span class="string">"Register to kubelet with endpoint %s"</span>, req.Endpoint)</span><br><span class="line">_, err = client.Register(context.Background(), req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个 <code>m.bundleServer</code>，分别是 <code>vcore</code> 和 <code>vmemory</code> 的 gRPC Server。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *managerImpl)</span> <span class="title">setupGRPCService</span><span class="params">()</span></span> &#123;</span><br><span class="line">vcoreServer := newVcoreServer(m)</span><br><span class="line">vmemoryServer := newVmemoryServer(m)</span><br><span class="line"></span><br><span class="line">m.bundleServer[types.VCoreAnnotation] = vcoreServer</span><br><span class="line">m.bundleServer[types.VMemoryAnnotation] = vmemoryServer</span><br><span class="line"></span><br><span class="line">displayapi.RegisterGPUDisplayServer(m.srv, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看 <code>ListAndWatch</code> 的实现，对于两种资源，它会去检查 <code>capacity()</code>里面包含对应 <code>resourceName</code> 的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ListAndWatchWithResourceName send devices for request resource back to server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *NvidiaTopoAllocator)</span> <span class="title">ListAndWatchWithResourceName</span><span class="params">(resourceName <span class="keyword">string</span>, e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">devs := <span class="built_in">make</span>([]*pluginapi.Device, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> ta.capacity() &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(dev.ID, resourceName) &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, dev)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: devs&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don't send unhealthy state</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glog.V(<span class="number">2</span>).Infof(<span class="string">"ListAndWatch %s exit"</span>, resourceName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里的 <code>ta.capicity()</code> 是如何得到的呢？这里维护了一个拓扑树，树根是物理的Host，树叶是物理的GPU。这里根据树叶上GPU的数目和总的显存大小，构建了 <code>vcore</code> 设备 和 <code>vmemory</code> 设备，命名以各自的资源名为前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *NvidiaTopoAllocator)</span> <span class="title">capacity</span><span class="params">()</span> <span class="params">(devs []*pluginapi.Device)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">gpuDevices, memoryDevices []*pluginapi.Device</span><br><span class="line">totalMemory               <span class="keyword">int64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">nodes := ta.tree.Leaves()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">totalMemory += <span class="keyword">int64</span>(nodes[i].Meta.TotalMemory)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">totalCores := <span class="built_in">len</span>(nodes) * nvtree.HundredCore</span><br><span class="line">gpuDevices = <span class="built_in">make</span>([]*pluginapi.Device, totalCores)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; totalCores; i++ &#123;</span><br><span class="line">gpuDevices[i] = &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     fmt.Sprintf(<span class="string">"%s-%d"</span>, types.VCoreAnnotation, i),</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">totalMemoryBlocks := totalMemory / types.MemoryBlockSize</span><br><span class="line">memoryDevices = <span class="built_in">make</span>([]*pluginapi.Device, totalMemoryBlocks)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">0</span>); i &lt; totalMemoryBlocks; i++ &#123;</span><br><span class="line">memoryDevices[i] = &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     fmt.Sprintf(<span class="string">"%s-%d-%d"</span>, types.VMemoryAnnotation, types.MemoryBlockSize, i),</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">devs = <span class="built_in">append</span>(devs, gpuDevices...)</span><br><span class="line">devs = <span class="built_in">append</span>(devs, memoryDevices...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调度插件扩展-1"><a href="#调度插件扩展-1" class="headerlink" title="调度插件扩展"></a>调度插件扩展</h4><h5 id="细粒度Quota准入"><a href="#细粒度Quota准入" class="headerlink" title="细粒度Quota准入"></a>细粒度Quota准入</h5><p><code>GPU Quota Admission</code> 作为调度器插件，实现了更细粒度的quota调度准入维度。用户通过配置一个 <code>ConfigMap</code>，对每个 <code>Namespace</code>可用的GPU卡的配额做规划，同时也定义了资源池，这样在调度的时候就可以实现按照资源池及GPU型号进行策略调度。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"A"</span>: &#123;</span><br><span class="line">    <span class="attr">"pool"</span>: [<span class="string">"public"</span>], <span class="comment">// Pods in namespace 'A' could use pool 'public'</span></span><br><span class="line">    <span class="attr">"quota"</span>: &#123;</span><br><span class="line">      <span class="attr">"M40"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"P100"</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"B"</span>: &#123;</span><br><span class="line">    <span class="attr">"pool"</span>: [ <span class="string">"wx"</span> ], <span class="comment">// Pods in namespace 'B' could use pool 'wx'</span></span><br><span class="line">    <span class="attr">"quota"</span>: &#123;</span><br><span class="line">      <span class="attr">"M40"</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">"P100"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体在调度的时候，对每一个Pod，根据Namespace可以筛选出一系列含有GPU的Pods，然后当前Namespace下，对于某种GPU Model（比如P100），计算已经使用了的GPU大小，根据 <code>ConfigMap</code> 定义的配额，找到没超出。通过这个，得到所有没超出Quota的Models。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NamespaceQuota <span class="keyword">struct</span> &#123;</span><br><span class="line">Quota <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="string">`json:"quota"`</span></span><br><span class="line">Pool []<span class="keyword">string</span> <span class="string">`json:"pool"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gpuFilter *GPUFilter)</span> <span class="title">filterGPUModel</span><span class="params">(pod *corev1.Pod, namespaceQuota NamespaceQuota)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> filteredGPUModels []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> gpuModel, limit := <span class="keyword">range</span> namespaceQuota.Quota &#123;</span><br><span class="line">limit = limit * VirtualGPUTimes</span><br><span class="line">  nodeSelector, err := metav1.LabelSelectorAsSelector(&amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchLabels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;gpuFilter.conf.GPUModelLabel: gpuModel&#125;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">pods, err := gpuFilter.listPodsOnNodes(nodeSelector, pod.Namespace)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">gpuUsed := calculateGPUUsage(<span class="built_in">append</span>(pods, pod))</span><br><span class="line"><span class="keyword">if</span> gpuUsed &lt;= limit &#123;</span><br><span class="line">filteredGPUModels = <span class="built_in">append</span>(filteredGPUModels, gpuModel)</span><br><span class="line">&#125;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"Pods in namespace %s will use %d %s GPU cards after adding this pod, quota is %d"</span>,</span><br><span class="line">pod.Namespace, gpuUsed, gpuModel, limit)</span><br><span class="line">&#125;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"These GPU models could be used by pod %s: %+v"</span>, pod.Name, filteredGPUModels)</span><br><span class="line"><span class="keyword">return</span> filteredGPUModels, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 Filter阶段，根据上面的可用 <code>GPU Models</code> 和定义的 <code>Quota Pool</code>，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gpuFilter *GPUFilter)</span> <span class="title">filterNodes</span><span class="params">(nodes []corev1.Node, gpuModels, pools []<span class="keyword">string</span>)</span> <span class="params">(filteredNodes []corev1.Node, failedNodesMap schedulerapi.FailedNodesMap, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> gpuModelSelector, poolSelector labels.Selector</span><br><span class="line"></span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"Filter nodes with gpuModels(%+v) and pools(%+v)"</span>, gpuModels, pools)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(gpuModels) != <span class="number">0</span> &#123;</span><br><span class="line">gpuModelSelector, err = metav1.LabelSelectorAsSelector(&amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchExpressions: []metav1.LabelSelectorRequirement&#123;&#123;</span><br><span class="line">Key:      gpuFilter.conf.GPUModelLabel,</span><br><span class="line">Operator: metav1.LabelSelectorOpIn,</span><br><span class="line">Values:   gpuModels,</span><br><span class="line">&#125;&#125;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">gpuModelSelector = labels.Nothing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If pool is empty, it means that pod could use every pool, it is OK to leave it as a empty selector.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pools) != <span class="number">0</span> &#123;</span><br><span class="line">poolSelector, err = metav1.LabelSelectorAsSelector(&amp;metav1.LabelSelector&#123;</span><br><span class="line">MatchExpressions: []metav1.LabelSelectorRequirement&#123;&#123;</span><br><span class="line">Key:      gpuFilter.conf.GPUPoolLabel,</span><br><span class="line">Operator: metav1.LabelSelectorOpIn,</span><br><span class="line">Values:   pools,</span><br><span class="line">&#125;&#125;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">poolSelector = labels.Everything()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">failedNodesMap = schedulerapi.FailedNodesMap&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line"><span class="keyword">if</span> gpuModelSelector.Matches(labels.Set(node.Labels)) &amp;&amp; poolSelector.Matches(labels.Set(node.Labels)) &#123;</span><br><span class="line">filteredNodes = <span class="built_in">append</span>(filteredNodes, node)</span><br><span class="line">glog.V(<span class="number">5</span>).Infof(<span class="string">"Add %s to filteredNodes"</span>, node.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">failedNodesMap[node.Name] = <span class="string">"ExceedsGPUQuota"</span></span><br><span class="line">glog.V(<span class="number">5</span>).Infof(<span class="string">"Add %s to failedNodesMap"</span>, node.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> filteredNodes, failedNodesMap, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，也就是实现了细粒度的Quota调度准入控制。</p><h5 id="避免GPU碎片化"><a href="#避免GPU碎片化" class="headerlink" title="避免GPU碎片化"></a>避免GPU碎片化</h5><p>为此我们增加了GPU predicate controller来尽可能的降低系统默认调度策略带来的碎片化问题。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-19_gpu-manager-predicate.png"></p><p>我们看看它是如何实现的，首先在 <code>deviceFilter</code>的入口里面，拿到当前Node上存在的所有Pod：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pods, err := gpuFilter.ListPodsOnNode(node)</span><br><span class="line">...</span><br><span class="line">nodeInfo := device.NewNodeInfo(node, pods)</span><br><span class="line">alloc := algorithm.NewAllocator(nodeInfo)</span><br><span class="line">newPod, err := alloc.Allocate(pod)</span><br></pre></td></tr></table></figure><p>接下来构建一个 <code>NodeInfo</code> 结构体，里面包含有当前Node的所有信息，这里记录了Node上所有的GPU显存和GPU设备数目。这个是通过Node Status里面两个扩展资源计算出来的。<strong>GPU Manager 方案也是认为每台机器上的GPU的不同卡的显存大小是相同的，这样可以算出每张卡的显存大小</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">name        <span class="keyword">string</span></span><br><span class="line">node        *v1.Node</span><br><span class="line">devs        <span class="keyword">map</span>[<span class="keyword">int</span>]*DeviceInfo</span><br><span class="line">deviceCount <span class="keyword">int</span></span><br><span class="line">totalMemory <span class="keyword">uint</span></span><br><span class="line">usedCore    <span class="keyword">uint</span></span><br><span class="line">usedMemory  <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NodeInfo</code> 里面还有一个 <code>DeviceInfo</code> 的map，用于记录每张卡的使用情况。这里在初始化这个 <code>NodeInfo</code> 数据结构的时候也会根据传入的 <code>pods</code> 信息更新 <code>DeviceInfo</code> 的设备使用情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeviceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">id          <span class="keyword">int</span></span><br><span class="line">totalMemory <span class="keyword">uint</span></span><br><span class="line">usedMemory  <span class="keyword">uint</span></span><br><span class="line">usedCore    <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是每个 <code>Allocate</code> 函数的实现，对于Pod里面的每一个容器，都会分配得到一个 <code>devIDs</code> 列表，然后得到对Pod打上Annotation：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(alloc *allocator)</span> <span class="title">Allocate</span><span class="params">(pod *v1.Pod)</span> <span class="params">(*v1.Pod, error)</span></span> &#123;</span><br><span class="line">newPod := pod.DeepCopy()</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> newPod.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> !util.IsGPURequiredContainer(&amp;c) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">devIDs := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">devs, err := alloc.AllocateOne(&amp;c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Infof(<span class="string">"failed to allocate for pod %s(%s)"</span>, newPod.Name, c.Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> devs &#123;</span><br><span class="line">devIDs = <span class="built_in">append</span>(devIDs, strconv.Itoa(dev.GetID()))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> newPod.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">newPod.Annotations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line">newPod.Annotations[util.PredicateGPUIndexPrefix+strconv.Itoa(i)] = strings.Join(devIDs, <span class="string">","</span>)</span><br><span class="line">&#125;</span><br><span class="line">newPod.Annotations[util.GPUAssigned] = <span class="string">"false"</span></span><br><span class="line">newPod.Annotations[util.PredicateTimeAnnotation] = fmt.Sprintf(<span class="string">"%d"</span>, time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newPod, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的问题就是，这里的 <code>AllocateOne</code> 是如何实现的呢？对于每个容器，根据其申请的GPU资源，可以分为GPU是共享模式还是独占模式，然后调用 <code>Evaluate</code>去得到 <code>devs</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(alloc *allocator)</span> <span class="title">AllocateOne</span><span class="params">(container *v1.Container)</span> <span class="params">([]*device.DeviceInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">devs           []*device.DeviceInfo</span><br><span class="line">sharedMode     <span class="keyword">bool</span></span><br><span class="line">vcore, vmemory <span class="keyword">uint</span></span><br><span class="line">)</span><br><span class="line">node := alloc.nodeInfo.GetNode()</span><br><span class="line">nodeTotalMemory := util.GetCapacityOfNode(node, util.VMemoryAnnotation)</span><br><span class="line">deviceCount := util.GetGPUDeviceCountOfNode(node)</span><br><span class="line">deviceTotalMemory := <span class="keyword">uint</span>(nodeTotalMemory / deviceCount)</span><br><span class="line">needCores := util.GetGPUResourceOfContainer(container, util.VCoreAnnotation)</span><br><span class="line">needMemory := util.GetGPUResourceOfContainer(container, util.VMemoryAnnotation)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> needCores &lt; util.HundredCore:</span><br><span class="line">eval := NewShareMode(alloc.nodeInfo)</span><br><span class="line">devs = eval.Evaluate(needCores, needMemory)</span><br><span class="line">sharedMode = <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">eval := NewExclusiveMode(alloc.nodeInfo)</span><br><span class="line">devs = eval.Evaluate(needCores, needMemory)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(devs) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to allocate for container %s"</span>, container.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sharedMode &#123;</span><br><span class="line">vcore = needCores</span><br><span class="line">vmemory = needMemory</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vcore = util.HundredCore</span><br><span class="line">vmemory = deviceTotalMemory</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> devs &#123;</span><br><span class="line">err := alloc.nodeInfo.AddUsedResources(dev.GetID(), vcore, vmemory)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Infof(<span class="string">"failed to update used resource for node %s dev %d due to %v"</span>, node.Name, dev.GetID(), err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> devs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以共享模式为例，这里拿到当前Node的所有 <code>Device</code>，分别根据最少可用的<code>cores</code>和可用的<code>memory</code>来排序，如果有满足用户需要的设备，则加入到 <code>devs</code> 里面，最后将这个 <code>list</code> 返回给用户。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(al *shareMode)</span> <span class="title">Evaluate</span><span class="params">(cores <span class="keyword">uint</span>, memory <span class="keyword">uint</span>)</span> []*<span class="title">device</span>.<span class="title">DeviceInfo</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">devs        []*device.DeviceInfo</span><br><span class="line">deviceCount = al.node.GetDeviceCount()</span><br><span class="line">tmpStore    = <span class="built_in">make</span>([]*device.DeviceInfo, deviceCount)</span><br><span class="line">sorter      = shareModeSort(device.ByAllocatableCores, device.ByAllocatableMemory, device.ByID)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deviceCount; i++ &#123;</span><br><span class="line">tmpStore[i] = al.node.GetDeviceMap()[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sorter.Sort(tmpStore)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> tmpStore &#123;</span><br><span class="line"><span class="keyword">if</span> dev.AllocatableCores() &gt;= cores &amp;&amp; dev.AllocatableMemory() &gt;= memory &#123;</span><br><span class="line">glog.V(<span class="number">4</span>).Infof(<span class="string">"Pick up %d , cores: %d, memory: %d"</span>, dev.GetID(), dev.AllocatableCores(), dev.AllocatableMemory())</span><br><span class="line">devs = <span class="built_in">append</span>(devs, dev)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> devs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里在调度过程中，选择最先满足的那个，一旦满足则跳出选择。这是因为这里的 <code>devs</code> 已经按照最少可用的资源来匹配了，通过这种方式可以减少碎片化。</p><h4 id="Kubelet创建Pod-1"><a href="#Kubelet创建Pod-1" class="headerlink" title="Kubelet创建Pod"></a>Kubelet创建Pod</h4><p>用户创建Pod之后，经过调度找到对应的Node，这时候Kubelet向DevicePlugin执行Allocate函数。因为Kubelet看到的是虚拟的Devices，这里需要有一个从虚拟Device到实际GPU Device的映射，这里就是上图中GPU Manager做的事情，然后发送一个Request给GPU Scheduler，根据拓扑关系选择最合适的GPU，然后GPU Manager将 AllocateResponse返回给Kubelet。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_gaia-device-plugin.png"></p><p>我们先看 <code>Allocate</code> 的实现，这段代码比较长，但是实现的逻辑也不难：</p><ul><li>Allocate传入的参数是 <code>deviceIDs</code> 这样里一个List，<strong>里面只有 <code>vcore</code> 这种设备</strong> （代码是这样的，需要进一步看一看 kubelet）</li><li>Pod可能有多个Container，这里每次只处理一个容器<ul><li>如果还有未处理的Pod，先解决未处理Pod中的容器</li><li>否则从当前Node上的Pod遍历，选择与用户申请的 <code>vcore</code> 相同的容器</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *NvidiaTopoAllocator)</span> <span class="title">Allocate</span><span class="params">(_ context.Context, reqs *pluginapi.AllocateRequest)</span> <span class="params">(*pluginapi.AllocateResponse, error)</span></span> &#123;</span><br><span class="line">ta.Lock()</span><br><span class="line"><span class="keyword">defer</span> ta.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">reqCount           <span class="keyword">uint</span></span><br><span class="line">candidatePod       *v1.Pod</span><br><span class="line">candidateContainer *v1.Container</span><br><span class="line">found              <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(reqs.ContainerRequests) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"empty container request"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// k8s send allocate request for one container at a time</span></span><br><span class="line">req := reqs.ContainerRequests[<span class="number">0</span>]</span><br><span class="line">resps := &amp;pluginapi.AllocateResponse&#123;&#125;</span><br><span class="line">reqCount = <span class="keyword">uint</span>(<span class="built_in">len</span>(req.DevicesIDs))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ta.unfinishedPod != <span class="literal">nil</span> &#123;</span><br><span class="line">candidatePod = ta.unfinishedPod</span><br><span class="line">cache := ta.allocatedPod.GetCache(<span class="keyword">string</span>(candidatePod.UID))</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> candidatePod.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := cache[c.Name]; ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !utils.IsGPURequiredContainer(&amp;c) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reqCount != utils.GetGPUResourceOfContainer(&amp;candidatePod.Spec.Containers[i], types.VCoreAnnotation) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(msg)</span><br><span class="line">&#125;</span><br><span class="line">candidateContainer = &amp;candidatePod.Spec.Containers[i]</span><br><span class="line">found = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pods, err := getCandidatePods(ta.k8sClient, ta.config.Hostname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"Failed to find candidate pods due to %v"</span>, err)</span><br><span class="line">glog.Infof(msg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line"><span class="keyword">if</span> !utils.IsGPURequiredContainer(&amp;c) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">podCache := ta.allocatedPod.GetCache(<span class="keyword">string</span>(pod.UID))</span><br><span class="line"><span class="keyword">if</span> podCache != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := podCache[c.Name]; ok &#123;</span><br><span class="line">glog.Infof(<span class="string">"container %s of pod %s has been allocate, continue to next"</span>, c.Name, pod.UID)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> utils.GetGPUResourceOfContainer(&amp;pod.Spec.Containers[i], types.VCoreAnnotation) == reqCount &#123;</span><br><span class="line">glog.Infof(<span class="string">"Found candidate Pod %s(%s) with device count %d"</span>, pod.UID, c.Name, reqCount)</span><br><span class="line">candidatePod = pod</span><br><span class="line">candidateContainer = &amp;pod.Spec.Containers[i]</span><br><span class="line">found = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到这样的一个容器之后，拿到容器申请的 <code>vmemory</code>，每一个虚拟的 <code>vmemory</code> 作为一个设备加入到 <code>req.DevicesIDs</code> 中，继续调用 <code>allocateOne</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line"><span class="comment">// get vmemory info from container spec</span></span><br><span class="line">vmemory := utils.GetGPUResourceOfContainer(candidateContainer, types.VMemoryAnnotation)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(vmemory); i++ &#123;</span><br><span class="line">req.DevicesIDs = <span class="built_in">append</span>(req.DevicesIDs, types.VMemoryAnnotation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := ta.allocateOne(candidatePod, candidateContainer, req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Errorf(err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resps.ContainerResponses = <span class="built_in">append</span>(resps.ContainerResponses, resp)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"candidate pod not found for request %v, allocation failed"</span>, reqs)</span><br><span class="line">glog.Infof(msg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resps, ni</span><br></pre></td></tr></table></figure><p>具体的 <code>Allocate</code> 实现在 <code>allocateOne</code> 里面，根据Pod计算出其申请的 <code>needCores</code> 和 <code>needMemory</code> 之后，根据三种情况有不同的分配策略。注意这里还是在拓扑树上面操作，拓扑树树根是物理的Host，树叶是物理的GPU</p><ul><li>申请的资源超过一张卡，这时候分配的策略是尽可能减少卡之间的通信开销</li><li>申请的资源等于一张卡，这时候的分配策略是尽可能减少拓扑树里面产生没有兄弟节点的叶节点</li><li>申请的资源小于一张卡，这时候的分配策略是尽可能减少卡资源的碎片化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> needCores &gt; nvtree.HundredCore:</span><br><span class="line">eval, ok := ta.evaluators[<span class="string">"link"</span>]</span><br><span class="line"><span class="comment">// 这种场景下needCores must be multiple of nvtree.HundredCore</span></span><br><span class="line">nodes = eval.Evaluate(needCores, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">case</span> needCores == nvtree.HundredCore:</span><br><span class="line">eval, ok := ta.evaluators[<span class="string">"fragment"</span>]</span><br><span class="line">nodes = eval.Evaluate(needCores, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// evaluate in share mode</span></span><br><span class="line">shareMode = <span class="literal">true</span></span><br><span class="line">eval, ok := ta.evaluators[<span class="string">"share"</span>]</span><br><span class="line">nodes = eval.Evaluate(needCores, needMemory)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Evaluate</code> 返回的是 <code>NvidiaNode</code> 这样的 GPU 节点，通过这个结构可以构建一个拓扑树：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NvidiaNode represents a node of Nvidia GPU</span></span><br><span class="line"><span class="keyword">type</span> NvidiaNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Meta            DeviceMeta</span><br><span class="line">AllocatableMeta SchedulerCache</span><br><span class="line"></span><br><span class="line">Parent   *NvidiaNode</span><br><span class="line">Children []*NvidiaNode</span><br><span class="line">Mask     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">pendingReset <span class="keyword">bool</span></span><br><span class="line">vchildren    <span class="keyword">map</span>[<span class="keyword">int</span>]*NvidiaNode</span><br><span class="line">ntype        nvml.GpuTopologyLevel</span><br><span class="line">tree         *NvidiaTree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里具体的分配算法此处就不再详述了，抓住主脉络。</p><p>接下来构建 <code>pluginapi.ContainerAllocateResponse</code>，这里会分别设置环境变量，挂载的目录，找到的设备，以及<code>Annotation</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctntResp := &amp;pluginapi.ContainerAllocateResponse&#123;</span><br><span class="line">Envs:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">Mounts:      <span class="built_in">make</span>([]*pluginapi.Mount, <span class="number">0</span>),</span><br><span class="line">Devices:     <span class="built_in">make</span>([]*pluginapi.DeviceSpec, <span class="number">0</span>),</span><br><span class="line">Annotations: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是 <code>Devices</code> 字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">allocatedDevices := sets.NewString()</span><br><span class="line">deviceList := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">name := n.MinorName()</span><br><span class="line">glog.V(<span class="number">2</span>).Infof(<span class="string">"Allocate %s for %s(%s), Meta (%d:%d)"</span>, name, pod.UID, container.Name, n.Meta.ID, n.Meta.MinorID)</span><br><span class="line"></span><br><span class="line">ctntResp.Annotations[types.VCoreAnnotation] = fmt.Sprintf(<span class="string">"%d"</span>, needCores)</span><br><span class="line">ctntResp.Annotations[types.VMemoryAnnotation] = fmt.Sprintf(<span class="string">"%d"</span>, needMemory)</span><br><span class="line"></span><br><span class="line">ctntResp.Devices = <span class="built_in">append</span>(ctntResp.Devices, &amp;pluginapi.DeviceSpec&#123;</span><br><span class="line">ContainerPath: name,</span><br><span class="line">HostPath:      name,</span><br><span class="line">Permissions:   <span class="string">"rwm"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">deviceList = <span class="built_in">append</span>(deviceList, n.Meta.UUID)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !allocated &#123;</span><br><span class="line">ta.tree.MarkOccupied(n, needCores, needMemory)</span><br><span class="line">&#125;</span><br><span class="line">allocatedDevices.Insert(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有一些控制设备：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append control device</span></span><br><span class="line">ctntResp.Devices = <span class="built_in">append</span>(ctntResp.Devices, &amp;pluginapi.DeviceSpec&#123;</span><br><span class="line">ContainerPath: types.NvidiaCtlDevice,</span><br><span class="line">HostPath:      types.NvidiaCtlDevice,</span><br><span class="line">Permissions:   <span class="string">"rwm"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ctntResp.Devices = <span class="built_in">append</span>(ctntResp.Devices, &amp;pluginapi.DeviceSpec&#123;</span><br><span class="line">ContainerPath: types.NvidiaUVMDevice,</span><br><span class="line">HostPath:      types.NvidiaUVMDevice,</span><br><span class="line">Permissions:   <span class="string">"rwm"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append default device</span></span><br><span class="line"><span class="keyword">if</span> cfg, found := ta.extraConfig[<span class="string">"default"</span>]; found &#123;</span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> cfg.Devices &#123;</span><br><span class="line">ctntResp.Devices = <span class="built_in">append</span>(ctntResp.Devices, &amp;pluginapi.DeviceSpec&#123;</span><br><span class="line">ContainerPath: dev,</span><br><span class="line">HostPath:      dev,</span><br><span class="line">Permissions:   <span class="string">"rwm"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是 <code>Annotations</code> 字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctntResp.Annotations[types.VDeviceAnnotation] = vDeviceAnnotationStr(nodes)</span><br><span class="line"><span class="keyword">if</span> !allocated &#123;</span><br><span class="line">ta.allocatedPod.Insert(<span class="keyword">string</span>(pod.UID), container.Name, &amp;cache.Info&#123;</span><br><span class="line">Devices: allocatedDevices.UnsortedList(),</span><br><span class="line">Cores:   needCores,</span><br><span class="line">Memory:  needMemory,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <code>Envs</code> 字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LD_LIBRARY_PATH</span></span><br><span class="line">ctntResp.Envs[<span class="string">"LD_LIBRARY_PATH"</span>] = <span class="string">"/usr/local/nvidia/lib64"</span></span><br><span class="line"><span class="keyword">for</span> _, env := <span class="keyword">range</span> container.Env &#123;</span><br><span class="line"><span class="keyword">if</span> env.Name == <span class="string">"compat32"</span> &amp;&amp; strings.ToLower(env.Value) == <span class="string">"true"</span> &#123;</span><br><span class="line">ctntResp.Envs[<span class="string">"LD_LIBRARY_PATH"</span>] = <span class="string">"/usr/local/nvidia/lib"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVIDIA_VISIBLE_DEVICES</span></span><br><span class="line">ctntResp.Envs[<span class="string">"NVIDIA_VISIBLE_DEVICES"</span>] = strings.Join(deviceList, <span class="string">","</span>)</span><br></pre></td></tr></table></figure><p>最后是 <code>Mounts</code> 字段，这里给GPU容器配置一个volume挂载点来提供CUDA Library以及配置环境变量<code>LD_LIBRARY_PATH</code> 告诉应用哪里去找到 <code>CUDA Library</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shareMode &#123;</span><br><span class="line">ctntResp.Mounts = <span class="built_in">append</span>(ctntResp.Mounts, &amp;pluginapi.Mount&#123;</span><br><span class="line">ContainerPath: <span class="string">"/usr/local/nvidia"</span>,</span><br><span class="line">HostPath:      types.DriverLibraryPath,</span><br><span class="line">ReadOnly:      <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctntResp.Mounts = <span class="built_in">append</span>(ctntResp.Mounts, &amp;pluginapi.Mount&#123;</span><br><span class="line">ContainerPath: <span class="string">"/usr/local/nvidia"</span>,</span><br><span class="line">HostPath:      types.DriverOriginLibraryPath,</span><br><span class="line">ReadOnly:      <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctntResp.Mounts = <span class="built_in">append</span>(ctntResp.Mounts, &amp;pluginapi.Mount&#123;</span><br><span class="line">ContainerPath: types.VCUDA_MOUNTPOINT,</span><br><span class="line">HostPath:      filepath.Join(ta.config.VirtualManagerPath, <span class="keyword">string</span>(pod.UID)),</span><br><span class="line">ReadOnly:      <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="vGPU-Manager"><a href="#vGPU-Manager" class="headerlink" title="vGPU Manager"></a>vGPU Manager</h4><p><code>vGPU Manager</code> 作为 <code>GPU Manager</code> 这个 <code>DaemonSet</code> 的一部分，负责下发容器配置和监控容器分配的vGPU。上一步在拓扑分配器确定好每个容器的资源配置之后，<code>vGPU Manager</code> 负责为每个容器在 host 上创建一个独立的目录，这个目录以容器的名称命名，并且会被包括在 <code>AllocateResponse</code> 中返回给 kubelet，对就是上面那段代码做的事情。</p><p><code>vGPU Manager</code> 会维护一个使用了GPU的并且仍然活着的容器列表，还会去周期性的检查他们。一旦有容器挂掉，就会将这个容器移出列表并且删去目录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                Host                     |                Container</span></span><br><span class="line"><span class="comment">//                                         |</span></span><br><span class="line"><span class="comment">//                                         |</span></span><br><span class="line"><span class="comment">//  .-----------.                          |</span></span><br><span class="line"><span class="comment">//  | allocator |----------.               |             ___________</span></span><br><span class="line"><span class="comment">//  '-----------'   PodUID |               |             \          \</span></span><br><span class="line"><span class="comment">//                         v               |              ) User App )--------.</span></span><br><span class="line"><span class="comment">//                .-----------------.      |             /__________/         |</span></span><br><span class="line"><span class="comment">//     .----------| virtual-manager |      |                                  |</span></span><br><span class="line"><span class="comment">//     |          '-----------------'      |                                  |</span></span><br><span class="line"><span class="comment">// $VirtualManagerPath/PodUID              |                                  |</span></span><br><span class="line"><span class="comment">//     |                                   |       read /proc/self/cgroup     |</span></span><br><span class="line"><span class="comment">//     |  .------------------.             |       to get PodUID, ContainerID |</span></span><br><span class="line"><span class="comment">//     '-&gt;| create directory |------.      |                                  |</span></span><br><span class="line"><span class="comment">//        '------------------'      |      |                                  |</span></span><br><span class="line"><span class="comment">//                                  |      |                                  |</span></span><br><span class="line"><span class="comment">//                 .----------------'      |       .----------------------.   |</span></span><br><span class="line"><span class="comment">//                 |                       |       | fork call gpu-client |&lt;--'</span></span><br><span class="line"><span class="comment">//                 |                       |       '----------------------'</span></span><br><span class="line"><span class="comment">//                 v                       |                   |</span></span><br><span class="line"><span class="comment">//    .------------------------.           |                   |</span></span><br><span class="line"><span class="comment">//   ( wait for client register )&lt;-------PodUID, ContainerID---'</span></span><br><span class="line"><span class="comment">//    '------------------------'           |</span></span><br><span class="line"><span class="comment">//                 |                       |</span></span><br><span class="line"><span class="comment">//                 v                       |</span></span><br><span class="line"><span class="comment">//   .--------------------------.          |</span></span><br><span class="line"><span class="comment">//   | locate pod and container |          |</span></span><br><span class="line"><span class="comment">//   '--------------------------'          |</span></span><br><span class="line"><span class="comment">//                 |                       |</span></span><br><span class="line"><span class="comment">//                 v                       |</span></span><br><span class="line"><span class="comment">//   .---------------------------.         |</span></span><br><span class="line"><span class="comment">//   | write down configure and  |         |</span></span><br><span class="line"><span class="comment">//   | pid file with containerID |         |</span></span><br><span class="line"><span class="comment">//   | as name                   |         |</span></span><br><span class="line"><span class="comment">//   '---------------------------'         |</span></span><br><span class="line"><span class="comment">//                                         |</span></span><br><span class="line"><span class="comment">//                                         |</span></span><br><span class="line"><span class="comment">//                                         v</span></span><br></pre></td></tr></table></figure><h3 id="vGPU-Library"><a href="#vGPU-Library" class="headerlink" title="vGPU Library"></a>vGPU Library</h3><p>论文中的 <code>vGPU Library</code>，具体实现为 <a href="https://github.com/tkestack/vcuda-controller" target="_blank" rel="external nofollow noopener noreferrer">vcuda-controller</a> ，它运行在容器中用于管理部署在容器中的GPU资源。这个 <code>vGPU Library</code> 本质上就是自己封装了 <code>CUDA Library</code>，劫持了 <code>memory-related</code> API 和 <code>computing-related</code> API，下表显示了劫持的API。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_gaia-vcuda.png"></p><p><code>vCUDA</code> 在调用相应API时检查：</p><ul><li>对于显存，一旦该任务申请显存后占用的显存大小大于config中的设置，就报错。</li><li>对于计算资源，存在硬隔离和软隔离两种方式<ul><li>共同点是当任务使用的GPU SM利用率超出资源上限，则暂缓下发API调用。</li><li>不同点是如果有资源空闲，软隔离允许任务超过设置，动态计算资源上限。而硬隔离则不允许超出设置量。</li></ul></li></ul><p>这里对于其具体实现按下不表。</p><p>一个令人疑惑的问题是，在GPU Manager中，用户的容器是如何能够使用这个动态库的呢？具体有两个问题：</p><ul><li>这个库从哪里来？<ul><li><code>GPU Manager</code> 作为 <code>DaemonSet</code> 会在其Image中将我们自定义的库打包进去，然后挂载到Node上的一个目录。</li></ul></li><li>容器中的应用是如何感知到的？<ul><li>这里主要是通过在创建容器的时候，设置 <code>LD_LIBRARY_PATH</code> ，将其指向这个自定义的动态库的地址。</li></ul></li></ul><h3 id="资源监控统计"><a href="#资源监控统计" class="headerlink" title="资源监控统计"></a>资源监控统计</h3><p>这部分代码还没有看。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender/blob/master/docs/designs/designs.md" target="_blank" rel="external nofollow noopener noreferrer">阿里GPUShare设计文档</a></li><li><a href="https://www.alibabacloud.com/help/zh/doc-detail/163994.htm" target="_blank" rel="external nofollow noopener noreferrer">阿里共享调度使用文档</a></li><li><a href="https://ieeexplore.ieee.org/document/8672318" target="_blank" rel="external nofollow noopener noreferrer">Gaia GPUManager论文</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生的 k8s 基于 &lt;code&gt;Device Plugin&lt;/code&gt; 和 &lt;code&gt;Extended Resource&lt;/code&gt; 机制实现了在容器中使用GPU，但是只支持GPU的独占使用，不允许在Pod间共享GPU，这大大降低了对集群中GPU的利用率。为了在集群层面共享GPU，我们需要实现GPU资源的隔离与调度，本文将依次介绍阿里的 &lt;a href=&quot;https://github.com/AliyunContainerService/gpushare-scheduler-extender&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GPUShare&lt;/a&gt; 与腾讯的 &lt;a href=&quot;https://github.com/tkestack/gpu-manager&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GPUManager&lt;/a&gt;，分析其实现机制。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_aliyun-gpu-share.jpg" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="device plugin" scheme="http://houmin.cc/tags/device-plugin/"/>
    
      <category term="资源隔离" scheme="http://houmin.cc/tags/%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/"/>
    
      <category term="scheduler extender" scheme="http://houmin.cc/tags/scheduler-extender/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】在Docker中使用GPU</title>
    <link href="http://houmin.cc/posts/574111db/"/>
    <id>http://houmin.cc/posts/574111db/</id>
    <published>2020-11-17T12:45:00.000Z</published>
    <updated>2020-11-23T05:29:01.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们在 <a href="https://houmin.cc/posts/5004f8e5/">GPU 与 CUDA 编程入门</a> 这篇博客中初步介绍了如何Linux上使用GPU的方法，随着容器和k8s的迅猛发展，人们对于在容器中使用GPU的需求越发强烈。本文将基于前文，继续介绍如何在容器中使用GPU，进一步地，介绍在Kubernetes中如何调度GPU，并以Tensorflow为例，介绍如何基于Docker搭建部署了GPU的深度学习开发环境。</p><a id="more"></a><h2 id="NVIDIA-Container-Toolkit"><a href="#NVIDIA-Container-Toolkit" class="headerlink" title="NVIDIA Container Toolkit"></a>NVIDIA Container Toolkit</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>容器最早是用于无缝部署基于CPU的应用，它们对于硬件和平台是无感知的，但是显然这种使用场景对于GPU并不适用。对于不同的GPU，需要机器安装不同的硬件驱动，这极大限制了在容器中使用GPU。为了解决这个问题，最早的一种使用方法是在容器中完全重新安装一次NVIDIA驱动，然后将在容器启动的时候将GPU以字符设备 <code>/dev/nvidia0</code> 的方式传递给容器。然而这种方法要求容器中安装的驱动版本与Host上的驱动版本完全一致，同一个Docker Image不能在各个机器上复用，这极大的限制了容器的扩展性。</p><p>为了解决上述问题，容器必须对于 NVIDIA 驱动是无感知的，基于此 NVIDIA 推出了 <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA Container Toolkit</a>：</p><p><img alt="nvidia-gpu-docker" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_nvidia-gpu-docker.png"></p><p>如上图所示， NVIDIA 将原来 CUDA 应用依赖的API环境划分为两个部分：</p><ul><li>驱动级API：由<code>libcuda.so.major.minor</code>动态库和内核module提供支持，图中表示为CUDA Driver<ul><li>驱动级API属于底层API，每当NVIDIA公司释放出某一个版本的驱动时，如果你要升级主机上的驱动，那么内核模块和<code>libcuda.so.major.minor</code>这2个文件就必须同时升级到同一个版本，这样原有的程序才能正常工作,</li><li>不同版本的驱动不能同时存在于宿主机上</li></ul></li><li>非驱动级API：由动态库<code>libcublas.so</code>等用户空间级别的API组成，图中表示为CUDA Toolkit<ul><li>非驱动级API的版本号是以Toolkit自身的版本号来管理, 比如cuda-10，cuda-11</li><li>不同版本的Toolkit可以同时运行在相同的宿主机上</li><li>非驱动级API算是对驱动级API的一种更高级的封装,最终还是要调用驱动级API来实现功能</li></ul></li></ul><p>为了让使用GPU的容器更具可扩展性，关于非驱动级的API被 NVIDIA 打包进了  <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA Container Toolkit</a>，因此在容器中使用GPU之前，每个机器需要先安装好NVIDIA驱动，之后配置好 NVIDIA Container Toolkit之后，就可以在容器中方便使用GPU了。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>NVIDIA 的容器工具包本质是使用一个<code>nvidia-runc</code>的方式来提供GPU容器的创建, 在用户创建出来的OCI spec上补上几个hook函数，来达到GPU设备运行的准备工作。具体包括以下几个组件，从上到下展示如图：</p><ul><li><code>nvidia-docker2</code></li><li><code>nvidia-container-runtime</code></li><li><code>nvidia-container-toolkit</code></li><li><code>libnvidia-container</code></li></ul><p><img alt data-src="https://docs.nvidia.com/datacenter/cloud-native/_images/nvidia-docker-arch.png"></p><p>下面对这几个组件依次介绍：</p><h4 id="libnvidia-container"><a href="#libnvidia-container" class="headerlink" title="libnvidia-container"></a><code>libnvidia-container</code></h4><p>This component provides a library and a simple CLI utility to automatically configure GNU/Linux containers leveraging NVIDIA GPUs. The implementation relies on kernel primitives and is designed to be agnostic of the container runtime.</p><p><code>libnvidia-container</code> provides a well-defined API and a wrapper CLI (called <code>nvidia-container-cli</code>) that different runtimes can invoke to inject NVIDIA GPU support into their containers.</p><h4 id="nvidia-container-toolkit"><a href="#nvidia-container-toolkit" class="headerlink" title="nvidia-container-toolkit"></a><code>nvidia-container-toolkit</code></h4><p>This component includes a script that implements the interface required by a <code>runC</code> <code>prestart</code> hook. This script is invoked by <code>runC</code> after a container has been created, but before it has been started, and is given access to the <code>config.json</code> associated with the container (e.g. this <a href="https://github.com/opencontainers/runtime-spec/blob/master/config.md#configuration-schema-example=" target="_blank" rel="external nofollow noopener noreferrer">config.json</a> ). It then takes information contained in the <code>config.json</code> and uses it to invoke the <code>libnvidia-container</code> CLI with an appropriate set of flags. One of the most important flags being which specific GPU devices should be injected into the container.</p><p>Note that the previous name of this component was <code>nvidia-container-runtime-hook</code>. <code>nvidia-container-runtime-hook</code> is now simply a symlink to <code>nvidia-container-toolkit</code> on the system.</p><h4 id="nvidia-container-runtime"><a href="#nvidia-container-runtime" class="headerlink" title="nvidia-container-runtime"></a><code>nvidia-container-runtime</code></h4><p>This component used to be a complete fork of <code>runC</code> with NVIDIA specific code injected into it. Since 2019, it is a thin wrapper around the native <code>runC</code> installed on the host system. <code>nvidia-container-runtime</code> takes a <code>runC</code> spec as input, injects the <code>nvidia-container-toolkit</code> script as a <code>prestart</code> hook into it, and then calls out to the native <code>runC</code>, passing it the modified <code>runC</code> spec with that hook set. It’s important to note that this component is not necessarily specific to docker (but it is specific to <code>runC</code>).</p><p>When the package is installed, the Docker <code>daemon.json</code> is updated to point to the binary as can be seen below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"default-runtime"</span>: <span class="string">"nvidia"</span>,</span><br><span class="line"><span class="string">"runtimes"</span>: &#123;</span><br><span class="line">    <span class="string">"nvidia"</span>: &#123;</span><br><span class="line">        <span class="string">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">        <span class="string">"runtimeArgs"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nvidia-docker2"><a href="#nvidia-docker2" class="headerlink" title="nvidia-docker2"></a><code>nvidia-docker2</code></h4><p>This package is the only docker-specific package of the hierarchy. It takes the script associated with the <code>nvidia-container-runtime</code> and installs it into docker’s <code>/etc/docker/daemon.json</code> file. This then allows you to run (for example) <code>docker run --runtime=nvidia ...</code> to automatically add GPU support to your containers. It also installs a wrapper script around the native docker CLI called <code>nvidia-docker</code> which lets you invoke docker without needing to specify <code>--runtime=nvidia</code> every single time. It also lets you set an environment variable on the host (<code>NV_GPU</code>) to specify which GPUs should be injected into a container.</p><h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><p>这里仍然基于腾讯云的 CentOS 7机器为例演示如何在安装配置 <code>NVIDIA Container Toolkit</code>，对于更多的平台可以参考其<a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>。</p><h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://get.docker.com | sh \</span><br><span class="line">  &amp;&amp; sudo systemctl start docker \</span><br><span class="line">  &amp;&amp; sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h4 id="安装-NVIDIA-Container-Toolkit"><a href="#安装-NVIDIA-Container-Toolkit" class="headerlink" title="安装 NVIDIA Container Toolkit"></a>安装 NVIDIA Container Toolkit</h4><p>Setup the <code>stable</code> repository and the GPG key:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br></pre></td></tr></table></figure><p>Install the <code>nvidia-docker2</code> package (and dependencies) after updating the package listing:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y nvidia-docker2</span><br></pre></td></tr></table></figure><p>Restart the Docker daemon to complete the installation after setting the default runtime:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>At this point, a working setup can be tested by running a base CUDA container:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure><p>This should result in a console output shown below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 450.51.06    Driver Version: 450.51.06    CUDA Version: 11.0     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla T4            On   | 00000000:00:1E.0 Off |                    0 |</span><br><span class="line">| N/A   34C    P8     9W /  70W |      0MiB / 15109MiB |      0%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h4 id="配置-NVIDIA-Runtime"><a href="#配置-NVIDIA-Runtime" class="headerlink" title="配置 NVIDIA Runtime"></a>配置 NVIDIA Runtime</h4><p>To register the <code>nvidia</code> runtime, use the method below that is best suited to your environment. You might need to merge the new argument with your existing configuration. Three options are available:</p><h4 id="Systemd-drop-in-file"><a href="#Systemd-drop-in-file" class="headerlink" title="Systemd drop-in file"></a>Systemd drop-in file</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>docker.service.d</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>docker.service.d/override.conf &lt;&lt;EOF</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=<span class="regexp">/usr/</span>bin<span class="regexp">/dockerd --host=fd:/</span><span class="regexp">/ --add-runtime=nvidia=/</span>usr<span class="regexp">/bin/</span>nvidia-container-runtime</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload \</span><br><span class="line">  &amp;&amp; sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="Daemon-configuration-file"><a href="#Daemon-configuration-file" class="headerlink" title="Daemon configuration file"></a>Daemon configuration file</h4><p>The <code>nvidia</code> runtime can also be registered with Docker using the <code>daemon.json</code> configuration file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="string">"nvidia"</span>: &#123;</span><br><span class="line">            <span class="string">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">            <span class="string">"runtimeArgs"</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -SIGHUP dockerd</span><br></pre></td></tr></table></figure><p>You can optionally reconfigure the default runtime by adding the following to <code>/etc/docker/daemon.json</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"default-runtime"</span>: <span class="string">"nvidia"</span></span><br></pre></td></tr></table></figure><h4 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h4><p>Use <code>dockerd</code> to add the <code>nvidia</code> runtime:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime [...]</span><br></pre></td></tr></table></figure><h2 id="在k8s中管理GPU"><a href="#在k8s中管理GPU" class="headerlink" title="在k8s中管理GPU"></a>在k8s中管理GPU</h2><p>为了在 k8s 中管理和使用GPU，我们除了需要配置 <code>NVIDIA Container Toolkit</code>，还需要安装NVIDIA推出的 <a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA/k8s-device-plugin</a>，具体安装可以参考 <a href="../3f069334">我的这篇博文</a>。上面的步骤加起来显得还是有些繁琐，如果你直接使用腾讯云 TKE 的话，在集群添加装有GPU的Node时候，就会自动帮你安装配置好  <code>NVIDIA Container Toolkit</code> 和  <code>NVIDIA/k8s-device-plugin</code>，十分方便。接下来我们以Tensorflow为例，演示在 k8s 环境运行有GPU的Tensorflow。</p><h3 id="单机版Tensorflow"><a href="#单机版Tensorflow" class="headerlink" title="单机版Tensorflow"></a>单机版Tensorflow</h3><p>首先是单机版的Tensorflow，执行 <code>kubectl apply -f tensorflow.yaml</code>来运行 <code>Jupiter Notebook</code>。</p><figure class="highlight yaml"><figcaption><span>tensorflow.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8888</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">jupyter-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8888</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">tensorflow</span></span><br></pre></td></tr></table></figure><p>我们看到容器很快运行起来，根据 <code>http:&lt;nodeIP&gt;:&lt;nodePort&gt;</code> 可以访问到 <code>Jupiter Notebook</code>，但是显示需要token：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_tensorflow-jupiter.png"></p><p>查看 <code>Tensorflow</code> 日志，可以获得 token：<code>aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-1-14-centos single]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">tensorflow-6cbc85744b-c567p   1/1     Running   0          7m37s</span><br><span class="line">[root@VM-1-14-centos single]<span class="comment"># kubectl logs tensorflow-6cbc85744b-c567p</span></span><br><span class="line"></span><br><span class="line">________                               _______________</span><br><span class="line">___  __/__________________________________  ____/__  /________      __</span><br><span class="line">__  /  _  _ \_  __ \_  ___/  __ \_  ___/_  /_   __  /_  __ \_ | /| / /</span><br><span class="line">_  /   /  __/  / / /(__  )/ /_/ /  /   _  __/   _  / / /_/ /_ |/ |/ /</span><br><span class="line">/_/    \___//_/ /_//____/ \____//_/    /_/      /_/  \____/____/|__/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WARNING: You are running this container as root, <span class="built_in">which</span> can cause new files <span class="keyword">in</span></span><br><span class="line">mounted volumes to be created as the root user on your host machine.</span><br><span class="line"></span><br><span class="line">To avoid this, run the container by specifying your user<span class="string">'s userid:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ docker run -u $(id -u):$(id -g) args...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[I 04:47:52.083 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] Serving notebooks from local directory: /tf</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] Jupyter Notebook 6.1.4 is running at:</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] http://tensorflow-6cbc85744b-c567p:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp]  or http://127.0.0.1:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">[I 04:47:52.315 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span></span><br><span class="line"><span class="string">[C 04:47:52.319 NotebookApp]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To access the notebook, open this file in a browser:</span></span><br><span class="line"><span class="string">        file:///root/.local/share/jupyter/runtime/nbserver-1-open.html</span></span><br><span class="line"><span class="string">    Or copy and paste one of these URLs:</span></span><br><span class="line"><span class="string">        http://tensorflow-6cbc85744b-c567p:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">     or http://127.0.0.1:8888/?token=aa06c9f12d80adac1a6288b97bf8030522cecc92202dbb20</span></span><br><span class="line"><span class="string">[I 04:49:28.692 NotebookApp] 302 GET / (172.16.0.193) 0.57ms</span></span><br><span class="line"><span class="string">[I 04:49:28.700 NotebookApp] 302 GET /tree? (172.16.0.193) 0.67ms</span></span><br></pre></td></tr></table></figure><p>登陆之后即可看到 <code>Jupiter Notebook</code>：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_tensorflow-jupiter.png"></p><p>新建Notebook，运行命令如下：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_tensorflow-gpu.png"></p><p>可以看到，TensorFlow 支持在GPU上的运算</p><ul><li><code>&quot;/device:GPU:0&quot;</code>：TensorFlow 可见的机器上第一个 GPU 的速记表示法。</li><li><code>&quot;/job:localhost/replica:0/task:0/device:GPU:0&quot;</code>：TensorFlow 可见的机器上第一个 GPU 的完全限定名称。</li></ul><h3 id="分布式Tensorflow"><a href="#分布式Tensorflow" class="headerlink" title="分布式Tensorflow"></a>分布式Tensorflow</h3><p>整体架构：</p><p>这个架构图是分布式tensorflow的实战图，其中有</p><ul><li>两个参数服务</li><li>多个worker服务</li><li>还有个shuffle和抽样的服务</li></ul><p>shuffle就是对样根据其标签进行混排，然后对外提供batch抽样服务（可以是有放回和无放回，抽样是一门科学，详情可以参考抽样技术一书），每个batch的抽样是由每个worker去触发，worker拿到抽样的数据样本ID后就去基于kubernetes构建的分布式数据库里边提取该batchSize的样本数据，进行训练计算，由于分布式的tensorflow能够保证异步梯度下降算法，所以每次训练batch数据的时候都会基于最新的参数迭代，然而，更新参数操作就是两个参数服务做的，架构中模型（参数）的存储在NFS中，这样以来，参数服务与worker就可以共享参数了，最后说明一下，我们训练的所有数据都是存储在分布式数据库中（数据库的选型可以根据具体的场景而定）。为什么需要一个shuffle和抽样的服务，因为当数据量很大的时候，我们如果对所有的样本数据进行shuffle和抽样计算的话会浪费很大的资源，因此需要一个这样的服务专门提取数据的（id，label）来进行混排和抽样，这里如果（id, label）的数据量也很大的时候我们可以考虑基于spark 来分布式的进行shuffle和抽样，目前spark2.3已经原生支持kubernetes调度</p><p><img alt data-src="https://upload-images.jianshu.io/upload_images/3521279-7ab3727232db8073.png"></p><p>首先是 <code>Parameter Server</code>：</p><figure class="highlight yaml"><figcaption><span>tf-ps.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">ps</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ps</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2222</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/datanfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">nfs:</span></span><br><span class="line">          <span class="attr">server:</span> <span class="string">你的nfs服务地址</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">"/data/nfs"</span>   </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-ps-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2222</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">2222</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-ps</span></span><br></pre></td></tr></table></figure><p>然后是 <code>Worker</code>：</p><figure class="highlight yaml"><figcaption><span>tf-worker.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">worker</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">worker</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:2.2.1-gpu-py3-jupyter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">2222</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">4</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="number">2</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/datanfs</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">nfs:</span></span><br><span class="line">          <span class="attr">server:</span> <span class="string">你的nfs服务地址</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">"/data/nfs"</span>   </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tensorflow-wk-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">2222</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">2222</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensorflow-worker</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1005137" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1005137</a></li><li><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA Container Toolkit</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在 &lt;a href=&quot;https://houmin.cc/posts/5004f8e5/&quot;&gt;GPU 与 CUDA 编程入门&lt;/a&gt; 这篇博客中初步介绍了如何Linux上使用GPU的方法，随着容器和k8s的迅猛发展，人们对于在容器中使用GPU的需求越发强烈。本文将基于前文，继续介绍如何在容器中使用GPU，进一步地，介绍在Kubernetes中如何调度GPU，并以Tensorflow为例，介绍如何基于Docker搭建部署了GPU的深度学习开发环境。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-22_nvidia-gpu-docker.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="container" scheme="http://houmin.cc/tags/container/"/>
    
      <category term="docker" scheme="http://houmin.cc/tags/docker/"/>
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="Nvidia" scheme="http://houmin.cc/tags/Nvidia/"/>
    
      <category term="tensorflow" scheme="http://houmin.cc/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>【Kubernetes】Device Plugin</title>
    <link href="http://houmin.cc/posts/3f069334/"/>
    <id>http://houmin.cc/posts/3f069334/</id>
    <published>2020-11-16T07:31:42.000Z</published>
    <updated>2020-12-17T03:27:17.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Kubernetes 原生支持对于CPU和内存资源的发现，但是有很多其他的设备 kubelet不能原生处理，比如GPU、FPGA、RDMA、存储设备和其他类似的异构计算资源设备。为了能够使用这些设备资源，我们需要进行各个设备的初始化和设置。按照 Kubernetes 的 <code>OutOfTree</code> 的哲学理念，我们不应该把各个厂商的设备初始化设置相关代码与 Kubernetes 核心代码放在一起。与之相反，我们需要一种机制能够让各个设备厂商向 Kubelet 上报设备资源，而不需要修改 Kubernetes 核心代码。这即是 <code>Device Plugin</code> 这一机制的来源，本文将介绍 Device Plugin 的实现原理，并介绍其使用。</p><a id="more"></a><h2 id="Device-插件原理"><a href="#Device-插件原理" class="headerlink" title="Device 插件原理"></a>Device 插件原理</h2><p>Device Plugin 实际上是一个 gPRC server，Device 插件一般推荐使用 DaemonSet 的方式部署，并将 <code>/var/lib/kubelet/device-plugins</code> 以 Volume 的形式挂载到容器中。当然，也可以手动运行的方式来部署，但这样就没有失败自动恢复的功能了。</p><p>为了能够使用某个厂商的特定设备，一般有两步：</p><ul><li><code>kubectl create -f http://vendor.com/device-plugin-daemonset.yaml</code></li><li>执行 <code>kubectl describe nodes</code>的时候，相关设备会出现在node status中：<code>vendor-domain/vendor-device</code></li></ul><p>当 Device Plugin 向 kubelet 注册后，kubelet 就通过 RPC 与 Device Plugin 交互：</p><ul><li><code>ListAndWatch()</code> ：让 kubelet 发现设备资源和对应属性，并且在设备资源发生变动的时候接收通知</li><li><code>Allocate()</code> ：kubelet 在创建容器前通过 Allocate来申请相关设备资源</li></ul><p><img alt="Process" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_k8s-device-plugin.png"></p><h3 id="Registration"><a href="#Registration" class="headerlink" title="Registration"></a>Registration</h3><p>为了向 kubelet 告知 Device Plugin 的存在，Device Plugin 必须向 kubelet 发出注册请求，这之后 kubelet 才会和 Device Plugin 通过 <code>gRPC</code>交互，具体过程如下：</p><ul><li>Device Plugin 向 Kubelet 发送一个 <code>RegisterRequest</code>的请求</li><li>Kubelet 收到 <code>RegisterRequest</code> 请求后，返回一个 <code>RegisterResponse</code>，如果Kubelet碰到任何错误，会把错误附在Response中</li><li>如果 Device Plugin 没有收到任何错误，则启动他的 gRPC server</li></ul><p>插件启动后要持续监控 Kubelet 的状态，并在 Kubelet 重启后重新注册自己。比如，Kubelet 刚启动后会清空 <code>/var/lib/kubelet/device-plugins/</code> 目录，所以插件作者可以监控自己监听的 unix socket 是否被删除了，并根据此事件重新注册自己</p><h3 id="Unix-Socket"><a href="#Unix-Socket" class="headerlink" title="Unix Socket"></a>Unix Socket</h3><p>Device Plugin 和 Kubelet 通过在一个 Unix Socket上使用 gRPC 交互，当启动 gRPC server的时候，Device Plugin 将会在 <code>/var/lib/kubelet/device-plugins/</code>  这个 HostPath 创建一个 UnixSocket，比如 <code>/var/lib/kubelet/device-plugins/nvidiaGPU.sock</code>。</p><p>在实现 Device 插件时需要注意</p><ul><li>插件启动时，需要通过 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 向 Kubelet 注册，同时提供插件的 Unix Socket 名称、API 的版本号和插件名称（格式为 <code>vendor-domain/resource</code>，如 <code>nvidia.com/gpu</code>）。Kubelet 会将这些设备暴露到 Node 状态中，方便后续调度器使用</li><li>插件启动后向 Kubelet 发送插件列表、按需分配设备并持续监控设备的实时状态</li></ul><h3 id="Protocol-Overview"><a href="#Protocol-Overview" class="headerlink" title="Protocol Overview"></a>Protocol Overview</h3><p><img alt="Protocol Overview" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_k8s-device-plugin-protocol.png"></p><h3 id="API-specification"><a href="#API-specification" class="headerlink" title="API specification"></a>API specification</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Registration is the service advertised by the Kubelet</span></span><br><span class="line"><span class="comment">// Only when Kubelet answers with a success code to a Register Request</span></span><br><span class="line"><span class="comment">// may Device Plugins start their service</span></span><br><span class="line"><span class="comment">// Registration may fail when device plugin version is not supported by</span></span><br><span class="line"><span class="comment">// Kubelet or the registered resourceName is already taken by another</span></span><br><span class="line"><span class="comment">// active device plugin. Device plugin is expected to terminate upon registration failure</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Registration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Register(RegisterRequest) <span class="keyword">returns</span> (Empty) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message DevicePluginOptions &#123;</span></span><br><span class="line"><span class="function">  // Indicates if PreStartContainer call is required before each container start</span></span><br><span class="line"><span class="function">    bool pre_start_required = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">RegisterRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Version of the API the Device Plugin was built against</span></span><br><span class="line">    <span class="built_in">string</span> version = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Name of the unix socket the device plugin is listening on</span></span><br><span class="line">    <span class="comment">// PATH = path.Join(DevicePluginPath, endpoint)</span></span><br><span class="line">    <span class="built_in">string</span> endpoint = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Schedulable resource name. As of now it's expected to be a DNS Label</span></span><br><span class="line">    <span class="built_in">string</span> resource_name = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// Options to be communicated with Device Manager</span></span><br><span class="line">    options = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Empty</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DevicePlugin is the service advertised by Device Plugins</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">DevicePlugin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GetDevicePluginOptions returns options to be communicated with Device</span></span><br><span class="line">    <span class="comment">// Manager</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetDevicePluginOptions(Empty) <span class="keyword">returns</span> (DevicePluginOptions) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // ListAndWatch <span class="keyword">returns</span> a stream of List of Devices</span></span><br><span class="line"><span class="function">    // Whenever a Device state change or a Device disapears, ListAndWatch</span></span><br><span class="line"><span class="function">    // <span class="keyword">returns</span> the new list</span></span><br><span class="line"><span class="function">    <span class="keyword">rpc</span> ListAndWatch(Empty) <span class="keyword">returns</span> (stream ListAndWatchResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // Allocate is called during container creation so that the Device</span></span><br><span class="line"><span class="function">    // Plugin can run device specific operations and instruct Kubelet</span></span><br><span class="line"><span class="function">    // of the steps to make the Device available in the container</span></span><br><span class="line"><span class="function">    <span class="keyword">rpc</span> Allocate(AllocateRequest) <span class="keyword">returns</span> (AllocateResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // PreStartContainer is called, if indicated by Device Plugin during registeration phase,</span></span><br><span class="line"><span class="function">    // before each container start. Device plugin can run device specific operations</span></span><br><span class="line"><span class="function">    // such as reseting the device before making devices available to the container</span></span><br><span class="line"><span class="function">    <span class="keyword">rpc</span> PreStartContainer(PreStartContainerRequest) <span class="keyword">returns</span> (PreStartContainerResponse) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// ListAndWatch <span class="keyword">returns</span> a stream of List of Devices</span></span><br><span class="line"><span class="function">// Whenever a Device state change or a Device disapears, ListAndWatch</span></span><br><span class="line"><span class="function">// <span class="keyword">returns</span> the new list</span></span><br><span class="line"><span class="function">message ListAndWatchResponse &#123;</span></span><br><span class="line"><span class="function">    repeated Device devices = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* E.g:</span><br><span class="line">* struct Device &#123;</span><br><span class="line">*    ID: <span class="string">"GPU-fef8089b-4820-abfc-e83e-94318197576e"</span>,</span><br><span class="line">*    State: <span class="string">"Healthy"</span>,</span><br><span class="line">*&#125; */</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A unique ID assigned by the device plugin used</span></span><br><span class="line">    <span class="comment">// to identify devices during the communication</span></span><br><span class="line">    <span class="comment">// Max length of this field is 63 characters</span></span><br><span class="line">    <span class="built_in">string</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Health of the device, can be healthy or unhealthy, see constants.go</span></span><br><span class="line">    <span class="built_in">string</span> health = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - PreStartContainer is expected to be called before each container start if indicated by plugin during registration phase.</span></span><br><span class="line"><span class="comment">// - PreStartContainer allows kubelet to pass reinitialized devices to containers.</span></span><br><span class="line"><span class="comment">// - PreStartContainer allows Device Plugin to run device specific operations on</span></span><br><span class="line"><span class="comment">//   the Devices requested</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PreStartContainerRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> devicesIDs = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreStartContainerResponse will be send by plugin in response to PreStartContainerRequest</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PreStartContainerResponse</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - Allocate is expected to be called during pod creation since allocation</span></span><br><span class="line"><span class="comment">//   failures for any container would result in pod startup failure.</span></span><br><span class="line"><span class="comment">// - Allocate allows kubelet to exposes additional artifacts in a pod's</span></span><br><span class="line"><span class="comment">//   environment as directed by the plugin.</span></span><br><span class="line"><span class="comment">// - Allocate allows Device Plugin to run device specific operations on</span></span><br><span class="line"><span class="comment">//   the Devices requested</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AllocateRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> ContainerAllocateRequest container_requests = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ContainerAllocateRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> devicesIDs = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllocateResponse includes the artifacts that needs to be injected into</span></span><br><span class="line"><span class="comment">// a container for accessing 'deviceIDs' that were mentioned as part of</span></span><br><span class="line"><span class="comment">// 'AllocateRequest'.</span></span><br><span class="line"><span class="comment">// Failure Handling:</span></span><br><span class="line"><span class="comment">// if Kubelet sends an allocation request for dev1 and dev2.</span></span><br><span class="line"><span class="comment">// Allocation on dev1 succeeds but allocation on dev2 fails.</span></span><br><span class="line"><span class="comment">// The Device plugin should send a ListAndWatch update and fail the</span></span><br><span class="line"><span class="comment">// Allocation request</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AllocateResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> ContainerAllocateResponse container_responses = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ContainerAllocateResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// List of environment variable to be set in the container to access one of more devices.</span></span><br><span class="line">    map&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; envs = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Mounts for the container.</span></span><br><span class="line">    <span class="keyword">repeated</span> Mount mounts = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Devices for the container.</span></span><br><span class="line">    <span class="keyword">repeated</span> DeviceSpec devices = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// Container annotations to pass to the container runtime</span></span><br><span class="line">    map&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; annotations = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount specifies a host volume to mount into a container.</span></span><br><span class="line"><span class="comment">// where device library or tools are installed on host and container</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Mount</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Path of the mount within the container.</span></span><br><span class="line">    <span class="built_in">string</span> container_path = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Path of the mount on the host.</span></span><br><span class="line">    <span class="built_in">string</span> host_path = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// If set, the mount is read-only.</span></span><br><span class="line">    <span class="built_in">bool</span> read_only = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeviceSpec specifies a host device to mount into a container.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">DeviceSpec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Path of the device within the container.</span></span><br><span class="line">  <span class="built_in">string</span> container_path = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Path of the device on the host.</span></span><br><span class="line">  <span class="built_in">string</span> host_path = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// Cgroups permissions of the device, candidates are one or more of</span></span><br><span class="line">  <span class="comment">// * r - allows container to read from the specified device.</span></span><br><span class="line">  <span class="comment">// * w - allows container to write to the specified device.</span></span><br><span class="line">  <span class="comment">// * m - allows container to create device files that do not yet exist.</span></span><br><span class="line">  <span class="built_in">string</span> permissions = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件生命周期管理"><a href="#插件生命周期管理" class="headerlink" title="插件生命周期管理"></a>插件生命周期管理</h3><p>插件启动时，以grpc的形式通过/var/lib/kubelet/device-plugins/kubelet.sock向Kubelet注册，同时提供插件的监听Unix Socket，API版本号和设备名称（比如nvidia.com/gpu）。Kubelet将会把这些设备暴露到Node状态中，以Extended Resource的要求发送到API server中，后续Scheduler会根据这些信息进行调度。</p><p>插件启动后，Kubelet会建立一个到插件的listAndWatch长连接，当插件检测到某个设备不健康的时候，就会主动通知Kubelet。此时如果这个设备处于空闲状态，Kubelet就会将其挪出可分配列表；如果该设备已经被某个pod使用，Kubelet就会将该Pod杀掉</p><p>插件启动后可以利用Kubelet的socket持续检查Kubelet的状态，如果Kubelet重启，插件也会相应的重启，并且重新向Kubelet注册自己</p><h2 id="NVIDIA-Device-Plugin"><a href="#NVIDIA-Device-Plugin" class="headerlink" title="NVIDIA Device Plugin"></a>NVIDIA Device Plugin</h2><p>NVIDIA 提供了一个基于 Device Plugins 接口的 GPU 设备插件 <a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA/k8s-device-plugin</a>。</p><p>部署</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/master/nvidia-device-plugin.yml</span><br></pre></td></tr></table></figure><p>创建 Pod 时请求 GPU 资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nvidia/cuda</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod1-ctr</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["sleep"]</span></span><br><span class="line">    <span class="attr">args:</span> <span class="string">["100000"]</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意：使用该插件时需要配置 <a href="https://github.com/NVIDIA/nvidia-docker/" target="_blank" rel="external nofollow noopener noreferrer">nvidia-docker 2.0</a>，并配置 <code>nvidia</code> 为默认运行时 （即配置 docker daemon 的选项 <code>--default-runtime=nvidia</code>）。nvidia-docker 2.0 的安装方法为（以 Ubuntu Xenial 为例，其他系统的安装方法可以参考 <a href="http://nvidia.github.io/nvidia-docker/" target="_blank" rel="external nofollow noopener noreferrer">这里</a>）：</p><p>整个Kubernetes调度GPU的过程如下：</p><ul><li>GPU Device plugin 部署到GPU节点上，通过 <code>ListAndWatch</code> 接口，上报注册节点的GPU信息和对应的DeviceID。 </li><li>当有声明 <code>nvidia.com/gpu</code> 的GPU Pod创建出现，调度器会综合考虑GPU设备的空闲情况，将Pod调度到有充足GPU设备的节点上。</li><li>节点上的kubelet 启动Pod时，根据request中的声明调用各个Device plugin 的 allocate接口， 由于容器声明了GPU。 kubelet 根据之前 <code>ListAndWatch</code> 接口收到的Device信息，选取合适的设备，DeviceID 作为参数，调用GPU DevicePlugin的 <code>Allocate</code> 接口</li><li>GPU DevicePlugin ，接收到调用，将DeviceID 转换为 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，返回kubelet</li><li>kubelet将环境变量注入到Pod， 启动容器</li><li>容器启动时， <code>gpu-container-runtime</code> 调用 <code>gpu-containers-runtime-hook</code> </li><li><code>gpu-containers-runtime-hook</code> 根据容器的 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，转换为 <code>--devices</code> 参数，调用 <code>nvidia-container-cli prestart</code> </li><li><code>nvidia-container-cli</code> 根据 <code>--devices</code> ，将GPU设备映射到容器中。 并且将宿主机的Nvidia Driver Lib 的so文件也映射到容器中。 此时容器可以通过这些so文件，调用宿主机的Nvidia Driver。</li></ul><p>在前面 <code>API Specification</code> 中，通过 <code>Protobuf</code> 定义了 <code>DevicePlugin</code> 应该提供的服务，在 <code>Kubelet</code> 中会调用 <code>DevicePluginClient</code> 来使用对应的服务，这里的 <code>DevicePluginClient</code> 即是通过 <code>Protobuf</code> 自动生成的代码。</p><figure class="highlight go"><figcaption><span>k8s.io/kubelet/pkg/apis/deviceplugin/v1beta1/api.pb.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DevicePluginClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetDevicePluginOptions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DevicePluginOptions, error)</span><br><span class="line">    ListAndWatch(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DevicePlugin_ListAndWatchClient, error)</span><br><span class="line">    Allocate(ctx context.Context, in *AllocateRequest, opts ...grpc.CallOption) (*AllocateResponse, error)</span><br><span class="line">    PreStartContainer(ctx context.Context, in *PreStartContainerRequest, opts ...grpc.CallOption) (*PreStartContainerResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NVIDIA/k8s-device-plugin</code> 中，我们可以看到上面不同服务的具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">GetDevicePluginOptions</span><span class="params">(context.Context, *pluginapi.Empty)</span> <span class="params">(*pluginapi.DevicePluginOptions, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">ListAndWatch</span><span class="params">(e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">Allocate</span><span class="params">(ctx context.Context, reqs *pluginapi.AllocateRequest)</span> <span class="params">(*pluginapi.AllocateResponse, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">PreStartContainer</span><span class="params">(context.Context, *pluginapi.PreStartContainerRequest)</span> <span class="params">(*pluginapi.PreStartContainerResponse, error)</span></span></span><br></pre></td></tr></table></figure><p>对 <code>NVIDIA/k8s-device-plugin</code> 来说，这里的关键数据结构为 <code>NvidiaDevicePlugin</code>，它实现了 <code>Device Plugin</code> 架构定义的API：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NvidiaDevicePlugin <span class="keyword">struct</span> &#123;</span><br><span class="line">    ResourceManager</span><br><span class="line">    resourceName     <span class="keyword">string</span></span><br><span class="line">    deviceListEnvvar <span class="keyword">string</span></span><br><span class="line">    allocatePolicy   gpuallocator.Policy</span><br><span class="line">    socket           <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    server        *grpc.Server</span><br><span class="line">    cachedDevices []*Device</span><br><span class="line">    health        <span class="keyword">chan</span> *Device</span><br><span class="line">    stop          <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面根据 <code>Device Plugin</code> 的生命周期，依次分析每个部分的实现机制。</p><h3 id="NVIDIA-DevicePlugin-启动"><a href="#NVIDIA-DevicePlugin-启动" class="headerlink" title="NVIDIA DevicePlugin 启动"></a>NVIDIA DevicePlugin 启动</h3><p><code>NVIDIA</code> 的 <code>k8s-device-plugin</code> 启动之后逻辑如下，总的来说干了三件事：</p><ul><li>Serve：启动 <code>gRPC server</code>  </li><li>Register：向 <code>Kubelet</code> 注册给定的 <code>resourceName</code></li><li>CheckHealth：执行设备的健康检查逻辑，当检查到不健康的设备时，写到 <code>unhealthy</code> 的 channel 中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    m.initialize()</span><br><span class="line"></span><br><span class="line">    err := m.Serve()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    err = m.Register()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">go</span> m.CheckHealth(m.stop, m.cachedDevices, m.health)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Serve"><a href="#Serve" class="headerlink" title="Serve"></a>Serve</h4><p><code>Serve</code> 监听在<code>/var/lib/kubelet/device-plugins/nvidia-gpu.sock</code> 这 个 <code>Unix Socket</code>，并且启动了 <code>gRPC server</code>，其他的就是启动失败重试的逻辑了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">Serve</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    os.Remove(m.socket)</span><br><span class="line">    sock, err := net.Listen(<span class="string">"unix"</span>, m.socket)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pluginapi.RegisterDevicePluginServer(m.server, m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lastCrashTime := time.Now()</span><br><span class="line">        restartCount := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Starting GRPC server for '%s'"</span>, m.resourceName)</span><br><span class="line">            err := m.server.Serve(sock)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">"GRPC server for '%s' crashed with error: %v"</span>, m.resourceName, err)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// restart if it has not been too often</span></span><br><span class="line">            <span class="comment">// i.e. if server has crashed more than 5 times and it didn't last more than one hour each time</span></span><br><span class="line">            <span class="keyword">if</span> restartCount &gt; <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">// quit</span></span><br><span class="line">                log.Fatalf(<span class="string">"GRPC server for '%s' has repeatedly crashed recently. Quitting"</span>, m.resourceName)</span><br><span class="line">            &#125;</span><br><span class="line">            timeSinceLastCrash := time.Since(lastCrashTime).Seconds()</span><br><span class="line">            lastCrashTime = time.Now()</span><br><span class="line">            <span class="keyword">if</span> timeSinceLastCrash &gt; <span class="number">3600</span> &#123;</span><br><span class="line">                <span class="comment">// it has been one hour since the last crash.. reset the count</span></span><br><span class="line">                <span class="comment">// to reflect on the frequency</span></span><br><span class="line">                restartCount = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                restartCount++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for server to start by launching a blocking connexion</span></span><br><span class="line">    conn, err := m.dial(m.socket, <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p><code>Register</code> 通过和 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 这个 <code>Unix Socket</code> 向 <code>Kubelet</code> 注册，传递了 <code>DevicePlugin</code> 的 <code>Unix Socket</code> 的 Endpoint、资源的名称、API的版本号等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">Register</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    conn, err := m.dial(pluginapi.KubeletSocket, <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    client := pluginapi.NewRegistrationClient(conn)</span><br><span class="line">    reqt := &amp;pluginapi.RegisterRequest&#123;</span><br><span class="line">        Version:      pluginapi.Version,</span><br><span class="line">        Endpoint:     path.Base(m.socket),</span><br><span class="line">        ResourceName: m.resourceName,</span><br><span class="line">        Options: &amp;pluginapi.DevicePluginOptions&#123;</span><br><span class="line">            GetPreferredAllocationAvailable: (m.allocatePolicy != <span class="literal">nil</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = client.Register(context.Background(), reqt)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckHealth"><a href="#CheckHealth" class="headerlink" title="CheckHealth"></a>CheckHealth</h4><p>这里调用了 <code>nvml.NewEventSet</code> 来监听 GPU 是否发生变化的事件，并且将 <code>unhealthy Device</code>  传递给 <code>m.health</code> 这个<code>channel</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkHealth</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, devices []*Device, unhealthy <span class="keyword">chan</span>&lt;- *Device)</span></span> &#123;</span><br><span class="line">    disableHealthChecks := strings.ToLower(os.Getenv(envDisableHealthChecks))</span><br><span class="line">    <span class="keyword">if</span> disableHealthChecks == <span class="string">"all"</span> &#123;</span><br><span class="line">        disableHealthChecks = allHealthChecks</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(disableHealthChecks, <span class="string">"xids"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventSet := nvml.NewEventSet()</span><br><span class="line">    <span class="keyword">defer</span> nvml.DeleteEventSet(eventSet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">        gpu, _, _, err := nvml.ParseMigDeviceUUID(d.ID)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            gpu = d.ID</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = nvml.RegisterEventForDevice(eventSet, nvml.XidCriticalError, gpu)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; strings.HasSuffix(err.Error(), <span class="string">"Not Supported"</span>) &#123;</span><br><span class="line">            log.Printf(<span class="string">"Warning: %s is too old to support healthchecking: %s. Marking it unhealthy."</span>, d.ID, err)</span><br><span class="line">            unhealthy &lt;- d</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        check(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e, err := nvml.WaitForEvent(eventSet, <span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; e.Etype != nvml.XidCriticalError &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> formalize the full list and document it.</span></span><br><span class="line">        <span class="comment">// http://docs.nvidia.com/deploy/xid-errors/index.html#topic_4</span></span><br><span class="line">        <span class="comment">// Application errors: the GPU should still be healthy</span></span><br><span class="line">        <span class="keyword">if</span> e.Edata == <span class="number">31</span> || e.Edata == <span class="number">43</span> || e.Edata == <span class="number">45</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> e.UUID == <span class="literal">nil</span> || <span class="built_in">len</span>(*e.UUID) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// All devices are unhealthy</span></span><br><span class="line">            log.Printf(<span class="string">"XidCriticalError: Xid=%d, All devices will go unhealthy."</span>, e.Edata)</span><br><span class="line">            <span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">                unhealthy &lt;- d</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">            <span class="comment">// Please see https://github.com/NVIDIA/gpu-monitoring-tools/blob/148415f505c96052cb3b7fdf443b34ac853139ec/bindings/go/nvml/nvml.h#L1424</span></span><br><span class="line">            <span class="comment">// for the rationale why gi and ci can be set as such when the UUID is a full GPU UUID and not a MIG device UUID.</span></span><br><span class="line">            gpu, gi, ci, err := nvml.ParseMigDeviceUUID(d.ID)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                gpu = d.ID</span><br><span class="line">                gi = <span class="number">0xFFFFFFFF</span></span><br><span class="line">                ci = <span class="number">0xFFFFFFFF</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> gpu == *e.UUID &amp;&amp; gi == *e.GpuInstanceId &amp;&amp; ci == *e.ComputeInstanceId &#123;</span><br><span class="line">                log.Printf(<span class="string">"XidCriticalError: Xid=%d on Device=%s, the device will go unhealthy."</span>, e.Edata, d.ID)</span><br><span class="line">                unhealthy &lt;- d</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kubelet-DeviceManager"><a href="#Kubelet-DeviceManager" class="headerlink" title="Kubelet DeviceManager"></a>Kubelet DeviceManager</h3><h4 id="DeviceManager-启动"><a href="#DeviceManager-启动" class="headerlink" title="DeviceManager 启动"></a>DeviceManager 启动</h4><figure class="highlight go"><figcaption><span>kubernetes/pkg/kubelet/cm/devicemanager/manager.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    socketname <span class="keyword">string</span></span><br><span class="line">    socketdir  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    endpoints <span class="keyword">map</span>[<span class="keyword">string</span>]endpointInfo <span class="comment">// Key is ResourceName</span></span><br><span class="line">    mutex     sync.Mutex</span><br><span class="line"></span><br><span class="line">    server *grpc.Server</span><br><span class="line">    wg     sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// activePods is a method for listing active pods on the node</span></span><br><span class="line">    <span class="comment">// so the amount of pluginResources requested by existing pods</span></span><br><span class="line">    <span class="comment">// could be counted when updating allocated devices</span></span><br><span class="line">    activePods ActivePodsFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sourcesReady provides the readiness of kubelet configuration sources such as apiserver update readiness.</span></span><br><span class="line">    <span class="comment">// We use it to determine when we can purge inactive pods from checkpointed state.</span></span><br><span class="line">    sourcesReady config.SourcesReady</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callback is used for updating devices' states in one time call.</span></span><br><span class="line">    <span class="comment">// e.g. a new device is advertised, two old devices are deleted and a running device fails.</span></span><br><span class="line">    callback monitorCallback</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allDevices is a map by resource name of all the devices currently registered to the device manager</span></span><br><span class="line">    allDevices <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]pluginapi.Device</span><br><span class="line"></span><br><span class="line">    <span class="comment">// healthyDevices contains all of the registered healthy resourceNames and their exported device IDs.</span></span><br><span class="line">    healthyDevices <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unhealthyDevices contains all of the unhealthy devices and their exported device IDs.</span></span><br><span class="line">    unhealthyDevices <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocatedDevices contains allocated deviceIds, keyed by resourceName.</span></span><br><span class="line">    allocatedDevices <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br><span class="line"></span><br><span class="line">    <span class="comment">// podDevices contains pod to allocated device mapping.</span></span><br><span class="line">    podDevices        podDevices</span><br><span class="line">    checkpointManager checkpointmanager.CheckpointManager</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List of NUMA Nodes available on the underlying machine</span></span><br><span class="line">    numaNodes []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store of Topology Affinties that the Device Manager can query.</span></span><br><span class="line">    topologyAffinityStore topologymanager.Store</span><br><span class="line"></span><br><span class="line">    <span class="comment">// devicesToReuse contains devices that can be reused as they have been allocated to</span></span><br><span class="line">    <span class="comment">// init containers.</span></span><br><span class="line">    devicesToReuse PodReusableDevices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Device Manager</code> 在 <code>kubelet</code> 启动时的 <code>NewContainerManager</code> 中创建,属于 <code>containerManager</code> 的子模块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerManager</span><span class="params">(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn <span class="keyword">bool</span>, devicePluginEnabled <span class="keyword">bool</span>, recorder record.EventRecorder)</span> <span class="params">(ContainerManager, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    klog.Infof(<span class="string">"Creating device plugin manager: %t"</span>, devicePluginEnabled)</span><br><span class="line">    <span class="keyword">if</span> devicePluginEnabled &#123;</span><br><span class="line">        cm.deviceManager, err = devicemanager.NewManagerImpl(numaNodeInfo, cm.topologyManager)</span><br><span class="line">        cm.topologyManager.AddHintProvider(cm.deviceManager)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cm.deviceManager, err = devicemanager.NewManagerStub()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体创建 <code>DeviceManager</code> 的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newManagerImpl</span><span class="params">(socketPath <span class="keyword">string</span>, numaNodeInfo cputopology.NUMANodeInfo, topologyAffinityStore topologymanager.Store)</span> <span class="params">(*ManagerImpl, error)</span></span> &#123;</span><br><span class="line">    klog.V(<span class="number">2</span>).Infof(<span class="string">"Creating Device Plugin manager at %s"</span>, socketPath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> socketPath == <span class="string">""</span> || !filepath.IsAbs(socketPath) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(errBadSocket+<span class="string">" %s"</span>, socketPath)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> numaNodes []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> node := <span class="keyword">range</span> numaNodeInfo &#123;</span><br><span class="line">        numaNodes = <span class="built_in">append</span>(numaNodes, node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir, file := filepath.Split(socketPath)</span><br><span class="line">    manager := &amp;ManagerImpl&#123;</span><br><span class="line">        endpoints: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]endpointInfo),</span><br><span class="line"></span><br><span class="line">        socketname:            file,</span><br><span class="line">        socketdir:             dir,</span><br><span class="line">        allDevices:            <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]pluginapi.Device),</span><br><span class="line">        healthyDevices:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sets.String),</span><br><span class="line">        unhealthyDevices:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sets.String),</span><br><span class="line">        allocatedDevices:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sets.String),</span><br><span class="line">        podDevices:            <span class="built_in">make</span>(podDevices),</span><br><span class="line">        numaNodes:             numaNodes,</span><br><span class="line">        topologyAffinityStore: topologyAffinityStore,</span><br><span class="line">        devicesToReuse:        <span class="built_in">make</span>(PodReusableDevices),</span><br><span class="line">    &#125;</span><br><span class="line">    manager.callback = manager.genericDeviceUpdateCallback</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following structures are populated with real implementations in manager.Start()</span></span><br><span class="line">    <span class="comment">// Before that, initializes them to perform no-op operations.</span></span><br><span class="line">    manager.activePods = <span class="function"><span class="keyword">func</span><span class="params">()</span> []*<span class="title">v1</span>.<span class="title">Pod</span></span> &#123; <span class="keyword">return</span> []*v1.Pod&#123;&#125; &#125;</span><br><span class="line">    manager.sourcesReady = &amp;sourcesReadyStub&#123;&#125;</span><br><span class="line">    checkpointManager, err := checkpointmanager.NewCheckpointManager(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to initialize checkpoint manager: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    manager.checkpointManager = checkpointManager</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中除了构建 <code>DeviceManager</code> 相关的结构之外，另外做的一个事情就是注册了一个 <code>callback</code>，用来处理对应 <code>devices</code> 的<code>add</code>，<code>delete</code>，<code>update</code> 事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">genericDeviceUpdateCallback</span><span class="params">(resourceName <span class="keyword">string</span>, devices []pluginapi.Device)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    m.healthyDevices[resourceName] = sets.NewString()</span><br><span class="line">    m.unhealthyDevices[resourceName] = sets.NewString()</span><br><span class="line">    m.allDevices[resourceName] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]pluginapi.Device)</span><br><span class="line">    <span class="keyword">for</span> _, dev := <span class="keyword">range</span> devices &#123;</span><br><span class="line">        m.allDevices[resourceName][dev.ID] = dev</span><br><span class="line">        <span class="keyword">if</span> dev.Health == pluginapi.Healthy &#123;</span><br><span class="line">            m.healthyDevices[resourceName].Insert(dev.ID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m.unhealthyDevices[resourceName].Insert(dev.ID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> err := m.writeCheckpoint(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"writing checkpoint encountered %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来到了 <code>DeviceManager</code> 启动的方法，它读取了 <code>checkpoint file</code> 中的数据，恢复 <code>ManagerImpl</code>中的相关数据，包括：</p><ul><li>podDevices</li><li>allocatedDevices</li><li>healthyDevices</li><li>unhealthyDevices</li><li>endpoints</li></ul><p>然后将 <code>/var/lib/kubelet/device-plugins/</code> 下面的除了 <code>checkpiont文件</code> 的所有文件清空，也就是清空所有的socket文件，包括自己的 <code>kubelet.sock</code>，以及其他所有之前的 <code>DevicePlugin</code> 的socket文件。最后创建 <code>kubelet.sock</code> 并启动 <code>gRPC Server</code>对外提供gRPC服务，其中 <code>Register()</code>用于 <code>DevicePlugin</code> 调用进行插件注册。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">Start</span><span class="params">(activePods ActivePodsFunc, sourcesReady config.SourcesReady)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    klog.V(<span class="number">2</span>).Infof(<span class="string">"Starting Device Plugin manager"</span>)</span><br><span class="line"></span><br><span class="line">    m.activePods = activePods</span><br><span class="line">    m.sourcesReady = sourcesReady</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loads in allocatedDevices information from disk.</span></span><br><span class="line">    err := m.readCheckpoint()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Warningf(<span class="string">"Continue after failing to read checkpoint file. Device allocation info may NOT be up-to-date. Err: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socketPath := filepath.Join(m.socketdir, m.socketname)</span><br><span class="line">    <span class="keyword">if</span> err = os.MkdirAll(m.socketdir, <span class="number">0750</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> selinux.SELinuxEnabled() &#123;</span><br><span class="line">        <span class="keyword">if</span> err := selinux.SetFileLabel(m.socketdir, config.KubeletPluginsDirSELinuxLabel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Warningf(<span class="string">"Unprivileged containerized plugins might not work. Could not set selinux context on %s: %v"</span>, m.socketdir, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes all stale sockets in m.socketdir. Device plugins can monitor</span></span><br><span class="line">    <span class="comment">// this and use it as a signal to re-register with the new Kubelet.</span></span><br><span class="line">    <span class="keyword">if</span> err := m.removeContents(m.socketdir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Fail to clean up stale contents under %s: %v"</span>, m.socketdir, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s, err := net.Listen(<span class="string">"unix"</span>, socketPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(errListenSocket+<span class="string">" %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.wg.Add(<span class="number">1</span>)</span><br><span class="line">    m.server = grpc.NewServer([]grpc.ServerOption&#123;&#125;...)</span><br><span class="line"></span><br><span class="line">    pluginapi.RegisterRegistrationServer(m.server, m)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> m.wg.Done()</span><br><span class="line">        m.server.Serve(s)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    klog.V(<span class="number">2</span>).Infof(<span class="string">"Serving device plugin registration server on %q"</span>, socketPath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DeviceManager-注册"><a href="#DeviceManager-注册" class="headerlink" title="DeviceManager 注册"></a>DeviceManager 注册</h4><p><code>DeviceManager</code> 接收到 <code>DevicePlugin</code>的 RegisterRequest请求，其结构体如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisterRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">   Version <span class="keyword">string</span></span><br><span class="line">   Endpoint <span class="keyword">string</span> </span><br><span class="line">   ResourceName <span class="keyword">string</span> </span><br><span class="line">   Options   *DevicePluginOptions </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查注册的device Name、version是否符合 <code>Extended Resource</code> 的规则，Name不能属于kubernetes.i  o，得有自己的domain，比如<code>nvidia.com</code></p><p>根据 <code>endpoint</code> 信息创建 <code>EndpointImpl</code> 对象，即根据 <code>endpoint</code> 建立 <code>socket</code> 连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">RegisterPlugin</span><span class="params">(pluginName <span class="keyword">string</span>, endpoint <span class="keyword">string</span>, versions []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    klog.V(<span class="number">2</span>).Infof(<span class="string">"Registering Plugin %s at endpoint %s"</span>, pluginName, endpoint)</span><br><span class="line"></span><br><span class="line">    e, err := newEndpointImpl(endpoint, pluginName, m.callback)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to dial device plugin with socketPath %s: %v"</span>, endpoint, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options, err := e.client.GetDevicePluginOptions(context.Background(), &amp;pluginapi.Empty&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get device plugin options: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.registerEndpoint(pluginName, options, e)</span><br><span class="line">    <span class="keyword">go</span> m.runEndpoint(pluginName, e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>endPointsImpl</code>  的具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> endpointImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    client     pluginapi.DevicePluginClient</span><br><span class="line">    clientConn *grpc.ClientConn</span><br><span class="line"></span><br><span class="line">    socketPath   <span class="keyword">string</span></span><br><span class="line">    resourceName <span class="keyword">string</span></span><br><span class="line">    stopTime     time.Time</span><br><span class="line"></span><br><span class="line">    mutex sync.Mutex</span><br><span class="line">    cb    monitorCallback</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEndpointImpl</span><span class="params">(socketPath, resourceName <span class="keyword">string</span>, callback monitorCallback)</span> <span class="params">(*endpointImpl, error)</span></span> &#123;</span><br><span class="line">    client, c, err := dial(socketPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Can't create new endpoint with path %s err %v"</span>, socketPath, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;endpointImpl&#123;</span><br><span class="line">        client:     client,</span><br><span class="line">        clientConn: c,</span><br><span class="line"></span><br><span class="line">        socketPath:   socketPath,</span><br><span class="line">        resourceName: resourceName,</span><br><span class="line"></span><br><span class="line">        cb: callback,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>EndpointImpl</code> 对象的 <code>run()</code>，在 <code>run</code>方法中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpointImpl)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stream, err := e.client.ListAndWatch(context.Background(), &amp;pluginapi.Empty&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(errListAndWatch, e.resourceName, err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        response, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            klog.Errorf(errListAndWatch, e.resourceName, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devs := response.Devices</span><br><span class="line">        klog.V(<span class="number">2</span>).Infof(<span class="string">"State pushed for device plugin %s"</span>, e.resourceName)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> newDevs []pluginapi.Device</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> devs &#123;</span><br><span class="line">            newDevs = <span class="built_in">append</span>(newDevs, *d)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e.callback(e.resourceName, newDevs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 <code>DevicePlugin</code> 的<code>ListAndWatch gRPC</code> 接口，通过长连接持续获取 <code>ListAndWatch gRPC stream</code></li><li>从 <code>stream</code> 流中获取的devices详情列表然后调用Endpoint的 <code>callback</code>，也就是 <code>ManagerImpl</code> 注册的callback方法<code>genericDeviceUpdateCallback</code>进行Device Manager的缓存更新并写到checkpoint文件中</li><li>run()是通过协程启动的，持续获取device server的ListAndWatch结果，持续更新device状态</li><li>当获取异常时，deviceManager断开连接，将device设置为不健康的状态。</li></ul><h3 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h3><p>看一下 <code>DevicePlugin</code> 实现的 <code>ListAndWatch</code>，先是立马返回device详情列表，然后开启协程，一旦感知device的健康状态发生变化了，更新 <code>device</code> 详情列表再次返回给 <code>deviceManager</code>。回想起健康检查，<code>DevicePlugin</code> 的 <code>CheckHealth</code> 就就会将设备的健康状态传递给 <code>m.health</code> 这个 <code>channel</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (m *NvidiaDevicePlugin) ListAndWatch(e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer) error &#123;</span><br><span class="line">    s.Send(&amp;pluginapi.ListAndWatchResponse&#123;<span class="attr">Devices</span>: m.apiDevices()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="xml"><span class="tag">&lt;<span class="name">-m.stop:</span></span></span></span><br><span class="line"><span class="xml">            return nil</span></span><br><span class="line">        case d := &lt;-m.health:</span><br><span class="line">            // FIXME: there is no way to recover from the Unhealthy state.</span><br><span class="line">            d.Health = pluginapi.Unhealthy</span><br><span class="line">            log.Printf("'%s' device marked unhealthy: %s", m.resourceName, d.ID)</span><br><span class="line">            s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: m.apiDevices()&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，<code>DevicePlugin</code> 是如何知道有多少 <code>Device</code> 的呢？我们看看 <code>apiDevices</code> 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">apiDevices</span><span class="params">()</span> []*<span class="title">pluginapi</span>.<span class="title">Device</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pdevs []*pluginapi.Device</span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> m.cachedDevices &#123;</span><br><span class="line">        pdevs = <span class="built_in">append</span>(pdevs, &amp;d.Device)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pdevs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>cachedDevices</code> 是通过 <code>ResourceManager</code> 获得的 <code>Device</code> 信息，其具体通过 <code>GpuDeviceManager</code> 结构来实现，可以看到它们是调用了 <code>nvml</code> 库而实现的。这里还有一个 <code>MigDeviceManager</code> 本质上相同，不再概述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GpuDeviceManager)</span> <span class="title">Devices</span><span class="params">()</span> []*<span class="title">Device</span></span> &#123;</span><br><span class="line">    n, err := nvml.GetDeviceCount()</span><br><span class="line">    check(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> devs []*Device</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">        d, err := nvml.NewDeviceLite(i)</span><br><span class="line">        check(err)</span><br><span class="line"></span><br><span class="line">        migEnabled, err := d.IsMigEnabled()</span><br><span class="line">        check(err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> migEnabled &amp;&amp; g.skipMigEnabledGPUs &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devs = <span class="built_in">append</span>(devs, buildDevice(d))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> devs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p><code>kubelet</code> 接收到被调度到本节点的pods后</p><h4 id="HandlePodAdditions"><a href="#HandlePodAdditions" class="headerlink" title="HandlePodAdditions"></a>HandlePodAdditions</h4><p>当 Node 上的 <code>Kubelet</code> 监听到有新的 <code>Pod</code> 创建时，会调用 <code>HandlerPodAdditions</code> 来处理 <code>Pod</code> 创建的事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">    syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">        <span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">        <span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">            klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (ADD, %q): %q"</span>, u.Source, format.Pods(u.Pods))</span><br><span class="line">            handler.HandlePodAdditions(u.Pods)</span><br><span class="line">        <span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">            klog.V(<span class="number">2</span>).Infof(<span class="string">"SyncLoop (UPDATE, %q): %q"</span>, u.Source, format.PodsWithDeletionTimestamps(u.Pods))</span><br><span class="line">            handler.HandlePodUpdates(u.Pods)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来进一步看下 <code>HandlerPodAdditions</code> 的实现，对于传入的每一个 <code>Pod</code> ，如果它没有被 <code>terminate</code>，则通过 <code>canAdmitPod</code> 检查是否可以允许该 <code>Pod</code> 创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">    start := kl.clock.Now()</span><br><span class="line">    sort.Sort(sliceutils.PodsByCreationTime(pods))</span><br><span class="line">    <span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">        existingPods := kl.podManager.GetPods()</span><br><span class="line">        kl.podManager.AddPod(pod)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> !kl.podIsTerminated(pod) &#123;</span><br><span class="line">            activePods := kl.filterOutTerminatedPods(existingPods)</span><br><span class="line">            <span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</span><br><span class="line">                kl.rejectPod(pod, reason, message)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>canAdmitPod</code> 里面，<code>Kubelet</code> 将会依次执行每一个 <code>admit handler</code> 来看 Pod 能否通过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "pod" is new pod, while "pods" are all admitted pods</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">canAdmitPod</span><span class="params">(pods []*v1.Pod, pod *v1.Pod)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    attrs := &amp;lifecycle.PodAdmitAttributes&#123;Pod: pod, OtherPods: pods&#125;</span><br><span class="line">    <span class="keyword">for</span> _, podAdmitHandler := <span class="keyword">range</span> kl.admitHandlers &#123;</span><br><span class="line">        <span class="keyword">if</span> result := podAdmitHandler.Admit(attrs); !result.Admit &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>, result.Reason, result.Message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="string">""</span>, <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>admitHandlers</code> 是一个 <code>PodAdmitHandler</code> 的切片，其接口如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PodAdmitHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Admit evaluates if a pod can be admitted.</span></span><br><span class="line">    Admit(attrs *PodAdmitAttributes) PodAdmitResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kubelet</code> 在创建的时候会添加一系列的 <code>PodAdmitHandler</code> 用于检查，对pod的资源做一些准入判断，比如：</p><ul><li><code>evictionAdmitHandler</code> :当节点有内存压力时，拒绝创建best effort的pod，还有其它条件先略过</li><li><code>TopologyPodAdmitHandler</code>：拒绝创建因为Topology locality冲突而无法分配资源的pod</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  klet.admitHandlers.AddPodAdmitHandler(evictionAdmitHandler)</span><br><span class="line">  klet.admitHandlers.AddPodAdmitHandler(klet.containerManager.GetAllocateResourcesPodAdmitHandler())</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>与我们 <code>DevicePlugin</code> 相关的则是 <code>containerManager</code> 的 <code>resourceAllocator</code>，这里会分别调用 <code>DeviceManager</code> 和 <code>CpuManager</code> 的 <code>Allocate</code> 函数，看是否能够申请到相关的资源。这里会对 Pod 的每一个 <code>InitContainer</code> 和 <code>Container</code>检查，看能否申请到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *resourceAllocator)</span> <span class="title">Admit</span><span class="params">(attrs *lifecycle.PodAdmitAttributes)</span> <span class="title">lifecycle</span>.<span class="title">PodAdmitResult</span></span> &#123;</span><br><span class="line">    pod := attrs.Pod</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, container := <span class="keyword">range</span> <span class="built_in">append</span>(pod.Spec.InitContainers, pod.Spec.Containers...) &#123;</span><br><span class="line">        err := m.deviceManager.Allocate(pod, &amp;container)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lifecycle.PodAdmitResult&#123;</span><br><span class="line">                Message: fmt.Sprintf(<span class="string">"Allocate failed due to %v, which is unexpected"</span>, err),</span><br><span class="line">                Reason:  <span class="string">"UnexpectedAdmissionError"</span>,</span><br><span class="line">                Admit:   <span class="literal">false</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m.cpuManager != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = m.cpuManager.Allocate(pod, &amp;container)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> lifecycle.PodAdmitResult&#123;</span><br><span class="line">                    Message: fmt.Sprintf(<span class="string">"Allocate failed due to %v, which is unexpected"</span>, err),</span><br><span class="line">                    Reason:  <span class="string">"UnexpectedAdmissionError"</span>,</span><br><span class="line">                    Admit:   <span class="literal">false</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lifecycle.PodAdmitResult&#123;Admit: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看 <code>ManagerImpl</code> 的 <code>Allocate</code> 函数实现。</p><h4 id="ManagerImpl-Allocate"><a href="#ManagerImpl-Allocate" class="headerlink" title="ManagerImpl.Allocate"></a>ManagerImpl.Allocate</h4><ul><li>allocateContainerResources为Pod中的init container分配devices，并更新deviceManager中PodDevices缓存；</li><li><code>allocateContainerResources为</code> Pod中的regular container分配devices，并更新deviceManager中PodDevices缓存<ul><li>每次在为Pod分配devices之前，都去检查一下此时的active pods，并与podDevices缓存中的pods进行比对，将已经terminated的Pods的devices从podDevices中删除，即进行了devices的GC操作。</li><li>从 <code>healthyDevices</code> 中随机分配对应数量的devices给该Pod，并注意更新allocatedDevices，否则会导致一个device被分配给多个Pod。</li><li>拿到devices后，就通过Grpc调用 <code>DevicePlugin</code> 的 <code>Allocate</code>方法，<code>DevicePlugin</code> 返回 <code>ContainerAllocateResponse</code> (包括注入的环境变量、挂载信息、Annotations)，<code>deviceManager</code> </li><li>根据 <code>pod uuid</code> 和 <code>container name</code> 将返回的信息存入 <code>podDevices</code> 缓存，更新 <code>podDevices</code> 缓存信息，并将<code>deviceManager</code> 中缓存数据更新到 <code>checkpoint</code> 文件中。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">Allocate</span><span class="params">(pod *v1.Pod, container *v1.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := m.devicesToReuse[<span class="keyword">string</span>(pod.UID)]; !ok &#123;</span><br><span class="line">        m.devicesToReuse[<span class="keyword">string</span>(pod.UID)] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sets.String)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If pod entries to m.devicesToReuse other than the current pod exist, delete them.</span></span><br><span class="line">    <span class="keyword">for</span> podUID := <span class="keyword">range</span> m.devicesToReuse &#123;</span><br><span class="line">        <span class="keyword">if</span> podUID != <span class="keyword">string</span>(pod.UID) &#123;</span><br><span class="line">            <span class="built_in">delete</span>(m.devicesToReuse, podUID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allocate resources for init containers first as we know the caller always loops</span></span><br><span class="line">    <span class="comment">// through init containers before looping through app containers. Should the caller</span></span><br><span class="line">    <span class="comment">// ever change those semantics, this logic will need to be amended.</span></span><br><span class="line">    <span class="keyword">for</span> _, initContainer := <span class="keyword">range</span> pod.Spec.InitContainers &#123;</span><br><span class="line">        <span class="keyword">if</span> container.Name == initContainer.Name &#123;</span><br><span class="line">            <span class="keyword">if</span> err := m.allocateContainerResources(pod, container, m.devicesToReuse[<span class="keyword">string</span>(pod.UID)]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            m.podDevices.addContainerAllocatedResources(<span class="keyword">string</span>(pod.UID), container.Name, m.devicesToReuse[<span class="keyword">string</span>(pod.UID)])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := m.allocateContainerResources(pod, container, m.devicesToReuse[<span class="keyword">string</span>(pod.UID)]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    m.podDevices.removeContainerAllocatedResources(<span class="keyword">string</span>(pod.UID), container.Name, m.devicesToReuse[<span class="keyword">string</span>(pod.UID)])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看 <code>allocateContainerResource</code> 的实现，因为扩展资源是<code>DevicePlugin</code> 所发现的，而扩展资源不允许过量提交，因此要求容器中的 <code>Request</code> 与 <code>Limits</code> 相等，并且 <code>DevicePlugin</code> 会遍历所有的 <code>Limits</code> 保证资源是充足的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">allocateContainerResources</span><span class="params">(pod *v1.Pod, container *v1.Container, devicesToReuse <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    podUID := <span class="keyword">string</span>(pod.UID)</span><br><span class="line">    contName := container.Name</span><br><span class="line">    allocatedDevicesUpdated := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// Extended resources are not allowed to be overcommitted.</span></span><br><span class="line">    <span class="comment">// Since device plugin advertises extended resources,</span></span><br><span class="line">    <span class="comment">// therefore Requests must be equal to Limits and iterating</span></span><br><span class="line">    <span class="comment">// over the Limits should be sufficient.</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> container.Resources.Limits &#123;</span><br><span class="line">        resource := <span class="keyword">string</span>(k)</span><br><span class="line">        needed := <span class="keyword">int</span>(v.Value())</span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">"needs %d %s"</span>, needed, resource)</span><br><span class="line">        <span class="keyword">if</span> !m.isDevicePluginResource(resource) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Updates allocatedDevices to garbage collect any stranded resources</span></span><br><span class="line">        <span class="comment">// before doing the device plugin allocation.</span></span><br><span class="line">        <span class="keyword">if</span> !allocatedDevicesUpdated &#123;</span><br><span class="line">            m.UpdateAllocatedDevices()</span><br><span class="line">            allocatedDevicesUpdated = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        allocDevices, err := m.devicesToAllocate(podUID, contName, resource, needed, devicesToReuse[resource])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> allocDevices == <span class="literal">nil</span> || <span class="built_in">len</span>(allocDevices) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startRPCTime := time.Now()</span><br><span class="line">        <span class="comment">// Manager.Allocate involves RPC calls to device plugin, which</span></span><br><span class="line">        <span class="comment">// could be heavy-weight. Therefore we want to perform this operation outside</span></span><br><span class="line">        <span class="comment">// mutex lock. Note if Allocate call fails, we may leave container resources</span></span><br><span class="line">        <span class="comment">// partially allocated for the failed container. We rely on UpdateAllocatedDevices()</span></span><br><span class="line">        <span class="comment">// to garbage collect these resources later. Another side effect is that if</span></span><br><span class="line">        <span class="comment">// we have X resource A and Y resource B in total, and two containers, container1</span></span><br><span class="line">        <span class="comment">// and container2 both require X resource A and Y resource B. Both allocation</span></span><br><span class="line">        <span class="comment">// requests may fail if we serve them in mixed order.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> may revisit this part later if we see inefficient resource allocation</span></span><br><span class="line">        <span class="comment">// in real use as the result of this. Should also consider to parallelize device</span></span><br><span class="line">        <span class="comment">// plugin Allocate grpc calls if it becomes common that a container may require</span></span><br><span class="line">        <span class="comment">// resources from multiple device plugins.</span></span><br><span class="line">        m.mutex.Lock()</span><br><span class="line">        eI, ok := m.endpoints[resource]</span><br><span class="line">        m.mutex.Unlock()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            m.mutex.Lock()</span><br><span class="line">            m.allocatedDevices = m.podDevices.devices()</span><br><span class="line">            m.mutex.Unlock()</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"unknown Device Plugin %s"</span>, resource)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devs := allocDevices.UnsortedList()</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> refactor this part of code to just append a ContainerAllocationRequest</span></span><br><span class="line">        <span class="comment">// in a passed in AllocateRequest pointer, and issues a single Allocate call per pod.</span></span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">"Making allocation request for devices %v for device plugin %s"</span>, devs, resource)</span><br><span class="line">        resp, err := eI.e.allocate(devs)</span><br><span class="line">        metrics.DevicePluginAllocationDuration.WithLabelValues(resource).Observe(metrics.SinceInSeconds(startRPCTime))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// In case of allocation failure, we want to restore m.allocatedDevices</span></span><br><span class="line">            <span class="comment">// to the actual allocated state from m.podDevices.</span></span><br><span class="line">            m.mutex.Lock()</span><br><span class="line">            m.allocatedDevices = m.podDevices.devices()</span><br><span class="line">            m.mutex.Unlock()</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(resp.ContainerResponses) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"no containers return in allocation response %v"</span>, resp)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update internal cached podDevices state.</span></span><br><span class="line">        m.mutex.Lock()</span><br><span class="line">        m.podDevices.insert(podUID, contName, resource, allocDevices, resp.ContainerResponses[<span class="number">0</span>])</span><br><span class="line">        m.mutex.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checkpoints device to container allocation information.</span></span><br><span class="line">    <span class="keyword">return</span> m.writeCheckpoint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这里通过 <code>resp, err := eI.e.allocate(devs)</code> 执行 RPC 调用，进入到了 <code>DevicePlugin</code> 的逻辑。这里有一个问题，<code>RPC</code> 远程调用中的 <code>deviceIDs</code> 参数是怎么来的呢？我们看到这里有一个 <code>devicesToAllocate</code>的调用。这里的主要逻辑如下：</p><ul><li>拿到对应Pod的对应容器已经申请的资源的设备列表，检查是否只申请了部分，如果只有一部分，那么报错</li><li>然后从 <code>resuableDevices</code> 结构中拿到可以使用的设备列表，如果可用的足够则返回，否则继续从 <code>healthyDevices</code> 中找</li><li>从 <code>healthyDevices</code> 去掉已经在使用的设备，然后检查是否足够，如果不够则报错</li><li>如果足够的话，根据是否有满足拓扑亲和性去拿到足够的设备列表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">devicesToAllocate</span><span class="params">(podUID, contName, resource <span class="keyword">string</span>, required <span class="keyword">int</span>, reusableDevices sets.String)</span> <span class="params">(sets.String, error)</span></span> &#123;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    needed := required</span><br><span class="line">    <span class="comment">// Gets list of devices that have already been allocated.</span></span><br><span class="line">    <span class="comment">// This can happen if a container restarts for example.</span></span><br><span class="line">    devices := m.podDevices.containerDevices(podUID, contName, resource)</span><br><span class="line">    <span class="keyword">if</span> devices != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.V(<span class="number">3</span>).Infof(<span class="string">"Found pre-allocated devices for resource %s container %q in Pod %q: %v"</span>, resource, contName, podUID, devices.List())</span><br><span class="line">        needed = needed - devices.Len()</span><br><span class="line">        <span class="comment">// A pod's resource is not expected to change once admitted by the API server,</span></span><br><span class="line">        <span class="comment">// so just fail loudly here. We can revisit this part if this no longer holds.</span></span><br><span class="line">        <span class="keyword">if</span> needed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"pod %q container %q changed request for resource %q from %d to %d"</span>, podUID, contName, resource, devices.Len(), required)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> needed == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// No change, no work.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    klog.V(<span class="number">3</span>).Infof(<span class="string">"Needs to allocate %d %q for pod %q container %q"</span>, needed, resource, podUID, contName)</span><br><span class="line">    <span class="comment">// Needs to allocate additional devices.</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := m.healthyDevices[resource]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"can't allocate unregistered device %s"</span>, resource)</span><br><span class="line">    &#125;</span><br><span class="line">    devices = sets.NewString()</span><br><span class="line">    <span class="comment">// Allocates from reusableDevices list first.</span></span><br><span class="line">    <span class="keyword">for</span> device := <span class="keyword">range</span> reusableDevices &#123;</span><br><span class="line">        devices.Insert(device)</span><br><span class="line">        needed--</span><br><span class="line">        <span class="keyword">if</span> needed == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> devices, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Needs to allocate additional devices.</span></span><br><span class="line">    <span class="keyword">if</span> m.allocatedDevices[resource] == <span class="literal">nil</span> &#123;</span><br><span class="line">        m.allocatedDevices[resource] = sets.NewString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Gets Devices in use.</span></span><br><span class="line">    devicesInUse := m.allocatedDevices[resource]</span><br><span class="line">    <span class="comment">// Gets a list of available devices.</span></span><br><span class="line">    available := m.healthyDevices[resource].Difference(devicesInUse)</span><br><span class="line">    <span class="keyword">if</span> available.Len() &lt; needed &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"requested number of devices unavailable for %s. Requested: %d, Available: %d"</span>, resource, needed, available.Len())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// By default, pull devices from the unsorted list of available devices.</span></span><br><span class="line">    allocated := available.UnsortedList()[:needed]</span><br><span class="line">    <span class="comment">// If topology alignment is desired, update allocated to the set of devices</span></span><br><span class="line">    <span class="comment">// with the best alignment.</span></span><br><span class="line">    hint := m.topologyAffinityStore.GetAffinity(podUID, contName)</span><br><span class="line">    <span class="keyword">if</span> m.deviceHasTopologyAlignment(resource) &amp;&amp; hint.NUMANodeAffinity != <span class="literal">nil</span> &#123;</span><br><span class="line">        allocated = m.takeByTopology(resource, available, hint.NUMANodeAffinity, needed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Updates m.allocatedDevices with allocated devices to prevent them</span></span><br><span class="line">    <span class="comment">// from being allocated to other pods/containers, given that we are</span></span><br><span class="line">    <span class="comment">// not holding lock during the rpc call.</span></span><br><span class="line">    <span class="keyword">for</span> _, device := <span class="keyword">range</span> allocated &#123;</span><br><span class="line">        m.allocatedDevices[resource].Insert(device)</span><br><span class="line">        devices.Insert(device)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> devices, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RPC</code> 调用成功后，会将对应的 <code>Response</code> 记录到 <code>m.podDevices</code> 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pdev podDevices)</span> <span class="title">insert</span><span class="params">(podUID, contName, resource <span class="keyword">string</span>, devices sets.String, resp *pluginapi.ContainerAllocateResponse)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, podExists := pdev[podUID]; !podExists &#123;</span><br><span class="line">        pdev[podUID] = <span class="built_in">make</span>(containerDevices)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, contExists := pdev[podUID][contName]; !contExists &#123;</span><br><span class="line">        pdev[podUID][contName] = <span class="built_in">make</span>(resourceAllocateInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    pdev[podUID][contName][resource] = deviceAllocateInfo&#123;</span><br><span class="line">        deviceIds: devices,</span><br><span class="line">        allocResp: resp,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DevicePlugin-Allocate"><a href="#DevicePlugin-Allocate" class="headerlink" title="DevicePlugin.Allocate"></a>DevicePlugin.Allocate</h4><p><code>Allocate</code> 接口给容器加上 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，设置了相关的 <code>DeviceSpec</code>参数，将 <code>Response</code> 返回给 <code>Kubelet</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *NvidiaDevicePlugin)</span> <span class="title">Allocate</span><span class="params">(ctx context.Context, reqs *pluginapi.AllocateRequest)</span> <span class="params">(*pluginapi.AllocateResponse, error)</span></span> &#123;</span><br><span class="line">    responses := pluginapi.AllocateResponse&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line">        <span class="keyword">for</span> _, id := <span class="keyword">range</span> req.DevicesIDs &#123;</span><br><span class="line">            <span class="keyword">if</span> !m.deviceExists(id) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid allocation request for '%s': unknown device: %s"</span>, m.resourceName, id)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response := pluginapi.ContainerAllocateResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> *deviceListStrategyFlag == DeviceListStrategyEnvvar &#123;</span><br><span class="line">            response.Envs = m.apiEnvs(m.deviceListEnvvar, req.DevicesIDs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> *deviceListStrategyFlag == DeviceListStrategyVolumeMounts &#123;</span><br><span class="line">            response.Envs = m.apiEnvs(m.deviceListEnvvar, []<span class="keyword">string</span>&#123;deviceListAsVolumeMountsContainerPathRoot&#125;)</span><br><span class="line">            response.Mounts = m.apiMounts(req.DevicesIDs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> *passDeviceSpecs &#123;</span><br><span class="line">            response.Devices = m.apiDeviceSpecs(req.DevicesIDs)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responses.ContainerResponses = <span class="built_in">append</span>(responses.ContainerResponses, &amp;response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;responses, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到， Nvidia的 <code>gpu-container-runtime</code> 根据容器的 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量，会决定这个容器是否为GPU容器，并且可以使用哪些GPU设备。 而Nvidia GPU device plugin做的事情，就是根据kubelet 请求中的GPU DeviceId， 转换为 <code>NVIDIA_VISIBLE_DEVICES</code> 环境变量返回给kubelet， kubelet收到返回内容后，会自动将返回的环境变量注入到容器中。当容器中包含环境变量，启动时 <code>gpu-container-runtime</code> 会根据 <code>NVIDIA_VISIBLE_DEVICES</code> 里声明的设备信息，将设备映射到容器中，并将对应的Nvidia Driver Lib 也映射到容器中。</p><h3 id="Device-的使用"><a href="#Device-的使用" class="headerlink" title="Device 的使用"></a>Device 的使用</h3><p>在kubelet的 <code>GetResource</code> 中，会调用 <code>DeviceManager</code> 的 <code>GetDeviceRunContainerOptions</code>，并将这些 <code>options</code>添加到<code>kubecontainer.RunContainerOptions</code> 中。<code>RunContainerOptions</code> 包括 <code>Envs</code>、<code>Mounts</code>、<code>Devices</code>、<code>PortMappings</code>、<code>Annotations</code>等信息。kubelet调用 <code>GetResources()</code> 为启动<code>container</code>获取启动参数 <code>runtimeapi.ContainerConfig{Args...}</code></p><figure class="highlight go"><figcaption><span>kubernetes/pkg/kubelet/cm/container_manager_linux.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cm *containerManagerImpl)</span> <span class="title">GetResources</span><span class="params">(pod *v1.Pod, container *v1.Container)</span> <span class="params">(*kubecontainer.RunContainerOptions, error)</span></span> &#123;</span><br><span class="line">    opts := &amp;kubecontainer.RunContainerOptions&#123;&#125;</span><br><span class="line">    <span class="comment">// Allocate should already be called during predicateAdmitHandler.Admit(),</span></span><br><span class="line">    <span class="comment">// just try to fetch device runtime information from cached state here</span></span><br><span class="line">    devOpts, err := cm.deviceManager.GetDeviceRunContainerOptions(pod, container)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> devOpts == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> opts, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    opts.Devices = <span class="built_in">append</span>(opts.Devices, devOpts.Devices...)</span><br><span class="line">    opts.Mounts = <span class="built_in">append</span>(opts.Mounts, devOpts.Mounts...)</span><br><span class="line">    opts.Envs = <span class="built_in">append</span>(opts.Envs, devOpts.Envs...)</span><br><span class="line">    opts.Annotations = <span class="built_in">append</span>(opts.Annotations, devOpts.Annotations...)</span><br><span class="line">    <span class="keyword">return</span> opts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetDeviceRunContainerOptions()</code> 根据 <code>pod uuid</code> 和 <code>container name</code> 从 <code>podDevices</code> 缓存（device的分配过程中会设置缓存数据）中取出Envs、Mounts、Devices、PortMappings、Annotations等信息，另外对于一些PreStartRequired为true的 <code>DevicePlugin</code>，deviceManager需要在启动container之前调用 <code>DevicePlugin</code>的 <code>PreStartContainer</code>grpc接口，做一些device的初始化工作，超时时间限制为30秒。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ManagerImpl)</span> <span class="title">GetDeviceRunContainerOptions</span><span class="params">(pod *v1.Pod, container *v1.Container)</span> <span class="params">(*DeviceRunContainerOptions, error)</span></span> &#123;</span><br><span class="line">    podUID := <span class="keyword">string</span>(pod.UID)</span><br><span class="line">    contName := container.Name</span><br><span class="line">    needsReAllocate := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> container.Resources.Limits &#123;</span><br><span class="line">        resource := <span class="keyword">string</span>(k)</span><br><span class="line">        <span class="keyword">if</span> !m.isDevicePluginResource(resource) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        err := m.callPreStartContainerIfNeeded(podUID, contName, resource)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is a device plugin resource yet we don't have cached</span></span><br><span class="line">        <span class="comment">// resource state. This is likely due to a race during node</span></span><br><span class="line">        <span class="comment">// restart. We re-issue allocate request to cover this race.</span></span><br><span class="line">        <span class="keyword">if</span> m.podDevices.containerDevices(podUID, contName, resource) == <span class="literal">nil</span> &#123;</span><br><span class="line">            needsReAllocate = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> needsReAllocate &#123;</span><br><span class="line">        klog.V(<span class="number">2</span>).Infof(<span class="string">"needs re-allocate device plugin resources for pod %s, container %s"</span>, podUID, container.Name)</span><br><span class="line">        <span class="keyword">if</span> err := m.Allocate(pod, container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> m.podDevices.deviceRunContainerOptions(<span class="keyword">string</span>(pod.UID), container.Name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Device-的状态管理"><a href="#Device-的状态管理" class="headerlink" title="Device 的状态管理"></a>Device 的状态管理</h3><p>device的状态管理涉及到以下3个部分：</p><ul><li>node上的device状态管理当kubelet更新node status时会调用GetCapacity更新device plugins对应的Resource信息。</li></ul><p>kubelet_node_status.go调用deviceManager的GetCapacity()获取device的状态，将device状态添加到node info并通过kube-apiserver存入etcd，GetCapacity()返回device server含有的所有device、已经分配给pod使用的device、pod不能使用的device即no-active的device kubelet_node_status.go根据返回的数据更新node info</p><ul><li>kubelet deviceManager服务的device状态管理其实在device的注册、device分配中都有讲解，即使用checkpoint机制默认是将podDevices以 PodDevicesEntry的格式存入<em>/var/lib/kubelet/device-plugins/kubelet_internal_checkpoint 文件</em></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type PodDevicesEntry struct &#123;</span><br><span class="line">   PodUID        string</span><br><span class="line">   ContainerName string</span><br><span class="line">   ResourceName  string</span><br><span class="line">   DeviceIDs     []string</span><br><span class="line">   AllocResp     []byte     <span class="comment">//包含启动container时使用的Envs、Mounts、Devices、PortMappings、Annotations等信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要device的状态发生了变化（如注册新device、device被分配、device的健康状态发生变化、device被删除），就要将podDevices存入<em>kubelet_internal_checkpoint 文件。kubelet在启动或重启时，都需要读取kubelet_internal_checkpoint 文件里的数据，并以podDevices格式存入podDevices缓存。</em></p><ul><li><code>DevicePlugin</code> 上报device状态在device的注册部分已经讲解过，归纳为<ul><li><code>deviceManager</code> 注册完 <code>DevicePlugin</code> 后，会跟 <code>DevicePlugin</code> 建立长连接，持续获取 <code>DevicePlugin</code> 的ListAndWatch结果，持续更新device状态；</li><li>当获取异常时，<code>deviceManager</code>断开连接，将device设置为不健康的状态；</li><li><code>DevicePlugin</code> 默认会重启重新注册，重新上报device的状态</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes device plugin design proposal</a></li><li><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/plugin-watcher.md" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes plugin watcher design proposal</a></li><li><a href="https://github.com/NVIDIA/k8s-device-plugin" target="_blank" rel="external nofollow noopener noreferrer">Nvidia Device Plugin</a></li><li><a href="https://cloud.tencent.com/developer/article/1592800" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1592800</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 原生支持对于CPU和内存资源的发现，但是有很多其他的设备 kubelet不能原生处理，比如GPU、FPGA、RDMA、存储设备和其他类似的异构计算资源设备。为了能够使用这些设备资源，我们需要进行各个设备的初始化和设置。按照 Kubernetes 的 &lt;code&gt;OutOfTree&lt;/code&gt; 的哲学理念，我们不应该把各个厂商的设备初始化设置相关代码与 Kubernetes 核心代码放在一起。与之相反，我们需要一种机制能够让各个设备厂商向 Kubelet 上报设备资源，而不需要修改 Kubernetes 核心代码。这即是 &lt;code&gt;Device Plugin&lt;/code&gt; 这一机制的来源，本文将介绍 Device Plugin 的实现原理，并介绍其使用。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_k8s-device-plugin.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="k8s" scheme="http://houmin.cc/tags/k8s/"/>
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="device plugin" scheme="http://houmin.cc/tags/device-plugin/"/>
    
      <category term="RDMA" scheme="http://houmin.cc/tags/RDMA/"/>
    
      <category term="FPGA" scheme="http://houmin.cc/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>GPU 与 CUDA 编程入门</title>
    <link href="http://houmin.cc/posts/5004f8e5/"/>
    <id>http://houmin.cc/posts/5004f8e5/</id>
    <published>2020-11-15T05:16:10.000Z</published>
    <updated>2020-11-21T16:41:14.107Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>随着近年来深度学习的爆发，原来被用于图形渲染的GPU被大量用于并行加速深度学习的模型训练中，在这个过程中 CUDA 作为 NVIDIA 推出的基于GPU的一个通用并行计算平台和编程模型也得到了广泛的使用。或许你已经十分了解 <a href="../b893097a/">现代CPU的体系架构</a>，但是对于GPU还不甚清晰，GPU的体系架构到底和CPU有何区别，CUDA模型是什么，我们该如何使用 CUDA实现并行计算，本文将为你扫盲祛魅，本文中使用到的所有代码可以在我的 <a href="https://github.com/SimpCosm/cuda-tutorial" target="_blank" rel="external nofollow noopener noreferrer">Github</a> 中找到。</p><a id="more"></a><h2 id="GPU-体系架构"><a href="#GPU-体系架构" class="headerlink" title="GPU 体系架构"></a>GPU 体系架构</h2><h3 id="为什么我们需要-GPU"><a href="#为什么我们需要-GPU" class="headerlink" title="为什么我们需要 GPU"></a>为什么我们需要 GPU</h3><p>如前所述，GPU （Graphics Processing Unit）最开始只是用于游戏、视频中的图形渲染，而现在最热门的一个应用领域是在深度学习的加速计算上。为什么需要 GPU 来加速计算呢？我们知道，随着摩尔定律的发展，在过去五十年间CPU的性能获得了巨大的提升，不论是从芯片上晶体管数目，还是时钟频率，到后来的从单核处理器发展到后来的多核多处理器。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-18_moores-law-develop.jpg"></p><p>下图是过去五十年间各款CPU处理器上晶体管数目的变化，基本上满足每18个月提升一倍的规律，虽然现在看起来50十年后摩尔定律对CPU来说有停滞的迹象（这是另一个话题，此处不表）</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-18_moores-law.png"></p><p>在 CPU 算力快速提升的这五十年，人们需要的计算量也同时在迅猛发展着，从最开始的桌面互联网，到后来的移动互联网，以及5年前爆发的深度学习，无一不需要庞大的计算力。在这个过程中，仅仅依靠CPU的算力开始力有不逮，这个过程中像GPU、FPGA、DSP等异构计算单元开始得到广泛的应用。下面，我回归计算的本质，以GPU为例来分析为什么我们需要这些异构计算单元。</p><p>无论是 CPU 还是 GPU，我们可以把计算模型抽象为下面这张图，这也是典型的冯诺伊曼体系架构。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_computing.png"></p><p>影响计算能力的4个主要因素如下：</p><ul><li><strong>Parallel Processing</strong>：Amount of data processed at one time</li><li><strong>Clock Frequency</strong>：Processing speed on each data element</li><li><strong>Memory Bandwidth</strong>：Amount of data transferred at one time</li><li><strong>Memory Lantency</strong>：Time for each data element to be transferred</li></ul><p>对于CPU，依次分析这几个因素：</p><ul><li>为了提供并行处理能力，我们从单核单处理器发展到多核多处理器，每个时钟周期CPU也能够处理多条指令</li><li>因为CPU时钟频率和功率的关系  $ Power = k <em> ClockFrequency </em> Voltage^2 $ ，在CPU过去的发展历史中，通过提高CPU时钟频率可以变得更快，与此同时为了保持CPU功耗的正常，也需要不断降低电压。但是当主频逐渐逼近到 4GHz 时，电压已经不能再降低了，因为这已经到达了晶体管高低电平反转的极限，关于这部分的更多内容可以参考 <a href="../">摩尔定律</a> 。</li><li>现在CPU用的是常规的DDR内存，明显存在着内存带宽限制</li><li>从CPU到DDR内存的延时很高，2020年的时候大概有100ns，具体可以参考 <a href="../fb3d782a/">Key Numbers Every Programmer Should Know</a>。CPU通过其他的方式隐藏了这个问题：<ul><li>Large On-Chip Low-Latency Cache，大概1ns</li><li>MultiThreading</li><li>Out-of-order execution</li></ul></li></ul><p><img alt="Credit to https://queue.acm.org/detail.cfm?id=2181798" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_processor-frequency-scaling.png"></p><p>尽管现在CPU的能力还在发展，但是以上的问题极大的限制了其算力的提高，当前仅靠CPU已经不能够满足人们对庞大算力的需求了。因此我们需要其他的专用芯片来帮助CPU一起计算，这就是异构计算的来源。GPU等专用计算单元虽然工作频率较低，但具有更多的内核数和并行计算能力，总体性能/芯片面积比和性能/功耗比都很高。随着人工智能时代的降临，GPU从游戏走进了人们的视野。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cpu-vs-gpu.png"></p><p>无论是CPU还是GPU，在进行计算时都需要用核心（Core）来做算术逻辑运算。核心中有ALU（逻辑运算单元）和寄存器等电路。在进行计算时，一个核心只能顺序执行某项任务。CPU作为通用计算芯片，不仅仅做算术逻辑计算，其很重要的一部分功能是做复杂的逻辑控制，一般而言CPU上的Core数目相对较少，数据中心的服务器一般也就40左右个CPU核心。但是GPU动辄有上千个核心，这些核心可以独立的进行算术逻辑计算，大大提高了并行计算处理能力。</p><p>GPU时代的最大获益者是NVIDIA，当然AMD他们家也有GPU产品，但是因为AMD并没有形成CUDA这样的软件生态导致深度学习中主要用的都是NVIDIA的GPU，后面的分析都将基于NVIDIA的GPU产品。NVIDIA 不同时代产品的芯片设计不同，每代产品背后有一个架构代号，架构均以著名的物理学家为名，以向先贤致敬，对于消费者而言，英伟达主要有两条产品线：</p><ul><li>消费级产品 GeForce系列：GeForce 2080 Ti…</li><li>高性能计算产品 Telsa系列：Telsa V100、Telsa P100、Telsa P40…</li></ul><p><img alt="NVIDIA GPU产品体系" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-gpu.png"></p><h3 id="GPU-硬件模型"><a href="#GPU-硬件模型" class="headerlink" title="GPU 硬件模型"></a>GPU 硬件模型</h3><h4 id="Host-and-Device"><a href="#Host-and-Device" class="headerlink" title="Host and Device"></a>Host and Device</h4><p>GPU并不是一个独立运行的计算平台，而是需要与CPU的协同工作，可以看作是CPU的协处理器，因此当我们说GPU并行计算的时候，实质上是指的 <code>CPU+GPU</code> 的异构计算架构。由于CPU和GPU是分开的，在NVIDIA的设计理念里，CPU和主存被称为 <strong>Host</strong>，GPU和显存被称为 <strong>Device</strong>。Host 和 Device 概念会贯穿整个NVIDIA GPU编程。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cpu-and-gpu.png"></p><p>基于 CPU + GPU 的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。CUDA 程序中既包含 <strong>Host</strong> 程序，又包含 <strong>Device</strong> 程序，它们分别在CPU和GPU上运行。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cuda-application.jpg"></p><p>同时， <strong>Host</strong> 与 <strong>Device</strong> 之间通过PCIe总线交互进行数据拷贝，典型的 CUDA 程序的执行流程如下：</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_cuda-flow.jpg"></p><ol><li>初始化后，将数据从 Main Memory 拷贝到 GPU Memory</li><li>CPU 调用 CUDA 的核函数</li><li>GPU 的 CUDA Core 并行执行核函数</li><li>将 <strong>Device</strong> 上的运算结果拷贝到 <strong>Host</strong> 上</li></ol><p>GPU核心在做计算时，只能直接从显存中读写数据，程序员需要在代码中指明哪些数据需要从内存和显存之间相互拷贝。这些数据传输都是在总线上，因此总线的传输速度和带宽成了部分计算任务的瓶颈。当前最新的总线技术是NVLink，IBM的 Power CPU 和 NVIDIA 的高端显卡可以通过NVLink直接通信，Intel 的 CPU目前不支持NVLink，只能使用PCIe技术。同时，单台机器上的多张英伟达显卡也可以使用NVLink相互通信，适合多GPU卡并行计算的场景。</p><p><img alt="NVLink可以连接CPU和GPU" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvlink.png"></p><h4 id="Streaming-Multiprocessor"><a href="#Streaming-Multiprocessor" class="headerlink" title="Streaming Multiprocessor"></a>Streaming Multiprocessor</h4><p>在 NVIDIA 的设计里，一张GPU卡有多个Streaming Multiprocessor（<strong>SM</strong>），每个 SM 中有多个计算核心，SM 是运算和调度的基本单元。下图为当前计算力最强的显卡Tesla V100，密密麻麻的绿色小格子就是GPU小核心，多个小核心一起组成了一个SM。</p><p><img alt="Tesla V100 with 84 SM Units" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-tesla-v100.png"></p><p>将 SM 放大，单个SM的结构如图所示：</p><p><img alt="Tesla V100 Streaming Multiprocessor(SM)" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-tesla-v100-sm.png"></p><p>可以看到一个SM中包含了计算核心和存储部分，SM的核心组件包括CUDA核心，共享内存，寄存器等，SM可以并发地执行数百个线程，并发能力就取决于SM所拥有的资源数。</p><ul><li>针对不同计算的小核心（绿色小格子），包括优化深度学习的TENSOR CORE，32个64位浮点核心（FP64），64个整型核心(INT)，64个32位浮点核心(FP32)</li><li>计算核心直接从寄存器（Register）中读写数据</li><li>调度和分发器（Scheduler和Dispatch Unit）</li><li>L0和L1级缓存</li></ul><p>具体而言，SM中的FP32进行32位浮点加乘运算，INT进行整型加乘运算，SFU（Special Functional Unit）执行一些倒数和三角函数等运算。Tensor Core是 NVIDIA 新的微架构中提出的一种混合精度的计算核心。我们知道，当前深度神经网络中使用到最频繁的矩阵运算是： $ D = A \times B + C $。Tensor Core可以对 $ 4 \times 4  $ 的矩阵做上述运算。其中：</p><ul><li>涉及乘法的 A 和 B 使用FP16的16位浮点运算，精度较低</li><li>涉及加法的 C 和 D 使用FP16或FP32精度</li></ul><p>Tensor Core是在 Volta 架构开始提出的，使用Volta架构的V100在深度学习上的性能远超Pascal架构的P100。</p><p><img alt="Tensor Core是一种为优化深度学习计算核心" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_tensor-core.png"></p><h2 id="CUDA-编程模型"><a href="#CUDA-编程模型" class="headerlink" title="CUDA 编程模型"></a>CUDA 编程模型</h2><p>前面提到，NVIDIA 相对于 AMD 的一个巨大优势是它的 CUDA 软件生态，下图是 NVIDIA GPU 编程的软件栈，从底层的GPU驱动和CUDA 工具包，上面还提供了科学计算所必需的cuBLAS线性代数库，cuFFT快速傅里叶变换库以及cuDNN深度神经网络加速库，当前常见的 TensorFlow 和 PyTorch 深度学习框架底层大多都基于 cuDNN 库。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_gpu-software-stack.png"></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>在进一步学习 CUDA 编程模型之前，我们首先配置好 CUDA 的运行环境，跑通 <code>Hello World</code> 从而对 CUDA 编程有一个直观的认识，这里使用的是腾讯云的 GPU 服务器，机器安装的是 CentOS 7 系统，CUDA 环境配置可以参考 <a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html" target="_blank" rel="external nofollow noopener noreferrer">CUDA Installation Guide Linux</a> 。</p><p>根据上图的 NVIDIA GPU 软件栈，有了一个插上了 GPU 的服务器之后，我们首先查看机器上的 GPU，可以看到当前机器上装GPU是 <code>Tesla P40</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lspci | grep -i nvidia</span><br><span class="line">00:08.0 3D controller: NVIDIA Corporation GP102GL [Tesla P40] (rev a1)</span><br></pre></td></tr></table></figure><p>接下来在 <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载 CUDA Toolkit，这里选择的是 <code>rpm local</code> 的安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://developer.download.nvidia.com/compute/cuda/11.1.1/local_installers/cuda-repo-rhel7-11-1-local-11.1.1_455.32.00-1.x86_64.rpm</span><br><span class="line">$ sudo rpm -i cuda-repo-rhel7-11-1-local-11.1.1_455.32.00-1.x86_64.rpm</span><br><span class="line">$ sudo yum clean all</span><br><span class="line">$ sudo yum -y install nvidia-driver-latest-dkms cuda</span><br><span class="line">$ sudo yum -y install cuda-drivers</span><br></pre></td></tr></table></figure><p>执行上面的安装操作之后，我们可以看到在 <code>/usr/lib64/</code> 看到 <code>libcuda.so</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls /usr/lib64 -al | grep cuda</span><br><span class="line">lrwxrwxrwx   1 root root        20 Nov 21 15:05 libcuda.so -&gt; libcuda.so.455.32.00</span><br><span class="line">lrwxrwxrwx   1 root root        20 Nov 21 15:05 libcuda.so.1 -&gt; libcuda.so.455.32.00</span><br><span class="line">-rwxr-xr-x   1 root root  21074296 Oct 15 06:58 libcuda.so.455.32.00</span><br></pre></td></tr></table></figure><p>下面是一些我们会经常用到的 CUDA 工具，你需要通过配置环境变量来使用他们：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">编译器：nvcc</span> <span class="comment">(C/C</span>++<span class="comment">)</span></span><br><span class="line"><span class="comment">调试器：nvcc</span><span class="literal">-</span><span class="comment">gdb</span></span><br><span class="line"><span class="comment">性能分析：nsight</span><span class="string">,</span> <span class="comment">nvprof</span></span><br><span class="line"><span class="comment">函数库：cublas</span><span class="string">,</span> <span class="comment">nvblas</span><span class="string">,</span> <span class="comment">cusolver</span><span class="string">,</span> <span class="comment">cufftw</span><span class="string">,</span> <span class="comment">cusparse</span><span class="string">,</span> <span class="comment">nvgraph</span></span><br></pre></td></tr></table></figure><p>设置环境变量如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-11.1/bin<span class="variable">$&#123;PATH:+:$&#123;PATH&#125;</span>&#125;</span><br><span class="line">$ nvcc --version</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2020 NVIDIA Corporation</span><br><span class="line">Built on Mon_Oct_12_20:09:46_PDT_2020</span><br><span class="line">Cuda compilation tools, release 11.1, V11.1.105</span><br><span class="line">Build cuda_11.1.TC455_06.29190527_0</span><br></pre></td></tr></table></figure><p>除此之外，对于 64 位系统，需要设置 <code>LD_LIBRARY_PATH</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-11.1/lib64<span class="variable">$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span><br></pre></td></tr></table></figure><p>这个时候可以确认驱动的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/driver/nvidia/version</span><br><span class="line">NVRM version: NVIDIA UNIX x86_64 Kernel Module  455.32.00  Wed Oct 14 22:46:18 UTC 2020</span><br><span class="line">GCC version:  gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)</span><br></pre></td></tr></table></figure><p>可以使用<code>nvidia-smi</code>命令查看显卡情况，比如这台机器上几张显卡，CUDA版本，显卡上运行的进程等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br><span class="line">Sat Nov 21 17:09:13 2020</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 455.32.00    Driver Version: 455.32.00    CUDA Version: 11.1     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla P40           Off  | 00000000:00:08.0 Off |                    0 |</span><br><span class="line">| N/A   27C    P0    49W / 250W |      0MiB / 22919MiB |      3%      Default |</span><br><span class="line">|                               |                      |                  N/A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p><code>CUDA</code> 自己提供了一系列的代码示例，可以通过下面的方法安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cuda-install-samples-11.1.sh &lt;dir&gt;</span><br></pre></td></tr></table></figure><p>在对应目录下，我们可以看到 <code>CUDA</code> 提供的源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls NVIDIA_CUDA-11.1_Samples</span><br><span class="line">0_Simple     2_Graphics  4_Finance      6_Advanced       bin     EULA.txt  Makefile</span><br><span class="line">1_Utilities  3_Imaging   5_Simulations  7_CUDALibraries  common  LICENSE</span><br></pre></td></tr></table></figure><p>直接在这个目录下执行 <code>make</code>，可以在 <code>bin</code>目录下得到所有代码的二进制程序，选择其中的 <code>deviceQuery</code> 执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ ./deviceQuery</span><br><span class="line">./deviceQuery Starting...</span><br><span class="line"></span><br><span class="line"> CUDA Device Query (Runtime API) version (CUDART static linking)</span><br><span class="line"></span><br><span class="line">Detected 1 CUDA Capable device(s)</span><br><span class="line"></span><br><span class="line">Device 0: <span class="string">"Tesla P40"</span></span><br><span class="line">  CUDA Driver Version / Runtime Version          11.1 / 11.1</span><br><span class="line">  CUDA Capability Major/Minor version number:    6.1</span><br><span class="line">  Total amount of global memory:                 22919 MBytes (24032378880 bytes)</span><br><span class="line">  (30) Multiprocessors, (128) CUDA Cores/MP:     3840 CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            1531 MHz (1.53 GHz)</span><br><span class="line">  Memory Clock rate:                             3615 Mhz</span><br><span class="line">  Memory Bus Width:                              384-bit</span><br><span class="line">  L2 Cache Size:                                 3145728 bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)</span><br><span class="line">  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers</span><br><span class="line">  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers</span><br><span class="line">  Total amount of constant memory:               65536 bytes</span><br><span class="line">  Total amount of shared memory per block:       49152 bytes</span><br><span class="line">  Total shared memory per multiprocessor:        98304 bytes</span><br><span class="line">  Total number of registers available per block: 65536</span><br><span class="line">  Warp size:                                     32</span><br><span class="line">  Maximum number of threads per multiprocessor:  2048</span><br><span class="line">  Maximum number of threads per block:           1024</span><br><span class="line">  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)</span><br><span class="line">  Maximum memory pitch:                          2147483647 bytes</span><br><span class="line">  Texture alignment:                             512 bytes</span><br><span class="line">  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)</span><br><span class="line">  Run time <span class="built_in">limit</span> on kernels:                     No</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page-locked memory mapping:       Yes</span><br><span class="line">  Alignment requirement <span class="keyword">for</span> Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Enabled</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Device supports Managed Memory:                Yes</span><br><span class="line">  Device supports Compute Preemption:            Yes</span><br><span class="line">  Supports Cooperative Kernel Launch:            Yes</span><br><span class="line">  Supports MultiDevice Co-op Kernel Launch:      Yes</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   0 / 0 / 8</span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 11.1, CUDA Runtime Version = 11.1, NumDevs = 1</span><br><span class="line">Result = PASS</span><br></pre></td></tr></table></figure><p>到现在，<code>CUDA Toolkit</code> 安装完毕，接下来通过编写一个简单的 <code>hello world</code> 来直观感受 CUDA 编程：</p><figure class="highlight c"><figcaption><span>hello.cu</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">hello_from_gpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\"Hello, world!\", says the GPU.\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_from_cpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\"Hello, world!\", says the CPU.\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// host code entrance</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello_from_cpu();</span><br><span class="line">    hello_from_gpu &lt;&lt;&lt; <span class="number">2</span>, <span class="number">4</span>&gt;&gt;&gt;();</span><br><span class="line">    cudaDeviceReset();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，CUDA 程序基本上和标准 C 语言程序一样，主要的区别在于 <code>__global__</code> 限定词 和 <code>&lt;&lt;&lt;... &gt;&gt;&gt;</code> 符号。其中 <code>__global__</code> 标记用来告诉编译器这段代码会运行在 <strong>Device</strong>  （GPU）上，它会被运行在 <strong>Host</strong> 上的代码调用，也被称作是在 <strong>Device</strong> 上线程中并行执行的核函数（Kernel），是在 <strong>Device</strong> 上线程中并行执行的函数。</p><p>当一个核函数被调用时，需要通过 <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code> 符号 来设置核函数执行时的配置，在 CUDA 的术语中，这称作 <code>kernel lauch</code>，在后面我们将深入介绍这部分。</p><p><code>hello world</code> 程序写完，我们以 <code>hello.cu</code> 这样的后缀名来保存，接下来使用 <code>nvcc</code> 来编译，整体上用法与 <code>gcc</code> 几乎一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ nvcc hello.cu -o hello</span><br><span class="line">$./hello</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the CPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br><span class="line"><span class="string">"Hello, world!"</span>, says the GPU.</span><br></pre></td></tr></table></figure><p>可以看到，来自 CPU 的 <code>Hello World</code> 执行了一次，来自 GPU 的 <code>Hello World</code> 执行了8次。</p><h3 id="核函数与线程模型"><a href="#核函数与线程模型" class="headerlink" title="核函数与线程模型"></a>核函数与线程模型</h3><p>上文提到，为了实现 GPU 并行加速计算，我们需要在 <strong>Host</strong> 上执行 <code>kernel launch</code>，让 核函数 在 <strong>Device</strong> 上的多个线程并发执行。具体的方式就是在调用核函数的时候通过 <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code> 来指定核函数要执行的线程数量N，之后GPU上的N个Core会并行执行核函数，并且每个线程会分配一个唯一的线程号threadID，这个ID值可以通过核函数的内置变量<code>threadIdx</code>来获得。</p><p>CUDA将核函数所定义的运算称为<strong>线程（Thread）</strong>，多个线程组成一个<strong>块（Block）</strong>，多个块组成<strong>网格（Grid）</strong>。这样一个Grid可以定义成千上万个线程，也就解决了并行执行上万次操作的问题。 <code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code> 中括号中第一个数字表示整个Grid有多少个Block，括号中第二个数字表示一个Block有多少个Thread。前面 <code>Hello World</code> 用 2 个Block，每个Block中有4个Thread，所以总共执行了8次。</p><p><img alt="Grid of Thread Blocks" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-thread-hierarchy.png"></p><p>实际上，线程（Thread）是一个编程上的软件概念。从硬件来看，Thread运行在一个CUDA核心上，多个Thread组成的Block运行在Streaming Multiprocessor（SM），多个Block组成的Grid运行在一个GPU显卡上。当一个 <code>kernel</code> 被执行时，它的gird中的线程块被分配到SM上，<strong>一个线程块只能在一个SM上被调度</strong>。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个 <code>kernel</code> 的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-software-hardware-view.png"></p><p><code>grid</code> 和 <code>block</code>都是定义为<code>dim3</code>类型的变量，<code>dim3</code>可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此 <code>grid</code> 和 <code>block</code> 可以灵活地定义为 <code>1-dim</code>，<code>2-dim</code> 以及<code>3-dim</code> 结构，对于上图中结构（主要水平方向为x轴），定义的 <code>grid</code>和 <code>block</code> 如下所示， <code>kernel</code> 在调用时也必须通过<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#execution-configuration" target="_blank" rel="external nofollow noopener noreferrer">执行配置</a><code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定 <code>kernel</code> 所使用的线程数及结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure><p>所以，一个线程需要两个内置的坐标变量<code>（blockIdx，threadIdx）</code>来唯一标识，它们都是<code>dim3</code>类型变量，其中blockIdx指明线程所在grid中的位置，而threaIdx指明线程所在block中的位置，如图中的 <code>Thread (1,1)</code> 满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadIdx.x &#x3D; 1</span><br><span class="line">threadIdx.y &#x3D; 1</span><br><span class="line">blockIdx.x &#x3D; 1</span><br><span class="line">blockIdx.y &#x3D; 1</span><br></pre></td></tr></table></figure><p>不同的执行配置会影响GPU程序的速度，一般需要多次调试才能找到较好的执行配置，在实际编程中，执行配置<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>应参考下面的方法：</p><ul><li>Block运行在SM上，不同硬件架构（Turing、Volta、Pascal…）的CUDA核心数不同，一般需要根据当前硬件来设置Block的大小<code>block</code>（执行配置中第二个参数）。一个Block中的Thread数最好是32、128、256的倍数。注意，限于当前硬件的设计，Block大小不能超过1024。</li><li>Grid的大小<code>grid</code>（执行配置中第一个参数），即一个Grid中Block的个数可以由总次数<code>N</code>除以<code>block</code>，并向上取整。</li></ul><p>例如，我们想并行启动1000个Thread，可以将blockDim设置为128，<code>1000 ÷ 128 = 7.8</code>，向上取整为8。使用时，执行配置可以写成<code>gpuWork&lt;&lt;&lt;8, 128&gt;&gt;&gt;()</code>，CUDA共启动<code>8 * 128 = 1024</code>个Thread，实际计算时只使用前1000个Thread，多余的24个Thread不进行计算。</p> <div class="note info">            <p>这几个变量比较容易混淆，再次明确一下：<code>block</code>是Block中Thread的个数，一个Block中的<code>threadIdx</code>最大不超过<code>block</code>；<code>grid</code>是Grid中Block的个数，一个Grid中的<code>blockIdx</code>最大不超过<code>grid</code>。</p>          </div><p>这几个变量比较容易混淆，再次明确一下：<code>block</code>是Block中Thread的个数，一个Block中的<code>threadIdx</code>最大不超过<code>block</code>；<code>grid</code>是Grid中Block的个数，一个Grid中的<code>blockIdx</code>最大不超过<code>grid</code>。</p><p> <code>kernel</code> 的这种线程组织结构天然适合vector，matrix等运算，我们将在后面实现向量加法和矩阵乘法。如我们将利用上图2-dim结构实现两个矩阵的加法，每个线程负责处理每个位置的两个元素相加，代码如下所示。线程块大小为(16, 16)，然后将 $ N*N $ 大小的矩阵均分为不同的线程块来执行加法运算。</p><p>SM采用的是<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#simt-architecture" target="_blank" rel="external nofollow noopener noreferrer">SIMT</a> (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是 <strong>线程束（wraps)</strong>，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。</p><p>当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。<code>(16, 16)</code>的二维Block是一个常用的配置，共256个线程。之前也曾提到过，每个Block的Thread个数最好是128、256或512，这与GPU的硬件架构高度相关。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kernel定义</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; j &lt; N) </span><br><span class="line">        C[i][j] = A[i][j] + B[i][j]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Kernel 线程配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>; </span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span><br><span class="line">    <span class="comment">// kernel调用</span></span><br><span class="line">    MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程块中的线程数是有限制的，现代GPUs的线程块可支持的线程数可达1024个。有时候，我们要知道一个线程在 <code>blcok</code> 中的全局ID，此时就必须还要知道 <code>block</code> 的组织结构，这是通过线程的内置变量 <code>blockDim</code>来获得。它获取线程块各个维度的大小。</p><ul><li>对于一个 <code>2-dim</code> 的block $ (D_x, D_y) $ ，线程  $ (x, y) $ 的ID值为 $ (x + y * D_x) $ </li><li>对于一个<code>3-dim</code> 的block  $ (D_x, D_y, D_z) $，线程 $(x, y, z)$  的ID值为 $ (x + y <em> D_z + z </em> D_z * D_y) $  </li></ul><p>另外线程还有内置变量 <code>gridDim</code>，用于获得网格块各个维度的大小。</p><h3 id="内存模型与管理"><a href="#内存模型与管理" class="headerlink" title="内存模型与管理"></a>内存模型与管理</h3><p>此外这里简单介绍一下CUDA的内存模型，如下图所示。可以看到，</p><ul><li>每个 <strong>Thread</strong> 有自己的私有本地内存（Local Memory）</li><li>每个 <strong>Block</strong> 有包含共享内存（Shared Memory），可以被线程块中所有线程共享，其生命周期与线程块一致</li><li>所有的 <strong>Thread</strong>  都可以访问全局内存（Global Memory）</li><li>访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）</li><li>L1 Cache，L2 Cache</li></ul><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-memory-sm.png"></div><div class="group-picture-column" style="width: 50%;"><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-memory-model.jpg"></div></div></div></div><p>下面简单介绍一下CUDA编程中内存管理常用的API。首先是在 <strong>Device</strong> 上分配内存的 <code>cudaMalloc</code> 、<code>cudaFree</code> 和 <code>cudaMemcpy</code>函数，分别对应C语言中的 <code>malloc</code>、<code>free</code>和 <code>memcpy</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Device 上申请一定字节大小的显存，其中 `devPtr` 是指向所分配内存的指针</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="keyword">void</span>** devPtr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Device 上释放一定大小的现存， `devPtr` 是指向所释放内存的指针</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaFree</span><span class="params">(<span class="keyword">void</span>* devPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责 Host 和 Device 之间数据通信，src指向数据源，dst是目标区域，count是复制的字节数，kind控制复制的方向</span></span><br><span class="line"><span class="comment">// 这里的 kind 有四种类型：</span></span><br><span class="line"><span class="comment">// - cudaMemcpyHostToHost</span></span><br><span class="line"><span class="comment">// - cudaMemcpyHostToDevice</span></span><br><span class="line"><span class="comment">// - cudaMemcpyDeviceToHost</span></span><br><span class="line"><span class="comment">// - cudaMemcpyDeviceToDevice</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count, cudaMemcpyKind kind)</span></span></span><br></pre></td></tr></table></figure><h2 id="CUDA-编程实战"><a href="#CUDA-编程实战" class="headerlink" title="CUDA 编程实战"></a>CUDA 编程实战</h2><p>知道了CUDA编程基础，接下来我们以两个向量的加法为例，介绍如何利用CUDA编程来实现GPU加速计算。</p><h3 id="CPU-向量加法：传统计算方法"><a href="#CPU-向量加法：传统计算方法" class="headerlink" title="CPU 向量加法：传统计算方法"></a>CPU 向量加法：传统计算方法</h3><p>我们首先来看利用 CPU 来计算向量加法该如何编程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize array</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main function</span></span><br><span class="line">    vector_add(out, a, b, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out[0] = %f\n"</span>, out[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-向量加法：一个Block一个Thread"><a href="#GPU-向量加法：一个Block一个Thread" class="headerlink" title="GPU 向量加法：一个Block一个Thread"></a>GPU 向量加法：一个Block一个Thread</h3><p>我们将 CPU 的向量加法转换成 CUDA 程序，使用 GPU 来计算，下面这段代码演示了如何使用 CUDA 编程规范来编写程序。实际上仍然只是使用一个 <code>core</code> 来进行计算，不仅没有提高并行度，反而还增加了数据拷贝的成本，显然相比原来的计算是会更慢的，这里主要作为演示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out;</span><br><span class="line">    <span class="keyword">float</span> *d_a, *d_b, *d_out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate host memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device memory</span></span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer data from host to device memory</span></span><br><span class="line">    cudaMemcpy(d_a, a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_b, b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    vector_add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer data back to host memory</span></span><br><span class="line">    cudaMemcpy(out, d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate device memory</span></span><br><span class="line">    cudaFree(d_a);</span><br><span class="line">    cudaFree(d_b);</span><br><span class="line">    cudaFree(d_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate host memory</span></span><br><span class="line">    <span class="built_in">free</span>(a); </span><br><span class="line">    <span class="built_in">free</span>(b); </span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-向量加法：一个Block多个Thread"><a href="#GPU-向量加法：一个Block多个Thread" class="headerlink" title="GPU 向量加法：一个Block多个Thread"></a>GPU 向量加法：一个Block多个Thread</h3><p>为了提高并行度，我们设置一个 <code>Block</code> 多个 <code>Thread</code> 同时进行计算，如下图所示总共有256个<code>Thread</code>，每个 Thread 负责处理 Vector 中的一部分。每一次迭代中，256个Thread分别计算 Vector 的这256个数，然后在下一次迭代中每个Thread往后推进256个数，继续计算。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-parallel_thread.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = threadIdx.x;</span><br><span class="line">    <span class="keyword">int</span> stride = blockDim.x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; n; i += stride)&#123;</span><br><span class="line">        out[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out;</span><br><span class="line">    <span class="keyword">float</span> *d_a, *d_b, *d_out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate host memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device memory </span></span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer data from host to device memory</span></span><br><span class="line">    cudaMemcpy(d_a, a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_b, b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    vector_add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">256</span>&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer data back to host memory</span></span><br><span class="line">    cudaMemcpy(out, d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate device memory</span></span><br><span class="line">    cudaFree(d_a);</span><br><span class="line">    cudaFree(d_b);</span><br><span class="line">    cudaFree(d_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate host memory</span></span><br><span class="line">    <span class="built_in">free</span>(a); </span><br><span class="line">    <span class="built_in">free</span>(b); </span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 CPU 程序，这里的并行度显著提高，GPU 计算的时间也大大减小。</p><h3 id="GPU-向量加法：多个Block多个Thread"><a href="#GPU-向量加法：多个Block多个Thread" class="headerlink" title="GPU 向量加法：多个Block多个Thread"></a>GPU 向量加法：多个Block多个Thread</h3><p>在上一个方案中，我们的256个Thread仍然需要计算多个数字，如果我们将并行度继续扩大，让每个Thread只需要计算Vector中的一个数，那么计算消耗时间将会更短。如下图所示，我们使用多个Block多个Thread，其中每个Block还是256个Thread，但是我们现在的Grid有多个Block，Block数字由Vector的长度除以BlockSize得到。</p><p><img alt data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-21_cuda-parallel_block.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handling arbitrary vector size</span></span><br><span class="line">    <span class="keyword">if</span> (tid &lt; n)&#123;</span><br><span class="line">        out[tid] = a[tid] + b[tid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *a, *b, *out;</span><br><span class="line">    <span class="keyword">float</span> *d_a, *d_b, *d_out; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate host memory</span></span><br><span class="line">    a   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    b   = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    out = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate device memory </span></span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer data from host to device memory</span></span><br><span class="line">    cudaMemcpy(d_a, a, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_b, b, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    <span class="keyword">int</span> block_size = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> grid_size = ((N + block_size - <span class="number">1</span>) / block_size);</span><br><span class="line">    vector_add&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;(d_out, d_a, d_b, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Transfer data back to host memory</span></span><br><span class="line">    cudaMemcpy(out, d_out, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate device memory</span></span><br><span class="line">    cudaFree(d_a);</span><br><span class="line">    cudaFree(d_b);</span><br><span class="line">    cudaFree(d_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate host memory</span></span><br><span class="line">    <span class="built_in">free</span>(a); </span><br><span class="line">    <span class="built_in">free</span>(b); </span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPU-向量加法：Unified-Memory"><a href="#GPU-向量加法：Unified-Memory" class="headerlink" title="GPU 向量加法：Unified Memory"></a>GPU 向量加法：Unified Memory</h3><p>在上面的实现中，我们需要单独在 <strong>Host</strong> 和 <strong>Device</strong> 上进行内存分配，并且要进行数据拷贝，这是很容易出错的。好在CUDA 6.0引入统一内存（<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-unified-memory-programming-hd" target="_blank" rel="external nofollow noopener noreferrer">Unified Memory</a>）来避免这种麻烦，简单来说就是统一内存使用一个托管内存来共同管理 <strong>Host</strong> 和 <strong>Device</strong> 中的内存，并且自动在 <strong>Host</strong> 和 <strong>Device</strong> 中进行数据传输。CUDA中使用cudaMallocManaged函数分配托管内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocManaged</span><span class="params">(<span class="keyword">void</span> **devPtr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>利用统一内存，可以将上面的程序简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERR 1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span> *out, <span class="keyword">float</span> *a, <span class="keyword">float</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Handling arbitrary vector size</span></span><br><span class="line">    <span class="keyword">if</span> (tid &lt; n)&#123;</span><br><span class="line">        out[tid] = a[tid] + b[tid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Allocate managed memory</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;y, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;z, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize host arrays</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        x[i] = <span class="number">1.0f</span>;</span><br><span class="line">        y[i] = <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executing kernel </span></span><br><span class="line">    <span class="keyword">int</span> block_size = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> grid_size = ((N + block_size - <span class="number">1</span>) / block_size);</span><br><span class="line">    vector_add&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;(z, x, y, N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步 Device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Verification</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        assert(<span class="built_in">fabs</span>(out[i] - a[i] - b[i]) &lt; MAX_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate managed memory</span></span><br><span class="line">    cudaFree(x);</span><br><span class="line">    cudaFree(y);</span><br><span class="line">    cudaFree(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之前的代码，使用统一内存更简洁了，值得注意的是 <code>kernel</code> 执行是与 <strong>Host</strong> 异步的，由于托管内存自动进行数据传输，这里要用<code>cudaDeviceSynchronize()</code> 函数保证 <strong>Device</strong> 和 <strong>Host</strong> 同步，这样后面才可以正确访问 <code>kernel</code> 计算的结果。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://download.nvidia.com/developer/cuda/seminar/TDCI_Arch.pdf" target="_blank" rel="external nofollow noopener noreferrer">An Introduction to Modern GPU Architecture</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html" target="_blank" rel="external nofollow noopener noreferrer">NVIDIA CUDA 编程模型官方文档</a></li><li><a href="https://github.com/huiscliu/Tutorials/tree/master/CUDA编程入门" target="_blank" rel="external nofollow noopener noreferrer">CUDA编程入门</a></li><li><a href="http://www.mat.unimi.it/users/sansotte/cuda/CUDA_by_Example.pdf" target="_blank" rel="external nofollow noopener noreferrer">CUDA By Example</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着近年来深度学习的爆发，原来被用于图形渲染的GPU被大量用于并行加速深度学习的模型训练中，在这个过程中 CUDA 作为 NVIDIA 推出的基于GPU的一个通用并行计算平台和编程模型也得到了广泛的使用。或许你已经十分了解 &lt;a href=&quot;../b893097a/&quot;&gt;现代CPU的体系架构&lt;/a&gt;，但是对于GPU还不甚清晰，GPU的体系架构到底和CPU有何区别，CUDA模型是什么，我们该如何使用 CUDA实现并行计算，本文将为你扫盲祛魅，本文中使用到的所有代码可以在我的 &lt;a href=&quot;https://github.com/SimpCosm/cuda-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Github&lt;/a&gt; 中找到。&lt;/p&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-20_nvidia-tesla-v100.png" type="image" />
    
    
      <category term="术业专攻" scheme="http://houmin.cc/categories/%E6%9C%AF%E4%B8%9A%E4%B8%93%E6%94%BB/"/>
    
    
      <category term="GPU" scheme="http://houmin.cc/tags/GPU/"/>
    
      <category term="CUDA" scheme="http://houmin.cc/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>The Social Dilemma</title>
    <link href="http://houmin.cc/posts/b86144be/"/>
    <id>http://houmin.cc/posts/b86144be/</id>
    <published>2020-11-14T10:39:02.000Z</published>
    <updated>2020-11-26T13:10:59.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Back on track，本周继续「朝花夕拾」的定期发布，这里是今年的第二十四期「The Social Dilemma」，标题来自最新 Netflix 推出的一个剧情式纪录片。本期会简单聊聊社交困境，除了纪录片所涵盖的内容，还包括自己从字面上对其的漫无边际的延伸思考。</p>    <div id="aplayer-dtUlbdWq" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="446874778" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><a id="more"></a><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>这周末出去和高中同学KM一起吃了顿饭，跟进了同学间的动态，最大的感慨就是，班上有几个同学自从高中毕业之后就如同人间蒸发了一半，再也没有消息。北京有雾霾了，没有太出去拍照，自己在家做饭看剧。嗯，我越来越喜欢吃意大利面了，真香。</p><p>继续看数据，首先是Rescue Time：</p><ul><li>工作日的ScreenTime依旧是9个小时左右，其中周三因为公司消防演练降低了很多，周五因为一些事情走的比较早，此处不表</li><li>具体到实际每个应用，可以看到企业微信是软件开发以外占据时间最多的，这个感觉可以具体到某个时间来处理，避免每次进入到状态的时候被打断</li><li>周末的时间就很分散，现在对于周末的一个感觉就是时间太短，本来很多想做的事情都没有做完（比如这次的朝花夕拾）</li></ul><p><img alt="Rescue Time" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-15_rescue-time.png"></p><p>还是希望自己的时间使用能够更专注更有效，不喜欢那种漫无目的的刷，下周继续观察。</p><p>时间方面谷歌日历已经可以做到每天具体的时间分配在什么事项上，但是每天的总结还是欠缺，下周开始补上。接下来是Forest专注时间观察，</p><p><img alt="Forest - Nov 8 ~ Nov 14, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_forest.jpg"></p><p>这周加入一个新的观察维度，那就是健身数据，目前我的健身行为比较单一，就暂且以跑步的数字作为衡量。是的，在年初的时候，我给自己定下的目标是700公里，今年实际完成度很低。以年为单位总是会让人松懈，本周开始加入每周的跑步数据观察：</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img alt="Running Records" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_year-running.jpg"></div><div class="group-picture-column" style="width: 50%;"><img alt="Running - Nov 8 ~ Nov 14, 2020" data-src="https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-14_running.jpg"></div></div></div></div><p>这里还希望加入的一个观察数据是睡眠时间，前一周看每天的上班时间，经常性的9点才出门，早上不想起来，晚上也睡的很晚。为了改善这个方面，继续立Flag。</p><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><h3 id="反垄断法"><a href="#反垄断法" class="headerlink" title="反垄断法"></a>反垄断法</h3><p>背景：11月10日上午，国家市场监管总局发布《关于平台经济领域的反垄断指南（征求意见稿）》公开征求意见，目的是为预防和制止平台经济领域垄断行为，加强和改进平台经济领域反垄断监管，保护市场公平竞争，维护消费者利益和社会公共利益。指南发布后，阿里、美团、腾讯、京东等企业股价大跌。</p><p>分析：中国互联网野蛮生长了二十年，终于发展到现在足以影响到每一个人的体量。互联网企业作为平台型企业，做大之后开始从各个环节抽佣。另一方面，电商平台的二选一，社交平台的链接封杀，都引起了众多争议。这一次的反垄断指南，从某个方面反映了政府监管部门对于大平台问题的重视。但是，毕竟是平台型企业，反垄断指南能够执行到何种程度仍然值得观望，股价该回来还是会回来的。</p><h3 id="荣耀拆分出售"><a href="#荣耀拆分出售" class="headerlink" title="荣耀拆分出售"></a>荣耀拆分出售</h3><p>背景：荣耀拆分出售从最早的传闻到现越来越像真的了。本次传闻：根据去年荣耀60亿元利润，16倍PE来定，约为1000亿人民币，<strong>收购方包括神州数码、三家国资机构，以及TCL等公司组成的小股东阵营</strong>。拆分的缘由还是美国封杀，若华为分拆或出售荣耀手机，荣耀手机的采购零部件不受美国的华为禁令限制，将有助荣耀手机业务与供货商增长，这对荣耀品牌、供货商以及大陆电子业都是多赢局面。</p><p>分析：拜登当选，美国封杀令是否仍会继续？如果不再继续，华为是否能够凤凰涅槃，继续关注。</p><h3 id="Mac换芯"><a href="#Mac换芯" class="headerlink" title="Mac换芯"></a>Mac换芯</h3><p>背景：苹果发布M1芯片，宣布笔记本等产品线将从Intel芯片切换到基于ARM自研的M1芯片。</p><p>分析：从最早的PowerPC，到现在的M1，苹果软硬件一体的初心依然不变。这当然得益于其开创的软硬件生态，也是因为牙膏厂最年来牙膏越来越难挤了。关于M1具体细节尚未研究，不过毕竟是新体系下的第一款芯片，仍然需要时间打磨，现在的主要卖点应该还是功耗。</p><h3 id="辉瑞疫苗"><a href="#辉瑞疫苗" class="headerlink" title="辉瑞疫苗"></a>辉瑞疫苗</h3><p>背景：美国辉瑞制药和德国BioNTech在美股盘前宣布了其合作新冠疫苗的三期临床实验的首批结果，显示其有效性超过90%。受这一消息影响，欧美股市突然暴涨，道指期货涨逾5%，欧洲三大股指全线拉升，与此同时，随着全球风险偏好回升，美元、黄金等避险资产大幅下挫。</p><p>分析：疫苗才是真正的群体免疫。但是疫苗是否能够应对新冠病毒变异，是否最后真正有效，还需要继续观察，至少这个冬天应该还用不了。</p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>本期主题是「The Social Dilemma」，主题就是讲述了互联网公司通过获取用户数据，通过社交媒体来影响用户的事情。</p><p>这并不是一个新话题，早在年初的时候我就在 <a href="../3e030bdb/">Carpe Diem</a> 里面简单讨论过这个话题。正如那句话，羊毛出在猪身上，互联网用户享受的免费便捷的互联网产品是由广告厂商们为之付费的。互联网用户并不是大厂们的客户，广告商才是。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Back on track，本周继续「朝花夕拾」的定期发布，这里是今年的第二十四期「The Social Dilemma」，标题来自最新 Netflix 推出的一个剧情式纪录片。本期会简单聊聊社交困境，除了纪录片所涵盖的内容，还包括自己从字面上对其的漫无边际的延伸思考。&lt;/p&gt;

    &lt;div id=&quot;aplayer-dtUlbdWq&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;446874778&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    <content src="http://houmin.cc/https://cosmos-1251905798.cos.ap-beijing.myqcloud.com/blog/2020-11-07_winter-bulrush.png" type="image" />
    
    
      <category term="朝花夕拾" scheme="http://houmin.cc/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="反垄断" scheme="http://houmin.cc/tags/%E5%8F%8D%E5%9E%84%E6%96%AD/"/>
    
      <category term="surveillance capitalism" scheme="http://houmin.cc/tags/surveillance-capitalism/"/>
    
      <category term="平台" scheme="http://houmin.cc/tags/%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
</feed>
